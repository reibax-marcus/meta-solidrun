From 5fa525037026ffe3ed23da6ccb2f1e595843c7ac Mon Sep 17 00:00:00 2001
From: Grzegorz Jaszczyk <jaz@semihalf.com>
Date: Fri, 31 Aug 2018 10:55:38 +0200
Subject: [PATCH 0036/1239] phy: marvell: a3700: let the firmware configure the
 phy

Serdes lanes configuration are now available via SiP services in
firmware (firmware comphy driver exposes it's API via RT service).
Therefore take advantage and replace all comphy initialization with
appropriate SMC calls.

Change-Id: I81d66ba1b130cccd4bbc4388774e0a6e2b4d0972
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-by: Igal Liberman <igall@marvell.com>
---
 drivers/phy/marvell/Makefile       |   1 -
 drivers/phy/marvell/comphy_a3700.c | 868 +++++------------------------
 drivers/phy/marvell/comphy_a3700.h | 175 +-----
 drivers/phy/marvell/comphy_core.h  |  11 -
 drivers/phy/marvell/comphy_mux.c   | 134 -----
 5 files changed, 151 insertions(+), 1038 deletions(-)
 delete mode 100644 drivers/phy/marvell/comphy_mux.c

diff --git a/drivers/phy/marvell/Makefile b/drivers/phy/marvell/Makefile
index 51be0399ea..a5c28fe12e 100644
--- a/drivers/phy/marvell/Makefile
+++ b/drivers/phy/marvell/Makefile
@@ -1,6 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0+
 
 obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_core.o
-obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_mux.o
 obj-$(CONFIG_ARMADA_3700) += comphy_a3700.o
 obj-$(CONFIG_ARMADA_8K) += comphy_cp110.o
diff --git a/drivers/phy/marvell/comphy_a3700.c b/drivers/phy/marvell/comphy_a3700.c
index fc70d7428f..b1b0b47e49 100644
--- a/drivers/phy/marvell/comphy_a3700.c
+++ b/drivers/phy/marvell/comphy_a3700.c
@@ -13,135 +13,53 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct comphy_mux_data a3700_comphy_mux_data[] = {
-/* Lane 0 */
-	{
-		4,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0 },
-			{ PHY_TYPE_SGMII1,	0x0 },
-			{ PHY_TYPE_USB3_HOST0,	0x1 },
-			{ PHY_TYPE_USB3_DEVICE,	0x1 }
-		}
-	},
-/* Lane 1 */
-	{
-		3,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0},
-			{ PHY_TYPE_SGMII0,	0x0},
-			{ PHY_TYPE_PEX0,	0x1}
-		}
-	},
-/* Lane 2 */
-	{
-		4,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0},
-			{ PHY_TYPE_SATA0,	0x0},
-			{ PHY_TYPE_USB3_HOST0,	0x1},
-			{ PHY_TYPE_USB3_DEVICE,	0x1}
-		}
-	},
-};
-
-struct sgmii_phy_init_data_fix {
-	u16 addr;
-	u16 value;
-};
-
-/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
-static struct sgmii_phy_init_data_fix sgmii_phy_init_fix[] = {
-	{0x005, 0x07CC}, {0x015, 0x0000}, {0x01B, 0x0000}, {0x01D, 0x0000},
-	{0x01E, 0x0000}, {0x01F, 0x0000}, {0x020, 0x0000}, {0x021, 0x0030},
-	{0x026, 0x0888}, {0x04D, 0x0152}, {0x04F, 0xA020}, {0x050, 0x07CC},
-	{0x053, 0xE9CA}, {0x055, 0xBD97}, {0x071, 0x3015}, {0x076, 0x03AA},
-	{0x07C, 0x0FDF}, {0x0C2, 0x3030}, {0x0C3, 0x8000}, {0x0E2, 0x5550},
-	{0x0E3, 0x12A4}, {0x0E4, 0x7D00}, {0x0E6, 0x0C83}, {0x101, 0xFCC0},
-	{0x104, 0x0C10}
-};
-
-/* 40M1G25 mode init data */
-static u16 sgmii_phy_init[512] = {
-	/* 0       1       2       3       4       5       6       7 */
-	/*-----------------------------------------------------------*/
-	/* 8       9       A       B       C       D       E       F */
-	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,	/* 00 */
-	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,	/* 08 */
-	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,	/* 10 */
-	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,	/* 18 */
-	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,	/* 20 */
-	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,	/* 28 */
-	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* 30 */
-	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,	/* 38 */
-	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,	/* 40 */
-	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,	/* 48 */
-	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,	/* 50 */
-	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,	/* 58 */
-	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,	/* 60 */
-	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,	/* 68 */
-	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,	/* 70 */
-	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,	/* 78 */
-	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,	/* 80 */
-	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,	/* 88 */
-	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,	/* 90 */
-	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,	/* 98 */
-	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,	/* A0 */
-	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* B0 */
-	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,	/* B8 */
-	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,	/* C0 */
-	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,	/* C8 */
-	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,	/* D0 */
-	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,	/* D8 */
-	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,	/* E0 */
-	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,	/* E8 */
-	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,	/* F0 */
-	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,	/* F8 */
-	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,	/*100 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*108 */
-	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,	/*110 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*118 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*120 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*128 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*130 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*138 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*140 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*148 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*150 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*158 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*160 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*168 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*170 */
-	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,	/*178 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*180 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*188 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*190 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*198 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1F0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000	/*1F8 */
-};
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+
+#define COMPHY_FW_MODE_FORMAT(mode, invert)	((mode) << 12 | (invert) << 0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
+#define A3700_LANE_MAX_NUM	3
+
+static int comphy_smc(u32 function_id, u32 lane, u32 mode)
+{
+#ifndef CONFIG_MVEBU_PALLADIUM
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = lane;
+	pregs.regs[2] = mode;
+
+	smc_call(&pregs);
+
+	return pregs.regs[0];
+#else
+	return 1;
+#endif
+}
 
 /*
  * comphy_poll_reg
  *
  * return: 1 on success, 0 on timeout
  */
-static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u8 op_type)
+static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout,
+			   u8 op_type)
 {
-	u32 rval = 0xDEAD, timeout;
+	u32 rval = 0xDEAD;
 
-	for (timeout = PLL_LOCK_TIMEOUT; timeout > 0; timeout--) {
+	for (; timeout > 0; timeout--) {
 		if (op_type == POLL_16B_REG)
 			rval = readw(addr);	/* 16 bit */
 		else
@@ -157,367 +75,72 @@ static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u8 op_type)
 	return 0;
 }
 
-/*
- * comphy_pcie_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
- */
-static int comphy_pcie_power_up(u32 speed, u32 invert)
-{
-	int ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Enable max PLL.
-	 */
-	reg_set16(phy_addr(PCIE, LANE_CFG1), bf_use_max_pll_rate, 0);
-
-	/*
-	 * 2. Select 20 bit SERDES interface.
-	 */
-	reg_set16(phy_addr(PCIE, GLOB_CLK_SRC_LO), bf_cfg_sel_20b, 0);
-
-	/*
-	 * 3. Force to use reg setting for PCIe mode
-	 */
-	reg_set16(phy_addr(PCIE, MISC_REG1), bf_sel_bits_pcie_force, 0);
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16(phy_addr(PCIE, PWR_MGM_TIM1), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16(phy_addr(PCIE, UNIT_CTRL), 0x60 | rb_idle_sync_en, 0xFFFF);
-
-	/*
-	 * 6. Enable the output of 100M/125M/500M clock
-	 */
-	reg_set16(phy_addr(PCIE, MISC_REG0),
-		  0xA00D | rb_clk500m_en | rb_clk100m_125m_en, 0xFFFF);
-
-	/*
-	 * 7. Enable TX
-	 */
-	reg_set(PCIE_REF_CLK_ADDR, 0x1342, 0xFFFFFFFF);
-
-	/*
-	 * 8. Check crystal jumper setting and program the Power and PLL
-	 *    Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		reg_set16(phy_addr(PCIE, PWR_PLL_CTRL), 0xFC63, 0xFFFF);
-	} else {
-		/* 25 MHz */
-		reg_set16(phy_addr(PCIE, PWR_PLL_CTRL), 0xFC62, 0xFFFF);
-	}
-
-	/*
-	 * 9. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16(phy_addr(PCIE, KVCO_CAL_CTRL), 0x0040 | rb_use_max_pll_rate,
-		  0xFFFF);
-
-	/*
-	 * 10. Check the Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT)
-		reg_set16(phy_addr(PCIE, SYNC_PATTERN), phy_txd_inv, 0);
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT)
-		reg_set16(phy_addr(PCIE, SYNC_PATTERN), phy_rxd_inv, 0);
-
-	/*
-	 * 11. Release SW reset
-	 */
-	reg_set16(phy_addr(PCIE, GLOB_PHY_CTRL0),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32,
-		  bf_soft_rst | bf_mode_refdiv);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg(phy_addr(PCIE, LANE_STAT1),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      POLL_16B_REG);			/* 16bit */
-	if (!ret)
-		printf("Failed to lock PCIe PLL\n");
-
-	debug_exit();
-
-	/* Return the status of the PLL */
-	return ret;
-}
-
-/*
- * reg_set_indirect
- *
- * return: void
- */
-static void reg_set_indirect(u32 reg, u16 data, u16 mask)
-{
-	reg_set(rh_vsreg_addr, reg, 0xFFFFFFFF);
-	reg_set(rh_vsreg_data, data, mask);
-}
-
 /*
  * comphy_sata_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_sata_power_up(void)
+static int comphy_sata_power_up(u32 invert, u32 lane)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
 	/*
-	 * 0. Swap SATA TX lines
-	 */
-	reg_set_indirect(vphy_sync_pattern_reg, bs_txd_inv, bs_txd_inv);
-
-	/*
-	 * 1. Select 40-bit data width width
-	 */
-	reg_set_indirect(vphy_loopback_reg0, 0x800, bs_phyintf_40bit);
-
-	/*
-	 * 2. Select reference clock and PHY mode (SATA)
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		reg_set_indirect(vphy_power_reg0, 0x3, 0x00FF);
-	} else {
-		/* 20 MHz */
-		reg_set_indirect(vphy_power_reg0, 0x1, 0x00FF);
-	}
-
-	/*
-	 * 3. Use maximum PLL rate (no power save)
+	 * Set vendor-specific configuration (??).
+	 * It was done in the middle of comphy initialization but test shows
+	 * that moving it before strict comphy init works ok. Thanks to that the
+	 * comphy init can be done with pure comphy range access, not touching
+	 * ahci range.
 	 */
-	reg_set_indirect(vphy_calctl_reg, bs_max_pll_rate, bs_max_pll_rate);
+	reg_set((void __iomem *)rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
+	reg_set((void __iomem *)rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
 
-	/*
-	 * 4. Reset reserved bit (??)
-	 */
-	reg_set_indirect(vphy_reserve_reg, 0, bs_phyctrl_frm_pin);
-
-	/*
-	 * 5. Set vendor-specific configuration (??)
-	 */
-	reg_set(rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
-	reg_set(rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
-
-	/* Wait for > 55 us to allow PLL be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert SATA PLL enabled */
-	reg_set(rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	ret = comphy_poll_reg(rh_vsreg_data,	/* address */
-			      bs_pll_ready_tx,	/* value */
-			      bs_pll_ready_tx,	/* mask */
-			      POLL_32B_REG);	/* 32bit */
-	if (!ret)
-		printf("Failed to lock SATA PLL\n");
-
-	debug_exit();
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE, invert));
 
 	return ret;
 }
 
-/*
- * usb3_reg_set16
- *
- * return: void
- */
-static void usb3_reg_set16(u32 reg, u16 data, u16 mask, u32 lane)
-{
-	/*
-	 * When Lane 2 PHY is for USB3, access the PHY registers
-	 * through indirect Address and Data registers INDIR_ACC_PHY_ADDR
-	 * (RD00E0178h [31:0]) and INDIR_ACC_PHY_DATA (RD00E017Ch [31:0])
-	 * within the SATA Host Controller registers, Lane 2 base register
-	 * offset is 0x200
-	 */
-
-	if (lane == 2)
-		reg_set_indirect(USB3PHY_LANE2_REG_BASE_OFFSET + reg, data,
-				 mask);
-	else
-		reg_set16(phy_addr(USB3, reg), data, mask);
-}
-
 /*
  * comphy_usb3_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_usb3_power_up(u32 lane, u32 type, u32 speed, u32 invert)
+static int comphy_usb3_power_up(u32 speed, u32 invert, u32 lane,
+				bool indirect_reg_access)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
 	/*
 	 * 1. Power up OTG module
 	 */
-	reg_set(USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+	reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
 
 	/*
 	 * 2. Set counter for 100us pulse in USB3 Host and Device
 	 * restore default burst size limit (Reference Clock 31:24)
 	 */
-	reg_set(USB3_CTRPUL_VAL_REG, 0x8 << 24, rb_usb3_ctr_100ns);
+	reg_set((void __iomem *)USB3_CTRPUL_VAL_REG,
+		0x8 << 24, rb_usb3_ctr_100ns);
 
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_USB3_MODE, invert));
 
-	/* 0xd005c300 = 0x1001 */
-	/* set PRD_TXDEEMPH (3.5db de-emph) */
-	usb3_reg_set16(LANE_CFG0, 0x1, 0xFF, lane);
-
-	/*
-	 * Set BIT0: enable transmitter in high impedance mode
-	 * Set BIT[3:4]: delay 2 clock cycles for HiZ off latency
-	 * Set BIT6: Tx detect Rx at HiZ mode
-	 * Unset BIT15: set to 0 to set USB3 De-emphasize level to -3.5db
-	 *              together with bit 0 of COMPHY_REG_LANE_CFG0_ADDR
-	 *              register
-	 */
-	usb3_reg_set16(LANE_CFG1,
-		       tx_det_rx_mode | gen2_tx_data_dly_deft
-		       | tx_elec_idle_mode_en,
-		       prd_txdeemph1_mask | tx_det_rx_mode
-		       | gen2_tx_data_dly_mask | tx_elec_idle_mode_en, lane);
-
-	/* 0xd005c310 = 0x93: set Spread Spectrum Clock Enabled */
-	usb3_reg_set16(LANE_CFG4, bf_spread_spectrum_clock_en, 0x80, lane);
-
-	/*
-	 * set Override Margining Controls From the MAC: Use margining signals
-	 * from lane configuration
-	 */
-	usb3_reg_set16(TEST_MODE_CTRL, rb_mode_margin_override, 0xFFFF, lane);
-
-	/* set Lane-to-Lane Bundle Clock Sampling Period = per PCLK cycles */
-	/* set Mode Clock Source = PCLK is generated from REFCLK */
-	usb3_reg_set16(GLOB_CLK_SRC_LO, 0x0, 0xFF, lane);
-
-	/* set G2 Spread Spectrum Clock Amplitude at 4K */
-	usb3_reg_set16(GEN2_SETTINGS_2, g2_tx_ssc_amp, 0xF000, lane);
-
-	/*
-	 * unset G3 Spread Spectrum Clock Amplitude & set G3 TX and RX Register
-	 * Master Current Select
+	/* No matter host mode and device mode, it works with Hard ID detection
+	 * Unset DP and DM pulldown for USB2 Device mode
 	 */
-	usb3_reg_set16(GEN2_SETTINGS_3, 0x0, 0xFFFF, lane);
+	reg_set((void __iomem *)USB2_OTG_PHY_CTRL_ADDR, 0x0,
+		rb_usb2_dp_pulldn_dev_mode | rb_usb2_dm_pulldn_dev_mode);
 
-	/*
-	 * 3. Check crystal jumper setting and program the Power and PLL
-	 * Control accordingly
-	 * 4. Change RX wait
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		usb3_reg_set16(PWR_PLL_CTRL, 0xFCA3, 0xFFFF, lane);
-		usb3_reg_set16(PWR_MGM_TIM1, 0x10C, 0xFFFF, lane);
-	} else {
-		/* 25 MHz */
-		usb3_reg_set16(PWR_PLL_CTRL, 0xFCA2, 0xFFFF, lane);
-		usb3_reg_set16(PWR_MGM_TIM1, 0x107, 0xFFFF, lane);
-	}
+	/* Disbale VBus interrupt which will be enable again in kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0, vbus_int_enable);
 
-	/*
-	 * 5. Enable idle sync
-	 */
-	usb3_reg_set16(UNIT_CTRL, 0x60 | rb_idle_sync_en, 0xFFFF, lane);
-
-	/*
-	 * 6. Enable the output of 500M clock
-	 */
-	usb3_reg_set16(MISC_REG0, 0xA00D | rb_clk500m_en, 0xFFFF, lane);
-
-	/*
-	 * 7. Set 20-bit data width
-	 */
-	usb3_reg_set16(DIG_LB_EN, 0x0400, 0xFFFF, lane);
-
-	/*
-	 * 8. Override Speed_PLL value and use MAC PLL
-	 */
-	usb3_reg_set16(KVCO_CAL_CTRL, 0x0040 | rb_use_max_pll_rate, 0xFFFF,
-		       lane);
-
-	/*
-	 * 9. Check the Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT)
-		usb3_reg_set16(SYNC_PATTERN, phy_txd_inv, 0, lane);
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT)
-		usb3_reg_set16(SYNC_PATTERN, phy_rxd_inv, 0, lane);
-
-	/*
-	 * 10. Set max speed generation to USB3.0 5Gbps
-	 */
-	usb3_reg_set16(SYNC_MASK_GEN, 0x0400, 0x0C00, lane);
-
-	/*
-	 * 11. Set capacitor value for FFE gain peaking to 0xF
-	 */
-	usb3_reg_set16(GEN3_SETTINGS_3, 0xF, 0xF, lane);
-
-	/*
-	 * 12. Release SW reset
-	 */
-	usb3_reg_set16(GLOB_PHY_CTRL0,
-		       rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32
-		       | 0x20, 0xFFFF, lane);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	if (lane == 2) {
-		reg_set(rh_vsreg_addr,
-			LANE_STAT1 + USB3PHY_LANE2_REG_BASE_OFFSET,
-			0xFFFFFFFF);
-		ret = comphy_poll_reg(rh_vsreg_data,		/* address */
-				      rb_txdclk_pclk_en,	/* value */
-				      rb_txdclk_pclk_en,	/* mask */
-				      POLL_32B_REG);		/* 32bit */
-	} else {
-		ret = comphy_poll_reg(phy_addr(USB3, LANE_STAT1), /* address */
-				      rb_txdclk_pclk_en,	  /* value */
-				      rb_txdclk_pclk_en,	  /* mask */
-				      POLL_16B_REG);		  /* 16bit */
-	}
-	if (!ret)
-		printf("Failed to lock USB3 PLL\n");
-
-	/*
-	 * Set Soft ID for Host mode (Device mode works with Hard ID
-	 * detection)
-	 */
-	if (type == COMPHY_TYPE_USB3_HOST0) {
-		/*
-		 * set   BIT0: set ID_MODE of Host/Device = "Soft ID" (BIT1)
-		 * clear BIT1: set SOFT_ID = Host
-		 * set   BIT4: set INT_MODE = ID. Interrupt Mode: enable
-		 *             interrupt by ID instead of using both interrupts
-		 *             of HOST and Device ORed simultaneously
-		 *             INT_MODE=ID in order to avoid unexpected
-		 *             behaviour or both interrupts together
-		 */
-		reg_set(USB32_CTRL_BASE,
-			usb32_ctrl_id_mode | usb32_ctrl_int_mode,
-			usb32_ctrl_id_mode | usb32_ctrl_soft_id |
-			usb32_ctrl_int_mode);
-	}
+	/* Clear VBus interrupt to prepare a clean state for kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+		vbus_int_state, vbus_int_state);
 
 	debug_exit();
 
@@ -531,7 +154,7 @@ static int comphy_usb3_power_up(u32 lane, u32 type, u32 speed, u32 invert)
  */
 static int comphy_usb2_power_up(u8 usb32)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
@@ -547,63 +170,79 @@ static int comphy_usb2_power_up(u8 usb32)
 	 *    See "PLL Settings for Typical REFCLK" table
 	 */
 	if (get_ref_clk() == 25) {
-		reg_set(USB2_PHY_BASE(usb32), 5 | (96 << 16),
-			0x3F | (0xFF << 16) | (0x3 << 28));
+		reg_set((void __iomem *)USB2_PHY_BASE(usb32),
+			5 | (96 << 16), 0x3F | (0xFF << 16) | (0x3 << 28));
 	}
 
 	/*
 	 * 1. PHY pull up and disable USB2 suspend
 	 */
-	reg_set(USB2_PHY_CTRL_ADDR(usb32),
+	reg_set((void __iomem *)USB2_PHY_CTRL_ADDR(usb32),
 		RB_USB2PHY_SUSPM(usb32) | RB_USB2PHY_PU(usb32), 0);
 
 	if (usb32 != 0) {
 		/*
 		 * 2. Power up OTG module
 		 */
-		reg_set(USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+		reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
 
 		/*
 		 * 3. Configure PHY charger detection
 		 */
-		reg_set(USB2_PHY_CHRGR_DET_ADDR, 0,
+		reg_set((void __iomem *)USB2_PHY_CHRGR_DET_ADDR, 0,
 			rb_cdp_en | rb_dcp_en | rb_pd_en | rb_cdp_dm_auto |
 			rb_enswitch_dp | rb_enswitch_dm | rb_pu_chrg_dtc);
 	}
 
 	/* Assert PLL calibration done */
-	ret = comphy_poll_reg(USB2_PHY_CAL_CTRL_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_CAL_CTRL_ADDR(usb32),
 			      rb_usb2phy_pllcal_done,	/* value */
 			      rb_usb2phy_pllcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 PLL calibration\n");
 
 	/* Assert impedance calibration done */
-	ret = comphy_poll_reg(USB2_PHY_CAL_CTRL_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_CAL_CTRL_ADDR(usb32),
 			      rb_usb2phy_impcal_done,	/* value */
 			      rb_usb2phy_impcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 impedance calibration\n");
 
 	/* Assert squetch calibration done */
-	ret = comphy_poll_reg(USB2_PHY_RX_CHAN_CTRL1_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_RX_CHAN_CTRL1_ADDR(usb32),
 			      rb_usb2phy_sqcal_done,	/* value */
 			      rb_usb2phy_sqcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 unknown calibration\n");
 
 	/* Assert PLL is ready */
-	ret = comphy_poll_reg(USB2_PHY_PLL_CTRL0_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_PLL_CTRL0_ADDR(usb32),
 			      rb_usb2phy_pll_ready,		/* value */
 			      rb_usb2phy_pll_ready,		/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
 
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to lock USB2 PLL\n");
 
+	if (usb32) {
+		/*
+		 * Disbale VBus interrupt which will be
+		 * enable again in kernel
+		 */
+		reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0,
+			vbus_int_enable);
+		/* Clear VBus interrupt to prepare a clean state for kernel */
+		reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+			vbus_int_state, vbus_int_state);
+	}
+
 	debug_exit();
 
 	return ret;
@@ -621,34 +260,35 @@ static int comphy_emmc_power_up(void)
 	/*
 	 * 1. Bus power ON, Bus voltage 1.8V
 	 */
-	reg_set(SDIO_HOST_CTRL1_ADDR, 0xB00, 0xF00);
+	reg_set((void __iomem *)SDIO_HOST_CTRL1_ADDR, 0xB00, 0xF00);
 
 	/*
 	 * 2. Set FIFO parameters
 	 */
-	reg_set(SDIO_SDHC_FIFO_ADDR, 0x315, 0xFFFFFFFF);
+	reg_set((void __iomem *)SDIO_SDHC_FIFO_ADDR, 0x315, 0xFFFFFFFF);
 
 	/*
 	 * 3. Set Capabilities 1_2
 	 */
-	reg_set(SDIO_CAP_12_ADDR, 0x25FAC8B2, 0xFFFFFFFF);
+	reg_set((void __iomem *)SDIO_CAP_12_ADDR, 0x25FAC8B2, 0xFFFFFFFF);
 
 	/*
 	 * 4. Set Endian
 	 */
-	reg_set(SDIO_ENDIAN_ADDR, 0x00c00000, 0);
+	reg_set((void __iomem *)SDIO_ENDIAN_ADDR, 0x00c00000, 0);
 
 	/*
 	 * 4. Init PHY
 	 */
-	reg_set(SDIO_PHY_TIMING_ADDR, 0x80000000, 0x80000000);
-	reg_set(SDIO_PHY_PAD_CTRL0_ADDR, 0x50000000, 0xF0000000);
+	reg_set((void __iomem *)SDIO_PHY_TIMING_ADDR, 0x80000000, 0x80000000);
+	reg_set((void __iomem *)SDIO_PHY_PAD_CTRL0_ADDR, 0x50000000,
+		0xF0000000);
 
 	/*
 	 * 5. DLL reset
 	 */
-	reg_set(SDIO_DLL_RST_ADDR, 0xFFFEFFFF, 0);
-	reg_set(SDIO_DLL_RST_ADDR, 0x00010000, 0);
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0xFFFEFFFF, 0);
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0x00010000, 0);
 
 	debug_exit();
 
@@ -656,236 +296,9 @@ static int comphy_emmc_power_up(void)
 }
 
 /*
- * comphy_sgmii_power_up
- *
- * return:
- */
-static void comphy_sgmii_phy_init(u32 lane, u32 speed)
-{
-	const int fix_arr_sz = ARRAY_SIZE(sgmii_phy_init_fix);
-	int addr, fix_idx;
-	u16 val;
-
-	fix_idx = 0;
-	for (addr = 0; addr < 512; addr++) {
-		/*
-		 * All PHY register values are defined in full for 3.125Gbps
-		 * SERDES speed. The values required for 1.25 Gbps are almost
-		 * the same and only few registers should be "fixed" in
-		 * comparison to 3.125 Gbps values. These register values are
-		 * stored in "sgmii_phy_init_fix" array.
-		 */
-		if ((speed != COMPHY_SPEED_1_25G) &&
-		    (sgmii_phy_init_fix[fix_idx].addr == addr)) {
-			/* Use new value */
-			val = sgmii_phy_init_fix[fix_idx].value;
-			if (fix_idx < fix_arr_sz)
-				fix_idx++;
-		} else {
-			val = sgmii_phy_init[addr];
-		}
-
-		reg_set16(sgmiiphy_addr(lane, addr), val, 0xFFFF);
-	}
-}
-
-/*
- * comphy_sgmii_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ * comphy_dedicated_phys_init initialize the dedicated PHYs
+ * - not muxed SerDes lanes e.g. UTMI PHY
  */
-static int comphy_sgmii_power_up(u32 lane, u32 speed, u32 invert)
-{
-	int ret;
-	u32 saved_selector;
-
-	debug_enter();
-
-	/*
-	 * 1. Configure PHY to SATA/SAS mode by setting pin PIN_PIPE_SEL=0
-	 */
-	saved_selector = readl(COMPHY_SEL_ADDR);
-	reg_set(COMPHY_SEL_ADDR, 0, 0xFFFFFFFF);
-
-	/*
-	 * 2. Reset PHY by setting PHY input port PIN_RESET=1.
-	 * 3. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
-	 *    PHY TXP/TXN output to idle state during PHY initialization
-	 * 4. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_reset_comphy | rb_pin_tx_idle | rb_pin_pu_iveref,
-		rb_pin_reset_core | rb_pin_pu_pll |
-		rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 5. Release reset to the PHY by setting PIN_RESET=0.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), 0, rb_pin_reset_comphy);
-
-	/*
-	 * 7. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide
-	 *    COMPHY bit rate
-	 */
-	if (speed == COMPHY_SPEED_3_125G) { /* 3.125 GHz */
-		reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-			(0x8 << rf_gen_rx_sel_shift) |
-			(0x8 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-
-	} else if (speed == COMPHY_SPEED_1_25G) { /* 1.25 GHz */
-		reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-			(0x6 << rf_gen_rx_sel_shift) |
-			(0x6 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-	} else {
-		printf("Unsupported COMPHY speed!\n");
-		return 0;
-	}
-
-	/*
-	 * 8. Wait 1mS for bandgap and reference clocks to stabilize;
-	 *    then start SW programming.
-	 */
-	mdelay(10);
-
-	/* 9. Program COMPHY register PHY_MODE */
-	reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-		  PHY_MODE_SGMII << rf_phy_mode_shift, rf_phy_mode_mask);
-
-	/*
-	 * 10. Set COMPHY register REFCLK_SEL to select the correct REFCLK
-	 *     source
-	 */
-	reg_set16(sgmiiphy_addr(lane, MISC_REG0), 0, rb_ref_clk_sel);
-
-	/*
-	 * 11. Set correct reference clock frequency in COMPHY register
-	 *     REF_FREF_SEL.
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-			  0x4 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	} else {
-		/* 25MHz */
-		reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-			  0x1 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	}
-
-	/* 12. Program COMPHY register PHY_GEN_MAX[1:0] */
-	/*
-	 * This step is mentioned in the flow received from verification team.
-	 * However the PHY_GEN_MAX value is only meaningful for other
-	 * interfaces (not SGMII). For instance, it selects SATA speed
-	 * 1.5/3/6 Gbps or PCIe speed  2.5/5 Gbps
-	 */
-
-	/*
-	 * 13. Program COMPHY register SEL_BITS to set correct parallel data
-	 *     bus width
-	 */
-	/* 10bit */
-	reg_set16(sgmiiphy_addr(lane, DIG_LB_EN), 0, rf_data_width_mask);
-
-	/*
-	 * 14. As long as DFE function needs to be enabled in any mode,
-	 *     COMPHY register DFE_UPDATE_EN[5:0] shall be programmed to 0x3F
-	 *     for real chip during COMPHY power on.
-	 */
-	/*
-	 * The step 14 exists (and empty) in the original initialization flow
-	 * obtained from the verification team. According to the functional
-	 * specification DFE_UPDATE_EN already has the default value 0x3F
-	 */
-
-	/*
-	 * 15. Program COMPHY GEN registers.
-	 *     These registers should be programmed based on the lab testing
-	 *     result to achieve optimal performance. Please contact the CEA
-	 *     group to get the related GEN table during real chip bring-up.
-	 *     We only requred to run though the entire registers programming
-	 *     flow defined by "comphy_sgmii_phy_init" when the REF clock is
-	 *     40 MHz. For REF clock 25 MHz the default values stored in PHY
-	 *     registers are OK.
-	 */
-	debug("Running C-DPI phy init %s mode\n",
-	      speed == COMPHY_SPEED_3_125G ? "2G5" : "1G");
-	if (get_ref_clk() == 40)
-		comphy_sgmii_phy_init(lane, speed);
-
-	/*
-	 * 16. [Simulation Only] should not be used for real chip.
-	 *     By pass power up calibration by programming EXT_FORCE_CAL_DONE
-	 *     (R02h[9]) to 1 to shorten COMPHY simulation time.
-	 */
-	/*
-	 * 17. [Simulation Only: should not be used for real chip]
-	 *     Program COMPHY register FAST_DFE_TIMER_EN=1 to shorten RX
-	 *     training simulation time.
-	 */
-
-	/*
-	 * 18. Check the PHY Polarity invert bit
-	 */
-	if (invert & COMPHY_POLARITY_TXD_INVERT)
-		reg_set16(sgmiiphy_addr(lane, SYNC_PATTERN), phy_txd_inv, 0);
-
-	if (invert & COMPHY_POLARITY_RXD_INVERT)
-		reg_set16(sgmiiphy_addr(lane, SYNC_PATTERN), phy_rxd_inv, 0);
-
-	/*
-	 * 19. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1
-	 *     to start PHY power up sequence. All the PHY register
-	 *     programming should be done before PIN_PU_PLL=1. There should be
-	 *     no register programming for normal PHY operation from this point.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx,
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 20. Wait for PHY power up sequence to finish by checking output ports
-	 *     PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
-	 */
-	ret = comphy_poll_reg(COMPHY_PHY_STAT1_ADDR(lane),	/* address */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* value */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* mask */
-			      POLL_32B_REG);			/* 32bit */
-	if (!ret)
-		printf("Failed to lock PLL for SGMII PHY %d\n", lane);
-
-	/*
-	 * 21. Set COMPHY input port PIN_TX_IDLE=0
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), 0x0, rb_pin_tx_idle);
-
-	/*
-	 * 22. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1.
-	 *     to start RX initialization. PIN_RX_INIT_DONE will be cleared to
-	 *     0 by the PHY. After RX initialization is done, PIN_RX_INIT_DONE
-	 *     will be set to 1 by COMPHY. Set PIN_RX_INIT=0 after
-	 *     PIN_RX_INIT_DONE= 1.
-	 *     Please refer to RX initialization part for details.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), rb_phy_rx_init, 0x0);
-
-	ret = comphy_poll_reg(COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_rx_init_done,			/* value */
-			      rb_rx_init_done,			/* mask */
-			      POLL_32B_REG);			/* 32bit */
-	if (!ret)
-		printf("Failed to init RX of SGMII PHY %d\n", lane);
-
-	/*
-	 * Restore saved selector.
-	 */
-	reg_set(COMPHY_SEL_ADDR, saved_selector, 0xFFFFFFFF);
-
-	debug_exit();
-
-	return ret;
-}
-
 void comphy_dedicated_phys_init(void)
 {
 	int node, usb32, ret = 1;
@@ -909,7 +322,7 @@ void comphy_dedicated_phys_init(void)
 		if (node > 0) {
 			if (fdtdec_get_is_enabled(blob, node)) {
 				ret = comphy_usb2_power_up(usb32);
-				if (!ret)
+				if (ret == 0)
 					printf("Failed to initialize UTMI PHY\n");
 				else
 					debug("UTMI PHY init succeed\n");
@@ -922,22 +335,6 @@ void comphy_dedicated_phys_init(void)
 		}
 	}
 
-	node = fdt_node_offset_by_compatible(blob, -1,
-					     "marvell,armada-3700-ahci");
-	if (node > 0) {
-		if (fdtdec_get_is_enabled(blob, node)) {
-			ret = comphy_sata_power_up();
-			if (!ret)
-				printf("Failed to initialize SATA PHY\n");
-			else
-				debug("SATA PHY init succeed\n");
-		} else {
-			debug("SATA node is disabled\n");
-		}
-	}  else {
-		debug("No SATA node in DT\n");
-	}
-
 	node = fdt_node_offset_by_compatible(blob, -1,
 					     "marvell,armada-8k-sdhci");
 	if (node <= 0) {
@@ -948,7 +345,7 @@ void comphy_dedicated_phys_init(void)
 	if (node > 0) {
 		if (fdtdec_get_is_enabled(blob, node)) {
 			ret = comphy_emmc_power_up();
-			if (!ret)
+			if (ret == 0)
 				printf("Failed to initialize SDIO/eMMC PHY\n");
 			else
 				debug("SDIO/eMMC PHY init succeed\n");
@@ -968,12 +365,14 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 	struct comphy_map *comphy_map;
 	u32 comphy_max_count = chip_cfg->comphy_lanes_count;
 	u32 lane, ret = 0;
+	u32 mode = 0, fw_format = 0;
 
 	debug_enter();
 
-	/* Initialize PHY mux */
-	chip_cfg->mux_data = a3700_comphy_mux_data;
-	comphy_mux_init(chip_cfg, serdes_map, COMPHY_SEL_ADDR);
+	if (comphy_max_count > A3700_LANE_MAX_NUM) {
+		printf("Comphy number %d is too large\n", comphy_max_count);
+		return 1;
+	}
 
 	for (lane = 0, comphy_map = serdes_map; lane < comphy_max_count;
 	     lane++, comphy_map++) {
@@ -987,22 +386,41 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			break;
 
 		case COMPHY_TYPE_PEX0:
-			ret = comphy_pcie_power_up(comphy_map->speed,
-						   comphy_map->invert);
+			fw_format = COMPHY_FW_MODE_FORMAT(COMPHY_PCIE_MODE,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
 			break;
 
+		case COMPHY_TYPE_USB3:
 		case COMPHY_TYPE_USB3_HOST0:
 		case COMPHY_TYPE_USB3_DEVICE:
-			ret = comphy_usb3_power_up(lane,
-						   comphy_map->type,
-						   comphy_map->speed,
-						   comphy_map->invert);
+
+			ret = comphy_usb3_power_up(comphy_map->speed,
+						   comphy_map->invert,
+						   lane,
+						   (lane == 2) ? true : false);
 			break;
 
 		case COMPHY_TYPE_SGMII0:
 		case COMPHY_TYPE_SGMII1:
-			ret = comphy_sgmii_power_up(lane, comphy_map->speed,
-						    comphy_map->invert);
+			if (comphy_map->speed == COMPHY_SPEED_1_25G)
+				mode = COMPHY_SGMII_MODE;
+			else if (comphy_map->speed == COMPHY_SPEED_3_125G)
+				mode = COMPHY_HS_SGMII_MODE;
+			else
+				printf("Unsupported COMPHY speed!\n");
+
+			fw_format = COMPHY_FW_MODE_FORMAT(mode,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
+
+			break;
+
+		case COMPHY_TYPE_SATA0:
+			ret = comphy_sata_power_up(comphy_map->invert, lane);
+
 			break;
 
 		default:
@@ -1011,7 +429,7 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			ret = 1;
 			break;
 		}
-		if (!ret)
+		if (ret != 0)
 			printf("PLL is not locked - Failed to initialize lane %d\n",
 			       lane);
 	}
diff --git a/drivers/phy/marvell/comphy_a3700.h b/drivers/phy/marvell/comphy_a3700.h
index 8748c6c84a..0634800b05 100644
--- a/drivers/phy/marvell/comphy_a3700.h
+++ b/drivers/phy/marvell/comphy_a3700.h
@@ -8,172 +8,31 @@
 
 #include "comphy_core.h"
 
-#define MVEBU_REG(offs)			\
-	((void __iomem *)(ulong)MVEBU_REGISTER(offs))
+#define MVEBU_REG(offs)			((uintptr_t)MVEBU_REGISTER(offs))
 
-#define DEFAULT_REFCLK_MHZ		25
-#define PLL_SET_DELAY_US		600
 #define PLL_LOCK_TIMEOUT		1000
 #define POLL_16B_REG			1
 #define POLL_32B_REG			0
 
 /*
- * COMPHY SB definitions
+ * USB definitions
  */
-#define COMPHY_SEL_ADDR			MVEBU_REG(0x0183FC)
-
-#define COMPHY_PHY_CFG1_ADDR(lane)	MVEBU_REG(0x018300 + (1 - lane) * 0x28)
-#define rb_pin_pu_iveref		BIT(1)
-#define rb_pin_reset_core		BIT(11)
-#define rb_pin_reset_comphy		BIT(12)
-#define rb_pin_pu_pll			BIT(16)
-#define rb_pin_pu_rx			BIT(17)
-#define rb_pin_pu_tx			BIT(18)
-#define rb_pin_tx_idle			BIT(19)
-#define rf_gen_rx_sel_shift		22
-#define rf_gen_rx_select		(0x0F << rf_gen_rx_sel_shift)
-#define rf_gen_tx_sel_shift		26
-#define rf_gen_tx_select		(0x0F << rf_gen_tx_sel_shift)
-#define rb_phy_rx_init			BIT(30)
-
-#define COMPHY_PHY_STAT1_ADDR(lane)	MVEBU_REG(0x018318 + (1 - lane) * 0x28)
-#define rb_rx_init_done			BIT(0)
-#define rb_pll_ready_rx			BIT(2)
-#define rb_pll_ready_tx			BIT(3)
-
-/*
- * PCIe/USB/SGMII definitions
- */
-#define PCIE_BASE			MVEBU_REG(0x070000)
-#define PCIETOP_BASE			MVEBU_REG(0x080000)
-#define PCIE_RAMBASE			MVEBU_REG(0x08C000)
-#define PCIEPHY_BASE			MVEBU_REG(0x01F000)
-#define PCIEPHY_SHFT			2
-
 #define USB32_BASE			MVEBU_REG(0x050000) /* usb3 device */
-#define USB32H_BASE			MVEBU_REG(0x058000) /* usb3 host */
-#define USB3PHY_BASE			MVEBU_REG(0x05C000)
 #define USB2PHY_BASE			MVEBU_REG(0x05D000)
 #define USB2PHY2_BASE			MVEBU_REG(0x05F000)
-#define USB32_CTRL_BASE			MVEBU_REG(0x05D800)
-#define USB3PHY_SHFT			2
-#define USB3PHY_LANE2_REG_BASE_OFFSET	0x200
-
-static inline void __iomem *sgmiiphy_addr(u32 lane, u32 addr)
-{
-	addr = (addr & 0x00007FF) * 2;
-	if (lane == 1)
-		return PCIEPHY_BASE + addr;
-	else
-		return USB3PHY_BASE + addr;
-}
-
-/* units */
-enum phy_unit {
-	PCIE = 1,
-	USB3 = 2,
-};
-
-static inline void __iomem *phy_addr(enum phy_unit unit, u32 addr)
-{
-	if (unit == PCIE)
-		return PCIEPHY_BASE + addr * PCIEPHY_SHFT;
-	else
-		return USB3PHY_BASE + addr * USB3PHY_SHFT;
-}
-
-/* bit definition for USB32_CTRL_BASE (USB32 Control Mode) */
-#define usb32_ctrl_id_mode		BIT(0)
-#define usb32_ctrl_soft_id		BIT(1)
-#define usb32_ctrl_int_mode		BIT(4)
-
-#define PWR_PLL_CTRL			0x01
-#define rf_phy_mode_shift		5
-#define rf_phy_mode_mask		(0x7 << rf_phy_mode_shift)
-#define rf_ref_freq_sel_shift		0
-#define rf_ref_freq_sel_mask		(0x1F << rf_ref_freq_sel_shift)
-#define PHY_MODE_SGMII			0x4
-
-#define KVCO_CAL_CTRL			0x02
-#define rb_use_max_pll_rate		BIT(12)
-#define rb_force_calibration_done	BIT(9)
-
-#define DIG_LB_EN			0x23
-#define rf_data_width_shift		10
-#define rf_data_width_mask		(0x3 << rf_data_width_shift)
-
-#define SYNC_PATTERN			0x24
-#define phy_txd_inv			BIT(10)
-#define phy_rxd_inv			BIT(11)
-
-#define SYNC_MASK_GEN			0x25
-#define rb_idle_sync_en			BIT(12)
-
-#define UNIT_CTRL			0x48
-
-#define GEN2_SETTINGS_2			0x3e
-#define g2_tx_ssc_amp			BIT(14)
-
-#define GEN2_SETTINGS_3			0x3f
-
-#define GEN3_SETTINGS_3			0x112
-
-#define MISC_REG0			0x4f
-#define rb_clk100m_125m_en		BIT(4)
-#define rb_clk500m_en			BIT(7)
-#define rb_ref_clk_sel			BIT(10)
-
-#define UNIT_IFACE_REF_CLK_CTRL		0x51
-#define rb_ref1m_gen_div_force		BIT(8)
-#define rf_ref1m_gen_div_value_shift	0
-#define rf_ref1m_gen_div_value_mask	(0xFF << rf_ref1m_gen_div_value_shift)
-
-#define UNIT_ERR_CNT_CONST_CTRL		0x6a
-#define rb_fast_dfe_enable		BIT(13)
-
-#define MISC_REG1			0x73
-#define bf_sel_bits_pcie_force		BIT(15)
-
-#define LANE_CFG0			0x180
-#define bf_use_max_pll_rate		BIT(9)
-
-#define LANE_CFG1			0x181
-#define bf_use_max_pll_rate		BIT(9)
-#define prd_txdeemph1_mask		BIT(15)
-#define tx_det_rx_mode			BIT(6)
-#define gen2_tx_data_dly_deft		(2 << 3)
-#define gen2_tx_data_dly_mask		(BIT(3) | BIT(4))
-#define tx_elec_idle_mode_en		BIT(0)
-
-#define LANE_CFG4			0x188
-#define bf_spread_spectrum_clock_en	BIT(7)
-
-#define LANE_STAT1			0x183
-#define rb_txdclk_pclk_en		BIT(0)
-
-#define GLOB_PHY_CTRL0			0x1c1
-#define bf_soft_rst			BIT(0)
-#define bf_mode_refdiv			0x30
-#define rb_mode_core_clk_freq_sel	BIT(9)
-#define rb_mode_pipe_width_32		BIT(3)
-
-#define TEST_MODE_CTRL			0x1c2
-#define rb_mode_margin_override		BIT(2)
-
-#define GLOB_CLK_SRC_LO			0x1c3
-#define bf_cfg_sel_20b			BIT(15)
-
-#define PWR_MGM_TIM1			0x1d0
-
-#define PCIE_REF_CLK_ADDR		(PCIE_BASE + 0x4814)
 
 #define USB3_CTRPUL_VAL_REG		(0x20 + USB32_BASE)
-#define USB3H_CTRPUL_VAL_REG		(0x3454 + USB32H_BASE)
+#define USB3_TOP_INT_STATUS_REG		(0xd8 + USB32_BASE)
+#define vbus_int_state			BIT(5)
+#define USB3_TOP_INT_ENABLE_REG		(0xdc + USB32_BASE)
+#define vbus_int_enable			BIT(5)
 #define rb_usb3_ctr_100ns		0xff000000
 
 #define USB2_OTG_PHY_CTRL_ADDR		(0x820 + USB2PHY_BASE)
 #define rb_usb2phy_suspm		BIT(14)
 #define rb_usb2phy_pu			BIT(0)
+#define rb_usb2_dp_pulldn_dev_mode	BIT(5)
+#define rb_usb2_dm_pulldn_dev_mode	BIT(6)
 
 #define USB2_PHY_OTG_CTRL_ADDR		(0x34 + USB2PHY_BASE)
 #define rb_pu_otg			BIT(4)
@@ -223,27 +82,9 @@ static inline void __iomem *phy_addr(enum phy_unit unit, u32 addr)
  */
 #define AHCI_BASE			MVEBU_REG(0xE0000)
 
-#define rh_vsreg_addr			(AHCI_BASE + 0x178)
-#define rh_vsreg_data			(AHCI_BASE + 0x17C)
 #define rh_vs0_a			(AHCI_BASE + 0xA0)
 #define rh_vs0_d			(AHCI_BASE + 0xA4)
 
-#define vphy_sync_pattern_reg		0x224
-#define bs_txd_inv			BIT(10)
-#define bs_rxd_inv			BIT(11)
-
-#define vphy_loopback_reg0		0x223
-#define bs_phyintf_40bit		0x0C00
-#define bs_pll_ready_tx			0x10
-
-#define vphy_power_reg0			0x201
-
-#define vphy_calctl_reg			0x202
-#define bs_max_pll_rate			BIT(12)
-
-#define vphy_reserve_reg		0x0e
-#define bs_phyctrl_frm_pin		BIT(13)
-
 #define vsata_ctrl_reg			0x00
 #define bs_phy_pu_pll			BIT(6)
 
diff --git a/drivers/phy/marvell/comphy_core.h b/drivers/phy/marvell/comphy_core.h
index ba64491dfe..7c778fd74a 100644
--- a/drivers/phy/marvell/comphy_core.h
+++ b/drivers/phy/marvell/comphy_core.h
@@ -20,18 +20,7 @@
 #define MAX_LANE_OPTIONS			10
 #define MAX_UTMI_PHY_COUNT			6
 
-struct comphy_mux_options {
-	u32 type;
-	u32 mux_value;
-};
-
-struct comphy_mux_data {
-	u32 max_lane_values;
-	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
-};
-
 struct chip_serdes_phy_config {
-	struct comphy_mux_data *mux_data;
 	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *,
 				    struct comphy_map *);
 	int (*rx_training)(struct chip_serdes_phy_config *, u32);
diff --git a/drivers/phy/marvell/comphy_mux.c b/drivers/phy/marvell/comphy_mux.c
deleted file mode 100644
index e3a9b7b0a0..0000000000
--- a/drivers/phy/marvell/comphy_mux.c
+++ /dev/null
@@ -1,134 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- */
-
-#include <common.h>
-#include <asm/io.h>
-
-#include "comphy_core.h"
-
-/*
- * comphy_mux_check_config()
- * description: this function passes over the COMPHY lanes and check if the type
- *              is valid for specific lane. If the type is not valid,
- *              the function update the struct and set the type of the lane as
- *              COMPHY_TYPE_UNCONNECTED
- */
-static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes)
-{
-	struct comphy_mux_options *mux_opt;
-	int lane, opt, valid;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		/* Don't check ignored COMPHYs */
-		if (comphy_map_data->type == COMPHY_TYPE_IGNORE)
-			continue;
-
-		mux_opt = mux_data->mux_values;
-		for (opt = 0, valid = 0; opt < mux_data->max_lane_values;
-		     opt++, mux_opt++) {
-			if (mux_opt->type == comphy_map_data->type) {
-				valid = 1;
-				break;
-			}
-		}
-		if (valid == 0) {
-			debug("lane number %d, had invalid type %d\n",
-			      lane, comphy_map_data->type);
-			debug("set lane %d as type %d\n", lane,
-			      COMPHY_TYPE_UNCONNECTED);
-			comphy_map_data->type = COMPHY_TYPE_UNCONNECTED;
-		} else {
-			debug("lane number %d, has type %d\n",
-			      lane, comphy_map_data->type);
-		}
-	}
-
-	debug_exit();
-}
-
-static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data,
-				    u32 type, int lane)
-{
-	struct comphy_mux_options *mux_opt;
-	int opt;
-	u32 value = 0;
-
-	debug_enter();
-
-	mux_opt = mux_data->mux_values;
-	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, mux_opt++) {
-		if (mux_opt->type == type) {
-			value = mux_opt->mux_value;
-			break;
-		}
-	}
-
-	debug_exit();
-
-	return value;
-}
-
-static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
-				 struct comphy_map *comphy_map_data,
-				 int comphy_max_lanes,
-				 void __iomem *selector_base,
-				 const fdt32_t *mux_lane_order, u32 bitcount)
-{
-	u32 lane, value, offset, mask;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		if (comphy_map_data->type == COMPHY_TYPE_IGNORE)
-			continue;
-
-		/*
-		 * if the order of nodes in selector base register is
-		 * nontrivial, use mapping from mux_lane_order
-		 */
-		if (mux_lane_order)
-			offset = fdt32_to_cpu(mux_lane_order[lane]) * bitcount;
-		else
-			offset = lane * bitcount;
-
-		mask = (((1 << bitcount) - 1) << offset);
-		value = (comphy_mux_get_mux_value(mux_data,
-						  comphy_map_data->type,
-						  lane) << offset);
-		reg_set(selector_base, value, mask);
-	}
-
-	debug_exit();
-}
-
-void comphy_mux_init(struct chip_serdes_phy_config *chip_cfg,
-		     struct comphy_map *comphy_map_data,
-		     void __iomem *selector_base)
-{
-	struct comphy_mux_data *mux_data;
-	const fdt32_t *mux_lane_order;
-	u32 mux_bitcount;
-	u32 comphy_max_lanes;
-
-	debug_enter();
-
-	comphy_max_lanes = chip_cfg->comphy_lanes_count;
-	mux_data = chip_cfg->mux_data;
-	mux_lane_order = chip_cfg->comphy_mux_lane_order;
-	mux_bitcount = chip_cfg->comphy_mux_bitcount;
-
-	/* check if the configuration is valid */
-	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
-	/* Init COMPHY selectors */
-	comphy_mux_reg_write(mux_data, comphy_map_data, comphy_max_lanes,
-			     selector_base, mux_lane_order, mux_bitcount);
-
-	debug_exit();
-}
-- 
2.29.0

