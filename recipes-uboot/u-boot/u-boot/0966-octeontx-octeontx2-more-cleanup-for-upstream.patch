From e805c398087d9712ee855ec1857e7d7ce08828d1 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <sgarapati@caviumnetworks.com>
Date: Tue, 8 Oct 2019 17:19:56 -0700
Subject: [PATCH 0966/1239] octeontx: octeontx2: more cleanup for upstream

 - cleanup board headers and files
 - cleanup miscellaneous defines
 - cleanup checkpatch errors
 - simplify file names

Change-Id: I8236307eb46a1ff8d1796be4e896d307dd5febf6
Signed-off-by: Suneel Garapati <sgarapati@caviumnetworks.com>
Reviewed-on: https://sj1git1.cavium.com/17193
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
---
 arch/arm/include/asm/arch-octeontx/atf.h      |   12 -
 arch/arm/include/asm/arch-octeontx/board.h    |  194 +++
 arch/arm/include/asm/arch-octeontx/clock.h    |  112 +-
 arch/arm/include/asm/arch-octeontx/octeontx.h |   55 -
 .../include/asm/arch-octeontx/octeontx_svc.h  |   26 -
 .../include/asm/arch-octeontx/octeontx_vnic.h |   21 -
 .../include/asm/arch-octeontx/octeontx_xcv.h  |   15 -
 arch/arm/include/asm/arch-octeontx/smc.h      |   20 +
 arch/arm/include/asm/arch-octeontx/soc.h      |   73 +
 arch/arm/include/asm/arch-octeontx2/atf.h     |   20 -
 arch/arm/include/asm/arch-octeontx2/board.h   |  239 ++++
 arch/arm/include/asm/arch-octeontx2/clock.h   |  111 +-
 .../include/asm/arch-octeontx2/csrs-mio_emm.h | 1199 -----------------
 .../include/asm/arch-octeontx2/octeontx2.h    |  106 --
 .../asm/arch-octeontx2/octeontx2_fdt.h        |   13 -
 .../{octeontx2_svc.h => smc-id.h}             |   15 +-
 arch/arm/include/asm/arch-octeontx2/smc.h     |   24 +
 arch/arm/include/asm/arch-octeontx2/soc.h     |   33 +
 arch/arm/mach-octeontx/clock.c                |    5 +-
 arch/arm/mach-octeontx/cpu.c                  |    2 +-
 arch/arm/mach-octeontx/lowlevel_init.S        |    3 -
 arch/arm/mach-octeontx2/clock.c               |    5 +-
 arch/arm/mach-octeontx2/cpu.c                 |    2 +-
 arch/arm/mach-octeontx2/lowlevel_init.S       |    1 -
 board/Marvell/octeontx/MAINTAINERS            |    8 +-
 board/Marvell/octeontx/Makefile               |    4 +-
 board/Marvell/octeontx/board-fdt.c            |  271 ++++
 board/Marvell/octeontx/board.c                |  146 ++
 board/Marvell/octeontx/fdt.c                  |  212 ---
 board/Marvell/octeontx/octeontx.c             |  263 ----
 board/Marvell/octeontx/{atf.c => smc.c}       |    5 +-
 board/Marvell/octeontx/soc-utils.c            |   61 +
 board/Marvell/octeontx2/MAINTAINERS           |    5 +-
 board/Marvell/octeontx2/Makefile              |    8 +-
 board/Marvell/octeontx2/board-fdt.c           |  155 +++
 .../octeontx2/{octeontx2.c => board.c}        |  214 +--
 board/Marvell/octeontx2/fdt.c                 |   68 -
 board/Marvell/octeontx2/{atf.c => smc.c}      |   19 +-
 board/Marvell/octeontx2/soc-utils.c           |   49 +
 cmd/marvell/mdio_dbg.c                        |    6 +-
 cmd/marvell/octeontx2_attest_cmds.c           |    8 +-
 cmd/marvell/octeontx2_failsafe_cmds.c         |    4 +-
 cmd/marvell/octeontx2_qlm_cmds.c              |    1 -
 drivers/ata/ahci.c                            |    5 +-
 drivers/mmc/octeontx_hsmmc.c                  |   30 +-
 drivers/mtd/nand/octeontx_bch.c               |   14 +-
 drivers/mtd/nand/octeontx_bch.h               |    4 +-
 drivers/mtd/nand/octeontx_nand.c              |    4 +-
 drivers/net/Makefile                          |    2 +-
 drivers/net/octeontx/Makefile                 |    4 +-
 .../net/octeontx/{octeontx_bgx.c => bgx.c}    |   54 +-
 .../net/octeontx/{octeontx_bgx.h => bgx.h}    |    8 +-
 drivers/net/octeontx/nic.h                    |    2 +-
 drivers/net/octeontx/nic_main.c               |    4 -
 drivers/net/octeontx/nicvf_main.c             |    6 +-
 .../net/octeontx/{octeontx_smi.c => smi.c}    |    0
 .../net/octeontx/{octeontx_xcv.c => xcv.c}    |    5 +-
 drivers/net/octeontx2/cgx.c                   |    2 +-
 drivers/net/octeontx2/cgx_intf.c              |    2 +-
 drivers/net/octeontx2/lmt.h                   |    8 +-
 drivers/net/octeontx2/nix.c                   |   22 +-
 drivers/net/octeontx2/nix_af.c                |    2 +-
 drivers/net/octeontx2/rvu.h                   |    4 +-
 drivers/net/octeontx2/rvu_af.c                |    8 +-
 drivers/net/octeontx2/rvu_pf.c                |    8 +-
 drivers/spi/octeontx_spi.c                    |    2 +-
 66 files changed, 1457 insertions(+), 2556 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-octeontx/atf.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/board.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_svc.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/smc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/soc.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/atf.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/board.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/octeontx2.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
 rename arch/arm/include/asm/arch-octeontx2/{octeontx2_svc.h => smc-id.h} (80%)
 create mode 100644 arch/arm/include/asm/arch-octeontx2/smc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/soc.h
 create mode 100644 board/Marvell/octeontx/board-fdt.c
 create mode 100644 board/Marvell/octeontx/board.c
 delete mode 100644 board/Marvell/octeontx/fdt.c
 delete mode 100644 board/Marvell/octeontx/octeontx.c
 rename board/Marvell/octeontx/{atf.c => smc.c} (79%)
 create mode 100644 board/Marvell/octeontx/soc-utils.c
 create mode 100644 board/Marvell/octeontx2/board-fdt.c
 rename board/Marvell/octeontx2/{octeontx2.c => board.c} (53%)
 delete mode 100644 board/Marvell/octeontx2/fdt.c
 rename board/Marvell/octeontx2/{atf.c => smc.c} (81%)
 create mode 100644 board/Marvell/octeontx2/soc-utils.c
 rename drivers/net/octeontx/{octeontx_bgx.c => bgx.c} (97%)
 rename drivers/net/octeontx/{octeontx_bgx.h => bgx.h} (98%)
 rename drivers/net/octeontx/{octeontx_smi.c => smi.c} (100%)
 rename drivers/net/octeontx/{octeontx_xcv.c => xcv.c} (97%)

diff --git a/arch/arm/include/asm/arch-octeontx/atf.h b/arch/arm/include/asm/arch-octeontx/atf.h
deleted file mode 100644
index 1d5d581c7f..0000000000
--- a/arch/arm/include/asm/arch-octeontx/atf.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef __ATF_H__
-#define __ATF_H__
-
-ssize_t atf_dram_size(unsigned int node);
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx/board.h b/arch/arm/include/asm/arch-octeontx/board.h
new file mode 100644
index 0000000000..52cbef2ad8
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/board.h
@@ -0,0 +1,194 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+#include <asm/arch/soc.h>
+
+#define MAX_LMAC_PER_BGX 4
+#define LMAC_CNT MAX_LMAC_PER_BGX
+
+#if defined(CONFIG_TARGET_OCTEONTX_81XX)
+
+/** Maximum number of BGX interfaces per CPU node */
+#define MAX_BGX_PER_NODE	3
+#define OCTEONTX_XCV	/* RGMII Interface */
+
+#elif defined(CONFIG_TARGET_OCTEONTX_83XX)
+
+/** Maximum number of BGX interfaces per CPU node */
+#define MAX_BGX_PER_NODE	4
+
+#endif
+
+/** Reg offsets */
+#define RST_BOOT	0x87E006001600ULL
+
+#define GTI_CWD_POKEX	0x844000050000ULL
+#define GTI_CWD_WDOGX	0x844000040000ULL
+
+/** Structure definitions */
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register This register is not accessible through ROM scripts;
+ * see SCR_WRITE32_S[ADDR].
+ */
+union rst_boot {
+	u64 u;
+	struct rst_boot_s {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_32                    : 31;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 reserved_61_62                   : 2;
+		u64 chipkill                         : 1;
+	} s;
+	struct rst_boot_cn81xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 reserved_26_29                   : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn81xx;
+	struct rst_boot_cn83xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 lboot_pf_flr                     : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn83xx;
+	struct rst_boot_cn96xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_23                    : 22;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn96xx;
+	struct rst_boot_cn98xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 rxp_mul                          : 7;
+		u64 reserved_15                      : 1;
+		u64 cpt1_mul                         : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn98xx;
+	struct rst_boot_cnf95xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 bphy_mul                         : 7;
+		u64 reserved_15                      : 1;
+		u64 dsp_mul                          : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cnf95xx;
+};
+
+/** Function definitions */
+int octeontx_board_has_pmp(void);
+const char *fdt_get_board_model(void);
+void fdt_parse_phy_info(void);
+void fdt_board_get_ethaddr(int bgx, int lmac, unsigned char *eth);
+
+void bgx_set_board_info(int bgx_id, int *mdio_bus, int *phy_addr,
+			bool *autoneg_dis, bool *lmac_reg, bool *lmac_enable);
+
+#endif /* __BOARD_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/clock.h b/arch/arm/include/asm/arch-octeontx/clock.h
index f94f755e48..7bf600a1f2 100644
--- a/arch/arm/include/asm/arch-octeontx/clock.h
+++ b/arch/arm/include/asm/arch-octeontx/clock.h
@@ -5,119 +5,13 @@
  * https://spdx.org/licenses
  */
 
-#ifndef __OCTEONTX_CLOCK_H__
+#ifndef __CLOCK_H__
+#define __CLOCK_H__
 
 /** System PLL reference clock */
 #define PLL_REF_CLK                     50000000        /* 50 MHz */
 #define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
 
-/** Address of RST_BOOT register */
-#define RST_BOOT	0x87e006001600ll
-
-/**
- * Register (RSL) rst_boot
- *
- * RST Boot Register
- */
-union cavm_rst_boot {
-	u64 u;
-	struct cavm_rst_boot_s {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} s;
-	struct cavm_rst_boot_cn81xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn81xx;
-	struct cavm_rst_boot_cn88xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 reserved_24_25:2;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn88xx;
-	struct cavm_rst_boot_cn83xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn83xx;
-};
-
 /**
  * Returns the I/O clock speed in Hz
  */
@@ -128,4 +22,4 @@ u64 octeontx_get_io_clock(void);
  */
 u64 octeontx_get_core_clock(void);
 
-#endif /* __OCTEONTX_CLOCK_H__ */
+#endif /* __CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx.h b/arch/arm/include/asm/arch-octeontx/octeontx.h
deleted file mode 100644
index ac2bc86a30..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef __OCTEONTX_H__
-#define __OCTEONTX_H__
-
-#define CN81XX	0xA2
-#define CN83XX	0xA3
-#define is_board_model(model)  (g_cavm_bdt.prod_id == (model))
-
-#define MAX_LMAC_PER_BGX 4
-#define LMAC_CNT MAX_LMAC_PER_BGX
-
-#if defined(CONFIG_TARGET_OCTEONTX_81XX)
-
-/** Maximum number of BGX interfaces per CPU node */
-#define MAX_BGX_PER_NODE	3
-#define OCTEONTX_XCV	/* RGMII Interface */
-
-#elif defined(CONFIG_TARGET_OCTEONTX_83XX)
-
-/** Maximum number of BGX interfaces per CPU node */
-#define MAX_BGX_PER_NODE	4
-
-#endif
-
-/** Reg offsets */
-#define CAVM_MIO_FUS_DAT2	0x87E003001410ULL
-
-#define CAVM_GTI_CWD_POKEX	0x844000050000ULL
-#define CAVM_GTI_CWD_WDOGX	0x844000040000ULL
-
-/** Structure definitions */
-
-/** Function definitions */
-void octeontx_parse_board_info(void);
-int octeontx_board_has_pmp(void);
-void octeontx_parse_phy_info(void);
-void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth);
-
-/** Board data definitions */
-struct cavm_bdt {
-	u8 resv[6];
-	u8 prod_id;
-	u8 alt_pkg;
-	char type[16];
-};
-
-extern struct cavm_bdt g_cavm_bdt;
-
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_svc.h b/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
deleted file mode 100644
index fe2f45ab70..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef __OCTEONTX_SVC_H__
-#define __OCTEONTX_SVC_H__
-
-/* SMC function IDs for general purpose queries */
-
-#define OCTEONTX_SVC_CALL_COUNT		0xc200ff00
-#define OCTEONTX_SVC_UID		0xc200ff01
-
-#define OCTEONTX_SVC_VERSION		0xc200ff03
-
-/* OcteonTX Service Calls version numbers */
-#define OCTEONTX_VERSION_MAJOR	0x1
-#define OCTEONTX_VERSION_MINOR	0x0
-
-/* x1 - node number
- */
-#define OCTEONTX_DRAM_SIZE		0xc2000301
-
-#endif /* __OCTEONTX_SVC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h b/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
deleted file mode 100644
index 68237bb288..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef VNIC_H_
-#define VNIC_H_
-
-struct nicpf;
-struct nicvf;
-
-int octeontx_bgx_initialize(unsigned int bgx_idx, unsigned int node);
-void bgx_get_count(int node, int *bgx_count);
-int bgx_get_lmac_count(int node, int bgx_idx);
-void bgx_set_board_info(int bgx_id, int *mdio_bus,
-			int *phy_addr, bool *autoneg_dis,
-			bool *lmac_reg, bool *lmac_enable);
-
-#endif /* VNIC_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h b/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
deleted file mode 100644
index 67a89396d6..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef OCTEONTX_XCV_H_
-#define OCTEONTX_XCV_H_
-
-#define XCVX_BASE		0x87E0DB000000ULL
-
-#include <asm/arch/csrs/csrs-xcv.h>
-
-#endif /* OCTEONTX_XCV_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/smc.h b/arch/arm/include/asm/arch-octeontx/smc.h
new file mode 100644
index 0000000000..beff4d158f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/smc.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SMC_H__
+#define __SMC_H__
+
+/* OcteonTX Service Calls version numbers */
+#define OCTEONTX_VERSION_MAJOR	0x1
+#define OCTEONTX_VERSION_MINOR	0x0
+
+/* x1 - node number */
+#define OCTEONTX_DRAM_SIZE	0xc2000301
+
+ssize_t smc_dram_size(unsigned int node);
+
+#endif /* __SMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/soc.h b/arch/arm/include/asm/arch-octeontx/soc.h
new file mode 100644
index 0000000000..6d780929ec
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/soc.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SOC_H__
+#define __SOC_H__
+
+/* Product PARTNUM */
+#define CN81XX	0xA2
+#define CN83XX	0xA3
+
+/* Register defines */
+#define MIO_FUS_DAT2	0x87E003001410ULL
+
+#define otx_is_altpkg()	read_alt_pkg()
+#define otx_is_soc(soc)	(read_partnum() == (soc))
+#define otx_is_board(model) (!strcmp(read_board_name(), model))
+#define otx_is_platform(platform) (read_platform() == (platform))
+
+typedef enum {
+	PLATFORM_HW = 0,
+	PLATFORM_EMULATOR = 1,
+	PLATFORM_ASIM = 3,
+} platform_t;
+
+/**
+ * Register (RSL) mio_fus_dat2
+ *
+ * MIO Fuse Data Register 2
+ */
+union mio_fus_dat2 {
+	u64 u;
+	struct mio_fus_dat2_s {
+		u64 reserved_0                       : 1;
+		u64 ddf_dis                          : 1;
+		u64 bgx2_dis                         : 1;
+		u64 bgx3_dis                         : 1;
+		u64 tim_dis                          : 1;
+		u64 lmc_half                         : 1;
+		u64 pem_dis                          : 3;
+		u64 sata_dis                         : 4;
+		u64 bgx_dis                          : 2;
+		u64 ocx_dis                          : 1;
+		u64 chip_id                          : 8;
+		u64 reserved_24                      : 1;
+		u64 trustzone_en                     : 1;
+		u64 nocrypto                         : 1;
+		u64 nomul                            : 1;
+		u64 nodfa_cp2                        : 1;
+		u64 reserved_29                      : 1;
+		u64 lmc_mode32                       : 1;
+		u64 reserved_31                      : 1;
+		u64 raid_en                          : 1;
+		u64 fus318                           : 1;
+		u64 dorm_crypto                      : 1;
+		u64 power_limit                      : 2;
+		u64 rom_info                         : 10;
+		u64 fus118                           : 1;
+		u64 gbl_pwr_throttle                 : 8;
+		u64 run_platform                     : 3;
+		u64 reserved_59_63                   : 5;
+	} s;
+};
+
+platform_t read_platform(void);
+u8 read_partnum(void);
+const char *read_board_name(void);
+bool read_alt_pkg(void);
+
+#endif /* __SOC_H */
diff --git a/arch/arm/include/asm/arch-octeontx2/atf.h b/arch/arm/include/asm/arch-octeontx2/atf.h
deleted file mode 100644
index 8a21846118..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/atf.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#ifndef __ATF_H__
-#define __ATF_H__
-
-ssize_t atf_dram_size(unsigned int node);
-ssize_t atf_disable_rvu_lfs(unsigned int node);
-ssize_t atf_flsf_fw_booted(void);
-ssize_t atf_flsf_clr_force_2ndry(void);
-ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
-			  int reg);
-ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
-			   int reg, int val);
-ssize_t atf_attest(long nonce_len);
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/board.h b/arch/arm/include/asm/arch-octeontx2/board.h
new file mode 100644
index 0000000000..a8e37e3e11
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/board.h
@@ -0,0 +1,239 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+#include <asm/arch/soc.h>
+
+/** Reg offsets */
+#define RST_BOOT		0x87E006001600ULL
+#define RST_CHIP_DOM_W1S	0x87E006001810ULL
+
+#define CPC_BOOT_OWNERX(a)	0x86D000000160ULL + (8 * (a))
+
+#define GTI_CWD_POKEX	0x802000050000ULL
+#define GTI_CWD_WDOGX	0x802000040000ULL
+
+/* attestation definitions shared with ATF (see 'plat_octeontx.h') */
+
+#define ATTESTATION_MAGIC_ID 0x5f415454 /* "_ATT" */
+
+enum sw_attestation_tlv_type {
+	ATT_IMG_INIT_BIN,
+	ATT_IMG_ATF_BL1,
+	ATT_IMG_BOARD_DT,
+	ATT_IMG_LINUX_DT,
+	ATT_IMG_SCP_TBL1FW,
+	ATT_IMG_MCP_TBL1FW,
+	ATT_IMG_AP_TBL1FW,
+	ATT_IMG_ATF_BL2,
+	ATT_IMG_ATF_BL31,
+	ATT_IMG_ATF_BL33,
+	ATT_SIG_NONCE,
+
+	ATT_TLV_TYPE_COUNT,
+};
+
+typedef struct sw_attestation_tlv {
+	u16 type_be;   /* sw_attestation_tlv_type */
+	u16 length_be;
+	u8 value[0];   /* array of 'length_be' bytes */
+} sw_attestation_tlv_t;
+
+#define SW_ATT_INFO_NONCE_MAX_LEN  256
+
+typedef struct sw_attestation_info_hdr {
+	u32 magic_be;
+	u16 tlv_len_be;
+	u16 total_len_be;
+	u16 certificate_len_be;
+	u16 signature_len_be;
+	union {
+		sw_attestation_tlv_t tlv_list[0];
+		s8 input_nonce[0];
+	};
+} __packed sw_attestation_info_hdr_t;
+
+/** Structure definitions */
+/**
+ * Register (NCB32b) cpc_boot_owner#
+ *
+ * CPC Boot Owner Registers These registers control an external arbiter
+ * for the boot device (SPI/eMMC) across multiple external devices. There
+ * is a register for each requester: _ \<0\> - SCP          - reset on
+ * SCP reset _ \<1\> - MCP          - reset on MCP reset _ \<2\> - AP
+ * Secure    - reset on core reset _ \<3\> - AP Nonsecure - reset on core
+ * reset  These register is only writable to the corresponding
+ * requestor(s) permitted with CPC_PERMIT.
+ */
+union cpc_boot_ownerx {
+	u32 u;
+	struct cpc_boot_ownerx_s {
+		u32 boot_req		: 1;
+		u32 reserved_1_7	: 7;
+		u32 boot_wait		: 1;
+		u32 reserved_9_31	: 23;
+	} s;
+};
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register This register is not accessible through ROM scripts;
+ * see SCR_WRITE32_S[ADDR].
+ */
+union rst_boot {
+	u64 u;
+	struct rst_boot_s {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_32                    : 31;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 reserved_61_62                   : 2;
+		u64 chipkill                         : 1;
+	} s;
+	struct rst_boot_cn81xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 reserved_26_29                   : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn81xx;
+	struct rst_boot_cn83xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 lboot_pf_flr                     : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn83xx;
+	struct rst_boot_cn96xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_23                    : 22;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn96xx;
+	struct rst_boot_cn98xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 rxp_mul                          : 7;
+		u64 reserved_15                      : 1;
+		u64 cpt1_mul                         : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn98xx;
+	struct rst_boot_cnf95xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 bphy_mul                         : 7;
+		u64 reserved_15                      : 1;
+		u64 dsp_mul                          : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cnf95xx;
+};
+
+/** Function definitions */
+int fdt_get_board_mac_cnt(void);
+u64 fdt_get_board_mac_addr(void);
+const char *fdt_get_board_model(void);
+void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr);
+void acquire_flash_arb(bool acquire);
+
+#endif /* __BOARD_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/clock.h b/arch/arm/include/asm/arch-octeontx2/clock.h
index 1ce4535fd6..7be8852a55 100644
--- a/arch/arm/include/asm/arch-octeontx2/clock.h
+++ b/arch/arm/include/asm/arch-octeontx2/clock.h
@@ -5,119 +5,12 @@
  * https://spdx.org/licenses
  */
 
-#ifndef __OCTEONTX2_CLOCK_H__
+#ifndef __CLOCK_H__
 
 /** System PLL reference clock */
 #define PLL_REF_CLK                     50000000        /* 50 MHz */
 #define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
 
-/** Address of RST_BOOT register */
-#define RST_BOOT	0x87e006001600ll
-
-/**
- * Register (RSL) rst_boot
- *
- * RST Boot Register
- */
-union cavm_rst_boot {
-	u64 u;
-	struct cavm_rst_boot_s {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} s;
-	struct cavm_rst_boot_cn81xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn81xx;
-	struct cavm_rst_boot_cn88xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 reserved_24_25:2;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn88xx;
-	struct cavm_rst_boot_cn83xx {
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-	} cn83xx;
-};
-
 /**
  * Returns the I/O clock speed in Hz
  */
@@ -128,4 +21,4 @@ u64 octeontx_get_io_clock(void);
  */
 u64 octeontx_get_core_clock(void);
 
-#endif /* __OCTEONTX2_CLOCK_H__ */
+#endif /* __CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
deleted file mode 100644
index 4dd8958d2f..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
+++ /dev/null
@@ -1,1199 +0,0 @@
-/* SPDX-License-Identifier:    GPL-2.0
- *
- * Copyright (C) 2019 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-#ifndef __CSRS_MIO_EMM_H__
-#define __CSRS_MIO_EMM_H__
-
-/**
- * @file
- *
- * Configuration and status register (CSR) address and type definitions for
- * MIO_EMM.
- *
- * This file is auto generated.  Do not edit.
- *
- */
-
-/**
- * Enumeration mio_emm_bar_e
- *
- * eMMC Base Address Register Enumeration Enumerates the base address
- * registers.
- */
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
-#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
-
-/**
- * Enumeration mio_emm_int_vec_e
- *
- * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
- */
-#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
-#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
-#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
-#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
-#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
-#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
-#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
-#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
-#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
-#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
-#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
-
-/**
- * Register (RSL) mio_emm_access_wdog
- *
- * eMMC Access Watchdog Register
- */
-union mio_emm_access_wdog {
-	u64 u;
-	struct mio_emm_access_wdog_s {
-		u64 clk_cnt                          : 32;
-		u64 reserved_32_63                   : 32;
-	} s;
-	/* struct mio_emm_access_wdog_s cn; */
-};
-
-static inline u64 MIO_EMM_ACCESS_WDOG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_ACCESS_WDOG(void)
-{
-	return 0x20f0;
-}
-
-/**
- * Register (RSL) mio_emm_buf_dat
- *
- * eMMC Data Buffer Access Register
- */
-union mio_emm_buf_dat {
-	u64 u;
-	struct mio_emm_buf_dat_s {
-		u64 dat                              : 64;
-	} s;
-	/* struct mio_emm_buf_dat_s cn; */
-};
-
-static inline u64 MIO_EMM_BUF_DAT(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_BUF_DAT(void)
-{
-	return 0x20e8;
-}
-
-/**
- * Register (RSL) mio_emm_buf_idx
- *
- * eMMC Data Buffer Address Register
- */
-union mio_emm_buf_idx {
-	u64 u;
-	struct mio_emm_buf_idx_s {
-		u64 offset                           : 6;
-		u64 buf_num                          : 1;
-		u64 reserved_7_15                    : 9;
-		u64 inc                              : 1;
-		u64 reserved_17_63                   : 47;
-	} s;
-	/* struct mio_emm_buf_idx_s cn; */
-};
-
-static inline u64 MIO_EMM_BUF_IDX(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_BUF_IDX(void)
-{
-	return 0x20e0;
-}
-
-/**
- * Register (RSL) mio_emm_calb
- *
- * eMMC Calbration Register This register initiates delay line
- * characterization.
- */
-union mio_emm_calb {
-	u64 u;
-	struct mio_emm_calb_s {
-		u64 start                            : 1;
-		u64 reserved_1_63                    : 63;
-	} s;
-	/* struct mio_emm_calb_s cn; */
-};
-
-static inline u64 MIO_EMM_CALB(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_CALB(void)
-{
-	return 0x20c0;
-}
-
-/**
- * Register (RSL) mio_emm_cfg
- *
- * eMMC Configuration Register
- */
-union mio_emm_cfg {
-	u64 u;
-	struct mio_emm_cfg_s {
-		u64 bus_ena                          : 4;
-		u64 reserved_4_63                    : 60;
-	} s;
-	/* struct mio_emm_cfg_s cn; */
-};
-
-static inline u64 MIO_EMM_CFG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_CFG(void)
-{
-	return 0x2000;
-}
-
-/**
- * Register (RSL) mio_emm_cmd
- *
- * eMMC Command Register
- */
-union mio_emm_cmd {
-	u64 u;
-	struct mio_emm_cmd_s {
-		u64 arg                              : 32;
-		u64 cmd_idx                          : 6;
-		u64 rtype_xor                        : 3;
-		u64 ctype_xor                        : 2;
-		u64 reserved_43_48                   : 6;
-		u64 offset                           : 6;
-		u64 dbuf                             : 1;
-		u64 reserved_56_58                   : 3;
-		u64 cmd_val                          : 1;
-		u64 bus_id                           : 2;
-		u64 skip_busy                        : 1;
-		u64 reserved_63                      : 1;
-	} s;
-	/* struct mio_emm_cmd_s cn; */
-};
-
-static inline u64 MIO_EMM_CMD(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_CMD(void)
-{
-	return 0x2058;
-}
-
-/**
- * Register (RSL) mio_emm_comp
- *
- * eMMC Compensation Register
- */
-union mio_emm_comp {
-	u64 u;
-	struct mio_emm_comp_s {
-		u64 nctl                             : 3;
-		u64 reserved_3_7                     : 5;
-		u64 pctl                             : 3;
-		u64 reserved_11_63                   : 53;
-	} s;
-	/* struct mio_emm_comp_s cn; */
-};
-
-static inline u64 MIO_EMM_COMP(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_COMP(void)
-{
-	return 0x2040;
-}
-
-/**
- * Register (RSL) mio_emm_debug
- *
- * eMMC Debug Register
- */
-union mio_emm_debug {
-	u64 u;
-	struct mio_emm_debug_s {
-		u64 clk_on                           : 1;
-		u64 reserved_1_7                     : 7;
-		u64 cmd_sm                           : 4;
-		u64 data_sm                          : 4;
-		u64 dma_sm                           : 4;
-		u64 emmc_clk_disable                 : 1;
-		u64 rdsync_rst                       : 1;
-		u64 reserved_22_63                   : 42;
-	} s;
-	struct mio_emm_debug_cn96xxp1 {
-		u64 clk_on                           : 1;
-		u64 reserved_1_7                     : 7;
-		u64 cmd_sm                           : 4;
-		u64 data_sm                          : 4;
-		u64 dma_sm                           : 4;
-		u64 reserved_20_63                   : 44;
-	} cn96xxp1;
-	/* struct mio_emm_debug_s cn96xxp3; */
-	/* struct mio_emm_debug_s cn98xx; */
-	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
-	/* struct mio_emm_debug_s loki; */
-};
-
-static inline u64 MIO_EMM_DEBUG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DEBUG(void)
-{
-	return 0x20f8;
-}
-
-/**
- * Register (RSL) mio_emm_dma
- *
- * eMMC External DMA Configuration Register
- */
-union mio_emm_dma {
-	u64 u;
-	struct mio_emm_dma_s {
-		u64 card_addr                        : 32;
-		u64 block_cnt                        : 16;
-		u64 multi                            : 1;
-		u64 rw                               : 1;
-		u64 rel_wr                           : 1;
-		u64 thres                            : 6;
-		u64 dat_null                         : 1;
-		u64 sector                           : 1;
-		u64 dma_val                          : 1;
-		u64 bus_id                           : 2;
-		u64 skip_busy                        : 1;
-		u64 extra_args                       : 1;
-	} s;
-	struct mio_emm_dma_cn8 {
-		u64 card_addr                        : 32;
-		u64 block_cnt                        : 16;
-		u64 multi                            : 1;
-		u64 rw                               : 1;
-		u64 rel_wr                           : 1;
-		u64 thres                            : 6;
-		u64 dat_null                         : 1;
-		u64 sector                           : 1;
-		u64 dma_val                          : 1;
-		u64 bus_id                           : 2;
-		u64 skip_busy                        : 1;
-		u64 reserved_63                      : 1;
-	} cn8;
-	struct mio_emm_dma_cn9 {
-		u64 card_addr                        : 32;
-		u64 block_cnt                        : 16;
-		u64 multi                            : 1;
-		u64 rw                               : 1;
-		u64 reserved_50                      : 1;
-		u64 thres                            : 6;
-		u64 dat_null                         : 1;
-		u64 sector                           : 1;
-		u64 dma_val                          : 1;
-		u64 bus_id                           : 2;
-		u64 skip_busy                        : 1;
-		u64 extra_args                       : 1;
-	} cn9;
-};
-
-static inline u64 MIO_EMM_DMA(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA(void)
-{
-	return 0x2050;
-}
-
-/**
- * Register (RSL) mio_emm_dma_adr
- *
- * eMMC DMA Address Register This register sets the address for eMMC/SD
- * flash transfers to/from memory. Sixty-four-bit operations must be used
- * to access this register. This register is updated by the DMA hardware
- * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
- */
-union mio_emm_dma_adr {
-	u64 u;
-	struct mio_emm_dma_adr_s {
-		u64 adr                              : 53;
-		u64 reserved_53_63                   : 11;
-	} s;
-	struct mio_emm_dma_adr_cn8 {
-		u64 adr                              : 49;
-		u64 reserved_49_63                   : 15;
-	} cn8;
-	/* struct mio_emm_dma_adr_s cn9; */
-};
-
-static inline u64 MIO_EMM_DMA_ADR(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_ADR(void)
-{
-	return 0x188;
-}
-
-/**
- * Register (RSL) mio_emm_dma_arg
- *
- * eMMC External DMA Extra Arguments Register
- */
-union mio_emm_dma_arg {
-	u64 u;
-	struct mio_emm_dma_arg_s {
-		u64 cmd23_args                       : 8;
-		u64 force_pgm                        : 1;
-		u64 context_id                       : 4;
-		u64 tag_req                          : 1;
-		u64 pack_cmd                         : 1;
-		u64 rel_wr                           : 1;
-		u64 alt_cmd                          : 6;
-		u64 skip_blk_cmd                     : 1;
-		u64 reserved_23_31                   : 9;
-		u64 alt_cmd_arg                      : 32;
-	} s;
-	/* struct mio_emm_dma_arg_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_ARG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_ARG(void)
-{
-	return 0x2090;
-}
-
-/**
- * Register (RSL) mio_emm_dma_cfg
- *
- * eMMC DMA Configuration Register This register controls the internal
- * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
- * operations must be used to access this register. This register is
- * updated by the hardware DMA engine and can also be reloaded by writes
- * to the MIO_EMM_DMA_FIFO_CMD register.
- */
-union mio_emm_dma_cfg {
-	u64 u;
-	struct mio_emm_dma_cfg_s {
-		u64 reserved_0_35                    : 36;
-		u64 size                             : 20;
-		u64 endian                           : 1;
-		u64 swap8                            : 1;
-		u64 swap16                           : 1;
-		u64 swap32                           : 1;
-		u64 reserved_60                      : 1;
-		u64 clr                              : 1;
-		u64 rw                               : 1;
-		u64 en                               : 1;
-	} s;
-	/* struct mio_emm_dma_cfg_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_CFG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_CFG(void)
-{
-	return 0x180;
-}
-
-/**
- * Register (RSL) mio_emm_dma_fifo_adr
- *
- * eMMC Internal DMA FIFO Address Register This register specifies the
- * internal address that is loaded into the eMMC internal DMA FIFO. The
- * FIFO is used to queue up operations for the
- * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
- */
-union mio_emm_dma_fifo_adr {
-	u64 u;
-	struct mio_emm_dma_fifo_adr_s {
-		u64 reserved_0_2                     : 3;
-		u64 adr                              : 50;
-		u64 reserved_53_63                   : 11;
-	} s;
-	struct mio_emm_dma_fifo_adr_cn8 {
-		u64 reserved_0_2                     : 3;
-		u64 adr                              : 46;
-		u64 reserved_49_63                   : 15;
-	} cn8;
-	/* struct mio_emm_dma_fifo_adr_s cn9; */
-};
-
-static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
-{
-	return 0x170;
-}
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cfg
- *
- * eMMC Internal DMA FIFO Configuration Register This register controls
- * DMA FIFO operations.
- */
-union mio_emm_dma_fifo_cfg {
-	u64 u;
-	struct mio_emm_dma_fifo_cfg_s {
-		u64 count                            : 5;
-		u64 reserved_5_7                     : 3;
-		u64 int_lvl                          : 5;
-		u64 reserved_13_15                   : 3;
-		u64 clr                              : 1;
-		u64 reserved_17_63                   : 47;
-	} s;
-	/* struct mio_emm_dma_fifo_cfg_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
-{
-	return 0x160;
-}
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cmd
- *
- * eMMC Internal DMA FIFO Command Register This register specifies a
- * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
- * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
- * when the DMA completes successfully. Writes to this register store
- * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
- * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
- * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
- * exception that the EN and CLR fields are absent. These are supported
- * in MIO_EMM_DMA_FIFO_CFG.
- */
-union mio_emm_dma_fifo_cmd {
-	u64 u;
-	struct mio_emm_dma_fifo_cmd_s {
-		u64 reserved_0_35                    : 36;
-		u64 size                             : 20;
-		u64 endian                           : 1;
-		u64 swap8                            : 1;
-		u64 swap16                           : 1;
-		u64 swap32                           : 1;
-		u64 intdis                           : 1;
-		u64 reserved_61                      : 1;
-		u64 rw                               : 1;
-		u64 reserved_63                      : 1;
-	} s;
-	/* struct mio_emm_dma_fifo_cmd_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
-{
-	return 0x178;
-}
-
-/**
- * Register (RSL) mio_emm_dma_int
- *
- * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
- * access this register.
- */
-union mio_emm_dma_int {
-	u64 u;
-	struct mio_emm_dma_int_s {
-		u64 done                             : 1;
-		u64 fifo                             : 1;
-		u64 reserved_2_63                    : 62;
-	} s;
-	/* struct mio_emm_dma_int_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_INT(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_INT(void)
-{
-	return 0x190;
-}
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1c
- *
- * eMMC DMA Interrupt Enable Clear Register This register clears
- * interrupt enable bits.
- */
-union mio_emm_dma_int_ena_w1c {
-	u64 u;
-	struct mio_emm_dma_int_ena_w1c_s {
-		u64 done                             : 1;
-		u64 fifo                             : 1;
-		u64 reserved_2_63                    : 62;
-	} s;
-	/* struct mio_emm_dma_int_ena_w1c_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
-{
-	return 0x1a8;
-}
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1s
- *
- * eMMC DMA Interrupt Enable Set Register This register sets interrupt
- * enable bits.
- */
-union mio_emm_dma_int_ena_w1s {
-	u64 u;
-	struct mio_emm_dma_int_ena_w1s_s {
-		u64 done                             : 1;
-		u64 fifo                             : 1;
-		u64 reserved_2_63                    : 62;
-	} s;
-	/* struct mio_emm_dma_int_ena_w1s_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
-{
-	return 0x1a0;
-}
-
-/**
- * Register (RSL) mio_emm_dma_int_w1s
- *
- * eMMC DMA Interrupt Set Register This register sets interrupt bits.
- */
-union mio_emm_dma_int_w1s {
-	u64 u;
-	struct mio_emm_dma_int_w1s_s {
-		u64 done                             : 1;
-		u64 fifo                             : 1;
-		u64 reserved_2_63                    : 62;
-	} s;
-	/* struct mio_emm_dma_int_w1s_s cn; */
-};
-
-static inline u64 MIO_EMM_DMA_INT_W1S(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_DMA_INT_W1S(void)
-{
-	return 0x198;
-}
-
-/**
- * Register (RSL) mio_emm_int
- *
- * eMMC Interrupt Register
- */
-union mio_emm_int {
-	u64 u;
-	struct mio_emm_int_s {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 ncb_flt                          : 1;
-		u64 ncb_ras                          : 1;
-		u64 reserved_9_63                    : 55;
-	} s;
-	struct mio_emm_int_cn8 {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 reserved_7_63                    : 57;
-	} cn8;
-	/* struct mio_emm_int_s cn9; */
-};
-
-static inline u64 MIO_EMM_INT(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_INT(void)
-{
-	return 0x2078;
-}
-
-/**
- * Register (RSL) mio_emm_int_ena_w1c
- *
- * eMMC Interrupt Enable Clear Register This register clears interrupt
- * enable bits.
- */
-union mio_emm_int_ena_w1c {
-	u64 u;
-	struct mio_emm_int_ena_w1c_s {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 ncb_flt                          : 1;
-		u64 ncb_ras                          : 1;
-		u64 reserved_9_63                    : 55;
-	} s;
-	struct mio_emm_int_ena_w1c_cn8 {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 reserved_7_63                    : 57;
-	} cn8;
-	/* struct mio_emm_int_ena_w1c_s cn9; */
-};
-
-static inline u64 MIO_EMM_INT_ENA_W1C(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_INT_ENA_W1C(void)
-{
-	return 0x20b8;
-}
-
-/**
- * Register (RSL) mio_emm_int_ena_w1s
- *
- * eMMC Interrupt Enable Set Register This register sets interrupt enable
- * bits.
- */
-union mio_emm_int_ena_w1s {
-	u64 u;
-	struct mio_emm_int_ena_w1s_s {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 ncb_flt                          : 1;
-		u64 ncb_ras                          : 1;
-		u64 reserved_9_63                    : 55;
-	} s;
-	struct mio_emm_int_ena_w1s_cn8 {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 reserved_7_63                    : 57;
-	} cn8;
-	/* struct mio_emm_int_ena_w1s_s cn9; */
-};
-
-static inline u64 MIO_EMM_INT_ENA_W1S(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_INT_ENA_W1S(void)
-{
-	return 0x20b0;
-}
-
-/**
- * Register (RSL) mio_emm_int_w1s
- *
- * eMMC Interrupt Set Register This register sets interrupt bits.
- */
-union mio_emm_int_w1s {
-	u64 u;
-	struct mio_emm_int_w1s_s {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 ncb_flt                          : 1;
-		u64 ncb_ras                          : 1;
-		u64 reserved_9_63                    : 55;
-	} s;
-	struct mio_emm_int_w1s_cn8 {
-		u64 buf_done                         : 1;
-		u64 cmd_done                         : 1;
-		u64 dma_done                         : 1;
-		u64 cmd_err                          : 1;
-		u64 dma_err                          : 1;
-		u64 switch_done                      : 1;
-		u64 switch_err                       : 1;
-		u64 reserved_7_63                    : 57;
-	} cn8;
-	/* struct mio_emm_int_w1s_s cn9; */
-};
-
-static inline u64 MIO_EMM_INT_W1S(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_INT_W1S(void)
-{
-	return 0x2080;
-}
-
-/**
- * Register (RSL) mio_emm_io_ctl
- *
- * eMMC I/O Control Register
- */
-union mio_emm_io_ctl {
-	u64 u;
-	struct mio_emm_io_ctl_s {
-		u64 slew                             : 1;
-		u64 reserved_1                       : 1;
-		u64 drive                            : 2;
-		u64 reserved_4_63                    : 60;
-	} s;
-	/* struct mio_emm_io_ctl_s cn; */
-};
-
-static inline u64 MIO_EMM_IO_CTL(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_IO_CTL(void)
-{
-	return 0x2040;
-}
-
-/**
- * Register (RSL) mio_emm_mode#
- *
- * eMMC Operating Mode Register
- */
-union mio_emm_modex {
-	u64 u;
-	struct mio_emm_modex_s {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 clk_swap                         : 1;
-		u64 reserved_37_39                   : 3;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 hs200_timing                     : 1;
-		u64 hs400_timing                     : 1;
-		u64 reserved_51_63                   : 13;
-	} s;
-	struct mio_emm_modex_cn8 {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 reserved_49_63                   : 15;
-	} cn8;
-	struct mio_emm_modex_cn96xxp1 {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 hs200_timing                     : 1;
-		u64 hs400_timing                     : 1;
-		u64 reserved_51_63                   : 13;
-	} cn96xxp1;
-	/* struct mio_emm_modex_s cn96xxp3; */
-	/* struct mio_emm_modex_s cn98xx; */
-	/* struct mio_emm_modex_s cnf95xx; */
-	/* struct mio_emm_modex_s loki; */
-};
-
-static inline u64 MIO_EMM_MODEX(u64 a)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_MODEX(u64 a)
-{
-	return 0x2008 + 8 * a;
-}
-
-/**
- * Register (RSL) mio_emm_msix_pba#
- *
- * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
- * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
- */
-union mio_emm_msix_pbax {
-	u64 u;
-	struct mio_emm_msix_pbax_s {
-		u64 pend                             : 64;
-	} s;
-	/* struct mio_emm_msix_pbax_s cn; */
-};
-
-static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
-{
-	return 0xf0000 + 8 * a;
-}
-
-/**
- * Register (RSL) mio_emm_msix_vec#_addr
- *
- * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
- * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
- */
-union mio_emm_msix_vecx_addr {
-	u64 u;
-	struct mio_emm_msix_vecx_addr_s {
-		u64 secvec                           : 1;
-		u64 reserved_1                       : 1;
-		u64 addr                             : 51;
-		u64 reserved_53_63                   : 11;
-	} s;
-	struct mio_emm_msix_vecx_addr_cn8 {
-		u64 secvec                           : 1;
-		u64 reserved_1                       : 1;
-		u64 addr                             : 47;
-		u64 reserved_49_63                   : 15;
-	} cn8;
-	/* struct mio_emm_msix_vecx_addr_s cn9; */
-};
-
-static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
-{
-	return 0 + 0x10 * a;
-}
-
-/**
- * Register (RSL) mio_emm_msix_vec#_ctl
- *
- * eMMC MSI-X Vector-Table Control and Data Register This register is the
- * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
- */
-union mio_emm_msix_vecx_ctl {
-	u64 u;
-	struct mio_emm_msix_vecx_ctl_s {
-		u64 data                             : 32;
-		u64 mask                             : 1;
-		u64 reserved_33_63                   : 31;
-	} s;
-	struct mio_emm_msix_vecx_ctl_cn8 {
-		u64 data                             : 20;
-		u64 reserved_20_31                   : 12;
-		u64 mask                             : 1;
-		u64 reserved_33_63                   : 31;
-	} cn8;
-	/* struct mio_emm_msix_vecx_ctl_s cn9; */
-};
-
-static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
-{
-	return 8 + 0x10 * a;
-}
-
-/**
- * Register (RSL) mio_emm_rca
- *
- * eMMC Relative Card Address Register
- */
-union mio_emm_rca {
-	u64 u;
-	struct mio_emm_rca_s {
-		u64 card_rca                         : 16;
-		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct mio_emm_rca_s cn; */
-};
-
-static inline u64 MIO_EMM_RCA(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_RCA(void)
-{
-	return 0x20a0;
-}
-
-/**
- * Register (RSL) mio_emm_rsp_hi
- *
- * eMMC Response Data High Register
- */
-union mio_emm_rsp_hi {
-	u64 u;
-	struct mio_emm_rsp_hi_s {
-		u64 dat                              : 64;
-	} s;
-	/* struct mio_emm_rsp_hi_s cn; */
-};
-
-static inline u64 MIO_EMM_RSP_HI(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_RSP_HI(void)
-{
-	return 0x2070;
-}
-
-/**
- * Register (RSL) mio_emm_rsp_lo
- *
- * eMMC Response Data Low Register
- */
-union mio_emm_rsp_lo {
-	u64 u;
-	struct mio_emm_rsp_lo_s {
-		u64 dat                              : 64;
-	} s;
-	/* struct mio_emm_rsp_lo_s cn; */
-};
-
-static inline u64 MIO_EMM_RSP_LO(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_RSP_LO(void)
-{
-	return 0x2068;
-}
-
-/**
- * Register (RSL) mio_emm_rsp_sts
- *
- * eMMC Response Status Register
- */
-union mio_emm_rsp_sts {
-	u64 u;
-	struct mio_emm_rsp_sts_s {
-		u64 cmd_done                         : 1;
-		u64 cmd_idx                          : 6;
-		u64 cmd_type                         : 2;
-		u64 rsp_type                         : 3;
-		u64 rsp_val                          : 1;
-		u64 rsp_bad_sts                      : 1;
-		u64 rsp_crc_err                      : 1;
-		u64 rsp_timeout                      : 1;
-		u64 stp_val                          : 1;
-		u64 stp_bad_sts                      : 1;
-		u64 stp_crc_err                      : 1;
-		u64 stp_timeout                      : 1;
-		u64 rsp_busybit                      : 1;
-		u64 blk_crc_err                      : 1;
-		u64 blk_timeout                      : 1;
-		u64 dbuf                             : 1;
-		u64 reserved_24_27                   : 4;
-		u64 dbuf_err                         : 1;
-		u64 reserved_29_54                   : 26;
-		u64 acc_timeout                      : 1;
-		u64 dma_pend                         : 1;
-		u64 dma_val                          : 1;
-		u64 switch_val                       : 1;
-		u64 cmd_val                          : 1;
-		u64 bus_id                           : 2;
-		u64 reserved_62_63                   : 2;
-	} s;
-	/* struct mio_emm_rsp_sts_s cn; */
-};
-
-static inline u64 MIO_EMM_RSP_STS(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_RSP_STS(void)
-{
-	return 0x2060;
-}
-
-/**
- * Register (RSL) mio_emm_sample
- *
- * eMMC Sampling Register
- */
-union mio_emm_sample {
-	u64 u;
-	struct mio_emm_sample_s {
-		u64 dat_cnt                          : 10;
-		u64 reserved_10_15                   : 6;
-		u64 cmd_cnt                          : 10;
-		u64 reserved_26_63                   : 38;
-	} s;
-	/* struct mio_emm_sample_s cn; */
-};
-
-static inline u64 MIO_EMM_SAMPLE(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_SAMPLE(void)
-{
-	return 0x2090;
-}
-
-/**
- * Register (RSL) mio_emm_sts_mask
- *
- * eMMC Status Mask Register
- */
-union mio_emm_sts_mask {
-	u64 u;
-	struct mio_emm_sts_mask_s {
-		u64 sts_msk                          : 32;
-		u64 reserved_32_63                   : 32;
-	} s;
-	/* struct mio_emm_sts_mask_s cn; */
-};
-
-static inline u64 MIO_EMM_STS_MASK(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_STS_MASK(void)
-{
-	return 0x2098;
-}
-
-/**
- * Register (RSL) mio_emm_switch
- *
- * eMMC Operating Mode Switch Register This register allows software to
- * change eMMC related parameters associated with a specific BUS_ID.  The
- * MIO_EMM_MODE() registers contain the current setting for each BUS.
- * This register is also used to switch the [CLK_HI] and [CLK_LO]
- * settings associated with the common EMMC_CLK.  These settings can only
- * be changed when [BUS_ID] = 0.
- */
-union mio_emm_switch {
-	u64 u;
-	struct mio_emm_switch_s {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 clk_swap                         : 1;
-		u64 reserved_37_39                   : 3;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 hs200_timing                     : 1;
-		u64 hs400_timing                     : 1;
-		u64 reserved_51_55                   : 5;
-		u64 switch_err2                      : 1;
-		u64 switch_err1                      : 1;
-		u64 switch_err0                      : 1;
-		u64 switch_exe                       : 1;
-		u64 bus_id                           : 2;
-		u64 reserved_62_63                   : 2;
-	} s;
-	struct mio_emm_switch_cn8 {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 reserved_49_55                   : 7;
-		u64 switch_err2                      : 1;
-		u64 switch_err1                      : 1;
-		u64 switch_err0                      : 1;
-		u64 switch_exe                       : 1;
-		u64 bus_id                           : 2;
-		u64 reserved_62_63                   : 2;
-	} cn8;
-	struct mio_emm_switch_cn96xxp1 {
-		u64 clk_lo                           : 16;
-		u64 clk_hi                           : 16;
-		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
-		u64 bus_width                        : 3;
-		u64 reserved_43_47                   : 5;
-		u64 hs_timing                        : 1;
-		u64 hs200_timing                     : 1;
-		u64 hs400_timing                     : 1;
-		u64 reserved_51_55                   : 5;
-		u64 switch_err2                      : 1;
-		u64 switch_err1                      : 1;
-		u64 switch_err0                      : 1;
-		u64 switch_exe                       : 1;
-		u64 bus_id                           : 2;
-		u64 reserved_62_63                   : 2;
-	} cn96xxp1;
-	/* struct mio_emm_switch_s cn96xxp3; */
-	/* struct mio_emm_switch_s cn98xx; */
-	/* struct mio_emm_switch_s cnf95xx; */
-	/* struct mio_emm_switch_s loki; */
-};
-
-static inline u64 MIO_EMM_SWITCH(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_SWITCH(void)
-{
-	return 0x2048;
-}
-
-/**
- * Register (RSL) mio_emm_tap
- *
- * eMMC TAP Delay Register This register indicates the delay line
- * characteristics.
- */
-union mio_emm_tap {
-	u64 u;
-	struct mio_emm_tap_s {
-		u64 delay                            : 8;
-		u64 reserved_8_63                    : 56;
-	} s;
-	/* struct mio_emm_tap_s cn; */
-};
-
-static inline u64 MIO_EMM_TAP(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_TAP(void)
-{
-	return 0x20c8;
-}
-
-/**
- * Register (RSL) mio_emm_timing
- *
- * eMMC Timing Register This register determines the number of tap delays
- * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
- * relation to EMM_CLK. These values should only be changed when the eMMC
- * bus is idle.
- */
-union mio_emm_timing {
-	u64 u;
-	struct mio_emm_timing_s {
-		u64 data_out_tap                     : 6;
-		u64 reserved_6_15                    : 10;
-		u64 data_in_tap                      : 6;
-		u64 reserved_22_31                   : 10;
-		u64 cmd_out_tap                      : 6;
-		u64 reserved_38_47                   : 10;
-		u64 cmd_in_tap                       : 6;
-		u64 reserved_54_63                   : 10;
-	} s;
-	/* struct mio_emm_timing_s cn; */
-};
-
-static inline u64 MIO_EMM_TIMING(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_TIMING(void)
-{
-	return 0x20d0;
-}
-
-/**
- * Register (RSL) mio_emm_wdog
- *
- * eMMC Watchdog Register
- */
-union mio_emm_wdog {
-	u64 u;
-	struct mio_emm_wdog_s {
-		u64 clk_cnt                          : 26;
-		u64 reserved_26_63                   : 38;
-	} s;
-	/* struct mio_emm_wdog_s cn; */
-};
-
-static inline u64 MIO_EMM_WDOG(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 MIO_EMM_WDOG(void)
-{
-	return 0x2088;
-}
-
-#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2.h b/arch/arm/include/asm/arch-octeontx2/octeontx2.h
deleted file mode 100644
index fc20de2fd6..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/octeontx2.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef __OCTEONTX2_H__
-#define __OCTEONTX2_H__
-
-#define CN98XX	0xB1
-#define CN96XX	0xB2
-#define CN95XX	0xB3
-#define LOKI	0xB4
-
-#define is_board_model(model)	(g_cavm_bdt.prod_id == (model))
-
-/** Reg offsets */
-#define CAVM_RST_BOOT		0x87E006001600ULL
-#define CAVM_RST_CHIP_DOM_W1S	0x87E006001810ULL
-
-#define CAVM_CPC_BOOT_OWNERX(a)	0x86D000000160ULL + (8 * a)
-
-#define CAVM_GTI_CWD_POKEX	0x802000050000ULL
-#define CAVM_GTI_CWD_WDOGX	0x802000040000ULL
-
-/* attestation definitions shared with ATF (see 'plat_octeontx.h') */
-
-#define ATTESTATION_MAGIC_ID 0x5f415454 /* "_ATT" */
-
-enum sw_attestation_tlv_type {
-	ATT_IMG_INIT_BIN,
-	ATT_IMG_ATF_BL1,
-	ATT_IMG_BOARD_DT,
-	ATT_IMG_LINUX_DT,
-	ATT_IMG_SCP_TBL1FW,
-	ATT_IMG_MCP_TBL1FW,
-	ATT_IMG_AP_TBL1FW,
-	ATT_IMG_ATF_BL2,
-	ATT_IMG_ATF_BL31,
-	ATT_IMG_ATF_BL33,
-	ATT_SIG_NONCE,
-
-	ATT_TLV_TYPE_COUNT,
-};
-
-typedef struct sw_attestation_tlv {
-	u16 type_be;   /* sw_attestation_tlv_type */
-	u16 length_be;
-	u8 value[0];   /* array of 'length_be' bytes */
-} sw_attestation_tlv_t;
-
-#define SW_ATT_INFO_NONCE_MAX_LEN  256
-
-typedef struct sw_attestation_info_hdr {
-	u32 magic_be;
-	u16 tlv_len_be;
-	u16 total_len_be;
-	u16 certificate_len_be;
-	u16 signature_len_be;
-	union {
-		sw_attestation_tlv_t tlv_list[0];
-		s8 input_nonce[0];
-	};
-} __packed sw_attestation_info_hdr_t;
-
-/** Structure definitions */
-/**
- * Register (NCB32b) cpc_boot_owner#
- *
- * CPC Boot Owner Registers These registers control an external arbiter
- * for the boot device (SPI/eMMC) across multiple external devices. There
- * is a register for each requester: _ \<0\> - SCP          - reset on
- * SCP reset _ \<1\> - MCP          - reset on MCP reset _ \<2\> - AP
- * Secure    - reset on core reset _ \<3\> - AP Nonsecure - reset on core
- * reset  These register is only writable to the corresponding
- * requestor(s) permitted with CPC_PERMIT.
- */
-union cavm_cpc_boot_ownerx {
-        u32 u;
-        struct cavm_cpc_boot_ownerx_s {
-                u32 boot_req                         : 1;
-                u32 reserved_1_7                     : 7;
-                u32 boot_wait                        : 1;
-                u32 reserved_9_31                    : 23;
-        } s;
-        /* struct cavm_cpc_boot_ownerx_s cn; */
-};
-
-
-/** Function definitions */
-void octeontx2_parse_board_info(void);
-void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr);
-void acquire_flash_arb(bool acquire);
-
-/** Board data definitions */
-struct cavm_bdt {
-	u8 resv[6];
-	u8 prod_id;
-	u8 alt_pkg;
-	char type[16];
-};
-extern struct cavm_bdt g_cavm_bdt;
-
-#endif /* __OCTEONTX2_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h b/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
deleted file mode 100644
index fb406c6312..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef __OCTEONTX2_FDT_H__
-#define __OCTEONTX2_FDT_H__
-
-
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h b/arch/arm/include/asm/arch-octeontx2/smc-id.h
similarity index 80%
rename from arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h
rename to arch/arm/include/asm/arch-octeontx2/smc-id.h
index 4dc3edabe4..791363a2cb 100644
--- a/arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h
+++ b/arch/arm/include/asm/arch-octeontx2/smc-id.h
@@ -1,16 +1,16 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-#ifndef __OCTEONTX2_SVC_H__
-#define __OCTEONTX2_SVC_H__
+#ifndef __SMC_ID_H__
+#define __SMC_ID_H__
 
 /* SMC function IDs for general purpose queries */
 
-#define OCTEONTX2_SVC_CALL_COUNT		0xc200ff00
+#define OCTEONTX2_SVC_CALL_COUNT	0xc200ff00
 #define OCTEONTX2_SVC_UID		0xc200ff01
 
 #define OCTEONTX2_SVC_VERSION		0xc200ff03
@@ -19,8 +19,7 @@
 #define OCTEONTX2_VERSION_MAJOR	0x1
 #define OCTEONTX2_VERSION_MINOR	0x0
 
-/* x1 - node number
- */
+/* x1 - node number */
 #define OCTEONTX2_DRAM_SIZE		0xc2000301
 #define OCTEONTX2_NODE_COUNT		0xc2000601
 #define OCTEONTX2_DISABLE_RVU_LFS	0xc2000b01
@@ -39,4 +38,4 @@
  */
 #define OCTEONTX_ATTESTATION_QUERY	0xc2000d03
 
-#endif /* __OCTEONTX2_SVC_H__ */
+#endif /* __SMC_ID_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/smc.h b/arch/arm/include/asm/arch-octeontx2/smc.h
new file mode 100644
index 0000000000..e0a9efbddb
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/smc.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SMC_H__
+#define __SMC_H__
+
+#include <asm/arch/smc-id.h>
+
+ssize_t smc_configure_ooo(unsigned int val);
+ssize_t smc_dram_size(unsigned int node);
+ssize_t smc_disable_rvu_lfs(unsigned int node);
+ssize_t smc_flsf_fw_booted(void);
+ssize_t smc_flsf_clr_force_2ndry(void);
+ssize_t smc_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+			  int reg);
+ssize_t smc_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+			   int reg, int val);
+ssize_t smc_attest(long nonce_len);
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/soc.h b/arch/arm/include/asm/arch-octeontx2/soc.h
new file mode 100644
index 0000000000..775f742f3b
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/soc.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SOC_H__
+#define __SOC_H__
+
+/* Product PARTNUM */
+#define CN98XX	0xB1
+#define CN96XX	0xB2
+#define CN95XX	0xB3
+#define LOKI	0xB4
+
+/* Register defines */
+
+#define otx_is_soc(soc)	(read_partnum() == (soc))
+#define otx_is_board(model) (!strcmp(read_board_name(), model))
+#define otx_is_platform(platform) (read_platform() == (platform))
+
+typedef enum {
+	PLATFORM_HW = 0,
+	PLATFORM_EMULATOR = 1,
+	PLATFORM_ASIM = 3,
+} platform_t;
+
+platform_t read_platform(void);
+u8 read_partnum(void);
+const char *read_board_name(void);
+
+#endif /* __SOC_H */
diff --git a/arch/arm/mach-octeontx/clock.c b/arch/arm/mach-octeontx/clock.c
index 8b8b046d20..9da21077ec 100644
--- a/arch/arm/mach-octeontx/clock.c
+++ b/arch/arm/mach-octeontx/clock.c
@@ -7,6 +7,7 @@
 
 #include <common.h>
 #include <asm/io.h>
+#include <asm/arch/board.h>
 #include <asm/arch/clock.h>
 
 /**
@@ -14,7 +15,7 @@
  */
 u64 octeontx_get_io_clock(void)
 {
-	union cavm_rst_boot rst_boot;
+	union rst_boot rst_boot;
 
 	rst_boot.u = readq(RST_BOOT);
 
@@ -26,7 +27,7 @@ u64 octeontx_get_io_clock(void)
  */
 u64 octeontx_get_core_clock(void)
 {
-	union cavm_rst_boot rst_boot;
+	union rst_boot rst_boot;
 
 	rst_boot.u = readq(RST_BOOT);
 
diff --git a/arch/arm/mach-octeontx/cpu.c b/arch/arm/mach-octeontx/cpu.c
index 96b0982dab..f111501b8f 100644
--- a/arch/arm/mach-octeontx/cpu.c
+++ b/arch/arm/mach-octeontx/cpu.c
@@ -15,7 +15,7 @@ static struct mm_region octeontx_mem_map[] = {
 	{
 		.virt = 0x0UL,
 		.phys = 0x0UL,
-		.size = 0x40000000000UL,
+		.size = 0x4000000000UL,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_NON_SHARE
 	}, {
diff --git a/arch/arm/mach-octeontx/lowlevel_init.S b/arch/arm/mach-octeontx/lowlevel_init.S
index 18b7d3956b..41a9f08aed 100644
--- a/arch/arm/mach-octeontx/lowlevel_init.S
+++ b/arch/arm/mach-octeontx/lowlevel_init.S
@@ -7,8 +7,6 @@
 
 #include <config.h>
 #include <linux/linkage.h>
-#include <asm/arch/octeontx_svc.h>
-
 #include <asm/macro.h>
 
 .align 8
@@ -33,4 +31,3 @@ ENTRY(lowlevel_init)
 	mov	lr, x29			/* Restore LR */
 	ret
 ENDPROC(lowlevel_init)
-
diff --git a/arch/arm/mach-octeontx2/clock.c b/arch/arm/mach-octeontx2/clock.c
index 8b8b046d20..9da21077ec 100644
--- a/arch/arm/mach-octeontx2/clock.c
+++ b/arch/arm/mach-octeontx2/clock.c
@@ -7,6 +7,7 @@
 
 #include <common.h>
 #include <asm/io.h>
+#include <asm/arch/board.h>
 #include <asm/arch/clock.h>
 
 /**
@@ -14,7 +15,7 @@
  */
 u64 octeontx_get_io_clock(void)
 {
-	union cavm_rst_boot rst_boot;
+	union rst_boot rst_boot;
 
 	rst_boot.u = readq(RST_BOOT);
 
@@ -26,7 +27,7 @@ u64 octeontx_get_io_clock(void)
  */
 u64 octeontx_get_core_clock(void)
 {
-	union cavm_rst_boot rst_boot;
+	union rst_boot rst_boot;
 
 	rst_boot.u = readq(RST_BOOT);
 
diff --git a/arch/arm/mach-octeontx2/cpu.c b/arch/arm/mach-octeontx2/cpu.c
index ad9a50264b..a6eaa9112f 100644
--- a/arch/arm/mach-octeontx2/cpu.c
+++ b/arch/arm/mach-octeontx2/cpu.c
@@ -15,7 +15,7 @@ static struct mm_region octeontx2_mem_map[] = {
 	{
 		.virt = 0x0UL,
 		.phys = 0x0UL,
-		.size = 0x40000000000UL,
+		.size = 0x4000000000UL,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_NON_SHARE
 	}, {
diff --git a/arch/arm/mach-octeontx2/lowlevel_init.S b/arch/arm/mach-octeontx2/lowlevel_init.S
index 66583108aa..41a9f08aed 100644
--- a/arch/arm/mach-octeontx2/lowlevel_init.S
+++ b/arch/arm/mach-octeontx2/lowlevel_init.S
@@ -31,4 +31,3 @@ ENTRY(lowlevel_init)
 	mov	lr, x29			/* Restore LR */
 	ret
 ENDPROC(lowlevel_init)
-
diff --git a/board/Marvell/octeontx/MAINTAINERS b/board/Marvell/octeontx/MAINTAINERS
index 7cd0e6029e..10816c7a03 100644
--- a/board/Marvell/octeontx/MAINTAINERS
+++ b/board/Marvell/octeontx/MAINTAINERS
@@ -1,5 +1,9 @@
 OCTEONTX BOARD
-M:	Sergey Temerkhanov <s.temerkhanov@gmail.com>
-M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+M:	Suneel Garapati <sgarapati@marvell.com>
+M:	Aaron Williams <awilliams@marvell.com>
 S:	Maintained
 F:	board/Marvell/octeontx/
+F:	include/configs/octeontx_81xx.h
+F:	include/configs/octeontx_83xx.h
+F:	configs/octeontx_81xx_defconfig
+F:	configs/octeontx_83xx_defconfig
diff --git a/board/Marvell/octeontx/Makefile b/board/Marvell/octeontx/Makefile
index 331a849b80..fbe32ae003 100644
--- a/board/Marvell/octeontx/Makefile
+++ b/board/Marvell/octeontx/Makefile
@@ -5,5 +5,5 @@
 # * https://spdx.org/licenses
 # */
 
-obj-y	:= octeontx.o atf.o
-obj-$(CONFIG_OF_LIBFDT) += fdt.o
+obj-y	:= board.o smc.o soc-utils.o
+obj-$(CONFIG_OF_LIBFDT) += board-fdt.o
diff --git a/board/Marvell/octeontx/board-fdt.c b/board/Marvell/octeontx/board-fdt.c
new file mode 100644
index 0000000000..9e1c8f5d81
--- /dev/null
+++ b/board/Marvell/octeontx/board-fdt.c
@@ -0,0 +1,271 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+#ifdef CONFIG_NET_OCTEONTX
+static int fdt_get_mdio_bus(const void *fdt, int phy_offset)
+{
+	int node, bus = -1;
+	const u64 *reg;
+	u64 addr;
+
+	if (phy_offset < 0)
+		return -1;
+	/* obtain mdio node and get the reg prop */
+	node = fdt_parent_offset(fdt, phy_offset);
+	if (node < 0)
+		return -1;
+
+	reg = fdt_getprop(fdt, node, "reg", NULL);
+	addr = fdt64_to_cpu(*reg);
+	bus = (addr & (1 << 7)) ? 1 : 0;
+	return bus;
+}
+
+static int fdt_get_phy_addr(const void *fdt, int phy_offset)
+{
+	const u32 *reg;
+	int addr = -1;
+
+	if (phy_offset < 0)
+		return -1;
+	reg = fdt_getprop(fdt, phy_offset, "reg", NULL);
+	addr = fdt32_to_cpu(*reg);
+	return addr;
+}
+
+void fdt_parse_phy_info(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int offset = 0, node, bgx_id = 0, lmacid = 0;
+	const u32 *val;
+	char bgxname[24];
+	int len, rgx_id = 0, eth_id = 0;
+	int phandle, phy_offset;
+	int subnode, i;
+	int bdknode;
+
+	bdknode = fdt_path_offset(fdt, "/cavium,bdk");
+	if (bdknode < 0) {
+		printf("%s: bdk node is missing from device tree: %s\n",
+		       __func__, fdt_strerror(bdknode));
+	}
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 1)
+		return;
+
+	for (bgx_id = 0; bgx_id < MAX_BGX_PER_NODE; bgx_id++) {
+		int phy_addr[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
+		bool autoneg_dis[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+		int mdio_bus[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
+		bool lmac_reg[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+		bool lmac_enable[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx_id);
+		node = fdt_subnode_offset(fdt, offset, bgxname);
+		if (node < 0) {
+			/* check if it is rgx node */
+			snprintf(bgxname, sizeof(bgxname), "rgx%d", rgx_id);
+			node = fdt_subnode_offset(fdt, offset, bgxname);
+			if (node < 0) {
+				debug("bgx%d/rgx0 node not found\n", bgx_id);
+				return;
+			}
+		}
+		debug("bgx%d node found\n", bgx_id);
+
+		/*
+		 * loop through each of the bgx/rgx nodes
+		 * to find PHY nodes
+		 */
+		fdt_for_each_subnode(subnode, fdt, node) {
+			/* Check for reg property */
+			val = fdt_getprop(fdt, subnode, "reg", &len);
+			if (val) {
+				debug("lmacid = %d\n", lmacid);
+				lmac_reg[lmacid] = 1;
+			}
+			/* check for phy-handle property */
+			val = fdt_getprop(fdt, subnode, "phy-handle", &len);
+			if (val) {
+				phandle = fdt32_to_cpu(*val);
+				if (!phandle) {
+					debug("phandle not valid %d\n", lmacid);
+				} else {
+					phy_offset = fdt_node_offset_by_phandle
+							(fdt, phandle);
+					phy_addr[lmacid] = fdt_get_phy_addr
+							(fdt, phy_offset);
+					mdio_bus[lmacid] = fdt_get_mdio_bus
+							(fdt, phy_offset);
+					}
+				} else {
+					debug("phy-handle prop not found %d\n",
+					      lmacid);
+				}
+				/* check for autonegotiation property */
+				val = fdt_getprop(fdt, subnode,
+						  "cavium,disable-autonegotiation",
+						  &len);
+				if (val)
+					autoneg_dis[lmacid] = 1;
+
+				eth_id++;
+				lmacid++;
+			}
+
+			for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
+				const char *str;
+
+				snprintf(bgxname, sizeof(bgxname),
+					 "BGX-ENABLE.N0.BGX%d.P%d", bgx_id, i);
+				if (bdknode >= 0) {
+					str = fdt_getprop(fdt, bdknode,
+							  bgxname, &len);
+					if (str)
+						lmac_enable[i] =
+							simple_strtol(str, NULL,
+								      10);
+				}
+			}
+
+			lmacid = 0;
+			bgx_set_board_info(bgx_id, mdio_bus, phy_addr,
+					   autoneg_dis, lmac_reg, lmac_enable);
+		}
+}
+#endif
+
+const char *fdt_get_board_model(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int ret, node, len = 16;
+	const char *str = NULL;
+
+	if (!fdt) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return NULL;
+	}
+
+	ret = fdt_check_header(fdt);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return NULL;
+	}
+
+	node = fdt_path_offset(fdt, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return NULL;
+	}
+
+	str = fdt_getprop(fdt, node, "BOARD-MODEL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board model from fdt\n");
+	return str;
+}
+
+void fdt_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
+{
+	const void *fdt = gd->fdt_blob;
+	const char *mac = NULL;
+	int offset = 0, node, len;
+	int subnode, i = 0;
+	char bgxname[24];
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 0) {
+		printf("%s couldn't find mrml bridge node in fdt\n",
+		       __func__);
+		return;
+	}
+	if (bgx == 2 && otx_is_soc(CN81XX)) {
+		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
+		lmac = 0;
+	} else {
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx);
+	}
+
+	node = fdt_subnode_offset(fdt, offset, bgxname);
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		if (i++ != lmac)
+			continue;
+		/* check for local-mac-address */
+		mac = fdt_getprop(fdt, subnode, "local-mac-address", &len);
+		if (mac) {
+			debug("%s mac %pM\n", __func__, mac);
+			memcpy(eth, mac, ARP_HLEN);
+		} else {
+			memset(eth, 0, ARP_HLEN);
+		}
+		debug("%s eth %pM\n", __func__, eth);
+		return;
+	}
+}
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* remove "cavium, bdk" node from DT */
+	int ret = 0, offset;
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob) {
+		offset = fdt_path_offset(blob, "/cavium,bdk");
+		if (offset < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return offset;
+		}
+
+		/* delete node */
+		ret = fdt_del_node(blob, offset);
+		if (ret < 0) {
+			printf("WARNING : could not remove bdk node\n");
+			return ret;
+		}
+
+		debug("%s deleted bdk node\n", __func__);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx/board.c b/board/Marvell/octeontx/board.c
new file mode 100644
index 0000000000..45758772c1
--- /dev/null
+++ b/board/Marvell/octeontx/board.c
@@ -0,0 +1,146 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+extern unsigned long fdt_base_addr;
+
+void octeontx_cleanup_ethaddr(void)
+{
+	char ename[32];
+
+	for (int i = 0; i < 20; i++) {
+		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
+		if (env_get(ename))
+			env_set(ename, NULL);
+	}
+}
+
+int octeontx_board_has_pmp(void)
+{
+	return (otx_is_board("sff8104") || otx_is_board("nas8104"));
+}
+
+int board_early_init_r(void)
+{
+	pci_init();
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_NET_OCTEONTX
+	fdt_parse_phy_info();
+#endif
+	return 0;
+}
+
+int timer_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = smc_dram_size(0);
+	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_OCTEONTX
+void board_late_probe_devices(void)
+{
+	struct udevice *dev;
+	int err, bgx_cnt, i;
+
+	/* Probe MAC(BGX) and NIC PF devices before Network stack init */
+	bgx_cnt = otx_is_soc(CN81XX) ? 2 : 4;
+	for (i = 0; i < bgx_cnt; i++) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA026, i,
+					 &dev);
+		if (err)
+			debug("%s BGX%d device not found\n", __func__, i);
+	}
+	if (otx_is_soc(CN81XX)) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA054, 0,
+					 &dev);
+		if (err)
+			debug("%s RGX device not found\n", __func__);
+	}
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA01E, 0, &dev);
+	if (err)
+		debug("NIC PF device not found\n");
+}
+#endif
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[32];
+
+	/*
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of network interfaces can change.
+	 */
+	octeontx_cleanup_ethaddr();
+
+	snprintf(boardname, sizeof(boardname), "%s> ", fdt_get_board_model());
+	env_set("prompt", boardname);
+
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+
+#ifdef CONFIG_NET_OCTEONTX
+	board_late_probe_devices();
+#endif
+	return 0;
+}
+
+/*
+ * Invoked before relocation, so limit to stack variables.
+ */
+int show_board_info(void)
+{
+	char *str = NULL;
+
+	if (otx_is_soc(CN81XX))
+		str = "CN81XX";
+	if (otx_is_soc(CN83XX))
+		str = "CN83XX";
+	printf("OcteonTX %s ARM V8 Core\n", str);
+
+	printf("Board: %s\n", fdt_get_board_model());
+
+	return 0;
+}
+
+#ifdef CONFIG_HW_WATCHDOG
+void hw_watchdog_reset(void)
+{
+	writeq(~0ULL, GTI_CWD_POKEX);
+}
+
+void hw_watchdog_disable(void)
+{
+	writeq(0ULL, GTI_CWD_WDOGX);
+}
+#endif
diff --git a/board/Marvell/octeontx/fdt.c b/board/Marvell/octeontx/fdt.c
deleted file mode 100644
index 2a43cfdb66..0000000000
--- a/board/Marvell/octeontx/fdt.c
+++ /dev/null
@@ -1,212 +0,0 @@
-// SPDX-License-Identifier:    GPL-2.0
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <errno.h>
-#include <environment.h>
-#include <asm/io.h>
-#include <linux/compiler.h>
-#include <linux/libfdt.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <asm/arch/atf.h>
-#include <asm/arch/octeontx.h>
-#include <asm/arch/octeontx_vnic.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-extern unsigned long fdt_base_addr;
-
-#ifdef CONFIG_NET_OCTEONTX
-static int octeontx_get_mdio_bus(const void *fdt, int phy_offset)
-{
-	int node, bus = -1;
-	const u64 *reg;
-	u64 addr;
-
-	if (phy_offset < 0)
-		return -1;
-	/* obtain mdio node and get the reg prop */
-	node = fdt_parent_offset(fdt, phy_offset);
-	if (node < 0)
-		return -1;
-
-	reg = fdt_getprop(fdt, node, "reg", NULL);
-	addr = fdt64_to_cpu(*reg);
-	bus = (addr & (1 << 7)) ? 1 : 0;
-	return bus;
-}
-
-static int octeontx_get_phy_addr(const void *fdt, int phy_offset)
-{
-	const u32 *reg;
-	int addr = -1;
-
-	if (phy_offset < 0)
-		return -1;
-	reg = fdt_getprop(fdt, phy_offset, "reg", NULL);
-	addr = fdt32_to_cpu(*reg);
-	return addr;
-}
-#endif
-
-void octeontx_parse_phy_info(void)
-{
-#ifdef CONFIG_NET_OCTEONTX
-	const void *fdt = gd->fdt_blob;
-	int offset = 0, node, bgx_id = 0, lmacid = 0;
-	const u32 *val;
-	char bgxname[24];
-	int len, rgx_id = 0, eth_id = 0;
-	int phandle, phy_offset;
-	int subnode, i;
-	int bgxnode;
-
-	bgxnode = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	if (bgxnode < 0) {
-		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-		       __func__, fdt_strerror(bgxnode));
-	}
-
-	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
-	if (offset > 1) {
-		for (bgx_id = 0; bgx_id < MAX_BGX_PER_NODE; bgx_id++) {
-			int phy_addr[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
-			bool autoneg_dis[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
-			int mdio_bus[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
-			bool lmac_reg[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
-			bool lmac_enable[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
-
-			snprintf(bgxname, sizeof(bgxname),
-				 "bgx%d", bgx_id);
-			node = fdt_subnode_offset(fdt, offset, bgxname);
-			if (node < 0) {
-				/* check if it is rgx node */
-				snprintf(bgxname, sizeof(bgxname),
-					 "rgx%d", rgx_id);
-				node = fdt_subnode_offset(fdt, offset, bgxname);
-				if (node < 0) {
-					debug("bgx%d/rgx0 node not found\n",
-					      bgx_id);
-					return;
-				}
-			}
-			debug("bgx%d node found\n", bgx_id);
-
-			/*
-			 * loop through each of the bgx/rgx nodes
-			 * to find PHY nodes
-			 */
-			fdt_for_each_subnode(subnode, fdt, node) {
-				/* Check for reg property */
-				val = fdt_getprop(fdt, subnode, "reg",
-						  &len);
-
-				if (val) {
-					debug("lmacid = %d\n", lmacid);
-					lmac_reg[lmacid] = 1;
-				}
-				/* check for phy-handle property */
-				val = fdt_getprop(fdt, subnode, "phy-handle",
-						  &len);
-				if (val) {
-					phandle = fdt32_to_cpu(*val);
-					if (!phandle) {
-						debug("phandle not valid %d\n",
-						      lmacid);
-					} else {
-						phy_offset =
-						fdt_node_offset_by_phandle
-							(fdt, phandle);
-						phy_addr[lmacid] =
-						octeontx_get_phy_addr
-							(fdt, phy_offset);
-
-						mdio_bus[lmacid] =
-						octeontx_get_mdio_bus
-							(fdt, phy_offset);
-					}
-				} else {
-					debug("phy-handle property not found %d\n",
-					      lmacid);
-				}
-				/* check for autonegotiation property */
-				val = fdt_getprop(fdt, subnode,
-						  "cavium,disable-autonegotiation",
-						  &len);
-				if (val)
-					autoneg_dis[lmacid] = 1;
-
-				eth_id++;
-				lmacid++;
-			}
-
-			for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
-				const char *str;
-
-				snprintf(bgxname, sizeof(bgxname), "BGX-ENABLE.N0.BGX%d.P%d", bgx_id, i);
-				if (bgxnode >= 0) {
-					str = fdt_getprop(gd->fdt_blob, bgxnode, bgxname, &len);
-					if (str)
-						lmac_enable[i] = simple_strtol(str, NULL, 10);
-				}
-			}
-
-			lmacid = 0;
-			bgx_set_board_info(bgx_id, mdio_bus, phy_addr,
-					   autoneg_dis, lmac_reg, lmac_enable);
-		}
-	}
-#endif
-}
-
-int arch_fixup_memory_node(void *blob)
-{
-	return 0;
-}
-
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	/* remove "cavium, bdk" node from DT */
-	int ret = 0, offset;
-
-	ret = fdt_check_header(blob);
-	if (ret < 0) {
-		printf("ERROR: %s\n", fdt_strerror(ret));
-		return ret;
-	}
-
-	if (blob) {
-		offset = fdt_path_offset(blob, "/cavium,bdk");
-		if (offset < 0) {
-			printf("ERROR: FDT BDK node not found\n");
-			return offset;
-		}
-
-		/* delete node */
-		ret = fdt_del_node(blob, offset);
-		if (ret < 0) {
-			printf("WARNING : could not remove cavium, bdk node\n");
-			return ret;
-		}
-
-		debug("%s deleted 'cavium,bdk' node\n", __func__);
-	}
-
-	return 0;
-}
-
-/**
- * Return the FDT base address that was passed by ATF
- *
- * @return	FDT base address received from ATF in x1 register
- */
-void *board_fdt_blob_setup(void)
-{
-	return (void *)fdt_base_addr;
-}
diff --git a/board/Marvell/octeontx/octeontx.c b/board/Marvell/octeontx/octeontx.c
deleted file mode 100644
index c5f1ceac7c..0000000000
--- a/board/Marvell/octeontx/octeontx.c
+++ /dev/null
@@ -1,263 +0,0 @@
-// SPDX-License-Identifier:    GPL-2.0
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#include <common.h>
-#include <dm.h>
-#include <malloc.h>
-#include <errno.h>
-#include <netdev.h>
-#include <asm/io.h>
-#include <linux/compiler.h>
-#include <linux/libfdt.h>
-#include <fdt_support.h>
-#include <asm/arch/atf.h>
-#include <asm/arch/octeontx.h>
-#include <dm/util.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-struct cavm_bdt g_cavm_bdt;
-
-extern unsigned long fdt_base_addr;
-extern void eth_common_init(void);
-
-void octeontx_cleanup_ethaddr(void)
-{
-	char ename[32];
-
-	for (int i = 0; i < 20; i++) {
-		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
-		if (env_get(ename))
-			env_set(ename, NULL);
-	}
-}
-
-void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
-{
-	const void *fdt = gd->fdt_blob;
-	const char *mac = NULL;
-	int offset = 0, node, len;
-	int subnode, i = 0;
-	char bgxname[24];
-
-	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
-	if (offset < 0) {
-		printf("%s couldn't find mrml bridge node in fdt\n",
-		       __func__);
-		return;
-	}
-	if (bgx == 2 && is_board_model(CN81XX)) {
-		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
-		lmac = 0;
-	} else {
-		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx);
-	}
-
-	node = fdt_subnode_offset(fdt, offset, bgxname);
-
-	fdt_for_each_subnode(subnode, fdt, node) {
-		if (i++ != lmac)
-			continue;
-		/* check for local-mac-address */
-		mac = fdt_getprop(fdt, subnode, "local-mac-address", &len);
-		if (mac) {
-			debug("%s mac %pM\n", __func__, mac);
-			memcpy(eth, mac, ARP_HLEN);
-		} else {
-			memset(eth, 0, ARP_HLEN);
-		}
-		debug("%s eth %pM\n", __func__, eth);
-		return;
-	}
-}
-
-int octeontx_board_has_pmp(void)
-{
-	if ((strcasecmp(g_cavm_bdt.type, "sff8104") == 0) ||
-	    (strcasecmp(g_cavm_bdt.type, "nas8104") == 0))
-		return 1;
-
-	return 0;
-}
-
-void octeontx_parse_board_info(void)
-{
-	const char *str;
-	int node;
-	int ret = 0, len = 16;
-	u64 midr, val;
-
-	debug("%s: ENTER\n", __func__);
-
-	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
-
-	g_cavm_bdt.prod_id = (midr >> 4) & 0xff;
-
-	val = readq(CAVM_MIO_FUS_DAT2);
-	g_cavm_bdt.alt_pkg = (val >> 22) & 0x3;
-	if (g_cavm_bdt.prod_id == CN81XX &&
-	    (g_cavm_bdt.alt_pkg || ((val >> 30) & 0x1)))
-		g_cavm_bdt.alt_pkg = 2;
-
-	if (!gd->fdt_blob) {
-		printf("ERROR: %s: no valid device tree found\n", __func__);
-		return;
-	}
-
-	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
-	ret = fdt_check_header(gd->fdt_blob);
-	if (ret < 0) {
-		printf("fdt: %s\n", fdt_strerror(ret));
-		return;
-	}
-	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
-
-	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	if (node < 0) {
-		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-		       __func__, fdt_strerror(node));
-		return;
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (str) {
-		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
-		debug("fdt: BOARD-MODEL bdt.type %s\n", g_cavm_bdt.type);
-	} else {
-		printf("Error: cannot retrieve board type from fdt\n");
-	}
-}
-
-int board_early_init_r(void)
-{
-	pci_init();
-	return 0;
-}
-
-int board_init(void)
-{
-	octeontx_parse_phy_info();
-	/* populates cavm_bdt structure */
-	octeontx_parse_board_info();
-
-	return 0;
-}
-
-int timer_init(void)
-{
-	return 0;
-}
-
-int dram_init(void)
-{
-	gd->ram_size = atf_dram_size(0);
-	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
-
-	return 0;
-}
-
-/**
- * Board late initialization routine.
- */
-int board_late_init(void)
-{
-	struct udevice *dev;
-	char boardname[20];
-	int err, bgx_cnt, i;
-
-	debug("%s()\n", __func__);
-
-	/*
-	 * Now that pci_init initializes env device.
-	 * Try to cleanup ethaddr env variables, this is needed
-	 * as with each boot, configuration of QLM can change.
-	 */
-	octeontx_cleanup_ethaddr();
-
-	debug("bdt.type %s\n", g_cavm_bdt.type);
-	snprintf(boardname, sizeof(boardname), "%s> ", g_cavm_bdt.type);
-	env_set("prompt", boardname);
-	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
-
-	/* Probe MAC(BGX) and NIC PF devices before Network stack init */
-	bgx_cnt = is_board_model(CN81XX) ? 2 : 4;
-	for (i = 0; i < bgx_cnt; i++) {
-		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA026, i,
-					 &dev);
-		if (err)
-			debug("%s BGX%d device not found\n", __func__, i);
-	}
-	if (is_board_model(CN81XX)) {
-		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA054, 0,
-					 &dev);
-		if (err)
-			debug("%s RGX device not found\n", __func__);
-	}
-	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA01E, 0, &dev);
-	if (err)
-		debug("NIC PF device not found\n");
-
-	return 0;
-}
-
-/*
- * Invoked before relocation, so limit to stack variables.
- */
-int show_board_info(void)
-{
-	const char *str;
-	int node, prod_id;
-	int ret = 0, len = 16;
-	u64 midr;
-
-	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
-
-	prod_id = (midr >> 4) & 0xff;
-
-	if (!gd->fdt_blob) {
-		printf("ERROR: %s: no valid device tree found\n", __func__);
-		return ret;
-	}
-
-	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
-	ret = fdt_check_header(gd->fdt_blob);
-	if (ret < 0) {
-		printf("fdt: %s\n", fdt_strerror(ret));
-		return ret;
-	}
-	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
-
-	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	if (node < 0) {
-		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-		       __func__, fdt_strerror(node));
-		return ret;
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (!str)
-		printf("Error: cannot retrieve board type from fdt\n");
-
-	if (prod_id == CN81XX)
-		printf("OcteonTX CN81XX ARM V8 Core\n");
-	if (prod_id == CN83XX)
-		printf("OcteonTX CN83XX ARM V8 Core\n");
-
-	printf("Board: %s\n", str);
-	return 0;
-}
-
-#ifdef CONFIG_HW_WATCHDOG
-void hw_watchdog_reset(void)
-{
-	writeq(~0ULL, CAVM_GTI_CWD_POKEX);
-}
-
-void hw_watchdog_disable(void)
-{
-	writeq(0ULL, CAVM_GTI_CWD_WDOGX);
-}
-#endif
diff --git a/board/Marvell/octeontx/atf.c b/board/Marvell/octeontx/smc.c
similarity index 79%
rename from board/Marvell/octeontx/atf.c
rename to board/Marvell/octeontx/smc.c
index 1aa4101e3d..f6e6706b57 100644
--- a/board/Marvell/octeontx/atf.c
+++ b/board/Marvell/octeontx/smc.c
@@ -9,8 +9,7 @@
 #include <asm/io.h>
 
 #include <asm/system.h>
-#include <asm/arch/octeontx_svc.h>
-#include <asm/arch/atf.h>
+#include <asm/arch/smc.h>
 
 #include <asm/psci.h>
 
@@ -18,7 +17,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-ssize_t atf_dram_size(unsigned int node)
+ssize_t smc_dram_size(unsigned int node)
 {
 	struct pt_regs regs;
 
diff --git a/board/Marvell/octeontx/soc-utils.c b/board/Marvell/octeontx/soc-utils.c
new file mode 100644
index 0000000000..694eb64c7d
--- /dev/null
+++ b/board/Marvell/octeontx/soc-utils.c
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+platform_t read_platform(void)
+{
+	platform_t plat = PLATFORM_HW;
+
+	const char *model = fdt_get_board_model();
+
+	if (model && !strncmp(model, "ASIM-", 5))
+		plat = PLATFORM_ASIM;
+	if (model && !strncmp(model, "EMUL-", 5))
+		plat = PLATFORM_EMULATOR;
+	return plat;
+}
+
+static inline u64 read_midr(void)
+{
+	u64 result;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (result));
+	return result;
+}
+
+u8 read_partnum(void)
+{
+	return ((read_midr() >> 4) & 0xFF);
+}
+
+const char *read_board_name(void)
+{
+	return fdt_get_board_model();
+}
+
+bool read_alt_pkg(void)
+{
+	union mio_fus_dat2 fus_dat2;
+
+	fus_dat2.u = readq(MIO_FUS_DAT2);
+	if (fus_dat2.s.chip_id >> 6)
+		return true;
+	/* Some parts only have lmc_mode32 set */
+	if (read_partnum() == CN81XX && fus_dat2.s.lmc_mode32)
+		return true;
+	return false;
+}
+
diff --git a/board/Marvell/octeontx2/MAINTAINERS b/board/Marvell/octeontx2/MAINTAINERS
index 8acac706b2..73026ccdc6 100644
--- a/board/Marvell/octeontx2/MAINTAINERS
+++ b/board/Marvell/octeontx2/MAINTAINERS
@@ -1,6 +1,9 @@
 OCTEONTX2 BOARD
-M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+M:	Suneel Garapati <sgarapati@marvell.com>
+M:	Aaron Williams <awilliams@marvell.com>
 S:	Maintained
 F:	board/Marvell/octeontx2/
 F:	include/configs/octeontx2_96xx.h
+F:	include/configs/octeontx2_95xx.h
 F:	configs/octeontx2_96xx_defconfig
+F:	configs/octeontx2_95xx_defconfig
diff --git a/board/Marvell/octeontx2/Makefile b/board/Marvell/octeontx2/Makefile
index 4827bf7e97..1f763b197b 100644
--- a/board/Marvell/octeontx2/Makefile
+++ b/board/Marvell/octeontx2/Makefile
@@ -1,9 +1,9 @@
-#/*
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
 # * Copyright (C) 2018 Marvell International Ltd.
 # *
-# * SPDX-License-Identifier:    GPL-2.0
 # * https://spdx.org/licenses
 # */
 
-obj-y	:= octeontx2.o atf.o
-obj-$(CONFIG_OF_LIBFDT) += fdt.o
+obj-y	:= board.o smc.o soc-utils.o
+obj-$(CONFIG_OF_LIBFDT) += board-fdt.o
diff --git a/board/Marvell/octeontx2/board-fdt.c b/board/Marvell/octeontx2/board-fdt.c
new file mode 100644
index 0000000000..b07e8a51eb
--- /dev/null
+++ b/board/Marvell/octeontx2/board-fdt.c
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+int fdt_get_bdk_node(void)
+{
+	int node, ret;
+	const void *fdt = gd->fdt_blob;
+
+	if (!fdt) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return 0;
+	}
+
+	ret = fdt_check_header(fdt);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return 0;
+	}
+
+	node = fdt_path_offset(fdt, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return 0;
+	}
+	return node;
+}
+
+u64 fdt_get_board_mac_addr(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+	u64 mac_addr = 0;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return mac_addr;
+	str = fdt_getprop(fdt, node, "BOARD-MAC-ADDRESS", &len);
+	if (str)
+		mac_addr = simple_strtol(str, NULL, 16);
+	return mac_addr;
+}
+
+int fdt_get_board_mac_cnt(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+	int mac_count = 0;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return mac_count;
+	str = fdt_getprop(fdt, node, "BOARD-MAC-ADDRESS-NUM", &len);
+	if (str) {
+		mac_count = simple_strtol(str, NULL, 10);
+		if (!mac_count)
+			mac_count = simple_strtol(str, NULL, 16);
+		debug("fdt: MAC_NUM %d\n", mac_count);
+	} else {
+		printf("Error: cannot retrieve mac count prop from fdt\n");
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM-OVERRIDE",
+			  &len);
+	if (str) {
+		if (simple_strtol(str, NULL, 10) >= 0)
+			mac_count = simple_strtol(str, NULL, 10);
+		debug("fdt: MAC_NUM %d\n", mac_count);
+	} else {
+		printf("Error: cannot retrieve mac num override prop\n");
+	}
+	return mac_count;
+}
+
+const char *fdt_get_board_model(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+	str = fdt_getprop(fdt, node, "BOARD-MODEL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board model from fdt\n");
+	return str;
+}
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* remove "cavium, bdk" node from DT */
+	int ret = 0, offset;
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob) {
+		offset = fdt_path_offset(blob, "/cavium,bdk");
+		if (offset < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return offset;
+		}
+
+		/* delete node */
+		ret = fdt_del_node(blob, offset);
+		if (ret < 0) {
+			printf("WARNING : could not remove cavium, bdk node\n");
+			return ret;
+		}
+
+		debug("%s deleted 'cavium,bdk' node\n", __func__);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx2/octeontx2.c b/board/Marvell/octeontx2/board.c
similarity index 53%
rename from board/Marvell/octeontx2/octeontx2.c
rename to board/Marvell/octeontx2/board.c
index 9645a53bc3..89d58deeb9 100644
--- a/board/Marvell/octeontx2/octeontx2.c
+++ b/board/Marvell/octeontx2/board.c
@@ -15,22 +15,17 @@
 #include <linux/compiler.h>
 #include <linux/libfdt.h>
 #include <fdt_support.h>
-#include <asm/arch/octeontx2.h>
-#include <asm/arch/atf.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
 #include <dm/util.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct cavm_bdt g_cavm_bdt;
-static int board_mac_num;
-u64 board_mac_addr;
-
 extern unsigned long fdt_base_addr;
 extern void cgx_intf_shutdown(void);
-extern void eth_common_init(void);
-extern ssize_t atf_configure_ooo(unsigned int val);
 
-void octeontx2_cleanup_ethaddr(void)
+void cleanup_env_ethaddr(void)
 {
 	char ename[32];
 
@@ -43,8 +38,10 @@ void octeontx2_cleanup_ethaddr(void)
 
 void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr)
 {
-	u64 tmp_mac = board_mac_addr;
+	u64 tmp_mac, board_mac_addr = fdt_get_board_mac_addr();
+	static int board_mac_num;
 
+	board_mac_num = fdt_get_board_mac_cnt();
 	if ((!is_zero_ethaddr((u8 *)&board_mac_addr)) && board_mac_num) {
 		tmp_mac += index;
 		tmp_mac = swab64(tmp_mac) >> 16;
@@ -89,73 +86,6 @@ void board_get_env_spi_bus_cs(int *bus, int *cs)
 	*cs = env_cs;
 }
 
-void octeontx_parse_board_info(void)
-{
-	const char *str;
-	int node;
-	int ret = 0, len = 16;
-	u64 midr;
-
-	debug("%s: ENTER\n", __func__);
-
-	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
-
-	g_cavm_bdt.prod_id = (midr >> 4) & 0xff;
-
-	if (!gd->fdt_blob) {
-		printf("ERROR: %s: no valid device tree found\n", __func__);
-		return;
-	}
-
-	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
-	ret = fdt_check_header(gd->fdt_blob);
-	if (ret < 0) {
-		printf("fdt: %s\n", fdt_strerror(ret));
-		return;
-	}
-	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
-
-	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	if (node < 0) {
-		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-		       __func__, fdt_strerror(node));
-		return;
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (str) {
-		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
-		debug("fdt: BOARD-MODEL bdt.type %s\n", g_cavm_bdt.type);
-	} else {
-		printf("Error: cannot retrieve board type from fdt\n");
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM", &len);
-	if (str) {
-		board_mac_num = simple_strtol(str, NULL, 10);
-		if (!board_mac_num)
-			board_mac_num = simple_strtol(str, NULL, 16);
-		debug("fdt: MAC_NUM %d\n", board_mac_num);
-	} else {
-		printf("Error: cannot retrieve mac num prop from fdt\n");
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM-OVERRIDE",
-			  &len);
-	if (str) {
-		if (simple_strtol(str, NULL, 10) >= 0)
-			board_mac_num = simple_strtol(str, NULL, 10);
-		debug("fdt: MAC_NUM %d\n", board_mac_num);
-	} else {
-		printf("Error: cannot retrieve macnum override prop\n");
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS", &len);
-	if (str) {
-		board_mac_addr = simple_strtoul(str, NULL, 16);
-		debug("%s mac %llx\n", __func__, board_mac_addr);
-	} else {
-		board_mac_addr = 0;
-	}
-}
-
 void board_quiesce_devices(void)
 {
 	struct uclass *uc_dev;
@@ -181,7 +111,7 @@ void board_quiesce_devices(void)
 		printf("couldn't remove misc (cgx/rvu_af) devices\n");
 
 	/* SMC call - removes all LF<->PF mappings */
-	atf_disable_rvu_lfs(0);
+	smc_disable_rvu_lfs(0);
 }
 
 int board_early_init_r(void)
@@ -192,7 +122,6 @@ int board_early_init_r(void)
 
 int board_init(void)
 {
-	octeontx_parse_board_info();
 	return 0;
 }
 
@@ -203,11 +132,7 @@ int timer_init(void)
 
 int dram_init(void)
 {
-	gd->ram_size = 0;
-
-	gd->ram_size = atf_dram_size(0);
-	debug("Node0: %lld MBytes of DRAM\n", gd->ram_size >> 20);
-
+	gd->ram_size = smc_dram_size(0);
 	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
 
 	return 0;
@@ -232,37 +157,13 @@ int misc_init_r(void)
 	return 0;
 }
 
-/**
- * Board late initialization routine.
- */
-int board_late_init(void)
-{
-	char boardname[20];
-	long val;
 #ifdef CONFIG_OCTEONTX_SERIAL_BOOTCMD
+void board_init_serial_bootcmd(void)
+{
 	struct udevice *bootcmd_dev = NULL;
 	int ret;
 	char *stdinname = env_get("stdin");
-#endif
 
-	debug("%s()\n", __func__);
-
-	/*
-	 * Now that pci_init initializes env device.
-	 * Try to cleanup ethaddr env variables, this is needed
-	 * as with each boot, configuration of QLM can change.
-	 */
-	octeontx2_cleanup_ethaddr();
-
-	debug("bdt.type %s\n", g_cavm_bdt.type);
-	snprintf(boardname, sizeof(boardname), "%s> ", g_cavm_bdt.type);
-	env_set("prompt", boardname);
-	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
-
-	val = env_get_hex("disable_ooo", 0);
-	atf_configure_ooo(val);
-
-#ifdef CONFIG_OCTEONTX_SERIAL_BOOTCMD
 	if (!stdinname) {
 		env_set("stdin", "serial");
 		stdinname = env_get("stdin");
@@ -285,6 +186,32 @@ int board_late_init(void)
 			       __func__, iomux_name);
 	}
 #endif
+}
+#endif
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[20];
+	long val;
+
+	/*
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of QLM can change.
+	 */
+	cleanup_env_ethaddr();
+
+	snprintf(boardname, sizeof(boardname), "%s> ", fdt_get_board_model());
+	env_set("prompt", boardname);
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+
+	val = env_get_hex("disable_ooo", 0);
+	smc_configure_ooo(val);
+
+#ifdef CONFIG_OCTEONTX_SERIAL_BOOTCMD
+	board_init_serial_bootcmd();
 #endif
 	return 0;
 }
@@ -294,67 +221,38 @@ int board_late_init(void)
  */
 int show_board_info(void)
 {
-	const char *str;
-	int node, prod_id;
-	int ret = 0, len = 16;
-	u64 midr;
-
-	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
+	char *str = NULL;
 
-	prod_id = (midr >> 4) & 0xff;
+	if (otx_is_soc(CN96XX))
+		str = "CN96XX";
+	if (otx_is_soc(CN95XX))
+		str = "CN95XX";
+	if (otx_is_soc(LOKI))
+		str = "LOKI";
+	if (otx_is_soc(CN98XX))
+		str = "CN98XX";
+	printf("OcteonTX2 %s ARM V8 Core\n", str);
 
-	if (!gd->fdt_blob) {
-		printf("ERROR: %s: no valid device tree found\n", __func__);
-		return ret;
-	}
-
-	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
-	ret = fdt_check_header(gd->fdt_blob);
-	if (ret < 0) {
-		printf("fdt: %s\n", fdt_strerror(ret));
-		return ret;
-	}
-	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
+	printf("Board: %s\n", fdt_get_board_model());
 
-	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	if (node < 0) {
-		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-		       __func__, fdt_strerror(node));
-		return ret;
-	}
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (!str)
-		printf("Error: cannot retrieve board type from fdt\n");
-
-	if (prod_id == CN96XX)
-		printf("OcteonTX2 CN96XX ARM V8 Core\n");
-	if (prod_id == CN95XX)
-		printf("OcteonTX2 CN95XX ARM V8 Core\n");
-	if (prod_id == LOKI)
-		printf("OcteonTX2 LOKI ARM V8 Core\n");
-	if (prod_id == CN98XX)
-		printf("OcteonTX2 CN98XX ARM V8 Core\n");
-
-	printf("Board: %s\n", str);
 	return 0;
 }
 
 void acquire_flash_arb(bool acquire)
 {
-	union cavm_cpc_boot_ownerx ownerx;
+	union cpc_boot_ownerx ownerx;
 
 	if (!acquire) {
-		ownerx.u = readl(CAVM_CPC_BOOT_OWNERX(3));
+		ownerx.u = readl(CPC_BOOT_OWNERX(3));
 		ownerx.s.boot_req = 0;
-		writel(ownerx.u, CAVM_CPC_BOOT_OWNERX(3));
+		writel(ownerx.u, CPC_BOOT_OWNERX(3));
 	} else {
 		ownerx.u = 0;
 		ownerx.s.boot_req = 1;
-		writel(ownerx.u, CAVM_CPC_BOOT_OWNERX(3));
+		writel(ownerx.u, CPC_BOOT_OWNERX(3));
 		udelay(1);
 		do {
-			ownerx.u = readl(CAVM_CPC_BOOT_OWNERX(3));
+			ownerx.u = readl(CPC_BOOT_OWNERX(3));
 		} while (ownerx.s.boot_wait);
 	}
 }
@@ -362,19 +260,19 @@ void acquire_flash_arb(bool acquire)
 #ifdef CONFIG_HW_WATCHDOG
 void hw_watchdog_reset(void)
 {
-	writeq(~0ULL, CAVM_GTI_CWD_POKEX);
+	writeq(~0ULL, GTI_CWD_POKEX);
 }
 
 void hw_watchdog_disable(void)
 {
-	writeq(0ULL, CAVM_GTI_CWD_WDOGX);
+	writeq(0ULL, GTI_CWD_WDOGX);
 }
 #endif
 
 #ifdef CONFIG_LAST_STAGE_INIT
 int last_stage_init(void)
 {
-	(void)atf_flsf_fw_booted();
+	(void)smc_flsf_fw_booted();
 	return 0;
 }
 #endif
diff --git a/board/Marvell/octeontx2/fdt.c b/board/Marvell/octeontx2/fdt.c
deleted file mode 100644
index a938f1f712..0000000000
--- a/board/Marvell/octeontx2/fdt.c
+++ /dev/null
@@ -1,68 +0,0 @@
-// SPDX-License-Identifier:    GPL-2.0
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * https://spdx.org/licenses
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <errno.h>
-#include <environment.h>
-#include <asm/io.h>
-#include <linux/compiler.h>
-#include <linux/libfdt.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <asm/arch/atf.h>
-#include <asm/arch/octeontx2.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-extern unsigned long fdt_base_addr;
-
-int arch_fixup_memory_node(void *blob)
-{
-	return 0;
-}
-
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	/* remove "cavium, bdk" node from DT */
-	int ret = 0, offset;
-
-	ret = fdt_check_header(blob);
-	if (ret < 0) {
-		printf("ERROR: %s\n", fdt_strerror(ret));
-		return ret;
-	}
-
-	if (blob) {
-		offset = fdt_path_offset(blob, "/cavium,bdk");
-		if (offset < 0) {
-			printf("ERROR: FDT BDK node not found\n");
-			return offset;
-		}
-
-		/* delete node */
-		ret = fdt_del_node(blob, offset);
-		if (ret < 0) {
-			printf("WARNING : could not remove cavium, bdk node\n");
-			return ret;
-		}
-
-		debug("%s deleted 'cavium,bdk' node\n", __func__);
-	}
-
-	return 0;
-}
-
-/**
- * Return the FDT base address that was passed by ATF
- *
- * @return	FDT base address received from ATF in x1 register
- */
-void *board_fdt_blob_setup(void)
-{
-	return (void *)fdt_base_addr;
-}
diff --git a/board/Marvell/octeontx2/atf.c b/board/Marvell/octeontx2/smc.c
similarity index 81%
rename from board/Marvell/octeontx2/atf.c
rename to board/Marvell/octeontx2/smc.c
index c9eae788c7..c785993997 100644
--- a/board/Marvell/octeontx2/atf.c
+++ b/board/Marvell/octeontx2/smc.c
@@ -9,8 +9,7 @@
 #include <asm/io.h>
 
 #include <asm/system.h>
-#include <asm/arch/octeontx2_svc.h>
-#include <asm/arch/atf.h>
+#include <asm/arch/smc.h>
 
 #include <asm/psci.h>
 
@@ -18,7 +17,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-ssize_t atf_dram_size(unsigned int node)
+ssize_t smc_dram_size(unsigned int node)
 {
 	struct pt_regs regs;
 
@@ -29,7 +28,7 @@ ssize_t atf_dram_size(unsigned int node)
 	return regs.regs[0];
 }
 
-ssize_t atf_disable_rvu_lfs(unsigned int node)
+ssize_t smc_disable_rvu_lfs(unsigned int node)
 {
 	struct pt_regs regs;
 
@@ -40,7 +39,7 @@ ssize_t atf_disable_rvu_lfs(unsigned int node)
 	return regs.regs[0];
 }
 
-ssize_t atf_configure_ooo(unsigned int val)
+ssize_t smc_configure_ooo(unsigned int val)
 {
 	struct pt_regs regs;
 
@@ -51,7 +50,7 @@ ssize_t atf_configure_ooo(unsigned int val)
 	return regs.regs[0];
 }
 
-ssize_t atf_flsf_fw_booted(void)
+ssize_t smc_flsf_fw_booted(void)
 {
 	struct pt_regs regs;
 
@@ -61,7 +60,7 @@ ssize_t atf_flsf_fw_booted(void)
 	return regs.regs[0];
 }
 
-ssize_t atf_flsf_clr_force_2ndry(void)
+ssize_t smc_flsf_clr_force_2ndry(void)
 {
 	struct pt_regs regs;
 
@@ -71,7 +70,7 @@ ssize_t atf_flsf_clr_force_2ndry(void)
 	return regs.regs[0];
 }
 
-ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+ssize_t smc_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
 			  int reg)
 {
 	struct pt_regs regs;
@@ -87,7 +86,7 @@ ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
 	return regs.regs[0];
 }
 
-ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+ssize_t smc_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
 			   int reg, int val)
 {
 	struct pt_regs regs;
@@ -113,7 +112,7 @@ ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
  *   signed value: <0 - error code
  *                  0 - success
  */
-ssize_t atf_attest(long nonce_len)
+ssize_t smc_attest(long nonce_len)
 {
 	struct pt_regs regs;
 
diff --git a/board/Marvell/octeontx2/soc-utils.c b/board/Marvell/octeontx2/soc-utils.c
new file mode 100644
index 0000000000..228efe4db8
--- /dev/null
+++ b/board/Marvell/octeontx2/soc-utils.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+platform_t read_platform(void)
+{
+	platform_t plat = PLATFORM_HW;
+
+	const char *model = fdt_get_board_model();
+
+	if (model && !strncmp(model, "ASIM-", 5))
+		plat = PLATFORM_ASIM;
+	if (model && !strncmp(model, "EMUL-", 5))
+		plat = PLATFORM_EMULATOR;
+
+	return plat;
+}
+
+static inline u64 read_midr(void)
+{
+	u64 result;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (result));
+	return result;
+}
+
+u8 read_partnum(void)
+{
+	return ((read_midr() >> 4) & 0xFF);
+}
+
+const char *read_board_name(void)
+{
+	return fdt_get_board_model();
+}
+
diff --git a/cmd/marvell/mdio_dbg.c b/cmd/marvell/mdio_dbg.c
index 194912aa95..5378293a1c 100644
--- a/cmd/marvell/mdio_dbg.c
+++ b/cmd/marvell/mdio_dbg.c
@@ -8,7 +8,7 @@
 #include <common.h>
 #include <command.h>
 #include <dm.h>
-#include <asm/arch/atf.h>
+#include <asm/arch/smc.h>
 
 extern void nix_get_cgx_lmac_id(struct udevice *dev, int *cgxid, int *lmacid);
 
@@ -52,7 +52,7 @@ static int do_mdio_dbg(cmd_tbl_t *cmdtp, int flag, int argc,
 		if (mode)
 			devaddr = simple_strtol(argv[5], &endp, 0);
 		regaddr = simple_strtol(argv[6], &endp, 0);
-		ret = atf_mdio_dbg_read(cgx_lmac, mode, phyaddr, devaddr,
+		ret = smc_mdio_dbg_read(cgx_lmac, mode, phyaddr, devaddr,
 					regaddr);
 		printf("Read register 0x%x devad[%d] of PHY@0x%x => 0x%x\n",
 		       regaddr, devaddr, phyaddr, ret);
@@ -61,7 +61,7 @@ static int do_mdio_dbg(cmd_tbl_t *cmdtp, int flag, int argc,
 			devaddr = simple_strtol(argv[5], &endp, 0);
 		regaddr = simple_strtol(argv[6], &endp, 0);
 		data = simple_strtol(argv[7], &endp, 0);
-		ret = atf_mdio_dbg_write(cgx_lmac, mode, phyaddr, devaddr,
+		ret = smc_mdio_dbg_write(cgx_lmac, mode, phyaddr, devaddr,
 					 regaddr, data);
 		printf("Write register 0x%x devad[%d] of PHY@0x%x <= 0x%x\n",
 		       regaddr, devaddr, phyaddr, data);
diff --git a/cmd/marvell/octeontx2_attest_cmds.c b/cmd/marvell/octeontx2_attest_cmds.c
index 9a49f38b5c..89b1a67370 100644
--- a/cmd/marvell/octeontx2_attest_cmds.c
+++ b/cmd/marvell/octeontx2_attest_cmds.c
@@ -8,8 +8,8 @@
 #include <common.h>
 #include <command.h>
 #include <malloc.h>
-#include <asm/arch/atf.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/board.h>
 
 static void hexdump(const char *prefix, unsigned char *buf, int len)
 {
@@ -68,7 +68,7 @@ static int do_attest(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 	}
 
 	/* query for buffer address */
-	attest_ret = atf_attest(0);
+	attest_ret = smc_attest(0);
 
 	if ((ssize_t)attest_ret <= 0) {
 		printf("Error: unable to obtain buffer address.\n");
@@ -80,7 +80,7 @@ static int do_attest(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 	/* Pass nonce data to service in buffer */
 	memcpy(att_info->input_nonce, argv[1], nonce_len);
 
-	attest_ret = atf_attest(nonce_len);
+	attest_ret = smc_attest(nonce_len);
 
 	if ((ssize_t)attest_ret != 0) {
 		printf("Error %ld from attest command\n", attest_ret);
diff --git a/cmd/marvell/octeontx2_failsafe_cmds.c b/cmd/marvell/octeontx2_failsafe_cmds.c
index 1f184b3bc1..785f300095 100644
--- a/cmd/marvell/octeontx2_failsafe_cmds.c
+++ b/cmd/marvell/octeontx2_failsafe_cmds.c
@@ -7,12 +7,12 @@
 
 #include <common.h>
 #include <command.h>
-#include <asm/arch/atf.h>
+#include <asm/arch/smc.h>
 
 static int do_fsafe_clr(
 	cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
-	(void)atf_flsf_clr_force_2ndry();
+	(void)smc_flsf_clr_force_2ndry();
 	return CMD_RET_SUCCESS;
 }
 
diff --git a/cmd/marvell/octeontx2_qlm_cmds.c b/cmd/marvell/octeontx2_qlm_cmds.c
index 71d391b3c4..ab1c4465e0 100644
--- a/cmd/marvell/octeontx2_qlm_cmds.c
+++ b/cmd/marvell/octeontx2_qlm_cmds.c
@@ -7,7 +7,6 @@
 
 #include <common.h>
 #include <command.h>
-#include <asm/arch/atf.h>
 
 extern int cgx_intf_prbs(u8 qlm, u8 mode, u32 time);
 extern int cgx_intf_display_eye(u8 qlm, u8 lane);
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index ada045305e..7affdffd1c 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -27,8 +27,9 @@
 #include <ahci.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
-#if CONFIG_ARCH_OCTEONTX
-#include <asm/arch/octeontx.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+#include <asm/arch/board.h>
 #endif
 
 static int ata_io_flush(struct ahci_uc_priv *uc_priv, u8 port);
diff --git a/drivers/mmc/octeontx_hsmmc.c b/drivers/mmc/octeontx_hsmmc.c
index fcdcd854cb..04c6509735 100644
--- a/drivers/mmc/octeontx_hsmmc.c
+++ b/drivers/mmc/octeontx_hsmmc.c
@@ -19,19 +19,13 @@
 #include <fdtdec.h>
 #include <asm/arch/csrs/csrs-mio_emm.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/board.h>
 #include <linux/list.h>
 #include <div64.h>
 #include <watchdog.h>
 #include <power/regulator.h>
 #include <console.h>	/* for ctrlc */
 #include "octeontx_hsmmc.h"
-#if defined(CONFIG_ARCH_OCTEONTX)
-# include <asm/arch/octeontx.h>
-#elif defined(CONFIG_ARCH_OCTEONTX2)
-# include <asm/arch/octeontx2.h>
-#else
-# error Unsupported architecture!
-#endif
 
 #define PCI_DEVICE_ID_OCTEONTX_EMMC	0xA010
 
@@ -45,8 +39,8 @@
 #define MMC_DEFAULT_DATA_OUT_TAP		39
 #define MMC_DEFAULT_HS200_CMD_IN_TAP		24
 #define MMC_DEFAULT_HS200_DATA_IN_TAP		24
-#define MMC_DEFAULT_HS200_CMD_OUT_TAP	(is_board_model(CN95XX) ? 10 : 5)
-#define MMC_DEFAULT_HS200_DATA_OUT_TAP	(is_board_model(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS200_CMD_OUT_TAP	(otx_is_soc(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS200_DATA_OUT_TAP	(otx_is_soc(CN95XX) ? 10 : 5)
 #define MMC_DEFAULT_SD_UHS_SDR104_CMD_OUT_TAP	MMC_DEFAULT_HS200_CMD_OUT_TAP
 #define MMC_DEFAULT_SD_UHS_SDR104_DATA_OUT_TAP	MMC_DEFAULT_HS200_DATA_OUT_TAP
 #define MMC_LEGACY_DEFAULT_CMD_OUT_TAP		39
@@ -3090,8 +3084,6 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 	pci_dev_t bdf = dm_pci_get_bdf(dev);
 	struct octeontx_mmc_host *host = dev_get_priv(dev);
 	union mio_emm_int emm_int;
-	const char *board_model;
-	ofnode node;
 #if defined(CONFIG_ARCH_OCTEONTX2)
 	u8 rev;
 #endif
@@ -3119,14 +3111,10 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 	host->node = dev->node;
 	dev->req_seq = PCI_FUNC(bdf);
 	host->last_slotid = -1;
-	node = ofnode_path("/cavium,bdk");
-	if (ofnode_valid(node)) {
-		board_model = ofnode_read_string(node, "BOARD-MODEL");
-		if (board_model && !strncmp(board_model, "ASIM-", 5))
-			host->is_asim = true;
-		if (board_model && !strncmp(board_model, "EMUL-", 5))
-			host->is_emul = true;
-	}
+	if (otx_is_platform(PLATFORM_ASIM))
+		host->is_asim = true;
+	if (otx_is_platform(PLATFORM_EMULATOR))
+		host->is_emul = true;
 	/* Force reset of eMMC */
 	writeq(0, host->base_addr + MIO_EMM_CFG());
 	debug("%s: Clearing MIO_EMM_CFG\n", __func__);
@@ -3142,7 +3130,7 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 #ifdef CONFIG_ARCH_OCTEONTX2
 	/* Flags for issues to work around */
 	dm_pci_read_config8(dev, PCI_REVISION_ID, &rev);
-	if (is_board_model(CN96XX)) {
+	if (otx_is_soc(CN96XX)) {
 		switch (rev) {
 		case 0:
 			host->calibrate_glitch = true;
@@ -3151,7 +3139,7 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 		default:
 			break;
 		}
-	} else if (is_board_model(CN95XX)) {
+	} else if (otx_is_soc(CN95XX)) {
 		if (!rev)
 			host->cond_clock_glitch = true;
 	}
diff --git a/drivers/mtd/nand/octeontx_bch.c b/drivers/mtd/nand/octeontx_bch.c
index 62b180074f..db6c948320 100644
--- a/drivers/mtd/nand/octeontx_bch.c
+++ b/drivers/mtd/nand/octeontx_bch.c
@@ -198,21 +198,15 @@ static int octeontx_pci_bchpf_probe(struct udevice *dev)
 }
 
 static const struct pci_device_id octeontx_bchpf_pci_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, BCH_PCI_PF_DEVICE_ID) },
+	{ PCI_VDEVICE(CAVIUM, BCH_PCI_PF_DEVICE_ID) },
 	{},
 };
 
 static const struct pci_device_id octeontx_bchvf_pci_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, BCH_PCI_VF_DEVICE_ID)},
+	{ PCI_VDEVICE(CAVIUM, BCH_PCI_VF_DEVICE_ID)},
 	{},
 };
 
-U_BOOT_DRIVER(octeontx_bchpf) = {
-	.name	= CAVIUM_BCHPF_DRIVER_NAME,
-	.id	= UCLASS_MISC,
-	.probe = octeontx_pci_bchpf_probe,
-};
-
 /**
  * Given a data block calculate the ecc data and fill in the response
  *
@@ -411,7 +405,7 @@ static int octeontx_pci_bchpf_remove(struct udevice *dev)
 }
 
 U_BOOT_DRIVER(octeontx_pci_bchpf) = {
-	.name	= CAVIUM_BCHPF_DRIVER_NAME,
+	.name	= BCHPF_DRIVER_NAME,
 	.id	= UCLASS_MISC,
 	.probe	= octeontx_pci_bchpf_probe,
 	.remove = octeontx_pci_bchpf_remove,
@@ -420,7 +414,7 @@ U_BOOT_DRIVER(octeontx_pci_bchpf) = {
 };
 
 U_BOOT_DRIVER(octeontx_pci_bchvf) = {
-	.name	= CAVIUM_BCHVF_DRIVER_NAME,
+	.name	= BCHVF_DRIVER_NAME,
 	.id	= UCLASS_MISC,
 	.probe = octeontx_pci_bchvf_probe,
 	.priv_auto_alloc_size = sizeof(struct bch_vf),
diff --git a/drivers/mtd/nand/octeontx_bch.h b/drivers/mtd/nand/octeontx_bch.h
index e752896104..4629b4b535 100644
--- a/drivers/mtd/nand/octeontx_bch.h
+++ b/drivers/mtd/nand/octeontx_bch.h
@@ -41,8 +41,8 @@
 #define BCH_VQX_CMD_PTR(z)		0x20ull
 #define BCH_VQX_DOORBELL(z)		0x800ull
 
-#define CAVIUM_BCHPF_DRIVER_NAME	"cavium-bchpf"
-#define CAVIUM_BCHVF_DRIVER_NAME	"cavium-bchvf"
+#define BCHPF_DRIVER_NAME	"octeontx-bchpf"
+#define BCHVF_DRIVER_NAME	"octeontx-bchvf"
 
 struct bch_device {
 	struct list_head list;
diff --git a/drivers/mtd/nand/octeontx_nand.c b/drivers/mtd/nand/octeontx_nand.c
index d457604bd7..14f237331c 100644
--- a/drivers/mtd/nand/octeontx_nand.c
+++ b/drivers/mtd/nand/octeontx_nand.c
@@ -1871,7 +1871,7 @@ static void octeontx_nfc_chip_sizing(struct nand_chip *nand)
 	      __func__, nand, chip->row_bytes, chip->col_bytes, ecc->mode);
 
 	/*
-	 * HW_BCH using Cavium BCH engine, or SOFT_BCH laid out in
+	 * HW_BCH using OcteonTX BCH engine, or SOFT_BCH laid out in
 	 * HW_BCH-compatible fashion, depending on devtree advice
 	 * and kernel config.
 	 * BCH/NFC hardware capable of subpage ops, not implemented.
@@ -2217,7 +2217,7 @@ int octeontx_pci_nand_deferred_probe(void)
 #endif
 
 static const struct pci_device_id octeontx_nfc_pci_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xa04f) },
+	{ PCI_VDEVICE(CAVIUM, 0xA04F) },
 	{}
 };
 
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 50d78c8f25..5555594ce4 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -64,7 +64,7 @@ obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_TSEC_ENET) += tsec.o fsl_mdio.o
 obj-$(CONFIG_NET_OCTEONTX) += octeontx/
 obj-$(CONFIG_NET_OCTEONTX2) += octeontx2/
-obj-$(CONFIG_OCTEONTX_SMI) += octeontx/octeontx_smi.o
+obj-$(CONFIG_OCTEONTX_SMI) += octeontx/smi.o
 obj-$(CONFIG_OCTEONTX2_CGX_INTF) += octeontx2/cgx_intf.o
 obj-$(CONFIG_FMAN_ENET) += fsl_mdio.o
 obj-$(CONFIG_ULI526X) += uli526x.o
diff --git a/drivers/net/octeontx/Makefile b/drivers/net/octeontx/Makefile
index e0bb524c37..170f1f41cd 100644
--- a/drivers/net/octeontx/Makefile
+++ b/drivers/net/octeontx/Makefile
@@ -5,5 +5,5 @@
 # * https://spdx.org/licenses
 # */
 
-obj-$(CONFIG_NET_OCTEONTX) += octeontx_bgx.o nic_main.o nicvf_queues.o \
-		nicvf_main.o octeontx_xcv.o
+obj-$(CONFIG_NET_OCTEONTX) += bgx.o nic_main.o nicvf_queues.o nicvf_main.o \
+				xcv.o
diff --git a/drivers/net/octeontx/octeontx_bgx.c b/drivers/net/octeontx/bgx.c
similarity index 97%
rename from drivers/net/octeontx/octeontx_bgx.c
rename to drivers/net/octeontx/bgx.c
index ef3d9091d9..d885b2a8c9 100644
--- a/drivers/net/octeontx/octeontx_bgx.c
+++ b/drivers/net/octeontx/bgx.c
@@ -22,12 +22,9 @@
  #include <fdt_support.h>
 #endif
 
-#include <asm/arch/octeontx.h>
-#include <asm/arch/octeontx_vnic.h>
-
 #include "nic_reg.h"
 #include "nic.h"
-#include "octeontx_bgx.h"
+#include "bgx.h"
 
 static const phy_interface_t if_mode[] = {
 	[QLM_MODE_SGMII]  = PHY_INTERFACE_MODE_SGMII,
@@ -73,7 +70,6 @@ struct bgx {
 struct bgx_board_info bgx_board_info[MAX_BGX_PER_NODE];
 
 struct bgx *bgx_vnic[MAX_BGX_PER_NODE];
-bool is_altpkg;
 extern int rxaui_phy_xs_init(struct mii_dev *bus, int phy_addr);
 
 /* APIs to read/write BGXX CSRs */
@@ -274,10 +270,10 @@ static int get_qlm_for_bgx(int node, int bgx_id, int index)
 	int qlm = 0;
 	u64 cfg;
 
-	if (is_board_model(CN81XX)) {
+	if (otx_is_soc(CN81XX)) {
 		qlm = (bgx_id) ? 2 : 0;
 		qlm += (index >= 2) ? 1 : 0;
-	} else if (is_board_model(CN83XX)) {
+	} else if (otx_is_soc(CN83XX)) {
 		switch (bgx_id) {
 		case 0:
 			qlm = 2;
@@ -573,9 +569,9 @@ static int bgx_lmac_xaui_init(struct bgx *bgx, int lmacid, int lmac_type)
 /* Get max number of lanes present in a given QLM/DLM */
 static int get_qlm_lanes(int qlm)
 {
-	if (is_board_model(CN81XX))
+	if (otx_is_soc(CN81XX))
 		return 2;
-	else if (is_board_model(CN83XX))
+	else if (otx_is_soc(CN83XX))
 		return (qlm >= 5) ? 2 : 4;
 	else
 		return -1;
@@ -700,8 +696,8 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 		int qlm;
 		bool use_dlm = 0;
 
-		if (is_board_model(CN81XX) || (is_board_model(CN83XX) &&
-					       bgx->bgx_id == 2))
+		if (otx_is_soc(CN81XX) || (otx_is_soc(CN83XX) &&
+					   bgx->bgx_id == 2))
 			use_dlm = 1;
 		switch (lmac->lmac_type) {
 		default:
@@ -751,8 +747,9 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 		case BGX_MODE_XFI:
 			{
 				int lid;
+				bool altpkg = otx_is_altpkg();
 
-				if (bgx->bgx_id == 0 && is_altpkg && lmacid)
+				if (bgx->bgx_id == 0 && altpkg && lmacid)
 					lid = 0;
 				else if ((lmacid >= 2) && use_dlm)
 					lid = lmacid - 2;
@@ -1071,7 +1068,7 @@ static void bgx_init_hw(struct bgx *bgx)
 			/* EBB8000 (alternative pkg) has only lane0 present on
 			 * DLM0 and DLM1, skip configuring other lanes
 			 */
-			if (bgx->bgx_id == 0 && is_altpkg) {
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1116,7 +1113,7 @@ static void bgx_init_hw(struct bgx *bgx)
 			/* EBB8000 (alternative pkg) has only lane0 present on
 			 * DLM0 and DLM1, skip configuring other lanes
 			 */
-			if (bgx->bgx_id == 0 && is_altpkg) {
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1139,7 +1136,7 @@ static void bgx_init_hw(struct bgx *bgx)
 			/* EBB8000 (alternative pkg) has only lane0 present on
 			 * DLM0 and DLM1, skip configuring other lanes
 			 */
-			if (bgx->bgx_id == 0 && is_altpkg) {
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1274,8 +1271,8 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		int train_en;
 		int index = 0;
 
-		if (is_board_model(CN81XX) || (is_board_model(CN83XX) &&
-					       bgx->bgx_id == 2))
+		if (otx_is_soc(CN81XX) || (otx_is_soc(CN83XX) &&
+					   bgx->bgx_id == 2))
 			index = (lmacid < 2) ? 0 : 2;
 
 		lmac = &bgx->lmac[lmacid];
@@ -1287,7 +1284,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		lmac_type = bgx_reg_read(bgx, index, BGX_CMRX_CFG);
 		lmac->lmac_type = (lmac_type >> 8) & 0x07;
 		debug("%s:%d:%d: lmac_type = %d, altpkg = %d\n", __func__,
-		      bgx->bgx_id, lmacid, lmac->lmac_type, is_altpkg);
+		      bgx->bgx_id, lmacid, lmac->lmac_type, otx_is_altpkg());
 
 		train_en = (readq(CSR_PA(0, GSERX_SCRATCH(lmac->qlm))) & 0xf);
 		lmac->is_1gx = bgx_reg_read(bgx, index, BGX_GMP_PCS_MISCX_CTL)
@@ -1303,7 +1300,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 				}
 				continue;
 			} else {
-				if (bgx->bgx_id == 0 && is_altpkg) {
+				if (bgx->bgx_id == 0 && otx_is_altpkg()) {
 					if (lmacid % 2)
 						continue;
 				}
@@ -1314,7 +1311,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 			}
 			break;
 		case BGX_MODE_XAUI:
-			if (bgx->bgx_id == 0 && is_altpkg)
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
 				continue;
 			lmac->qlm_mode = QLM_MODE_XAUI;
 			if (lmacid != 0)
@@ -1323,7 +1320,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 			      bgx->bgx_id, lmac->qlm, lmacid);
 			break;
 		case BGX_MODE_RXAUI:
-			if (bgx->bgx_id == 0 && is_altpkg)
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
 				continue;
 			lmac->qlm_mode = QLM_MODE_RXAUI;
 			if (index == lmacid) {
@@ -1332,7 +1329,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 			}
 			break;
 		case BGX_MODE_XFI:
-			if (bgx->bgx_id == 0 && is_altpkg) {
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1348,7 +1345,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 			}
 			break;
 		case BGX_MODE_XLAUI:
-			if (bgx->bgx_id == 0 && is_altpkg)
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
 				continue;
 			if (train_en) {
 				lmac->qlm_mode = QLM_MODE_40G_KR4;
@@ -1366,7 +1363,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		break;
 		case BGX_MODE_QSGMII:
 			/* If QLM is configured as QSGMII, use lmac0 */
-			if (is_board_model(CN83XX) && lmacid == 2 &&
+			if (otx_is_soc(CN83XX) && lmacid == 2 &&
 			    bgx->bgx_id != 2) {
 				//lmac->qlm_mode = QLM_MODE_DISABLED;
 				continue;
@@ -1457,7 +1454,6 @@ int octeontx_bgx_probe(struct udevice *dev)
 		debug("No PCI region found\n");
 		return 0;
 	}
-	is_altpkg = g_cavm_bdt.alt_pkg;
 
 #ifdef OCTEONTX_XCV
 	/* Use FAKE BGX2 for RGX interface */
@@ -1480,14 +1476,14 @@ int octeontx_bgx_probe(struct udevice *dev)
 	node = node_id(bgx->reg_base);
 	bgx_idx = ((uintptr_t)bgx->reg_base >> 24) & 3;
 	bgx->bgx_id = (node * MAX_BGX_PER_NODE) + bgx_idx;
-	if (is_board_model(CN81XX))
+	if (otx_is_soc(CN81XX))
 		inc = 2;
-	else if (is_board_model(CN83XX) && (bgx_idx == 2))
+	else if (otx_is_soc(CN83XX) && (bgx_idx == 2))
 		inc = 2;
 
 	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac += inc) {
 		/* BGX3 (DLM4), has only 2 lanes */
-		if (is_board_model(CN83XX) && bgx_idx == 3 && lmac >= 2)
+		if (otx_is_soc(CN83XX) && bgx_idx == 3 && lmac >= 2)
 			continue;
 		qlm[lmac + 0] = get_qlm_for_bgx(node, bgx_idx, lmac);
 		/* Each DLM has 2 lanes, configure both lanes with
@@ -1501,7 +1497,7 @@ int octeontx_bgx_probe(struct udevice *dev)
 	/* A BGX can take 1 or 2 DLMs, if both the DLMs are not configured
 	 * as BGX, then return, nothing to initialize
 	 */
-	if (is_board_model(CN81XX))
+	if (otx_is_soc(CN81XX))
 		if ((qlm[0] == -1) && (qlm[2] == -1))
 			return -ENODEV;
 
diff --git a/drivers/net/octeontx/octeontx_bgx.h b/drivers/net/octeontx/bgx.h
similarity index 98%
rename from drivers/net/octeontx/octeontx_bgx.h
rename to drivers/net/octeontx/bgx.h
index bf05a268d0..1ad582a91a 100644
--- a/drivers/net/octeontx/octeontx_bgx.h
+++ b/drivers/net/octeontx/bgx.h
@@ -5,10 +5,10 @@
  * https://spdx.org/licenses
  */
 
-#ifndef OCTEONT_BGX_H
-#define OCTEONT_BGX_H
+#ifndef BGX_H
+#define BGX_H
 
-#include <asm/arch/octeontx.h>
+#include <asm/arch/board.h>
 
 /* PCI device IDs */
 #define	PCI_DEVICE_ID_OCTEONTX_BGX	0xA026
@@ -256,4 +256,4 @@ enum LMAC_TYPE {
 	BGX_MODE_INVALID = 7,
 };
 
-#endif /* OCTEONT_BGX_H */
+#endif /* BGX_H */
diff --git a/drivers/net/octeontx/nic.h b/drivers/net/octeontx/nic.h
index 471621ecf4..760675d577 100644
--- a/drivers/net/octeontx/nic.h
+++ b/drivers/net/octeontx/nic.h
@@ -9,7 +9,7 @@
 #define	NIC_H
 
 #include <linux/netdevice.h>
-#include "octeontx_bgx.h"
+#include "bgx.h"
 
 /**
  * Macro to get the physical address of a CSR on a node
diff --git a/drivers/net/octeontx/nic_main.c b/drivers/net/octeontx/nic_main.c
index 20023ca0f4..e821dbd3f4 100644
--- a/drivers/net/octeontx/nic_main.c
+++ b/drivers/net/octeontx/nic_main.c
@@ -16,13 +16,9 @@
 #include <pci.h>
 #include <asm/io.h>
 
-#include <asm/arch/octeontx.h>
-#include <asm/arch/octeontx_vnic.h>
-
 #include "nic_reg.h"
 #include "nic.h"
 #include "q_struct.h"
-#include "octeontx_bgx.h"
 
 #define ETH_HLEN 6
 
diff --git a/drivers/net/octeontx/nicvf_main.c b/drivers/net/octeontx/nicvf_main.c
index 7e9a700593..4a10e69870 100644
--- a/drivers/net/octeontx/nicvf_main.c
+++ b/drivers/net/octeontx/nicvf_main.c
@@ -14,13 +14,9 @@
 #include <malloc.h>
 #include <asm/io.h>
 
-#include <asm/arch/octeontx_vnic.h>
-#include <asm/arch/octeontx.h>
-
 #include "nic_reg.h"
 #include "nic.h"
 #include "nicvf_queues.h"
-#include "octeontx_bgx.h"
 
 #define ETH_ALEN 6
 
@@ -534,7 +530,7 @@ int nicvf_initialize(struct udevice *dev)
 	      __func__, nicvf->nicpf, nicvf->nicpf->udev, nicvf, nicvf->dev,
 	      pdata);
 
-	octeontx_board_get_ethaddr(bgx, lmac, ethaddr);
+	fdt_board_get_ethaddr(bgx, lmac, ethaddr);
 
 	debug("%s bgx %d lmac %d ethaddr %pM\n", __func__, bgx, lmac, ethaddr);
 
diff --git a/drivers/net/octeontx/octeontx_smi.c b/drivers/net/octeontx/smi.c
similarity index 100%
rename from drivers/net/octeontx/octeontx_smi.c
rename to drivers/net/octeontx/smi.c
diff --git a/drivers/net/octeontx/octeontx_xcv.c b/drivers/net/octeontx/xcv.c
similarity index 97%
rename from drivers/net/octeontx/octeontx_xcv.c
rename to drivers/net/octeontx/xcv.c
index 3020c85112..1186157485 100644
--- a/drivers/net/octeontx/octeontx_xcv.c
+++ b/drivers/net/octeontx/xcv.c
@@ -22,8 +22,9 @@
  #include <fdt_support.h>
 #endif
 
-#include <asm/arch/octeontx_xcv.h>
-#include <asm/arch/octeontx_vnic.h>
+#include <asm/arch/csrs/csrs-xcv.h>
+
+#define XCVX_BASE		0x87E0DB000000ULL
 
 /* Initialize XCV block */
 void xcv_init_hw(void)
diff --git a/drivers/net/octeontx2/cgx.c b/drivers/net/octeontx2/cgx.c
index f044842b51..ea25a1b968 100644
--- a/drivers/net/octeontx2/cgx.c
+++ b/drivers/net/octeontx2/cgx.c
@@ -13,7 +13,7 @@
 #include <asm/io.h>
 #include <errno.h>
 #include <linux/list.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #include <asm/arch/csrs/csrs-cgx.h>
 #include "cgx.h"
 
diff --git a/drivers/net/octeontx2/cgx_intf.c b/drivers/net/octeontx2/cgx_intf.c
index b31d5055b2..94ab0646ff 100644
--- a/drivers/net/octeontx2/cgx_intf.c
+++ b/drivers/net/octeontx2/cgx_intf.c
@@ -13,7 +13,7 @@
 #include <asm/io.h>
 #include <errno.h>
 #include <linux/list.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 
 #include "cgx_intf.h"
 #include "cgx.h"
diff --git a/drivers/net/octeontx2/lmt.h b/drivers/net/octeontx2/lmt.h
index a2453204a6..97777eab00 100644
--- a/drivers/net/octeontx2/lmt.h
+++ b/drivers/net/octeontx2/lmt.h
@@ -19,7 +19,7 @@
  *
  * @return Value of memory location before increment
  */
-static inline s64 cavm_atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
+static inline s64 atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
 {
 	s64 result;
 	/* Atomic add with no ordering */
@@ -30,18 +30,18 @@ static inline s64 cavm_atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
 	return result;
 }
 
-static inline void cavm_lmt_cancel(const struct nix *nix)
+static inline void lmt_cancel(const struct nix *nix)
 {
 	writeq(0, nix->lmt_base + LMT_LF_LMTCANCEL());
 }
 
-static inline u64 *cavm_lmt_store_ptr(struct nix *nix)
+static inline u64 *lmt_store_ptr(struct nix *nix)
 {
 	return (u64 *)((u8 *)(nix->lmt_base) +
 				       LMT_LF_LMTLINEX(0));
 }
 
-static inline s64 cavm_lmt_submit(u64 io_address)
+static inline s64 lmt_submit(u64 io_address)
 {
 	s64 result = 0;
 
diff --git a/drivers/net/octeontx2/nix.c b/drivers/net/octeontx2/nix.c
index 152f944af4..6250b45a49 100644
--- a/drivers/net/octeontx2/nix.c
+++ b/drivers/net/octeontx2/nix.c
@@ -17,7 +17,7 @@
 #include <asm/io.h>
 #include <linux/types.h>
 #include <linux/log2.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #include <asm/arch/csrs/csrs-lmt.h>
 #include "nix.h"
 #include "lmt.h"
@@ -91,8 +91,8 @@ static int npa_setup_pool(struct npa *npa, u32 pool_id,
 		aura_descr.f0.s.addr = (u64)buffers[index];
 		aura_descr.f1.u = 0;
 		aura_descr.f1.s.aura = pool_id;
-		cavm_st128(npa->npa_base + NPA_LF_AURA_OP_FREE0(),
-			   aura_descr.f0.u, aura_descr.f1.u);
+		st128(npa->npa_base + NPA_LF_AURA_OP_FREE0(),
+		      aura_descr.f0.u, aura_descr.f1.u);
 	}
 
 	return 0;
@@ -453,7 +453,7 @@ u64 npa_aura_op_alloc(struct npa *npa, u64 aura_id)
 {
 	union npa_lf_aura_op_allocx op_allocx;
 
-	op_allocx.u = cavm_atomic_fetch_and_add64_nosync(npa->npa_base +
+	op_allocx.u = atomic_fetch_and_add64_nosync(npa->npa_base +
 			NPA_LF_AURA_OP_ALLOCX(0), aura_id);
 	return op_allocx.s.addr;
 }
@@ -463,7 +463,7 @@ u64 nix_cq_op_status(struct nix *nix, u64 cq_id)
 	union nixx_lf_cq_op_status op_status;
 	s64 *reg = nix->nix_base + NIXX_LF_CQ_OP_STATUS();
 
-	op_status.u = cavm_atomic_fetch_and_add64_nosync(reg, cq_id << 32);
+	op_status.u = atomic_fetch_and_add64_nosync(reg, cq_id << 32);
 	return op_status.u;
 }
 
@@ -473,7 +473,7 @@ static inline void nix_write_lmt(struct nix *nix, void *buffer,
 {
 	int i;
 
-	u64 *lmt_ptr = cavm_lmt_store_ptr(nix);
+	u64 *lmt_ptr = lmt_store_ptr(nix);
 	u64 *ptr = buffer;
 
 	debug("%s lmt_ptr %p %p\n", __func__, nix->lmt_base, lmt_ptr);
@@ -575,7 +575,7 @@ int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len)
 	do {
 		nix_write_lmt(nix, &tx_dr, (dr_sz - 1) * 2);
 		__iowmb();
-		result = cavm_lmt_submit((u64)(nix->nix_base +
+		result = lmt_submit((u64)(nix->nix_base +
 					       NIXX_LF_OP_SENDX(0)));
 		WATCHDOG_RESET();
 	} while (result == 0);
@@ -614,8 +614,8 @@ void nix_lf_flush_rx(struct udevice *dev)
 
 		seg = (dma_addr_t *)(&rx_dr->rx_sg + 1);
 
-		cavm_st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
-			   seg[0], (1ULL << 63) | NPA_POOL_RX);
+		st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
+		      seg[0], (1ULL << 63) | NPA_POOL_RX);
 
 		debug("%s return %llx to NPA\n", __func__, seg[0]);
 		nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
@@ -637,8 +637,8 @@ int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
 
 	/* Return rx packet to NPA */
 	debug("%s return %p to NPA\n", __func__, pkt);
-	cavm_st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
-		   (u64)pkt, (1ULL << 63) | NPA_POOL_RX);
+	st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(), (u64)pkt,
+	      (1ULL << 63) | NPA_POOL_RX);
 	nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
 			 (NIX_CQ_RX << 32) | 1);
 
diff --git a/drivers/net/octeontx2/nix_af.c b/drivers/net/octeontx2/nix_af.c
index 8ea6168a4d..7bcae3bd15 100644
--- a/drivers/net/octeontx2/nix_af.c
+++ b/drivers/net/octeontx2/nix_af.c
@@ -17,7 +17,7 @@
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/log2.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #include "asm/arch/csrs/csrs-npc.h"
 #include "asm/arch/csrs/csrs-lmt.h"
 #include "nix.h"
diff --git a/drivers/net/octeontx2/rvu.h b/drivers/net/octeontx2/rvu.h
index 24b107ea69..b08a747db5 100644
--- a/drivers/net/octeontx2/rvu.h
+++ b/drivers/net/octeontx2/rvu.h
@@ -78,7 +78,7 @@ struct rvu_pf {
  * @param	val0	first 64 bits to write
  * @param	val1	second 64 bits to write
  */
-static inline void cavm_st128(void *dest, u64 val0, u64 val1)
+static inline void st128(void *dest, u64 val0, u64 val1)
 {
 	__asm__ __volatile__("stp %x[x0], %x[x1], [%[pm]]" :
 		: [x0]"r"(val0), [x1]"r"(val1), [pm]"r"(dest)
@@ -92,7 +92,7 @@ static inline void cavm_st128(void *dest, u64 val0, u64 val1)
  * @param[out]	val0		first 64 bits of data
  * @param[out]	val1		second 64 bits of data
  */
-static inline void cavm_ld128(const u64 *src, u64 *val0, u64 *val1)
+static inline void ld128(const u64 *src, u64 *val0, u64 *val1)
 {
 	__asm__ __volatile__ ("ldp %x[x0], %x[x1], [%[pm]]" :
 		 : [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
diff --git a/drivers/net/octeontx2/rvu_af.c b/drivers/net/octeontx2/rvu_af.c
index 863f594b98..e8c9d12939 100644
--- a/drivers/net/octeontx2/rvu_af.c
+++ b/drivers/net/octeontx2/rvu_af.c
@@ -13,7 +13,7 @@
 #include <errno.h>
 #include <linux/list.h>
 #include <asm/io.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #include <asm/arch/csrs/csrs-npa.h>
 #include "nix.h"
 
@@ -156,17 +156,11 @@ int rvu_af_remove(struct udevice *dev)
 	return 0;
 }
 
-static const struct udevice_id rvu_af_ids[] = {
-	{ .compatible = "cavium,rvu-af" },
-	{}
-};
-
 U_BOOT_DRIVER(rvu_af) = {
 	.name   = "rvu_af",
 	.id     = UCLASS_MISC,
 	.probe  = rvu_af_probe,
 	.remove = rvu_af_remove,
-	.of_match = rvu_af_ids,
 	.priv_auto_alloc_size = sizeof(struct rvu_af),
 };
 
diff --git a/drivers/net/octeontx2/rvu_pf.c b/drivers/net/octeontx2/rvu_pf.c
index 4f59030793..36755f75ed 100644
--- a/drivers/net/octeontx2/rvu_pf.c
+++ b/drivers/net/octeontx2/rvu_pf.c
@@ -13,7 +13,7 @@
 #include <asm/io.h>
 #include <errno.h>
 #include <asm/types.h>
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #include "cgx.h"
 #include "nix.h"
 
@@ -100,15 +100,9 @@ int rvu_pf_remove(struct udevice *dev)
 	return 0;
 }
 
-static const struct udevice_id rvu_pf_ids[] = {
-	{ .compatible = "cavium,rvu-pf" },
-	{}
-};
-
 U_BOOT_DRIVER(rvu_pf) = {
 	.name   = "rvu_pf",
 	.id     = UCLASS_ETH,
-	.of_match = rvu_pf_ids,
 	.probe	= rvu_pf_probe,
 	.remove = rvu_pf_remove,
 	.ops    = &nix_eth_ops,
diff --git a/drivers/spi/octeontx_spi.c b/drivers/spi/octeontx_spi.c
index 830d94c2a8..fd112de950 100644
--- a/drivers/spi/octeontx_spi.c
+++ b/drivers/spi/octeontx_spi.c
@@ -15,7 +15,7 @@
 #include <watchdog.h>
 
 #if defined(CONFIG_ARCH_OCTEONTX2)
-#include <asm/arch/octeontx2.h>
+#include <asm/arch/board.h>
 #define USE_TBI_CLK
 #endif
 
-- 
2.29.0

