From 8417f6f7dab5b9a60e5a54a14e3e72d5c8127e35 Mon Sep 17 00:00:00 2001
From: Sergey Temerkhanov <s.temerkhanov@gmail.com>
Date: Sat, 14 May 2016 23:40:38 -0400
Subject: [PATCH 0441/1239] pci: thunderx: Support PCIe switches

This commit adds support for PCIe switches connected to
ThunderX PEMs

Signed-off-by: Sergey Temerkhanov<s.temerkhanov@gmail.com>
---
 drivers/pci/pci_thunderx_ecam.c | 99 ++++++++++++++++++++++-----------
 1 file changed, 68 insertions(+), 31 deletions(-)

diff --git a/drivers/pci/pci_thunderx_ecam.c b/drivers/pci/pci_thunderx_ecam.c
index 3b10d13606..33313d720b 100644
--- a/drivers/pci/pci_thunderx_ecam.c
+++ b/drivers/pci/pci_thunderx_ecam.c
@@ -58,6 +58,7 @@ static int pci_thunderx_ecam_read_config(struct udevice *bus, pci_dev_t bdf,
 		*valuep = readl(address);
 		break;
 	};
+
 /*
 	debug("%02x.%02x.%02x: u%d %x -> %lx\n",
 	      b, d, f, size, offset, *valuep);
@@ -93,6 +94,7 @@ static int pci_thunderx_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
 		writel(valuep, address);
 		break;
 	};
+
 /*
 	debug("%02x.%02x.%02x: u%d %x <- %lx\n",
 	      b, d, f, size, offset, valuep);
@@ -108,29 +110,44 @@ static int pci_thunderx_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 	struct pci_controller *hose = dev_get_uclass_priv(bus);
 	uintptr_t address;
 	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
 
-	b = PCI_BUS(bdf) + pcie->bus.start + 1 - hose->first_busno;
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
 	d = PCI_DEV(bdf);
 	f = PCI_FUNC(bdf);
 
-	address = (b << 24) | (d << 19) | (f << 16) | offset;
+	address = (b << 24) | (d << 19) | (f << 16);
 
 	address += pcie->cfg.start;
 
 	*valuep = pci_conv_32_to_size(~0UL, offset, size);
 
-	if (d == 0) {
-		switch (size) {
-		case PCI_SIZE_8:
-			*valuep = readb(address);
-			break;
-		case PCI_SIZE_16:
-			*valuep = readw(address);
-			break;
-		case PCI_SIZE_32:
-			*valuep = readl(address);
-			break;
-		};
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = readb(address + offset);
+		break;
+	case PCI_SIZE_16:
+		*valuep = readw(address + offset);
+		break;
+	case PCI_SIZE_32:
+		*valuep = readl(address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
+	    (offset >= PCI_PRIMARY_BUS) &&
+	    (offset <= PCI_SUBORDINATE_BUS) &&
+	    *valuep != pci_conv_32_to_size(~0UL, offset, size)) {
+		*valuep -= pci_conv_32_to_size(bus_offs, offset, size);
 	}
 /*
 	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
@@ -140,38 +157,53 @@ static int pci_thunderx_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 }
 
 static int pci_thunderx_pem_write_config(struct udevice *bus, pci_dev_t bdf,
-				 uint offset, ulong valuep,
+				 uint offset, ulong value,
 				 enum pci_size_t size)
 {
 	struct thunderx_pci *pcie = (void *)dev_get_priv(bus);
 	struct pci_controller *hose = dev_get_uclass_priv(bus);
 	uintptr_t address;
 	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
 
-	b = PCI_BUS(bdf) + pcie->bus.start + 1 - hose->first_busno;
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
 	d = PCI_DEV(bdf);
 	f = PCI_FUNC(bdf);
 
-	address = (b << 24) | (d << 19) | (f << 16) | offset;
+	address = (b << 24) | (d << 19) | (f << 16);
 
 	address += pcie->cfg.start;
 
-	if (d == 0) {
-		switch (size) {
-		case PCI_SIZE_8:
-			writeb(valuep, address);
-			break;
-		case PCI_SIZE_16:
-			writew(valuep, address);
-			break;
-		case PCI_SIZE_32:
-			writel(valuep, address);
-			break;
-		};
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
+	    (offset >= PCI_PRIMARY_BUS) &&
+	    (offset <= PCI_SUBORDINATE_BUS) &&
+	    (value != pci_conv_32_to_size(~0UL, offset, size))) {
+		value +=  pci_conv_32_to_size(bus_offs, offset, size);
+	}
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		writeb(value, address + offset);
+		break;
+	case PCI_SIZE_16:
+		writew(value, address + offset);
+		break;
+	case PCI_SIZE_32:
+		writel(value, address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
 	}
 /*
 	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
-	      b, d, f, size, offset, address, valuep);
+	      b, d, f, size, offset, address, value);
 */
 	return 0;
 }
@@ -193,7 +225,12 @@ static int pci_thunderx_ecam_probe(struct udevice *dev)
 		return err;
 	}
 
-	err = fdt_get_resource(gd->fdt_blob, dev->of_offset, "bus-range", 0, &pcie->bus);
+	err = fdtdec_get_pci_bus_range(gd->fdt_blob, dev->of_offset, &pcie->bus);
+
+	if (err) {
+		printf("Error reading resource: %s\n", fdt_strerror(err));
+		return err;
+	}
 
 	return 0;
 }
-- 
2.29.0

