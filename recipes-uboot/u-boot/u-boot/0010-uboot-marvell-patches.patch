From 253dec472f094d81793fc705ee1db1f52f01bad8 Mon Sep 17 00:00:00 2001
From: Alon Rotman <alon.rotman@solid-run.com>
Date: Wed, 12 Jan 2022 16:32:37 +0200
Subject: [PATCH 10/16] uboot: marvell patches

Signed-off-by: Alon Rotman <alon.rotman@solid-run.com>
---
 MAINTAINERS                                   |    16 +
 README                                        |     7 +
 arch/arm/Kconfig                              |    24 +-
 arch/arm/Makefile                             |     2 +
 arch/arm/cpu/armv8/cache_v8.c                 |    39 +-
 arch/arm/dts/Makefile                         |    50 +-
 arch/arm/dts/armada-3720-db.dts               |    71 +-
 arch/arm/dts/armada-3720-ddr3-db-v1-A.dts     |    43 +
 arch/arm/dts/armada-3720-ddr3-db-v1-B.dts     |    55 +
 arch/arm/dts/armada-3720-ddr3-db-v1-C.dts     |    62 +
 arch/arm/dts/armada-3720-ddr3-db-v2-B.dts     |    55 +
 arch/arm/dts/armada-3720-ddr3-db-v2-C.dts     |    62 +
 arch/arm/dts/armada-3720-ddr4-db-v1-A.dts     |    47 +
 arch/arm/dts/armada-3720-ddr4-db-v1-B.dts     |    56 +
 arch/arm/dts/armada-3720-ddr4-db-v3-A.dts     |    33 +
 arch/arm/dts/armada-3720-ddr4-db-v3-B.dts     |    56 +
 arch/arm/dts/armada-3720-ddr4-db-v3-C.dts     |    63 +
 arch/arm/dts/armada-3720-espressobin-emmc.dts |    19 +
 arch/arm/dts/armada-3720-espressobin.dts      |   110 +-
 arch/arm/dts/armada-3720-turris-mox.dts       |    12 +-
 arch/arm/dts/armada-3720-uDPU.dts             |    12 +-
 arch/arm/dts/armada-375-db.dts                |     2 +
 arch/arm/dts/armada-385-ap.dts                |   181 +
 arch/arm/dts/armada-388-gp.dts                |    39 +-
 arch/arm/dts/armada-38x.dtsi                  |     8 +
 arch/arm/dts/armada-7020-amc.dts              |   212 +
 arch/arm/dts/armada-7020-comexp.dts           |   199 +
 arch/arm/dts/armada-7040-db-B.dts             |   221 +
 arch/arm/dts/armada-7040-db-C.dts             |   222 +
 arch/arm/dts/armada-7040-db-D.dts             |   201 +
 arch/arm/dts/armada-7040-db-E.dts             |   233 +
 arch/arm/dts/armada-7040-db-F.dts             |   235 +
 arch/arm/dts/armada-7040-db-nand.dts          |   223 -
 arch/arm/dts/armada-7040-db.dts               |   111 +-
 arch/arm/dts/armada-7040-dev-info.dtsi        |    73 +
 arch/arm/dts/armada-7040-pcac.dts             |   222 +
 arch/arm/dts/armada-7040.dtsi                 |    56 -
 arch/arm/dts/armada-70x0-db.dtsi              |    90 +
 arch/arm/dts/armada-70x0.dtsi                 |    69 +
 arch/arm/dts/armada-8020.dtsi                 |    74 +-
 arch/arm/dts/armada-8040-clearfog-gt-8k.dts   |   107 +-
 arch/arm/dts/armada-8040-db-B.dts             |   339 +
 arch/arm/dts/armada-8040-db-C.dts             |   334 +
 arch/arm/dts/armada-8040-db-D.dts             |   316 +
 arch/arm/dts/armada-8040-db-E.dts             |   331 +
 arch/arm/dts/armada-8040-db-F.dts             |   395 +
 arch/arm/dts/armada-8040-db-G.dts             |   344 +
 arch/arm/dts/armada-8040-db-H.dts             |   351 +
 arch/arm/dts/armada-8040-db.dts               |   161 +-
 arch/arm/dts/armada-8040-dev-info.dtsi        |    64 +
 .../arm/dts/armada-8040-mcbin-single-shot.dts |    28 +
 arch/arm/dts/armada-8040-mcbin.dts            |   190 +-
 arch/arm/dts/armada-8040-ocp.dts              |   339 +
 arch/arm/dts/armada-8040-ucpe.dts             |   382 +
 arch/arm/dts/armada-8040.dtsi                 |    90 +-
 arch/arm/dts/armada-80x0-db.dtsi              |   143 +
 arch/arm/dts/armada-8k.dtsi                   |    20 +
 arch/arm/dts/armada-ap806-quad.dtsi           |    82 -
 arch/arm/dts/armada-ap806.dtsi                |   235 +-
 arch/arm/dts/armada-ap807.dtsi                |    42 +
 arch/arm/dts/armada-ap80x-quad.dtsi           |    45 +
 arch/arm/dts/armada-ap80x.dtsi                |   144 +
 arch/arm/dts/armada-common.dtsi               |    30 +
 arch/arm/dts/armada-cp110-master.dtsi         |   370 -
 arch/arm/dts/armada-cp110-slave.dtsi          |   343 -
 arch/arm/dts/armada-cp110.dtsi                |   368 +
 arch/arm/dts/cn9130-crb-A.dts                 |    57 +
 arch/arm/dts/cn9130-crb-B.dts                 |    61 +
 arch/arm/dts/cn9130-crb-C.dts                 |    67 +
 arch/arm/dts/cn9130-crb-r1p3-A.dts            |    15 +
 arch/arm/dts/cn9130-crb-r1p3-B.dts            |    15 +
 arch/arm/dts/cn9130-crb-r1p3-C.dts            |    15 +
 arch/arm/dts/cn9130-crb-r1p3.dtsi             |    44 +
 arch/arm/dts/cn9130-crb.dtsi                  |   229 +
 arch/arm/dts/cn9130-db-A.dts                  |   214 +
 arch/arm/dts/cn9130-db-B.dts                  |   225 +
 arch/arm/dts/cn9130-db-C.dts                  |   237 +
 arch/arm/dts/cn9130-db-dev-info.dtsi          |    44 +
 arch/arm/dts/cn9130-db.dtsi                   |   153 +
 arch/arm/dts/cn9130.dtsi                      |    87 +
 arch/arm/dts/cn9131-db-A.dts                  |    56 +
 arch/arm/dts/cn9131-db-B.dts                  |    71 +
 arch/arm/dts/cn9131-db-C.dts                  |    55 +
 arch/arm/dts/cn9131-db.dtsi                   |   178 +
 arch/arm/dts/cn9132-db-A.dts                  |   109 +
 arch/arm/dts/cn9132-db-B.dts                  |   109 +
 arch/arm/dts/cn9132-db-C.dts                  |   104 +
 arch/arm/dts/cn9132-db.dtsi                   |   134 +
 arch/arm/dts/thunderx-88xx.dts                |    30 -
 arch/arm/dts/thunderx-88xx.dtsi               |   362 -
 arch/arm/include/asm/arch-armada3700/efuse.h  |   137 +
 arch/arm/include/asm/arch-armada3700/mbox.h   |    91 +
 .../arm/include/asm/arch-armada8k/cache_llc.h |     5 +
 arch/arm/include/asm/arch-mvebu/thermal.h     |    37 +
 arch/arm/include/asm/arch-octeontx/board.h    |   124 +
 arch/arm/include/asm/arch-octeontx/clock.h    |    25 +
 .../asm/arch-octeontx/csrs/csrs-mio_emm.h     |  1199 ++
 .../include/asm/arch-octeontx/csrs/csrs-xcv.h |   428 +
 arch/arm/include/asm/arch-octeontx/gpio.h     |     6 +
 arch/arm/include/asm/arch-octeontx/lock.h     |   139 +
 arch/arm/include/asm/arch-octeontx/smc.h      |    20 +
 arch/arm/include/asm/arch-octeontx/soc.h      |    73 +
 arch/arm/include/asm/arch-octeontx2/board.h   |   190 +
 arch/arm/include/asm/arch-octeontx2/clock.h   |    24 +
 .../asm/arch-octeontx2/csrs/csrs-cgx.h        |  7841 ++++++++++++
 .../asm/arch-octeontx2/csrs/csrs-lmt.h        |    60 +
 .../asm/arch-octeontx2/csrs/csrs-mio_emm.h    |  1199 ++
 .../asm/arch-octeontx2/csrs/csrs-nix.h        | 10548 ++++++++++++++++
 .../asm/arch-octeontx2/csrs/csrs-npa.h        |  2298 ++++
 .../asm/arch-octeontx2/csrs/csrs-npc.h        |  1936 +++
 .../asm/arch-octeontx2/csrs/csrs-rvu.h        |  2480 ++++
 arch/arm/include/asm/arch-octeontx2/gpio.h    |     6 +
 arch/arm/include/asm/arch-octeontx2/lock.h    |   139 +
 arch/arm/include/asm/arch-octeontx2/smc-id.h  |    41 +
 arch/arm/include/asm/arch-octeontx2/smc.h     |    26 +
 arch/arm/include/asm/arch-octeontx2/soc.h     |    35 +
 arch/arm/include/asm/io.h                     |     8 +
 arch/arm/include/asm/system.h                 |     5 +
 arch/arm/lib/interrupts_64.c                  |     6 +
 arch/arm/mach-mvebu/Kconfig                   |    43 +-
 arch/arm/mach-mvebu/Makefile                  |     4 +-
 arch/arm/mach-mvebu/arm64-common.c            |    79 +-
 arch/arm/mach-mvebu/armada3700/Kconfig        |    12 +
 arch/arm/mach-mvebu/armada3700/Makefile       |     3 +
 arch/arm/mach-mvebu/armada3700/clock.c        |   244 +
 arch/arm/mach-mvebu/armada3700/cpu.c          |    20 +
 arch/arm/mach-mvebu/armada3700/efuse.c        |   448 +
 arch/arm/mach-mvebu/armada3700/mbox.c         |   170 +
 arch/arm/mach-mvebu/armada8k/Makefile         |     2 +
 arch/arm/mach-mvebu/armada8k/clock.c          |    53 +
 arch/arm/mach-mvebu/armada8k/cpu.c            |   103 +-
 arch/arm/mach-mvebu/armada8k/soc.c            |   347 +
 arch/arm/mach-mvebu/cpu.c                     |    53 +-
 arch/arm/mach-mvebu/efuse.c                   |   263 -
 arch/arm/mach-mvebu/include/mach/clock.h      |    23 +
 arch/arm/mach-mvebu/include/mach/cpu.h        |     3 +-
 arch/arm/mach-mvebu/include/mach/efuse.h      |    68 -
 arch/arm/mach-mvebu/include/mach/fw_info.h    |    23 +
 arch/arm/mach-mvebu/include/mach/soc.h        |    54 +
 arch/arm/mach-mvebu/spl.c                     |     1 +
 arch/arm/mach-octeontx/Kconfig                |    23 +
 arch/arm/mach-octeontx/Makefile               |     8 +
 arch/arm/mach-octeontx/clock.c                |    35 +
 arch/arm/mach-octeontx/cpu.c                  |    78 +
 arch/arm/mach-octeontx/lowlevel_init.S        |    33 +
 arch/arm/mach-octeontx2/Kconfig               |    32 +
 arch/arm/mach-octeontx2/Makefile              |     8 +
 arch/arm/mach-octeontx2/clock.c               |    35 +
 arch/arm/mach-octeontx2/config.mk             |     4 +
 arch/arm/mach-octeontx2/cpu.c                 |    75 +
 arch/arm/mach-octeontx2/lowlevel_init.S       |    33 +
 board/Marvell/common/Kconfig                  |    22 +
 board/Marvell/common/Makefile                 |     9 +
 board/Marvell/common/cfg_eeprom.c             |   385 +
 board/Marvell/common/sar.c                    |   516 +
 board/Marvell/db-88f6820-ap/Makefile          |     8 +
 board/Marvell/db-88f6820-ap/db-88f6820-ap.c   |   140 +
 board/Marvell/db-88f6820-ap/kwbimage.cfg      |    12 +
 board/Marvell/mvebu_armada-37xx/board.c       |    82 +
 board/Marvell/mvebu_armada-8k/board.c         |   209 +-
 board/Marvell/octeontx/Kconfig                |    14 +
 board/Marvell/octeontx/MAINTAINERS            |     9 +
 board/Marvell/octeontx/Makefile               |     9 +
 board/Marvell/octeontx/board-fdt.c            |   347 +
 board/Marvell/octeontx/board.c                |   321 +
 board/Marvell/octeontx/smc.c                  |    29 +
 board/Marvell/octeontx/soc-utils.c            |    60 +
 board/Marvell/octeontx2/Kconfig               |    18 +
 board/Marvell/octeontx2/MAINTAINERS           |     9 +
 board/Marvell/octeontx2/Makefile              |     9 +
 board/Marvell/octeontx2/board-fdt.c           |   221 +
 board/Marvell/octeontx2/board.c               |   441 +
 board/Marvell/octeontx2/smc.c                 |   142 +
 board/Marvell/octeontx2/soc-utils.c           |    53 +
 board/Marvell/octeontx2_cn913x/MAINTAINERS    |     4 +
 board/Marvell/octeontx2_cn913x/Makefile       |     8 +
 board/Marvell/octeontx2_cn913x/board.c        |   121 +
 board/cavium/thunderx/Kconfig                 |    27 -
 board/cavium/thunderx/MAINTAINERS             |     6 -
 board/cavium/thunderx/Makefile                |     6 -
 board/cavium/thunderx/atf.c                   |   309 -
 board/cavium/thunderx/thunderx.c              |   128 -
 board/raspberrypi/rpi/rpi.c                   |    10 +
 cmd/Kconfig                                   |    17 +
 cmd/Makefile                                  |     4 +
 cmd/fdt.c                                     |     3 +-
 cmd/marvell/Kconfig                           |    41 +
 cmd/marvell/Makefile                          |    16 +
 cmd/marvell/bootimgup.c                       |  1251 ++
 cmd/marvell/eth_cmds.c                        |   225 +
 cmd/marvell/mdio_dbg.c                        |    83 +
 cmd/marvell/octeontx2_attest_cmds.c           |   282 +
 cmd/marvell/octeontx2_failsafe_cmds.c         |    22 +
 cmd/marvell/octeontx2_qlm_cmds.c              |    86 +
 cmd/mem.c                                     |    95 +
 cmd/mii.c                                     |    19 +
 cmd/mmc.c                                     |     4 +-
 cmd/mtdparts.c                                |     2 +-
 cmd/mvebu/Kconfig                             |   147 +-
 cmd/mvebu/Makefile                            |    13 +
 cmd/mvebu/avs.c                               |   102 +
 cmd/mvebu/bubt.c                              |    89 +-
 cmd/mvebu/ddr_phy.c                           |    70 +
 cmd/mvebu/efuse.c                             |   138 +
 cmd/mvebu/hw_info.c                           |   297 +
 cmd/mvebu/map.c                               |   254 +
 cmd/mvebu/mv88e6xxx-util.c                    |   633 +
 cmd/mvebu/mv88e6xxx-util.h                    |   397 +
 cmd/mvebu/mv_fw_info.c                        |    78 +
 cmd/mvebu/mv_get_counters.c                   |   184 +
 cmd/mvebu/pxa3xx_nand_oem.c                   |   587 +
 cmd/mvebu/rx_training.c                       |    56 +
 cmd/mvebu/sar.c                               |   108 +
 cmd/mvebu/thermal.c                           |    47 +
 common/board_f.c                              |     4 +
 common/board_r.c                              |    13 +
 common/fdt_support.c                          |     2 +
 common/usb_hub.c                              |     3 +-
 configs/clearfog_defconfig                    |     1 -
 configs/db-88f6720_defconfig                  |     1 +
 configs/db-88f6820-amc_defconfig              |     1 +
 configs/db-88f6820-ap_defconfig               |    66 +
 configs/db-88f6820-gp_defconfig               |    17 +-
 configs/mvebu_comexpress-88f7020_defconfig    |    97 +
 configs/mvebu_crb_cn9130_defconfig            |   102 +
 configs/mvebu_crb_ep_cn9130_defconfig         |   105 +
 configs/mvebu_db-88f3720_defconfig            |    20 +-
 configs/mvebu_db_armada8k_defconfig           |    39 +-
 configs/mvebu_db_cn91xx_defconfig             |    98 +
 configs/mvebu_db_ep_cn91xx_defconfig          |   102 +
 configs/mvebu_espressobin-88f3720_defconfig   |    20 +-
 configs/mvebu_mcbin-88f8040_defconfig         |    26 +-
 configs/mvebu_ocp-88f8040_defconfig           |    93 +
 configs/mvebu_ucpe-88f8040_defconfig          |    86 +
 configs/octeontx2_95mm_defconfig              |   108 +
 configs/octeontx2_95xx_defconfig              |   109 +
 configs/octeontx2_96xx_defconfig              |   140 +
 configs/octeontx2_98xx_defconfig              |   133 +
 configs/octeontx2_loki_defconfig              |   112 +
 configs/octeontx_81xx_defconfig               |   136 +
 configs/octeontx_83xx_defconfig               |   137 +
 configs/thunderx_88xx_defconfig               |    29 -
 doc/device-tree-bindings/mmc/xenon-mmc.txt    |    46 +
 doc/device-tree-bindings/net/ethernet.txt     |     4 +-
 doc/device-tree-bindings/phy/mvebu_comphy.txt |    68 +
 .../regulator/regulator.txt                   |     1 +
 doc/device-tree-bindings/rtc/marvell-rtc.txt  |    23 +
 doc/device-tree-bindings/spi/mvebu-spi.txt    |    73 +
 .../thermal/mvebu-thermal.txt                 |    63 +
 .../usb/marvell.ehci-usb.txt                  |    22 +
 .../usb/marvell.xhci-usb.txt                  |     3 +
 doc/mvebu/a3700/armada-3700-db-setup.txt      |    76 +
 doc/mvebu/a7k-a8k/armada3900-db-setup.txt     |   126 +
 doc/mvebu/a7k-a8k/armada70x0-db-setup.txt     |   243 +
 doc/mvebu/a7k-a8k/armada80x0-db-setup.txt     |   307 +
 doc/mvebu/build.txt                           |   210 +
 doc/mvebu/linux_boot.txt                      |    42 +
 doc/mvebu/porting_guide.txt                   |   128 +
 doc/mvebu/trusted_boot.txt                    |   540 +
 doc/mvebu/uart_boot.txt                       |   116 +
 doc/mvebu/uboot_cmd.txt                       |   366 +
 drivers/Kconfig                               |     2 +
 drivers/Makefile                              |    10 +-
 drivers/ata/ahci.c                            |   130 +-
 drivers/fuse/Kconfig                          |    24 +
 drivers/fuse/Makefile                         |     4 +
 drivers/fuse/fuse-mvebu-hd.c                  |   163 +
 drivers/fuse/fuse-mvebu-init.c                |    33 +
 drivers/fuse/fuse-mvebu-ld.c                  |   111 +
 drivers/fuse/fuse-mvebu.c                     |   266 +
 drivers/gpio/Kconfig                          |    18 +
 drivers/gpio/Makefile                         |     2 +
 drivers/gpio/i2c_gpio.c                       |   236 +
 drivers/gpio/mvebu_gpio.c                     |    19 +-
 drivers/gpio/octeontx_gpio.c                  |   218 +
 drivers/i2c/Kconfig                           |     7 +
 drivers/i2c/Makefile                          |     1 +
 drivers/i2c/i2c-uclass.c                      |     3 +
 drivers/i2c/muxes/Kconfig                     |     4 +-
 drivers/i2c/muxes/pca954x.c                   |     6 +
 drivers/i2c/mv_i2c.c                          |    29 +-
 drivers/i2c/mvtwsi.c                          |     6 +-
 drivers/i2c/octeontx_i2c.c                    |   968 ++
 drivers/misc/Makefile                         |     1 +
 drivers/misc/mvebu_sar/Makefile               |    12 +
 drivers/misc/mvebu_sar/ap806_sar.c            |   263 +
 drivers/misc/mvebu_sar/ap807_sar.c            |   244 +
 drivers/misc/mvebu_sar/cp110_sar.c            |   236 +
 drivers/misc/mvebu_sar/sar-uclass.c           |   146 +
 drivers/mmc/Kconfig                           |    11 +
 drivers/mmc/Makefile                          |     1 +
 drivers/mmc/mmc.c                             |    12 +-
 drivers/mmc/octeontx_hsmmc.c                  |  3867 ++++++
 drivers/mmc/octeontx_hsmmc.h                  |   207 +
 drivers/mmc/xenon_sdhci.c                     |   534 +-
 drivers/mtd/nand/raw/Kconfig                  |    16 +
 drivers/mtd/nand/raw/Makefile                 |     2 +
 drivers/mtd/nand/raw/octeontx_bch.c           |   424 +
 drivers/mtd/nand/raw/octeontx_bch.h           |   142 +
 drivers/mtd/nand/raw/octeontx_bch_regs.h      |   169 +
 drivers/mtd/nand/raw/octeontx_nand.c          |  2256 ++++
 drivers/mtd/nand/raw/pxa3xx_nand.c            |   183 +-
 drivers/mtd/nand/raw/pxa3xx_nand.h            |   107 +
 drivers/mtd/spi/spi-nor-core.c                |   155 +-
 drivers/mtd/spi/spi-nor-ids.c                 |    21 +-
 drivers/net/Kconfig                           |    32 +
 drivers/net/Makefile                          |     4 +
 drivers/net/e1000.c                           |    25 +-
 drivers/net/mvneta.c                          |    17 +-
 drivers/net/mvpp2.c                           |   589 +-
 drivers/net/octeontx/Makefile                 |     9 +
 drivers/net/octeontx/bgx.c                    |  1574 +++
 drivers/net/octeontx/bgx.h                    |   259 +
 drivers/net/octeontx/nic.h                    |   518 +
 drivers/net/octeontx/nic_main.c               |   776 ++
 drivers/net/octeontx/nic_reg.h                |   252 +
 drivers/net/octeontx/nicvf_main.c             |   581 +
 drivers/net/octeontx/nicvf_queues.c           |  1141 ++
 drivers/net/octeontx/nicvf_queues.h           |   355 +
 drivers/net/octeontx/q_struct.h               |   697 +
 drivers/net/octeontx/smi.c                    |   382 +
 drivers/net/octeontx/xcv.c                    |   129 +
 drivers/net/octeontx2/Makefile                |    10 +
 drivers/net/octeontx2/cgx.c                   |   298 +
 drivers/net/octeontx2/cgx.h                   |   113 +
 drivers/net/octeontx2/cgx_intf.c              |   714 ++
 drivers/net/octeontx2/cgx_intf.h              |   450 +
 drivers/net/octeontx2/lmt.h                   |    51 +
 drivers/net/octeontx2/nix.c                   |   831 ++
 drivers/net/octeontx2/nix.h                   |   356 +
 drivers/net/octeontx2/nix_af.c                |  1104 ++
 drivers/net/octeontx2/npc.h                   |    91 +
 drivers/net/octeontx2/rvu.h                   |   143 +
 drivers/net/octeontx2/rvu_af.c                |   219 +
 drivers/net/octeontx2/rvu_common.c            |    74 +
 drivers/net/octeontx2/rvu_pf.c                |   138 +
 drivers/net/phy/Kconfig                       |     9 +
 drivers/net/phy/Makefile                      |     2 +
 drivers/net/phy/marvell.c                     |   269 +-
 drivers/net/phy/mv88e6xxx.c                   |   604 +
 drivers/net/phy/mv88e6xxx.h                   |   393 +
 drivers/net/phy/mvebu_fw_download.c           |   559 +
 drivers/net/phy/phy.c                         |     2 +-
 drivers/nvme/nvme.c                           |     3 +-
 drivers/pci/Kconfig                           |    17 +
 drivers/pci/Makefile                          |     1 +
 drivers/pci/pci-aardvark.c                    |     8 +
 drivers/pci/pci-uclass.c                      |   211 +-
 drivers/pci/pci_mvebu.c                       |    16 +
 drivers/pci/pci_octeontx.c                    |   553 +
 drivers/pci/pcie_dw_mvebu.c                   |    37 +-
 drivers/phy/marvell/Makefile                  |     1 -
 drivers/phy/marvell/comphy_a3700.c            |   880 +-
 drivers/phy/marvell/comphy_a3700.h            |   176 +-
 drivers/phy/marvell/comphy_core.c             |    85 +-
 drivers/phy/marvell/comphy_core.h             |    78 +-
 drivers/phy/marvell/comphy_cp110.c            |  1818 +--
 drivers/phy/marvell/comphy_hpipe.h            |   660 -
 drivers/phy/marvell/comphy_mux.c              |   135 -
 drivers/phy/marvell/utmi_phy.h                |    29 +-
 drivers/pinctrl/mvebu/pinctrl-armada-37xx.c   |     4 +-
 drivers/pinctrl/mvebu/pinctrl-mvebu.c         |     7 +-
 drivers/power/regulator/regulator-uclass.c    |    38 +
 drivers/rtc/Kconfig                           |    16 +
 drivers/rtc/Makefile                          |     1 +
 drivers/rtc/ds1337.c                          |   171 +
 drivers/rtc/marvell_rtc.c                     |   187 +
 drivers/rtc/marvell_rtc.h                     |    54 +
 drivers/serial/Kconfig                        |    25 +
 drivers/serial/Makefile                       |     2 +
 drivers/serial/serial_octeontx_bootcmd.c      |   300 +
 drivers/serial/serial_octeontx_pcie_console.c |  1156 ++
 drivers/serial/serial_octeontx_pcie_console.h |   271 +
 drivers/serial/serial_pl01x.c                 |     3 +
 drivers/spi/Kconfig                           |     6 +
 drivers/spi/Makefile                          |     1 +
 drivers/spi/kirkwood_spi.c                    |   161 +-
 drivers/spi/mvebu_a3700_spi.c                 |   391 +-
 drivers/spi/octeontx_spi.c                    |   766 ++
 drivers/thermal/Kconfig                       |    31 +
 drivers/thermal/Makefile                      |     3 +
 drivers/thermal/mvebu_ext_thermal_28nm.c      |   141 +
 drivers/thermal/mvebu_thermal_28nm.c          |    87 +
 drivers/thermal/mvebu_thermal_core.c          |   143 +
 drivers/usb/eth/usb_ether.c                   |     1 +
 drivers/usb/host/ehci-marvell.c               |    45 +-
 drivers/usb/host/xhci-mem.c                   |    10 +
 drivers/usb/host/xhci-mvebu.c                 |    43 +-
 drivers/usb/host/xhci-ring.c                  |    23 +
 drivers/usb/host/xhci.c                       |     3 +-
 drivers/usb/host/xhci.h                       |    10 +
 drivers/watchdog/Kconfig                      |    10 +
 drivers/watchdog/Makefile                     |     1 +
 drivers/watchdog/octeontx_wdt.c               |    76 +
 env/common.c                                  |    12 +
 env/sf.c                                      |    23 +-
 fs/ext4/ext4_common.c                         |    41 +-
 fs/ext4/ext4_write.c                          |     2 +-
 include/ahci.h                                |     7 +-
 include/cavium/atf.h                          |     2 +-
 include/cavium/thunderx_svc.h                 |     3 +
 include/configs/db-88f6820-ap.h               |   131 +
 include/configs/db-88f6820-gp.h               |    12 +-
 include/configs/mv-common.h                   |    57 +
 include/configs/mvebu_armada-37xx.h           |    94 +-
 include/configs/mvebu_armada-8k.h             |    90 +-
 include/configs/mvebu_armada-common.h         |   175 +
 include/configs/octeontx2_95mm.h              |    85 +
 include/configs/octeontx2_95xx.h              |    85 +
 include/configs/octeontx2_96xx.h              |    96 +
 include/configs/octeontx2_98xx.h              |    95 +
 include/configs/octeontx2_cn913x.h            |    43 +
 include/configs/octeontx2_loki.h              |    86 +
 include/configs/octeontx_common.h             |   101 +
 include/configs/thunderx_88xx.h               |   237 +-
 include/dm/uclass-id.h                        |     1 +
 include/dt-bindings/comphy/comphy_data.h      |    80 +-
 include/env.h                                 |    10 +
 include/ext4fs.h                              |     3 +
 include/fdtdec.h                              |    15 +
 include/linux/ethtool.h                       |     3 +-
 include/linux/mtd/spi-nor.h                   |     1 +
 include/miiphy.h                              |     4 +
 include/mmc.h                                 |     1 +
 include/mvebu/cfg_eeprom.h                    |    95 +
 include/mvebu/comphy.h                        |     2 +-
 include/mvebu/fuse-mvebu.h                    |    54 +
 include/mvebu/mvebu_chip_sar.h                |    75 +
 include/mvebu/sar.h                           |    60 +
 include/mvebu/var.h                           |    31 +
 include/net.h                                 |     4 +
 include/pci.h                                 |    26 +-
 include/pci_ep.h                              |     2 +
 include/pci_ids.h                             |     2 +
 include/phy.h                                 |    11 +-
 include/phy_interface.h                       |     6 +
 include/power/regulator.h                     |    23 +
 include/sar-uclass.h                          |    27 +
 lib/fdtdec.c                                  |    24 +-
 localversion                                  |     1 +
 net/bootp.c                                   |     9 +
 scripts/checkpatch.pl                         |   397 +-
 scripts/ci/baseline.txt                       |     7 +
 scripts/ci/compile.sh                         |   244 +
 scripts/ci/pack.sh                            |    25 +
 scripts/ci/pack_source.sh                     |    42 +
 scripts/ci/supported_builds.txt               |    78 +
 scripts/config                                |   225 +
 scripts/const_structs.checkpatch              |    66 +-
 scripts/spelling.txt                          |   159 +
 tools/mrvl_uart.sh                            |    42 +-
 451 files changed, 86332 insertions(+), 7560 deletions(-)
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
 create mode 100644 arch/arm/dts/armada-3720-espressobin-emmc.dts
 create mode 100644 arch/arm/dts/armada-385-ap.dts
 create mode 100644 arch/arm/dts/armada-7020-amc.dts
 create mode 100644 arch/arm/dts/armada-7020-comexp.dts
 create mode 100644 arch/arm/dts/armada-7040-db-B.dts
 create mode 100644 arch/arm/dts/armada-7040-db-C.dts
 create mode 100644 arch/arm/dts/armada-7040-db-D.dts
 create mode 100644 arch/arm/dts/armada-7040-db-E.dts
 create mode 100644 arch/arm/dts/armada-7040-db-F.dts
 delete mode 100644 arch/arm/dts/armada-7040-db-nand.dts
 create mode 100644 arch/arm/dts/armada-7040-dev-info.dtsi
 create mode 100644 arch/arm/dts/armada-7040-pcac.dts
 delete mode 100644 arch/arm/dts/armada-7040.dtsi
 create mode 100644 arch/arm/dts/armada-70x0-db.dtsi
 create mode 100644 arch/arm/dts/armada-70x0.dtsi
 create mode 100644 arch/arm/dts/armada-8040-db-B.dts
 create mode 100644 arch/arm/dts/armada-8040-db-C.dts
 create mode 100644 arch/arm/dts/armada-8040-db-D.dts
 create mode 100644 arch/arm/dts/armada-8040-db-E.dts
 create mode 100644 arch/arm/dts/armada-8040-db-F.dts
 create mode 100644 arch/arm/dts/armada-8040-db-G.dts
 create mode 100644 arch/arm/dts/armada-8040-db-H.dts
 create mode 100644 arch/arm/dts/armada-8040-dev-info.dtsi
 create mode 100644 arch/arm/dts/armada-8040-mcbin-single-shot.dts
 create mode 100644 arch/arm/dts/armada-8040-ocp.dts
 create mode 100644 arch/arm/dts/armada-8040-ucpe.dts
 create mode 100644 arch/arm/dts/armada-80x0-db.dtsi
 create mode 100644 arch/arm/dts/armada-8k.dtsi
 delete mode 100644 arch/arm/dts/armada-ap806-quad.dtsi
 create mode 100644 arch/arm/dts/armada-ap807.dtsi
 create mode 100644 arch/arm/dts/armada-ap80x-quad.dtsi
 create mode 100644 arch/arm/dts/armada-ap80x.dtsi
 create mode 100644 arch/arm/dts/armada-common.dtsi
 delete mode 100644 arch/arm/dts/armada-cp110-master.dtsi
 delete mode 100644 arch/arm/dts/armada-cp110-slave.dtsi
 create mode 100644 arch/arm/dts/armada-cp110.dtsi
 create mode 100644 arch/arm/dts/cn9130-crb-A.dts
 create mode 100644 arch/arm/dts/cn9130-crb-B.dts
 create mode 100644 arch/arm/dts/cn9130-crb-C.dts
 create mode 100644 arch/arm/dts/cn9130-crb-r1p3-A.dts
 create mode 100644 arch/arm/dts/cn9130-crb-r1p3-B.dts
 create mode 100644 arch/arm/dts/cn9130-crb-r1p3-C.dts
 create mode 100644 arch/arm/dts/cn9130-crb-r1p3.dtsi
 create mode 100644 arch/arm/dts/cn9130-crb.dtsi
 create mode 100644 arch/arm/dts/cn9130-db-A.dts
 create mode 100644 arch/arm/dts/cn9130-db-B.dts
 create mode 100644 arch/arm/dts/cn9130-db-C.dts
 create mode 100644 arch/arm/dts/cn9130-db-dev-info.dtsi
 create mode 100644 arch/arm/dts/cn9130-db.dtsi
 create mode 100644 arch/arm/dts/cn9130.dtsi
 create mode 100644 arch/arm/dts/cn9131-db-A.dts
 create mode 100644 arch/arm/dts/cn9131-db-B.dts
 create mode 100644 arch/arm/dts/cn9131-db-C.dts
 create mode 100644 arch/arm/dts/cn9131-db.dtsi
 create mode 100644 arch/arm/dts/cn9132-db-A.dts
 create mode 100644 arch/arm/dts/cn9132-db-B.dts
 create mode 100644 arch/arm/dts/cn9132-db-C.dts
 create mode 100644 arch/arm/dts/cn9132-db.dtsi
 delete mode 100644 arch/arm/dts/thunderx-88xx.dts
 delete mode 100644 arch/arm/dts/thunderx-88xx.dtsi
 create mode 100644 arch/arm/include/asm/arch-armada3700/efuse.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/mbox.h
 create mode 100644 arch/arm/include/asm/arch-mvebu/thermal.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/board.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/clock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/gpio.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/lock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/smc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/soc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/board.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/clock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/gpio.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/lock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/smc-id.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/smc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/soc.h
 create mode 100644 arch/arm/mach-mvebu/armada3700/Kconfig
 create mode 100644 arch/arm/mach-mvebu/armada3700/clock.c
 create mode 100644 arch/arm/mach-mvebu/armada3700/efuse.c
 create mode 100644 arch/arm/mach-mvebu/armada3700/mbox.c
 create mode 100644 arch/arm/mach-mvebu/armada8k/clock.c
 create mode 100644 arch/arm/mach-mvebu/armada8k/soc.c
 delete mode 100644 arch/arm/mach-mvebu/efuse.c
 create mode 100644 arch/arm/mach-mvebu/include/mach/clock.h
 delete mode 100644 arch/arm/mach-mvebu/include/mach/efuse.h
 create mode 100644 arch/arm/mach-mvebu/include/mach/fw_info.h
 create mode 100644 arch/arm/mach-octeontx/Kconfig
 create mode 100644 arch/arm/mach-octeontx/Makefile
 create mode 100644 arch/arm/mach-octeontx/clock.c
 create mode 100644 arch/arm/mach-octeontx/cpu.c
 create mode 100644 arch/arm/mach-octeontx/lowlevel_init.S
 create mode 100644 arch/arm/mach-octeontx2/Kconfig
 create mode 100644 arch/arm/mach-octeontx2/Makefile
 create mode 100644 arch/arm/mach-octeontx2/clock.c
 create mode 100644 arch/arm/mach-octeontx2/config.mk
 create mode 100644 arch/arm/mach-octeontx2/cpu.c
 create mode 100644 arch/arm/mach-octeontx2/lowlevel_init.S
 create mode 100644 board/Marvell/common/Kconfig
 create mode 100644 board/Marvell/common/Makefile
 create mode 100644 board/Marvell/common/cfg_eeprom.c
 create mode 100644 board/Marvell/common/sar.c
 create mode 100644 board/Marvell/db-88f6820-ap/Makefile
 create mode 100644 board/Marvell/db-88f6820-ap/db-88f6820-ap.c
 create mode 100644 board/Marvell/db-88f6820-ap/kwbimage.cfg
 create mode 100644 board/Marvell/octeontx/Kconfig
 create mode 100644 board/Marvell/octeontx/MAINTAINERS
 create mode 100644 board/Marvell/octeontx/Makefile
 create mode 100644 board/Marvell/octeontx/board-fdt.c
 create mode 100644 board/Marvell/octeontx/board.c
 create mode 100644 board/Marvell/octeontx/smc.c
 create mode 100644 board/Marvell/octeontx/soc-utils.c
 create mode 100644 board/Marvell/octeontx2/Kconfig
 create mode 100644 board/Marvell/octeontx2/MAINTAINERS
 create mode 100644 board/Marvell/octeontx2/Makefile
 create mode 100644 board/Marvell/octeontx2/board-fdt.c
 create mode 100644 board/Marvell/octeontx2/board.c
 create mode 100644 board/Marvell/octeontx2/smc.c
 create mode 100644 board/Marvell/octeontx2/soc-utils.c
 create mode 100644 board/Marvell/octeontx2_cn913x/MAINTAINERS
 create mode 100644 board/Marvell/octeontx2_cn913x/Makefile
 create mode 100644 board/Marvell/octeontx2_cn913x/board.c
 delete mode 100644 board/cavium/thunderx/Kconfig
 delete mode 100644 board/cavium/thunderx/MAINTAINERS
 delete mode 100644 board/cavium/thunderx/Makefile
 delete mode 100644 board/cavium/thunderx/atf.c
 delete mode 100644 board/cavium/thunderx/thunderx.c
 create mode 100644 cmd/marvell/Kconfig
 create mode 100644 cmd/marvell/Makefile
 create mode 100644 cmd/marvell/bootimgup.c
 create mode 100644 cmd/marvell/eth_cmds.c
 create mode 100644 cmd/marvell/mdio_dbg.c
 create mode 100644 cmd/marvell/octeontx2_attest_cmds.c
 create mode 100644 cmd/marvell/octeontx2_failsafe_cmds.c
 create mode 100644 cmd/marvell/octeontx2_qlm_cmds.c
 create mode 100644 cmd/mvebu/avs.c
 create mode 100644 cmd/mvebu/ddr_phy.c
 create mode 100644 cmd/mvebu/efuse.c
 create mode 100644 cmd/mvebu/hw_info.c
 create mode 100644 cmd/mvebu/map.c
 create mode 100644 cmd/mvebu/mv88e6xxx-util.c
 create mode 100644 cmd/mvebu/mv88e6xxx-util.h
 create mode 100644 cmd/mvebu/mv_fw_info.c
 create mode 100644 cmd/mvebu/mv_get_counters.c
 create mode 100644 cmd/mvebu/pxa3xx_nand_oem.c
 create mode 100644 cmd/mvebu/rx_training.c
 create mode 100644 cmd/mvebu/sar.c
 create mode 100644 cmd/mvebu/thermal.c
 create mode 100644 configs/db-88f6820-ap_defconfig
 create mode 100644 configs/mvebu_comexpress-88f7020_defconfig
 create mode 100644 configs/mvebu_crb_cn9130_defconfig
 create mode 100644 configs/mvebu_crb_ep_cn9130_defconfig
 create mode 100644 configs/mvebu_db_cn91xx_defconfig
 create mode 100644 configs/mvebu_db_ep_cn91xx_defconfig
 create mode 100644 configs/mvebu_ocp-88f8040_defconfig
 create mode 100644 configs/mvebu_ucpe-88f8040_defconfig
 create mode 100644 configs/octeontx2_95mm_defconfig
 create mode 100644 configs/octeontx2_95xx_defconfig
 create mode 100644 configs/octeontx2_96xx_defconfig
 create mode 100644 configs/octeontx2_98xx_defconfig
 create mode 100644 configs/octeontx2_loki_defconfig
 create mode 100644 configs/octeontx_81xx_defconfig
 create mode 100644 configs/octeontx_83xx_defconfig
 delete mode 100644 configs/thunderx_88xx_defconfig
 create mode 100644 doc/device-tree-bindings/mmc/xenon-mmc.txt
 create mode 100644 doc/device-tree-bindings/phy/mvebu_comphy.txt
 create mode 100644 doc/device-tree-bindings/rtc/marvell-rtc.txt
 create mode 100644 doc/device-tree-bindings/spi/mvebu-spi.txt
 create mode 100644 doc/device-tree-bindings/thermal/mvebu-thermal.txt
 create mode 100644 doc/device-tree-bindings/usb/marvell.ehci-usb.txt
 create mode 100644 doc/mvebu/a3700/armada-3700-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada3900-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
 create mode 100644 doc/mvebu/build.txt
 create mode 100644 doc/mvebu/linux_boot.txt
 create mode 100644 doc/mvebu/porting_guide.txt
 create mode 100644 doc/mvebu/trusted_boot.txt
 create mode 100644 doc/mvebu/uart_boot.txt
 create mode 100644 doc/mvebu/uboot_cmd.txt
 create mode 100644 drivers/fuse/Kconfig
 create mode 100644 drivers/fuse/Makefile
 create mode 100644 drivers/fuse/fuse-mvebu-hd.c
 create mode 100644 drivers/fuse/fuse-mvebu-init.c
 create mode 100644 drivers/fuse/fuse-mvebu-ld.c
 create mode 100644 drivers/fuse/fuse-mvebu.c
 create mode 100644 drivers/gpio/i2c_gpio.c
 create mode 100644 drivers/gpio/octeontx_gpio.c
 create mode 100644 drivers/i2c/octeontx_i2c.c
 create mode 100644 drivers/misc/mvebu_sar/Makefile
 create mode 100644 drivers/misc/mvebu_sar/ap806_sar.c
 create mode 100644 drivers/misc/mvebu_sar/ap807_sar.c
 create mode 100644 drivers/misc/mvebu_sar/cp110_sar.c
 create mode 100644 drivers/misc/mvebu_sar/sar-uclass.c
 create mode 100644 drivers/mmc/octeontx_hsmmc.c
 create mode 100644 drivers/mmc/octeontx_hsmmc.h
 create mode 100644 drivers/mtd/nand/raw/octeontx_bch.c
 create mode 100644 drivers/mtd/nand/raw/octeontx_bch.h
 create mode 100644 drivers/mtd/nand/raw/octeontx_bch_regs.h
 create mode 100644 drivers/mtd/nand/raw/octeontx_nand.c
 mode change 100644 => 100755 drivers/mtd/spi/spi-nor-core.c
 create mode 100644 drivers/net/octeontx/Makefile
 create mode 100644 drivers/net/octeontx/bgx.c
 create mode 100644 drivers/net/octeontx/bgx.h
 create mode 100644 drivers/net/octeontx/nic.h
 create mode 100644 drivers/net/octeontx/nic_main.c
 create mode 100644 drivers/net/octeontx/nic_reg.h
 create mode 100644 drivers/net/octeontx/nicvf_main.c
 create mode 100644 drivers/net/octeontx/nicvf_queues.c
 create mode 100644 drivers/net/octeontx/nicvf_queues.h
 create mode 100644 drivers/net/octeontx/q_struct.h
 create mode 100644 drivers/net/octeontx/smi.c
 create mode 100644 drivers/net/octeontx/xcv.c
 create mode 100644 drivers/net/octeontx2/Makefile
 create mode 100644 drivers/net/octeontx2/cgx.c
 create mode 100644 drivers/net/octeontx2/cgx.h
 create mode 100644 drivers/net/octeontx2/cgx_intf.c
 create mode 100644 drivers/net/octeontx2/cgx_intf.h
 create mode 100644 drivers/net/octeontx2/lmt.h
 create mode 100644 drivers/net/octeontx2/nix.c
 create mode 100644 drivers/net/octeontx2/nix.h
 create mode 100644 drivers/net/octeontx2/nix_af.c
 create mode 100644 drivers/net/octeontx2/npc.h
 create mode 100644 drivers/net/octeontx2/rvu.h
 create mode 100644 drivers/net/octeontx2/rvu_af.c
 create mode 100644 drivers/net/octeontx2/rvu_common.c
 create mode 100644 drivers/net/octeontx2/rvu_pf.c
 create mode 100644 drivers/net/phy/mv88e6xxx.c
 create mode 100644 drivers/net/phy/mv88e6xxx.h
 create mode 100644 drivers/net/phy/mvebu_fw_download.c
 create mode 100644 drivers/pci/pci_octeontx.c
 delete mode 100644 drivers/phy/marvell/comphy_hpipe.h
 delete mode 100644 drivers/phy/marvell/comphy_mux.c
 create mode 100644 drivers/rtc/marvell_rtc.c
 create mode 100644 drivers/rtc/marvell_rtc.h
 create mode 100644 drivers/serial/serial_octeontx_bootcmd.c
 create mode 100644 drivers/serial/serial_octeontx_pcie_console.c
 create mode 100644 drivers/serial/serial_octeontx_pcie_console.h
 create mode 100644 drivers/spi/octeontx_spi.c
 create mode 100644 drivers/thermal/mvebu_ext_thermal_28nm.c
 create mode 100644 drivers/thermal/mvebu_thermal_28nm.c
 create mode 100644 drivers/thermal/mvebu_thermal_core.c
 create mode 100644 drivers/watchdog/octeontx_wdt.c
 create mode 100644 include/configs/db-88f6820-ap.h
 create mode 100644 include/configs/mvebu_armada-common.h
 create mode 100644 include/configs/octeontx2_95mm.h
 create mode 100644 include/configs/octeontx2_95xx.h
 create mode 100644 include/configs/octeontx2_96xx.h
 create mode 100644 include/configs/octeontx2_98xx.h
 create mode 100644 include/configs/octeontx2_cn913x.h
 create mode 100644 include/configs/octeontx2_loki.h
 create mode 100644 include/configs/octeontx_common.h
 create mode 100644 include/mvebu/cfg_eeprom.h
 create mode 100644 include/mvebu/fuse-mvebu.h
 create mode 100644 include/mvebu/mvebu_chip_sar.h
 create mode 100644 include/mvebu/sar.h
 create mode 100644 include/mvebu/var.h
 create mode 100644 include/sar-uclass.h
 create mode 100644 localversion
 create mode 100644 scripts/ci/baseline.txt
 create mode 100755 scripts/ci/compile.sh
 create mode 100755 scripts/ci/pack.sh
 create mode 100755 scripts/ci/pack_source.sh
 create mode 100644 scripts/ci/supported_builds.txt
 create mode 100755 scripts/config

diff --git a/MAINTAINERS b/MAINTAINERS
index c53656695a..e70ac727ad 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -170,6 +170,22 @@ F:	board/CZ.NIC/
 F:	configs/turris_*_defconfig
 F:	include/configs/turris_*.h
 
+ARM OCTEONTX
+M:	Aaron Williams <aaron.williams@cavium.com>
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	arch/arm/mach-octeontx/
+F:	arch/arm/include/asm/arch-octeontx/
+F:	board/Marvell/octeontx/
+
+ARM OCTEONTX2
+M:	Aaron Williams <aaron.williams@cavium.com>
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	arch/arm/mach-octeontx2/
+F:	arch/arm/include/asm/arch-octeontx2/
+F:	board/Marvell/octeontx2/
+
 ARM FREESCALE IMX
 M:	Stefano Babic <sbabic@denx.de>
 M:	Fabio Estevam <festevam@gmail.com>
diff --git a/README b/README
index 1389e8ff12..567a045d34 100644
--- a/README
+++ b/README
@@ -1446,6 +1446,7 @@ The following options need to be configured:
 		CONFIG_BOOTP_BOOTFILESIZE
 		CONFIG_BOOTP_SEND_HOSTNAME
 		CONFIG_BOOTP_NTPSERVER
+		CONFIG_BOOTP_TFTP_SERVERIP
 		CONFIG_BOOTP_TIMEOFFSET
 		CONFIG_BOOTP_VENDOREX
 		CONFIG_BOOTP_MAY_FAIL
@@ -1466,6 +1467,12 @@ The following options need to be configured:
 		of the "hostname" environment variable is passed as
 		option 12 to the DHCP server.
 
+		CONFIG_BOOTP_TFTP_SERVERIP - Some DHCP servers can send
+		the IP address of the TFTP server.  By setting this,
+		the DHCP client will automatically set the serverip
+		based on the response from the DHCP server via option
+		150.
+
 		CONFIG_BOOTP_DHCP_REQUEST_DELAY
 
 		A 32bit value in microseconds for a delay between
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 3b0e315061..49b2061de2 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1599,6 +1599,22 @@ config ARCH_ROCKCHIP
 	imply TPL_SYSRESET
 	imply USB_FUNCTION_FASTBOOT
 
+config ARCH_OCTEONTX
+	bool "Support OcteonTX SoCs"
+	select DM
+	select ARM64
+	select OF_CONTROL
+	select BOARD_LATE_INIT
+	select SYS_CACHE_SHIFT_7
+
+config ARCH_OCTEONTX2
+	bool "Support OcteonTX2 SoCs"
+	select DM
+	select ARM64
+	select OF_CONTROL
+	select BOARD_LATE_INIT
+	select SYS_CACHE_SHIFT_7
+
 config TARGET_THUNDERX_88XX
 	bool "Support ThunderX 88xx"
 	select ARM64
@@ -1676,6 +1692,10 @@ source "arch/arm/cpu/arm926ejs/lpc32xx/Kconfig"
 
 source "arch/arm/mach-mvebu/Kconfig"
 
+source "arch/arm/mach-octeontx/Kconfig"
+
+source "arch/arm/mach-octeontx2/Kconfig"
+
 source "arch/arm/cpu/armv7/ls102xa/Kconfig"
 
 source "arch/arm/mach-imx/mx2/Kconfig"
@@ -1753,6 +1773,8 @@ source "board/bosch/guardian/Kconfig"
 source "board/CarMediaLab/flea3/Kconfig"
 source "board/Marvell/aspenite/Kconfig"
 source "board/Marvell/gplugd/Kconfig"
+source "board/Marvell/octeontx/Kconfig"
+source "board/Marvell/octeontx2/Kconfig"
 source "board/armadeus/apf27/Kconfig"
 source "board/armltd/vexpress/Kconfig"
 source "board/armltd/vexpress64/Kconfig"
@@ -1763,7 +1785,6 @@ source "board/broadcom/bcm968580xref/Kconfig"
 source "board/broadcom/bcmcygnus/Kconfig"
 source "board/broadcom/bcmnsp/Kconfig"
 source "board/broadcom/bcmns2/Kconfig"
-source "board/cavium/thunderx/Kconfig"
 source "board/cirrus/edb93xx/Kconfig"
 source "board/eets/pdu001/Kconfig"
 source "board/emulation/qemu-arm/Kconfig"
@@ -1794,6 +1815,7 @@ source "board/hisilicon/hikey/Kconfig"
 source "board/hisilicon/hikey960/Kconfig"
 source "board/hisilicon/poplar/Kconfig"
 source "board/isee/igep003x/Kconfig"
+source "board/Marvell/common/Kconfig"
 source "board/phytec/pcm051/Kconfig"
 source "board/silica/pengwyn/Kconfig"
 source "board/spear/spear300/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 5384981c17..80c7c61061 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -79,6 +79,8 @@ machine-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip
 machine-$(CONFIG_STM32)			+= stm32
 machine-$(CONFIG_ARCH_STM32MP)		+= stm32mp
 machine-$(CONFIG_TEGRA)			+= tegra
+machine-$(CONFIG_ARCH_OCTEONTX)		+= octeontx
+machine-$(CONFIG_ARCH_OCTEONTX2)	+= octeontx2
 machine-$(CONFIG_ARCH_UNIPHIER)		+= uniphier
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_ARCH_ZYNQMP)		+= zynqmp
diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index e500e722e5..d4fc59eded 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -10,7 +10,7 @@
 #include <common.h>
 #include <asm/system.h>
 #include <asm/armv8/mmu.h>
-
+#undef DEBUG_CACHE
 DECLARE_GLOBAL_DATA_PTR;
 
 #if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF)
@@ -107,9 +107,9 @@ static u64 *find_pte(u64 addr, int level)
 	u64 idx;
 	u64 va_bits;
 	int i;
-
+#ifdef DEBUG_CACHE
 	debug("addr=%llx level=%d\n", addr, level);
-
+#endif
 	get_tcr(0, NULL, &va_bits);
 	if (va_bits < 39)
 		start_level = 1;
@@ -122,8 +122,9 @@ static u64 *find_pte(u64 addr, int level)
 	for (i = start_level; i < 4; i++) {
 		idx = (addr >> level2shift(i)) & 0x1FF;
 		pte += idx;
+#ifdef DEBUG_CACHE
 		debug("idx=%llx PTE %p at level %d: %llx\n", idx, pte, i, *pte);
-
+#endif
 		/* Found it */
 		if (i == level)
 			return pte;
@@ -162,7 +163,9 @@ static u64 *create_table(void)
 static void set_pte_table(u64 *pte, u64 *table)
 {
 	/* Point *pte to the new table */
+#ifdef DEBUG_CACHE
 	debug("Setting %p to addr=%p\n", pte, table);
+#endif
 	*pte = PTE_TYPE_TABLE | (ulong)table;
 }
 
@@ -181,8 +184,9 @@ static void split_block(u64 *pte, int level)
 		      "mem_map.", pte, old_pte);
 
 	new_table = create_table();
+#ifdef DEBUG_CACHE
 	debug("Splitting pte %p (%llx) into %p\n", pte, old_pte, new_table);
-
+#endif
 	for (i = 0; i < MAX_PTE_ENTRIES; i++) {
 		new_table[i] = old_pte | (i << levelshift);
 
@@ -190,7 +194,9 @@ static void split_block(u64 *pte, int level)
 		if ((level + 1) == 3)
 			new_table[i] |= PTE_TYPE_TABLE;
 
+#ifdef DEBUG_CACHE
 		debug("Setting new_table[%lld] = %llx\n", i, new_table[i]);
+#endif
 	}
 
 	/* Set the new table into effect */
@@ -212,7 +218,9 @@ static void add_map(struct mm_region *map)
 	while (size) {
 		pte = find_pte(virt, 0);
 		if (pte && (pte_type(pte) == PTE_TYPE_FAULT)) {
+#ifdef DEBUG_CACHE
 			debug("Creating table for virt 0x%llx\n", virt);
+#endif
 			new_table = create_table();
 			set_pte_table(pte, new_table);
 		}
@@ -223,12 +231,16 @@ static void add_map(struct mm_region *map)
 				panic("pte not found\n");
 
 			blocksize = 1ULL << level2shift(level);
+#ifdef DEBUG_CACHE
 			debug("Checking if pte fits for virt=%llx size=%llx blocksize=%llx\n",
 			      virt, size, blocksize);
+#endif
 			if (size >= blocksize && !(virt & (blocksize - 1))) {
 				/* Page fits, create block PTE */
+#ifdef DEBUG_CACHE
 				debug("Setting PTE %p to block virt=%llx\n",
 				      pte, virt);
+#endif
 				if (level == 3)
 					*pte = phys | attrs | PTE_TYPE_PAGE;
 				else
@@ -239,13 +251,17 @@ static void add_map(struct mm_region *map)
 				break;
 			} else if (pte_type(pte) == PTE_TYPE_FAULT) {
 				/* Page doesn't fit, create subpages */
+#ifdef DEBUG_CACHE
 				debug("Creating subtable for virt 0x%llx blksize=%llx\n",
 				      virt, blocksize);
+#endif
 				new_table = create_table();
 				set_pte_table(pte, new_table);
 			} else if (pte_type(pte) == PTE_TYPE_BLOCK) {
+#ifdef DEBUG_CACHE
 				debug("Split block into subtable for virt 0x%llx blksize=0x%llx\n",
 				      virt, blocksize);
+#endif
 				split_block(pte, level);
 			}
 		}
@@ -433,14 +449,16 @@ void invalidate_dcache_all(void)
  */
 inline void flush_dcache_all(void)
 {
-	int ret;
+	int __maybe_unused ret;
 
 	__asm_flush_dcache_all();
 	ret = __asm_flush_l3_dcache();
+#ifdef DEBUG_CACHE
 	if (ret)
 		debug("flushing dcache returns 0x%x\n", ret);
 	else
 		debug("flushing dcache successfully.\n");
+#endif
 }
 
 #ifndef CONFIG_SYS_DISABLE_DCACHE_OPS
@@ -529,14 +547,16 @@ static u64 set_one_region(u64 start, u64 size, u64 attrs, bool flag, int level)
 			*pte &= ~PMD_ATTRINDX_MASK;
 			*pte |= attrs & PMD_ATTRINDX_MASK;
 		}
+#ifdef DEBUG_CACHE
 		debug("Set attrs=%llx pte=%p level=%d\n", attrs, pte, level);
-
+#endif
 		return levelsize;
 	}
 
 	/* Unaligned or doesn't fit, maybe split block into table */
+#ifdef DEBUG_CACHE
 	debug("addr=%llx level=%d pte=%p (%llx)\n", start, level, pte, *pte);
-
+#endif
 	/* Maybe we need to split the block into a table */
 	if (pte_type(pte) == PTE_TYPE_BLOCK)
 		split_block(pte, level);
@@ -557,8 +577,9 @@ void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
 	u64 real_start = start;
 	u64 real_size = size;
 
+#ifdef DEBUG_CACHE
 	debug("start=%lx size=%lx\n", (ulong)start, (ulong)size);
-
+#endif
 	if (!gd->arch.tlb_emerg)
 		panic("Emergency page table not setup.");
 
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 62da168ef8..61bf75a5b6 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -171,20 +171,49 @@ dtb-$(CONFIG_TEGRA) += tegra20-harmony.dtb \
 
 dtb-$(CONFIG_ARCH_MVEBU) +=			\
 	armada-3720-db.dtb			\
+	armada-3720-ddr3-db-v2-B.dtb		\
+	armada-3720-ddr3-db-v2-C.dtb		\
+	armada-3720-ddr3-db-v1-A.dtb		\
+	armada-3720-ddr3-db-v1-B.dtb		\
+	armada-3720-ddr3-db-v1-C.dtb		\
+	armada-3720-ddr4-db-v3-A.dtb		\
+	armada-3720-ddr4-db-v3-B.dtb		\
+	armada-3720-ddr4-db-v3-C.dtb		\
+	armada-3720-ddr4-db-v1-A.dtb		\
+	armada-3720-ddr4-db-v1-B.dtb		\
 	armada-3720-espressobin.dtb		\
+	armada-3720-espressobin-emmc.dtb	\
 	armada-3720-turris-mox.dtb		\
 	armada-3720-uDPU.dtb			\
 	armada-375-db.dtb			\
 	armada-388-clearfog.dtb			\
 	armada-388-gp.dtb			\
+	armada-385-ap.dtb			\
 	armada-388-helios4.dtb			\
 	armada-385-db-88f6820-amc.dtb		\
 	armada-385-turris-omnia.dtb		\
+	armada-7020-amc.dtb			\
+	armada-7020-comexp.dtb                  \
+	armada-7040-pcac.dtb	                \
 	armada-7040-db.dtb			\
-	armada-7040-db-nand.dtb			\
+	armada-7040-db-B.dtb			\
+	armada-7040-db-C.dtb                    \
+	armada-7040-db-D.dtb			\
+	armada-7040-db-E.dtb			\
+	armada-7040-db-F.dtb			\
 	armada-8040-db.dtb			\
+	armada-8040-db-B.dtb			\
+	armada-8040-db-C.dtb			\
+	armada-8040-db-D.dtb			\
+	armada-8040-db-E.dtb			\
+	armada-8040-db-F.dtb			\
+	armada-8040-db-G.dtb			\
+	armada-8040-db-H.dtb			\
 	armada-8040-mcbin.dtb			\
+	armada-8040-mcbin-single-shot.dtb	\
 	armada-8040-clearfog-gt-8k.dtb		\
+	armada-8040-ocp.dtb			\
+	armada-8040-ucpe.dtb			\
 	armada-xp-gp.dtb			\
 	armada-xp-maxbcm.dtb			\
 	armada-xp-synology-ds414.dtb		\
@@ -193,7 +222,22 @@ dtb-$(CONFIG_ARCH_MVEBU) +=			\
 	armada-385-atl-x530.dtb			\
 	armada-385-atl-x530DP.dtb		\
 	armada-xp-db-xc3-24g4xg.dtb		\
-	armada-xp-crs305-1g-4s.dtb
+	armada-xp-crs305-1g-4s.dtb		\
+	cn9130-crb-A.dtb			\
+	cn9130-crb-B.dtb			\
+	cn9130-crb-C.dtb			\
+	cn9130-crb-r1p3-A.dtb			\
+	cn9130-crb-r1p3-B.dtb			\
+	cn9130-crb-r1p3-C.dtb			\
+	cn9130-db-A.dtb				\
+	cn9130-db-B.dtb				\
+	cn9130-db-C.dtb				\
+	cn9131-db-A.dtb				\
+	cn9131-db-B.dtb				\
+	cn9131-db-C.dtb                         \
+	cn9132-db-A.dtb				\
+	cn9132-db-B.dtb				\
+	cn9132-db-C.dtb
 
 dtb-$(CONFIG_ARCH_UNIPHIER_LD11) += \
 	uniphier-ld11-global.dtb \
@@ -306,7 +350,7 @@ dtb-$(CONFIG_AM43XX) += am437x-gp-evm.dtb am437x-sk-evm.dtb	\
 	am437x-cm-t43.dtb
 dtb-$(CONFIG_TARGET_AM3517_EVM) += am3517-evm.dtb
 dtb-$(CONFIG_TI816X) += dm8168-evm.dtb
-dtb-$(CONFIG_THUNDERX) += thunderx-88xx.dtb
+dtb-$(CONFIG_OCTEONTX) += octeontx-88xx.dtb
 
 dtb-$(CONFIG_ARCH_SOCFPGA) +=				\
 	socfpga_arria5_socdk.dtb			\
diff --git a/arch/arm/dts/armada-3720-db.dts b/arch/arm/dts/armada-3720-db.dts
index 1b219c423b..adba9ead48 100644
--- a/arch/arm/dts/armada-3720-db.dts
+++ b/arch/arm/dts/armada-3720-db.dts
@@ -49,8 +49,10 @@
 #include "armada-372x.dtsi"
 
 / {
-	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3";
-	compatible = "marvell,armada-3720-db", "marvell,armada3720", "marvell,armada3710";
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
 
 	chosen {
 		stdout-path = "serial0:115200n8";
@@ -66,17 +68,61 @@
 		device_type = "memory";
 		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
 	};
+
+	reg_usb3_vbus: usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb3-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+	};
+
+	reg_usb2_vbus: usb2_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb2-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+	};
+
+	vcc_sd_reg0: regulator@0 {
+		compatible = "regulator-gpio";
+		regulator-name = "vcc_sd0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-type = "voltage";
+		states = <1800000 0x1
+				  3300000 0x0>;
+		gpios = <&gpiosb 23 GPIO_ACTIVE_HIGH>;
+	};
+
+	vcc_sd_reg1: regulator@1 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sd1";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+	};
 };
 
 &comphy {
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
-		phy-speed = <PHY_SPEED_2_5G>;
+		phy-type = <COMPHY_TYPE_USB3>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_2_5G>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+		phy-speed = <COMPHY_SPEED_6G>;
+		phy-invert = <COMPHY_POLARITY_NO_INVERT>;
 	};
 };
 
@@ -91,6 +137,15 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c1_pins>;
 	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	expander0: pca953x@22 {
+		compatible = "nxp,pca9555";
+                #gpio-cells = <2>;
+		reg = <0x22>;
+		status = "okay";
+	};
 };
 
 /* CON3 */
@@ -100,6 +155,8 @@
 
 &sdhci0 {
 	bus-width = <4>;
+	vqmmc-supply = <&vcc_sd_reg0>;
+	vmmc-supply = <&vcc_sd_reg1>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&sdio_pins>;
 	status = "okay";
@@ -147,11 +204,13 @@
 
 /* CON29 */
 &usb2 {
+	vbus-supply = <&reg_usb2_vbus>;
 	status = "okay";
 };
 
 /* CON31 */
 &usb3 {
+	vbus-supply = <&reg_usb3_vbus>;
 	status = "okay";
 };
 
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
new file mode 100644
index 0000000000..4fe02d0acc
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy2 {
+					phy-invert =
+						<COMPHY_POLARITY_TXD_INVERT>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
new file mode 100644
index 0000000000..11122f9189
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via PHY (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1-B";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
new file mode 100644
index 0000000000..e17d5c2714
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1-C";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts b/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
new file mode 100644
index 0000000000..6f16c82491
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via PHY (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2-B";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts b/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
new file mode 100644
index 0000000000..3b5b764748
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+*/
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2-C";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts b/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
new file mode 100644
index 0000000000..76545695cd
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V1";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy2 {
+					phy-invert =
+						<COMPHY_POLARITY_NO_INVERT>;
+				};
+			};
+		};
+	};
+
+	vcc_sd_reg0: regulator@0 {
+		gpios = <&gpiosb 22 GPIO_ACTIVE_HIGH>;
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts b/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
new file mode 100644
index 0000000000..2e73878aae
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V1-B";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
new file mode 100644
index 0000000000..a956ec6cc4
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
new file mode 100644
index 0000000000..85530f78b3
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v3-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3-B";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
new file mode 100644
index 0000000000..1fa8b5409d
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v3-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1 via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3-C";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-espressobin-emmc.dts b/arch/arm/dts/armada-3720-espressobin-emmc.dts
new file mode 100644
index 0000000000..0dd59af9c0
--- /dev/null
+++ b/arch/arm/dts/armada-3720-espressobin-emmc.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-espressobin.dts"
+
+/ {
+	model = "Marvell Armada 3720 Community Board ESPRESSOBin (eMMC)";
+	compatible = "marvell,armada-3720-espressobin",
+		     "marvell,armada-3720-espressobin-emmc",
+		     "marvell,armada3720", "marvell,armada3710";
+
+};
+
+/* U11 */
+&sdhci1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/armada-3720-espressobin.dts b/arch/arm/dts/armada-3720-espressobin.dts
index 84e2c2adba..169060fb23 100644
--- a/arch/arm/dts/armada-3720-espressobin.dts
+++ b/arch/arm/dts/armada-3720-espressobin.dts
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Device Tree file for Marvell Armada 3720 community board
  * (ESPRESSOBin)
@@ -5,53 +6,15 @@
  *
  * Gregory CLEMENT <gregory.clement@free-electrons.com>
  * Konstantin Porotchkin <kostap@marvell.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED , WITHOUT WARRANTY OF ANY KIND
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
  */
-
 /dts-v1/;
 
 #include "armada-372x.dtsi"
 
 / {
 	model = "Marvell Armada 3720 Community Board ESPRESSOBin";
-	compatible = "marvell,armada-3720-espressobin", "marvell,armada3720", "marvell,armada3710";
+	compatible = "marvell,armada-3720-espressobin",
+		     "marvell,armada3720", "marvell,armada3710";
 
 	chosen {
 		stdout-path = "serial0:115200n8";
@@ -67,23 +30,48 @@
 		device_type = "memory";
 		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
 	};
+
+	vcc_sd_reg0: regulator@0 {
+		compatible = "regulator-gpio";
+		regulator-name = "vcc_sd0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-type = "voltage";
+		states = <1800000 0x1
+			  3300000 0x0>;
+		gpios = <&gpionb 4 GPIO_ACTIVE_HIGH>;
+	};
+
+	mdio@32004 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		mvswitch: switch@000000{
+			compatible = "marvell,mv88e6xxx";
+			status = "okay";
+			phy-addr = <1>;
+			cpu-port = <0x0>;
+			port-mask = <0xf>;
+		};
+	};
 };
 
 &comphy {
 	max-lanes = <3>;
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
-		phy-speed = <PHY_SPEED_2_5G>;
+		phy-type = <COMPHY_TYPE_USB3>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_2_5G>;
 	};
 
 	phy2 {
-		phy-type = <PHY_TYPE_SATA0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_SATA0>;
+		phy-speed = <COMPHY_SPEED_6G>;
 	};
 };
 
@@ -93,6 +81,8 @@
 	pinctrl-0 = <&rgmii_pins>, <&smi_pins>;
 	phy-mode = "rgmii";
 	phy_addr = <0x1>;
+	phy = <&mvswitch>;
+
 	fixed-link {
 		speed = <1000>;
 		full-duplex;
@@ -110,6 +100,34 @@
 	status = "okay";
 };
 
+/* J1 */
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio_pins>;
+	bus-width = <4>;
+	vqmmc-supply = <&vcc_sd_reg0>;
+	status = "okay";
+};
+
+/* U11 */
+&sdhci1 {
+	non-removable;
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	marvell,pad-type = "fixed-1-8v";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc_pins>;
+	status = "disabled";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	mmccard: mmccard@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+	};
+};
+
 &spi0 {
 	status = "okay";
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/armada-3720-turris-mox.dts b/arch/arm/dts/armada-3720-turris-mox.dts
index c36a5b8895..0b1da93229 100644
--- a/arch/arm/dts/armada-3720-turris-mox.dts
+++ b/arch/arm/dts/armada-3720-turris-mox.dts
@@ -58,18 +58,18 @@
 &comphy {
 	max-lanes = <3>;
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_3_125G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_PEX0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 
 	phy2 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 };
 
diff --git a/arch/arm/dts/armada-3720-uDPU.dts b/arch/arm/dts/armada-3720-uDPU.dts
index 683dac2a7c..42fe726a8e 100644
--- a/arch/arm/dts/armada-3720-uDPU.dts
+++ b/arch/arm/dts/armada-3720-uDPU.dts
@@ -108,17 +108,17 @@
 
 &comphy {
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
         phy1 {
-                phy-type = <PHY_TYPE_SGMII0>;
-                phy-speed = <PHY_SPEED_1_25G>;
+                phy-type = <COMPHY_TYPE_SGMII0>;
+                phy-speed = <COMPHY_SPEED_1_25G>;
         };
 
         phy2 {
-                phy-type = <PHY_TYPE_USB3_HOST1>;
-                phy-speed = <PHY_SPEED_5G>;
+                phy-type = <COMPHY_TYPE_USB3_HOST1>;
+                phy-speed = <COMPHY_SPEED_5G>;
         };
 };
 
diff --git a/arch/arm/dts/armada-375-db.dts b/arch/arm/dts/armada-375-db.dts
index 343349b8fd..7571bacd60 100644
--- a/arch/arm/dts/armada-375-db.dts
+++ b/arch/arm/dts/armada-375-db.dts
@@ -171,6 +171,8 @@
 			};
 
 			mdio {
+				status = "okay";
+
 				phy0: ethernet-phy@0 {
 					reg = <0>;
 				};
diff --git a/arch/arm/dts/armada-385-ap.dts b/arch/arm/dts/armada-385-ap.dts
new file mode 100644
index 0000000000..dc527d548a
--- /dev/null
+++ b/arch/arm/dts/armada-385-ap.dts
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+/dts-v1/;
+#include "armada-385.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Marvell Armada 385 Access Point Development Board";
+	compatible = "marvell,a385-db-ap", "marvell,armada385",
+		     "marvell,armada380";
+
+	aliases {
+		ethernet0 = &eth0;
+		ethernet1 = &eth1;
+		ethernet2 = &eth2;
+		serial0 = &uart0;
+		serial1 = &uart1;
+	};
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000>; /* 2GB */
+	};
+
+	soc {
+		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
+			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000>;
+
+		internal-regs {
+
+			i2c0: i2c@11000 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&i2c0_pins>;
+				status = "okay";
+
+				/*
+				 * This bus is wired to two EEPROM
+				 * sockets, one of which holding the
+				 * board ID used by the	bootloader.
+				 * Erasing this EEPROM's content will
+				 * brick the board.
+				 * Use this bus with caution.
+				 */
+			};
+			mdio@72004 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&mdio_pins>;
+
+				phy0: ethernet-phy@1 {
+					reg = <1>;
+				};
+
+				phy1: ethernet-phy@4 {
+					reg = <4>;
+				};
+
+				phy2: ethernet-phy@6 {
+					reg = <6>;
+				};
+			};
+
+			/* UART0 is exposed through the JP8 connector */
+			uart0: serial@12000 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&uart0_pins>;
+				status = "okay";
+				u-boot,dm-pre-reloc;
+			};
+
+			/*
+			 * UART1 is exposed through a FTDI chip
+			 * wired to the mini-USB connector
+			 */
+			uart1: serial@12100 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&uart1_pins>;
+				status = "okay";
+				u-boot,dm-pre-reloc;
+			};
+
+			pinctrl@18000 {
+				xhci0_vbus_pins: xhci0-vbus-pins {
+					marvell,pins = "mpp44";
+					marvell,function = "gpio";
+				};
+			};
+
+			ethernet@30000 {
+				status = "okay";
+				phy = <&phy2>;
+				phy-mode = "sgmii";
+			};
+
+			ethernet@34000 {
+				status = "okay";
+				phy = <&phy1>;
+				phy-mode = "sgmii";
+			};
+
+			usb@58000 {
+				status = "okay";
+			};
+
+			ethernet@70000 {
+				pinctrl-names = "default";
+
+				/*
+				 * The Reference Clock 0 is used to
+				 * provide a clock to the PHY
+				 */
+				pinctrl-0 = <&ge0_rgmii_pins>, <&ref_clk0_pins>;
+				status = "okay";
+				phy = <&phy0>;
+				phy-mode = "rgmii-id";
+			};
+
+			nand_controller: nand-controller@d0000 {
+				status = "okay";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				num-cs = <1>;
+				nand-ecc-strength = <4>;
+				nand-ecc-step-size = <512>;
+				marvell,nand-keep-config;
+				marvell,nand-enable-arbiter;
+				nand-on-flash-bbt;
+
+				partition@0 {
+					label = "U-Boot";
+					reg = <0x00000000 0x00800000>;
+					read-only;
+				};
+
+				partition@800000 {
+					label = "uImage";
+					reg = <0x00800000 0x00400000>;
+					read-only;
+				};
+
+				partition@c00000 {
+					label = "Root";
+					reg = <0x00c00000 0x3f400000>;
+				};
+			};
+
+		};
+
+		pciec: pcie {
+			status = "okay";
+
+			/*
+			 * The three PCIe units are accessible through
+			 * standard mini-PCIe slots on the board.
+			 */
+			pcie@1,0 {
+				/* Port 0, Lane 0 */
+				status = "okay";
+			};
+
+			pcie@2,0 {
+				/* Port 1, Lane 0 */
+				status = "okay";
+			};
+
+			pcie@3,0 {
+				/* Port 2, Lane 0 */
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-388-gp.dts b/arch/arm/dts/armada-388-gp.dts
index d5ad2fd7e2..a2bb198236 100644
--- a/arch/arm/dts/armada-388-gp.dts
+++ b/arch/arm/dts/armada-388-gp.dts
@@ -55,6 +55,7 @@
 		ethernet0 = &eth0;
 		ethernet1 = &eth1;
 		spi0 = &spi0;
+		fuse0 = &efuse;
 	};
 
 	memory {
@@ -66,23 +67,26 @@
 		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
 			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000>;
 
-		internal-regs {
-			spi@10600 {
-				pinctrl-names = "default";
-				pinctrl-0 = <&spi0_pins>;
-				status = "okay";
-				u-boot,dm-pre-reloc;
+		spi0: spi@10600 {
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_pins>;
+			status = "okay";
+			u-boot,dm-pre-reloc;
 
-				spi-flash@0 {
-					u-boot,dm-pre-reloc;
-					#address-cells = <1>;
-					#size-cells = <1>;
-					compatible = "st,m25p128", "jedec,spi-nor";
-					reg = <0>; /* Chip select 0 */
-					spi-max-frequency = <50000000>;
-					m25p,fast-read;
-				};
+			spi-flash@0 {
+				u-boot,dm-pre-reloc;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "st,m25p128",
+					   "jedec,spi-nor", "spi-flash";
+				reg = <0>; /* Chip select 0 */
+				spi-max-frequency = <50000000>;
+				m25p,fast-read;
 			};
+		};
+
+		internal-regs {
+
 
 			i2c@11000 {
 				pinctrl-names = "default";
@@ -232,6 +236,11 @@
 				vcc-supply = <&reg_usb3_vbus>;
 				status = "okay";
 			};
+
+			efuse@f9000 {
+				status = "okay";
+			};
+
 		};
 
 		pcie {
diff --git a/arch/arm/dts/armada-38x.dtsi b/arch/arm/dts/armada-38x.dtsi
index 72c49beb71..28151f61ac 100644
--- a/arch/arm/dts/armada-38x.dtsi
+++ b/arch/arm/dts/armada-38x.dtsi
@@ -590,6 +590,14 @@
 				clocks = <&gateclk 10>;
 				status = "disabled";
 			};
+
+			efuse: efuse@f9000 {
+				compatible = "marvell,mvebu-fuse-hd";
+				reg = <0xe4008 0x4>;
+				otp-mem = <0xf9000>;
+				rows-count = <64>;
+				status = "disabled";
+			};
 		};
 
 		crypto_sram0: sa-sram0 {
diff --git a/arch/arm/dts/armada-7020-amc.dts b/arch/arm/dts/armada-7020-amc.dts
new file mode 100644
index 0000000000..b0682e7d9e
--- /dev/null
+++ b/arch/arm/dts/armada-7020-amc.dts
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7020 AMC board
+ * Boot device: NAND
+ */
+
+#include "armada-70x0.dtsi"
+
+/ {
+	model = "Marvell Armada 7020 AMC";
+	compatible = "marvell,armada7020-amc", "marvell,armada7020",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_mss_i2c0;
+		i2c2 = &ap_i2c0;
+		spi0 = &ap_spi0;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>; /* 2GB */
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_smi0: reg_smi {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-smi";
+			/*
+			 * set GPIO[31] to 0 to connect SMI to main switch
+			 * board
+			 */
+			gpio = <&cp0_gpio0 31 GPIO_ACTIVE_HIGH>;
+		};
+
+		reg_i2c0: reg_i2c {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-i2c";
+			enable-active-high;
+			 /*
+			  * set GPIO[44] to 1 to connect ap_i2c0 to main switch
+			  * board
+			  */
+			gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI  [0-3]
+	    * I2C  [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	enable_gpios = <&reg_i2c0>;
+	status = "okay";
+};
+
+&ap_spi0 {
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+	};
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xfa000000 0  0xfa000000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf6000000 0  0xf6000000 0 0x4000000>;
+
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_mss_i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII [0-11]
+		 * Device Bus [13-27]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C0	 [37-38]
+		 * I2C1	 [50-51]
+		 * SD	 [49, 55-61]
+		 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 3    3    3    3    3    3    3    3    3    3
+		     3    3    0    2    3    1    1    1    1    1
+		     1    1    1    1    1    1    1    1    9    0xA
+		     0xA  0    7    0    7    7    7    2    2    0xFF
+		     0xFF 0xFF 0xFF 0xFF 0    0    0    0    0    0xA
+		     2    2    0    0    0    0xB  0xE  0xE  0xE  0xE
+		     0xE  0xE  0>;
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	enable_gpios = <&reg_smi0>;
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7020-comexp.dts b/arch/arm/dts/armada-7020-comexp.dts
new file mode 100644
index 0000000000..6f5c9b2075
--- /dev/null
+++ b/arch/arm/dts/armada-7020-comexp.dts
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7020 COMEXPRESS board
+ * Boot device: NAND
+ */
+
+#include "armada-70x0.dtsi"
+
+/ {
+	model = "Marvell Armada-7020 COMEXPRESS board setup";
+	compatible = "marvell,armada7020-comexp", "marvell,armada702",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_mss_i2c0;
+		i2c2 = &ap_i2c0;
+		spi0 = &ap_spi0;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>; /* 2GB */
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_smi0: reg_smi {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-smi";
+			/*
+			 * set GPIO[31] to 0 to connect SMI to main switch
+			 * board
+			 */
+			gpio = <&cp0_gpio0 31 GPIO_ACTIVE_HIGH>;
+		};
+
+		reg_i2c0: reg_i2c {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-i2c";
+			enable-active-high;
+			 /*
+			  * set GPIO[44] to 1 to connect ap_i2c0 to main switch
+			  * board
+			  */
+			gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI  [0-3]
+	    * I2C  [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	enable_gpios = <&reg_i2c0>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII [0-11]
+		 * Device Bus [13-27]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C0	 [37-38]
+		 * I2C1	 [50-51]
+		 * SD	 [55-61]
+		 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 3    3    3    3    3    3    3    3    3    3
+		     3    3    0    2    0    1    1    1    1    1
+		     1    1    1    1    1    1    1    1    9    0xA
+		     0xA  0    7    0    7    7    7    2    2    0
+		     0    0    0    0    0    0    0    0    0    0
+		     2    2    0    0    0    0xB  0xE  0xE  0xE  0xE
+		     0xE  0xE  0>;
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_nand {
+	/* MT29F8G08ABACAWP, ID=0xd32c, ONFI, page:4KB-224B, 8bit ECC,
+	 * 1GByte total.
+	 */
+	status = "okay";
+	nand-enable-arbiter;
+	num-cs = <1>;
+	nand-ecc-strength = <8>;
+	nand-ecc-step-size = <512>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_mss_i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	enable_gpios = <&reg_smi0>;
+	phy1: ethernet-phy@1 {
+		reg = <0x10>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xfa000000 0  0xfa000000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf6000000 0  0xf6000000 0 0x4000000>;
+
+	status = "okay";
+};
diff --git a/arch/arm/dts/armada-7040-db-B.dts b/arch/arm/dts/armada-7040-db-B.dts
new file mode 100644
index 0000000000..479523165b
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-B.dts
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(B)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII1 [0-11]
+		 * SPI    [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * XSMI   [35-36]
+		 * I2C	  [37-38]
+		 * RGMII2 [44-55]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-C.dts b/arch/arm/dts/armada-7040-db-C.dts
new file mode 100644
index 0000000000..ec4e114322
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-C.dts
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(C)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * TDM	  [0-5]
+		 * SPI0	  [6-11]
+		 * SPI1   [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * XSMI   [35-36]
+		 * I2C	  [37-38]
+		 * RGMII1 [44-55]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 4   4   4   4   4   4   4   4   4   4
+		     4   4   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-D.dts b/arch/arm/dts/armada-7040-db-D.dts
new file mode 100644
index 0000000000..95d8e06d10
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-D.dts
@@ -0,0 +1,201 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(D)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_sar {
+		boot_mode {
+			default = <0xe>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * AUDIO   [0-5]
+		 * SS_PWDN [12]
+		 * NF_RBn  [13]
+		 * DEV_BUS [14-27]
+		 * SATA1   [28]
+		 * UART0   [29-30]
+		 * MSS_VTT [31]
+		 * SMI	   [32,34]
+		 * XSMI    [35-36]
+		 * I2C	   [37-38]
+		 * RGMII1  [44-55]
+		 * SD	   [56-61]
+		 * GPIO    [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 2   2   2   2   2   2   0   0   0   0
+		     0   0   0   2   0   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1    0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_DEVICE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	utmi-port = <UTMI_PHY_TO_USB3_DEVICE0>;
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-E.dts b/arch/arm/dts/armada-7040-db-E.dts
new file mode 100644
index 0000000000..871734f881
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-E.dts
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(E)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_spi0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI0 [0-3]
+	    * I2C0 [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII0 [0-11]
+		 * SPI1   [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * I2C1   [35-36]
+		 * I2C0   [37-38]
+		 * UART1  [47-49]
+		 * UART0  [50-51]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   2   2   2   2   0
+		     0   0   0   0   1   1   1   7   1   7
+		     6   6   1   1   0xA 1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id"; /* lane-0 */
+};
diff --git a/arch/arm/dts/armada-7040-db-F.dts b/arch/arm/dts/armada-7040-db-F.dts
new file mode 100644
index 0000000000..bba2cdf8da
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-F.dts
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(F)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * SPI   [13-16]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C	 [37-38]
+		 * RGMII [44-55]
+		 * SD	 [56-61]
+		 * GPIO  [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 0   0   0   0   0   0   0   0   0   0
+		     0   0   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy-mode = "sgmii-2500"; /* lane-0 */
+
+	fixed-link {
+		speed = <2500>;
+		full-duplex;
+	};
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-nand.dts b/arch/arm/dts/armada-7040-db-nand.dts
deleted file mode 100644
index 3a9df21a8c..0000000000
--- a/arch/arm/dts/armada-7040-db-nand.dts
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (C) 2017 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada 7040 Development board platform
- * Boot device: NAND, 0xE (SW3)
- */
-
-#include "armada-7040.dtsi"
-
-/ {
-	model = "Marvell Armada 7040 DB board with NAND";
-	compatible = "marvell,armada7040-db-nand", "marvell,armada7040-db",
-		     "marvell,armada7040", "marvell,armada-ap806-quad",
-		     "marvell,armada-ap806";
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
-	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cpm_spi1;
-	};
-
-	memory@00000000 {
-		device_type = "memory";
-		reg = <0x0 0x0 0x0 0x80000000>;
-	};
-};
-
-&ap_pinctl {
-	   /* MPP Bus:
-	    * SDIO  [0-5]
-	    * UART0 [11,19]
-	    */
-		  /* 0   1   2   3   4   5   6   7   8   9 */
-	pin-func = < 0x1 0x1 0x1 0x1 0x1 0x1 0x0 0x0 0x0 0x0
-		     0x0 0x3 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x3 >;
-};
-
-&uart0 {
-	status = "okay";
-};
-
-
-&cpm_pcie2 {
-	status = "okay";
-};
-
-&cpm_i2c0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
-	status = "okay";
-	clock-frequency = <100000>;
-};
-
-&cpm_pinctl {
-		/* MPP Bus:
-		 * AUDIO   [0-5]
-                 * GBE     [6-11]
-		 * SS_PWDN [12]
-		 * NF_RBn  [13]
-                 * GPIO    [14]
-		 * DEV_BUS [15-27]
-		 * SATA1   [28]
-		 * UART0   [29-30]
-		 * MSS_VTT_EN [31]
-		 * SMI	   [32,34]
-		 * XSMI    [35-36]
-		 * I2C	   [37-38]
-		 * RGMII1  [44-55]
-		 * SD	   [56-61]
-		 * GPIO    [62]
-		 */
-		 /*   0   1   2   3   4   5   6   7   8   9 */
-	 pin-func = < 0x2 0x2 0x2 0x2 0x2 0x2 0x3 0x3 0x3 0x3
-		      0x3 0x3 0x0 0x2 0x0 0x1 0x1 0x1 0x1 0x1
-		      0x1 0x1 0x1 0x1 0x1 0x1 0x1 0x1 0x9 0xa
-		      0xa 0x0 0x7 0x0 0x7 0x7 0x7 0x2 0x2 0x0
-		      0x0 0x0 0x0 0x0 0x1 0x1 0x1 0x1 0x1 0x1
-		      0x1 0x1 0x1 0x1 0x1 0x1 0xe 0xe 0xe 0xe
-		      0xe 0xe 0x0>;
-};
-
-&cpm_spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_spi0_pins>;
-	status = "disabled";
-
-	spi-flash@0 {
-		#address-cells = <0x1>;
-		#size-cells = <0x1>;
-		compatible = "jedec,spi-nor";
-		reg = <0x0>;
-		spi-max-frequency = <20000000>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "U-Boot";
-				reg = <0x0 0x200000>;
-			};
-
-			partition@400000 {
-				label = "Filesystem";
-				reg = <0x200000 0xe00000>;
-			};
-		};
-	};
-};
-
-&cpm_sata0 {
-	status = "okay";
-};
-
-&cpm_usb3_0 {
-	status = "okay";
-};
-
-&cpm_usb3_1 {
-	status = "okay";
-};
-
-&cpm_comphy {
-	phy0 {
-		phy-type = <PHY_TYPE_SGMII2>;
-		phy-speed = <PHY_SPEED_3_125G>;
-	};
-
-	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy2 {
-		phy-type = <PHY_TYPE_SGMII0>;
-		phy-speed = <PHY_SPEED_1_25G>;
-	};
-
-	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-};
-
-&cpm_nand {
-	status = "okay";
-};
-
-&cpm_utmi0 {
-	status = "okay";
-};
-
-&cpm_utmi1 {
-	status = "okay";
-};
-
-&ap_sdhci0 {
-	status = "okay";
-	bus-width = <4>;
-	no-1-8-v;
-	non-removable;
-};
-
-&cpm_sdhci0 {
-	status = "okay";
-	bus-width = <4>;
-	no-1-8-v;
-	non-removable;
-};
diff --git a/arch/arm/dts/armada-7040-db.dts b/arch/arm/dts/armada-7040-db.dts
index cfd2b4baf3..170b8553c9 100644
--- a/arch/arm/dts/armada-7040-db.dts
+++ b/arch/arm/dts/armada-7040-db.dts
@@ -45,10 +45,10 @@
  * Boot device: SPI NOR, 0x32 (SW3)
  */
 
-#include "armada-7040.dtsi"
+#include "armada-70x0-db.dtsi"
 
 / {
-	model = "Marvell Armada 7040 DB board";
+	model = "Marvell Armada 7040 Development Board DB-88FA7040";
 	compatible = "marvell,armada7040-db", "marvell,armada7040",
 		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
 
@@ -57,8 +57,13 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cpm_spi1;
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -81,51 +86,67 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
 
-&cpm_pcie2 {
+&cp0_pcie2 {
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 		/* MPP Bus:
-		 * TDM	 [0-11]
 		 * SPI   [13-16]
 		 * SATA1 [28]
 		 * UART0 [29-30]
 		 * SMI	 [32,34]
 		 * XSMI  [35-36]
 		 * I2C	 [37-38]
-		 * RGMII1[44-55]
-		 * SD	 [56-62]
+		 * RGMII [44-55]
+		 * SD	 [56-61]
+		 * GPIO  [62]
 		 */
 		/*   0   1   2   3   4   5   6   7   8   9 */
-	pin-func = < 4   4   4   4   4   4   4   4   4   4
-		     4   4   0   3   3   3   3   0   0   0
+	pin-func = < 0   0   0   0   0   0   0   0   0   0
+		     0   0   0   3   3   3   3   0   0   0
 		     0   0   0   0   0   0   0   0   9   0xA
 		     0xA 0   7   0   7   7   7   2   2   0
 		     0   0   0   0   1   1   1   1   1   1
 		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
-		     0xE 0xE 0xE >;
+		     0xE 0xE 0>;
 };
 
-&cpm_spi1 {
+&cp0_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_spi0_pins>;
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <0x1>;
 		#size-cells = <0x1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0x0>;
-		spi-max-frequency = <20000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -145,54 +166,59 @@
 	};
 };
 
-&cpm_sata0 {
+&cp0_ld_efuse0 {
 	status = "okay";
 };
 
-&cpm_usb3_0 {
+&cp0_ld_efuse1 {
 	status = "okay";
 };
 
-&cpm_usb3_1 {
+&cp0_sata0 {
 	status = "okay";
 };
 
-&cpm_comphy {
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
 	};
 
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 
 	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
 	};
 
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
-&cpm_utmi0 {
+&cp0_utmi0 {
 	status = "okay";
 };
 
-&cpm_utmi1 {
+&cp0_utmi1 {
 	status = "okay";
 };
 
@@ -203,14 +229,15 @@
 	non-removable;
 };
 
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	status = "okay";
 	bus-width = <4>;
 	no-1-8-v;
 	non-removable;
 };
 
-&cpm_mdio {
+&cp0_mdio {
+	status = "okay";
 	phy0: ethernet-phy@0 {
 		reg = <0>;
 	};
@@ -219,22 +246,22 @@
 	};
 };
 
-&cpm_ethernet {
+&cp0_ethernet {
 	status = "okay";
 };
 
-&cpm_eth0 {
+&cp0_eth0 {
 	status = "okay";
 	phy-mode = "sfi"; /* lane-2 */
 };
 
-&cpm_eth1 {
+&cp0_eth1 {
 	status = "okay";
 	phy = <&phy0>;
-	phy-mode = "sgmii";
+	phy-mode = "sgmii"; /* lane-0 */
 };
 
-&cpm_eth2 {
+&cp0_eth2 {
 	status = "okay";
 	phy = <&phy1>;
 	phy-mode = "rgmii-id";
diff --git a/arch/arm/dts/armada-7040-dev-info.dtsi b/arch/arm/dts/armada-7040-dev-info.dtsi
new file mode 100644
index 0000000000..42b63f0968
--- /dev/null
+++ b/arch/arm/dts/armada-7040-dev-info.dtsi
@@ -0,0 +1,73 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2017 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+
+			freq {
+				key = "freq";
+				description = "CPU/DDR frequencies";
+				start-bit = <0>;
+				bit-length = <3>;
+				option-cnt = <7>;
+				options = "0x0", "1600/800 Mhz",
+					  "0x2", "1000/650 Mhz",
+					  "0x3", "1200/800 Mhz",
+					  "0x4", "1400/800 Mhz",
+					  "0x5", "600/800 Mhz",
+					  "0x6", "800/800 Mhz",
+					  "0x7", "1000/800 Mhz";
+				default = <0x3>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <14>;
+				options = "0xE", "NAND IHB BW-8bit, PS-4KB, ECC-4bit",
+					  "0xF", "NAND IHB BW-8bit, PS-4KB, ECC-8bit",
+					  "0x28", "AP_SD",
+					  "0x29", "CP_SD",
+					  "0x2A", "AP_EMMC",
+					  "0x2B", "CP_EMMC",
+					  "0x30", "AP_SPI 24bits",
+					  "0x31", "AP SPI BR-Disabled 24bits",
+					  "0x32", "CP_SPI_1 24bits",
+					  "0x33", "CP_SPI_1 32bits",
+					  "0x34", "CP_SPI_0 24bits",
+					  "0x35", "CP_SPI_0 32bits",
+					  "0x36", "CP_SPI_1 BR-Disabled 24bits",
+					  "0x37", "CP_SPI_1 BR-Disabled 32bits";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-7040-pcac.dts b/arch/arm/dts/armada-7040-pcac.dts
new file mode 100644
index 0000000000..3b429a5178
--- /dev/null
+++ b/arch/arm/dts/armada-7040-pcac.dts
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040-PCAC";
+	compatible = "marvell, armada7040-pcac", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb3h1_current_limiter: usb3-current-limiter1 {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
+			regulator-name = "reg-usb3h1-current-limiter";
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <900000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 14 GPIO_ACTIVE_HIGH>; /* GPIO[46] */
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-10]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII0[0-11]
+		 * SPI   [13-16]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * PCI_RST [31]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C	 [37-38]
+		 * UART1 [40-41]
+		 * USB CURRENT-LIMIT	[46]
+		 * UART2 [50-51]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 6   7   0   7   0   0   2   2   0
+		     0   0   0   0   0   0   0   7   0   7
+		     6   6   0   0   0   0   0   0   0   0
+		     0   0   0>;
+
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
+		marvell,pins = < 46 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	vbus-supply = <&reg_usb3h1_current_limiter>;
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&ap_sdhci0 {
+
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4*/
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id"; /* rgmii-0*/
+};
diff --git a/arch/arm/dts/armada-7040.dtsi b/arch/arm/dts/armada-7040.dtsi
deleted file mode 100644
index b5be0c4652..0000000000
--- a/arch/arm/dts/armada-7040.dtsi
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for the Armada 7040 SoC, made of an AP806 Quad and
- * one CP110.
- */
-
-#include <dt-bindings/gpio/gpio.h>
-#include "armada-ap806-quad.dtsi"
-#include "armada-cp110-master.dtsi"
-
-/ {
-	model = "Marvell Armada 7040";
-	compatible = "marvell,armada7040", "marvell,armada-ap806-quad",
-		     "marvell,armada-ap806";
-};
diff --git a/arch/arm/dts/armada-70x0-db.dtsi b/arch/arm/dts/armada-70x0-db.dtsi
new file mode 100644
index 0000000000..02db64794c
--- /dev/null
+++ b/arch/arm/dts/armada-70x0-db.dtsi
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-70x0.dtsi" /* include SoC device tree */
+#include "armada-7040-dev-info.dtsi"
+
+#define CP110_NUM				0
+#define SPI_DIRECT_BASE				(0xf9000000)
+
+/ {
+	model = "DB-ARMADA-70x0";
+	compatible = "marvell,armada-70x0-db", "marvell,armada-70x0";
+
+	cp0 {
+		config-space {
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+			i2c@701000 {
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+			};
+
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+			};
+
+			cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus0>;
+				current-limiter = <&cp0_reg_usb3_current_limiter0>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus1>;
+				current-limiter = <&cp0_reg_usb3_current_limiter1>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-70x0.dtsi b/arch/arm/dts/armada-70x0.dtsi
new file mode 100644
index 0000000000..d6b9cab366
--- /dev/null
+++ b/arch/arm/dts/armada-70x0.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for the Armada 7040 SoC, made of an AP806 Quad and
+ * one CP110.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
+#include "armada-8k.dtsi"
+#include "armada-ap806.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* CP110-0 Settings */
+#define CP110_NAME				cp0
+#define CP110_NUM				0
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
+
+/ {
+	model = "Marvell Armada 7040";
+	compatible = "marvell,armada7040", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-7k-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/armada-8020.dtsi b/arch/arm/dts/armada-8020.dtsi
index 048e5cf516..3f33e78e0b 100644
--- a/arch/arm/dts/armada-8020.dtsi
+++ b/arch/arm/dts/armada-8020.dtsi
@@ -45,12 +45,82 @@
  * two CP110.
  */
 
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
 #include "armada-ap806-dual.dtsi"
-#include "armada-cp110-master.dtsi"
-#include "armada-cp110-slave.dtsi"
+
+#define CP110_NAME		cp0
+#define CP110_BASE              0xf2000000
+#define CP110_PCIE_MEM_BASE     0xf6000000
+#define CP110_PCIE_MEM_OFFSET	0x1000000
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_BASE
+#undef CP110_PCIE_MEM_BASE
+
+#define CP110_NAME		cp1
+#define CP110_BASE              0xf4000000
+#define CP110_PCIE_MEM_BASE     0xfa000000
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_BASE
+#undef CP110_PCIE_MEM_BASE
 
 / {
 	model = "Marvell Armada 8020";
 	compatible = "marvell,armada8020", "marvell,armada-ap806-dual",
 		     "marvell,armada-ap806";
 };
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cps-pinctrl";
+	bank-name ="cp1-110";
+
+	cp1_ge1_rgmii_pins: cp1-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11 >;
+		marvell,function = <3>;
+	};
+	cp1_spi1_pins: cp1-spi-pins-1 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/armada-8040-clearfog-gt-8k.dts b/arch/arm/dts/armada-8040-clearfog-gt-8k.dts
index 720c95082b..5db5bb8bea 100644
--- a/arch/arm/dts/armada-8040-clearfog-gt-8k.dts
+++ b/arch/arm/dts/armada-8040-clearfog-gt-8k.dts
@@ -15,9 +15,9 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		i2c1 = &cpm_i2c1;
-		spi0 = &cps_spi1;
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
 	};
 
 	memory@00000000 {
@@ -31,14 +31,14 @@
 		reg_usb3h0_vbus: usb3-vbus0 {
 			compatible = "regulator-fixed";
 			pinctrl-names = "default";
-			pinctrl-0 = <&cpm_xhci_vbus_pins>;
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
 			regulator-name = "reg-usb3h0-vbus";
 			regulator-min-microvolt = <5000000>;
 			regulator-max-microvolt = <5000000>;
 			startup-delay-us = <300000>;
 			shutdown-delay-us = <500000>;
 			regulator-force-boot-off;
-			gpio = <&cpm_gpio1 15 GPIO_ACTIVE_LOW>; /* GPIO[47] */
+			gpio = <&cp0_gpio1 15 GPIO_ACTIVE_LOW>; /* GPIO[47] */
 		};
 	};
 };
@@ -66,7 +66,7 @@
 	status = "okay";
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-31] = 0xff: Keep default CP0_shared_pins:
@@ -99,111 +99,111 @@
 		     0    0    0    0    0    0    0xe  0xe  0xe  0xe
 		     0xe  0xe  0 >;
 
-	cpm_pcie_reset_pins: cpm-pcie-reset-pins {
+	cp0_pcie_reset_pins: cp0-pcie-reset-pins {
 		marvell,pins = < 32 >;
 		marvell,function = <0>;
 	};
 
-	cpm_xhci_vbus_pins: cpm-xhci-vbus-pins {
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
 		marvell,pins = < 47 >;
 		marvell,function = <0>;
 	};
 
-	cps_1g_phy_reset: cps-1g-phy-reset {
+	cp1_1g_phy_reset: cp1-1g-phy-reset {
 		marvell,pins = < 43 >;
 		marvell,function = <0>;
 	};
 };
 
 /* uSD slot */
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_sdhci_pins>;
+	pinctrl-0 = <&cp0_sdhci_pins>;
 	bus-width = <4>;
 	status = "okay";
 };
 
-&cpm_pcie0 {
+&cp0_pcie0 {
 	num-lanes = <1>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_pcie_reset_pins>;
-	marvell,reset-gpio = <&cpm_gpio1 0 GPIO_ACTIVE_LOW>;
+	pinctrl-0 = <&cp0_pcie_reset_pins>;
+	marvell,reset-gpio = <&cp0_gpio1 0 GPIO_ACTIVE_LOW>;
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_i2c1 {
+&cp0_i2c1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c1_pins>;
+	pinctrl-0 = <&cp0_i2c1_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_sata0 {
+&cp0_sata0 {
 	status = "okay";
 };
 
-&cpm_comphy {
+&cp0_comphy {
 	/*
 	 * CP0 Serdes Configuration:
 	 * Lane 0: PCIe0 (x1)
 	 * Lane 1: Not connected
-	 * Lane 2: SFI (10G)
+	 * Lane 2: SFI0 (10G)
 	 * Lane 3: Not connected
 	 * Lane 4: USB 3.0 host port1 (can be PCIe)
 	 * Lane 5: Not connected
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_UNCONNECTED>;
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_UNCONNECTED>;
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_UNCONNECTED>;
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
 	};
 };
 
-&cpm_ethernet {
+&cp0_ethernet {
         pinctrl-names = "default";
         status = "okay";
 };
 
 /* 10G SFI SFP */
-&cpm_eth0 {
+&cp0_eth0 {
         status = "okay";
         phy-mode = "sfi";
 };
 
-&cps_sata0 {
+&cp1_sata0 {
 	status = "okay";
 };
 
-&cps_usb3_0 {
+&cp1_usb3_0 {
 	vbus-supply = <&reg_usb3h0_vbus>;
 	status = "okay";
 };
 
-&cps_utmi0 {
+&cp1_utmi0 {
 	status = "okay";
 };
 
-&cps_pinctl {
+&cp1_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-5] TDM
@@ -234,9 +234,9 @@
 		     0xff 0xff 0xff>;
 };
 
-&cps_spi1 {
+&cp1_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_spi1_pins>;
+	pinctrl-0 = <&cp1_spi1_pins>;
 	status = "okay";
 
 	spi-flash@0 {
@@ -261,7 +261,7 @@
 	};
 };
 
-&cps_comphy {
+&cp1_comphy {
 	/*
 	 * CP1 Serdes Configuration:
 	 * Lane 0: SATA 1 (RX swapped). Can be PCIe0
@@ -272,52 +272,51 @@
 	 * Lane 5: SGMII2 - Connected to Topaz switch
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_SATA1>;
-		phy-invert = <PHY_POLARITY_RXD_INVERT>;
+		phy-type = <COMPHY_TYPE_SATA1>;
+		phy-invert = <COMPHY_POLARITY_RXD_INVERT>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_UNCONNECTED>;
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_UNCONNECTED>;
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_SGMII2>;
-		phy-speed = <PHY_SPEED_3_125G>;
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
 	};
 };
 
-&cps_mdio {
+&cp1_mdio {
 	phy0: ethernet-phy@0 {
 		reg = <0>;
 	};
 };
 
-&cps_ethernet {
+&cp1_ethernet {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_1g_phy_reset>;
+	pinctrl-0 = <&cp1_1g_phy_reset>;
 	status = "okay";
 };
 
 /* 1G SGMII */
-&cps_eth1 {
+&cp1_eth1 {
 	status = "okay";
 	phy-mode = "sgmii";
 	phy = <&phy0>;
-	phy-reset-gpios = <&cpm_gpio1 11 GPIO_ACTIVE_LOW>;
+	phy-reset-gpios = <&cp0_gpio1 11 GPIO_ACTIVE_LOW>;
 };
 
 /* 2.5G to Topaz switch */
-&cps_eth2 {
+&cp1_eth2 {
 	status = "okay";
-	phy-mode = "sgmii";
-	phy-speed = <2500>;
-	phy-reset-gpios = <&cps_gpio0 24 GPIO_ACTIVE_LOW>;
+	phy-mode = "sgmii-2500";
+	phy-reset-gpios = <&cp1_gpio0 24 GPIO_ACTIVE_LOW>;
 };
diff --git a/arch/arm/dts/armada-8040-db-B.dts b/arch/arm/dts/armada-8040-db-B.dts
new file mode 100644
index 0000000000..74f9fc2ef1
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-B.dts
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(B)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: USB3_HOST0
+	 *	Lane 2: SFI0 (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-C.dts b/arch/arm/dts/armada-8040-db-C.dts
new file mode 100644
index 0000000000..a3977c9e4f
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-C.dts
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(C)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11] TDM
+	 *	[13-16] SPI1
+	 *	[27-28] SATA[0/1]_PRESENT_ACTIVEn
+	 *	[29-30] UART0
+	 *	[32-62] = 0xff: Keep default CP1_shared_pins
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4
+		     0x4  0x4  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x9  0x9  0xA
+		     0xA  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
diff --git a/arch/arm/dts/armada-8040-db-D.dts b/arch/arm/dts/armada-8040-db-D.dts
new file mode 100644
index 0000000000..82679f67c9
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-D.dts
@@ -0,0 +1,316 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(D)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_sar {
+		boot_mode {
+			default = <0xe>;
+		};
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]  DEV_AD
+	 *	[12,13] ND_RBn
+	 *	[14-27] DEV_AD
+	 *	[28]    SATA1_PRESENT_ACTIVEn
+	 *	[29-30] UART0
+	 *	[32-62] = 0xff: Keep default CP1_shared_pins
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x2  0x2  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x9  0xA
+		     0xA  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SGMII0 (1.25G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_nand {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_nand_pins &cp1_nand_rb>;
+
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
diff --git a/arch/arm/dts/armada-8040-db-E.dts b/arch/arm/dts/armada-8040-db-E.dts
new file mode 100644
index 0000000000..22d4617d2a
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-E.dts
@@ -0,0 +1,331 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(E)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SPI0  [0-3]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 0 0 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_spi0 {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34] GE_MDIO/MDC
+	 *	[33]    GPIO: GE_INT#/push button/Wake
+	 *	[35]    MSS_GPIO[3]: MSS_PWDN
+	 *	[36]    MSS_GPIO[5]: MSS_VTT_EN
+	 *	[35-36] I2C1
+	 *	[37-38] I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41] SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43] XG_MDC/XG_MDIO (XSMI)
+	 *	[47,49] UART1
+	 *	[50-51] UART2
+	 *	[54]	SDIO_HW_RST
+	 *	[56-62] SD
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0x0  0xff 0x2  0x2  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0xff 0xff 0xff 0x7  0xff 0x7
+		     0x6  0x6  0xff 0xff 0xa  0xff 0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SGMII (3.125G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "disabled";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-F.dts b/arch/arm/dts/armada-8040-db-F.dts
new file mode 100644
index 0000000000..6d3596eb3e
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-F.dts
@@ -0,0 +1,395 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-8040.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(F)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+	};
+
+	cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+	};
+
+	/* even though this node used for enable/disable cp1 usb vbus-supply,
+	 * we use "cp0" prefix since the expander is connected to cp0.
+	 */
+	cp0_reg_usb3_vbus2: cp0_usb3_vbus@2 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander1 0 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_AP>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+	expander0: pca953x@21 {
+		compatible = "nxp,pca9555";
+		#gpio-cells = <2>;
+		reg = <0x21>;
+		status = "okay";
+	};
+	expander1: pca953x@25 {
+		compatible = "nxp,pca9555";
+		#gpio-cells = <2>;
+		reg = <0x25>;
+		status = "okay";
+	};
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	vbus-supply = <&cp0_reg_usb3_vbus0>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	vbus-supply = <&cp0_reg_usb3_vbus1>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "ap"; /* lane-2: left for auto-neg */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	vbus-supply = <&cp0_reg_usb3_vbus2>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-G.dts b/arch/arm/dts/armada-8040-db-G.dts
new file mode 100644
index 0000000000..964c71d064
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-G.dts
@@ -0,0 +1,344 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(G)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp1_usb3_1 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "disabled";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-H.dts b/arch/arm/dts/armada-8040-db-H.dts
new file mode 100644
index 0000000000..d8b78cd4ce
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-H.dts
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(H)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: SFI0 (10G)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI1>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: SFI0 (10G)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI1>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp1_usb3_1 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db.dts b/arch/arm/dts/armada-8040-db.dts
index 65b30bbc64..65214d6f73 100644
--- a/arch/arm/dts/armada-8040-db.dts
+++ b/arch/arm/dts/armada-8040-db.dts
@@ -44,10 +44,10 @@
  * Device Tree file for Marvell Armada 8040 Development board platform
  */
 
-#include "armada-8040.dtsi"
+#include "armada-80x0-db.dtsi"
 
 / {
-	model = "Marvell Armada 8040 DB board";
+	model = "Marvell Armada 8040 Development Board DB-88F8040";
 	compatible = "marvell,armada8040-db", "marvell,armada8040",
 		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
 
@@ -56,8 +56,14 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cps_spi1;
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -71,6 +77,18 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
 &ap_pinctl {
 	/* MPP Bus:
 	 * SDIO  [0-10]
@@ -85,10 +103,11 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&ap_emmc_pins>;
 	bus-width = <8>;
+	no-1-8-v;
 	status = "okay";
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 	/* MPP Bus:
 	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
 	 *	[11]	CLKOUT_MPP_11 (out)
@@ -116,7 +135,15 @@
 		     0xe  0xe  0xe>;
 };
 
-&cpm_comphy {
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
 	/* Serdes Configuration:
 	 *	Lane 0: PCIe0 (x1)
 	 *	Lane 1: SATA0
@@ -126,77 +153,78 @@
 	 *	Lane 5: PCIe2 (x1)
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
 /* CON6 on CP0 expansion */
-&cpm_pcie0 {
+&cp0_pcie0 {
 	status = "okay";
 };
 
-&cpm_pcie1 {
+&cp0_pcie1 {
 	status = "disabled";
 };
 
 /* CON5 on CP0 expansion */
-&cpm_pcie2 {
+&cp0_pcie2 {
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
 /* CON4 on CP0 expansion */
-&cpm_sata0 {
+&cp0_sata0 {
 	status = "okay";
 };
 
 /* CON9 on CP0 expansion */
-&cpm_usb3_0 {
+&cp0_usb3_0 {
 	status = "okay";
 };
 
 /* CON10 on CP0 expansion */
-&cpm_usb3_1 {
+&cp0_usb3_1 {
 	status = "okay";
 };
 
-&cpm_utmi0 {
+&cp0_utmi0 {
 	status = "okay";
 };
 
-&cpm_utmi1 {
+&cp0_utmi1 {
 	status = "okay";
 };
 
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_sdhci_pins>;
+	pinctrl-0 = <&cp0_sdhci_pins>;
 	bus-width = <4>;
 	status = "okay";
 };
 
-&cps_pinctl {
+&cp1_pinctl {
 	/* MPP Bus:
 	 *	[0-11]	RGMII0
 	 *	[13-16]	SPI1
@@ -215,7 +243,15 @@
 		     0xff 0xff 0xff>;
 };
 
-&cps_comphy {
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
 	/* Serdes Configuration:
 	 *	Lane 0: PCIe0 (x1)
 	 *	Lane 1: SATA0
@@ -225,50 +261,54 @@
 	 *	Lane 5: PCIe2 (x1)
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_PEX1>;
+		phy-type = <COMPHY_TYPE_PEX1>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
 /* CON6 on CP1 expansion */
-&cps_pcie0 {
+&cp1_pcie0 {
 	status = "okay";
 };
 
-&cps_pcie1 {
+&cp1_pcie1 {
 	status = "okay";
 };
 
 /* CON5 on CP1 expansion */
-&cps_pcie2 {
+&cp1_pcie2 {
 	status = "okay";
 };
 
-&cps_spi1 {
+&cp1_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_spi1_pins>;
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0>;
-		spi-max-frequency = <10000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -288,36 +328,59 @@
 };
 
 /* CON4 on CP1 expansion */
-&cps_sata0 {
+&cp1_sata0 {
 	status = "okay";
 };
 
 /* CON9 on CP1 expansion */
-&cps_usb3_0 {
+&cp1_usb3_0 {
 	status = "okay";
 };
 
-/* CON10 on CP1 expansion */
-&cps_usb3_1 {
+&cp1_utmi0 {
 	status = "okay";
 };
 
-&cps_utmi0 {
+&cp0_mdio {
 	status = "okay";
-};
-
-&cpm_mdio {
 	phy1: ethernet-phy@1 {
 		reg = <1>;
 	};
 };
 
-&cpm_ethernet {
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp1_ethernet {
 	status = "okay";
 };
 
-&cpm_eth2 {
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
 	status = "okay";
 	phy = <&phy1>;
 	phy-mode = "rgmii-id";
 };
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-dev-info.dtsi b/arch/arm/dts/armada-8040-dev-info.dtsi
new file mode 100644
index 0000000000..a8a51f225a
--- /dev/null
+++ b/arch/arm/dts/armada-8040-dev-info.dtsi
@@ -0,0 +1,64 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2017 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+
+			freq {
+				key = "freq";
+				description = "CPU/DDR and PIDI frequencies";
+				start-bit = <0>;
+				bit-length = <4>;
+				option-cnt = <4>;
+				options = "0x1", "CPU/DDR = 0x1:  2000/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0x3", "CPU/DDR = 0x3:  1800/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0x4", "CPU/DDR = 0x4:  1600/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0xe", "CPU/DDR = 0x34: 1300/800 Mhz,  PIDI = 1: 500Mhz";
+				default = <0x1>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <7>;
+				options = "0xE", "CP1_NAND IHB BW-8bit, PS-4KB, ECC-4bit\t(supported configuration: D)",
+					  "0xF", "CP1_NAND IHB BW-8bit, PS-4KB, ECC-8bit\t(supported configuration: D)",
+					  "0x29", "CP0_SD\t\t\t\t\t(supported configurations: C, D and E)",
+					  "0x2A", "AP_EMMC\t\t\t\t\t(supported configurations: A, B, C and D)",
+					  "0x2B", "CP0_EMMC\t\t\t\t\t(supported configurations: A and B)",
+					  "0x30", "AP_SPI 24bits\t\t\t\t(supported configurations: E and A0)",
+					  "0x32", "CP1_SPI_1 24bits\t\t\t\t(supported configurations: A, B, C and E)";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-8040-mcbin-single-shot.dts b/arch/arm/dts/armada-8040-mcbin-single-shot.dts
new file mode 100644
index 0000000000..44135daba7
--- /dev/null
+++ b/arch/arm/dts/armada-8040-mcbin-single-shot.dts
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-8040-mcbin.dts"
+
+/{
+	model = "Marvell 8040 MACHIATOBin SingleShot";
+	compatible = "marvell,armada8040-mcbin-single-shot",
+		     "marvell,armada8040-mcbin",
+		     "marvell,armada8040";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	/delete-property/phy;
+};
+
+/* 10G SFI/copper */
+&cp1_eth0 {
+	/delete-property/phy;
+};
+
+/delete-node/ &sfi_phy0;
+/delete-node/ &sfi_phy8;
diff --git a/arch/arm/dts/armada-8040-mcbin.dts b/arch/arm/dts/armada-8040-mcbin.dts
index 5a046d9de4..d5ec4fba7c 100644
--- a/arch/arm/dts/armada-8040-mcbin.dts
+++ b/arch/arm/dts/armada-8040-mcbin.dts
@@ -3,10 +3,10 @@
  * Copyright (C) 2016 Marvell International Ltd.
  */
 
-#include "armada-8040.dtsi" /* include SoC device tree */
+#include "armada-80x0-db.dtsi" /* include SoC device tree */
 
 / {
-	model = "MACCHIATOBin-8040";
+	model = "Marvell Armada 8040 MACCHIATOBin";
 	compatible = "marvell,armada8040-mcbin",
 		     "marvell,armada8040";
 
@@ -15,12 +15,18 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		i2c1 = &cpm_i2c1;
-		spi0 = &cps_spi1;
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
 		gpio0 = &ap_gpio0;
-		gpio1 = &cpm_gpio0;
-		gpio2 = &cpm_gpio1;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -36,15 +42,13 @@
 		reg_usb3h0_vbus: usb3-vbus0 {
 			compatible = "regulator-fixed";
 			pinctrl-names = "default";
-			pinctrl-0 = <&cpm_xhci_vbus_pins>;
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
 			regulator-name = "reg-usb3h0-vbus";
 			regulator-min-microvolt = <5000000>;
 			regulator-max-microvolt = <5000000>;
-			startup-delay-us = <500000>;
-			enable-active-high;
-			regulator-always-on;
-			regulator-boot-on;
-			gpio = <&cpm_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
+			startup-delay-us = <300000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
 		};
 	};
 };
@@ -54,6 +58,18 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
 &ap_pinctl {
 	/*
 	 * MPP Bus:
@@ -69,11 +85,11 @@
 &ap_sdhci0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&ap_emmc_pins>;
-	bus-width= <8>;
+	bus-width = <8>;
 	status = "okay";
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-31] = 0xff: Keep default CP0_shared_pins:
@@ -108,59 +124,68 @@
 		     0    0    0    0    0    0    0xe  0xe  0xe  0xe
 		     0xe  0xe  0 >;
 
-	cpm_xhci_vbus_pins: cpm-xhci-vbus-pins {
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
 		marvell,pins = < 47 >;
 		marvell,function = <0>;
 	};
 
-	cpm_pcie_reset_pins: cpm-pcie-reset-pins {
+	cp0_pcie_reset_pins: cp0-pcie-reset-pins {
 		marvell,pins = < 52 >;
 		marvell,function = <0>;
 	};
 };
 
 /* uSD slot */
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_sdhci_pins>;
+	pinctrl-0 = <&cp0_sdhci_pins>;
 	bus-width= <4>;
 	status = "okay";
 };
 
 /* PCIe x4 */
-&cpm_pcie0 {
+&cp0_pcie0 {
 	num-lanes = <4>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_pcie_reset_pins>;
-	marvell,reset-gpio = <&cpm_gpio1 20 GPIO_ACTIVE_LOW>; /* GPIO[52] */
+	pinctrl-0 = <&cp0_pcie_reset_pins>;
+	marvell,reset-gpio = <&cp0_gpio1 20 GPIO_ACTIVE_LOW>; /* GPIO[52] */
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_i2c1 {
+&cp0_i2c1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c1_pins>;
+	pinctrl-0 = <&cp0_i2c1_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_sata0 {
+&cp0_sata0 {
 	status = "okay";
 };
 
-&cpm_mdio {
+&cp0_mdio {
+	status = "okay";
 	ge_phy: ethernet-phy@0 {
 		reg = <0>;
 	};
 };
 
-&cpm_comphy {
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
 	/*
 	 * CP0 Serdes Configuration:
 	 * Lane 0: PCIe0 (x4)
@@ -171,49 +196,93 @@
 	 * Lane 5: SATA1
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	sfi_phy0: ethernet-phy@0 {
+		reg = <0>;
 	};
+
+	sfi_phy8: ethernet-phy@8 {
+		reg = <8>;
+	};
+};
+
+&cp0_ethernet {
+	pinctrl-names = "default";
+	status = "okay";
 };
 
-&cps_sata0 {
+/* 10G SFI/copper */
+&cp0_eth0 {
 	status = "okay";
+	phy-mode = "sfi";
+	phy = <&sfi_phy0>;
+	phy-reset-gpios = <&cp1_gpio0 31 GPIO_ACTIVE_LOW>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 29 GPIO_ACTIVE_HIGH>;
 };
 
-&cps_usb3_0 {
+&cp1_sata0 {
+	status = "okay";
+};
+
+&cp1_usb3_0 {
 	vbus-supply = <&reg_usb3h0_vbus>;
+	/delete-property/ current-limiter;
 	status = "okay";
 };
 
-&cps_utmi0 {
+&cp1_utmi0 {
 	status = "okay";
 };
 
-&cps_ethernet {
+&cp1_ethernet {
 	status = "okay";
 };
 
-&cps_eth1 {
+/* 10G SFI/copper */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&sfi_phy8>;
+	phy-reset-gpios = <&cp1_gpio0 9 GPIO_ACTIVE_LOW>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 10 GPIO_ACTIVE_HIGH>;
+};
+
+/* 1G SGMII */
+&cp1_eth1 {
 	status = "okay";
 	phy = <&ge_phy>;
 	phy-mode = "sgmii";
 };
 
-&cps_pinctl {
+/* 2.5G SGMII */
+&cp1_eth2 {
+	status = "okay";
+	phy-mode = "sgmii-2500";
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-5] TDM
@@ -246,17 +315,20 @@
 		     0xff 0xff 0xff>;
 };
 
-&cps_spi1 {
+&cp1_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_spi1_pins>;
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0>;
-		spi-max-frequency = <10000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -275,7 +347,15 @@
 	};
 };
 
-&cps_comphy {
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
 	/*
 	 * CP1 Serdes Configuration:
 	 * Lane 0: SGMII1
@@ -283,25 +363,27 @@
 	 * Lane 2: USB HOST 0
 	 * Lane 3: SATA1
 	 * Lane 4: SFI (10G)
-	 * Lane 5: SGMII3
+	 * Lane 5: SGMII2
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_SGMII3>;
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
 	};
 };
diff --git a/arch/arm/dts/armada-8040-ocp.dts b/arch/arm/dts/armada-8040-ocp.dts
new file mode 100644
index 0000000000..b8af2f154b
--- /dev/null
+++ b/arch/arm/dts/armada-8040-ocp.dts
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+
+/ {
+	model = "OCP-8K";	/* PCB model */
+	compatible = "marvell,armada8040-ocp",
+		     "marvell,armada8040";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb3h0_vbus: usb3-vbus0 {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
+			regulator-name = "reg-usb3h0-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* The PCI console memory must be reserved */
+		console_reserved: pci-console-nexus@3f000000 {
+			compatible = "marvell,pci-console-nexus-memory";
+			reg = <0 0x3f000000 0 0x1000000>;
+			no-map;
+		};
+	};
+
+};
+
+/*
+ * Accessible over the front panel micro USB connector CON9 or the
+ * three pin header (default unsoldered) J27 where the pinout is as follows -
+ * 1-GND, 2-8040 SoC RX, 3-8040 SoC TX.
+ */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/*
+	 * MPP Bus:
+	 * eMMC [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 2 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	no-1-8-v;
+	non-removable;
+	status = "okay";
+};
+
+&cp0_bootcmd {
+	status = "okay";
+};
+
+&cp0_pinctl {
+/*
+ * [0-32] = 0xff: Keep default CP1_shared_pins
+ * [32..34] Front panel LEDs (active low)
+ * [35-38] CP0 I2C1 and I2C0
+ * [39] MSS_GPIO
+ * [40-41] NC
+ * [42] LED
+ * [43] Mask system reset (active high)
+ * [47] USB VBUS EN GPIO
+ * [48-49] NC
+ * [50,51] CP0 MSS I2C
+ * [52-61] NC
+ * [62] CP1 SFI SFP FAULT
+ */
+		  /*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0    0    0    2    2    2    2    0
+		     7    7    0    0    0    0    0    0    0xff 0xff
+		     0    0    0    0    0    0    0xe  0xe  0xe  0xe
+		     0xe  0xe  0 >;
+
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
+		marvell,pins = < 47 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c1_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/*
+	 * CP0 Serdes Configuration:
+	 * PCIex4 is connected to CP0
+	 * Lane 0: IGNORE (x4)
+	 * Lane 1: IGNORE (x4)
+	 * Lane 2: IGNORE (x4)
+	 * Lane 3: IGNORE (x4)
+	 * Lane 4: SFI (10G)
+	 * Lane 5: UNCONNECTED
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp0_ethernet {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_usb3_0 {
+	vbus-supply = <&reg_usb3h0_vbus>;
+	status = "okay";
+};
+
+&cp1_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-5] NC
+	 * [6,7] UART0
+	 * [8]   CP1 10G SFP LOS
+	 * [9]   NC
+	 * [10]  CP1 10G SFP TX Disable
+	 * [11]  CP1 10G SFP Mode
+	 * [12]  SPI1 CS1n
+	 * [13]  SPI1 MISO (TDM and SPI ROM shared)
+	 * [14]  SPI1 CS0n
+	 * [15]  SPI1 MOSI (TDM and SPI ROM shared)
+	 * [16]  SPI1 CLK (TDM and SPI ROM shared)
+	 * [17-23] NC
+	 * [24]  CP0_10G_SFP_TX_DISABLE
+	 * [25]  NC
+	 * [26]  CP0 10G SFP TX Fault
+	 * [27]  CP0 10G SFP Mode
+	 * [28]  CP0 10G SFP LOS
+	 * [29]  MSS_TWSI_SDA - NOTE: set as gpio, to be used
+	 *                            when MSS is used for power cooling
+	 * [30]  MSS_TWSI_SDA - NOTE: set as gpio, to be used
+	 *                            when MSS is used for power cooling
+	 * [31]  USB Over current indication
+	 * [32-62] = 0xff: Keep default CP0_shared_pins:
+	 */
+		/*     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = <  0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x8  0    0xff
+		      0    0    3    3    3    3    3    0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0    0xff 0    0    0    0
+		      0    0    0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff>;
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+		<0x2000000 0x1000000>,	/* CS0 */
+		<0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* check if PCI is here, else none
+	 * CP1 Serdes Configuration:
+	 * Lane 0: UNCONNECTED
+	 * Lane 1: UNCONNECTED
+	 * Lane 2: UNCONNECTED
+	 * Lane 3: UNCONNECTED
+	 * Lane 4: SFI (10G)
+	 * Lane 5: UNCONNECTED
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sgmii";
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 10 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/armada-8040-ucpe.dts b/arch/arm/dts/armada-8040-ucpe.dts
new file mode 100644
index 0000000000..5455095179
--- /dev/null
+++ b/arch/arm/dts/armada-8040-ucpe.dts
@@ -0,0 +1,382 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+
+/ {
+	model = "Marvell Armada 8040 uCPE";
+	compatible = "marvell,armada-8040-ucpe",
+		     "marvell,armada8040";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cp0_reg_usb3h0_vbus: usb3-right-port-vbus {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins0>;
+			regulator-name = "cp0_reg-usb3h0-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			gpio = <&cp0_gpio1 10 GPIO_ACTIVE_LOW>; /* GPIO[42] */
+		};
+
+		cp0_reg_usb3h1_vbus: usb3-left-port-vbus {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins1>;
+			regulator-name = "cp0_reg-usb3h1-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			gpio = <&cp0_gpio1 11 GPIO_ACTIVE_LOW>; /* GPIO[43] */
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/*
+	 * MPP Bus:
+	 * AP_SD_CLK    [0]
+	 * AP_SD_CMD    [1]
+	 * AP_SD_D[0~7] [2-10]
+	 * UART0        [11,19]
+	 * AP_SD_HW_RST [12]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 2 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC, KLM8G1GEME-B041 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-31] = 0xff: Keep default CP0_shared_pins:
+	 * [32] CP1_PCIE1_CLKREQn
+	 * [33] 10_SFP_LED
+	 * [34] CP1_PCIE0_CLKREQn
+	 * [35-36] CP0 I2C1
+	 * [37-38] CP0 I2C0
+	 * [39] PWM IC enable
+	 * [40,41] CP0 SMI
+	 * [42] USB3 PWR EN Port1
+	 * [43] USB3 PWR EN Port2
+	 * [44] CP0_PCIe0_clk_en
+	 * [45] CP0 PCIe0 and PCIe1 RSTOUTn
+	 * [46] CP0_PCIe0_waken
+	 * [47] CP0_PCIe1_waken
+	 * [48] CP0_PCIe1_clk_en / SFP 1G LED SW4
+	 * [49] CP0 PCIe0 wifi disable
+	 * [50-51] CP0_UA2
+	 * [52] TP31 --> CP0_LED_CLK ?
+	 * [53] TP32 --> CP0_LED_STB ?
+	 * [54] CP0 LED data
+	 * [55] Micro SD card detect
+	 * [56-61] Micro SD
+	 * [62] CP0 PCIe1 wifi disable
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0    0x9  0x0  0x9  0x2  0x2  0x2  0x2  0x0
+		     0x8  0x8  0x0  0x0  0x0  0x9  0x0  0x0  0x0  0x0
+		     0x6  0x6  0x8  0x8  0x0  0x0  0xe  0xe  0xe  0xe
+		     0xe  0xe  0x0 >;
+
+	cp0_xhci_vbus_pins0: cpm-xhci-vbus-pins {
+		marvell,pins = < 42 >;
+		marvell,function = <0>;
+	};
+
+	cp0_xhci_vbus_pins1: cpm-xhci-vbus-pins {
+		marvell,pins = < 43 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_pcie0 {
+	status = "okay";
+	reset-gpios = <&cp0_gpio1 13 GPIO_ACTIVE_HIGH>;
+	gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>; /* MPP[44] clock enable*/
+};
+
+&cp0_pcie1 {
+	status = "okay";
+	reset-gpios = <&cp0_gpio1 13 GPIO_ACTIVE_HIGH>;
+	gpio = <&cp0_gpio1 16 GPIO_ACTIVE_HIGH>; /* MPP[48] clock enable*/
+};
+
+&cp0_pcie2 {
+	status = "disabled";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c1_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* uSD slot */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	/* MPP[42] for USB3 port0 vbus on/off*/
+	vbus-supply = <&cp0_reg_usb3h0_vbus>;
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	/* MPP[43] for USB3 port0 vbus on/off*/
+	vbus-supply = <&cp0_reg_usb3h1_vbus>;
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/*
+	 * CP0 Serdes Configuration:
+	 * Lane 0: PCIE0
+	 * Lane 1: USB3 HOST0
+	 * Lane 2: SFI
+	 * Lane 3: USB3 HOST1
+	 * Lane 4: PCIE1
+	 * Lane 5: NC
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp0_mdio {
+	status = "okay";
+
+	mvswitch: switch@0{
+		compatible = "marvell,mv88e6xxx";
+		status = "okay";
+		phy-addr = <0x0>;
+		cpu-port = <0xa>;
+		port-mask = <0x7FF>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp1_sata0 {
+	status = "okay";
+	gpio = <&cp1_gpio0 17 GPIO_ACTIVE_LOW>;
+};
+
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-5] TDM
+	 * [6,7] CP1_UART 0
+	 * [8]   CP1 10G SFP LOS
+	 * [9]   CP1 10G TX FAULT
+	 * [10]  CP1 10G SFP TX Disable
+	 * [11]  CP1 10G SFP Mode
+	 * [12]  SPI1 CS1n
+	 * [13]  SPI1 MISO (TDM and SPI ROM shared)
+	 * [14]  SPI1 CS0n
+	 * [15]  SPI1 MOSI (TDM and SPI ROM shared)
+	 * [16]  SPI1 CLK (TDM and SPI ROM shared)
+	 * [17]  SSD DEV SLEEP (pull down to wake up SSD)
+	 * [18]  FAN PWM
+	 * [19]  PWM Sense
+	 * [20]  SFP 1G LED SW1
+	 * [21]  SFP 1G LED SW2
+	 * [22]  USB3 Port1 PWR overcurrent ?
+	 * [23]  USB3 Port2 PWR overcurrent ?
+	 * [24]  TP33
+	 * [25-28] LTE
+	 * [29]  PCA9535 int
+	 * [30]  E6390 int
+	 * [31]  E6390 RESETn
+	 * [32-62] = 0xff: Keep default CP1_shared_pins:
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x4  0x4  0x4  0x4  0x4  0x4  0x8  0x8  0x0  0x0
+		     0x0  0x0  0x3  0x3  0x3  0x3  0x3  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+&cp1_comphy {
+	/*
+	 * CP1 Serdes Configuration:
+	 * Lane 0: SATA 1
+	 * Lane 1: SATA 0
+	 * Lane 2: USB HOST 0
+	 * Lane 3: HS-SGMII
+	 * Lane 4: RXAUI0
+	 * Lane 5: RXAUI1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_RXAUI0>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_RXAUI1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 10G RXAUI to E6390X port9 - CP1 SRDS[4:5] */
+&cp1_eth0 {
+	status = "disabled";
+	phy-mode = "rxaui";
+};
+
+/* 2.5G SGMii to E6390X port10 - CP1 SRDS[3] */
+&cp1_eth1 {
+	status = "okay";
+	phy-mode = "sgmii-2500";
+	phy = <&mvswitch>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+	fixed-link {
+		speed = <2500>;
+		full-duplex;
+	};
+};
+
+&cp1_eth2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/armada-8040.dtsi b/arch/arm/dts/armada-8040.dtsi
index 96cc112ac9..9d701c4a87 100644
--- a/arch/arm/dts/armada-8040.dtsi
+++ b/arch/arm/dts/armada-8040.dtsi
@@ -46,12 +46,96 @@
  */
 
 #include <dt-bindings/gpio/gpio.h>
-#include "armada-ap806-quad.dtsi"
-#include "armada-cp110-master.dtsi"
-#include "armada-cp110-slave.dtsi"
+#include "armada-common.dtsi"
+#include "armada-8k.dtsi"
+#include "armada-ap806.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* CP110-0 Settings */
+#define CP110_NAME				cp0
+#define CP110_NUM				0
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
+
+/* CP110-1 Settings */
+#define CP110_NAME				cp1
+#define CP110_NUM				1
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
 
 / {
 	model = "Marvell Armada 8040";
 	compatible = "marvell,armada8040", "marvell,armada-ap806-quad",
 		     "marvell,armada-ap806";
 };
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cps-pinctrl";
+	bank-name ="cp1-110";
+
+	cp1_ge1_rgmii_pins: cp1-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11 >;
+		marvell,function = <3>;
+	};
+	cp1_spi1_pins: cp1-spi-pins-1 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+
+	cp1_nand_pins: cp1-nand-pins {
+		marvell,pins = < 0  1  2  3  4  5  6  7  8
+				 9  10 11 14 15 16 17 18 19
+				 20 21 22 23 24 25 26 27 >;
+		marvell,function = <1>;
+	};
+
+	cp1_nand_rb: cp1-nand-rb {
+		marvell,pins = < 12 13 >;
+		marvell,function = <2>;
+	};
+};
diff --git a/arch/arm/dts/armada-80x0-db.dtsi b/arch/arm/dts/armada-80x0-db.dtsi
new file mode 100644
index 0000000000..fe074e07bf
--- /dev/null
+++ b/arch/arm/dts/armada-80x0-db.dtsi
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+#include "armada-8040-dev-info.dtsi"
+
+/ {
+	compatible = "marvell,armada-80x0-db", "marvell,armada-8040";
+	model = "DB-ARMADA-80x0";
+
+	cp0 {
+		config-space {
+			i2c@701000 {
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+				expander1: pca953x@25 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x25>;
+					status = "okay";
+				};
+			};
+
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+			};
+
+			cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+			/*
+			 * Even though this node used for enable/disable
+			 * cp1 usb vbus-supply, we use "cp0" prefix since
+			 * the expander is connected to cp0.
+			 */
+			cp0_reg_usb3_vbus2: cp0_usb3_vbus@2 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus3: cp0_usb3_vbus@3 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter2: cp0_usb3_current_limiter@2 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus0>;
+				current-limiter = <&cp0_reg_usb3_current_limiter0>;
+				vbus-disable-delay = <500>;
+			};
+			cp0_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus1>;
+				current-limiter = <&cp0_reg_usb3_current_limiter1>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+		};
+	};
+
+#define CP110_NUM				1
+#define SPI_DIRECT_BASE				(0xf9000000)
+
+	cp1 {
+		config-space {
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+
+			cp1_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus2>;
+				current-limiter = <&cp0_reg_usb3_current_limiter2>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp1_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus3>;
+				vbus-disable-delay = <500>;
+			};
+
+		};
+	};
+#undef CP110_NUM
+};
diff --git a/arch/arm/dts/armada-8k.dtsi b/arch/arm/dts/armada-8k.dtsi
new file mode 100644
index 0000000000..60076d48c2
--- /dev/null
+++ b/arch/arm/dts/armada-8k.dtsi
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+/* Common definitions used by Armada 8K DTs */
+
+/* This defines used to calculate the base address of each CP */
+#define CP110_BASE_OFFSET			(0xf2000000)
+#define CP110_SPACE_SIZE			(0x02000000)
+#define CP110_BASE				(CP110_BASE_OFFSET + \
+	((CP110_NUM % 2) * CP110_SPACE_SIZE))
+
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)		\
+	(0xf6000000 + (CP110_NUM % 2) * 0x4000000 + (iface) *  0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)		\
+		(CP110_PCIEx_CPU_MEM_BASE(iface))
+#define CP110_PCIE_BUS_MEM_CFG			(0x82000000)
diff --git a/arch/arm/dts/armada-ap806-quad.dtsi b/arch/arm/dts/armada-ap806-quad.dtsi
deleted file mode 100644
index ba43a4357b..0000000000
--- a/arch/arm/dts/armada-ap806-quad.dtsi
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada AP806.
- */
-
-#include "armada-ap806.dtsi"
-
-/ {
-	model = "Marvell Armada AP806 Quad";
-	compatible = "marvell,armada-ap806-quad", "marvell,armada-ap806";
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@000 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x000>;
-			enable-method = "psci";
-		};
-		cpu@001 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x001>;
-			enable-method = "psci";
-		};
-		cpu@100 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x100>;
-			enable-method = "psci";
-		};
-		cpu@101 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x101>;
-			enable-method = "psci";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-ap806.dtsi b/arch/arm/dts/armada-ap806.dtsi
index 713c2dba74..6a8eced524 100644
--- a/arch/arm/dts/armada-ap806.dtsi
+++ b/arch/arm/dts/armada-ap806.dtsi
@@ -44,231 +44,32 @@
  * Device Tree file for Marvell Armada AP806.
  */
 
-#include <dt-bindings/interrupt-controller/arm-gic.h>
+/* AP806 Settings */
+#define AP_NAME				ap806
 
-/dts-v1/;
+#include "armada-ap80x.dtsi"
 
 / {
 	model = "Marvell Armada AP806";
-	compatible = "marvell,armada-ap806";
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	aliases {
-		serial0 = &uart0;
-		serial1 = &uart1;
-	};
-
-	psci {
-		compatible = "arm,psci-0.2";
-		method = "smc";
-	};
-
-	reserved-memory {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		ranges;
-
-		psci-area@4000000 {
-			reg = <0x0 0x4000000 0x0 0x200000>;
-			no-map;
-		};
-	};
-
-	ap806 {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
 
+	AP_NAME {
 		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			ranges = <0x0 0x0 0xf0000000 0x1000000>;
-
-			gic: interrupt-controller@210000 {
-				compatible = "arm,gic-400";
-				#interrupt-cells = <3>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				ranges;
-				interrupt-controller;
-				interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
-				reg = <0x210000 0x10000>,
-				      <0x220000 0x20000>,
-				      <0x240000 0x20000>,
-				      <0x260000 0x20000>;
-
-				gic_v2m0: v2m@280000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x280000 0x1000>;
-					arm,msi-base-spi = <160>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m1: v2m@290000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x290000 0x1000>;
-					arm,msi-base-spi = <192>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m2: v2m@2a0000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x2a0000 0x1000>;
-					arm,msi-base-spi = <224>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m3: v2m@2b0000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x2b0000 0x1000>;
-					arm,msi-base-spi = <256>;
-					arm,msi-num-spis = <32>;
-				};
-			};
-
-			timer {
-				compatible = "arm,armv8-timer";
-				interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>;
-			};
-
-			odmi: odmi@300000 {
-				compatible = "marvell,odmi-controller";
-				interrupt-controller;
-				msi-controller;
-				marvell,odmi-frames = <4>;
-				reg = <0x300000 0x4000>,
-				      <0x304000 0x4000>,
-				      <0x308000 0x4000>,
-				      <0x30C000 0x4000>;
-				marvell,spi-base = <128>, <136>, <144>, <152>;
-			};
-
-			ap_pinctl: ap-pinctl@6F4000 {
-				compatible = "marvell,ap806-pinctrl";
-				bank-name ="apn-806";
-				reg = <0x6F4000 0x10>;
-				pin-count = <20>;
-				max-func = <3>;
-
-				ap_i2c0_pins: i2c-pins-0 {
-					marvell,pins = < 4 5 >;
-					marvell,function = <3>;
-				};
-				ap_emmc_pins: emmc-pins-0 {
-					marvell,pins = < 0 1 2 3 4 5 6 7
-							 8 9 10 >;
-					marvell,function = <1>;
-				};
-			};
-
-			ap_gpio0: gpio@6F5040 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x6F5040 0x40>;
-				ngpios = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			xor@400000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x400000 0x1000>,
-				      <0x410000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@420000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x420000 0x1000>,
-				      <0x430000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@440000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x440000 0x1000>,
-				      <0x450000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@460000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x460000 0x1000>,
-				      <0x470000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			spi0: spi@510600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x510600 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <0>;
-				interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-			};
-
-			i2c0: i2c@511000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x511000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
-				timeout-ms = <1000>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-			};
-
-			uart0: serial@512000 {
-				compatible = "snps,dw-apb-uart";
-				reg = <0x512000 0x100>;
-				reg-shift = <2>;
-				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
-				reg-io-width = <1>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-				clock-frequency = <200000000>;
-			};
-
-			uart1: serial@512100 {
-				compatible = "snps,dw-apb-uart";
-				reg = <0x512100 0x100>;
-				reg-shift = <2>;
-				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
-				reg-io-width = <1>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-
-			};
-
-			ap_sdhci0: sdhci@6e0000 {
-				compatible = "marvell,armada-8k-sdhci";
-				reg = <0x6e0000 0x300>;
-				interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
-				dma-coherent;
-				status = "disabled";
+			sar-reg {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-ap806";
+				reg = <0x6F8200 0x8>;
+				sar-driver = "ap806_sar";
+				sar-name = "ap806_sar";
+				status = "okay";
 			};
 
-			ap_syscon: system-controller@6f4000 {
-				compatible = "marvell,ap806-system-controller",
-					     "syscon";
-				#clock-cells = <1>;
-				clock-output-names = "ap-cpu-cluster-0",
-						     "ap-cpu-cluster-1",
-						     "ap-fixed", "ap-mss";
-				reg = <0x6f4000 0x1000>;
+			thermal: thermal@6f8084 {
+				compatible = "marvell,mvebu-thermal", "marvell,thermal-ext-sensor";
+				reg = <0x6f8084 0x12>;
+				gain = <425>;
+				offset = <153400>;
+				divisor = <1000>;
+				status = "okay";
 			};
 		};
 	};
diff --git a/arch/arm/dts/armada-ap807.dtsi b/arch/arm/dts/armada-ap807.dtsi
new file mode 100644
index 0000000000..848e3fb363
--- /dev/null
+++ b/arch/arm/dts/armada-ap807.dtsi
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP807.
+ */
+
+/* AP807 Settings */
+#define AP_NAME				ap807
+
+#include "armada-ap80x.dtsi"
+
+/ {
+	model = "Marvell Armada AP807";
+
+	AP_NAME {
+		config-space {
+			sar-reg {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-ap807";
+				reg = <0x6F8200 0x8>;
+				sar-driver = "ap807_sar";
+				sar-name = "ap807_sar";
+				status = "okay";
+			};
+
+			thermal: thermal@6f8084 {
+				compatible = "marvell,mvebu-thermal",
+					     "marvell,thermal-ext-sensor";
+				reg = <0x6f8084 0x12>;
+				gain = <394>;
+				offset = <128900>;
+				divisor = <1000>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-ap80x-quad.dtsi b/arch/arm/dts/armada-ap80x-quad.dtsi
new file mode 100644
index 0000000000..d5d85db619
--- /dev/null
+++ b/arch/arm/dts/armada-ap80x-quad.dtsi
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP806/AP807.
+ */
+
+/ {
+	model = "Marvell Armada AP80X Quad";
+	compatible = "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@000 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x000>;
+			enable-method = "psci";
+		};
+		cpu@001 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x001>;
+			enable-method = "psci";
+		};
+		cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x100>;
+			enable-method = "psci";
+		};
+		cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x101>;
+			enable-method = "psci";
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-ap80x.dtsi b/arch/arm/dts/armada-ap80x.dtsi
new file mode 100644
index 0000000000..51bb6082be
--- /dev/null
+++ b/arch/arm/dts/armada-ap80x.dtsi
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP806/AP807.
+ */
+
+/dts-v1/;
+/ {
+	compatible = "marvell,armada-ap806";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+	};
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		psci-area@4000000 {
+			reg = <0x0 0x4000000 0x0 0x200000>;
+			no-map;
+		};
+	};
+
+	AP_NAME {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		config-space {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			ranges = <0x0 0x0 0xf0000000 0x1000000>;
+
+			ap_pinctl: ap-pinctl@6F4000 {
+				compatible = "marvell,ap806-pinctrl";
+				bank-name ="apn-806";
+				reg = <0x6F4000 0x10>;
+				pin-count = <20>;
+				max-func = <3>;
+
+				ap_i2c0_pins: i2c-pins-0 {
+					marvell,pins = < 4 5 >;
+					marvell,function = <3>;
+				};
+				ap_emmc_pins: emmc-pins-0 {
+					marvell,pins = < 0 1 2 3 4 5 6 7
+							 8 9 10 12 >;
+					marvell,function = <1>;
+				};
+			};
+
+			ap_gpio0: gpio@6F5040 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x6F5040 0x40>;
+				ngpios = <20>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			ap_spi0: spi@510600 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x510600 0x50>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				cell-index = <0>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			ap_i2c0: i2c@511000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x511000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				timeout-ms = <1000>;
+				status = "disabled";
+			};
+
+			uart0: serial@512000 {
+				compatible = "snps,dw-apb-uart";
+				reg = <0x512000 0x100>;
+				reg-shift = <2>;
+				reg-io-width = <1>;
+				status = "disabled";
+				clock-frequency = <200000000>;
+			};
+
+			uart1: serial@512100 {
+				compatible = "snps,dw-apb-uart";
+				reg = <0x512100 0x100>;
+				reg-shift = <2>;
+				reg-io-width = <1>;
+				status = "disabled";
+
+			};
+
+			ap_sdhci0: sdhci@6e0000 {
+				compatible = "marvell,armada-8k-sdhci";
+				reg = <0x6e0000 0x300>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			ap_ld_efuse0: efuse-0@6F8F00 {
+				compatible = "marvell,mvebu-fuse-ld-user";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F8F00>;
+				status = "disabled";
+			};
+
+			ap_ld_efuse1: efuse-1@6F8F00 {
+				compatible = "marvell,mvebu-fuse-ld-prop";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F8F00>;
+				status = "disabled";
+			};
+
+			ap_hd_efuse0: efuse@6F9000  {
+				compatible = "marvell,mvebu-fuse-hd";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F9000>;
+				rows-count = <64>;
+				status = "disabled";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-common.dtsi b/arch/arm/dts/armada-common.dtsi
new file mode 100644
index 0000000000..34bd7e3230
--- /dev/null
+++ b/arch/arm/dts/armada-common.dtsi
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* Common definitions used by Armada 7K/8K DTs */
+#define PASTER(x, y)		x ## _ ## y
+#define EVALUATOR(x, y)		PASTER(x, y)
+
+/* This define used to create die label:
+ * For example:
+ * CP110 master:
+ *     CP110_LABEL(spi0) -> cp0_spi0
+ * CP110 slave:
+ *     CP110_LABEL(usb0) -> cp1_usb0
+ */
+#define CP110_LABEL(name)	EVALUATOR(CP110_NAME, name)
+
+#define APPEND_NX(A, B)		A ##-## B
+#define APPEND(A, B)		APPEND_NX(A, B)
+
+#define STRINGIZE_NX(x)		#x
+#define STRINGIZE(x)		STRINGIZE_NX(x)
+
+/* Same idea here, but this define convert the name to string:
+ * For example:
+ * master: CP110_STRING_LABEL(ppv2) -> "cp0-ppv2"
+ * slave: CP110_STRING_LABEL(ppv2) -> "cp1-ppv2"
+ */
+#define CP110_STRING_LABEL(name)	STRINGIZE(APPEND(CP110_NAME, name))
diff --git a/arch/arm/dts/armada-cp110-master.dtsi b/arch/arm/dts/armada-cp110-master.dtsi
deleted file mode 100644
index e4c17e9f4b..0000000000
--- a/arch/arm/dts/armada-cp110-master.dtsi
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada CP110 Master.
- */
-
-#include <dt-bindings/comphy/comphy_data.h>
-
-/ {
-	cp110-master {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
-
-		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			interrupt-parent = <&gic>;
-			ranges = <0x0 0x0 0xf2000000 0x2000000>;
-
-			cpm_ethernet: ethernet@0 {
-				compatible = "marvell,armada-7k-pp22";
-				reg = <0x0 0x100000>, <0x129000 0xb000>;
-				clocks = <&cpm_syscon0 1 3>, <&cpm_syscon0 1 9>, <&cpm_syscon0 1 5>;
-				clock-names = "pp_clk", "gop_clk", "mg_clk";
-				status = "disabled";
-				dma-coherent;
-
-				cpm_eth0: eth0 {
-					interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <0>;
-					gop-port-id = <0>;
-					status = "disabled";
-				};
-
-				cpm_eth1: eth1 {
-					interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <1>;
-					gop-port-id = <2>;
-					status = "disabled";
-				};
-
-				cpm_eth2: eth2 {
-					interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <2>;
-					gop-port-id = <3>;
-					status = "disabled";
-				};
-			};
-
-			cpm_mdio: mdio@12a200 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "marvell,orion-mdio";
-				reg = <0x12a200 0x10>;
-				device-name = "cpm-mdio";
-			};
-
-			cpm_syscon0: system-controller@440000 {
-				compatible = "marvell,cp110-system-controller0",
-					     "syscon";
-				reg = <0x440000 0x1000>;
-				#clock-cells = <2>;
-				core-clock-output-names =
-					"cpm-apll", "cpm-ppv2-core", "cpm-eip",
-					"cpm-core", "cpm-nand-core";
-				gate-clock-output-names =
-					"cpm-audio", "cpm-communit", "cpm-nand",
-					"cpm-ppv2", "cpm-sdio", "cpm-mg-domain",
-					"cpm-mg-core", "cpm-xor1", "cpm-xor0",
-					"cpm-gop-dp", "none", "cpm-pcie_x10",
-					"cpm-pcie_x11", "cpm-pcie_x4", "cpm-pcie-xor",
-					"cpm-sata", "cpm-sata-usb", "cpm-main",
-					"cpm-sd-mmc", "none", "none",
-					"cpm-slow-io", "cpm-usb3h0", "cpm-usb3h1",
-					"cpm-usb3dev", "cpm-eip150", "cpm-eip197";
-			};
-
-			cpm_pinctl: cpm-pinctl@440000 {
-				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,armada-7k-pinctrl",
-					     "marvell,armada-8k-cpm-pinctrl";
-				bank-name ="cp0-110";
-				reg = <0x440000 0x20>;
-				pin-count = <63>;
-				max-func = <0xf>;
-
-				cpm_i2c0_pins: cpm-i2c-pins-0 {
-					marvell,pins = < 37 38 >;
-					marvell,function = <2>;
-				};
-				cpm_i2c1_pins: cpm-i2c-pins-1 {
-					marvell,pins = < 35 36 >;
-					marvell,function = <2>;
-				};
-				cpm_ge2_rgmii_pins: cpm-ge-rgmii-pins-0 {
-					marvell,pins = < 44 45 46 47 48 49 50 51
-							 52 53 54 55 >;
-					marvell,function = <1>;
-				};
-				pca0_pins: cpm-pca0_pins {
-					marvell,pins = <62>;
-					marvell,function = <0>;
-				};
-				cpm_sdhci_pins: cpm-sdhi-pins-0 {
-					marvell,pins = < 56 57 58 59 60 61 >;
-					marvell,function = <14>;
-				};
-				cpm_spi0_pins: cpm-spi-pins-0 {
-					marvell,pins = < 13 14 15 16 >;
-					marvell,function = <3>;
-				};
-			};
-
-			cpm_gpio0: gpio@440100 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440100 0x40>;
-				ngpios = <32>;
-				gpiobase = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cpm_gpio1: gpio@440140 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440140 0x40>;
-				ngpios = <31>;
-				gpiobase = <52>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cpm_sata0: sata@540000 {
-				compatible = "marvell,armada-8k-ahci";
-				reg = <0x540000 0x30000>;
-				interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 15>;
-				status = "disabled";
-			};
-
-			cpm_usb3_0: usb3@500000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x500000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 22>;
-				status = "disabled";
-			};
-
-			cpm_usb3_1: usb3@510000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x510000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 23>;
-				status = "disabled";
-			};
-
-			cpm_spi0: spi@700600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700600 0x50>;
-				#address-cells = <0x1>;
-				#size-cells = <0x0>;
-				cell-index = <1>;
-				clocks = <&cpm_syscon0 0 3>;
-				status = "disabled";
-			};
-
-			cpm_spi1: spi@700680 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700680 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <2>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_i2c0: i2c@701000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_i2c1: i2c@701100 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701100 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_comphy: comphy@441000 {
-				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
-				reg = <0x441000 0x8>,
-				      <0x120000 0x8>;
-				mux-bitcount = <4>;
-				max-lanes = <6>;
-			};
-
-			cpm_utmi0: utmi@580000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x580000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440440 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
-				status = "disabled";
-			};
-
-			cpm_utmi1: utmi@581000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x581000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440444 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST1>;
-				status = "disabled";
-			};
-
-			cpm_sdhci0: sdhci@780000 {
-				compatible = "marvell,armada-8k-sdhci";
-				reg = <0x780000 0x300>;
-				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
-				dma-coherent;
-				status = "disabled";
-			};
-
-			cpm_nand: nand@720000 {
-				compatible = "marvell,mvebu-pxa3xx-nand";
-				reg = <0x720000 0x100>;
-				#address-cells = <1>;
-
-				clocks = <&cpm_syscon0 1 2>;
-				nand-enable-arbiter;
-				num-cs = <1>;
-				nand-ecc-strength = <4>;
-				nand-ecc-step-size = <512>;
-				status = "disabled";
-			};
-
-		};
-
-		cpm_pcie0: pcie@f2600000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2600000 0 0x10000>,
-			      <0 0xf6f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9000000 0  0xf9000000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf6000000 0  0xf6000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 13>;
-			status = "disabled";
-		};
-
-		cpm_pcie1: pcie@f2620000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2620000 0 0x10000>,
-			      <0 0xf7f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9010000 0  0xf9010000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf7000000 0  0xf7000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 11>;
-			status = "disabled";
-		};
-
-		cpm_pcie2: pcie@f2640000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2640000 0 0x10000>,
-			      <0 0xf8f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9020000 0  0xf9020000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf8000000 0  0xf8000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 12>;
-			status = "disabled";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-cp110-slave.dtsi b/arch/arm/dts/armada-cp110-slave.dtsi
deleted file mode 100644
index 2fbd7b5514..0000000000
--- a/arch/arm/dts/armada-cp110-slave.dtsi
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada CP110 Slave.
- */
-
-#include <dt-bindings/comphy/comphy_data.h>
-
-/ {
-	cp110-slave {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
-
-		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			interrupt-parent = <&gic>;
-			ranges = <0x0 0x0 0xf4000000 0x2000000>;
-
-			cps_ethernet: ethernet@0 {
-				compatible = "marvell,armada-7k-pp22";
-				reg = <0x0 0x100000>, <0x129000 0xb000>;
-				clocks = <&cps_syscon0 1 3>, <&cps_syscon0 1 9>, <&cps_syscon0 1 5>;
-				clock-names = "pp_clk", "gop_clk", "mg_clk";
-				status = "disabled";
-				dma-coherent;
-
-				cps_eth0: eth0 {
-					interrupts = <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <0>;
-					gop-port-id = <0>;
-					status = "disabled";
-				};
-
-				cps_eth1: eth1 {
-					interrupts = <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <1>;
-					gop-port-id = <2>;
-					status = "disabled";
-				};
-
-				cps_eth2: eth2 {
-					interrupts = <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <2>;
-					gop-port-id = <3>;
-					status = "disabled";
-				};
-			};
-
-			cps_mdio: mdio@12a200 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "marvell,orion-mdio";
-				reg = <0x12a200 0x10>;
-				device-name = "cps-mdio";
-			};
-
-			cps_syscon0: system-controller@440000 {
-				compatible = "marvell,cp110-system-controller0",
-					     "syscon";
-				reg = <0x440000 0x1000>;
-				#clock-cells = <2>;
-				core-clock-output-names =
-					"cps-apll", "cps-ppv2-core", "cps-eip",
-					"cps-core", "cps-nand-core";
-				gate-clock-output-names =
-					"cps-audio", "cps-communit", "cps-nand",
-					"cps-ppv2", "cps-sdio", "cps-mg-domain",
-					"cps-mg-core", "cps-xor1", "cps-xor0",
-					"cps-gop-dp", "none", "cps-pcie_x10",
-					"cps-pcie_x11", "cps-pcie_x4", "cps-pcie-xor",
-					"cps-sata", "cps-sata-usb", "cps-main",
-					"cps-sd-mmc", "none", "none",
-					"cps-slow-io", "cps-usb3h0", "cps-usb3h1",
-					"cps-usb3dev", "cps-eip150", "cps-eip197";
-			};
-
-			cps_pinctl: cps-pinctl@440000 {
-				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,armada-8k-cps-pinctrl";
-				bank-name ="cp1-110";
-				reg = <0x440000 0x20>;
-				pin-count = <63>;
-				max-func = <0xf>;
-
-				cps_ge1_rgmii_pins: cps-ge-rgmii-pins-0 {
-					marvell,pins = < 0  1  2  3  4  5  6  7
-							 8  9  10 11 >;
-					marvell,function = <3>;
-				};
-				cps_spi1_pins: cps-spi-pins-1 {
-					marvell,pins = < 13 14 15 16 >;
-					marvell,function = <3>;
-				};
-			};
-
-			cps_gpio0: gpio@440100 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440100 0x40>;
-				ngpios = <32>;
-				gpiobase = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cps_gpio1: gpio@440140 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440140 0x40>;
-				ngpios = <31>;
-				gpiobase = <52>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cps_sata0: sata@540000 {
-				compatible = "marvell,armada-8k-ahci";
-				reg = <0x540000 0x30000>;
-				interrupts = <GIC_SPI 287 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 15>;
-				status = "disabled";
-			};
-
-			cps_usb3_0: usb3@500000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x500000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 286 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 22>;
-				status = "disabled";
-			};
-
-			cps_usb3_1: usb3@510000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x510000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 285 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 23>;
-				status = "disabled";
-			};
-
-			cps_xor0: xor@6a0000 {
-				compatible = "marvell,armada-7k-xor", "marvell,xor-v2";
-				reg = <0x6a0000 0x1000>,
-				      <0x6b0000 0x1000>;
-				dma-coherent;
-				msi-parent = <&gic_v2m0>;
-				clocks = <&cps_syscon0 1 8>;
-			};
-
-			cps_xor1: xor@6c0000 {
-				compatible = "marvell,armada-7k-xor", "marvell,xor-v2";
-				reg = <0x6c0000 0x1000>,
-				      <0x6d0000 0x1000>;
-				dma-coherent;
-				msi-parent = <&gic_v2m0>;
-				clocks = <&cps_syscon0 1 7>;
-			};
-
-			cps_spi0: spi@700600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700600 0x50>;
-				#address-cells = <0x1>;
-				#size-cells = <0x0>;
-				cell-index = <1>;
-				clocks = <&cps_syscon0 0 3>;
-				status = "disabled";
-			};
-
-			cps_spi1: spi@700680 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700680 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <2>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_i2c0: i2c@701000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 310 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_i2c1: i2c@701100 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701100 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 311 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_comphy: comphy@441000 {
-				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
-				reg = <0x441000 0x8>,
-				      <0x120000 0x8>;
-				mux-bitcount = <4>;
-				max-lanes = <6>;
-			};
-
-			cps_utmi0: utmi@580000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x580000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440440 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
-				status = "disabled";
-			};
-		};
-
-		cps_pcie0: pcie@f4600000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4600000 0 0x10000>,
-			      <0 0xfaf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd000000 0  0xfd000000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfa000000 0  0xfa000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>;
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 13>;
-			status = "disabled";
-		};
-
-		cps_pcie1: pcie@f4620000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4620000 0 0x10000>,
-			      <0 0xfbf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd010000 0  0xfd010000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfb000000 0  0xfb000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 11>;
-			status = "disabled";
-		};
-
-		cps_pcie2: pcie@f4640000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4640000 0 0x10000>,
-			      <0 0xfcf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd020000 0  0xfd020000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfc000000 0  0xfc000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 12>;
-			status = "disabled";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-cp110.dtsi b/arch/arm/dts/armada-cp110.dtsi
new file mode 100644
index 0000000000..448cdb2f80
--- /dev/null
+++ b/arch/arm/dts/armada-cp110.dtsi
@@ -0,0 +1,368 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Generic Device Tree describing Marvell Armada CP-110 device
+ */
+#include <dt-bindings/comphy/comphy_data.h>
+
+#define U64_TO_U32_H(addr)		(((addr) >> 32) & 0xffffffff)
+#define U64_TO_U32_L(addr)		((addr) & 0xffffffff)
+
+#define CP110_PCIEx_REG0_BASE(iface)	\
+	(CP110_BASE + 0x600000 + (iface) * 0x20000)
+#define CP110_PCIEx_REG1_BASE(iface)	\
+	(CP110_PCIEx_CPU_MEM_BASE(iface) + CP110_PCIE_MEM_SIZE(iface))
+#define CP110_PCIE_EP_REG_BASE(iface)	(CP110_BASE + 0x600000 + \
+					 (iface) * 0x4000)
+
+/ {
+	CP110_NAME {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		config-space {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>;
+
+			CP110_LABEL(mdio): mdio@12a200 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "marvell,orion-mdio";
+				reg = <0x12a200 0x10>;
+				mdio-name = CP110_STRING_LABEL(mdio);
+				status = "disabled";
+			};
+
+			CP110_LABEL(xmdio): mdio@12a600 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "marvell,xmdio";
+				reg = <0x12a600 0x200>;
+				mdio-name = CP110_STRING_LABEL(xmdio);
+				status = "disabled";
+			};
+
+			CP110_LABEL(sar-reg) {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-cp110";
+				reg = <0x400200 0x8>;
+				sar-driver = "cp110_sar";
+				sar-name = CP110_STRING_LABEL(sar);
+				status = "okay";
+			};
+
+			CP110_LABEL(ld_efuse0): CP110_LABEL(efuse0)@400F00 {
+				compatible = "marvell,mvebu-fuse-ld-user";
+				reg = <0x400008 0x4>;
+				otp-mem = <0x400F00>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(ld_efuse1): CP110_LABEL(efuse1)@400F00 {
+				compatible = "marvell,mvebu-fuse-ld-prop";
+				reg = <0x400008 0x4>;
+				otp-mem = <0x400F00>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(pinctl): pinctl@440000 {
+				compatible = "marvell,mvebu-pinctrl";
+				reg = <0x440000 0x20>;
+				pin-count = <63>;
+				max-func = <0xf>;
+			};
+
+			CP110_LABEL(gpio0): gpio@440100 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x440100 0x40>;
+				ngpios = <32>;
+				gpiobase = <20>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			CP110_LABEL(thermal): thermal@400070 {
+				compatible = "marvell,mvebu-thermal", "marvell,thermal-sensor";
+				reg = <0x400070 0x12>;
+				gain = <4761>;
+				offset = <2791000>;
+				divisor = <10000>;
+				status = "okay";
+			};
+
+			CP110_LABEL(gpio1): gpio@440140 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x440140 0x40>;
+				ngpios = <31>;
+				gpiobase = <52>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			CP110_LABEL(sata0): sata@540000 {
+				compatible = "marvell,armada-8k-ahci";
+				reg = <0x540000 0x30000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(usb3_0): usb3@500000 {
+				compatible = "marvell,armada-8k-xhci",
+					     "generic-xhci";
+				reg = <0x500000 0x4000>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(usb3_1): usb3@510000 {
+				compatible = "marvell,armada-8k-xhci",
+					     "generic-xhci";
+				reg = <0x510000 0x4000>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(spi0): spi@700600 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x700600 0x50>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+				cell-index = <1>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(spi1): spi@700680 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x700680 0x50>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				cell-index = <2>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(i2c0): i2c@701000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x701000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(i2c1): i2c@701100 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x701100 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(mss_i2c0): i2c@211000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x211000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(comphy): comphy@441000 {
+				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
+				reg = <0x441000 0x8>,
+				      <0x120000 0x8>;
+				mux-bitcount = <4>;
+				max-lanes = <6>;
+			};
+
+			CP110_LABEL(utmi): utmi@580000 {
+				compatible = "marvell,mvebu-utmi";
+				reg = <0x580000 0xc>; /* utmi-common-pll */
+				#address-cells = <1>;
+				#size-cells = <1>;
+				CP110_LABEL(utmi0): utmi@58000c {
+					compatible = "marvell,mvebu-utmi-2.6.0";
+					reg = <0x58000c 0x100>,/* utmi-unit */
+					      <0x440420 0x4>,	/* usb-cfg */
+					      <0x440440 0x4>;	/* utmi-cfg */
+					utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(utmi1): utmi@58100c {
+					compatible = "marvell,mvebu-utmi-2.6.0";
+					reg = <0x58100c 0x100>,/* utmi-unit */
+					      <0x440420 0x4>,	/* usb-cfg */
+					      <0x440444 0x4>;	/* utmi-cfg */
+					utmi-port = <UTMI_PHY_TO_USB3_HOST1>;
+					status = "disabled";
+				};
+			};
+
+			CP110_LABEL(sdhci0): sdhci@780000 {
+				compatible = "marvell,armada-8k-sdhci";
+				reg = <0x780000 0x300>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(nand): nand@720000 {
+				compatible = "marvell,mvebu-pxa3xx-nand";
+				reg = <0x720000 0x100>,
+				      <0x440700 0x20>,
+				      <0x440208 0x20>;
+				reg-names = "ctrl_base",
+					    "flash_clock",
+					    "dev_mux";
+				#address-cells = <1>;
+
+				nand-enable-arbiter;
+				num-cs = <1>;
+				nand-ecc-strength = <8>;
+				nand-ecc-step-size = <512>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(rtc): rtc-reg@284000 {
+				compatible = "marvell,armada-8k-rtc";
+				reg = <0x284000 104>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(ethernet): ethernet@0 {
+				compatible = "marvell,armada-7k-pp22";
+				reg = <0x0 0x100000>,
+				      <0x129000 0xb000>,
+				      <0x120000 0x6000>;
+				status = "disabled";
+				dma-coherent;
+
+				CP110_LABEL(eth0): eth0 {
+					port-id = <0>;
+					gop-port-id = <0>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(eth1): eth1 {
+					port-id = <1>;
+					gop-port-id = <2>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(eth2): eth2 {
+					port-id = <2>;
+					gop-port-id = <3>;
+					status = "disabled";
+				};
+			};
+		};
+
+		CP110_LABEL(pcie_ep): pcie-ep@600000 {
+			compatible = "marvell,armada-pcie-ep", "snps,dw-pcie";
+			reg =	<U64_TO_U32_H(CP110_PCIE_EP_REG_BASE(0))
+				U64_TO_U32_L(CP110_PCIE_EP_REG_BASE(0)) 0 0x4000>,
+				<U64_TO_U32_H(CP110_PCIE_EP_REG_BASE(2))
+				U64_TO_U32_L(CP110_PCIE_EP_REG_BASE(2)) 0 0x80000>,
+				<U64_TO_U32_H(CP110_PCIE_EP_REG_BASE(1))
+				U64_TO_U32_L(CP110_PCIE_EP_REG_BASE(1)) 0 0x1000>;
+			reg-names = "core", "lm", "shadow_core";
+			status = "disabled";
+		};
+
+		CP110_LABEL(pci_ep_uio): pci-ep-uio {
+			compatible = "marvell,pci-ep-uio";
+			reg = <0x00 0x00000000 0x0 0x00100000>,
+			      <0x00 0x3f000000 0x0 0x01000000>,
+			      <0x00 0xf0000000 0x0 0x01000000>,
+			      <0x80 0x00000000 0x4 0x00000000>;
+			reg-names = "bar0", "bar2", "bar4", "host-map";
+			device-id = <0x7080>;
+			vf-device-id = <0x7081>;
+			class-code = <0x2>;
+			subclass-code = <0x0>;
+			status = "disabled";
+		};
+
+		CP110_LABEL(bootcmd): pci-bootcmd@3ffff000 {
+			/* remote bootcmd buffer location */
+			compatible = "marvell,pci-bootcmd";
+			reg = <0 0x3ffff000 0 0x1000>;
+			skip-init;
+			status = "disabled";
+		};
+
+		CP110_LABEL(pcie0): pcie0@600000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(0)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(0)) 0 0x10000>,
+			   /* Last 512KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(0)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(0)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(0))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(0)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(0))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(0))
+				U64_TO_U32_H(CP110_PCIE_MEM_SIZE(0)) U64_TO_U32_L(CP110_PCIE_MEM_SIZE(0))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+
+		CP110_LABEL(pcie1): pcie1@620000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(1)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(1)) 0 0x10000>,
+			   /* Last 512KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(1)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(1)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(1))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(1)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(1))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(1)) U64_TO_U32_H(CP110_PCIE_MEM_SIZE(1))
+				U64_TO_U32_L(CP110_PCIE_MEM_SIZE(1))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+
+		CP110_LABEL(pcie2): pcie2@640000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(2)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(2)) 0 0x10000>,
+			   /* Last 64KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(2)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(2)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(2))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(2)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(2))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(2)) U64_TO_U32_H(CP110_PCIE_MEM_SIZE(2))
+				U64_TO_U32_L(CP110_PCIE_MEM_SIZE(2))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/dts/cn9130-crb-A.dts b/arch/arm/dts/cn9130-crb-A.dts
new file mode 100644
index 0000000000..e3fd22746f
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-A.dts
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130-crb.dtsi"
+
+/ {
+	model = "CN9130-CRB-A";
+	compatible = "marvell,cn9130-crb-A",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xc0000000 0 0xc0000000 0 0x2000000>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-crb-B.dts b/arch/arm/dts/cn9130-crb-B.dts
new file mode 100644
index 0000000000..52204d52d9
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-B.dts
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130-crb.dtsi"
+
+/ {
+	model = "CN9130-CRB-B";
+	compatible = "marvell,cn9130-crb-B",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	num-lanes = <1>;
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xc0000000 0 0xc0000000 0 0x2000000>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-crb-C.dts b/arch/arm/dts/cn9130-crb-C.dts
new file mode 100644
index 0000000000..c457e8304d
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-C.dts
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130-crb.dtsi"
+
+/ {
+	model = "CN9130-CRB-C (PCIe EP)";
+	compatible = "marvell,cn9130-crb-C",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* The PCI console memory must be reserved */
+		console_reserved: pci-console-nexus@3f000000 {
+			compatible = "marvell,pci-console-nexus-memory";
+			reg = <0 0x3f000000 0 0x1000000>;
+			no-map;
+		};
+	};
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+};
+
+&cp0_bootcmd {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-crb-r1p3-A.dts b/arch/arm/dts/cn9130-crb-r1p3-A.dts
new file mode 100644
index 0000000000..6959242fcd
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-r1p3-A.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ */
+
+#include "cn9130-crb-A.dts"
+#include "cn9130-crb-r1p3.dtsi"
+
+/ {
+	model = "CN9130-CRB-A";
+	compatible = "marvell,cn9130-crb-A",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
diff --git a/arch/arm/dts/cn9130-crb-r1p3-B.dts b/arch/arm/dts/cn9130-crb-r1p3-B.dts
new file mode 100644
index 0000000000..f30221588d
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-r1p3-B.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ */
+
+#include "cn9130-crb-B.dts"
+#include "cn9130-crb-r1p3.dtsi"
+
+/ {
+	model = "CN9130-CRB-B";
+	compatible = "marvell,cn9130-crb-B",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
diff --git a/arch/arm/dts/cn9130-crb-r1p3-C.dts b/arch/arm/dts/cn9130-crb-r1p3-C.dts
new file mode 100644
index 0000000000..4d034fae26
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-r1p3-C.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ */
+
+#include "cn9130-crb-C.dts"
+#include "cn9130-crb-r1p3.dtsi"
+
+/ {
+	model = "CN9130-CRB-C (PCIe EP)";
+	compatible = "marvell,cn9130-crb-C",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
diff --git a/arch/arm/dts/cn9130-crb-r1p3.dtsi b/arch/arm/dts/cn9130-crb-r1p3.dtsi
new file mode 100644
index 0000000000..8922c0d7e8
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-r1p3.dtsi
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ */
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12] GPIO
+	 *	[13-16] SPI1
+	 *	[17-32] GPIO
+	 *	[33]	SD_PWR_OFF
+	 *	[34]	CP_PCIE0_CLKREQn
+	 *	[35-38]	I2C1 I2C0
+	 *	[39]	GPIO
+	 *	[40-43]	SMI/XSMI
+	 *	[44-46]	GPIO
+	 *	[47]	UART1_TX
+	 *	[48]	GPIO
+	 *	[49]	SD_HST_18_EN
+	 *	[50]	GPIO
+	 *	[51]	SD_PWR_0
+	 *	[52]	PCIE_RSTn
+	 *	[53]	UART1_RX
+	 *	[54]	GPIO
+	 *	[55]	SD_DT
+	 *	[56-61]	SDIO
+	 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   0   0
+		     0   0   0   6   9   2   2   2   2   0
+		     8   8   8   8   0   0   0   7   0   0xa
+		     0   0xa 9   7   0   0xb 0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_spi1 {
+	pinctrl-0 = <&cp0_spi0_pins>;
+};
diff --git a/arch/arm/dts/cn9130-crb.dtsi b/arch/arm/dts/cn9130-crb.dtsi
new file mode 100644
index 0000000000..41906511ab
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb.dtsi
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130.dtsi" /* include SoC device tree */
+
+/ {
+	model = "CN9130-CRB";
+	compatible = "marvell,cn9130-crb",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0 {
+		config-space {
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+				vmmc-supply = <&cp0_reg_sd_vcc>;
+			};
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vccq";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&cp0_gpio1 18 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp0_reg_sd_vcc: cp0_sd_vcc@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&cp0_gpio1 22 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC - U6 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12-26]	GPIO
+	 *	[27-30]	SPI1
+	 *	[31]	GPIO
+	 *	[32]	GPIO
+	 *	[33]	SD_PWR_OFF
+	 *	[34]	CP_PCIE0_CLKREQn
+	 *	[35-38]	I2C1 I2C0
+	 *	[39]	GPIO
+	 *	[40-43]	SMI/XSMI
+	 *	[44-46]	GPIO
+	 *	[47]	UART1_TX
+	 *	[48]	GPIO
+	 *	[49]	SD_HST_18_EN
+	 *	[50]	GPIO
+	 *	[51]	SD_PWR_0
+	 *	[52]	PCIE_RSTn
+	 *	[53]	UART1_RX
+	 *	[54]	GPIO
+	 *	[55]	SD_DT
+	 *	[56-61]	SDIO
+	 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   0   0   0   0   0   0   0
+		     0   0   0   0   0   0   0   2   2   2
+		     2   0   0   6   9   2   2   2   2   0
+		     8   8   8   8   0   0   0   7   0   0xa
+		     0   0xa 9   7   0   0xb 0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_pinctl {
+	cp0_spi1_pins_crb: cp0-spi-pins-crb {
+		marvell,pins = < 27 28 29 30 >;
+		marvell,function = <2>;
+	};
+};
+
+/*
+ * CP0
+ */
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi1_pins_crb>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	switch6: ethernet-switch@6 {
+		reg = <6>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	nbaset_phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&nbaset_phy0>;
+	phy-mode = "sgmii-2500";
+};
diff --git a/arch/arm/dts/cn9130-db-A.dts b/arch/arm/dts/cn9130-db-A.dts
new file mode 100644
index 0000000000..ea1a8cc95e
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-A.dts
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db.dtsi"
+
+/ {
+	model = "Marvell CN9130 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9130-db", "marvell,cn91xx", "marvell,cn9030-vd",
+		     "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12]	GPIO GE-IN
+	 *	[13-16]	SPI1
+	 *	[17-27]	NAND
+	 *	[28]	MSS_GPIO[5] XXX:(mode nr from a3900)
+	 *	[29-30]	SATA
+	 *	[31]	MSS_GPIO[4] XXX:(mode nr from a3900)
+	 *	[32,34]	SMI
+	 *	[33]	SDIO
+	 *	[35-36]	I2C1
+	 *	[37-38]	I2C0
+	 *	[39-43]	SDIOctrl
+	 *	[44-55]	RGMII2
+	 *	[56-62]	SDIO
+	 */
+
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   1   1   1
+		     1   1   1   1   1   1   1   1   3   9
+		     9   3   7   6   7   2   2   2   2   1
+		     1   1   1   1   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+/* CON 28 */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* U54 */
+&cp0_nand {
+	status = "disabled";
+};
+
+/* U55 */
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_comphy {
+
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+/* SLM-1521-V2, CON6 */
+&cp0_pcie0 {
+	num-lanes = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* CON56 */
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+/* CON57 */
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+/* SLM-1521-V2, CON2 */
+&cp0_sata0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-db-B.dts b/arch/arm/dts/cn9130-db-B.dts
new file mode 100644
index 0000000000..ff15246e7c
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-B.dts
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db.dtsi"
+
+/ {
+	model = "Marvell CN9130 development board (CP NAND) setup(B)";
+	compatible = "marvell,cn9130-db", "marvell,cn91xx", "marvell,cn9030-vd",
+		     "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	cp0_nand_pins: cp0-nand-pins {
+		marvell,pins = <15 16 17 18 19 20 21 22 23 24 25 26 27 >;
+		marvell,function = <1>;
+	};
+	cp0_nand_rb: cp0-nand-rb {
+		marvell,pins = < 13 >;
+		marvell,function = <2>;
+	};
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12]	GPIO GE-IN
+	 *	[13-14]	SPI1
+	 *	[15-27]	NAND
+	 *	[28]	MSS_GPIO[5] XXX:(mode nr from a3900)
+	 *	[29-30]	SATA
+	 *	[31]	MSS_GPIO[4] XXX:(mode nr from a3900)
+	 *	[32,34]	SMI
+	 *	[33]	SDIO
+	 *	[35-36]	I2C1
+	 *	[37-38]	I2C0
+	 *	[39-43]	SDIOctrl
+	 *	[44-55]	RGMII2
+	 *	[56-62]	SDIO
+	 */
+
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   2   3   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   3   9
+		     9   3   7   6   7   2   2   2   2   1
+		     1   1   1   1   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+/* CON 28 */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* U54 */
+&cp0_nand {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_nand_pins &cp0_nand_rb>;
+	status = "okay";
+};
+
+/* U55 */
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "disabled";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+/* SLM-1521-V2, CON6 */
+&cp0_pcie0 {
+	num-lanes = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* CON56 */
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+/* CON57 */
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+/* SLM-1521-V2, CON2 */
+&cp0_sata0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-db-C.dts b/arch/arm/dts/cn9130-db-C.dts
new file mode 100644
index 0000000000..c08aaf428f
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-C.dts
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db.dtsi"
+
+/ {
+	model = "Marvell CN9130 development board (CP NOR) setup(C) PCIe EP";
+	compatible = "marvell,cn9130-db", "marvell,cn91xx", "marvell,cn9030-vd",
+		     "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* The PCI console memory must be reserved */
+		console_reserved: pci-console-nexus@3f000000 {
+			compatible = "marvell,pci-console-nexus-memory";
+			reg = <0 0x3f000000 0 0x1000000>;
+			no-map;
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC - U9 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12]	GPIO GE-IN
+	 *	[13-16]	SPI1
+	 *	[17-27]	NAND
+	 *	[28]	MSS_GPIO[5] XXX:(mode nr from a3900)
+	 *	[29-30]	SATA
+	 *	[31]	MSS_GPIO[4] XXX:(mode nr from a3900)
+	 *	[32,34]	SMI
+	 *	[33]	SDIO
+	 *	[35-36]	I2C1
+	 *	[37-38]	I2C0
+	 *	[39-43]	SDIOctrl
+	 *	[44-55]	RGMII2
+	 *	[56-62]	SDIO
+	 */
+
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   1   1   1
+		     1   1   1   1   1   1   1   1   3   9
+		     9   3   7   6   7   2   2   2   2   1
+		     1   1   1   1   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_bootcmd {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+/* CON 28 */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* U54 */
+&cp0_nand {
+	status = "disabled";
+};
+
+/* U55 */
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_comphy {
+
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* CON56 */
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+/* CON57 */
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+/* SLM-1521-V2, CON2 */
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_pcie0{
+	status = "disabled";
+};
diff --git a/arch/arm/dts/cn9130-db-dev-info.dtsi b/arch/arm/dts/cn9130-db-dev-info.dtsi
new file mode 100644
index 0000000000..f2e7c033b7
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-dev-info.dtsi
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+			freq {
+				key = "freq";
+				description = "CPU/DDR and PIDI frequencies";
+				start-bit = <0>;
+				bit-length = <4>;
+				option-cnt = <3>;
+				options = "0x0", "CPU/DDR = 0x0: 2000/1200 Mhz, PIDI = 0: 1Ghz",
+					  "0x2", "CPU/DDR = 0x6: 2200/1200 Mhz, PIDI = 0: 1Ghz",
+					  "0x4", "CPU/DDR = 0xD: 1600/1200 Mhz, PIDI = 0: 1Ghz";
+				default = <0x2>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <4>;
+				options = "0xE", "CP0_NAND PIDI BW-8bit, PS-4KB, ECC-4bit\t(supported configuration: B)",
+					  "0xF", "CP0_NAND PIDI BW-8bit, PS-4KB, ECC-8bit\t(supported configuration: B)",
+					  "0x2A", "AP_EMMC",
+					  "0x32", "CP1_SPI_1 24bits";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/cn9130-db.dtsi b/arch/arm/dts/cn9130-db.dtsi
new file mode 100644
index 0000000000..fa79d15673
--- /dev/null
+++ b/arch/arm/dts/cn9130-db.dtsi
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "cn9130.dtsi" /* include SoC device tree */
+#include "cn9130-db-dev-info.dtsi"
+
+/ {
+	model = "DB-CN-9130";
+	compatible = "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	cp0 {
+		config-space {
+			i2c@701000 {
+				/* U36 */
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+			};
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+				vmmc-supply = <&cp0_reg_sd_vcc>;
+			};
+
+			ap_reg_mmc_vccq: ap_mmc_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "ap_mmc_vccq";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 8 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp0_reg_usb3_vbus0: cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0-xhci1-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vccq";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp0_reg_sd_vcc: cp0_sd_vcc@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&expander0 14 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-always-on;
+			};
+			cp0_reg_usb3_current_lim0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_lim1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+/* on-board eMMC - U9 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	vqmmc-supply = <&ap_reg_mmc_vccq>;
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	status = "okay";
+};
+
+/*
+ * CP0
+ */
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus0>;
+	current-limiter = <&cp0_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus1>;
+	current-limiter = <&cp0_reg_usb3_current_lim1>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130.dtsi b/arch/arm/dts/cn9130.dtsi
new file mode 100644
index 0000000000..c02af096e4
--- /dev/null
+++ b/arch/arm/dts/cn9130.dtsi
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for the CN 9030 SoC, made of an AP806 Quad and
+ * one CP110.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
+#include "armada-ap807.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* This defines used to calculate the base address of each CP */
+#define CP110_BASE_OFFSET		(0xf2000000)
+#define CP110_SPACE_SIZE		(0x02000000)
+#define CP110_BASE			(CP110_BASE_OFFSET + \
+						(CP110_NUM * CP110_SPACE_SIZE))
+
+#define CP110_PCIE_MEM_SIZE(iface)	((iface == 0) ? 0x1ff00000 : 0xf00000)
+#define CP110_PCIE_BUS_MEM_CFG		(0x82000000)
+
+/* CP110-0 Settings */
+#define CP110_NAME			cp0
+#define CP110_NUM			0
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	((iface == 0) ? 0xc0000000 : \
+					 (0xe0000000 + (iface - 1) * 0x1000000))
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN 9030";
+	compatible = "marvell,armada70x0", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	aliases {
+		fuse0 = &ap_hd_efuse0;	/* banks 0-63 RW */
+		fuse1 = &ap_ld_efuse0;	/* bank 64 RO */
+		fuse2 = &ap_ld_efuse1;	/* bank 65 RW */
+		fuse3 = &cp0_ld_efuse0;	/* bank 66 RO */
+		fuse4 = &cp0_ld_efuse1;	/* bank 67 RW */
+	};
+};
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/cn9131-db-A.dts b/arch/arm/dts/cn9131-db-A.dts
new file mode 100644
index 0000000000..74a19c7dc2
--- /dev/null
+++ b/arch/arm/dts/cn9131-db-A.dts
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db-A.dts"
+#include "cn9131-db.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9131-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x2)
+	 *	Lane 1: PCIe0 (x2)
+	 *	Lane 2: unconnected
+	 *	Lane 3: USB1
+	 *	Lane 4: SFP (port 0)
+	 *	Lane 5: SATA1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* CON50 */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/cn9131-db-B.dts b/arch/arm/dts/cn9131-db-B.dts
new file mode 100644
index 0000000000..cd67ed7858
--- /dev/null
+++ b/arch/arm/dts/cn9131-db-B.dts
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db-B.dts"
+#include "cn9131-db.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board (CP NAND) setup(B)";
+	compatible = "marvell,cn9131-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x2)
+	 *	Lane 1: PCIe0 (x2)
+	 *	Lane 2: SFI (port 0)
+	 *	Lane 3: USB1
+	 *	Lane 4: SGMII (port 1)
+	 *	Lane 5: SATA1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 3310 RJ45 CON55 */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+	phy = <&sfi_phy8>; /* required by 3310 fw download */
+};
+
+/* CON50 */
+&cp1_eth1 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-4 */
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_xmdio {
+	status = "okay";
+	sfi_phy8: ethernet-phy@8 {
+		reg = <8>;
+	};
+};
diff --git a/arch/arm/dts/cn9131-db-C.dts b/arch/arm/dts/cn9131-db-C.dts
new file mode 100644
index 0000000000..7365479f4d
--- /dev/null
+++ b/arch/arm/dts/cn9131-db-C.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+#include "cn9130-db-C.dts"
+#include "cn9131-db.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board (CP NOR) setup(C)";
+	compatible = "marvell,cn9131-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x2)
+	 *	Lane 1: PCIe0 (x2)
+	 *	Lane 2: unconnected
+	 *	Lane 3: USB1
+	 *	Lane 4: SFP (port 0)
+	 *	Lane 5: SATA1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_pcie0{
+	status = "disabled";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* CON50 */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/cn9131-db.dtsi b/arch/arm/dts/cn9131-db.dtsi
new file mode 100644
index 0000000000..8dbf61ac1f
--- /dev/null
+++ b/arch/arm/dts/cn9131-db.dtsi
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#undef CP110_NAME
+#undef CP110_NUM
+#undef CP110_PCIE_MEM_SIZE
+#undef CP110_PCIEx_CPU_MEM_BASE
+#undef CP110_PCIEx_BUS_MEM_BASE
+
+/* CP110-1 Settings */
+#define CP110_NAME			cp1
+#define CP110_NUM			1
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	(0xe2000000 + (iface) * 0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board";
+	compatible = "marvell,cn9131-db";
+
+	aliases {
+		gpio3 = &cp1_gpio0;
+		gpio4 = &cp1_gpio1;
+		fuse5 = &cp1_ld_efuse0;	/* bank 68 RO */
+		fuse6 = &cp1_ld_efuse1;	/* bank 69 RW */
+	};
+
+	cp1 {
+		config-space {
+			cp1_reg_usb3_vbus0: cp1_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				pinctrl-names = "default";
+				pinctrl-0 = <&cp1_xhci0_vbus_pins>;
+				regulator-name = "cp1-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp1_gpio0 3 GPIO_ACTIVE_HIGH>;
+			};
+			cp1_reg_usb3_current_lim0: cp1_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp1_gpio0 2 GPIO_ACTIVE_HIGH>;
+			};
+			cp1_pcie_reset_pins: cp1-pcie-reset-pins {
+				marvell,pins = <0>;
+				marvell,function = <0>;
+			};
+		};
+	};
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON40 */
+&cp1_pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_pcie_reset_pins>;
+	marvell,reset-gpio = <&cp1_gpio0 0 GPIO_ACTIVE_LOW>;
+	status = "okay";
+	num-lanes = <2>;
+		/* non-prefetchable memory */
+	ranges = <0x82000000 0 0xe2000000 0 0xe2000000 0 0xf00000>;
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl",
+		     "marvell,cp115-standalone-pinctrl";
+	bank-name ="cp1-110";
+
+	/* MPP Bus:
+	 *	[0-12]	GPIO
+	 *	[13-16]	SPI1
+	 *	[17-27]	GPIO (Default)
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-34]	GPIO (Default)
+	 *	[35-36]	xSMI
+	 *	[37-38] I2C0
+	 *	[39-62]	GPIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x3  0x3  0x3  0x3  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x7  0x7  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0 >;
+
+	cp1_i2c0_pins: cp1-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp1_spi0_pins: cp1-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+	cp1_xhci0_vbus_pins: cp1-xhci0-vbus-pins {
+		marvell,pins = <3>;
+		marvell,function = <0>;
+	};
+};
+
+/* CON32 */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* U24 */
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+/* CON58 */
+&cp1_usb3_1 {
+	vbus-supply = <&cp1_reg_usb3_vbus0>;
+	current-limiter = <&cp1_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db-A.dts b/arch/arm/dts/cn9132-db-A.dts
new file mode 100644
index 0000000000..a8930d46d8
--- /dev/null
+++ b/arch/arm/dts/cn9132-db-A.dts
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9131-db-A.dts"
+#include "cn9132-db.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9132-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp2_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp2_ld_efuse1 {
+	status = "okay";
+};
+
+&cp2_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp2_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* SLM-1521-V2, CON6 */
+&cp2_pcie0 {
+	num-lanes = <2>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON8 */
+&cp2_pcie2 {
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&cp2_pinctl {
+	/* MPP Bus:
+	 *	[0-26]		GPIO
+	 *	[27]		SATA0_PRESENT_ACTIVEn
+	 *	[28]		SATA1_PRESENT_ACTIVEn
+	 *	[29-31, 33]	GPIO (Default)
+	 *	[32,34]		SMI
+	 *	[37-38]		I2C0
+	 *	[39-53]		GPIO
+	 *	[54]		SD_CRD_RSTn (out)
+	 *	[55]		SD_CRD_DT (in)
+	 *	[56-62]		SDIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x9  0x0
+		     0x0  0x0  0x8  0x0  0x8  0x0  0x0  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0xa  0xb  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe >;
+};
+
+/* SLM-1521-V2, CON4 */
+&cp2_sata0 {
+	status = "okay";
+};
+
+/* CON 2 on SLM-1683 - microSD */
+&cp2_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON11 */
+&cp2_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db-B.dts b/arch/arm/dts/cn9132-db-B.dts
new file mode 100644
index 0000000000..1575995213
--- /dev/null
+++ b/arch/arm/dts/cn9132-db-B.dts
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9131-db-B.dts"
+#include "cn9132-db.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board (CP NAND) setup(B)";
+	compatible = "marvell,cn9132-db-B", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp2_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp2_ld_efuse1 {
+	status = "okay";
+};
+
+&cp2_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp2_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* SLM-1521-V2, CON6 */
+&cp2_pcie0 {
+	num-lanes = <2>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON8 */
+&cp2_pcie2 {
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&cp2_pinctl {
+	/* MPP Bus:
+	 *	[0-26]		GPIO
+	 *	[27]		SATA0_PRESENT_ACTIVEn
+	 *	[28]		SATA1_PRESENT_ACTIVEn
+	 *	[29-31, 33]	GPIO (Default)
+	 *	[32,34]		SMI
+	 *	[37-38]		I2C0
+	 *	[39-53]		GPIO
+	 *	[54]		SD_CRD_RSTn (out)
+	 *	[55]		SD_CRD_DT (in)
+	 *	[56-62]		SDIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x9  0x0
+		     0x0  0x0  0x8  0x0  0x8  0x0  0x0  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0xa  0xb  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe >;
+};
+
+/* SLM-1521-V2, CON4 */
+&cp2_sata0 {
+	status = "okay";
+};
+
+/* CON 2 on SLM-1683 - microSD */
+&cp2_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON11 */
+&cp2_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db-C.dts b/arch/arm/dts/cn9132-db-C.dts
new file mode 100644
index 0000000000..87bf79db5c
--- /dev/null
+++ b/arch/arm/dts/cn9132-db-C.dts
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+#include "cn9131-db-C.dts"
+#include "cn9132-db.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board (CP NOR) setup(C)";
+	compatible = "marvell,cn9132-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp2_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp2_ld_efuse1 {
+	status = "okay";
+};
+
+&cp2_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp2_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* SLM-1521-V2, CON6 */
+&cp2_pcie0 {
+	num-lanes = <2>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON8 */
+&cp2_pcie2 {
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&cp2_pinctl {
+	/* MPP Bus:
+	 *	[0-26]		GPIO
+	 *	[27]		SATA0_PRESENT_ACTIVEn
+	 *	[28]		SATA1_PRESENT_ACTIVEn
+	 *	[29-31, 33]	GPIO (Default)
+	 *	[32,34]		SMI
+	 *	[37-38]		I2C0
+	 *	[39-53]		GPIO
+	 *	[54]		SD_CRD_RSTn (out)
+	 *	[55]		SD_CRD_DT (in)
+	 *	[56-62]		SDIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x9  0x0
+		     0x0  0x0  0x8  0x0  0x8  0x0  0x0  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0xa  0xb  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe >;
+};
+
+/* SLM-1521-V2, CON4 */
+&cp2_sata0 {
+	status = "okay";
+};
+
+/* CON 2 on SLM-1683 - microSD */
+&cp2_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON11 */
+&cp2_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db.dtsi b/arch/arm/dts/cn9132-db.dtsi
new file mode 100644
index 0000000000..add9f60237
--- /dev/null
+++ b/arch/arm/dts/cn9132-db.dtsi
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#undef CP110_NAME
+#undef CP110_NUM
+#undef CP110_PCIE_MEM_SIZE
+#undef CP110_PCIEx_CPU_MEM_BASE
+#undef CP110_PCIEx_BUS_MEM_BASE
+
+/* CP110-2 Settings */
+#define CP110_NAME			cp2
+#define CP110_NUM			2
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	(0xe5000000 + (iface) *  0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board";
+	compatible = "marvell,cn9132-db";
+
+	aliases {
+		gpio5 = &cp2_gpio0;
+		gpio6 = &cp2_gpio1;
+		fuse7 = &cp2_ld_efuse0;	/* bank 70 RO */
+		fuse8 = &cp2_ld_efuse1;	/* bank 71 RW */
+	};
+
+	cp2 {
+		config-space {
+			sdhci@780000 {
+				vqmmc-supply = <&cp2_reg_sd_vccq>;
+			};
+			cp2_reg_usb3_vbus0: cp2_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp2-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 2 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp2_reg_usb3_vbus1: cp2_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp2-xhci1-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 3 GPIO_ACTIVE_HIGH>;
+			};
+			cp2_reg_sd_vccq: cp2_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp2_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				/* cp2_mpp49 */
+				gpios = <&cp2_gpio1 17 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp2_reg_usb3_current_lim0: cp2_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp2_reg_usb3_current_lim1: cp2_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 1 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+&cp2_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp2_pcie0 {
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xe5000000 0 0xe5000000 0 0x1000000>;
+};
+
+&cp2_pinctl {
+	compatible = "marvell,mvebu-pinctrl",
+		     "marvell,cp115-standalone-pinctrl";
+	bank-name ="cp2-110";
+
+	cp2_i2c0_pins: cp2-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp2_sdhci_pins: cp2-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+};
+
+&cp2_usb3_0 {
+	status = "okay";
+	vbus-supply = <&cp2_reg_usb3_vbus0>;
+	current-limiter = <&cp2_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+};
+
+&cp2_usb3_1 {
+	status = "okay";
+	vbus-supply = <&cp2_reg_usb3_vbus1>;
+	current-limiter = <&cp2_reg_usb3_current_lim1>;
+	vbus-disable-delay = <500>;
+};
+
+&cp2_utmi0 {
+	status = "okay";
+};
+
+&cp2_utmi1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/thunderx-88xx.dts b/arch/arm/dts/thunderx-88xx.dts
deleted file mode 100644
index 22d8f7efb2..0000000000
--- a/arch/arm/dts/thunderx-88xx.dts
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR X11
-/*
- * Cavium Thunder DTS file - Thunder board description
- *
- * Copyright (C) 2014, Cavium Inc.
- *
- */
-
-/dts-v1/;
-
-/include/ "thunderx-88xx.dtsi"
-
-/ {
-	model = "Cavium ThunderX CN88XX board";
-	compatible = "cavium,thunder-88xx";
-
-	aliases {
-		serial0 = &uaa0;
-		serial1 = &uaa1;
-	};
-
-	chosen {
-                stdout-path = &uaa0;
-        };
-
-	memory@00000000 {
-		device_type = "memory";
-		reg = <0x0 0x00000000 0x0 0x80000000>;
-	};
-};
diff --git a/arch/arm/dts/thunderx-88xx.dtsi b/arch/arm/dts/thunderx-88xx.dtsi
deleted file mode 100644
index b8d6f7b315..0000000000
--- a/arch/arm/dts/thunderx-88xx.dtsi
+++ /dev/null
@@ -1,362 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR X11
-/*
- * Cavium Thunder DTS file - Thunder SoC description
- *
- * Copyright (C) 2014, Cavium Inc.
- *
- */
-
-/ {
-	compatible = "cavium,thunder-88xx";
-	interrupt-parent = <&gic0>;
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	psci {
-		compatible = "arm,psci-0.2";
-		method = "smc";
-	};
-
-	cpus {
-		#address-cells = <2>;
-		#size-cells = <0>;
-
-		cpu@000 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x000>;
-			enable-method = "psci";
-		};
-		cpu@001 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x001>;
-			enable-method = "psci";
-		};
-		cpu@002 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x002>;
-			enable-method = "psci";
-		};
-		cpu@003 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x003>;
-			enable-method = "psci";
-		};
-		cpu@004 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x004>;
-			enable-method = "psci";
-		};
-		cpu@005 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x005>;
-			enable-method = "psci";
-		};
-		cpu@006 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x006>;
-			enable-method = "psci";
-		};
-		cpu@007 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x007>;
-			enable-method = "psci";
-		};
-		cpu@008 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x008>;
-			enable-method = "psci";
-		};
-		cpu@009 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x009>;
-			enable-method = "psci";
-		};
-		cpu@00a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00a>;
-			enable-method = "psci";
-		};
-		cpu@00b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00b>;
-			enable-method = "psci";
-		};
-		cpu@00c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00c>;
-			enable-method = "psci";
-		};
-		cpu@00d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00d>;
-			enable-method = "psci";
-		};
-		cpu@00e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00e>;
-			enable-method = "psci";
-		};
-		cpu@00f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00f>;
-			enable-method = "psci";
-		};
-		cpu@100 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x100>;
-			enable-method = "psci";
-		};
-		cpu@101 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x101>;
-			enable-method = "psci";
-		};
-		cpu@102 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x102>;
-			enable-method = "psci";
-		};
-		cpu@103 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x103>;
-			enable-method = "psci";
-		};
-		cpu@104 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x104>;
-			enable-method = "psci";
-		};
-		cpu@105 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x105>;
-			enable-method = "psci";
-		};
-		cpu@106 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x106>;
-			enable-method = "psci";
-		};
-		cpu@107 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x107>;
-			enable-method = "psci";
-		};
-		cpu@108 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x108>;
-			enable-method = "psci";
-		};
-		cpu@109 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x109>;
-			enable-method = "psci";
-		};
-		cpu@10a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10a>;
-			enable-method = "psci";
-		};
-		cpu@10b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10b>;
-			enable-method = "psci";
-		};
-		cpu@10c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10c>;
-			enable-method = "psci";
-		};
-		cpu@10d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10d>;
-			enable-method = "psci";
-		};
-		cpu@10e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10e>;
-			enable-method = "psci";
-		};
-		cpu@10f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10f>;
-			enable-method = "psci";
-		};
-		cpu@200 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x200>;
-			enable-method = "psci";
-		};
-		cpu@201 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x201>;
-			enable-method = "psci";
-		};
-		cpu@202 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x202>;
-			enable-method = "psci";
-		};
-		cpu@203 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x203>;
-			enable-method = "psci";
-		};
-		cpu@204 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x204>;
-			enable-method = "psci";
-		};
-		cpu@205 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x205>;
-			enable-method = "psci";
-		};
-		cpu@206 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x206>;
-			enable-method = "psci";
-		};
-		cpu@207 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x207>;
-			enable-method = "psci";
-		};
-		cpu@208 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x208>;
-			enable-method = "psci";
-		};
-		cpu@209 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x209>;
-			enable-method = "psci";
-		};
-		cpu@20a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20a>;
-			enable-method = "psci";
-		};
-		cpu@20b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20b>;
-			enable-method = "psci";
-		};
-		cpu@20c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20c>;
-			enable-method = "psci";
-		};
-		cpu@20d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20d>;
-			enable-method = "psci";
-		};
-		cpu@20e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20e>;
-			enable-method = "psci";
-		};
-		cpu@20f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20f>;
-			enable-method = "psci";
-		};
-	};
-
-	timer {
-		compatible = "arm,armv8-timer";
-		interrupts = <1 13 0xff01>,
-		             <1 14 0xff01>,
-		             <1 11 0xff01>,
-		             <1 10 0xff01>;
-	};
-
-	soc {
-		compatible = "simple-bus";
-		#address-cells = <2>;
-		#size-cells = <2>;
-		ranges;
-
-		refclk50mhz: refclk50mhz {
-			compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <50000000>;
-			clock-output-names = "refclk50mhz";
-		};
-
-		gic0: interrupt-controller@8010,00000000 {
-			compatible = "arm,gic-v3";
-			#interrupt-cells = <3>;
-			interrupt-controller;
-			reg = <0x8010 0x00000000 0x0 0x010000>, /* GICD */
-			      <0x8010 0x80000000 0x0 0x600000>; /* GICR */
-			interrupts = <1 9 0xf04>;
-		};
-
-		uaa0: serial@87e0,24000000 {
-			compatible = "arm,pl011", "arm,primecell";
-			reg = <0x87e0 0x24000000 0x0 0x1000>;
-			interrupts = <1 21 4>;
-			clocks = <&refclk50mhz>;
-			clock-names = "apb_pclk";
-			uboot,skip-init;
-		};
-
-		uaa1: serial@87e0,25000000 {
-			compatible = "arm,pl011", "arm,primecell";
-			reg = <0x87e0 0x25000000 0x0 0x1000>;
-			interrupts = <1 22 4>;
-			clocks = <&refclk50mhz>;
-			clock-names = "apb_pclk";
-			uboot,skip-init;
-		};
-	};
-};
diff --git a/arch/arm/include/asm/arch-armada3700/efuse.h b/arch/arm/include/asm/arch-armada3700/efuse.h
new file mode 100644
index 0000000000..d509966593
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/efuse.h
@@ -0,0 +1,137 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2017 Marvell International Ltd.
+* ***************************************************************************
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+* Redistributions of source code must retain the above copyright notice, this
+* list of conditions and the following disclaimer.
+*
+* Redistributions in binary form must reproduce the above copyright notice,
+* this list of conditions and the following disclaimer in the documentation
+* and/or other materials provided with the distribution.
+*
+* Neither the name of Marvell nor the names of its contributors may be used
+* to endorse or promote products derived from this software without specific
+* prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*
+***************************************************************************
+*/
+#ifndef _A3700_EFUSE_H_
+#define _A3700_EFUSE_H_
+
+#define MVEBU_EFUSE_256B_ASCII_LEN	(64)
+	/* 256 bit key ASCII representation length */
+#define MVEBU_EFUSE_512B_ASCII_LEN	(128)
+	/* 256 bit key ASCII representation length */
+#define MVEBU_EFUSE_MAX_STRLEN		(MVEBU_EFUSE_512B_ASCII_LEN + 1)
+	/* MAX key length in ASCII + \0 */
+
+enum efuse_id {
+	EFUSE_ID_BOOT_DEVICE		= 0,
+	/* Platform boot device in trusted boot mode */
+	EFUSE_ID_KAK_DIGEST		= 1,
+	/* KAK key digest (OEM key hash) */
+	EFUSE_ID_CSK_INDEX		= 2,
+	/* CSK key valid index (0-15) */
+	EFUSE_ID_AES_KEY		= 3,
+	/* Symmetric key / RKEK (write only) */
+	EFUSE_ID_ENCRYPTION_EN		= 4,
+	/* Enable boot image encryption */
+	EFUSE_ID_JTAG_DIGECT		= 5,
+	/* JTAG key digest */
+	EFUSE_ID_SEC_JTAG_DIS		= 6,
+	/* Secure CPU JTAG disable */
+	EFUSE_ID_SEC_JTAG_PERM_DIS	= 7,
+	/* Secure CPU permanent JTAG disable */
+	EFUSE_ID_AP_JTAG_DIS		= 8,
+	/* Application CPU JTAG disable */
+	EFUSE_ID_AP_JTAG_PERM_DIS	= 9,
+	/* Application CPU permanent JTAG disable */
+	EFUSE_ID_SPI_NAND_CFG		= 10,
+	/* SPI NAND configuration */
+	EFUSE_ID_PIN			= 11,
+	/* PIN */
+	EFUSE_ID_TOKEN			= 12,
+	/* Token */
+	EFUSE_ID_SPI_CS			= 13,
+	/* SPI chip select (0-4) */
+	EFUSE_ID_EMMC_CLOCK		= 14,
+	/* EMMC boot clock */
+	EFUSE_ID_OPERATION_MODE		= 15,
+	/* Operation mode trusted/untrusted/etc. */
+	EFUSE_ID_UART_DIS		= 16,
+	/* UART boot disable */
+	EFUSE_ID_UART_PERM_DIS		= 17,
+	/* UART boot permanent disable */
+	EFUSE_ID_ESC_SEQ_DIS		= 18,
+	/* UART escape sequence disable */
+	EFUSE_ID_GPIO_TOGGLE_DIS	= 19,
+	/* GPIO toggle disable */
+	EFUSE_ID_LONG_KEY_EN		= 20,
+	/* Long key enable */
+	EFUSE_ID_MAX
+};
+
+struct efuse_info {
+	char *name;
+	char *note;
+};
+
+#define MVEBU_EFUSE_INFO	{ \
+		{"BOOT_DEVICE", "SPINOR, SPINAND, EMMCNORM, EMMCALT, SATA, UART, AUTO"}, \
+		{"KAK_DIGEST", "SHA-256 KAK key digest in HEX format"}, \
+		{"CSK_INDEX", "CSK index in range 0 to 15 in DEC format"}, \
+		{"AES256_KEY", "AES-256 symmetric encryption key in HEX format"}, \
+		{"ENCRYPTION", "Enabe/Disable image encryption (2 bits, binary value):\n" \
+				"\t\t\t00 - Encryption is disabled\n" \
+				"\t\t\t01 - Encryption is enabled for recovery type images for eMMC only\n" \
+				"\t\t\t10 - Encryption is enabled for primary type images\n" \
+				"\t\t\t11 - Encryption is enabled for primary and recovery type images"}, \
+		{"JTAG_DIGEST", "JTAG KAK key digest in HEX format"}, \
+		{"SEC_JTAG_DIS", "Enabe/Disable secure JTAG - 0 or 1"}, \
+		{"SEC_JTAG_PR_DIS", "Enabe/Disable secure JTAG permanently - 0 or 1"}, \
+		{"AP_JTAG_DIS", "Enabe/Disable application CPU JTAG - 0 or 1"}, \
+		{"AP_JTAG_PR_DIS", "Enabe/Disable application CPU JTAG permanently - 0 or 1"}, \
+		{"SPI_NAND_CFG", "SPI NAND parameters in format PZ.BP.SO.SN, where (all decimal numbers):\n" \
+				"\t\t\tPZ - Page Size (for instance 2048)\n" \
+				"\t\t\tBP - Number of Pages per Block (for instance 64)\n" \
+				"\t\t\tSO - Spare area byte Offset\n" \
+				"\t\t\tSN - Spare area page Number"}, \
+		{"PIN_CODE", "64-bit pin code in HEX format"}, \
+		{"TOKEN", "\t64-bit token in HEX format"}, \
+		{"SPI_CS", "\tSPI chip select 0 to 3"}, \
+		{"EMMC_CLOCK", "EMMC clock - 0 - 12.5MHz, 1 - 50MHz"}, \
+		{"OPER_MODE", "Operation mode in range of 0 to 3, where:\n" \
+				"\t\t\t0 - Non-trusted BootROM, unprogrammed\n" \
+				"\t\t\t1 - Non-trusted boot, no security check on the boot device content\n" \
+				"\t\t\t2 - Trusted boot, security check is performed on the boot device content\n" \
+				"\t\t\t3 - Tamper state; BootROM does not boot device"}, \
+		{"UART_DIS", "Enabe/Disable UART port - 0 or 1"}, \
+		{"UART_PR_DIS", "Enabe/Disable UART port permanently - 0 or 1"}, \
+		{"ESC_SEQ_DIS", "Enabe/Disable Escape sequence in trusted boot mode - 0 or 1"}, \
+		{"GPIO_TOGGLE_DIS", "Enabe/Disable GPIO pin 11 and 12 toogle - 0 or 1"}, \
+		{"LONG_KEY_EN", "Enabe/Disable long key (512b) support  - 0 or 1"}, \
+		{"INVALID", "Invalid ID"} \
+	}
+
+int efuse_id_valid(enum efuse_id fid);
+int efuse_write(enum efuse_id fid, const char *value);
+int efuse_read(enum efuse_id fid, char *value);
+void efuse_raw_dump(void);
+
+#endif /* _A3700_EFUSE_H_ */
diff --git a/arch/arm/include/asm/arch-armada3700/mbox.h b/arch/arm/include/asm/arch-armada3700/mbox.h
new file mode 100644
index 0000000000..29ac6424aa
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/mbox.h
@@ -0,0 +1,91 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2017 Marvell International Ltd.
+ * ***************************************************************************
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Marvell nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ***************************************************************************
+ */
+
+#ifndef _A3700_MBOX_H_
+#define _A3700_MBOX_H_
+
+#define MBOX_MAX_ARGS			(16)
+#define MBOX_CMD_TIMEOUT		(100000)
+#define A3700_MBOX_BASE			(MVEBU_REGISTER(0xb0000))
+
+/* Mailbox command, arguments and status */
+#define MBOX_SEND_ARG_OFFS(n)		(A3700_MBOX_BASE + (n) * 4)
+#define MBOX_SEND_CMD_OFFS		(A3700_MBOX_BASE + 0x40)
+#define MBOX_RECEIVE_STAT_OFFS		(A3700_MBOX_BASE + 0x80)
+#define MBOX_RECEIVE_ARG_OFFS(n)	(A3700_MBOX_BASE + 0x84 + (n) * 4)
+
+/* Host intterrupt reset - to complete received command/status processing */
+#define MBOX_HOST_INT_RESET		(A3700_MBOX_BASE + 0xC8)
+#define MBOX_SEC_CPU_CMD_COMPLETE	BIT(0)
+
+/*
+ * Host interrupt status - to poll for new command/status
+ * received from secure CPU
+ */
+#define MBOX_SEC_CPU_INT_STAT_REG	(SOC_REGS_PHY_BASE + 0x17814)
+#define MBOX_SEC_CPU_CMD_SET		BIT(31)
+
+#define MBOX_COMMAND(sz, op)		((sz) | ((op) << 8))
+#define MBOX_OP_SIZE(cmd)		((cmd) & 0xF)
+#define MBOX_OPERATION(cmd)		(((cmd) >> 8) & 0xF)
+
+enum mbox_opsize {
+	MB_OPSZ_BIT	= 1,	/* single bit */
+	MB_OPSZ_BYTE	= 2,	/* single byte */
+	MB_OPSZ_WORD	= 3,	/* 4 bytes - half row */
+	MB_OPSZ_DWORD	= 4,	/* 8 bytes - one row */
+	MB_OPSZ_256B	= 5,	/* 32 bytes - 4 rows */
+	MB_OPSZ_MAX
+};
+
+enum mbox_op {
+	MB_OP_READ	= 1,
+	MB_OP_WRITE	= 2,
+	MB_OP_MAX
+};
+
+enum mbox_status {
+	MB_STAT_SUCCESS			= 0,
+	MB_STAT_HW_ERROR		= 1,
+	MB_STAT_TIMEOUT			= 2,
+	MB_STAT_BAD_ARGUMENT		= 3,
+
+	MB_STAT_MAX
+};
+
+int mbox_send(enum mbox_opsize opsz, enum mbox_op op, uint32_t row,
+	      uint32_t offs, uint32_t *args);
+int mbox_receive(enum mbox_status *stat, uint32_t *args, uint32_t timeout_us);
+
+#endif /* _A3700_MBOX_H_ */
diff --git a/arch/arm/include/asm/arch-armada8k/cache_llc.h b/arch/arm/include/asm/arch-armada8k/cache_llc.h
index 8cb114496a..1ef61ca1f6 100644
--- a/arch/arm/include/asm/arch-armada8k/cache_llc.h
+++ b/arch/arm/include/asm/arch-armada8k/cache_llc.h
@@ -17,4 +17,9 @@
 #define LLC_WAY_MASK			0xffffffff
 #define LLC_CACHE_SYNC_MASK		0x1
 
+#define MVEBU_LLC_BASE			(MVEBU_REGISTER(LLC_BASE_ADDR))
+#define LLC_CTRL_REG_OFFSET		0x100
+#define LLC_EN				0x1
+#define LLC_EXCL_EN			0x100
+
 #endif	/* _CACHE_LLC_H_ */
diff --git a/arch/arm/include/asm/arch-mvebu/thermal.h b/arch/arm/include/asm/arch-mvebu/thermal.h
new file mode 100644
index 0000000000..a16b22955d
--- /dev/null
+++ b/arch/arm/include/asm/arch-mvebu/thermal.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#ifndef _MVEBU_THERMAL_H_
+#define _MVEBU_THERMAL_H_
+
+#include <dt-bindings/comphy/comphy_data.h>
+#include <fdtdec.h>
+
+struct thermal_unit_config {
+	/* thermal temperature parameters */
+	s32 tsen_offset;
+	s32 tsen_gain;
+	s32 tsen_divisor;
+	/* thermal data */
+	s32 tsen_ready;
+	void __iomem *regs_base;
+	/* thermal functionality */
+	u32 (*ptr_thermal_sensor_probe)(struct thermal_unit_config *cfg);
+	s32 (*ptr_thermal_sensor_read)(struct thermal_unit_config *cfg,
+				       int *temp);
+	u32 fw_smc_support;
+};
+
+/* Thermal sensors APIs */
+s32 mvebu_thermal_sensor_read(struct thermal_unit_config *thermal_config,
+			      int *temp);
+u32 mvebu_thermal_sensor_probe(struct thermal_unit_config *thermal_config);
+
+/* External Thermal sensors APIs */
+s32 mvebu_thermal_ext_sensor_read(struct thermal_unit_config *thermal_config,
+				  int *temp);
+u32 mvebu_thermal_ext_sensor_probe(struct thermal_unit_config *thermal_config);
+
+#endif /* _THERMAL_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/board.h b/arch/arm/include/asm/arch-octeontx/board.h
new file mode 100644
index 0000000000..139e56e423
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/board.h
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+#include <asm/arch/soc.h>
+
+#define MAX_LMAC_PER_BGX 4
+#define LMAC_CNT MAX_LMAC_PER_BGX
+
+#if defined(CONFIG_TARGET_OCTEONTX_81XX)
+
+/** Maximum number of BGX interfaces per CPU node */
+#define MAX_BGX_PER_NODE	3
+#define OCTEONTX_XCV	/* RGMII Interface */
+
+#elif defined(CONFIG_TARGET_OCTEONTX_83XX)
+
+/** Maximum number of BGX interfaces per CPU node */
+#define MAX_BGX_PER_NODE	4
+
+#endif
+
+/** Reg offsets */
+#define RST_BOOT	0x87E006001600ULL
+
+/** Structure definitions */
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register This register is not accessible through ROM scripts;
+ * see SCR_WRITE32_S[ADDR].
+ */
+union rst_boot {
+	u64 u;
+	struct rst_boot_s {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_32                    : 31;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 reserved_61_62                   : 2;
+		u64 chipkill                         : 1;
+	} s;
+	struct rst_boot_cn81xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 reserved_26_29                   : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn81xx;
+	struct rst_boot_cn83xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 lboot                            : 10;
+		u64 lboot_ext23                      : 6;
+		u64 lboot_ext45                      : 6;
+		u64 lboot_jtg                        : 1;
+		u64 lboot_ckill                      : 1;
+		u64 lboot_pf_flr                     : 4;
+		u64 lboot_oci                        : 3;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_54                   : 8;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 ejtagdis                         : 1;
+		u64 jtcsrdis                         : 1;
+		u64 chipkill                         : 1;
+	} cn83xx;
+};
+
+/** Function definitions */
+void mem_map_fill(void);
+int octeontx_board_has_pmp(void);
+const char *fdt_get_board_model(void);
+const char *fdt_get_board_serial(void);
+const char *fdt_get_board_revision(void);
+void fdt_parse_phy_info(void);
+void fdt_board_get_ethaddr(int bgx, int lmac, unsigned char *eth);
+#ifdef ALLOW_USER_MAC_ADDR
+void fdt_board_update_macaddr(int bgx_idx, int lmacid, char *mac);
+#endif
+void bgx_set_board_info(int bgx_id, int *mdio_bus, int *phy_addr,
+			bool *autoneg_dis, bool *lmac_reg, bool *lmac_enable);
+#endif /* __BOARD_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/clock.h b/arch/arm/include/asm/arch-octeontx/clock.h
new file mode 100644
index 0000000000..7bf600a1f2
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/clock.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __CLOCK_H__
+#define __CLOCK_H__
+
+/** System PLL reference clock */
+#define PLL_REF_CLK                     50000000        /* 50 MHz */
+#define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void);
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void);
+
+#endif /* __CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
new file mode 100644
index 0000000000..4dd8958d2f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
@@ -0,0 +1,1199 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_MIO_EMM_H__
+#define __CSRS_MIO_EMM_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * MIO_EMM.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union mio_emm_access_wdog {
+	u64 u;
+	struct mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union mio_emm_buf_dat {
+	u64 u;
+	struct mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union mio_emm_buf_idx {
+	u64 u;
+	struct mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union mio_emm_calb {
+	u64 u;
+	struct mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct mio_emm_calb_s cn; */
+};
+
+static inline u64 MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union mio_emm_cfg {
+	u64 u;
+	struct mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union mio_emm_cmd {
+	u64 u;
+	struct mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union mio_emm_comp {
+	u64 u;
+	struct mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct mio_emm_comp_s cn; */
+};
+
+static inline u64 MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union mio_emm_debug {
+	u64 u;
+	struct mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 emmc_clk_disable                 : 1;
+		u64 rdsync_rst                       : 1;
+		u64 reserved_22_63                   : 42;
+	} s;
+	struct mio_emm_debug_cn96xxp1 {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} cn96xxp1;
+	/* struct mio_emm_debug_s cn96xxp3; */
+	/* struct mio_emm_debug_s cn98xx; */
+	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
+	/* struct mio_emm_debug_s loki; */
+};
+
+static inline u64 MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union mio_emm_dma {
+	u64 u;
+	struct mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union mio_emm_dma_adr {
+	u64 u;
+	struct mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union mio_emm_dma_arg {
+	u64 u;
+	struct mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union mio_emm_dma_cfg {
+	u64 u;
+	struct mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union mio_emm_dma_fifo_adr {
+	u64 u;
+	struct mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_dma_fifo_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union mio_emm_dma_int {
+	u64 u;
+	struct mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_dma_int_w1s {
+	u64 u;
+	struct mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union mio_emm_int {
+	u64 u;
+	struct mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union mio_emm_int_ena_w1c {
+	u64 u;
+	struct mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union mio_emm_int_ena_w1s {
+	u64 u;
+	struct mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_int_w1s {
+	u64 u;
+	struct mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union mio_emm_io_ctl {
+	u64 u;
+	struct mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union mio_emm_modex {
+	u64 u;
+	struct mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	struct mio_emm_modex_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} cn96xxp1;
+	/* struct mio_emm_modex_s cn96xxp3; */
+	/* struct mio_emm_modex_s cn98xx; */
+	/* struct mio_emm_modex_s cnf95xx; */
+	/* struct mio_emm_modex_s loki; */
+};
+
+static inline u64 MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_pbax {
+	u64 u;
+	struct mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_addr {
+	u64 u;
+	struct mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union mio_emm_rca {
+	u64 u;
+	struct mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct mio_emm_rca_s cn; */
+};
+
+static inline u64 MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union mio_emm_rsp_hi {
+	u64 u;
+	struct mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union mio_emm_rsp_lo {
+	u64 u;
+	struct mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union mio_emm_rsp_sts {
+	u64 u;
+	struct mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union mio_emm_sample {
+	u64 u;
+	struct mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_sample_s cn; */
+};
+
+static inline u64 MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union mio_emm_sts_mask {
+	u64 u;
+	struct mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union mio_emm_switch {
+	u64 u;
+	struct mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	struct mio_emm_switch_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn96xxp1;
+	/* struct mio_emm_switch_s cn96xxp3; */
+	/* struct mio_emm_switch_s cn98xx; */
+	/* struct mio_emm_switch_s cnf95xx; */
+	/* struct mio_emm_switch_s loki; */
+};
+
+static inline u64 MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union mio_emm_tap {
+	u64 u;
+	struct mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct mio_emm_tap_s cn; */
+};
+
+static inline u64 MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union mio_emm_timing {
+	u64 u;
+	struct mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct mio_emm_timing_s cn; */
+};
+
+static inline u64 MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union mio_emm_wdog {
+	u64 u;
+	struct mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h b/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
new file mode 100644
index 0000000000..575f6dce82
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
@@ -0,0 +1,428 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_XCV_H__
+#define __CSRS_XCV_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * XCV.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration xcv_bar_e
+ *
+ * XCV Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define XCV_BAR_E_XCVX_PF_BAR0(a) (0x87e0db000000ll + 0ll * (a))
+#define XCV_BAR_E_XCVX_PF_BAR0_SIZE 0x100000ull
+#define XCV_BAR_E_XCVX_PF_BAR4(a) (0x87e0dbf00000ll + 0ll * (a))
+#define XCV_BAR_E_XCVX_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration xcv_int_vec_e
+ *
+ * XCV MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define XCV_INT_VEC_E_INT (0)
+
+/**
+ * Register (RSL) xcv#_batch_crd_ret
+ *
+ * XCV Batch Credit Return Register
+ */
+union xcvx_batch_crd_ret {
+	u64 u;
+	struct xcvx_batch_crd_ret_s {
+		u64 crd_ret                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct xcvx_batch_crd_ret_s cn; */
+};
+
+static inline u64 XCVX_BATCH_CRD_RET(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_BATCH_CRD_RET(u64 a)
+{
+	return 0x100 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_comp_ctl
+ *
+ * XCV Compensation Controller Register This register controls
+ * programmable compensation.
+ */
+union xcvx_comp_ctl {
+	u64 u;
+	struct xcvx_comp_ctl_s {
+		u64 nctl_sat                         : 1;
+		u64 reserved_1_26                    : 26;
+		u64 nctl_lock                        : 1;
+		u64 reserved_28                      : 1;
+		u64 pctl_sat                         : 1;
+		u64 pctl_lock                        : 1;
+		u64 reserved_31                      : 1;
+		u64 drv_nctl                         : 5;
+		u64 reserved_37_39                   : 3;
+		u64 drv_pctl                         : 5;
+		u64 reserved_45_47                   : 3;
+		u64 cmp_nctl                         : 5;
+		u64 reserved_53_55                   : 3;
+		u64 cmp_pctl                         : 5;
+		u64 reserved_61_62                   : 2;
+		u64 drv_byp                          : 1;
+	} s;
+	/* struct xcvx_comp_ctl_s cn; */
+};
+
+static inline u64 XCVX_COMP_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_COMP_CTL(u64 a)
+{
+	return 0x20 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_ctl
+ *
+ * XCV Control Register This register contains the status control bits.
+ */
+union xcvx_ctl {
+	u64 u;
+	struct xcvx_ctl_s {
+		u64 speed                            : 2;
+		u64 lpbk_int                         : 1;
+		u64 lpbk_ext                         : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct xcvx_ctl_s cn; */
+};
+
+static inline u64 XCVX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_CTL(u64 a)
+{
+	return 0x30 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_dll_ctl
+ *
+ * XCV DLL Controller Register The RGMII timing specification requires
+ * that devices transmit clock and data synchronously. The specification
+ * requires external sources (namely the PC board trace routes) to
+ * introduce the appropriate 1.5 to 2.0 ns of delay.  To eliminate the
+ * need for the PC board delays, the RGMII interface has optional on-
+ * board DLLs for both transmit and receive. For correct operation, at
+ * most one of the transmitter, board, or receiver involved in an RGMII
+ * link should introduce delay. By default/reset, the RGMII receivers
+ * delay the received clock, and the RGMII transmitters do not delay the
+ * transmitted clock. Whether this default works as-is with a given link
+ * partner depends on the behavior of the link partner and the PC board.
+ * These are the possible modes of RGMII receive operation:  *
+ * XCV()_DLL_CTL[CLKRX_BYP] = 0 (reset value) - The RGMII receive
+ * interface introduces clock delay using its internal DLL. This mode is
+ * appropriate if neither the remote transmitter nor the PC board delays
+ * the clock.  * XCV()_DLL_CTL[CLKRX_BYP] = 1, [CLKRX_SET] = 0x0 - The
+ * RGMII receive interface introduces no clock delay. This mode is
+ * appropriate if either the remote transmitter or the PC board delays
+ * the clock.  These are the possible modes of RGMII transmit operation:
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 1, [CLKTX_SET] = 0x0 (reset value) - The
+ * RGMII transmit interface introduces no clock delay. This mode is
+ * appropriate is either the remote receiver or the PC board delays the
+ * clock.  * XCV()_DLL_CTL[CLKTX_BYP] = 0 - The RGMII transmit interface
+ * introduces clock delay using its internal DLL. This mode is
+ * appropriate if neither the remote receiver nor the PC board delays the
+ * clock.
+ */
+union xcvx_dll_ctl {
+	u64 u;
+	struct xcvx_dll_ctl_s {
+		u64 refclk_sel                       : 2;
+		u64 reserved_2_7                     : 6;
+		u64 clktx_set                        : 7;
+		u64 clktx_byp                        : 1;
+		u64 clkrx_set                        : 7;
+		u64 clkrx_byp                        : 1;
+		u64 clk_set                          : 7;
+		u64 lock                             : 1;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct xcvx_dll_ctl_s cn; */
+};
+
+static inline u64 XCVX_DLL_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_DLL_CTL(u64 a)
+{
+	return 0x10 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_eco
+ *
+ * INTERNAL: XCV ECO Register
+ */
+union xcvx_eco {
+	u64 u;
+	struct xcvx_eco_s {
+		u64 eco_rw                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct xcvx_eco_s cn; */
+};
+
+static inline u64 XCVX_ECO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_ECO(u64 a)
+{
+	return 0x200 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_inbnd_status
+ *
+ * XCV Inband Status Register This register contains RGMII inband status.
+ */
+union xcvx_inbnd_status {
+	u64 u;
+	struct xcvx_inbnd_status_s {
+		u64 link                             : 1;
+		u64 speed                            : 2;
+		u64 duplex                           : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct xcvx_inbnd_status_s cn; */
+};
+
+static inline u64 XCVX_INBND_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INBND_STATUS(u64 a)
+{
+	return 0x80 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int
+ *
+ * XCV Interrupt Register This register flags error for TX FIFO overflow,
+ * TX FIFO underflow and incomplete byte for 10/100 Mode. It also flags
+ * status change for link duplex, link speed and link up/down.
+ */
+union xcvx_int {
+	u64 u;
+	struct xcvx_int_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_s cn; */
+};
+
+static inline u64 XCVX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT(u64 a)
+{
+	return 0x40 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_ena_w1c
+ *
+ * Loopback Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union xcvx_int_ena_w1c {
+	u64 u;
+	struct xcvx_int_ena_w1c_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_ena_w1c_s cn; */
+};
+
+static inline u64 XCVX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_ENA_W1C(u64 a)
+{
+	return 0x50 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_ena_w1s
+ *
+ * Loopback Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union xcvx_int_ena_w1s {
+	u64 u;
+	struct xcvx_int_ena_w1s_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_ena_w1s_s cn; */
+};
+
+static inline u64 XCVX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_ENA_W1S(u64 a)
+{
+	return 0x58 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_w1s
+ *
+ * Loopback Error Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union xcvx_int_w1s {
+	u64 u;
+	struct xcvx_int_w1s_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_w1s_s cn; */
+};
+
+static inline u64 XCVX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_W1S(u64 a)
+{
+	return 0x48 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_msix_pba#
+ *
+ * XCV MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_pbax {
+	u64 u;
+	struct xcvx_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct xcvx_msix_pbax_s cn; */
+};
+
+static inline u64 XCVX_MSIX_PBAX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_PBAX(u64 a, u64 b)
+{
+	return 0xf0000 + 0 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) xcv#_msix_vec#_addr
+ *
+ * XCV MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_vecx_addr {
+	u64 u;
+	struct xcvx_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} s;
+	/* struct xcvx_msix_vecx_addr_s cn; */
+};
+
+static inline u64 XCVX_MSIX_VECX_ADDR(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_VECX_ADDR(u64 a, u64 b)
+{
+	return 0 + 0 * a + 0x10 * b;
+}
+
+/**
+ * Register (RSL) xcv#_msix_vec#_ctl
+ *
+ * XCV MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_vecx_ctl {
+	u64 u;
+	struct xcvx_msix_vecx_ctl_s {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct xcvx_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 XCVX_MSIX_VECX_CTL(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_VECX_CTL(u64 a, u64 b)
+{
+	return 8 + 0 * a + 0x10 * b;
+}
+
+/**
+ * Register (RSL) xcv#_reset
+ *
+ * XCV Reset Registers This register controls reset.
+ */
+union xcvx_reset {
+	u64 u;
+	struct xcvx_reset_s {
+		u64 rx_dat_rst_n                     : 1;
+		u64 rx_pkt_rst_n                     : 1;
+		u64 tx_dat_rst_n                     : 1;
+		u64 tx_pkt_rst_n                     : 1;
+		u64 reserved_4_6                     : 3;
+		u64 comp                             : 1;
+		u64 reserved_8_10                    : 3;
+		u64 dllrst                           : 1;
+		u64 reserved_12_14                   : 3;
+		u64 clkrst                           : 1;
+		u64 reserved_16_62                   : 47;
+		u64 enable                           : 1;
+	} s;
+	/* struct xcvx_reset_s cn; */
+};
+
+static inline u64 XCVX_RESET(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_RESET(u64 a)
+{
+	return 0 + 0 * a;
+}
+
+#endif /* __CSRS_XCV_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/gpio.h b/arch/arm/include/asm/arch-octeontx/gpio.h
new file mode 100644
index 0000000000..3943ffd952
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/gpio.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
diff --git a/arch/arm/include/asm/arch-octeontx/lock.h b/arch/arm/include/asm/arch-octeontx/lock.h
new file mode 100644
index 0000000000..65fab6865f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/lock.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ */
+
+#ifndef __OCTEONTX2_LOCK_H__
+#define __OCTEONTX2_LOCK_H__
+
+/**
+ * U-Boot doesn't implement spinlocks but we need them here since
+ * we could be sharing with other processes (i.e. ATF)
+ *
+ * This is copied from the Linux kernel arm64 implementation.
+ */
+typedef struct octeontx_spinlock {
+	u16 next;
+	u16 owner;
+} __aligned(4) octeontx_spinlock_t;
+
+/**
+ * Atomic compare and exchange, derived from atomic_ll_sc.h in Linux
+ *
+ * @param	ptr	pointer to 128 bits to compare and exchange
+ * @param	old_hi	expected old value first 64 bits
+ * @param	old_lo	expected old value second 64 bits
+ * @param	new_hi	new first 64-bit value to set
+ * @param	new_lo	new second 64-bit value to set
+ * @param	last_hi	pointer to previous first 64-bit value
+ * @param	last_lo	pointer previous second 64-bit value
+ *
+ * @return	true if successful, false if the old values mismatched
+ *
+ * last_hi and last_lo may be NULL.
+ */
+static inline bool octeontx_cmpxchg_atomic128(volatile void *ptr,
+					      u64 old_hi, u64 old_lo,
+					      u64 new_hi, u64 new_lo,
+					      u64 *last_hi, u64 *last_lo)
+{
+	u64 tmp_hi, tmp_lo, oldval_hi, oldval_lo;
+	u32 tmp;
+
+	asm volatile (
+		"	prfm	pstl1strm, %[v]				\n"
+		"1:	ldaxp	%[oldval_lo], %[oldval_hi], %[v]	\n"
+		"	eor	%[tmp_lo], %[oldval_lo], %[old_lo]	\n"
+		"	eor	%[tmp_hi], %[oldval_hi], %[old_hi]	\n"
+		"	cbnz	%[tmp_lo], 2f				\n"
+		"	cbnz	%[tmp_hi], 2f				\n"
+		"	stxp	%w[tmp],  %[new_hi], %[new_lo], %[v]	\n"
+		"	cbnz	%w[tmp], 1b				\n"
+		"2:							\n"
+		: [tmp] "=&r" (tmp),
+		  [oldval_lo] "=&r" (oldval_lo),
+		  [oldval_hi] "=&r" (oldval_hi),
+		  [v] "+Q" (*(u64 *)ptr),
+		  [tmp_lo] "=&r" (tmp_lo), [tmp_hi] "=&r" (tmp_hi)
+		: [old_lo] "Lr" (old_lo), [old_hi] "Lr" (old_hi),
+		  [new_lo] "r" (new_lo), [new_hi] "r" (new_hi)
+		: "memory");
+	if (last_hi)
+		*last_hi = oldval_hi;
+	if (last_lo)
+		*last_lo = oldval_lo;
+	return !(tmp_hi | tmp_lo);
+}
+
+static inline void octeontx_init_spin_lock(octeontx_spinlock_t *lock)
+{
+	*(u32 *)lock = 0;
+	__iowmb();
+}
+
+/**
+ * Acquires a spinlock
+ *
+ * @param	lock	pointer to lock
+ *
+ * This code is copied from the Linux aarch64 spinlock.h file
+ * and is compatible with it.
+ */
+static inline void octeontx_spin_lock(octeontx_spinlock_t *lock)
+{
+	unsigned int tmp;
+	octeontx_spinlock_t lockval, newval;
+
+	asm volatile (
+	/* Atomically increment the next ticket. */
+	/* LL/SC */
+"	prfm	pstl1strm, %3		\n"
+"1:	ldaxr	%w0, %3			\n"
+"	add	%w1, %w0, %w5		\n"
+"	stxr	%w2, %w1, %3		\n"
+"	cbnz	%w2, 1b			\n"
+
+	/* Did we get the lock? */
+"	eor	%w1, %w0, %w0, ror #16	\n"
+"	cbz	%w1, 3f			\n"
+	/*
+	 * No: spin on the owner. Send a local event to avoid missing an
+	 * unlock before the exclusive load.
+	 */
+"	sevl				\n"
+"2:	wfe				\n"
+"	ldaxrh	%w2, %4			\n"
+"	eor	%w1, %w2, %w0, lsr #16	\n"
+"	cbnz	%w1, 2b			\n"
+	/* We got the lock. Critical section starts here. */
+"3:"
+	: "=&r" (lockval), "=&r" (newval), "=&r" (tmp), "+Q" (*lock)
+	: "Q" (lock->owner), "I" (1 << 16)
+	: "memory");
+}
+
+/**
+ * Releases a spinlock
+ *
+ * @param	lock	pointer to lock
+ *
+ * This code is copied from the Linux aarch64 spinlock.h file.
+ */
+static inline void octeontx_spin_unlock(octeontx_spinlock_t *lock)
+{
+	unsigned long tmp;
+
+	asm volatile (
+		"	ldrh	%w1, %0		\n"
+		"	add	%w1, %w1, #1	\n"
+		"	stlrh	%w1, %0		\n"
+		"	nop			\n"
+		: "=Q" (lock->owner), "=&r" (tmp)
+		:
+		: "memory"
+
+	);
+}
+
+#endif /* __OCTEONTX2_LOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/smc.h b/arch/arm/include/asm/arch-octeontx/smc.h
new file mode 100644
index 0000000000..beff4d158f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/smc.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SMC_H__
+#define __SMC_H__
+
+/* OcteonTX Service Calls version numbers */
+#define OCTEONTX_VERSION_MAJOR	0x1
+#define OCTEONTX_VERSION_MINOR	0x0
+
+/* x1 - node number */
+#define OCTEONTX_DRAM_SIZE	0xc2000301
+
+ssize_t smc_dram_size(unsigned int node);
+
+#endif /* __SMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/soc.h b/arch/arm/include/asm/arch-octeontx/soc.h
new file mode 100644
index 0000000000..6d780929ec
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/soc.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SOC_H__
+#define __SOC_H__
+
+/* Product PARTNUM */
+#define CN81XX	0xA2
+#define CN83XX	0xA3
+
+/* Register defines */
+#define MIO_FUS_DAT2	0x87E003001410ULL
+
+#define otx_is_altpkg()	read_alt_pkg()
+#define otx_is_soc(soc)	(read_partnum() == (soc))
+#define otx_is_board(model) (!strcmp(read_board_name(), model))
+#define otx_is_platform(platform) (read_platform() == (platform))
+
+typedef enum {
+	PLATFORM_HW = 0,
+	PLATFORM_EMULATOR = 1,
+	PLATFORM_ASIM = 3,
+} platform_t;
+
+/**
+ * Register (RSL) mio_fus_dat2
+ *
+ * MIO Fuse Data Register 2
+ */
+union mio_fus_dat2 {
+	u64 u;
+	struct mio_fus_dat2_s {
+		u64 reserved_0                       : 1;
+		u64 ddf_dis                          : 1;
+		u64 bgx2_dis                         : 1;
+		u64 bgx3_dis                         : 1;
+		u64 tim_dis                          : 1;
+		u64 lmc_half                         : 1;
+		u64 pem_dis                          : 3;
+		u64 sata_dis                         : 4;
+		u64 bgx_dis                          : 2;
+		u64 ocx_dis                          : 1;
+		u64 chip_id                          : 8;
+		u64 reserved_24                      : 1;
+		u64 trustzone_en                     : 1;
+		u64 nocrypto                         : 1;
+		u64 nomul                            : 1;
+		u64 nodfa_cp2                        : 1;
+		u64 reserved_29                      : 1;
+		u64 lmc_mode32                       : 1;
+		u64 reserved_31                      : 1;
+		u64 raid_en                          : 1;
+		u64 fus318                           : 1;
+		u64 dorm_crypto                      : 1;
+		u64 power_limit                      : 2;
+		u64 rom_info                         : 10;
+		u64 fus118                           : 1;
+		u64 gbl_pwr_throttle                 : 8;
+		u64 run_platform                     : 3;
+		u64 reserved_59_63                   : 5;
+	} s;
+};
+
+platform_t read_platform(void);
+u8 read_partnum(void);
+const char *read_board_name(void);
+bool read_alt_pkg(void);
+
+#endif /* __SOC_H */
diff --git a/arch/arm/include/asm/arch-octeontx2/board.h b/arch/arm/include/asm/arch-octeontx2/board.h
new file mode 100644
index 0000000000..ca189b9a65
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/board.h
@@ -0,0 +1,190 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+#include <asm/arch/soc.h>
+
+/** Reg offsets */
+#define RST_BOOT		0x87E006001600ULL
+
+#define CPC_BOOT_OWNERX(a)	0x86D000000160ULL + (8 * (a))
+
+/* attestation definitions shared with ATF (see 'plat_octeontx.h') */
+
+#define ATTESTATION_MAGIC_ID 0x5f415454 /* "_ATT" */
+
+enum sw_attestation_tlv_type {
+	ATT_IMG_INIT_BIN,
+	ATT_IMG_ATF_BL1,
+	ATT_IMG_BOARD_DT,
+	ATT_IMG_LINUX_DT,
+	ATT_IMG_SCP_TBL1FW,
+	ATT_IMG_MCP_TBL1FW,
+	ATT_IMG_AP_TBL1FW,
+	ATT_IMG_ATF_BL2,
+	ATT_IMG_ATF_BL31,
+	ATT_IMG_ATF_BL33,
+	ATT_SIG_NONCE,
+	ATT_IMG_FIT_KERNEL,
+
+	ATT_TLV_TYPE_COUNT,
+};
+
+typedef struct sw_attestation_tlv {
+	u16 type_be;   /* sw_attestation_tlv_type */
+	u16 length_be;
+	u8 value[0];   /* array of 'length_be' bytes */
+} sw_attestation_tlv_t;
+
+#define SW_ATT_INFO_NONCE_MAX_LEN  256
+
+typedef struct sw_attestation_info_hdr {
+	u32 magic_be;
+	u16 tlv_len_be;
+	u16 total_len_be;
+	u16 certificate_len_be;
+	u16 signature_len_be;
+	union {
+		sw_attestation_tlv_t tlv_list[0];
+		s8 input_nonce[0];
+	};
+} __packed sw_attestation_info_hdr_t;
+
+/** Structure definitions */
+/**
+ * Register (NCB32b) cpc_boot_owner#
+ *
+ * CPC Boot Owner Registers These registers control an external arbiter
+ * for the boot device (SPI/eMMC) across multiple external devices. There
+ * is a register for each requester: _ \<0\> - SCP          - reset on
+ * SCP reset _ \<1\> - MCP          - reset on MCP reset _ \<2\> - AP
+ * Secure    - reset on core reset _ \<3\> - AP Nonsecure - reset on core
+ * reset  These register is only writable to the corresponding
+ * requestor(s) permitted with CPC_PERMIT.
+ */
+union cpc_boot_ownerx {
+	u32 u;
+	struct cpc_boot_ownerx_s {
+		u32 boot_req		: 1;
+		u32 reserved_1_7	: 7;
+		u32 boot_wait		: 1;
+		u32 reserved_9_31	: 23;
+	} s;
+};
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register This register is not accessible through ROM scripts;
+ * see SCR_WRITE32_S[ADDR].
+ */
+union rst_boot {
+	u64 u;
+	struct rst_boot_s {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_32                    : 31;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 jt_tstmode                       : 1;
+		u64 ckill_ppdis                      : 1;
+		u64 trusted_mode                     : 1;
+		u64 reserved_61_62                   : 2;
+		u64 chipkill                         : 1;
+	} s;
+	struct rst_boot_cn96xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_23                    : 22;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn96xx;
+	struct rst_boot_cn98xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 rxp_mul                          : 7;
+		u64 reserved_15                      : 1;
+		u64 cpt1_mul                         : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cn98xx;
+	struct rst_boot_cnf95xx {
+		u64 rboot_pin                        : 1;
+		u64 rboot                            : 1;
+		u64 reserved_2_7                     : 6;
+		u64 bphy_mul                         : 7;
+		u64 reserved_15                      : 1;
+		u64 dsp_mul                          : 7;
+		u64 reserved_23                      : 1;
+		u64 cpt_mul                          : 7;
+		u64 reserved_31_32                   : 2;
+		u64 pnr_mul                          : 6;
+		u64 reserved_39                      : 1;
+		u64 c_mul                            : 7;
+		u64 reserved_47_52                   : 6;
+		u64 gpio_ejtag                       : 1;
+		u64 mcp_jtagdis                      : 1;
+		u64 dis_scan                         : 1;
+		u64 dis_huk                          : 1;
+		u64 vrm_err                          : 1;
+		u64 reserved_58_59                   : 2;
+		u64 trusted_mode                     : 1;
+		u64 scp_jtagdis                      : 1;
+		u64 jtagdis                          : 1;
+		u64 chipkill                         : 1;
+	} cnf95xx;
+};
+
+/** Function definitions */
+void mem_map_fill(void);
+int fdt_get_board_mac_cnt(void);
+u64 fdt_get_board_mac_addr(void);
+const char *fdt_get_board_model(void);
+const char *fdt_get_board_serial(void);
+const char *fdt_get_board_revision(void);
+void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr);
+void acquire_flash_arb(bool acquire);
+#endif /* __BOARD_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/clock.h b/arch/arm/include/asm/arch-octeontx2/clock.h
new file mode 100644
index 0000000000..7be8852a55
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/clock.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __CLOCK_H__
+
+/** System PLL reference clock */
+#define PLL_REF_CLK                     50000000        /* 50 MHz */
+#define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void);
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void);
+
+#endif /* __CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
new file mode 100644
index 0000000000..281008365c
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
@@ -0,0 +1,7841 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_CGX_H__
+#define __CSRS_CGX_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * CGX.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration cgx_bar_e
+ *
+ * CGX Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
+#define CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
+#define CGX_BAR_E_CGXX_PF_BAR4(a) (0x87e0e0400000ll + 0x1000000ll * (a))
+#define CGX_BAR_E_CGXX_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration cgx_int_vec_e
+ *
+ * CGX MSI-X Vector Enumeration Enumeration the MSI-X interrupt vectors.
+ */
+#define CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
+#define CGX_INT_VEC_E_CMRX_SW(a) (0x26 + (a))
+#define CGX_INT_VEC_E_CMR_MEM_INT (0x24)
+#define CGX_INT_VEC_E_GMPX_GMI_RX_INT(a) (5 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_GMI_TX_INT(a) (6 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_GMI_WOL_INT(a) (7 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_PCS_INT(a) (4 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_RX_INT(a) (2 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_RX_WOL_INT(a) (8 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_TX_INT(a) (3 + 9 * (a))
+#define CGX_INT_VEC_E_SPUX_INT(a) (1 + 9 * (a))
+#define CGX_INT_VEC_E_SW (0x25)
+
+/**
+ * Enumeration cgx_lmac_types_e
+ *
+ * CGX LMAC Type Enumeration Enumerates the LMAC Types that CGX supports.
+ */
+#define CGX_LMAC_TYPES_E_FIFTYG_R (8)
+#define CGX_LMAC_TYPES_E_FORTYG_R (4)
+#define CGX_LMAC_TYPES_E_HUNDREDG_R (9)
+#define CGX_LMAC_TYPES_E_QSGMII (6)
+#define CGX_LMAC_TYPES_E_RGMII (5)
+#define CGX_LMAC_TYPES_E_RXAUI (2)
+#define CGX_LMAC_TYPES_E_SGMII (0)
+#define CGX_LMAC_TYPES_E_TENG_R (3)
+#define CGX_LMAC_TYPES_E_TWENTYFIVEG_R (7)
+#define CGX_LMAC_TYPES_E_USXGMII (0xa)
+#define CGX_LMAC_TYPES_E_XAUI (1)
+
+/**
+ * Enumeration cgx_opcode_e
+ *
+ * INTERNAL: CGX Error Opcode Enumeration  Enumerates the error opcodes
+ * created by CGX and presented to NCSI/NIX.
+ */
+#define CGX_OPCODE_E_RE_FCS (7)
+#define CGX_OPCODE_E_RE_FCS_RCV (8)
+#define CGX_OPCODE_E_RE_JABBER (2)
+#define CGX_OPCODE_E_RE_NONE (0)
+#define CGX_OPCODE_E_RE_PARTIAL (1)
+#define CGX_OPCODE_E_RE_RX_CTL (0xb)
+#define CGX_OPCODE_E_RE_SKIP (0xc)
+#define CGX_OPCODE_E_RE_TERMINATE (9)
+
+/**
+ * Enumeration cgx_spu_br_train_cst_e
+ *
+ * CGX Training Coefficient Status Enumeration 2-bit status for each
+ * coefficient as defined in IEEE 802.3, Table 72-5.
+ */
+#define CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
+#define CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
+#define CGX_SPU_BR_TRAIN_CST_E_NOT_UPDATED (0)
+#define CGX_SPU_BR_TRAIN_CST_E_UPDATED (1)
+
+/**
+ * Enumeration cgx_spu_br_train_cup_e
+ *
+ * CGX Training Coefficient Enumeration 2-bit command for each
+ * coefficient as defined in IEEE 802.3, Table 72-4.
+ */
+#define CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
+#define CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
+#define CGX_SPU_BR_TRAIN_CUP_E_INCREMENT (2)
+#define CGX_SPU_BR_TRAIN_CUP_E_RSV_CMD (3)
+
+/**
+ * Enumeration cgx_usxgmii_rate_e
+ *
+ * CGX USXGMII Rate Enumeration Enumerates the USXGMII sub-port type
+ * rate, CGX()_SPU()_CONTROL1[USXGMII_RATE].  Selecting a rate higher
+ * than the maximum allowed for a given port sub-type (specified by
+ * CGX()_SPU()_CONTROL1[USXGMII_TYPE]), e.g., selecting ::RATE_2HG (2.5
+ * Gbps) for CGX_USXGMII_TYPE_E::SXGMII_2G, will cause unpredictable
+ * behavior. USXGMII hardware-based autonegotiation may change this
+ * setting.
+ */
+#define CGX_USXGMII_RATE_E_RATE_100M (1)
+#define CGX_USXGMII_RATE_E_RATE_10G (5)
+#define CGX_USXGMII_RATE_E_RATE_10M (0)
+#define CGX_USXGMII_RATE_E_RATE_1G (2)
+#define CGX_USXGMII_RATE_E_RATE_20G (6)
+#define CGX_USXGMII_RATE_E_RATE_2HG (3)
+#define CGX_USXGMII_RATE_E_RATE_5G (4)
+#define CGX_USXGMII_RATE_E_RSV_RATE (7)
+
+/**
+ * Enumeration cgx_usxgmii_type_e
+ *
+ * CGX USXGMII Port Sub-Type Enumeration Enumerates the USXGMII sub-port
+ * type, CGX()_SPU()_CONTROL1[USXGMII_TYPE].  The description indicates
+ * the maximum rate and the maximum number of ports (LMACs) for each sub-
+ * type. The minimum rate for any port is 10M. The rate selection for
+ * each LMAC is made using CGX()_SPU()_CONTROL1[USXGMII_RATE] and the
+ * number of active ports/LMACs is implicitly determined by the value
+ * given to CGX()_CMR()_CONFIG[ENABLE] for each LMAC.  Selecting a rate
+ * higher than the maximum allowed for a given port sub-type or enabling
+ * more LMACs than the maximum allowed for a given port sub-type will
+ * cause unpredictable behavior.
+ */
+#define CGX_USXGMII_TYPE_E_DXGMII_10G (3)
+#define CGX_USXGMII_TYPE_E_DXGMII_20G (5)
+#define CGX_USXGMII_TYPE_E_DXGMII_5G (4)
+#define CGX_USXGMII_TYPE_E_QXGMII_10G (7)
+#define CGX_USXGMII_TYPE_E_QXGMII_20G (6)
+#define CGX_USXGMII_TYPE_E_SXGMII_10G (0)
+#define CGX_USXGMII_TYPE_E_SXGMII_2G (2)
+#define CGX_USXGMII_TYPE_E_SXGMII_5G (1)
+
+/**
+ * Structure cgx_spu_br_lane_train_status_s
+ *
+ * CGX Lane Training Status Structure This is the group of lane status
+ * bits for a single lane in the BASE-R PMD status register (MDIO address
+ * 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
+ */
+union cgx_spu_br_lane_train_status_s {
+	u32 u;
+	struct cgx_spu_br_lane_train_status_s_s {
+		u32 rx_trained                       : 1;
+		u32 frame_lock                       : 1;
+		u32 training                         : 1;
+		u32 training_failure                 : 1;
+		u32 reserved_4_31                    : 28;
+	} s;
+	/* struct cgx_spu_br_lane_train_status_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_br_train_cup_s
+ *
+ * CGX Lane Training Coefficient Structure This is the coefficient update
+ * field of the BASE-R link training packet as defined in IEEE 802.3,
+ * Table 72-4.
+ */
+union cgx_spu_br_train_cup_s {
+	u32 u;
+	struct cgx_spu_br_train_cup_s_s {
+		u32 pre_cup                          : 2;
+		u32 main_cup                         : 2;
+		u32 post_cup                         : 2;
+		u32 reserved_6_11                    : 6;
+		u32 init                             : 1;
+		u32 preset                           : 1;
+		u32 reserved_14_31                   : 18;
+	} s;
+	struct cgx_spu_br_train_cup_s_cn {
+		u32 pre_cup                          : 2;
+		u32 main_cup                         : 2;
+		u32 post_cup                         : 2;
+		u32 reserved_6_11                    : 6;
+		u32 init                             : 1;
+		u32 preset                           : 1;
+		u32 reserved_14_15                   : 2;
+		u32 reserved_16_31                   : 16;
+	} cn;
+};
+
+/**
+ * Structure cgx_spu_br_train_rep_s
+ *
+ * CGX Training Report Structure This is the status report field of the
+ * BASE-R link training packet as defined in IEEE 802.3, Table 72-5.
+ */
+union cgx_spu_br_train_rep_s {
+	u32 u;
+	struct cgx_spu_br_train_rep_s_s {
+		u32 pre_cst                          : 2;
+		u32 main_cst                         : 2;
+		u32 post_cst                         : 2;
+		u32 reserved_6_14                    : 9;
+		u32 rx_ready                         : 1;
+		u32 reserved_16_31                   : 16;
+	} s;
+	/* struct cgx_spu_br_train_rep_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_cu_s
+ *
+ * INTERNAL: CGX Training Coeffiecient Structure  This structure is
+ * similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields
+ * removed and [RCVR_READY] field added.
+ */
+union cgx_spu_sds_cu_s {
+	u32 u;
+	struct cgx_spu_sds_cu_s_s {
+		u32 pre_cu                           : 2;
+		u32 main_cu                          : 2;
+		u32 post_cu                          : 2;
+		u32 initialize                       : 1;
+		u32 preset                           : 1;
+		u32 rcvr_ready                       : 1;
+		u32 reserved_9_31                    : 23;
+	} s;
+	/* struct cgx_spu_sds_cu_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_skew_status_s
+ *
+ * CGX Skew Status Structure Provides receive skew information detected
+ * for a physical SerDes lane when it is assigned to a multilane
+ * LMAC/LPCS. Contents are valid when RX deskew is done for the
+ * associated LMAC/LPCS.
+ */
+union cgx_spu_sds_skew_status_s {
+	u32 u;
+	struct cgx_spu_sds_skew_status_s_s {
+		u32 am_timestamp                     : 12;
+		u32 reserved_12_15                   : 4;
+		u32 am_lane_id                       : 5;
+		u32 reserved_21_22                   : 2;
+		u32 lane_skew                        : 7;
+		u32 reserved_30_31                   : 2;
+	} s;
+	/* struct cgx_spu_sds_skew_status_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_sr_s
+ *
+ * INTERNAL: CGX Lane Training Coefficient Structure  Similar to
+ * CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields
+ * removed.
+ */
+union cgx_spu_sds_sr_s {
+	u32 u;
+	struct cgx_spu_sds_sr_s_s {
+		u32 pre_status                       : 2;
+		u32 main_status                      : 2;
+		u32 post_status                      : 2;
+		u32 reserved_6_31                    : 26;
+	} s;
+	/* struct cgx_spu_sds_sr_s_s cn; */
+};
+
+/**
+ * Register (RSL) cgx#_active_pc
+ *
+ * CGX ACTIVE PC Register This register counts the conditional clocks for
+ * power management.
+ */
+union cgxx_active_pc {
+	u64 u;
+	struct cgxx_active_pc_s {
+		u64 cnt                              : 64;
+	} s;
+	/* struct cgxx_active_pc_s cn; */
+};
+
+static inline u64 CGXX_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_ACTIVE_PC(void)
+{
+	return 0x2010;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_activity
+ *
+ * CGX CMR Activity Registers
+ */
+union cgxx_cmrx_activity {
+	u64 u;
+	struct cgxx_cmrx_activity_s {
+		u64 act_tx_lo                        : 1;
+		u64 act_tx_hi                        : 1;
+		u64 pause_tx                         : 1;
+		u64 act_rx_lo                        : 1;
+		u64 act_rx_hi                        : 1;
+		u64 pause_rx                         : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_cmrx_activity_s cn; */
+};
+
+static inline u64 CGXX_CMRX_ACTIVITY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_ACTIVITY(u64 a)
+{
+	return 0x5f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_config
+ *
+ * CGX CMR Configuration Registers Logical MAC/PCS configuration
+ * registers; one per LMAC. The maximum number of LMACs (and maximum LMAC
+ * ID) that can be enabled by these registers is limited by
+ * CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS].  Internal:
+ * \<pre\> Example configurations:   ------------------------------------
+ * ---------------------------------------   Configuration
+ * LMACS  Register             [ENABLE]    [LMAC_TYPE]   ----------------
+ * -----------------------------------------------------------
+ * 1x50G+1x25G+1xSGMII     4      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------   USXGMII
+ * 1-4    CGXn_CMR0_CONFIG     1           a
+ * CGXn_CMR1_CONFIG     1           a
+ * CGXn_CMR2_CONFIG     1           a
+ * CGXn_CMR3_CONFIG     1           a   ---------------------------------
+ * ------------------------------------------   1x100GBASE-R4           1
+ * CGXn_CMR0_CONFIG     1           9
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   2x50GBASE-R2
+ * 2      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     1           8
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x25GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           7
+ * CGXn_CMR1_CONFIG     1           7
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           7   ---------------------------------
+ * ------------------------------------------   QSGMII                  4
+ * CGXn_CMR0_CONFIG     1           6
+ * CGXn_CMR1_CONFIG     1           6
+ * CGXn_CMR2_CONFIG     1           6
+ * CGXn_CMR3_CONFIG     1           6   ---------------------------------
+ * ------------------------------------------   1x40GBASE-R4            1
+ * CGXn_CMR0_CONFIG     1           4
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x10GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           3
+ * CGXn_CMR1_CONFIG     1           3
+ * CGXn_CMR2_CONFIG     1           3
+ * CGXn_CMR3_CONFIG     1           3   ---------------------------------
+ * ------------------------------------------   2xRXAUI                 2
+ * CGXn_CMR0_CONFIG     1           2
+ * CGXn_CMR1_CONFIG     1           2
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   1x10GBASE-X/XAUI/DXAUI
+ * 1      CGXn_CMR0_CONFIG     1           1
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4xSGMII/1000BASE-X
+ * 4      CGXn_CMR0_CONFIG     1           0
+ * CGXn_CMR1_CONFIG     1           0
+ * CGXn_CMR2_CONFIG     1           0
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------ \</pre\>
+ */
+union cgxx_cmrx_config {
+	u64 u;
+	struct cgxx_cmrx_config_s {
+		u64 lane_to_sds                      : 8;
+		u64 reserved_8_39                    : 32;
+		u64 lmac_type                        : 4;
+		u64 unused                           : 8;
+		u64 int_beat_gen                     : 1;
+		u64 data_pkt_tx_en                   : 1;
+		u64 data_pkt_rx_en                   : 1;
+		u64 enable                           : 1;
+		u64 x2p_select                       : 3;
+		u64 p2x_select                       : 3;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cgxx_cmrx_config_s cn; */
+};
+
+static inline u64 CGXX_CMRX_CONFIG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_CONFIG(u64 a)
+{
+	return 0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int
+ *
+ * CGX CMR Interrupt Register
+ */
+union cgxx_cmrx_int {
+	u64 u;
+	struct cgxx_cmrx_int_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_int_s cn; */
+};
+
+static inline u64 CGXX_CMRX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_INT(u64 a)
+{
+	return 0x40 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_ena_w1c
+ *
+ * CGX CMR Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_int_ena_w1c {
+	u64 u;
+	struct cgxx_cmrx_int_ena_w1c_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_CMRX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_INT_ENA_W1C(u64 a)
+{
+	return 0x50 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_ena_w1s
+ *
+ * CGX CMR Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_int_ena_w1s {
+	u64 u;
+	struct cgxx_cmrx_int_ena_w1s_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_INT_ENA_W1S(u64 a)
+{
+	return 0x58 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_w1s
+ *
+ * CGX CMR Interrupt Set Register This register sets interrupt bits.
+ */
+union cgxx_cmrx_int_w1s {
+	u64 u;
+	struct cgxx_cmrx_int_w1s_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_INT_W1S(u64 a)
+{
+	return 0x48 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_led_timing
+ *
+ * CGX MAC LED Activity Timing Registers
+ */
+union cgxx_cmrx_led_timing {
+	u64 u;
+	struct cgxx_cmrx_led_timing_s {
+		u64 extension                        : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cgxx_cmrx_led_timing_s cn; */
+};
+
+static inline u64 CGXX_CMRX_LED_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_LED_TIMING(u64 a)
+{
+	return 0x5f0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_prt_cbfc_ctl
+ *
+ * CGX CMR LMAC PFC Control Registers See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
+ */
+union cgxx_cmrx_prt_cbfc_ctl {
+	u64 u;
+	struct cgxx_cmrx_prt_cbfc_ctl_s {
+		u64 reserved_0_15                    : 16;
+		u64 phys_bp                          : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_cmrx_prt_cbfc_ctl_s cn; */
+};
+
+static inline u64 CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+{
+	return 0x608 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_drop
+ *
+ * CGX Receive Backpressure Drop Register
+ */
+union cgxx_cmrx_rx_bp_drop {
+	u64 u;
+	struct cgxx_cmrx_rx_bp_drop_s {
+		u64 mark                             : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_rx_bp_drop_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_BP_DROP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_BP_DROP(u64 a)
+{
+	return 0xd8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_off
+ *
+ * CGX Receive Backpressure Off Register
+ */
+union cgxx_cmrx_rx_bp_off {
+	u64 u;
+	struct cgxx_cmrx_rx_bp_off_s {
+		u64 mark                             : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_cmrx_rx_bp_off_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_BP_OFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_BP_OFF(u64 a)
+{
+	return 0xe8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_on
+ *
+ * CGX Receive Backpressure On Register
+ */
+union cgxx_cmrx_rx_bp_on {
+	u64 u;
+	struct cgxx_cmrx_rx_bp_on_s {
+		u64 mark                             : 13;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cgxx_cmrx_rx_bp_on_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_BP_ON(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_BP_ON(u64 a)
+{
+	return 0xe0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_status
+ *
+ * CGX CMR Receive Backpressure Status Registers
+ */
+union cgxx_cmrx_rx_bp_status {
+	u64 u;
+	struct cgxx_cmrx_rx_bp_status_s {
+		u64 bp                               : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_rx_bp_status_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_BP_STATUS(u64 a)
+{
+	return 0xf0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_dmac_ctl0
+ *
+ * CGX CMR Receive DMAC Address-Control0 Register DMAC CAM control
+ * register for use by X2P/NIX bound traffic. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM0 and
+ * CGX()_CMR_RX_STEERING0().  Internal: "* ALGORITHM Here is some pseudo
+ * code that represents the address filter behavior. \<pre\>
+ * dmac_addr_filter(uint8 prt, uint48 dmac) { for (lmac=0, lmac\<4,
+ * lmac++) {   if (is_bcst(dmac))                               //
+ * broadcast accept     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[BCST_ACCEPT]
+ * ? ACCEPT : REJECT);   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 0)   // multicast reject
+ * return REJECT;   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 1)   // multicast accept
+ * return ACCEPT;   else        // DMAC CAM filter     cam_hit = 0;   for
+ * (i=0; i\<32; i++) {     cam = CGX()_CMR_RX_DMAC(i)_CAM0;     if
+ * (cam[EN] && cam[ID] == lmac && cam[ADR] == dmac) {       cam_hit = 1;
+ * break;     }   }   if (cam_hit) {     return
+ * (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? ACCEPT : REJECT);   else
+ * return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
+ * } } \</pre\>"
+ */
+union cgxx_cmrx_rx_dmac_ctl0 {
+	u64 u;
+	struct cgxx_cmrx_rx_dmac_ctl0_s {
+		u64 bcst_accept                      : 1;
+		u64 mcst_mode                        : 2;
+		u64 cam_accept                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_cmrx_rx_dmac_ctl0_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+{
+	return 0x1f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_dmac_ctl1
+ *
+ * CGX CMR Receive DMAC Address-Control1 Register DMAC CAM control
+ * register for use by NCSI bound traffic. Received packets are only
+ * passed to NCSI when the DMAC1 filter result is ACCEPT and STEERING1
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI;
+ * see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR()_RX_DMAC_CTL0.
+ */
+union cgxx_cmrx_rx_dmac_ctl1 {
+	u64 u;
+	struct cgxx_cmrx_rx_dmac_ctl1_s {
+		u64 bcst_accept                      : 1;
+		u64 mcst_mode                        : 2;
+		u64 cam_accept                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_cmrx_rx_dmac_ctl1_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+{
+	return 0x3f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_fifo_len
+ *
+ * CGX CMR Receive Fifo Length Registers
+ */
+union cgxx_cmrx_rx_fifo_len {
+	u64 u;
+	struct cgxx_cmrx_rx_fifo_len_s {
+		u64 fifo_len                         : 14;
+		u64 busy                             : 1;
+		u64 fifo_len_e                       : 14;
+		u64 busy_e                           : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cgxx_cmrx_rx_fifo_len_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_FIFO_LEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_FIFO_LEN(u64 a)
+{
+	return 0x108 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_id_map
+ *
+ * CGX CMR Receive ID Map Register These registers set the RX LMAC ID
+ * mapping for X2P/NIX.
+ */
+union cgxx_cmrx_rx_id_map {
+	u64 u;
+	struct cgxx_cmrx_rx_id_map_s {
+		u64 pknd                             : 6;
+		u64 unused                           : 2;
+		u64 rid                              : 7;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cgxx_cmrx_rx_id_map_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_ID_MAP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_ID_MAP(u64 a)
+{
+	return 0x60 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_logl_xoff
+ *
+ * CGX CMR Receive Logical XOFF Registers
+ */
+union cgxx_cmrx_rx_logl_xoff {
+	u64 u;
+	struct cgxx_cmrx_rx_logl_xoff_s {
+		u64 xoff                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_cmrx_rx_logl_xoff_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+{
+	return 0xf8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_logl_xon
+ *
+ * CGX CMR Receive Logical XON Registers
+ */
+union cgxx_cmrx_rx_logl_xon {
+	u64 u;
+	struct cgxx_cmrx_rx_logl_xon_s {
+		u64 xon                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_cmrx_rx_logl_xon_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_LOGL_XON(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_LOGL_XON(u64 a)
+{
+	return 0x100 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat0
+ *
+ * CGX RX Preemption Status Register 0
+ */
+union cgxx_cmrx_rx_merge_stat0 {
+	u64 u;
+	struct cgxx_cmrx_rx_merge_stat0_s {
+		u64 fa_err_cnt                       : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_merge_stat0_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+{
+	return 0x138 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat1
+ *
+ * CGX RX Preemption Status Register 1
+ */
+union cgxx_cmrx_rx_merge_stat1 {
+	u64 u;
+	struct cgxx_cmrx_rx_merge_stat1_s {
+		u64 fs_err_cnt                       : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_merge_stat1_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+{
+	return 0x140 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat2
+ *
+ * CGX RX Preemption Status Register 2
+ */
+union cgxx_cmrx_rx_merge_stat2 {
+	u64 u;
+	struct cgxx_cmrx_rx_merge_stat2_s {
+		u64 fa_ok_cnt                        : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_merge_stat2_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+{
+	return 0x148 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat3
+ *
+ * CGX RX Preemption Status Register 3
+ */
+union cgxx_cmrx_rx_merge_stat3 {
+	u64 u;
+	struct cgxx_cmrx_rx_merge_stat3_s {
+		u64 ff_cnt                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_merge_stat3_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+{
+	return 0x150 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat4
+ *
+ * CGX RX Preemption Status Register 4
+ */
+union cgxx_cmrx_rx_merge_stat4 {
+	u64 u;
+	struct cgxx_cmrx_rx_merge_stat4_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_merge_stat4_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+{
+	return 0x158 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_pause_drop_time
+ *
+ * CGX CMR Receive Pause Drop-Time Register
+ */
+union cgxx_cmrx_rx_pause_drop_time {
+	u64 u;
+	struct cgxx_cmrx_rx_pause_drop_time_s {
+		u64 pause_time                       : 16;
+		u64 pause_time_e                     : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_cmrx_rx_pause_drop_time_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+{
+	return 0x68 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat0
+ *
+ * CGX Receive Status Register 0 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are not dropped due
+ * DMAC0 or STEERING0 filtering.  Internal: "This pseudo code represents
+ * the RX STAT0 through STAT8 accounting: \<pre\> If (errored)   incr
+ * RX_STAT8 else if (ctrl packet, i.e. Pause/PFC)   incr RX_STAT2,3 else
+ * if (fifo full drop)   incr RX_STAT6,7 else if (DMAC0/VLAN0 filter
+ * drop)   incr RX_STAT4,5 if not a filter+decision else   incr
+ * RX_STAT0,1 end \</pre\>"
+ */
+union cgxx_cmrx_rx_stat0 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat0_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat0_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT0(u64 a)
+{
+	return 0x70 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat1
+ *
+ * CGX Receive Status Register 1 These registers provide a count of
+ * octets of received packets.
+ */
+union cgxx_cmrx_rx_stat1 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat1_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat1_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT1(u64 a)
+{
+	return 0x78 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat2
+ *
+ * CGX Receive Status Register 2 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are recognized as PAUSE
+ * packets.  Pause packets can be optionally dropped or forwarded based
+ * on
+ * CGX()_SMU()_RX_FRM_CTL[CTL_DRP]/CGX()_GMP_GMI_RX()_FRM_CTL[CTL_DRP].
+ * This count increments regardless of whether the packet is dropped.
+ */
+union cgxx_cmrx_rx_stat2 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat2_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat2_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT2(u64 a)
+{
+	return 0x80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat3
+ *
+ * CGX Receive Status Register 3 These registers provide a count of
+ * octets of received PAUSE and control packets.
+ */
+union cgxx_cmrx_rx_stat3 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat3_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat3_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT3(u64 a)
+{
+	return 0x88 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat4
+ *
+ * CGX Receive Status Register 4 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are dropped due
+ * DMAC0 or STEERING0 filtering.  16B packets or smaller (20B in case of
+ * FCS strip) as the result of truncation or other means are not dropped
+ * by CGX (unless filter and decision is also asserted) and will never
+ * appear in this count. Should the MAC signal to the CMR that the packet
+ * be filtered upon decision before the end of packet, then STAT4 and
+ * STAT5 will not be updated.
+ */
+union cgxx_cmrx_rx_stat4 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat4_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat4_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT4(u64 a)
+{
+	return 0x90 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat5
+ *
+ * CGX Receive Status Register 5 These registers provide a count of
+ * octets of filtered DMAC0 or VLAN STEERING0 packets.
+ */
+union cgxx_cmrx_rx_stat5 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat5_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat5_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT5(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT5(u64 a)
+{
+	return 0x98 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat6
+ *
+ * CGX Receive Status Register 6 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are dropped due FIFO full status.  They do not count any
+ * packet that is truncated at the point of overflow and sent on to the
+ * NIX. The truncated packet will be marked with error and increment
+ * STAT8. These registers count all entire packets dropped by the FIFO
+ * for a given LMAC.
+ */
+union cgxx_cmrx_rx_stat6 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat6_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat6_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT6(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT6(u64 a)
+{
+	return 0xa0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat7
+ *
+ * CGX Receive Status Register 7 These registers provide a count of
+ * octets of received packets that were dropped due to a full receive
+ * FIFO.
+ */
+union cgxx_cmrx_rx_stat7 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat7_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat7_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT7(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT7(u64 a)
+{
+	return 0xa8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat8
+ *
+ * CGX Receive Status Register 8 These registers provide a count of
+ * received packets that meet the following conditions:  * are recognized
+ * as ERROR packets(any OPCODE).
+ */
+union cgxx_cmrx_rx_stat8 {
+	u64 u;
+	struct cgxx_cmrx_rx_stat8_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat8_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT8(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT8(u64 a)
+{
+	return 0xb0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat_pri#_xoff
+ *
+ * CGX CMR RX XON to XOFF transition Registers
+ */
+union cgxx_cmrx_rx_stat_prix_xoff {
+	u64 u;
+	struct cgxx_cmrx_rx_stat_prix_xoff_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_rx_stat_prix_xoff_s cn; */
+};
+
+static inline u64 CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+{
+	return 0x7c0 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_scratch#
+ *
+ * CGX CMR Scratch Registers
+ */
+union cgxx_cmrx_scratchx {
+	u64 u;
+	struct cgxx_cmrx_scratchx_s {
+		u64 scratch                          : 64;
+	} s;
+	/* struct cgxx_cmrx_scratchx_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+{
+	return 0x1050 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int
+ *
+ * CGX CMR Interrupt Register
+ */
+union cgxx_cmrx_sw_int {
+	u64 u;
+	struct cgxx_cmrx_sw_int_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT(u64 a)
+{
+	return 0x180 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_ena_w1c
+ *
+ * CGX CMR Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_sw_int_ena_w1c {
+	u64 u;
+	struct cgxx_cmrx_sw_int_ena_w1c_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1C(u64 a)
+{
+	return 0x190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_ena_w1s
+ *
+ * CGX CMR Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_sw_int_ena_w1s {
+	u64 u;
+	struct cgxx_cmrx_sw_int_ena_w1s_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1S(u64 a)
+{
+	return 0x198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_w1s
+ *
+ * CGX CMR Interrupt Set Register This register sets interrupt bits.
+ */
+union cgxx_cmrx_sw_int_w1s {
+	u64 u;
+	struct cgxx_cmrx_sw_int_w1s_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_W1S(u64 a)
+{
+	return 0x188 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_channel
+ *
+ * CGX CMR Transmit-Channels Registers
+ */
+union cgxx_cmrx_tx_channel {
+	u64 u;
+	struct cgxx_cmrx_tx_channel_s {
+		u64 msk                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_cmrx_tx_channel_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_CHANNEL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_CHANNEL(u64 a)
+{
+	return 0x600 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_fifo_len
+ *
+ * CGX CMR Transmit Fifo Length Registers
+ */
+union cgxx_cmrx_tx_fifo_len {
+	u64 u;
+	struct cgxx_cmrx_tx_fifo_len_s {
+		u64 fifo_len                         : 14;
+		u64 lmac_idle                        : 1;
+		u64 fifo_e_len                       : 14;
+		u64 lmac_e_idle                      : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cgxx_cmrx_tx_fifo_len_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_FIFO_LEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_FIFO_LEN(u64 a)
+{
+	return 0x618 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_hg2_status
+ *
+ * CGX CMR Transmit HiGig2 Status Registers
+ */
+union cgxx_cmrx_tx_hg2_status {
+	u64 u;
+	struct cgxx_cmrx_tx_hg2_status_s {
+		u64 lgtim2go                         : 16;
+		u64 xof                              : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_cmrx_tx_hg2_status_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_HG2_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_HG2_STATUS(u64 a)
+{
+	return 0x610 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_merge_stat0
+ *
+ * CGX TX Preemption Status Register 0
+ */
+union cgxx_cmrx_tx_merge_stat0 {
+	u64 u;
+	struct cgxx_cmrx_tx_merge_stat0_s {
+		u64 ff_cnt                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_merge_stat0_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+{
+	return 0x160 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_ovr_bp
+ *
+ * CGX CMR Transmit-Channels Backpressure Override Registers
+ */
+union cgxx_cmrx_tx_ovr_bp {
+	u64 u;
+	struct cgxx_cmrx_tx_ovr_bp_s {
+		u64 tx_chan_bp                       : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_cmrx_tx_ovr_bp_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_OVR_BP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_OVR_BP(u64 a)
+{
+	return 0x620 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat0
+ *
+ * CGX CMR Transmit Statistics Registers 0
+ */
+union cgxx_cmrx_tx_stat0 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat0_s {
+		u64 xscol                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat0_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT0(u64 a)
+{
+	return 0x700 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat1
+ *
+ * CGX CMR Transmit Statistics Registers 1
+ */
+union cgxx_cmrx_tx_stat1 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat1_s {
+		u64 xsdef                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat1_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT1(u64 a)
+{
+	return 0x708 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat10
+ *
+ * CGX CMR Transmit Statistics Registers 10
+ */
+union cgxx_cmrx_tx_stat10 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat10_s {
+		u64 hist4                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat10_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT10(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT10(u64 a)
+{
+	return 0x750 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat11
+ *
+ * CGX CMR Transmit Statistics Registers 11
+ */
+union cgxx_cmrx_tx_stat11 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat11_s {
+		u64 hist5                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat11_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT11(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT11(u64 a)
+{
+	return 0x758 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat12
+ *
+ * CGX CMR Transmit Statistics Registers 12
+ */
+union cgxx_cmrx_tx_stat12 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat12_s {
+		u64 hist6                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat12_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT12(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT12(u64 a)
+{
+	return 0x760 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat13
+ *
+ * CGX CMR Transmit Statistics Registers 13
+ */
+union cgxx_cmrx_tx_stat13 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat13_s {
+		u64 hist7                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat13_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT13(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT13(u64 a)
+{
+	return 0x768 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat14
+ *
+ * CGX CMR Transmit Statistics Registers 14
+ */
+union cgxx_cmrx_tx_stat14 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat14_s {
+		u64 bcst                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat14_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT14(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT14(u64 a)
+{
+	return 0x770 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat15
+ *
+ * CGX CMR Transmit Statistics Registers 15
+ */
+union cgxx_cmrx_tx_stat15 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat15_s {
+		u64 mcst                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat15_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT15(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT15(u64 a)
+{
+	return 0x778 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat16
+ *
+ * CGX CMR Transmit Statistics Registers 16
+ */
+union cgxx_cmrx_tx_stat16 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat16_s {
+		u64 undflw                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat16_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT16(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT16(u64 a)
+{
+	return 0x780 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat17
+ *
+ * CGX CMR Transmit Statistics Registers 17
+ */
+union cgxx_cmrx_tx_stat17 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat17_s {
+		u64 ctl                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat17_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT17(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT17(u64 a)
+{
+	return 0x788 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat2
+ *
+ * CGX CMR Transmit Statistics Registers 2
+ */
+union cgxx_cmrx_tx_stat2 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat2_s {
+		u64 mcol                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat2_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT2(u64 a)
+{
+	return 0x710 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat3
+ *
+ * CGX CMR Transmit Statistics Registers 3
+ */
+union cgxx_cmrx_tx_stat3 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat3_s {
+		u64 scol                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat3_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT3(u64 a)
+{
+	return 0x718 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat4
+ *
+ * CGX CMR Transmit Statistics Registers 4
+ */
+union cgxx_cmrx_tx_stat4 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat4_s {
+		u64 octs                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat4_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT4(u64 a)
+{
+	return 0x720 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat5
+ *
+ * CGX CMR Transmit Statistics Registers 5
+ */
+union cgxx_cmrx_tx_stat5 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat5_s {
+		u64 pkts                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat5_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT5(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT5(u64 a)
+{
+	return 0x728 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat6
+ *
+ * CGX CMR Transmit Statistics Registers 6
+ */
+union cgxx_cmrx_tx_stat6 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat6_s {
+		u64 hist0                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat6_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT6(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT6(u64 a)
+{
+	return 0x730 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat7
+ *
+ * CGX CMR Transmit Statistics Registers 7
+ */
+union cgxx_cmrx_tx_stat7 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat7_s {
+		u64 hist1                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat7_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT7(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT7(u64 a)
+{
+	return 0x738 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat8
+ *
+ * CGX CMR Transmit Statistics Registers 8
+ */
+union cgxx_cmrx_tx_stat8 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat8_s {
+		u64 hist2                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat8_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT8(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT8(u64 a)
+{
+	return 0x740 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat9
+ *
+ * CGX CMR Transmit Statistics Registers 9
+ */
+union cgxx_cmrx_tx_stat9 {
+	u64 u;
+	struct cgxx_cmrx_tx_stat9_s {
+		u64 hist3                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat9_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT9(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT9(u64 a)
+{
+	return 0x748 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat_pri#_xoff
+ *
+ * CGX CMR TX XON to XOFF transition Registers
+ */
+union cgxx_cmrx_tx_stat_prix_xoff {
+	u64 u;
+	struct cgxx_cmrx_tx_stat_prix_xoff_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmrx_tx_stat_prix_xoff_s cn; */
+};
+
+static inline u64 CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+{
+	return 0x800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_bad
+ *
+ * CGX CMR Bad Registers
+ */
+union cgxx_cmr_bad {
+	u64 u;
+	struct cgxx_cmr_bad_s {
+		u64 rxb_nxl                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmr_bad_s cn; */
+};
+
+static inline u64 CGXX_CMR_BAD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_BAD(void)
+{
+	return 0x1020;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_chan_msk_and
+ *
+ * CGX CMR Backpressure Channel Mask AND Registers
+ */
+union cgxx_cmr_chan_msk_and {
+	u64 u;
+	struct cgxx_cmr_chan_msk_and_s {
+		u64 msk_and                          : 64;
+	} s;
+	/* struct cgxx_cmr_chan_msk_and_s cn; */
+};
+
+static inline u64 CGXX_CMR_CHAN_MSK_AND(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_CHAN_MSK_AND(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_chan_msk_or
+ *
+ * CGX Backpressure Channel Mask OR Registers
+ */
+union cgxx_cmr_chan_msk_or {
+	u64 u;
+	struct cgxx_cmr_chan_msk_or_s {
+		u64 msk_or                           : 64;
+	} s;
+	/* struct cgxx_cmr_chan_msk_or_s cn; */
+};
+
+static inline u64 CGXX_CMR_CHAN_MSK_OR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_CHAN_MSK_OR(void)
+{
+	return 0x118;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_eco
+ *
+ * INTERNAL: CGX ECO Registers
+ */
+union cgxx_cmr_eco {
+	u64 u;
+	struct cgxx_cmr_eco_s {
+		u64 eco_rw                           : 32;
+		u64 eco_ro                           : 32;
+	} s;
+	/* struct cgxx_cmr_eco_s cn; */
+};
+
+static inline u64 CGXX_CMR_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_ECO(void)
+{
+	return 0x1028;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_global_config
+ *
+ * CGX CMR Global Configuration Register These registers configure the
+ * global CMR, PCS, and MAC.
+ */
+union cgxx_cmr_global_config {
+	u64 u;
+	struct cgxx_cmr_global_config_s {
+		u64 pmux_sds_sel                     : 1;
+		u64 cgx_clk_enable                   : 1;
+		u64 cmr_x2p_reset                    : 3;
+		u64 interleave_mode                  : 1;
+		u64 fcs_strip                        : 1;
+		u64 ncsi_lmac_id                     : 2;
+		u64 cmr_ncsi_drop                    : 1;
+		u64 cmr_ncsi_reset                   : 1;
+		u64 cmr_ncsi_tag_cnt                 : 13;
+		u64 cmr_clken_ovrd                   : 1;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cgxx_cmr_global_config_s cn; */
+};
+
+static inline u64 CGXX_CMR_GLOBAL_CONFIG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_GLOBAL_CONFIG(void)
+{
+	return 8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int
+ *
+ * CGX CMR Memory Interrupt Register
+ */
+union cgxx_cmr_mem_int {
+	u64 u;
+	struct cgxx_cmr_mem_int_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_cmr_mem_int_s cn; */
+};
+
+static inline u64 CGXX_CMR_MEM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_MEM_INT(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_ena_w1c
+ *
+ * CGX CMR Memory Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cgxx_cmr_mem_int_ena_w1c {
+	u64 u;
+	struct cgxx_cmr_mem_int_ena_w1c_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_cmr_mem_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1C(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_ena_w1s
+ *
+ * CGX CMR Memory Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cgxx_cmr_mem_int_ena_w1s {
+	u64 u;
+	struct cgxx_cmr_mem_int_ena_w1s_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_cmr_mem_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1S(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_w1s
+ *
+ * CGX CMR Memory Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union cgxx_cmr_mem_int_w1s {
+	u64 u;
+	struct cgxx_cmr_mem_int_w1s_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_cmr_mem_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMR_MEM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_MEM_INT_W1S(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nic_nxc_adr
+ *
+ * CGX CMR NIC NXC Exception Registers
+ */
+union cgxx_cmr_nic_nxc_adr {
+	u64 u;
+	struct cgxx_cmr_nic_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_cmr_nic_nxc_adr_s cn; */
+};
+
+static inline u64 CGXX_CMR_NIC_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_NIC_NXC_ADR(void)
+{
+	return 0x1030;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nix0_nxc_adr
+ *
+ * CGX CMR NIX0 NXC Exception Registers
+ */
+union cgxx_cmr_nix0_nxc_adr {
+	u64 u;
+	struct cgxx_cmr_nix0_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 channel_e                        : 12;
+		u64 lmac_e_id                        : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_cmr_nix0_nxc_adr_s cn; */
+};
+
+static inline u64 CGXX_CMR_NIX0_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_NIX0_NXC_ADR(void)
+{
+	return 0x1038;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nix1_nxc_adr
+ *
+ * CGX CMR NIX1 NXC Exception Registers
+ */
+union cgxx_cmr_nix1_nxc_adr {
+	u64 u;
+	struct cgxx_cmr_nix1_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 channel_e                        : 12;
+		u64 lmac_e_id                        : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_cmr_nix1_nxc_adr_s cn; */
+};
+
+static inline u64 CGXX_CMR_NIX1_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_NIX1_NXC_ADR(void)
+{
+	return 0x1040;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_p2x#_count
+ *
+ * CGX P2X Activity Register
+ */
+union cgxx_cmr_p2xx_count {
+	u64 u;
+	struct cgxx_cmr_p2xx_count_s {
+		u64 p2x_cnt                          : 64;
+	} s;
+	/* struct cgxx_cmr_p2xx_count_s cn; */
+};
+
+static inline u64 CGXX_CMR_P2XX_COUNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_P2XX_COUNT(u64 a)
+{
+	return 0x168 + 0x1000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_dmac#_cam0
+ *
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM0 entries in CGX, for use by X2P/NIX bound traffic.
+ */
+union cgxx_cmr_rx_dmacx_cam0 {
+	u64 u;
+	struct cgxx_cmr_rx_dmacx_cam0_s {
+		u64 adr                              : 48;
+		u64 en                               : 1;
+		u64 id                               : 2;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cgxx_cmr_rx_dmacx_cam0_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_DMACX_CAM0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_DMACX_CAM0(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_dmac#_cam1
+ *
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM entries in CGX for use by NCSI bound traffic. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and CGX()_CMR_RX_STEERING1()
+ * registers.
+ */
+union cgxx_cmr_rx_dmacx_cam1 {
+	u64 u;
+	struct cgxx_cmr_rx_dmacx_cam1_s {
+		u64 adr                              : 48;
+		u64 en                               : 1;
+		u64 id                               : 2;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cgxx_cmr_rx_dmacx_cam1_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_DMACX_CAM1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_DMACX_CAM1(u64 a)
+{
+	return 0x400 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_lmacs
+ *
+ * CGX CMR Receive Logical MACs Registers
+ */
+union cgxx_cmr_rx_lmacs {
+	u64 u;
+	struct cgxx_cmr_rx_lmacs_s {
+		u64 lmacs                            : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cgxx_cmr_rx_lmacs_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_LMACS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_LMACS(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_ovr_bp
+ *
+ * CGX CMR Receive-Ports Backpressure Override Registers Per-LMAC
+ * backpressure override register. For SMU, CGX()_CMR_RX_OVR_BP[EN]\<0\>
+ * must be set to one and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to
+ * zero (to forcibly disable hardware-automatic 802.3 PAUSE packet
+ * generation) with the HiGig2 Protocol when
+ * CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is indicated
+ * by CGX()_SMU()_TX_CTL[HG_EN]=1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16).
+ * Hardware can only auto-generate backpressure through HiGig2 messages
+ * (optionally, when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2
+ * protocol.
+ */
+union cgxx_cmr_rx_ovr_bp {
+	u64 u;
+	struct cgxx_cmr_rx_ovr_bp_s {
+		u64 ign_fifo_bp                      : 4;
+		u64 bp                               : 4;
+		u64 en                               : 4;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cgxx_cmr_rx_ovr_bp_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_OVR_BP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_OVR_BP(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat10
+ *
+ * CGX Receive Status Register 10 These registers provide a count of
+ * octets of filtered DMAC1 or VLAN STEERING1 packets.
+ */
+union cgxx_cmr_rx_stat10 {
+	u64 u;
+	struct cgxx_cmr_rx_stat10_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmr_rx_stat10_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STAT10(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STAT10(void)
+{
+	return 0xc0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat11
+ *
+ * CGX Receive Status Register 11 This registers provides a count of
+ * packets dropped at the NCSI interface. This includes drops due to
+ * CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_DROP] or NCSI FIFO full. The count of
+ * dropped NCSI packets is not accounted for in any other stats
+ * registers.
+ */
+union cgxx_cmr_rx_stat11 {
+	u64 u;
+	struct cgxx_cmr_rx_stat11_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmr_rx_stat11_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STAT11(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STAT11(void)
+{
+	return 0xc8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat12
+ *
+ * CGX Receive Status Register 12 This register provide a count of octets
+ * of dropped at the NCSI interface.
+ */
+union cgxx_cmr_rx_stat12 {
+	u64 u;
+	struct cgxx_cmr_rx_stat12_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmr_rx_stat12_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STAT12(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STAT12(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat9
+ *
+ * CGX Receive Status Register 9 These registers provide a count of all
+ * received packets that were dropped by the DMAC1 or VLAN STEERING1
+ * filter. Packets that are dropped by the DMAC1 or VLAN STEERING1
+ * filters are counted here regardless of whether they were ERR packets,
+ * but does not include those reported in CGX()_CMR()_RX_STAT6. 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation or other means are not dropped by CGX (unless filter and
+ * decision is also asserted) and will never appear in this count. Should
+ * the MAC signal to the CMR that the packet be filtered upon decision
+ * before the end of packet, then STAT9 and STAT10 will not be updated.
+ */
+union cgxx_cmr_rx_stat9 {
+	u64 u;
+	struct cgxx_cmr_rx_stat9_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_cmr_rx_stat9_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STAT9(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STAT9(void)
+{
+	return 0xb8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering0#
+ *
+ * CGX CMR Receive Steering0 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE0(), provide eight filters for identifying
+ * and steering receive traffic to X2P/NIX. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR()_RX_DMAC_CTL0.  Internal:
+ * "* ALGORITHM \<pre\> rx_steering(uint48 pkt_dmac, uint16 pkt_etype,
+ * uint16 pkt_vlan_id) {    for (int i = 0; i \< 8; i++) {       steer =
+ * CGX()_CMR_RX_STEERING0(i);       vetype =
+ * CGX()_CMR_RX_STEERING_VETYPE0(i);       if (steer[MCST_EN] ||
+ * steer[DMAC_EN] || vetype[VLAN_EN] || vetype[VLAN_TAG_EN]) {
+ * // Filter is enabled.          if (   (!steer[MCST_EN] ||
+ * is_mcst(pkt_dmac))              && (!steer[DMAC_EN] || pkt_dmac ==
+ * steer[DMAC])              && (!vetype[VLAN_EN] || pkt_vlan_id ==
+ * vetype[VLAN_ID])              && (!vetype[VLAN_TAG_EN] || pkt_etype ==
+ * vetype[VLAN_ETYPE]) )          {             // Filter match (all
+ * enabled matching criteria are met).             return steer[PASS];
+ * }       }    }    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No
+ * match } \</pre\>"
+ */
+union cgxx_cmr_rx_steering0x {
+	u64 u;
+	struct cgxx_cmr_rx_steering0x_s {
+		u64 dmac                             : 48;
+		u64 dmac_en                          : 1;
+		u64 mcst_en                          : 1;
+		u64 pass                             : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cgxx_cmr_rx_steering0x_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING0X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING0X(u64 a)
+{
+	return 0x300 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering1#
+ *
+ * CGX CMR Receive Steering1 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE1(), provide eight filters for identifying
+ * and steering NCSI receive traffic. Received packets are only passed to
+ * NCSI when the DMAC1 filter result is ACCEPT and STEERING1 filter
+ * result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI.
+ * See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR_RX_STEERING0().
+ */
+union cgxx_cmr_rx_steering1x {
+	u64 u;
+	struct cgxx_cmr_rx_steering1x_s {
+		u64 dmac                             : 48;
+		u64 dmac_en                          : 1;
+		u64 mcst_en                          : 1;
+		u64 pass                             : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cgxx_cmr_rx_steering1x_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING1X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING1X(u64 a)
+{
+	return 0x500 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_default0
+ *
+ * CGX CMR Receive Steering Default0 Destination Register For determining
+ * destination of traffic that does not meet matching algorithm described
+ * in registers CGX()_CMR_RX_STEERING0() and
+ * CGX()_CMR_RX_STEERING_VETYPE0(). All 16B packets or smaller (20B in
+ * case of FCS strip) as the result of truncation will steer to default
+ * destination
+ */
+union cgxx_cmr_rx_steering_default0 {
+	u64 u;
+	struct cgxx_cmr_rx_steering_default0_s {
+		u64 pass                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmr_rx_steering_default0_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT0(void)
+{
+	return 0x3f0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_default1
+ *
+ * CGX CMR Receive Steering Default1 Destination Register For use with
+ * the lmac_id associated with NCSI. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. For determining destination of
+ * traffic that does not meet matching algorithm described in registers
+ * CGX()_CMR_RX_STEERING1() and CGX()_CMR_RX_STEERING_VETYPE1(). All 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation will steer to default destination
+ */
+union cgxx_cmr_rx_steering_default1 {
+	u64 u;
+	struct cgxx_cmr_rx_steering_default1_s {
+		u64 pass                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmr_rx_steering_default1_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT1(void)
+{
+	return 0x5e0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_vetype0#
+ *
+ * CGX CMR Receive VLAN Ethertype1 Register These registers, along with
+ * CGX()_CMR_RX_STEERING0(), provide eight filters for identifying and
+ * steering X2P/NIX receive traffic.
+ */
+union cgxx_cmr_rx_steering_vetype0x {
+	u64 u;
+	struct cgxx_cmr_rx_steering_vetype0x_s {
+		u64 vlan_etype                       : 16;
+		u64 vlan_tag_en                      : 1;
+		u64 vlan_id                          : 12;
+		u64 vlan_en                          : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cgxx_cmr_rx_steering_vetype0x_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+{
+	return 0x380 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_vetype1#
+ *
+ * CGX CMR Receive VLAN Ethertype1 Register For use with the lmac_id
+ * associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. These
+ * registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters
+ * for identifying and steering NCSI receive traffic.
+ */
+union cgxx_cmr_rx_steering_vetype1x {
+	u64 u;
+	struct cgxx_cmr_rx_steering_vetype1x_s {
+		u64 vlan_etype                       : 16;
+		u64 vlan_tag_en                      : 1;
+		u64 vlan_id                          : 12;
+		u64 vlan_en                          : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cgxx_cmr_rx_steering_vetype1x_s cn; */
+};
+
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+{
+	return 0x580 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_tx_lmacs
+ *
+ * CGX CMR Transmit Logical MACs Registers This register sets the number
+ * of LMACs allowed on the TX interface. The value is important for
+ * defining the partitioning of the transmit FIFO.
+ */
+union cgxx_cmr_tx_lmacs {
+	u64 u;
+	struct cgxx_cmr_tx_lmacs_s {
+		u64 lmacs                            : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cgxx_cmr_tx_lmacs_s cn; */
+};
+
+static inline u64 CGXX_CMR_TX_LMACS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_TX_LMACS(void)
+{
+	return 0x1000;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_x2p#_count
+ *
+ * CGX X2P Activity Register
+ */
+union cgxx_cmr_x2px_count {
+	u64 u;
+	struct cgxx_cmr_x2px_count_s {
+		u64 x2p_cnt                          : 64;
+	} s;
+	/* struct cgxx_cmr_x2px_count_s cn; */
+};
+
+static inline u64 CGXX_CMR_X2PX_COUNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMR_X2PX_COUNT(u64 a)
+{
+	return 0x170 + 0x1000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_const
+ *
+ * CGX CONST Registers This register contains constants for software
+ * discovery.
+ */
+union cgxx_const {
+	u64 u;
+	struct cgxx_const_s {
+		u64 tx_fifosz                        : 24;
+		u64 lmacs                            : 8;
+		u64 rx_fifosz                        : 24;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cgxx_const_s cn; */
+};
+
+static inline u64 CGXX_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CONST(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) cgx#_const1
+ *
+ * CGX CONST1 Registers This register contains constants for software
+ * discovery.
+ */
+union cgxx_const1 {
+	u64 u;
+	struct cgxx_const1_s {
+		u64 types                            : 11;
+		u64 res_types                        : 21;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_const1_s cn; */
+};
+
+static inline u64 CGXX_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CONST1(void)
+{
+	return 0x2008;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl0
+ *
+ * CGX GMP GMI RX Wake-on-LAN Control 0 Registers
+ */
+union cgxx_gmp_gmix_rx_wol_ctrl0 {
+	u64 u;
+	struct cgxx_gmp_gmix_rx_wol_ctrl0_s {
+		u64 dmac                             : 48;
+		u64 pswd_len                         : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cgxx_gmp_gmix_rx_wol_ctrl0_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+{
+	return 0x38a00 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl1
+ *
+ * CGX GMP GMI RX Wake-on-LAN Control 1 Registers
+ */
+union cgxx_gmp_gmix_rx_wol_ctrl1 {
+	u64 u;
+	struct cgxx_gmp_gmix_rx_wol_ctrl1_s {
+		u64 pswd                             : 64;
+	} s;
+	/* struct cgxx_gmp_gmix_rx_wol_ctrl1_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+{
+	return 0x38a08 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_tx_eee
+ *
+ * INTERNAL: CGX GMP GMI TX EEE Configure Registers  Reserved. Internal:
+ * These registers control when GMP GMI TX requests to enter or exist
+ * LPI. Those registers take effect only when EEE is supported and
+ * enabled for a given LMAC.
+ */
+union cgxx_gmp_gmix_tx_eee {
+	u64 u;
+	struct cgxx_gmp_gmix_tx_eee_s {
+		u64 idle_thresh                      : 28;
+		u64 reserved_28                      : 1;
+		u64 force_lpi                        : 1;
+		u64 wakeup                           : 1;
+		u64 auto_lpi                         : 1;
+		u64 idle_cnt                         : 28;
+		u64 tx_lpi                           : 1;
+		u64 tx_lpi_wait                      : 1;
+		u64 sync_status_lpi_enable           : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cgxx_gmp_gmix_tx_eee_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_TX_EEE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_TX_EEE(u64 a)
+{
+	return 0x38800 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_tx_eee_cfg1
+ *
+ * INTERNAL: CGX GMP GMI TX EEE Configure More Configuration Registers
+ * Reserved. Internal: Controls the GMP exiting of LPI and starting to
+ * send data.
+ */
+union cgxx_gmp_gmix_tx_eee_cfg1 {
+	u64 u;
+	struct cgxx_gmp_gmix_tx_eee_cfg1_s {
+		u64 wake2data_time                   : 24;
+		u64 reserved_24_35                   : 12;
+		u64 tx_eee_enable                    : 1;
+		u64 reserved_37_39                   : 3;
+		u64 sync2lpi_time                    : 21;
+		u64 reserved_61_63                   : 3;
+	} s;
+	struct cgxx_gmp_gmix_tx_eee_cfg1_cn {
+		u64 wake2data_time                   : 24;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tx_eee_enable                    : 1;
+		u64 reserved_37_39                   : 3;
+		u64 sync2lpi_time                    : 21;
+		u64 reserved_61_63                   : 3;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+{
+	return 0x38808 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int
+ *
+ * CGX GMP GMI RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
+ */
+union cgxx_gmp_gmix_wol_int {
+	u64 u;
+	struct cgxx_gmp_gmix_wol_int_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmix_wol_int_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_WOL_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_WOL_INT(u64 a)
+{
+	return 0x38a80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1c
+ *
+ * CGX GMP GMI RX WOL Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union cgxx_gmp_gmix_wol_int_ena_w1c {
+	u64 u;
+	struct cgxx_gmp_gmix_wol_int_ena_w1c_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmix_wol_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+{
+	return 0x38a90 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1s
+ *
+ * CGX GMP GMI RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cgxx_gmp_gmix_wol_int_ena_w1s {
+	u64 u;
+	struct cgxx_gmp_gmix_wol_int_ena_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmix_wol_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+{
+	return 0x38a98 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_w1s
+ *
+ * CGX GMP GMI RX WOL Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union cgxx_gmp_gmix_wol_int_w1s {
+	u64 u;
+	struct cgxx_gmp_gmix_wol_int_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmix_wol_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+{
+	return 0x38a88 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_prt#_cfg
+ *
+ * CGX GMP GMI LMAC Configuration Registers This register controls the
+ * configuration of the LMAC.
+ */
+union cgxx_gmp_gmi_prtx_cfg {
+	u64 u;
+	struct cgxx_gmp_gmi_prtx_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 speed                            : 1;
+		u64 duplex                           : 1;
+		u64 slottime                         : 1;
+		u64 reserved_4_7                     : 4;
+		u64 speed_msb                        : 1;
+		u64 reserved_9_11                    : 3;
+		u64 rx_idle                          : 1;
+		u64 tx_idle                          : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_gmp_gmi_prtx_cfg_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_PRTX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_PRTX_CFG(u64 a)
+{
+	return 0x38020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_decision
+ *
+ * CGX GMP Packet-Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by GMI, the L2 byte count is compared
+ * against [CNT]. In normal operation, the L2 header begins after the
+ * PREAMBLE + SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).  Internal:
+ * Notes: As each byte in a packet is received by GMI, the L2 byte count
+ * is compared against the [CNT].  The L2 byte count is the number of
+ * bytes from the beginning of the L2 header (DMAC).  In normal
+ * operation, the L2 header begins after the PREAMBLE+SFD
+ * (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any optional UDD skip data
+ * (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]). When
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are
+ * prepended to the packet and would require UDD skip length to account
+ * for them.  Full Duplex: _   L2 Size \<  [CNT] - Accept packet. No
+ * filtering is applied. _   L2 Size \>= [CNT] - Apply filter. Accept
+ * packet based on PAUSE packet filter.  Half Duplex: _   L2 Size \<
+ * [CNT] - Drop packet. Packet is unconditionally dropped. _   L2 Size
+ * \>= [CNT] - Accept packet.  where L2_size = MAX(0, total_packet_size -
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
+ * ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
+ */
+union cgxx_gmp_gmi_rxx_decision {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_decision_s {
+		u64 cnt                              : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cgxx_gmp_gmi_rxx_decision_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_DECISION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_DECISION(u64 a)
+{
+	return 0x38040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_frm_chk
+ *
+ * CGX GMP Frame Check Registers
+ */
+union cgxx_gmp_gmi_rxx_frm_chk {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_frm_chk_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 reserved_2                       : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 reserved_5_6                     : 2;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cgxx_gmp_gmi_rxx_frm_chk_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+{
+	return 0x38030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_frm_ctl
+ *
+ * CGX GMP Frame Control Registers This register controls the handling of
+ * the frames. The [CTL_BCK] and [CTL_DRP] bits control how the hardware
+ * handles incoming PAUSE packets. The most common modes of operation: _
+ * [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything. _ [CTL_BCK]
+ * = 0, [CTL_DRP] = 0: software sees all PAUSE frames. _ [CTL_BCK] = 0,
+ * [CTL_DRP] = 1: all PAUSE frames are completely ignored.  These control
+ * bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex
+ * mode. Since PAUSE packets only apply to full duplex operation, any
+ * PAUSE packet would constitute an exception which should be handled by
+ * the processing cores. PAUSE packets should not be forwarded.
+ * Internal: Notes: [PRE_STRP]: When [PRE_CHK] is set (indicating that
+ * the PREAMBLE will be sent), [PRE_STRP] determines if the PREAMBLE+SFD
+ * bytes are thrown away or sent to the Octane core as part of the
+ * packet. In either mode, the PREAMBLE+SFD bytes are not counted toward
+ * the packet size when checking against the MIN and MAX bounds.
+ * Furthermore, the bytes are skipped when locating the start of the L2
+ * header for DMAC and Control frame recognition.
+ */
+union cgxx_gmp_gmi_rxx_frm_ctl {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_frm_ctl_s {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 pre_free                         : 1;
+		u64 reserved_7_8                     : 2;
+		u64 pre_align                        : 1;
+		u64 null_dis                         : 1;
+		u64 reserved_11                      : 1;
+		u64 ptp_mode                         : 1;
+		u64 rx_fc_type                       : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	struct cgxx_gmp_gmi_rxx_frm_ctl_cn {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 pre_free                         : 1;
+		u64 reserved_7                       : 1;
+		u64 reserved_8                       : 1;
+		u64 pre_align                        : 1;
+		u64 null_dis                         : 1;
+		u64 reserved_11                      : 1;
+		u64 ptp_mode                         : 1;
+		u64 rx_fc_type                       : 1;
+		u64 reserved_14_63                   : 50;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+{
+	return 0x38028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_ifg
+ *
+ * CGX GMI Minimum Interframe-Gap Cycles Registers This register
+ * specifies the minimum number of interframe-gap (IFG) cycles between
+ * packets.
+ */
+union cgxx_gmp_gmi_rxx_ifg {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_ifg_s {
+		u64 ifg                              : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_gmp_gmi_rxx_ifg_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_IFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_IFG(u64 a)
+{
+	return 0x38058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int
+ *
+ * CGX GMP GMI RX Interrupt Registers These registers allow interrupts to
+ * be sent to the control processor. * Exception conditions \<10:0\> can
+ * also set the rcv/opcode in the received packet's work-queue entry.
+ * CGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which
+ * conditions set the error. In half duplex operation, the expectation is
+ * that collisions will appear as either MINERR or CAREXT errors.
+ * Internal: Notes: (1) exception conditions 10:0 can also set the
+ * rcv/opcode in the received packet's workQ entry.  The
+ * CGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask for
+ * configuring which conditions set the error.  (2) in half duplex
+ * operation, the expectation is that collisions will appear as either
+ * MINERR o r CAREXT errors.  (3) JABBER An RX jabber error indicates
+ * that a packet was received which is longer than the maximum allowed
+ * packet as defined by the system.  GMI will truncate the packet at the
+ * JABBER count. Failure to do so could lead to system instabilty.  (4)
+ * NIBERR This error is illegal at 1000Mbs speeds
+ * (CGX()_GMP_GMI_PRT()_CFG[SPEED]==0) and will never assert.  (5) MINERR
+ * total frame DA+SA+TL+DATA+PAD+FCS \< 64  (6) ALNERR Indicates that the
+ * packet received was not an integer number of bytes.  If FCS checking
+ * is enabled, ALNERR will only assert if the FCS is bad.  If FCS
+ * checking is disabled, ALNERR will assert in all non-integer frame
+ * cases.  (7) Collisions Collisions can only occur in half-duplex mode.
+ * A collision is assumed by the receiver when the slottime
+ * (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
+ * this will result in a frame \< SLOTTIME.  In 1000 mode, it could
+ * result either in frame \< SLOTTIME or a carrier extend error with the
+ * SLOTTIME.  These conditions are visible by... . transfer ended before
+ * slottime COLDET . carrier extend error           CAREXT  (A) LENERR
+ * Length errors occur when the received packet does not match the length
+ * field.  LENERR is only checked for packets between 64 and 1500 bytes.
+ * For untagged frames, the length must exact match.  For tagged frames
+ * the length or length+4 must match.  (B) PCTERR checks that the frame
+ * begins with a valid PREAMBLE sequence. Does not check the number of
+ * PREAMBLE cycles.  (C) OVRERR *DON'T PUT IN HRM* OVRERR is an
+ * architectural assertion check internal to GMI to make sure no
+ * assumption was violated.  In a correctly operating system, this
+ * interrupt can never fire. GMI has an internal arbiter which selects
+ * which of four ports to buffer in the main RX FIFO.  If we normally
+ * buffer eight bytes, then each port will typically push a tick every
+ * eight cycles if the packet interface is going as fast as possible.  If
+ * there are four ports, they push every two cycles.  So that's the
+ * assumption.  That the inbound module will always be able to consume
+ * the tick before another is produced.  If that doesn't happen that's
+ * when OVRERR will assert."
+ */
+union cgxx_gmp_gmi_rxx_int {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_int_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cgxx_gmp_gmi_rxx_int_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_INT(u64 a)
+{
+	return 0x38000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1c
+ *
+ * CGX GMP GMI RX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_gmp_gmi_rxx_int_ena_w1c {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_int_ena_w1c_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cgxx_gmp_gmi_rxx_int_ena_w1c_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+{
+	return 0x38010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1s
+ *
+ * CGX GMP GMI RX Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cgxx_gmp_gmi_rxx_int_ena_w1s {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_int_ena_w1s_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cgxx_gmp_gmi_rxx_int_ena_w1s_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+{
+	return 0x38018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_w1s
+ *
+ * CGX GMP GMI RX Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cgxx_gmp_gmi_rxx_int_w1s {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_int_w1s_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cgxx_gmp_gmi_rxx_int_w1s_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+{
+	return 0x38008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_jabber
+ *
+ * CGX GMP Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the GMI truncates.
+ */
+union cgxx_gmp_gmi_rxx_jabber {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_jabber_s {
+		u64 cnt                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_rxx_jabber_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_JABBER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_JABBER(u64 a)
+{
+	return 0x38038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_udd_skp
+ *
+ * CGX GMP GMI User-Defined Data Skip Registers This register specifies
+ * the amount of user-defined data (UDD) added before the start of the
+ * L2C data.  Internal: Notes: (1) The skip bytes are part of the packet
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field - if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame - even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering is the user desires.  (5)
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] must be 0 in half-duplex operation
+ * unless CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, then
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] will normally be 8.  (6) In all cases,
+ * the UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
+ */
+union cgxx_gmp_gmi_rxx_udd_skp {
+	u64 u;
+	struct cgxx_gmp_gmi_rxx_udd_skp_s {
+		u64 len                              : 7;
+		u64 reserved_7                       : 1;
+		u64 fcssel                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cgxx_gmp_gmi_rxx_udd_skp_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+{
+	return 0x38048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_smac#
+ *
+ * CGX GMI SMAC Registers
+ */
+union cgxx_gmp_gmi_smacx {
+	u64 u;
+	struct cgxx_gmp_gmi_smacx_s {
+		u64 smac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_gmp_gmi_smacx_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_SMACX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_SMACX(u64 a)
+{
+	return 0x38230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_append
+ *
+ * CGX GMI TX Append Control Registers
+ */
+union cgxx_gmp_gmi_txx_append {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_append_s {
+		u64 preamble                         : 1;
+		u64 pad                              : 1;
+		u64 fcs                              : 1;
+		u64 force_fcs                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_append_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_APPEND(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_APPEND(u64 a)
+{
+	return 0x38218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_burst
+ *
+ * CGX GMI TX Burst-Counter Registers
+ */
+union cgxx_gmp_gmi_txx_burst {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_burst_s {
+		u64 burst                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_burst_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_BURST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_BURST(u64 a)
+{
+	return 0x38228 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_ctl
+ *
+ * CGX GMI Transmit Control Registers
+ */
+union cgxx_gmp_gmi_txx_ctl {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_ctl_s {
+		u64 xscol_en                         : 1;
+		u64 xsdef_en                         : 1;
+		u64 tx_fc_type                       : 1;
+		u64 link_drain                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_ctl_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_CTL(u64 a)
+{
+	return 0x38270 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int
+ *
+ * CGX GMI TX Interrupt Registers
+ */
+union cgxx_gmp_gmi_txx_int {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_int_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cgxx_gmp_gmi_txx_int_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_INT(u64 a)
+{
+	return 0x38500 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1c
+ *
+ * CGX GMI TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_gmp_gmi_txx_int_ena_w1c {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_int_ena_w1c_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cgxx_gmp_gmi_txx_int_ena_w1c_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+{
+	return 0x38510 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1s
+ *
+ * CGX GMI TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cgxx_gmp_gmi_txx_int_ena_w1s {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_int_ena_w1s_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cgxx_gmp_gmi_txx_int_ena_w1s_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+{
+	return 0x38518 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_w1s
+ *
+ * CGX GMI TX Interrupt Set Registers This register sets interrupt bits.
+ */
+union cgxx_gmp_gmi_txx_int_w1s {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_int_w1s_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cgxx_gmp_gmi_txx_int_w1s_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+{
+	return 0x38508 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_min_pkt
+ *
+ * CGX GMI TX Minimum-Size-Packet Registers
+ */
+union cgxx_gmp_gmi_txx_min_pkt {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_min_pkt_s {
+		u64 min_size                         : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_min_pkt_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+{
+	return 0x38240 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_interval
+ *
+ * CGX GMI TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent. Internal: Notes: Choosing
+ * proper values of CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME] and
+ * CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to
+ * the system designer.  It is suggested that TIME be much greater than
+ * INTERVAL and CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] be set.  This allows
+ * a periodic refresh of the PAUSE count and then when the backpressure
+ * condition is lifted, a PAUSE packet with TIME==0 will be sent
+ * indicating that Octane is ready for additional data.  If the system
+ * chooses to not set CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND], then it is
+ * suggested that TIME and INTERVAL are programmed such that they
+ * satisify the following rule:  _ INTERVAL \<= TIME - (largest_pkt_size
+ * + IFG + pause_pkt_size)  where largest_pkt_size is that largest packet
+ * that the system can send (normally 1518B), IFG is the interframe gap
+ * and pause_pkt_size is the size of the PAUSE packet (normally 64B).
+ */
+union cgxx_gmp_gmi_txx_pause_pkt_interval {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_pause_pkt_interval_s {
+		u64 interval                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_pause_pkt_interval_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+{
+	return 0x38248 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_time
+ *
+ * CGX GMI TX PAUSE Packet PAUSE-Time Registers
+ */
+union cgxx_gmp_gmi_txx_pause_pkt_time {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_pause_pkt_time_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_pause_pkt_time_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+{
+	return 0x38238 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_togo
+ *
+ * CGX GMI TX Time-to-Backpressure Registers
+ */
+union cgxx_gmp_gmi_txx_pause_togo {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_pause_togo_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_pause_togo_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+{
+	return 0x38258 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_zero
+ *
+ * CGX GMI TX PAUSE-Zero-Enable Registers
+ */
+union cgxx_gmp_gmi_txx_pause_zero {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_pause_zero_s {
+		u64 send                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_pause_zero_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+{
+	return 0x38260 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_sgmii_ctl
+ *
+ * CGX SGMII Control Registers
+ */
+union cgxx_gmp_gmi_txx_sgmii_ctl {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_sgmii_ctl_s {
+		u64 align                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_sgmii_ctl_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+{
+	return 0x38300 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_slot
+ *
+ * CGX GMI TX Slottime Counter Registers
+ */
+union cgxx_gmp_gmi_txx_slot {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_slot_s {
+		u64 slot                             : 10;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_slot_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_SLOT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_SLOT(u64 a)
+{
+	return 0x38220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_soft_pause
+ *
+ * CGX GMI TX Software PAUSE Registers
+ */
+union cgxx_gmp_gmi_txx_soft_pause {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_soft_pause_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_soft_pause_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+{
+	return 0x38250 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_thresh
+ *
+ * CGX GMI TX Threshold Registers
+ */
+union cgxx_gmp_gmi_txx_thresh {
+	u64 u;
+	struct cgxx_gmp_gmi_txx_thresh_s {
+		u64 cnt                              : 11;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cgxx_gmp_gmi_txx_thresh_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TXX_THRESH(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TXX_THRESH(u64 a)
+{
+	return 0x38210 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_col_attempt
+ *
+ * CGX TX Collision Attempts Before Dropping Frame Registers
+ */
+union cgxx_gmp_gmi_tx_col_attempt {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_col_attempt_s {
+		u64 limit                            : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_col_attempt_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+{
+	return 0x39010;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_ifg
+ *
+ * CGX GMI TX Interframe-Gap Cycles Registers Consider the following when
+ * programming IFG1 and IFG2: * For 10/100/1000 Mb/s half-duplex systems
+ * that require IEEE 802.3 compatibility, IFG1 must be in the range of
+ * 1-8, [IFG2] must be in the range of 4-12, and the [IFG1] + [IFG2] sum
+ * must be 12. * For 10/100/1000 Mb/s full-duplex systems that require
+ * IEEE 802.3 compatibility, IFG1 must be in the range of 1-11, [IFG2]
+ * must be in the range of 1-11, and the [IFG1] + [IFG2] sum must be 12.
+ * For all other systems, IFG1 and IFG2 can be any value in the range of
+ * 1-15, allowing for a total possible IFG sum of 2-30.
+ */
+union cgxx_gmp_gmi_tx_ifg {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_ifg_s {
+		u64 ifg1                             : 4;
+		u64 ifg2                             : 4;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_ifg_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_IFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_IFG(void)
+{
+	return 0x39000;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_jam
+ *
+ * CGX GMI TX JAM Pattern Registers This register provides the pattern
+ * used in JAM bytes.
+ */
+union cgxx_gmp_gmi_tx_jam {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_jam_s {
+		u64 jam                              : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_jam_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_JAM(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_JAM(void)
+{
+	return 0x39008;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_lfsr
+ *
+ * CGX GMI TX LFSR Registers This register shows the contents of the
+ * linear feedback shift register (LFSR), which is used to implement
+ * truncated binary exponential backoff.
+ */
+union cgxx_gmp_gmi_tx_lfsr {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_lfsr_s {
+		u64 lfsr                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_lfsr_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_LFSR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_LFSR(void)
+{
+	return 0x39028;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_dmac
+ *
+ * CGX TX PAUSE-Packet DMAC-Field Registers
+ */
+union cgxx_gmp_gmi_tx_pause_pkt_dmac {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_pause_pkt_dmac_s {
+		u64 dmac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_pause_pkt_dmac_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+{
+	return 0x39018;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_type
+ *
+ * CGX GMI TX PAUSE-Packet-PTYPE Field Registers This register provides
+ * the PTYPE field that is placed in outbound PAUSE packets.
+ */
+union cgxx_gmp_gmi_tx_pause_pkt_type {
+	u64 u;
+	struct cgxx_gmp_gmi_tx_pause_pkt_type_s {
+		u64 ptype                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_gmi_tx_pause_pkt_type_s cn; */
+};
+
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+{
+	return 0x39020;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_misc#_cfg
+ *
+ * CGX GMP PCS Miscellaneous Control Registers This register contains
+ * general configuration that should not need to be changed from reset
+ * settings.  Internal: Per lmac diagnostic and chicken bits.
+ */
+union cgxx_gmp_miscx_cfg {
+	u64 u;
+	struct cgxx_gmp_miscx_cfg_s {
+		u64 tx_eee_quiet_credit_mode         : 1;
+		u64 tx_eee_wait_gmi_fast_idle        : 1;
+		u64 tx_qsgmii_port0_init             : 1;
+		u64 tx_eee_rx_sync_status_enable     : 1;
+		u64 pcs_alt_an                       : 1;
+		u64 reserved_5_7                     : 3;
+		u64 rx_pcs_sync_signal_detect        : 1;
+		u64 rx_pcs_sync_timeout              : 1;
+		u64 rx_pcs_eee_mode_enable           : 1;
+		u64 rx_pcs_lpi_enable                : 1;
+		u64 rx_pcs_802_rx_k                  : 1;
+		u64 rx_pcs_alt_qlb2i                 : 1;
+		u64 reserved_14_15                   : 2;
+		u64 rx_cgp_gser_throttle             : 1;
+		u64 rx_cgp_edet_filter               : 1;
+		u64 rx_cgp_edet_qlm_val              : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cgxx_gmp_miscx_cfg_s cn; */
+};
+
+static inline u64 CGXX_GMP_MISCX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_MISCX_CFG(u64 a)
+{
+	return 0x34000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_expansion
+ *
+ * CGX GMP PCS AN Expansion register Register 6 AN status
+ */
+union cgxx_gmp_pcsx_an_expansion {
+	u64 u;
+	struct cgxx_gmp_pcsx_an_expansion_s {
+		u64 reserved_0                       : 1;
+		u64 page_received                    : 1;
+		u64 next_page_able                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cgxx_gmp_pcsx_an_expansion_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+{
+	return 0x30a60 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_lp_abil_np
+ *
+ * CGX GMP PCS AN Link Partner Ability Next Page Register 8 This register
+ * contains the advertised ability of the link partners Next Page. The
+ * definition for this register is provided in 32.5.4.2 for changes to
+ * 28.2.4.1.4.
+ */
+union cgxx_gmp_pcsx_an_lp_abil_np {
+	u64 u;
+	struct cgxx_gmp_pcsx_an_lp_abil_np_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcsx_an_lp_abil_np_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+{
+	return 0x30a80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_np_tx
+ *
+ * CGX GMP PCS AN Next Page Transmit Register 7 Software programs this
+ * register with the contents of the AN message next page or unformatted
+ * next page link code word to be transmitted during autonegotiation.
+ * Next page exchange occurs after the base link code words have been
+ * exchanged if either end of the link segment sets the NP bit to 1,
+ * indicating that it has at least one next page to send. Once initiated,
+ * next page exchange continues until both ends of the link segment set
+ * their NP bits to 0. Both sides must be NP capable to use NP exchanges.
+ */
+union cgxx_gmp_pcsx_an_np_tx {
+	u64 u;
+	struct cgxx_gmp_pcsx_an_np_tx_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcsx_an_np_tx_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+{
+	return 0x30a70 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_dbg_control
+ *
+ * CGX PCS Debug Control Registers
+ */
+union cgxx_gmp_pcsx_dbg_control {
+	u64 u;
+	struct cgxx_gmp_pcsx_dbg_control_s {
+		u64 us_clk_period                    : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_gmp_pcsx_dbg_control_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+{
+	return 0x31000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_rx_eee_wake
+ *
+ * INTERNAL: CGX GMP PCS  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: This register is used by PHY types that support EEE to count
+ * wake time faults where the PHY fails to complete its normal wake
+ * sequence within the time required for the specific PHY type. The
+ * definition of the fault event to be counted is defined for each PHY
+ * and may occur during a refresh or a wake-up as defined by the PHY.
+ * This 16-bit counter shall be reset to all zeros upon execution of the
+ * PCS reset. This counter shall be held at all ones in the case of
+ * overflow.
+ */
+union cgxx_gmp_pcsx_rx_eee_wake {
+	u64 u;
+	struct cgxx_gmp_pcsx_rx_eee_wake_s {
+		u64 error_counter                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcsx_rx_eee_wake_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+{
+	return 0x30910 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_rx_lpi_timing
+ *
+ * INTERNAL: CGX GMP PCS  RX EEE LPI Timing Parameters Registers
+ * Reserved. Internal: Receiver LPI timing parameters Tqr, Twr and Twtf.
+ */
+union cgxx_gmp_pcsx_rx_lpi_timing {
+	u64 u;
+	struct cgxx_gmp_pcsx_rx_lpi_timing_s {
+		u64 twtf                             : 18;
+		u64 reserved_18_19                   : 2;
+		u64 twr                              : 12;
+		u64 tqr                              : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cgxx_gmp_pcsx_rx_lpi_timing_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+{
+	return 0x30900 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_status1
+ *
+ * CGX GMP PCS Status 1 Register PCS LPI Status, Link OK.  Register 3.1
+ */
+union cgxx_gmp_pcsx_status1 {
+	u64 u;
+	struct cgxx_gmp_pcsx_status1_s {
+		u64 reserved_0_1                     : 2;
+		u64 receive_link_status              : 1;
+		u64 reserved_3_7                     : 5;
+		u64 rx_lpi_indication                : 1;
+		u64 tx_lpi_indication                : 1;
+		u64 rx_lpi_received                  : 1;
+		u64 tx_lpi_received                  : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cgxx_gmp_pcsx_status1_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_STATUS1(u64 a)
+{
+	return 0x30880 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_tx_lpi_timing
+ *
+ * INTERNAL: CGX GMP GMI  TX EEE LPI Timing Parameters Registers
+ * Reserved. Internal: Transmitter LPI timing parameters Tsl, Tql and
+ * Tul.
+ */
+union cgxx_gmp_pcsx_tx_lpi_timing {
+	u64 u;
+	struct cgxx_gmp_pcsx_tx_lpi_timing_s {
+		u64 tql                              : 19;
+		u64 reserved_19_31                   : 13;
+		u64 tul                              : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tsl                              : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cgxx_gmp_pcsx_tx_lpi_timing_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+{
+	return 0x30800 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_adv
+ *
+ * CGX GMP PCS Autonegotiation Advertisement Registers
+ */
+union cgxx_gmp_pcs_anx_adv {
+	u64 u;
+	struct cgxx_gmp_pcs_anx_adv_s {
+		u64 reserved_0_4                     : 5;
+		u64 fd                               : 1;
+		u64 hfd                              : 1;
+		u64 pause                            : 2;
+		u64 reserved_9_11                    : 3;
+		u64 rem_flt                          : 2;
+		u64 reserved_14                      : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_anx_adv_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_ANX_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_ANX_ADV(u64 a)
+{
+	return 0x30010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_ext_st
+ *
+ * CGX GMO PCS Autonegotiation Extended Status Registers
+ */
+union cgxx_gmp_pcs_anx_ext_st {
+	u64 u;
+	struct cgxx_gmp_pcs_anx_ext_st_s {
+		u64 reserved_0_11                    : 12;
+		u64 thou_thd                         : 1;
+		u64 thou_tfd                         : 1;
+		u64 thou_xhd                         : 1;
+		u64 thou_xfd                         : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_anx_ext_st_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+{
+	return 0x30028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_lp_abil
+ *
+ * CGX GMP PCS Autonegotiation Link Partner Ability Registers This is the
+ * autonegotiation link partner ability register 5 as per IEEE 802.3,
+ * Clause 37.
+ */
+union cgxx_gmp_pcs_anx_lp_abil {
+	u64 u;
+	struct cgxx_gmp_pcs_anx_lp_abil_s {
+		u64 reserved_0_4                     : 5;
+		u64 fd                               : 1;
+		u64 hfd                              : 1;
+		u64 pause                            : 2;
+		u64 reserved_9_11                    : 3;
+		u64 rem_flt                          : 2;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_anx_lp_abil_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+{
+	return 0x30018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_results
+ *
+ * CGX GMP PCS Autonegotiation Results Registers This register is not
+ * valid when CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
+ * CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 0 and
+ * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is
+ * valid.
+ */
+union cgxx_gmp_pcs_anx_results {
+	u64 u;
+	struct cgxx_gmp_pcs_anx_results_s {
+		u64 link_ok                          : 1;
+		u64 dup                              : 1;
+		u64 an_cpt                           : 1;
+		u64 spd                              : 2;
+		u64 pause                            : 2;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_gmp_pcs_anx_results_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+{
+	return 0x30020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#
+ *
+ * CGX GMP PCS Interrupt Registers
+ */
+union cgxx_gmp_pcs_intx {
+	u64 u;
+	struct cgxx_gmp_pcs_intx_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cgxx_gmp_pcs_intx_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_INTX(u64 a)
+{
+	return 0x30080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_ena_w1c
+ *
+ * CGX GMP PCS Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_gmp_pcs_intx_ena_w1c {
+	u64 u;
+	struct cgxx_gmp_pcs_intx_ena_w1c_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cgxx_gmp_pcs_intx_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+{
+	return 0x30090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_ena_w1s
+ *
+ * CGX GMP PCS Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cgxx_gmp_pcs_intx_ena_w1s {
+	u64 u;
+	struct cgxx_gmp_pcs_intx_ena_w1s_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cgxx_gmp_pcs_intx_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+{
+	return 0x30098 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_w1s
+ *
+ * CGX GMP PCS Interrupt Set Registers This register sets interrupt bits.
+ */
+union cgxx_gmp_pcs_intx_w1s {
+	u64 u;
+	struct cgxx_gmp_pcs_intx_w1s_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cgxx_gmp_pcs_intx_w1s_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_INTX_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_INTX_W1S(u64 a)
+{
+	return 0x30088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_link#_timer
+ *
+ * CGX GMP PCS Link Timer Registers This is the 1.6 ms nominal link timer
+ * register.
+ */
+union cgxx_gmp_pcs_linkx_timer {
+	u64 u;
+	struct cgxx_gmp_pcs_linkx_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_linkx_timer_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+{
+	return 0x30040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_misc#_ctl
+ *
+ * CGX GMP SGMII Miscellaneous Control Registers Internal: SGMII bit [12]
+ * is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate
+ * SGMII or 1000Base-X modes.  Note: The SGMII AN Advertisement Register
+ * above will be sent during Auto Negotiation if [MAC_PHY] is set (1=PHY
+ * mode). If the bit is not set (0=MAC mode), the tx_Config_Reg\<14\>
+ * becomes ACK bit and tx_Config_Reg\<0\> is always 1. All other bits in
+ * tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation
+ * results.
+ */
+union cgxx_gmp_pcs_miscx_ctl {
+	u64 u;
+	struct cgxx_gmp_pcs_miscx_ctl_s {
+		u64 samp_pt                          : 7;
+		u64 an_ovrd                          : 1;
+		u64 mode                             : 1;
+		u64 mac_phy                          : 1;
+		u64 loopbck2                         : 1;
+		u64 gmxeno                           : 1;
+		u64 reserved_12                      : 1;
+		u64 disp_en                          : 1;
+		u64 reserved_14_15                   : 2;
+		u64 qsgmii_comma_wd                  : 16;
+		u64 qsgmii_comma_wd_en               : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct cgxx_gmp_pcs_miscx_ctl_cn {
+		u64 samp_pt                          : 7;
+		u64 an_ovrd                          : 1;
+		u64 mode                             : 1;
+		u64 mac_phy                          : 1;
+		u64 loopbck2                         : 1;
+		u64 gmxeno                           : 1;
+		u64 reserved_12                      : 1;
+		u64 disp_en                          : 1;
+		u64 reserved_14_15                   : 2;
+		u64 qsgmii_comma_wd                  : 16;
+		u64 qsgmii_comma_wd_en               : 1;
+		u64 reserved_33_35                   : 3;
+		u64 reserved_36_63                   : 28;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_PCS_MISCX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_MISCX_CTL(u64 a)
+{
+	return 0x30078 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_mr#_control
+ *
+ * CGX GMP PCS Control Registers
+ */
+union cgxx_gmp_pcs_mrx_control {
+	u64 u;
+	struct cgxx_gmp_pcs_mrx_control_s {
+		u64 reserved_0_4                     : 5;
+		u64 uni                              : 1;
+		u64 spdmsb                           : 1;
+		u64 coltst                           : 1;
+		u64 dup                              : 1;
+		u64 rst_an                           : 1;
+		u64 reserved_10                      : 1;
+		u64 pwr_dn                           : 1;
+		u64 an_en                            : 1;
+		u64 spdlsb                           : 1;
+		u64 loopbck1                         : 1;
+		u64 reset                            : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_mrx_control_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+{
+	return 0x30000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_mr#_status
+ *
+ * CGX GMP PCS Status Registers Bits \<15:9\> in this register indicate
+ * the ability to operate when CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set
+ * to MAC mode. Bits \<15:9\> are always read as 0, indicating that the
+ * chip cannot operate in the corresponding modes. The field [RM_FLT] is
+ * a 'don't care' when the selected mode is SGMII/QSGMII.
+ */
+union cgxx_gmp_pcs_mrx_status {
+	u64 u;
+	struct cgxx_gmp_pcs_mrx_status_s {
+		u64 extnd                            : 1;
+		u64 reserved_1                       : 1;
+		u64 lnk_st                           : 1;
+		u64 an_abil                          : 1;
+		u64 rm_flt                           : 1;
+		u64 an_cpt                           : 1;
+		u64 prb_sup                          : 1;
+		u64 reserved_7                       : 1;
+		u64 ext_st                           : 1;
+		u64 hun_t2hd                         : 1;
+		u64 hun_t2fd                         : 1;
+		u64 ten_hd                           : 1;
+		u64 ten_fd                           : 1;
+		u64 hun_xhd                          : 1;
+		u64 hun_xfd                          : 1;
+		u64 hun_t4                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_mrx_status_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_MRX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_MRX_STATUS(u64 a)
+{
+	return 0x30008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_rx#_states
+ *
+ * CGX GMP PCS RX State-Machines States Registers
+ */
+union cgxx_gmp_pcs_rxx_states {
+	u64 u;
+	struct cgxx_gmp_pcs_rxx_states_s {
+		u64 an_st                            : 4;
+		u64 an_bad                           : 1;
+		u64 sync                             : 4;
+		u64 sync_bad                         : 1;
+		u64 rx_st                            : 5;
+		u64 rx_bad                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_rxx_states_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_RXX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_RXX_STATES(u64 a)
+{
+	return 0x30058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_rx#_sync
+ *
+ * CGX GMP PCS Code Group Synchronization Registers
+ */
+union cgxx_gmp_pcs_rxx_sync {
+	u64 u;
+	struct cgxx_gmp_pcs_rxx_sync_s {
+		u64 bit_lock                         : 1;
+		u64 sync                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_gmp_pcs_rxx_sync_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_RXX_SYNC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_RXX_SYNC(u64 a)
+{
+	return 0x30050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_sgm#_an_adv
+ *
+ * CGX GMP PCS SGMII Autonegotiation Advertisement Registers This is the
+ * SGMII autonegotiation advertisement register (sent out as
+ * tx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37). This
+ * register is sent during autonegotiation if
+ * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is
+ * not set (0 = MAC mode), then tx_Config_Reg\<14\> becomes ACK bit and
+ * tx_Config_Reg\<0\> is always 1. All other bits in tx_Config_Reg sent
+ * will be 0. The PHY dictates the autonegotiation results.
+ */
+union cgxx_gmp_pcs_sgmx_an_adv {
+	u64 u;
+	struct cgxx_gmp_pcs_sgmx_an_adv_s {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13                      : 1;
+		u64 ack                              : 1;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_gmp_pcs_sgmx_an_adv_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+{
+	return 0x30068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_sgm#_lp_adv
+ *
+ * CGX GMP PCS SGMII Link-Partner-Advertisement Registers This is the
+ * SGMII link partner advertisement register (received as
+ * rx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37).
+ */
+union cgxx_gmp_pcs_sgmx_lp_adv {
+	u64 u;
+	struct cgxx_gmp_pcs_sgmx_lp_adv_s {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13_14                   : 2;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	struct cgxx_gmp_pcs_sgmx_lp_adv_cn {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13                      : 1;
+		u64 reserved_14                      : 1;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+{
+	return 0x30070 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_tx#_states
+ *
+ * CGX GMP PCS TX State-Machines States Registers
+ */
+union cgxx_gmp_pcs_txx_states {
+	u64 u;
+	struct cgxx_gmp_pcs_txx_states_s {
+		u64 ord_st                           : 4;
+		u64 tx_bad                           : 1;
+		u64 xmit                             : 2;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_gmp_pcs_txx_states_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_TXX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_TXX_STATES(u64 a)
+{
+	return 0x30060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_tx_rx#_polarity
+ *
+ * CGX GMP PCS TX/RX Polarity Registers
+ * CGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed
+ * on the link receive path after code group synchronization is achieved.
+ * When LMAC_TYPE=QSGMII, only lane 0 polarity data and settings are
+ * relevant and settings for lanes 1, 2 and 3 are unused.
+ */
+union cgxx_gmp_pcs_tx_rxx_polarity {
+	u64 u;
+	struct cgxx_gmp_pcs_tx_rxx_polarity_s {
+		u64 txplrt                           : 1;
+		u64 rxplrt                           : 1;
+		u64 autorxpl                         : 1;
+		u64 rxovrd                           : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_gmp_pcs_tx_rxx_polarity_s cn; */
+};
+
+static inline u64 CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+{
+	return 0x30048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_pba#
+ *
+ * CGX MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table, the bit number is indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cgxx_msix_pbax {
+	u64 u;
+	struct cgxx_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cgxx_msix_pbax_s cn; */
+};
+
+static inline u64 CGXX_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_vec#_addr
+ *
+ * CGX MSI-X Vector Table Address Registers This register is the MSI-X
+ * vector table, indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cgxx_msix_vecx_addr {
+	u64 u;
+	struct cgxx_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cgxx_msix_vecx_addr_s cn; */
+};
+
+static inline u64 CGXX_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_vec#_ctl
+ *
+ * CGX MSI-X Vector Table Control and Data Registers This register is the
+ * MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cgxx_msix_vecx_ctl {
+	u64 u;
+	struct cgxx_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cgxx_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 CGXX_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_bp_test
+ *
+ * INTERNAL: CGX SMU TX Backpressure Test Registers
+ */
+union cgxx_smux_bp_test {
+	u64 u;
+	struct cgxx_smux_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_47                   : 24;
+		u64 enable                           : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cgxx_smux_bp_test_s cn; */
+};
+
+static inline u64 CGXX_SMUX_BP_TEST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_BP_TEST(u64 a)
+{
+	return 0x20230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_cbfc_ctl
+ *
+ * CGX SMU PFC Control Registers Internal: INTERNAL: XOFF for a specific
+ * class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
+ * ([LOGL_EN]\<i\> & cmr_rx_logl_xoff\<i\>).
+ */
+union cgxx_smux_cbfc_ctl {
+	u64 u;
+	struct cgxx_smux_cbfc_ctl_s {
+		u64 rx_en                            : 1;
+		u64 tx_en                            : 1;
+		u64 drp_en                           : 1;
+		u64 bck_en                           : 1;
+		u64 reserved_4_31                    : 28;
+		u64 logl_en                          : 16;
+		u64 phys_en                          : 16;
+	} s;
+	/* struct cgxx_smux_cbfc_ctl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_CBFC_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_CBFC_CTL(u64 a)
+{
+	return 0x20218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_ctrl
+ *
+ * CGX SMU Control Registers
+ */
+union cgxx_smux_ctrl {
+	u64 u;
+	struct cgxx_smux_ctrl_s {
+		u64 rx_idle                          : 1;
+		u64 tx_idle                          : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_smux_ctrl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_CTRL(u64 a)
+{
+	return 0x20200 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_ext_loopback
+ *
+ * CGX SMU External Loopback Registers In loopback mode, the IFG1+IFG2 of
+ * local and remote parties must match exactly; otherwise loopback FIFO
+ * will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
+ */
+union cgxx_smux_ext_loopback {
+	u64 u;
+	struct cgxx_smux_ext_loopback_s {
+		u64 thresh                           : 6;
+		u64 reserved_6_7                     : 2;
+		u64 depth                            : 6;
+		u64 reserved_14_15                   : 2;
+		u64 en                               : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cgxx_smux_ext_loopback_s cn; */
+};
+
+static inline u64 CGXX_SMUX_EXT_LOOPBACK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_EXT_LOOPBACK(u64 a)
+{
+	return 0x20208 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_hg2_control
+ *
+ * CGX SMU HiGig2 Control Registers HiGig2 TX- and RX-enable are normally
+ * set together for HiGig2 messaging. Setting just the TX or RX bit
+ * results in only the HG2 message transmit or receive capability.
+ * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure
+ * to NIX as per the received HiGig2 message. Setting these fields to 0
+ * disables link PAUSE and backpressure to NIX in response to received
+ * messages.  CGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig)
+ * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
+ * CGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
+ * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
+ * CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set and
+ * CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to 0 (to forcibly disable
+ * hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
+ * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated by
+ * CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16.)
+ * Hardware can only autogenerate backpressure via HiGig2 messages
+ * (optionally, when [HG2TX_EN] = 1) with the HiGig2 protocol.
+ */
+union cgxx_smux_hg2_control {
+	u64 u;
+	struct cgxx_smux_hg2_control_s {
+		u64 logl_en                          : 16;
+		u64 phys_en                          : 1;
+		u64 hg2rx_en                         : 1;
+		u64 hg2tx_en                         : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cgxx_smux_hg2_control_s cn; */
+};
+
+static inline u64 CGXX_SMUX_HG2_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_HG2_CONTROL(u64 a)
+{
+	return 0x20210 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_mmsi_ctl_sta
+ *
+ * CGX SMU MAC Merge Service Interface (MMSI) Control/Status Registers
+ * MMSI control and status registers for frame preemption mode. Refer to
+ * IEEE 802.3br, Clause 99.
+ */
+union cgxx_smux_mmsi_ctl_sta {
+	u64 u;
+	struct cgxx_smux_mmsi_ctl_sta_s {
+		u64 p_en                             : 1;
+		u64 dis_v                            : 1;
+		u64 afs                              : 2;
+		u64 v_sta                            : 3;
+		u64 tx_pactive                       : 1;
+		u64 reserved_8_31                    : 24;
+		u64 v_time                           : 24;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cgxx_smux_mmsi_ctl_sta_s cn; */
+};
+
+static inline u64 CGXX_SMUX_MMSI_CTL_STA(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_MMSI_CTL_STA(u64 a)
+{
+	return 0x20220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_ctrl
+ *
+ * CGX SMU RX Bad Column High Registers
+ */
+union cgxx_smux_rx_bad_col_ctrl {
+	u64 u;
+	struct cgxx_smux_rx_bad_col_ctrl_s {
+		u64 lane_rxc                         : 16;
+		u64 state                            : 3;
+		u64 val                              : 1;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cgxx_smux_rx_bad_col_ctrl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+{
+	return 0x20060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_data_hi
+ *
+ * CGX SMU RX Bad Column Low Registers
+ */
+union cgxx_smux_rx_bad_col_data_hi {
+	u64 u;
+	struct cgxx_smux_rx_bad_col_data_hi_s {
+		u64 lane_rxd                         : 64;
+	} s;
+	/* struct cgxx_smux_rx_bad_col_data_hi_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+{
+	return 0x20058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_data_lo
+ *
+ * CGX SMU RX Bad Column Low Registers
+ */
+union cgxx_smux_rx_bad_col_data_lo {
+	u64 u;
+	struct cgxx_smux_rx_bad_col_data_lo_s {
+		u64 lane_rxd                         : 64;
+	} s;
+	/* struct cgxx_smux_rx_bad_col_data_lo_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+{
+	return 0x20050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_ctl
+ *
+ * CGX SMU RX Control Registers
+ */
+union cgxx_smux_rx_ctl {
+	u64 u;
+	struct cgxx_smux_rx_ctl_s {
+		u64 status                           : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_smux_rx_ctl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_CTL(u64 a)
+{
+	return 0x20048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_decision
+ *
+ * CGX SMU Packet Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by CGX, the L2 byte count (i.e. the
+ * number of bytes from the beginning of the L2 header (DMAC)) is
+ * compared against CNT. In normal operation, the L2 header begins after
+ * the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (CGX()_SMU()_RX_UDD_SKP[LEN]).
+ */
+union cgxx_smux_rx_decision {
+	u64 u;
+	struct cgxx_smux_rx_decision_s {
+		u64 cnt                              : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cgxx_smux_rx_decision_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_DECISION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_DECISION(u64 a)
+{
+	return 0x20038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_frm_chk
+ *
+ * CGX SMU RX Frame Check Registers The CSRs provide the enable bits for
+ * a subset of errors passed to CMR encoded.
+ */
+union cgxx_smux_rx_frm_chk {
+	u64 u;
+	struct cgxx_smux_rx_frm_chk_s {
+		u64 reserved_0_2                     : 3;
+		u64 jabber                           : 1;
+		u64 fcserr_d                         : 1;
+		u64 fcserr_c                         : 1;
+		u64 reserved_6                       : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cgxx_smux_rx_frm_chk_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_FRM_CHK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_FRM_CHK(u64 a)
+{
+	return 0x20028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_frm_ctl
+ *
+ * CGX SMU RX Frame Control Registers This register controls the handling
+ * of the frames. The [CTL_BCK] and [CTL_DRP] bits control how the
+ * hardware handles incoming PAUSE packets. The most common modes of
+ * operation: _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames _
+ * [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
+ * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in
+ * half-duplex mode. Since PAUSE packets only apply to full duplex
+ * operation, any PAUSE packet would constitute an exception which should
+ * be handled by the processing cores. PAUSE packets should not be
+ * forwarded.
+ */
+union cgxx_smux_rx_frm_ctl {
+	u64 u;
+	struct cgxx_smux_rx_frm_ctl_s {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 reserved_6_11                    : 6;
+		u64 ptp_mode                         : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cgxx_smux_rx_frm_ctl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_FRM_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_FRM_CTL(u64 a)
+{
+	return 0x20020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int
+ *
+ * CGX SMU Receive Interrupt Registers SMU Interrupt Register. Internal:
+ * Exception conditions \<9\> and \<4:0\> can also set the rcv/opcode in
+ * the received packet's work queue entry. CGX()_SMU()_RX_FRM_CHK
+ * provides a bit mask for configuring which conditions set the error.
+ */
+union cgxx_smux_rx_int {
+	u64 u;
+	struct cgxx_smux_rx_int_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_smux_rx_int_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_INT(u64 a)
+{
+	return 0x20000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_ena_w1c
+ *
+ * CGX SMU Receive Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_smux_rx_int_ena_w1c {
+	u64 u;
+	struct cgxx_smux_rx_int_ena_w1c_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_smux_rx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+{
+	return 0x20010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_ena_w1s
+ *
+ * CGX SMU Receive Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cgxx_smux_rx_int_ena_w1s {
+	u64 u;
+	struct cgxx_smux_rx_int_ena_w1s_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_smux_rx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+{
+	return 0x20018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_w1s
+ *
+ * CGX SMU Receive Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cgxx_smux_rx_int_w1s {
+	u64 u;
+	struct cgxx_smux_rx_int_w1s_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_smux_rx_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_INT_W1S(u64 a)
+{
+	return 0x20008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_jabber
+ *
+ * CGX SMU Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the SMU truncates. Internal:
+ * JABBER[CNT] is checked against the packet that arrives from SPU.  The
+ * checking is performed before preamble is stripped or PTP is inserted.
+ * If present, preamble is counted as eight bytes of the incoming packet.
+ */
+union cgxx_smux_rx_jabber {
+	u64 u;
+	struct cgxx_smux_rx_jabber_s {
+		u64 cnt                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_rx_jabber_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_JABBER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_JABBER(u64 a)
+{
+	return 0x20030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_udd_skp
+ *
+ * CGX SMU User-Defined Data Skip Registers Internal: (1) The skip bytes
+ * are part of the packet and will be sent down the NCB packet interface
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering if the user desires.  (5) In all cases, the
+ * UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
+ */
+union cgxx_smux_rx_udd_skp {
+	u64 u;
+	struct cgxx_smux_rx_udd_skp_s {
+		u64 len                              : 7;
+		u64 reserved_7                       : 1;
+		u64 fcssel                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cgxx_smux_rx_udd_skp_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_UDD_SKP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_UDD_SKP(u64 a)
+{
+	return 0x20040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_ctrl0
+ *
+ * CGX SMU RX Wake-on-LAN Control 0 Registers
+ */
+union cgxx_smux_rx_wol_ctrl0 {
+	u64 u;
+	struct cgxx_smux_rx_wol_ctrl0_s {
+		u64 dmac                             : 48;
+		u64 pswd_len                         : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cgxx_smux_rx_wol_ctrl0_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+{
+	return 0x20068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_ctrl1
+ *
+ * CGX SMU RX Wake-on-LAN Control 1 Registers
+ */
+union cgxx_smux_rx_wol_ctrl1 {
+	u64 u;
+	struct cgxx_smux_rx_wol_ctrl1_s {
+		u64 pswd                             : 64;
+	} s;
+	/* struct cgxx_smux_rx_wol_ctrl1_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+{
+	return 0x20070 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int
+ *
+ * CGX SMU RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
+ */
+union cgxx_smux_rx_wol_int {
+	u64 u;
+	struct cgxx_smux_rx_wol_int_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_smux_rx_wol_int_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_INT(u64 a)
+{
+	return 0x20078 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1c
+ *
+ * CGX SMU RX WOL Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_smux_rx_wol_int_ena_w1c {
+	u64 u;
+	struct cgxx_smux_rx_wol_int_ena_w1c_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_smux_rx_wol_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+{
+	return 0x20088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1s
+ *
+ * CGX SMU RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cgxx_smux_rx_wol_int_ena_w1s {
+	u64 u;
+	struct cgxx_smux_rx_wol_int_ena_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_smux_rx_wol_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+{
+	return 0x20090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_w1s
+ *
+ * CGX SMU RX WOL Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cgxx_smux_rx_wol_int_w1s {
+	u64 u;
+	struct cgxx_smux_rx_wol_int_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_smux_rx_wol_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+{
+	return 0x20080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_smac
+ *
+ * CGX SMU SMAC Registers
+ */
+union cgxx_smux_smac {
+	u64 u;
+	struct cgxx_smux_smac_s {
+		u64 smac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_smux_smac_s cn; */
+};
+
+static inline u64 CGXX_SMUX_SMAC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_SMAC(u64 a)
+{
+	return 0x20108 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_append
+ *
+ * CGX SMU TX Append Control Registers For more details on the
+ * interactions between FCS and PAD, see also the description of
+ * CGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
+ */
+union cgxx_smux_tx_append {
+	u64 u;
+	struct cgxx_smux_tx_append_s {
+		u64 preamble                         : 1;
+		u64 pad                              : 1;
+		u64 fcs_d                            : 1;
+		u64 fcs_c                            : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_smux_tx_append_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_APPEND(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_APPEND(u64 a)
+{
+	return 0x20100 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_ctl
+ *
+ * CGX SMU Transmit Control Registers
+ */
+union cgxx_smux_tx_ctl {
+	u64 u;
+	struct cgxx_smux_tx_ctl_s {
+		u64 dic_en                           : 1;
+		u64 uni_en                           : 1;
+		u64 x4a_dis                          : 1;
+		u64 mia_en                           : 1;
+		u64 ls                               : 2;
+		u64 ls_byp                           : 1;
+		u64 l2p_bp_conv                      : 1;
+		u64 hg_en                            : 1;
+		u64 hg_pause_hgi                     : 2;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cgxx_smux_tx_ctl_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_CTL(u64 a)
+{
+	return 0x20178 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_dack
+ *
+ * CGX SMU TX Drop Counters Registers
+ */
+union cgxx_smux_tx_dack {
+	u64 u;
+	struct cgxx_smux_tx_dack_s {
+		u64 dpi_sdrop_ack                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_tx_dack_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_DACK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_DACK(u64 a)
+{
+	return 0x201b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_dcnt
+ *
+ * CGX SMU TX Drop Counters Registers
+ */
+union cgxx_smux_tx_dcnt {
+	u64 u;
+	struct cgxx_smux_tx_dcnt_s {
+		u64 dpi_sdrop_cnt                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_tx_dcnt_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_DCNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_DCNT(u64 a)
+{
+	return 0x201a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee
+ *
+ * INTERNAL: CGX SMU TX EEE Configure Registers  Resvered. Internal:
+ * These registers control when SMU TX requests to enter or exist LPI.
+ * Those registers take effect only when EEE is supported and enabled for
+ * a given LMAC.
+ */
+union cgxx_smux_tx_eee {
+	u64 u;
+	struct cgxx_smux_tx_eee_s {
+		u64 idle_thresh                      : 28;
+		u64 reserved_28                      : 1;
+		u64 force_lpi                        : 1;
+		u64 wakeup                           : 1;
+		u64 auto_lpi                         : 1;
+		u64 idle_cnt                         : 28;
+		u64 reserved_60_61                   : 2;
+		u64 tx_lpi_wake                      : 1;
+		u64 tx_lpi                           : 1;
+	} s;
+	/* struct cgxx_smux_tx_eee_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_EEE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_EEE(u64 a)
+{
+	return 0x20190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee_timer_status
+ *
+ * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers  Reserved. Internal:
+ * These registers configure SMU TX EEE timing parameters.
+ */
+union cgxx_smux_tx_eee_timer_status {
+	u64 u;
+	struct cgxx_smux_tx_eee_timer_status_s {
+		u64 lpi_wake_cnt                     : 16;
+		u64 reserved_16_30                   : 15;
+		u64 wake_timer_done                  : 1;
+		u64 link_ok_cnt                      : 30;
+		u64 reserved_62                      : 1;
+		u64 link_timer_done                  : 1;
+	} s;
+	/* struct cgxx_smux_tx_eee_timer_status_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+{
+	return 0x201a0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee_timing
+ *
+ * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers  Reserved.
+ * Internal: These registers configure SMU TX EEE timing parameters.
+ */
+union cgxx_smux_tx_eee_timing {
+	u64 u;
+	struct cgxx_smux_tx_eee_timing_s {
+		u64 w_sys_tx_min                     : 16;
+		u64 reserved_16_31                   : 16;
+		u64 link_ok_min                      : 30;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cgxx_smux_tx_eee_timing_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_EEE_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_EEE_TIMING(u64 a)
+{
+	return 0x20198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_ifg
+ *
+ * CGX SMU TX Interframe-Gap Cycles Registers Programming IFG1 and IFG2:
+ * * For XAUI/RXAUI/10G/25G/40G/50G/100G systems that require IEEE 802.3
+ * compatibility, the [IFG1]+[IFG2] sum must be 12. * In loopback mode,
+ * the [IFG1]+[IFG2] of local and remote parties must match exactly;
+ * otherwise loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW]. *
+ * When CGX()_SMU()_TX_CTL[DIC_EN] is set, [IFG1]+[IFG2] sum must be at
+ * least 8. The behavior of smaller values is un-determined. * When
+ * CGX()_SMU()_TX_CTL[DIC_EN] is cleared, the minimum value of
+ * [IFG1]+[IFG2] is 1 for 40G/50G/100G LMAC_TYPE configurations and 5 for
+ * all other values. The behavior of smaller values is un-determined.
+ * Internal: When CGX()_SMU()_TX_CTL[DIC_EN] is set, SMU TX treats
+ * ([IFG1]+[IFG2]) \< 8 as 8 for 40G/50G/100G MACs and ([IFG1]+[IFG2]) \<
+ * 8 as 8 for other MACs. When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU
+ * TX can work correctly with any IFG1 and IFG2.
+ */
+union cgxx_smux_tx_ifg {
+	u64 u;
+	struct cgxx_smux_tx_ifg_s {
+		u64 ifg1                             : 4;
+		u64 ifg2                             : 4;
+		u64 mia_amt                          : 2;
+		u64 reserved_10_15                   : 6;
+		u64 mia_cnt                          : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cgxx_smux_tx_ifg_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_IFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_IFG(u64 a)
+{
+	return 0x20160 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int
+ *
+ * CGX SMU TX Interrupt Registers
+ */
+union cgxx_smux_tx_int {
+	u64 u;
+	struct cgxx_smux_tx_int_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_smux_tx_int_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_INT(u64 a)
+{
+	return 0x20140 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_ena_w1c
+ *
+ * CGX SMU TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_smux_tx_int_ena_w1c {
+	u64 u;
+	struct cgxx_smux_tx_int_ena_w1c_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_smux_tx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+{
+	return 0x20150 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_ena_w1s
+ *
+ * CGX SMU TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cgxx_smux_tx_int_ena_w1s {
+	u64 u;
+	struct cgxx_smux_tx_int_ena_w1s_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_smux_tx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+{
+	return 0x20158 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_w1s
+ *
+ * CGX SMU TX Interrupt Set Registers This register sets interrupt bits.
+ */
+union cgxx_smux_tx_int_w1s {
+	u64 u;
+	struct cgxx_smux_tx_int_w1s_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_smux_tx_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_INT_W1S(u64 a)
+{
+	return 0x20148 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_min_pkt
+ *
+ * CGX SMU TX Minimum-Size-Packet Registers Internal: [MIN_SIZE] less
+ * than 16 will be ignored by hardware which will use 16 instead.
+ */
+union cgxx_smux_tx_min_pkt {
+	u64 u;
+	struct cgxx_smux_tx_min_pkt_s {
+		u64 min_size                         : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cgxx_smux_tx_min_pkt_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_MIN_PKT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_MIN_PKT(u64 a)
+{
+	return 0x20118 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_dmac
+ *
+ * CGX SMU TX PAUSE-Packet DMAC-Field Registers This register provides
+ * the DMAC value that is placed in outbound PAUSE packets.
+ */
+union cgxx_smux_tx_pause_pkt_dmac {
+	u64 u;
+	struct cgxx_smux_tx_pause_pkt_dmac_s {
+		u64 dmac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_smux_tx_pause_pkt_dmac_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+{
+	return 0x20168 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_interval
+ *
+ * CGX SMU TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent.
+ */
+union cgxx_smux_tx_pause_pkt_interval {
+	u64 u;
+	struct cgxx_smux_tx_pause_pkt_interval_s {
+		u64 interval                         : 16;
+		u64 hg2_intra_interval               : 16;
+		u64 hg2_intra_en                     : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cgxx_smux_tx_pause_pkt_interval_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+{
+	return 0x20120 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_time
+ *
+ * CGX SMU TX PAUSE Packet Time Registers
+ */
+union cgxx_smux_tx_pause_pkt_time {
+	u64 u;
+	struct cgxx_smux_tx_pause_pkt_time_s {
+		u64 p_time                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_tx_pause_pkt_time_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+{
+	return 0x20110 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_type
+ *
+ * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers This register provides
+ * the P_TYPE field that is placed in outbound PAUSE packets.
+ */
+union cgxx_smux_tx_pause_pkt_type {
+	u64 u;
+	struct cgxx_smux_tx_pause_pkt_type_s {
+		u64 p_type                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_tx_pause_pkt_type_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+{
+	return 0x20170 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_togo
+ *
+ * CGX SMU TX Time-to-Backpressure Registers
+ */
+union cgxx_smux_tx_pause_togo {
+	u64 u;
+	struct cgxx_smux_tx_pause_togo_s {
+		u64 p_time                           : 16;
+		u64 msg_time                         : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_smux_tx_pause_togo_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+{
+	return 0x20130 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_zero
+ *
+ * CGX SMU TX PAUSE Zero Registers
+ */
+union cgxx_smux_tx_pause_zero {
+	u64 u;
+	struct cgxx_smux_tx_pause_zero_s {
+		u64 send                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_smux_tx_pause_zero_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+{
+	return 0x20138 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_soft_pause
+ *
+ * CGX SMU TX Soft PAUSE Registers
+ */
+union cgxx_smux_tx_soft_pause {
+	u64 u;
+	struct cgxx_smux_tx_soft_pause_s {
+		u64 p_time                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_smux_tx_soft_pause_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+{
+	return 0x20128 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_thresh
+ *
+ * CGX SMU TX Threshold Registers
+ */
+union cgxx_smux_tx_thresh {
+	u64 u;
+	struct cgxx_smux_tx_thresh_s {
+		u64 cnt                              : 12;
+		u64 reserved_12_15                   : 4;
+		u64 dpi_thresh                       : 5;
+		u64 reserved_21_23                   : 3;
+		u64 dpi_depth                        : 5;
+		u64 reserved_29_31                   : 3;
+		u64 ecnt                             : 12;
+		u64 reserved_44_63                   : 20;
+	} s;
+	/* struct cgxx_smux_tx_thresh_s cn; */
+};
+
+static inline u64 CGXX_SMUX_TX_THRESH(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SMUX_TX_THRESH(u64 a)
+{
+	return 0x20180 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_adv
+ *
+ * CGX SPU Autonegotiation Advertisement Registers Software programs this
+ * register with the contents of the AN-link code word base page to be
+ * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for
+ * details.) Any write operations to this register prior to completion of
+ * autonegotiation, as indicated by CGX()_SPU()_AN_STATUS[AN_COMPLETE],
+ * should be followed by a renegotiation in order for the new values to
+ * take effect. Renegotiation is initiated by setting
+ * CGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has
+ * completed, software can examine this register along with
+ * CGX()_SPU()_AN_LP_BASE to determine the highest common denominator
+ * technology.
+ */
+union cgxx_spux_an_adv {
+	u64 u;
+	struct cgxx_spux_an_adv_s {
+		u64 s                                : 5;
+		u64 e                                : 5;
+		u64 pause                            : 1;
+		u64 asm_dir                          : 1;
+		u64 xnp_able                         : 1;
+		u64 rf                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 t                                : 5;
+		u64 a1g_kx                           : 1;
+		u64 a10g_kx4                         : 1;
+		u64 a10g_kr                          : 1;
+		u64 a40g_kr4                         : 1;
+		u64 a40g_cr4                         : 1;
+		u64 a100g_cr10                       : 1;
+		u64 a100g_kp4                        : 1;
+		u64 a100g_kr4                        : 1;
+		u64 a100g_cr4                        : 1;
+		u64 a25g_krs_crs                     : 1;
+		u64 a25g_kr_cr                       : 1;
+		u64 arsv                             : 12;
+		u64 a25g_rs_fec_req                  : 1;
+		u64 a25g_br_fec_req                  : 1;
+		u64 fec_able                         : 1;
+		u64 fec_req                          : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_spux_an_adv_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_ADV(u64 a)
+{
+	return 0x10198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_bp_status
+ *
+ * CGX SPU Autonegotiation Backplane Ethernet & BASE-R Copper Status
+ * Registers The contents of this register are updated during
+ * autonegotiation and are valid when CGX()_SPU()_AN_STATUS[AN_COMPLETE]
+ * is set. At that time, one of the port type bits will be set depending
+ * on the AN priority resolution. The port types are listed in order of
+ * decreasing priority. If a BASE-R type is negotiated then [FEC] or
+ * [RS_FEC] will be set to indicate whether/which FEC operation has been
+ * negotiated and will be clear otherwise.
+ */
+union cgxx_spux_an_bp_status {
+	u64 u;
+	struct cgxx_spux_an_bp_status_s {
+		u64 bp_an_able                       : 1;
+		u64 n1g_kx                           : 1;
+		u64 n10g_kx4                         : 1;
+		u64 n10g_kr                          : 1;
+		u64 n25g_kr1                         : 1;
+		u64 n25g_cr1                         : 1;
+		u64 n25g_krs_crs                     : 1;
+		u64 n25g_kr_cr                       : 1;
+		u64 n40g_kr4                         : 1;
+		u64 n40g_cr4                         : 1;
+		u64 n50g_kr2                         : 1;
+		u64 n50g_cr2                         : 1;
+		u64 n100g_cr10                       : 1;
+		u64 n100g_kp4                        : 1;
+		u64 n100g_kr4                        : 1;
+		u64 n100g_cr4                        : 1;
+		u64 fec                              : 1;
+		u64 rs_fec                           : 1;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cgxx_spux_an_bp_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_BP_STATUS(u64 a)
+{
+	return 0x101b8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_control
+ *
+ * CGX SPU Autonegotiation Control Registers
+ */
+union cgxx_spux_an_control {
+	u64 u;
+	struct cgxx_spux_an_control_s {
+		u64 reserved_0_8                     : 9;
+		u64 an_restart                       : 1;
+		u64 reserved_10_11                   : 2;
+		u64 an_en                            : 1;
+		u64 xnp_en                           : 1;
+		u64 reserved_14                      : 1;
+		u64 an_reset                         : 1;
+		u64 an_arb_link_chk_en               : 1;
+		u64 usx_an_arb_link_chk_en           : 1;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cgxx_spux_an_control_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_CONTROL(u64 a)
+{
+	return 0x10188 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_lp_base
+ *
+ * CGX SPU Autonegotiation Link-Partner Base-Page Ability Registers This
+ * register captures the contents of the latest AN link code word base
+ * page received from the link partner during autonegotiation. (See IEEE
+ * 802.3 section 73.6 for details.) CGX()_SPU()_AN_STATUS[PAGE_RX] is set
+ * when this register is updated by hardware.
+ */
+union cgxx_spux_an_lp_base {
+	u64 u;
+	struct cgxx_spux_an_lp_base_s {
+		u64 s                                : 5;
+		u64 e                                : 5;
+		u64 pause                            : 1;
+		u64 asm_dir                          : 1;
+		u64 xnp_able                         : 1;
+		u64 rf                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 t                                : 5;
+		u64 a1g_kx                           : 1;
+		u64 a10g_kx4                         : 1;
+		u64 a10g_kr                          : 1;
+		u64 a40g_kr4                         : 1;
+		u64 a40g_cr4                         : 1;
+		u64 a100g_cr10                       : 1;
+		u64 a100g_kp4                        : 1;
+		u64 a100g_kr4                        : 1;
+		u64 a100g_cr4                        : 1;
+		u64 a25g_krs_crs                     : 1;
+		u64 a25g_kr_cr                       : 1;
+		u64 arsv                             : 12;
+		u64 a25g_rs_fec_req                  : 1;
+		u64 a25g_br_fec_req                  : 1;
+		u64 fec_able                         : 1;
+		u64 fec_req                          : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_spux_an_lp_base_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_LP_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_LP_BASE(u64 a)
+{
+	return 0x101a0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_lp_xnp
+ *
+ * CGX SPU Autonegotiation Link Partner Extended Next Page Ability
+ * Registers This register captures the contents of the latest next page
+ * code word received from the link partner during autonegotiation, if
+ * any. See IEEE 802.3 section 73.7.7 for details.
+ */
+union cgxx_spux_an_lp_xnp {
+	u64 u;
+	struct cgxx_spux_an_lp_xnp_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 u                                : 32;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_spux_an_lp_xnp_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_LP_XNP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_LP_XNP(u64 a)
+{
+	return 0x101b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_status
+ *
+ * CGX SPU Autonegotiation Status Registers
+ */
+union cgxx_spux_an_status {
+	u64 u;
+	struct cgxx_spux_an_status_s {
+		u64 lp_an_able                       : 1;
+		u64 reserved_1                       : 1;
+		u64 link_status                      : 1;
+		u64 an_able                          : 1;
+		u64 rmt_flt                          : 1;
+		u64 an_complete                      : 1;
+		u64 page_rx                          : 1;
+		u64 xnp_stat                         : 1;
+		u64 reserved_8                       : 1;
+		u64 prl_flt                          : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cgxx_spux_an_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_STATUS(u64 a)
+{
+	return 0x10190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_xnp_tx
+ *
+ * CGX SPU Autonegotiation Extended Next Page Transmit Registers Software
+ * programs this register with the contents of the AN message next page
+ * or unformatted next page link code word to be transmitted during
+ * autonegotiation. Next page exchange occurs after the base link code
+ * words have been exchanged if either end of the link segment sets the
+ * NP bit to 1, indicating that it has at least one next page to send.
+ * Once initiated, next page exchange continues until both ends of the
+ * link segment set their NP bits to 0. See IEEE 802.3 section 73.7.7 for
+ * details.
+ */
+union cgxx_spux_an_xnp_tx {
+	u64 u;
+	struct cgxx_spux_an_xnp_tx_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 u                                : 32;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cgxx_spux_an_xnp_tx_s cn; */
+};
+
+static inline u64 CGXX_SPUX_AN_XNP_TX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_AN_XNP_TX(u64 a)
+{
+	return 0x101a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_algn_status
+ *
+ * CGX SPU Multilane BASE-R PCS Alignment-Status Registers This register
+ * implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4
+ * registers (3.50-3.53). It is valid only when the LPCS type is
+ * 40GBASE-R, 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE] =
+ * CGX_LMAC_TYPES_E::FORTYG_R,FIFTYG_R,HUNDREDG_R), and always returns
+ * 0x0 for all other LPCS types. Service interfaces (lanes) 19-0 (100G)
+ * and 3-0 (all others) are mapped to PCS lanes 19-0 or 3-0 via
+ * CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. For 100G, logical lane 0 fans
+ * out to service interfaces 0-4, logical lane 1 fans out to service
+ * interfaces 5-9, ... etc. For all other modes, logical lanes and
+ * service interfaces are identical. Logical interfaces (lanes) map to
+ * SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
+ */
+union cgxx_spux_br_algn_status {
+	u64 u;
+	struct cgxx_spux_br_algn_status_s {
+		u64 block_lock                       : 20;
+		u64 reserved_20_29                   : 10;
+		u64 alignd                           : 1;
+		u64 reserved_31_40                   : 10;
+		u64 marker_lock                      : 20;
+		u64 reserved_61_63                   : 3;
+	} s;
+	/* struct cgxx_spux_br_algn_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+{
+	return 0x10050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_lane_map#
+ *
+ * CGX SPU 40,50,100GBASE-R Lane-Mapping Registers This register
+ * implements the IEEE 802.3 lane 0-19 mapping registers (3.400-3.403).
+ * It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
+ * 100GBASE-R, USXGMII (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
+ * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each
+ * programmed PCS lane (called service interface in 802.3) is valid when
+ * that lane has achieved alignment marker lock on the receive side (i.e.
+ * the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is
+ * invalid otherwise. When valid, it returns the actual detected receive
+ * PCS lane number based on the received alignment marker contents
+ * received on that service interface.  In RS-FEC mode the LNx_MAPPING
+ * field is valid when that lane has achieved alignment marker lock on
+ * the receive side (i.e. the associated
+ * CGX(0..3)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid
+ * otherwise. When valid, it returns the actual detected receive FEC lane
+ * number based on the received alignment marker contents received on
+ * that logical lane therefore expect for RS-FEC that LNx_MAPPING = x.
+ * The mapping is flexible because IEEE 802.3 allows multilane BASE-R
+ * receive lanes to be re-ordered. Note that for the transmit side, each
+ * logical lane is mapped to a physical SerDes lane based on the
+ * programming of CGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
+ * CGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the logical lane to physical
+ * SerDes lane mapping, and this register specifies the service interface
+ * (or lane) to PCS lane mapping.
+ */
+union cgxx_spux_br_lane_mapx {
+	u64 u;
+	struct cgxx_spux_br_lane_mapx_s {
+		u64 ln_mapping                       : 6;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_spux_br_lane_mapx_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+{
+	return 0x10600 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_control
+ *
+ * CGX SPU BASE-R PMD Control Registers
+ */
+union cgxx_spux_br_pmd_control {
+	u64 u;
+	struct cgxx_spux_br_pmd_control_s {
+		u64 train_restart                    : 1;
+		u64 train_en                         : 1;
+		u64 use_lane_poly                    : 1;
+		u64 max_wait_disable                 : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	struct cgxx_spux_br_pmd_control_cn96xx {
+		u64 train_restart                    : 1;
+		u64 train_en                         : 1;
+		u64 use_lane_poly                    : 1;
+		u64 reserved_3_63                    : 61;
+	} cn96xx;
+	/* struct cgxx_spux_br_pmd_control_cn96xx cn98xx; */
+	/* struct cgxx_spux_br_pmd_control_s cnf95xxp1; */
+	/* struct cgxx_spux_br_pmd_control_cn96xx cnf95xxp2; */
+	/* struct cgxx_spux_br_pmd_control_cn96xx loki; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+{
+	return 0x100a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_ld_cup
+ *
+ * CGX SPU BASE-R PMD Local Device Coefficient Update Registers This
+ * register implements MDIO register 1.154 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1300-1.1303 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. When link training is in progress, each field
+ * reflects the contents of the coefficient update field in the
+ * associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
+ */
+union cgxx_spux_br_pmd_ld_cup {
+	u64 u;
+	struct cgxx_spux_br_pmd_ld_cup_s {
+		u64 ln0_cup                          : 16;
+		u64 ln1_cup                          : 16;
+		u64 ln2_cup                          : 16;
+		u64 ln3_cup                          : 16;
+	} s;
+	/* struct cgxx_spux_br_pmd_ld_cup_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+{
+	return 0x100c8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_ld_rep
+ *
+ * CGX SPU BASE-R PMD Local Device Status Report Registers This register
+ * implements MDIO register 1.155 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1400-1.1403 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. Each field reflects the contents of the status
+ * report field in the associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
+ */
+union cgxx_spux_br_pmd_ld_rep {
+	u64 u;
+	struct cgxx_spux_br_pmd_ld_rep_s {
+		u64 ln0_rep                          : 16;
+		u64 ln1_rep                          : 16;
+		u64 ln2_rep                          : 16;
+		u64 ln3_rep                          : 16;
+	} s;
+	/* struct cgxx_spux_br_pmd_ld_rep_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+{
+	return 0x100d0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_lp_cup
+ *
+ * CGX SPU BASE-R PMD Link Partner Coefficient Update Registers This
+ * register implements MDIO register 1.152 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1100-1.1103 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
+ */
+union cgxx_spux_br_pmd_lp_cup {
+	u64 u;
+	struct cgxx_spux_br_pmd_lp_cup_s {
+		u64 ln0_cup                          : 16;
+		u64 ln1_cup                          : 16;
+		u64 ln2_cup                          : 16;
+		u64 ln3_cup                          : 16;
+	} s;
+	/* struct cgxx_spux_br_pmd_lp_cup_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+{
+	return 0x100b8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_lp_rep
+ *
+ * CGX SPU BASE-R PMD Link Partner Status Report Registers This register
+ * implements MDIO register 1.153 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1200-1.1203 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
+ */
+union cgxx_spux_br_pmd_lp_rep {
+	u64 u;
+	struct cgxx_spux_br_pmd_lp_rep_s {
+		u64 ln0_rep                          : 16;
+		u64 ln1_rep                          : 16;
+		u64 ln2_rep                          : 16;
+		u64 ln3_rep                          : 16;
+	} s;
+	/* struct cgxx_spux_br_pmd_lp_rep_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+{
+	return 0x100c0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_status
+ *
+ * CGX SPU BASE-R PMD Status Registers The lane fields in this register
+ * are indexed by logical PCS lane ID. The lane 0 field (LN0_*) is valid
+ * for 10GBASE-R, 25GBASE-R, 40GBASE-R, 50GBASE-R and 100GBASE-R. The
+ * lane 1 field (LN1_*) is valid for 40GBASE-R, 50GBASE-R and 100GBASE-R.
+ * The remaining fields (LN2_*, LN3_*) are only valid for 40GBASE-R and
+ * 100GBASE-R.
+ */
+union cgxx_spux_br_pmd_status {
+	u64 u;
+	struct cgxx_spux_br_pmd_status_s {
+		u64 ln0_train_status                 : 4;
+		u64 ln1_train_status                 : 4;
+		u64 ln2_train_status                 : 4;
+		u64 ln3_train_status                 : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_br_pmd_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_PMD_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_PMD_STATUS(u64 a)
+{
+	return 0x100b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_status1
+ *
+ * CGX SPU BASE-R Status 1 Registers
+ */
+union cgxx_spux_br_status1 {
+	u64 u;
+	struct cgxx_spux_br_status1_s {
+		u64 blk_lock                         : 1;
+		u64 hi_ber                           : 1;
+		u64 prbs31                           : 1;
+		u64 prbs9                            : 1;
+		u64 reserved_4_11                    : 8;
+		u64 rcv_lnk                          : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cgxx_spux_br_status1_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_STATUS1(u64 a)
+{
+	return 0x10030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_status2
+ *
+ * CGX SPU BASE-R Status 2 Registers This register implements a
+ * combination of the following IEEE 802.3 registers: * BASE-R PCS status
+ * 2 (MDIO address 3.33). * BASE-R BER high-order counter (MDIO address
+ * 3.44). * Errored-blocks high-order counter (MDIO address 3.45).  Note
+ * that the relative locations of some fields have been moved from IEEE
+ * 802.3 in order to make the register layout more software friendly: the
+ * BER counter high-order and low-order bits from sections 3.44 and 3.33
+ * have been combined into the contiguous, 22-bit [BER_CNT] field;
+ * likewise, the errored-blocks counter high-order and low-order bits
+ * from section 3.45 have been combined into the contiguous, 22-bit
+ * [ERR_BLKS] field.
+ */
+union cgxx_spux_br_status2 {
+	u64 u;
+	struct cgxx_spux_br_status2_s {
+		u64 reserved_0_13                    : 14;
+		u64 latched_ber                      : 1;
+		u64 latched_lock                     : 1;
+		u64 ber_cnt                          : 22;
+		u64 reserved_38_39                   : 2;
+		u64 err_blks                         : 22;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cgxx_spux_br_status2_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_STATUS2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_STATUS2(u64 a)
+{
+	return 0x10038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_control
+ *
+ * CGX SPU BASE-R Test-Pattern Control Registers Refer to the test
+ * pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cgxx_spux_br_tp_control {
+	u64 u;
+	struct cgxx_spux_br_tp_control_s {
+		u64 dp_sel                           : 1;
+		u64 tp_sel                           : 1;
+		u64 rx_tp_en                         : 1;
+		u64 tx_tp_en                         : 1;
+		u64 prbs31_tx                        : 1;
+		u64 prbs31_rx                        : 1;
+		u64 prbs9_tx                         : 1;
+		u64 scramble_tp                      : 2;
+		u64 pr_tp_data_type                  : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cgxx_spux_br_tp_control_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_TP_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_TP_CONTROL(u64 a)
+{
+	return 0x10040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_err_cnt
+ *
+ * CGX SPU BASE-R Test-Pattern Error-Count Registers This register
+ * provides the BASE-R PCS test-pattern error counter.
+ */
+union cgxx_spux_br_tp_err_cnt {
+	u64 u;
+	struct cgxx_spux_br_tp_err_cnt_s {
+		u64 err_cnt                          : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_br_tp_err_cnt_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+{
+	return 0x10048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_seed_a
+ *
+ * CGX SPU BASE-R Test-Pattern Seed A Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cgxx_spux_br_tp_seed_a {
+	u64 u;
+	struct cgxx_spux_br_tp_seed_a_s {
+		u64 tp_seed_a                        : 58;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct cgxx_spux_br_tp_seed_a_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_TP_SEED_A(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_TP_SEED_A(u64 a)
+{
+	return 0x10060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_seed_b
+ *
+ * CGX SPU BASE-R Test-Pattern Seed B Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cgxx_spux_br_tp_seed_b {
+	u64 u;
+	struct cgxx_spux_br_tp_seed_b_s {
+		u64 tp_seed_b                        : 58;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct cgxx_spux_br_tp_seed_b_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BR_TP_SEED_B(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BR_TP_SEED_B(u64 a)
+{
+	return 0x10068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_bx_status
+ *
+ * CGX SPU BASE-X Status Registers
+ */
+union cgxx_spux_bx_status {
+	u64 u;
+	struct cgxx_spux_bx_status_s {
+		u64 lsync                            : 4;
+		u64 reserved_4_10                    : 7;
+		u64 pattst                           : 1;
+		u64 alignd                           : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cgxx_spux_bx_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_BX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_BX_STATUS(u64 a)
+{
+	return 0x10028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_control1
+ *
+ * CGX SPU Control 1 Registers
+ */
+union cgxx_spux_control1 {
+	u64 u;
+	struct cgxx_spux_control1_s {
+		u64 reserved_0_1                     : 2;
+		u64 spd                              : 4;
+		u64 spdsel0                          : 1;
+		u64 reserved_7_10                    : 4;
+		u64 lo_pwr                           : 1;
+		u64 reserved_12                      : 1;
+		u64 spdsel1                          : 1;
+		u64 loopbck                          : 1;
+		u64 reset                            : 1;
+		u64 usxgmii_type                     : 3;
+		u64 usxgmii_rate                     : 3;
+		u64 disable_am                       : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	struct cgxx_spux_control1_cn96xxp1 {
+		u64 reserved_0_1                     : 2;
+		u64 spd                              : 4;
+		u64 spdsel0                          : 1;
+		u64 reserved_7_10                    : 4;
+		u64 lo_pwr                           : 1;
+		u64 reserved_12                      : 1;
+		u64 spdsel1                          : 1;
+		u64 loopbck                          : 1;
+		u64 reset                            : 1;
+		u64 usxgmii_type                     : 3;
+		u64 usxgmii_rate                     : 3;
+		u64 reserved_22_63                   : 42;
+	} cn96xxp1;
+	/* struct cgxx_spux_control1_s cn96xxp3; */
+	/* struct cgxx_spux_control1_cn96xxp1 cn98xx; */
+	/* struct cgxx_spux_control1_cn96xxp1 cnf95xx; */
+	/* struct cgxx_spux_control1_cn96xxp1 loki; */
+};
+
+static inline u64 CGXX_SPUX_CONTROL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_CONTROL1(u64 a)
+{
+	return 0x10000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_control2
+ *
+ * CGX SPU Control 2 Registers
+ */
+union cgxx_spux_control2 {
+	u64 u;
+	struct cgxx_spux_control2_s {
+		u64 pcs_type                         : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cgxx_spux_control2_s cn; */
+};
+
+static inline u64 CGXX_SPUX_CONTROL2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_CONTROL2(u64 a)
+{
+	return 0x10018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_abil
+ *
+ * CGX SPU Forward Error Correction Ability Registers
+ */
+union cgxx_spux_fec_abil {
+	u64 u;
+	struct cgxx_spux_fec_abil_s {
+		u64 fec_abil                         : 1;
+		u64 err_abil                         : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cgxx_spux_fec_abil_s cn; */
+};
+
+static inline u64 CGXX_SPUX_FEC_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_FEC_ABIL(u64 a)
+{
+	return 0x100d8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_control
+ *
+ * CGX SPU Forward Error Correction Control Registers
+ */
+union cgxx_spux_fec_control {
+	u64 u;
+	struct cgxx_spux_fec_control_s {
+		u64 fec_en                           : 2;
+		u64 err_en                           : 1;
+		u64 fec_byp_ind_en                   : 1;
+		u64 fec_byp_cor_en                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cgxx_spux_fec_control_s cn; */
+};
+
+static inline u64 CGXX_SPUX_FEC_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_FEC_CONTROL(u64 a)
+{
+	return 0x100e0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_ln#_rsfec_err
+ *
+ * CGX SPU Reed-Solomon FEC Symbol Error Counter for FEC Lanes 0-3
+ * Registers This register is valid only when Reed-Solomon FEC is
+ * enabled. The symbol error counters are defined in 802.3 section
+ * 91.6.11 (for 100G and extended to 50G) and 802.3by-2016 section
+ * 108.6.9 (for 25G and extended to USXGMII). The counter is reset to all
+ * zeros when the register is read, and held at all ones in case of
+ * overflow.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
+ * purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cgxx_spux_fec_lnx_rsfec_err {
+	u64 u;
+	struct cgxx_spux_fec_lnx_rsfec_err_s {
+		u64 symb_err_cnt                     : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spux_fec_lnx_rsfec_err_s cn; */
+};
+
+static inline u64 CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+{
+	return 0x10900 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int
+ *
+ * CGX SPU Interrupt Registers
+ */
+union cgxx_spux_int {
+	u64 u;
+	struct cgxx_spux_int_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cgxx_spux_int_s cn; */
+};
+
+static inline u64 CGXX_SPUX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_INT(u64 a)
+{
+	return 0x10220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_ena_w1c
+ *
+ * CGX SPU Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cgxx_spux_int_ena_w1c {
+	u64 u;
+	struct cgxx_spux_int_ena_w1c_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cgxx_spux_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_SPUX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_INT_ENA_W1C(u64 a)
+{
+	return 0x10230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_ena_w1s
+ *
+ * CGX SPU Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cgxx_spux_int_ena_w1s {
+	u64 u;
+	struct cgxx_spux_int_ena_w1s_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cgxx_spux_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_SPUX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_INT_ENA_W1S(u64 a)
+{
+	return 0x10238 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_w1s
+ *
+ * CGX SPU Interrupt Set Registers This register sets interrupt bits.
+ */
+union cgxx_spux_int_w1s {
+	u64 u;
+	struct cgxx_spux_int_w1s_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cgxx_spux_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_SPUX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_INT_W1S(u64 a)
+{
+	return 0x10228 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_br_bip_err_cnt
+ *
+ * CGX SPU 40,50,100GBASE-R BIP Error-Counter Registers This register
+ * implements the IEEE 802.3 BIP error-counter registers for PCS lanes
+ * 0-19 (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R,
+ * 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
+ * returns 0x0 for all other LPCS types. The counters are indexed by the
+ * RX PCS lane number based on the alignment marker detected on each lane
+ * and captured in CGX()_SPU()_BR_LANE_MAP(). Each counter counts the BIP
+ * errors for its PCS lane, and is held at all ones in case of overflow.
+ * The counters are reset to all zeros when this register is read by
+ * software.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
+ * purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cgxx_spux_lnx_br_bip_err_cnt {
+	u64 u;
+	struct cgxx_spux_lnx_br_bip_err_cnt_s {
+		u64 bip_err_cnt                      : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_lnx_br_bip_err_cnt_s cn; */
+};
+
+static inline u64 CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+{
+	return 0x10500 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_fec_corr_blks
+ *
+ * CGX SPU FEC Corrected-Blocks Counters 0-19 Registers This register is
+ * valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.1. Each
+ * corrected-blocks counter increments by one for a corrected FEC block,
+ * i.e. an FEC block that has been received with invalid parity on the
+ * associated PCS lane and has been corrected by the FEC decoder. The
+ * counter is reset to all zeros when the register is read, and held at
+ * all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cgxx_spux_lnx_fec_corr_blks {
+	u64 u;
+	struct cgxx_spux_lnx_fec_corr_blks_s {
+		u64 ln_corr_blks                     : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spux_lnx_fec_corr_blks_s cn; */
+};
+
+static inline u64 CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+{
+	return 0x10700 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_fec_uncorr_blks
+ *
+ * CGX SPU FEC Uncorrected-Blocks Counters 0-19 Registers This register
+ * is valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.2. Each
+ * uncorrected-blocks counter increments by one for an uncorrected FEC
+ * block, i.e. an FEC block that has been received with invalid parity on
+ * the associated PCS lane and has not been corrected by the FEC decoder.
+ * The counter is reset to all zeros when the register is read, and held
+ * at all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cgxx_spux_lnx_fec_uncorr_blks {
+	u64 u;
+	struct cgxx_spux_lnx_fec_uncorr_blks_s {
+		u64 ln_uncorr_blks                   : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spux_lnx_fec_uncorr_blks_s cn; */
+};
+
+static inline u64 CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+{
+	return 0x10800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_lpcs_states
+ *
+ * CGX SPU BASE-X Transmit/Receive States Registers
+ */
+union cgxx_spux_lpcs_states {
+	u64 u;
+	struct cgxx_spux_lpcs_states_s {
+		u64 deskew_sm                        : 3;
+		u64 reserved_3                       : 1;
+		u64 deskew_am_found                  : 20;
+		u64 bx_rx_sm                         : 2;
+		u64 reserved_26_27                   : 2;
+		u64 br_rx_sm                         : 3;
+		u64 reserved_31_63                   : 33;
+	} s;
+	/* struct cgxx_spux_lpcs_states_s cn; */
+};
+
+static inline u64 CGXX_SPUX_LPCS_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_LPCS_STATES(u64 a)
+{
+	return 0x10208 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_misc_control
+ *
+ * CGX SPU Miscellaneous Control Registers "* RX logical PCS lane
+ * polarity vector \<3:0\> = [XOR_RXPLRT]\<3:0\> ^ {4{[RXPLRT]}}. * TX
+ * logical PCS lane polarity vector \<3:0\> = [XOR_TXPLRT]\<3:0\> ^
+ * {4{[TXPLRT]}}.  In short, keep [RXPLRT] and [TXPLRT] cleared, and use
+ * [XOR_RXPLRT] and [XOR_TXPLRT] fields to define the polarity per
+ * logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only
+ * bits 1:0 of vector are used for RXAUI."
+ */
+union cgxx_spux_misc_control {
+	u64 u;
+	struct cgxx_spux_misc_control_s {
+		u64 txplrt                           : 1;
+		u64 rxplrt                           : 1;
+		u64 xor_txplrt                       : 4;
+		u64 xor_rxplrt                       : 4;
+		u64 intlv_rdisp                      : 1;
+		u64 skip_after_term                  : 1;
+		u64 rx_packet_dis                    : 1;
+		u64 rx_edet_signal_ok                : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cgxx_spux_misc_control_s cn; */
+};
+
+static inline u64 CGXX_SPUX_MISC_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_MISC_CONTROL(u64 a)
+{
+	return 0x10218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_corr
+ *
+ * CGX SPU Reed-Solomon FEC Corrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC corrected codewords counter
+ * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and
+ * 802.3by-2016 section 108.6.7 (for 25G and extended to USXGMII).
+ */
+union cgxx_spux_rsfec_corr {
+	u64 u;
+	struct cgxx_spux_rsfec_corr_s {
+		u64 cw_cnt                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spux_rsfec_corr_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RSFEC_CORR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RSFEC_CORR(u64 a)
+{
+	return 0x10088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_status
+ *
+ * CGX SPU Reed-Solomon FEC Status Registers This register implements the
+ * IEEE 802.3 RS-FEC status and lane mapping registers as described in
+ * 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
+ * section 108-6 (for 25G and extended to USXGMII).
+ */
+union cgxx_spux_rsfec_status {
+	u64 u;
+	struct cgxx_spux_rsfec_status_s {
+		u64 fec_lane_mapping                 : 8;
+		u64 fec_align_status                 : 1;
+		u64 amps_lock                        : 4;
+		u64 hi_ser                           : 1;
+		u64 fec_byp_ind_abil                 : 1;
+		u64 fec_byp_cor_abil                 : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_rsfec_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RSFEC_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RSFEC_STATUS(u64 a)
+{
+	return 0x10080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_uncorr
+ *
+ * CGX SPU Reed-Solomon FEC Uncorrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC uncorrected codewords
+ * counter described in 802.3 section 91.6.9 (for 100G and extended to
+ * 50G) and 802.3by-2016 section 108.6.8 (for 25G and extended to
+ * USXGMII).
+ */
+union cgxx_spux_rsfec_uncorr {
+	u64 u;
+	struct cgxx_spux_rsfec_uncorr_s {
+		u64 cw_cnt                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spux_rsfec_uncorr_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RSFEC_UNCORR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RSFEC_UNCORR(u64 a)
+{
+	return 0x10090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_eee_wake
+ *
+ * INTERNAL: CGX SPU  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: A counter that is incremented each time that the LPI receive
+ * state diagram enters the RX_WTF state indicating that a wake time
+ * fault has been detected.
+ */
+union cgxx_spux_rx_eee_wake {
+	u64 u;
+	struct cgxx_spux_rx_eee_wake_s {
+		u64 wtf_error_counter                : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_rx_eee_wake_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RX_EEE_WAKE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RX_EEE_WAKE(u64 a)
+{
+	return 0x103e0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_lpi_timing
+ *
+ * INTERNAL: CGX SPU RX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters Tqr,
+ * Twr and Twtf.
+ */
+union cgxx_spux_rx_lpi_timing {
+	u64 u;
+	struct cgxx_spux_rx_lpi_timing_s {
+		u64 twtf                             : 20;
+		u64 twr                              : 20;
+		u64 tqr                              : 20;
+		u64 reserved_60_61                   : 2;
+		u64 rx_lpi_fw                        : 1;
+		u64 rx_lpi_en                        : 1;
+	} s;
+	/* struct cgxx_spux_rx_lpi_timing_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RX_LPI_TIMING(u64 a)
+{
+	return 0x103c0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_lpi_timing2
+ *
+ * INTERNAL: CGX SPU RX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters
+ * hold_off_timer.
+ */
+union cgxx_spux_rx_lpi_timing2 {
+	u64 u;
+	struct cgxx_spux_rx_lpi_timing2_s {
+		u64 hold_off_timer                   : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cgxx_spux_rx_lpi_timing2_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+{
+	return 0x10420 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_mrk_cnt
+ *
+ * CGX SPU Receiver Marker Interval Count Control Registers
+ */
+union cgxx_spux_rx_mrk_cnt {
+	u64 u;
+	struct cgxx_spux_rx_mrk_cnt_s {
+		u64 mrk_cnt                          : 20;
+		u64 reserved_20_43                   : 24;
+		u64 by_mrk_100g                      : 1;
+		u64 reserved_45_47                   : 3;
+		u64 ram_mrk_cnt                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cgxx_spux_rx_mrk_cnt_s cn; */
+};
+
+static inline u64 CGXX_SPUX_RX_MRK_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_RX_MRK_CNT(u64 a)
+{
+	return 0x103a0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_spd_abil
+ *
+ * CGX SPU PCS Speed Ability Registers
+ */
+union cgxx_spux_spd_abil {
+	u64 u;
+	struct cgxx_spux_spd_abil_s {
+		u64 tengb                            : 1;
+		u64 tenpasst                         : 1;
+		u64 usxgmii                          : 1;
+		u64 twentyfivegb                     : 1;
+		u64 fortygb                          : 1;
+		u64 fiftygb                          : 1;
+		u64 hundredgb                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cgxx_spux_spd_abil_s cn; */
+};
+
+static inline u64 CGXX_SPUX_SPD_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_SPD_ABIL(u64 a)
+{
+	return 0x10010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_status1
+ *
+ * CGX SPU Status 1 Registers
+ */
+union cgxx_spux_status1 {
+	u64 u;
+	struct cgxx_spux_status1_s {
+		u64 reserved_0                       : 1;
+		u64 lpable                           : 1;
+		u64 rcv_lnk                          : 1;
+		u64 reserved_3_6                     : 4;
+		u64 flt                              : 1;
+		u64 rx_lpi_indication                : 1;
+		u64 tx_lpi_indication                : 1;
+		u64 rx_lpi_received                  : 1;
+		u64 tx_lpi_received                  : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cgxx_spux_status1_s cn; */
+};
+
+static inline u64 CGXX_SPUX_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_STATUS1(u64 a)
+{
+	return 0x10008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_status2
+ *
+ * CGX SPU Status 2 Registers
+ */
+union cgxx_spux_status2 {
+	u64 u;
+	struct cgxx_spux_status2_s {
+		u64 tengb_r                          : 1;
+		u64 tengb_x                          : 1;
+		u64 tengb_w                          : 1;
+		u64 tengb_t                          : 1;
+		u64 usxgmii_r                        : 1;
+		u64 twentyfivegb_r                   : 1;
+		u64 fortygb_r                        : 1;
+		u64 fiftygb_r                        : 1;
+		u64 hundredgb_r                      : 1;
+		u64 reserved_9                       : 1;
+		u64 rcvflt                           : 1;
+		u64 xmtflt                           : 1;
+		u64 reserved_12_13                   : 2;
+		u64 dev                              : 2;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_status2_s cn; */
+};
+
+static inline u64 CGXX_SPUX_STATUS2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_STATUS2(u64 a)
+{
+	return 0x10020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_lpi_timing
+ *
+ * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: Transmit LPI timing parameters Tsl, Tql and Tul
+ */
+union cgxx_spux_tx_lpi_timing {
+	u64 u;
+	struct cgxx_spux_tx_lpi_timing_s {
+		u64 tql                              : 19;
+		u64 reserved_19_31                   : 13;
+		u64 tul                              : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tsl                              : 12;
+		u64 reserved_60                      : 1;
+		u64 tx_lpi_ignore_twl                : 1;
+		u64 tx_lpi_fw                        : 1;
+		u64 tx_lpi_en                        : 1;
+	} s;
+	/* struct cgxx_spux_tx_lpi_timing_s cn; */
+};
+
+static inline u64 CGXX_SPUX_TX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_TX_LPI_TIMING(u64 a)
+{
+	return 0x10400 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_lpi_timing2
+ *
+ * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies transmit LPI timer parameters.
+ */
+union cgxx_spux_tx_lpi_timing2 {
+	u64 u;
+	struct cgxx_spux_tx_lpi_timing2_s {
+		u64 t1u                              : 8;
+		u64 reserved_8_11                    : 4;
+		u64 twl                              : 12;
+		u64 reserved_24_31                   : 8;
+		u64 twl2                             : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tbyp                             : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cgxx_spux_tx_lpi_timing2_s cn; */
+};
+
+static inline u64 CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+{
+	return 0x10440 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_mrk_cnt
+ *
+ * CGX SPU Transmitter Marker Interval Count Control Registers
+ */
+union cgxx_spux_tx_mrk_cnt {
+	u64 u;
+	struct cgxx_spux_tx_mrk_cnt_s {
+		u64 mrk_cnt                          : 20;
+		u64 reserved_20_43                   : 24;
+		u64 by_mrk_100g                      : 1;
+		u64 reserved_45_47                   : 3;
+		u64 ram_mrk_cnt                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cgxx_spux_tx_mrk_cnt_s cn; */
+};
+
+static inline u64 CGXX_SPUX_TX_MRK_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_TX_MRK_CNT(u64 a)
+{
+	return 0x10380 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_adv
+ *
+ * CGX SPU USXGMII Autonegotiation Advertisement Registers Software
+ * programs this register with the contents of the AN-link code word base
+ * page to be transmitted during autonegotiation. Any write operations to
+ * this register prior to completion of autonegotiation should be
+ * followed by a renegotiation in order for the new values to take
+ * effect. Once autonegotiation has completed, software can examine this
+ * register along with CGX()_SPU()_USX_AN_ADV to determine the highest
+ * common denominator technology. The format for this register is from
+ * USXGMII Multiport specification section 1.1.2 Table 2.
+ */
+union cgxx_spux_usx_an_adv {
+	u64 u;
+	struct cgxx_spux_usx_an_adv_s {
+		u64 set                              : 1;
+		u64 reserved_1_6                     : 6;
+		u64 eee_clk_stop_abil                : 1;
+		u64 eee_abil                         : 1;
+		u64 spd                              : 3;
+		u64 dplx                             : 1;
+		u64 reserved_13_14                   : 2;
+		u64 lnk_st                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_usx_an_adv_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_ADV(u64 a)
+{
+	return 0x101d0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_control
+ *
+ * CGX SPU USXGMII Autonegotiation Control Register
+ */
+union cgxx_spux_usx_an_control {
+	u64 u;
+	struct cgxx_spux_usx_an_control_s {
+		u64 reserved_0_8                     : 9;
+		u64 rst_an                           : 1;
+		u64 reserved_10_11                   : 2;
+		u64 an_en                            : 1;
+		u64 reserved_13_14                   : 2;
+		u64 an_reset                         : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_usx_an_control_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_CONTROL(u64 a)
+{
+	return 0x101c0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_expansion
+ *
+ * CGX SPU USXGMII Autonegotiation Expansion Register This register is
+ * only used to signal page reception.
+ */
+union cgxx_spux_usx_an_expansion {
+	u64 u;
+	struct cgxx_spux_usx_an_expansion_s {
+		u64 reserved_0                       : 1;
+		u64 an_page_received                 : 1;
+		u64 next_page_able                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cgxx_spux_usx_an_expansion_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+{
+	return 0x101e0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_flow_ctrl
+ *
+ * CGX SPU USXGMII Flow Control Registers This register is used by
+ * software to affect USXGMII AN hardware behavior.
+ */
+union cgxx_spux_usx_an_flow_ctrl {
+	u64 u;
+	struct cgxx_spux_usx_an_flow_ctrl_s {
+		u64 start_idle_detect                : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_spux_usx_an_flow_ctrl_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+{
+	return 0x101e8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_link_timer
+ *
+ * CGX SPU USXGMII Link Timer Registers This is the link timer register.
+ */
+union cgxx_spux_usx_an_link_timer {
+	u64 u;
+	struct cgxx_spux_usx_an_link_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_usx_an_link_timer_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+{
+	return 0x101f0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_lp_abil
+ *
+ * CGX SPU USXGMII Autonegotiation Link-Partner Advertisement Registers
+ * This register captures the contents of the latest AN link code word
+ * base page received from the link partner during autonegotiation. This
+ * is register 5 per IEEE 802.3, Clause 37.
+ * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this
+ * register is updated by hardware.
+ */
+union cgxx_spux_usx_an_lp_abil {
+	u64 u;
+	struct cgxx_spux_usx_an_lp_abil_s {
+		u64 set                              : 1;
+		u64 reserved_1_6                     : 6;
+		u64 eee_clk_stop_abil                : 1;
+		u64 eee_abil                         : 1;
+		u64 spd                              : 3;
+		u64 dplx                             : 1;
+		u64 reserved_13_14                   : 2;
+		u64 lnk_st                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cgxx_spux_usx_an_lp_abil_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+{
+	return 0x101d8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_status
+ *
+ * CGX SPU USXGMII Autonegotiation Status Register
+ */
+union cgxx_spux_usx_an_status {
+	u64 u;
+	struct cgxx_spux_usx_an_status_s {
+		u64 extnd                            : 1;
+		u64 reserved_1                       : 1;
+		u64 lnk_st                           : 1;
+		u64 an_abil                          : 1;
+		u64 rmt_flt                          : 1;
+		u64 an_cpt                           : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_spux_usx_an_status_s cn; */
+};
+
+static inline u64 CGXX_SPUX_USX_AN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPUX_USX_AN_STATUS(u64 a)
+{
+	return 0x101c8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_dbg_control
+ *
+ * CGX SPU Debug Control Registers
+ */
+union cgxx_spu_dbg_control {
+	u64 u;
+	struct cgxx_spu_dbg_control_s {
+		u64 marker_rxp                       : 15;
+		u64 reserved_15                      : 1;
+		u64 scramble_dis                     : 1;
+		u64 reserved_17_18                   : 2;
+		u64 br_pmd_train_soft_en             : 1;
+		u64 reserved_20_27                   : 8;
+		u64 timestamp_norm_dis               : 1;
+		u64 an_nonce_match_dis               : 1;
+		u64 br_ber_mon_dis                   : 1;
+		u64 rf_cw_mon_erly_restart_dis       : 1;
+		u64 us_clk_period                    : 12;
+		u64 ms_clk_period                    : 12;
+		u64 reserved_56_63                   : 8;
+	} s;
+	struct cgxx_spu_dbg_control_cn96xxp1 {
+		u64 marker_rxp                       : 15;
+		u64 reserved_15                      : 1;
+		u64 scramble_dis                     : 1;
+		u64 reserved_17_18                   : 2;
+		u64 br_pmd_train_soft_en             : 1;
+		u64 reserved_20_27                   : 8;
+		u64 timestamp_norm_dis               : 1;
+		u64 an_nonce_match_dis               : 1;
+		u64 br_ber_mon_dis                   : 1;
+		u64 reserved_31                      : 1;
+		u64 us_clk_period                    : 12;
+		u64 ms_clk_period                    : 12;
+		u64 reserved_56_63                   : 8;
+	} cn96xxp1;
+	/* struct cgxx_spu_dbg_control_s cn96xxp3; */
+	/* struct cgxx_spu_dbg_control_s cn98xx; */
+	/* struct cgxx_spu_dbg_control_cn96xxp1 cnf95xxp1; */
+	/* struct cgxx_spu_dbg_control_s cnf95xxp2; */
+	/* struct cgxx_spu_dbg_control_s loki; */
+};
+
+static inline u64 CGXX_SPU_DBG_CONTROL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPU_DBG_CONTROL(void)
+{
+	return 0x10300;
+}
+
+/**
+ * Register (RSL) cgx#_spu_sds#_skew_status
+ *
+ * CGX SPU SerDes Lane Skew Status Registers This register provides
+ * SerDes lane skew status. One register per physical SerDes lane.
+ */
+union cgxx_spu_sdsx_skew_status {
+	u64 u;
+	struct cgxx_spu_sdsx_skew_status_s {
+		u64 skew_status                      : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cgxx_spu_sdsx_skew_status_s cn; */
+};
+
+static inline u64 CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+{
+	return 0x10340 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_sds#_states
+ *
+ * CGX SPU SerDes States Registers This register provides SerDes lane
+ * states. One register per physical SerDes lane.
+ */
+union cgxx_spu_sdsx_states {
+	u64 u;
+	struct cgxx_spu_sdsx_states_s {
+		u64 bx_sync_sm                       : 4;
+		u64 br_sh_cnt                        : 11;
+		u64 br_block_lock                    : 1;
+		u64 br_sh_invld_cnt                  : 7;
+		u64 reserved_23                      : 1;
+		u64 fec_sync_cnt                     : 4;
+		u64 fec_block_sync                   : 1;
+		u64 reserved_29                      : 1;
+		u64 an_rx_sm                         : 2;
+		u64 an_arb_sm                        : 3;
+		u64 reserved_35                      : 1;
+		u64 train_lock_bad_markers           : 3;
+		u64 train_lock_found_1st_marker      : 1;
+		u64 train_frame_lock                 : 1;
+		u64 train_code_viol                  : 1;
+		u64 train_sm                         : 3;
+		u64 reserved_45_47                   : 3;
+		u64 am_lock_sm                       : 2;
+		u64 am_lock_invld_cnt                : 2;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cgxx_spu_sdsx_states_s cn; */
+};
+
+static inline u64 CGXX_SPU_SDSX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPU_SDSX_STATES(u64 a)
+{
+	return 0x10360 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_usxgmii_control
+ *
+ * CGX SPU Common USXGMII Control Register This register is the common
+ * control register that enables USXGMII Mode. The fields in this
+ * register are preserved across any LMAC soft-resets. For an LMAC in
+ * soft- reset state in USXGMII mode, the CGX will transmit Remote Fault
+ * BASE-R blocks.
+ */
+union cgxx_spu_usxgmii_control {
+	u64 u;
+	struct cgxx_spu_usxgmii_control_s {
+		u64 enable                           : 1;
+		u64 usxgmii_type                     : 3;
+		u64 sds_id                           : 2;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cgxx_spu_usxgmii_control_s cn; */
+};
+
+static inline u64 CGXX_SPU_USXGMII_CONTROL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_SPU_USXGMII_CONTROL(void)
+{
+	return 0x10920;
+}
+
+#endif /* __CSRS_CGX_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
new file mode 100644
index 0000000000..72a5956c60
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_LMT_H__
+#define __CSRS_LMT_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * LMT.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtcancel
+ *
+ * RVU VF LMT Cancel Register
+ */
+union lmt_lf_lmtcancel {
+	u64 u;
+	struct lmt_lf_lmtcancel_s {
+		u64 data                             : 64;
+	} s;
+	/* struct lmt_lf_lmtcancel_s cn; */
+};
+
+static inline u64 LMT_LF_LMTCANCEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 LMT_LF_LMTCANCEL(void)
+{
+	return 0x400;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtline#
+ *
+ * RVU VF LMT Line Registers
+ */
+union lmt_lf_lmtlinex {
+	u64 u;
+	struct lmt_lf_lmtlinex_s {
+		u64 data                             : 64;
+	} s;
+	/* struct lmt_lf_lmtlinex_s cn; */
+};
+
+static inline u64 LMT_LF_LMTLINEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 LMT_LF_LMTLINEX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+#endif /* __CSRS_LMT_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
new file mode 100644
index 0000000000..4dd8958d2f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
@@ -0,0 +1,1199 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_MIO_EMM_H__
+#define __CSRS_MIO_EMM_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * MIO_EMM.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union mio_emm_access_wdog {
+	u64 u;
+	struct mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union mio_emm_buf_dat {
+	u64 u;
+	struct mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union mio_emm_buf_idx {
+	u64 u;
+	struct mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union mio_emm_calb {
+	u64 u;
+	struct mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct mio_emm_calb_s cn; */
+};
+
+static inline u64 MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union mio_emm_cfg {
+	u64 u;
+	struct mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union mio_emm_cmd {
+	u64 u;
+	struct mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union mio_emm_comp {
+	u64 u;
+	struct mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct mio_emm_comp_s cn; */
+};
+
+static inline u64 MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union mio_emm_debug {
+	u64 u;
+	struct mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 emmc_clk_disable                 : 1;
+		u64 rdsync_rst                       : 1;
+		u64 reserved_22_63                   : 42;
+	} s;
+	struct mio_emm_debug_cn96xxp1 {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} cn96xxp1;
+	/* struct mio_emm_debug_s cn96xxp3; */
+	/* struct mio_emm_debug_s cn98xx; */
+	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
+	/* struct mio_emm_debug_s loki; */
+};
+
+static inline u64 MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union mio_emm_dma {
+	u64 u;
+	struct mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union mio_emm_dma_adr {
+	u64 u;
+	struct mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union mio_emm_dma_arg {
+	u64 u;
+	struct mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union mio_emm_dma_cfg {
+	u64 u;
+	struct mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union mio_emm_dma_fifo_adr {
+	u64 u;
+	struct mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_dma_fifo_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union mio_emm_dma_int {
+	u64 u;
+	struct mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_dma_int_w1s {
+	u64 u;
+	struct mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union mio_emm_int {
+	u64 u;
+	struct mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union mio_emm_int_ena_w1c {
+	u64 u;
+	struct mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union mio_emm_int_ena_w1s {
+	u64 u;
+	struct mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_int_w1s {
+	u64 u;
+	struct mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union mio_emm_io_ctl {
+	u64 u;
+	struct mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union mio_emm_modex {
+	u64 u;
+	struct mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	struct mio_emm_modex_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} cn96xxp1;
+	/* struct mio_emm_modex_s cn96xxp3; */
+	/* struct mio_emm_modex_s cn98xx; */
+	/* struct mio_emm_modex_s cnf95xx; */
+	/* struct mio_emm_modex_s loki; */
+};
+
+static inline u64 MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_pbax {
+	u64 u;
+	struct mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_addr {
+	u64 u;
+	struct mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union mio_emm_rca {
+	u64 u;
+	struct mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct mio_emm_rca_s cn; */
+};
+
+static inline u64 MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union mio_emm_rsp_hi {
+	u64 u;
+	struct mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union mio_emm_rsp_lo {
+	u64 u;
+	struct mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union mio_emm_rsp_sts {
+	u64 u;
+	struct mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union mio_emm_sample {
+	u64 u;
+	struct mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_sample_s cn; */
+};
+
+static inline u64 MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union mio_emm_sts_mask {
+	u64 u;
+	struct mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union mio_emm_switch {
+	u64 u;
+	struct mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	struct mio_emm_switch_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn96xxp1;
+	/* struct mio_emm_switch_s cn96xxp3; */
+	/* struct mio_emm_switch_s cn98xx; */
+	/* struct mio_emm_switch_s cnf95xx; */
+	/* struct mio_emm_switch_s loki; */
+};
+
+static inline u64 MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union mio_emm_tap {
+	u64 u;
+	struct mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct mio_emm_tap_s cn; */
+};
+
+static inline u64 MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union mio_emm_timing {
+	u64 u;
+	struct mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct mio_emm_timing_s cn; */
+};
+
+static inline u64 MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union mio_emm_wdog {
+	u64 u;
+	struct mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
new file mode 100644
index 0000000000..81b9235365
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
@@ -0,0 +1,10548 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NIX_H__
+#define __CSRS_NIX_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * NIX.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration nix_af_int_vec_e
+ *
+ * NIX Admin Function Interrupt Vector Enumeration Enumerates the NIX AF
+ * MSI-X interrupt vectors.
+ */
+#define NIX_AF_INT_VEC_E_AF_ERR (3)
+#define NIX_AF_INT_VEC_E_AQ_DONE (2)
+#define NIX_AF_INT_VEC_E_GEN (1)
+#define NIX_AF_INT_VEC_E_POISON (4)
+#define NIX_AF_INT_VEC_E_RVU (0)
+
+/**
+ * Enumeration nix_aq_comp_e
+ *
+ * NIX Completion Enumeration Enumerates the values of
+ * NIX_AQ_RES_S[COMPCODE].
+ */
+#define NIX_AQ_COMP_E_CTX_FAULT (4)
+#define NIX_AQ_COMP_E_CTX_POISON (3)
+#define NIX_AQ_COMP_E_GOOD (1)
+#define NIX_AQ_COMP_E_LOCKERR (5)
+#define NIX_AQ_COMP_E_NOTDONE (0)
+#define NIX_AQ_COMP_E_SQB_ALLOC_FAIL (6)
+#define NIX_AQ_COMP_E_SWERR (2)
+
+/**
+ * Enumeration nix_aq_ctype_e
+ *
+ * NIX Context Type Enumeration Enumerates NIX_AQ_INST_S[CTYPE] values.
+ */
+#define NIX_AQ_CTYPE_E_CQ (2)
+#define NIX_AQ_CTYPE_E_DYNO (5)
+#define NIX_AQ_CTYPE_E_MCE (3)
+#define NIX_AQ_CTYPE_E_RQ (0)
+#define NIX_AQ_CTYPE_E_RSS (4)
+#define NIX_AQ_CTYPE_E_SQ (1)
+
+/**
+ * Enumeration nix_aq_instop_e
+ *
+ * NIX Admin Queue Opcode Enumeration Enumerates NIX_AQ_INST_S[OP]
+ * values.
+ */
+#define NIX_AQ_INSTOP_E_INIT (1)
+#define NIX_AQ_INSTOP_E_LOCK (4)
+#define NIX_AQ_INSTOP_E_NOP (0)
+#define NIX_AQ_INSTOP_E_READ (3)
+#define NIX_AQ_INSTOP_E_UNLOCK (5)
+#define NIX_AQ_INSTOP_E_WRITE (2)
+
+/**
+ * Enumeration nix_chan_e
+ *
+ * NIX Channel Number Enumeration Enumerates the receive and transmit
+ * channels, and values of NIX_RX_PARSE_S[CHAN],
+ * NIX_SQ_CTX_S[DEFAULT_CHAN]. CNXXXX implements a subset of these
+ * channels. Specifically, only channels for links enumerated by
+ * NIX_LINK_E are implemented.  Internal: P2X/X2P channel enumeration for
+ * t9x.
+ */
+#define NIX_CHAN_E_CGXX_LMACX_CHX(a, b, c)	\
+	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
+#define NIX_CHAN_E_LBKX_CHX(a, b) (0 + 0x100 * (a) + (b))
+#define NIX_CHAN_E_RX(a) (0 + 0x100 * (a))
+#define NIX_CHAN_E_SDP_CHX(a) (0x700 + (a))
+
+/**
+ * Enumeration nix_colorresult_e
+ *
+ * NIX Color Result Enumeration Enumerates the values of
+ * NIX_MEM_RESULT_S[COLOR], NIX_AF_TL1()_MD_DEBUG1[COLOR] and
+ * NIX_AF_TL1()_MD_DEBUG1[COLOR].
+ */
+#define NIX_COLORRESULT_E_GREEN (0)
+#define NIX_COLORRESULT_E_RED_DROP (3)
+#define NIX_COLORRESULT_E_RED_SEND (2)
+#define NIX_COLORRESULT_E_YELLOW (1)
+
+/**
+ * Enumeration nix_cqerrint_e
+ *
+ * NIX Completion Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_CQ_CTX_S[CQ_ERR_INT,CQ_ERR_INT_ENA].
+ */
+#define NIX_CQERRINT_E_CQE_FAULT (2)
+#define NIX_CQERRINT_E_DOOR_ERR (0)
+#define NIX_CQERRINT_E_WR_FULL (1)
+
+/**
+ * Enumeration nix_intf_e
+ *
+ * NIX Interface Number Enumeration Enumerates the bit index of
+ * NIX_AF_STATUS[CALIBRATE_STATUS].
+ */
+#define NIX_INTF_E_CGXX(a) (0 + (a))
+#define NIX_INTF_E_LBKX_CN96XX(a) (3 + (a))
+#define NIX_INTF_E_LBKX_CN98XX(a) (5 + (a))
+#define NIX_INTF_E_LBKX_CNF95XX(a) (3 + (a))
+#define NIX_INTF_E_LBKX_LOKI(a) (3 + (a))
+#define NIX_INTF_E_SDP_CN96XX (4)
+#define NIX_INTF_E_SDP_CN98XX (7)
+#define NIX_INTF_E_SDP_CNF95XX (4)
+#define NIX_INTF_E_SDP_LOKI (4)
+
+/**
+ * Enumeration nix_lf_int_vec_e
+ *
+ * NIX Local Function Interrupt Vector Enumeration Enumerates the NIX
+ * MSI-X interrupt vectors per LF.
+ */
+#define NIX_LF_INT_VEC_E_CINTX(a) (0x40 + (a))
+#define NIX_LF_INT_VEC_E_ERR_INT (0x81)
+#define NIX_LF_INT_VEC_E_GINT (0x80)
+#define NIX_LF_INT_VEC_E_POISON (0x82)
+#define NIX_LF_INT_VEC_E_QINTX(a) (0 + (a))
+
+/**
+ * Enumeration nix_link_e
+ *
+ * NIX Link Number Enumeration Enumerates the receive and transmit links,
+ * and LINK index of NIX_AF_RX_LINK()_CFG, NIX_AF_RX_LINK()_WRR_CFG,
+ * NIX_AF_TX_LINK()_NORM_CREDIT, NIX_AF_TX_LINK()_HW_XOFF and
+ * NIX_AF_TL3_TL2()_LINK()_CFG.
+ */
+#define NIX_LINK_E_CGXX_LMACX(a, b) (0 + 4 * (a) + (b))
+#define NIX_LINK_E_LBKX_CN96XX(a) (0xc + (a))
+#define NIX_LINK_E_LBKX_CN98XX(a) (0x14 + (a))
+#define NIX_LINK_E_LBKX_CNF95XX(a) (0xc + (a))
+#define NIX_LINK_E_LBKX_LOKI(a) (0xc + (a))
+#define NIX_LINK_E_MC_CN96XX (0xe)
+#define NIX_LINK_E_MC_CN98XX (0x17)
+#define NIX_LINK_E_MC_CNF95XX (0xe)
+#define NIX_LINK_E_MC_LOKI (0xe)
+#define NIX_LINK_E_SDP_CN96XX (0xd)
+#define NIX_LINK_E_SDP_CN98XX (0x16)
+#define NIX_LINK_E_SDP_CNF95XX (0xd)
+#define NIX_LINK_E_SDP_LOKI (0xd)
+
+/**
+ * Enumeration nix_lsoalg_e
+ *
+ * NIX Large Send Offload Algorithm Enumeration Enumerates
+ * NIX_AF_LSO_FORMAT()_FIELD()[ALG] values. Specifies algorithm for
+ * modifying the associated LSO packet field.
+ */
+#define NIX_LSOALG_E_ADD_OFFSET (3)
+#define NIX_LSOALG_E_ADD_PAYLEN (2)
+#define NIX_LSOALG_E_ADD_SEGNUM (1)
+#define NIX_LSOALG_E_NOP (0)
+#define NIX_LSOALG_E_TCP_FLAGS (4)
+
+/**
+ * Enumeration nix_maxsqesz_e
+ *
+ * NIX Maximum SQE Size Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[MAX_SQE_SIZE].
+ */
+#define NIX_MAXSQESZ_E_W16 (0)
+#define NIX_MAXSQESZ_E_W8 (1)
+
+/**
+ * Enumeration nix_mdtype_e
+ *
+ * NIX Meta Descriptor Type Enumeration Enumerates values of
+ * NIX_AF_MDQ()_MD_DEBUG[MD_TYPE].
+ */
+#define NIX_MDTYPE_E_FLUSH (1)
+#define NIX_MDTYPE_E_PMD (2)
+#define NIX_MDTYPE_E_RSVD (0)
+
+/**
+ * Enumeration nix_mnqerr_e
+ *
+ * NIX Meta-Descriptor Enqueue Error Enumeration Enumerates
+ * NIX_LF_MNQ_ERR_DBG[ERRCODE] values.
+ */
+#define NIX_MNQERR_E_CQ_QUERY_ERR (6)
+#define NIX_MNQERR_E_LSO_ERR (5)
+#define NIX_MNQERR_E_MAXLEN_ERR (8)
+#define NIX_MNQERR_E_MAX_SQE_SIZE_ERR (7)
+#define NIX_MNQERR_E_SQB_FAULT (2)
+#define NIX_MNQERR_E_SQB_POISON (3)
+#define NIX_MNQERR_E_SQE_SIZEM1_ZERO (9)
+#define NIX_MNQERR_E_SQ_CTX_FAULT (0)
+#define NIX_MNQERR_E_SQ_CTX_POISON (1)
+#define NIX_MNQERR_E_TOTAL_ERR (4)
+
+/**
+ * Enumeration nix_ndc_rx_port_e
+ *
+ * NIX Receive NDC Port Enumeration Enumerates NIX receive NDC
+ * (NDC_IDX_E::NIX()_RX) ports and the PORT index of
+ * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define NIX_NDC_RX_PORT_E_AQ (0)
+#define NIX_NDC_RX_PORT_E_CINT (2)
+#define NIX_NDC_RX_PORT_E_CQ (1)
+#define NIX_NDC_RX_PORT_E_MC (3)
+#define NIX_NDC_RX_PORT_E_PKT (4)
+#define NIX_NDC_RX_PORT_E_RQ (5)
+
+/**
+ * Enumeration nix_ndc_tx_port_e
+ *
+ * NIX Transmit NDC Port Enumeration Enumerates NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX) ports and the PORT index of
+ * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define NIX_NDC_TX_PORT_E_DEQ (3)
+#define NIX_NDC_TX_PORT_E_DMA (4)
+#define NIX_NDC_TX_PORT_E_ENQ (1)
+#define NIX_NDC_TX_PORT_E_LMT (0)
+#define NIX_NDC_TX_PORT_E_MNQ (2)
+#define NIX_NDC_TX_PORT_E_XQE (5)
+
+/**
+ * Enumeration nix_re_opcode_e
+ *
+ * NIX Receive Error Opcode Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NPC_ERRLEV_E::RE.
+ */
+#define NIX_RE_OPCODE_E_OL2_LENMISM (0x12)
+#define NIX_RE_OPCODE_E_OVERSIZE (0x11)
+#define NIX_RE_OPCODE_E_RE_DMAPKT (0xf)
+#define NIX_RE_OPCODE_E_RE_FCS (7)
+#define NIX_RE_OPCODE_E_RE_FCS_RCV (8)
+#define NIX_RE_OPCODE_E_RE_JABBER (2)
+#define NIX_RE_OPCODE_E_RE_NONE (0)
+#define NIX_RE_OPCODE_E_RE_PARTIAL (1)
+#define NIX_RE_OPCODE_E_RE_RX_CTL (0xb)
+#define NIX_RE_OPCODE_E_RE_SKIP (0xc)
+#define NIX_RE_OPCODE_E_RE_TERMINATE (9)
+#define NIX_RE_OPCODE_E_UNDERSIZE (0x10)
+
+/**
+ * Enumeration nix_redalg_e
+ *
+ * NIX Red Algorithm Enumeration Enumerates the different algorithms of
+ * NIX_SEND_EXT_S[SHP_RA].
+ */
+#define NIX_REDALG_E_DISCARD (3)
+#define NIX_REDALG_E_SEND (1)
+#define NIX_REDALG_E_STALL (2)
+#define NIX_REDALG_E_STD (0)
+
+/**
+ * Enumeration nix_rqint_e
+ *
+ * NIX Receive Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_RQ_CTX_S[RQ_INT,RQ_INT_ENA].
+ */
+#define NIX_RQINT_E_DROP (0)
+#define NIX_RQINT_E_RX(a) (0 + (a))
+#define NIX_RQINT_E_RED (1)
+
+/**
+ * Enumeration nix_rx_actionop_e
+ *
+ * NIX Receive Action Opcode Enumeration Enumerates the values of
+ * NIX_RX_ACTION_S[OP].
+ */
+#define NIX_RX_ACTIONOP_E_DROP (0)
+#define NIX_RX_ACTIONOP_E_MCAST (3)
+#define NIX_RX_ACTIONOP_E_MIRROR (6)
+#define NIX_RX_ACTIONOP_E_PF_FUNC_DROP (5)
+#define NIX_RX_ACTIONOP_E_RSS (4)
+#define NIX_RX_ACTIONOP_E_UCAST (1)
+#define NIX_RX_ACTIONOP_E_UCAST_IPSEC (2)
+
+/**
+ * Enumeration nix_rx_mcop_e
+ *
+ * NIX Receive Multicast/Mirror Opcode Enumeration Enumerates the values
+ * of NIX_RX_MCE_S[OP].
+ */
+#define NIX_RX_MCOP_E_RQ (0)
+#define NIX_RX_MCOP_E_RSS (1)
+
+/**
+ * Enumeration nix_rx_perrcode_e
+ *
+ * NIX Receive Protocol Error Code Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NPC_ERRLEV_E::NIX.
+ */
+#define NIX_RX_PERRCODE_E_BUFS_OFLOW (0xa)
+#define NIX_RX_PERRCODE_E_DATA_FAULT (8)
+#define NIX_RX_PERRCODE_E_IL3_LEN (0x20)
+#define NIX_RX_PERRCODE_E_IL4_CHK (0x22)
+#define NIX_RX_PERRCODE_E_IL4_LEN (0x21)
+#define NIX_RX_PERRCODE_E_IL4_PORT (0x23)
+#define NIX_RX_PERRCODE_E_MCAST_FAULT (4)
+#define NIX_RX_PERRCODE_E_MCAST_POISON (6)
+#define NIX_RX_PERRCODE_E_MEMOUT (9)
+#define NIX_RX_PERRCODE_E_MIRROR_FAULT (5)
+#define NIX_RX_PERRCODE_E_MIRROR_POISON (7)
+#define NIX_RX_PERRCODE_E_NPC_RESULT_ERR (2)
+#define NIX_RX_PERRCODE_E_OL3_LEN (0x10)
+#define NIX_RX_PERRCODE_E_OL4_CHK (0x12)
+#define NIX_RX_PERRCODE_E_OL4_LEN (0x11)
+#define NIX_RX_PERRCODE_E_OL4_PORT (0x13)
+
+/**
+ * Enumeration nix_send_status_e
+ *
+ * NIX Send Completion Status Enumeration Enumerates values of
+ * NIX_SEND_COMP_S[STATUS] and NIX_LF_SEND_ERR_DBG[ERRCODE].
+ */
+#define NIX_SEND_STATUS_E_DATA_FAULT (0x16)
+#define NIX_SEND_STATUS_E_DATA_POISON (0x17)
+#define NIX_SEND_STATUS_E_GOOD (0)
+#define NIX_SEND_STATUS_E_INVALID_SUBDC (0x14)
+#define NIX_SEND_STATUS_E_JUMP_FAULT (7)
+#define NIX_SEND_STATUS_E_JUMP_POISON (8)
+#define NIX_SEND_STATUS_E_LOCK_VIOL (0x21)
+#define NIX_SEND_STATUS_E_NPC_DROP_ACTION (0x20)
+#define NIX_SEND_STATUS_E_NPC_MCAST_ABORT (0x24)
+#define NIX_SEND_STATUS_E_NPC_MCAST_CHAN_ERR (0x23)
+#define NIX_SEND_STATUS_E_NPC_UCAST_CHAN_ERR (0x22)
+#define NIX_SEND_STATUS_E_NPC_VTAG_PTR_ERR (0x25)
+#define NIX_SEND_STATUS_E_NPC_VTAG_SIZE_ERR (0x26)
+#define NIX_SEND_STATUS_E_SEND_CRC_ERR (0x10)
+#define NIX_SEND_STATUS_E_SEND_EXT_ERR (6)
+#define NIX_SEND_STATUS_E_SEND_HDR_ERR (5)
+#define NIX_SEND_STATUS_E_SEND_IMM_ERR (0x11)
+#define NIX_SEND_STATUS_E_SEND_MEM_ERR (0x13)
+#define NIX_SEND_STATUS_E_SEND_MEM_FAULT (0x27)
+#define NIX_SEND_STATUS_E_SEND_SG_ERR (0x12)
+#define NIX_SEND_STATUS_E_SQB_FAULT (3)
+#define NIX_SEND_STATUS_E_SQB_POISON (4)
+#define NIX_SEND_STATUS_E_SQ_CTX_FAULT (1)
+#define NIX_SEND_STATUS_E_SQ_CTX_POISON (2)
+#define NIX_SEND_STATUS_E_SUBDC_ORDER_ERR (0x15)
+
+/**
+ * Enumeration nix_sendcrcalg_e
+ *
+ * NIX Send CRC Algorithm Enumeration Enumerates the CRC algorithm used,
+ * see NIX_SEND_CRC_S[ALG].
+ */
+#define NIX_SENDCRCALG_E_CRC32 (0)
+#define NIX_SENDCRCALG_E_CRC32C (1)
+#define NIX_SENDCRCALG_E_ONES16 (2)
+
+/**
+ * Enumeration nix_sendl3type_e
+ *
+ * NIX Send Layer 3 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL3TYPE], NIX_SEND_HDR_S[IL3TYPE]. Internal: Encoding
+ * matches DPDK TX IP types: \<pre\> PKT_TX_IP_CKSUM      (1ULL \<\< 54)
+ * PKT_TX_IPV4          (1ULL \<\< 55) PKT_TX_IPV6          (1ULL \<\<
+ * 56)  PKT_TX_OUTER_IP_CKSUM(1ULL \<\< 58) PKT_TX_OUTER_IPV4    (1ULL
+ * \<\< 59) PKT_TX_OUTER_IPV6    (1ULL \<\< 60) \</pre\>
+ */
+#define NIX_SENDL3TYPE_E_IP4 (2)
+#define NIX_SENDL3TYPE_E_IP4_CKSUM (3)
+#define NIX_SENDL3TYPE_E_IP6 (4)
+#define NIX_SENDL3TYPE_E_NONE (0)
+
+/**
+ * Enumeration nix_sendl4type_e
+ *
+ * NIX Send Layer 4 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL4TYPE], NIX_SEND_HDR_S[IL4TYPE]. Internal: Encoding
+ * matches DPDK TX L4 types. \<pre\> PKT_TX_L4_NO_CKSUM   (0ULL \<\< 52)
+ * // Disable L4 cksum of TX pkt. PKT_TX_TCP_CKSUM     (1ULL \<\< 52)  //
+ * TCP cksum of TX pkt. computed by nic. PKT_TX_SCTP_CKSUM    (2ULL \<\<
+ * 52)  // SCTP cksum of TX pkt. computed by nic. PKT_TX_UDP_CKSUM
+ * (3ULL \<\< 52)  // UDP cksum of TX pkt. computed by nic. \</pre\>
+ */
+#define NIX_SENDL4TYPE_E_NONE (0)
+#define NIX_SENDL4TYPE_E_SCTP_CKSUM (2)
+#define NIX_SENDL4TYPE_E_TCP_CKSUM (1)
+#define NIX_SENDL4TYPE_E_UDP_CKSUM (3)
+
+/**
+ * Enumeration nix_sendldtype_e
+ *
+ * NIX Send Load Type Enumeration Enumerates the load transaction types
+ * for reading segment bytes specified by NIX_SEND_SG_S[LD_TYPE] and
+ * NIX_SEND_JUMP_S[LD_TYPE].  Internal: The hardware implementation
+ * treats undefined encodings as LDD load type.
+ */
+#define NIX_SENDLDTYPE_E_LDD (0)
+#define NIX_SENDLDTYPE_E_LDT (1)
+#define NIX_SENDLDTYPE_E_LDWB (2)
+
+/**
+ * Enumeration nix_sendmemalg_e
+ *
+ * NIX Memory Modify Algorithm Enumeration Enumerates the different
+ * algorithms for modifying memory; see NIX_SEND_MEM_S[ALG]. mbufs_freed
+ * is the number of gather buffers freed to NPA for the send descriptor.
+ * See NIX_SEND_HDR_S[DF] and NIX_SEND_SG_S[I*].
+ */
+#define NIX_SENDMEMALG_E_ADD (8)
+#define NIX_SENDMEMALG_E_ADDLEN (0xa)
+#define NIX_SENDMEMALG_E_ADDMBUF (0xc)
+#define NIX_SENDMEMALG_E_SET (0)
+#define NIX_SENDMEMALG_E_SETRSLT (2)
+#define NIX_SENDMEMALG_E_SETTSTMP (1)
+#define NIX_SENDMEMALG_E_SUB (9)
+#define NIX_SENDMEMALG_E_SUBLEN (0xb)
+#define NIX_SENDMEMALG_E_SUBMBUF (0xd)
+
+/**
+ * Enumeration nix_sendmemdsz_e
+ *
+ * NIX Memory Data Size Enumeration Enumerates the datum size for
+ * modifying memory; see NIX_SEND_MEM_S[DSZ].
+ */
+#define NIX_SENDMEMDSZ_E_B16 (2)
+#define NIX_SENDMEMDSZ_E_B32 (1)
+#define NIX_SENDMEMDSZ_E_B64 (0)
+#define NIX_SENDMEMDSZ_E_B8 (3)
+
+/**
+ * Enumeration nix_sqint_e
+ *
+ * NIX Send Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_SQ_CTX_S[SQ_INT,SQ_INT_ENA].
+ */
+#define NIX_SQINT_E_LMT_ERR (0)
+#define NIX_SQINT_E_MNQ_ERR (1)
+#define NIX_SQINT_E_SEND_ERR (2)
+#define NIX_SQINT_E_SQB_ALLOC_FAIL (3)
+
+/**
+ * Enumeration nix_sqoperr_e
+ *
+ * NIX SQ Operation Error Enumeration Enumerates
+ * NIX_LF_SQ_OP_ERR_DBG[ERRCODE] values.
+ */
+#define NIX_SQOPERR_E_MAX_SQE_SIZE_ERR (4)
+#define NIX_SQOPERR_E_SQB_FAULT (7)
+#define NIX_SQOPERR_E_SQB_NULL (6)
+#define NIX_SQOPERR_E_SQE_OFLOW (5)
+#define NIX_SQOPERR_E_SQE_SIZEM1_ZERO (8)
+#define NIX_SQOPERR_E_SQ_CTX_FAULT (1)
+#define NIX_SQOPERR_E_SQ_CTX_POISON (2)
+#define NIX_SQOPERR_E_SQ_DISABLED (3)
+#define NIX_SQOPERR_E_SQ_OOR (0)
+
+/**
+ * Enumeration nix_stat_lf_rx_e
+ *
+ * NIX Local Function Receive Statistics Enumeration Enumerates the last
+ * index of NIX_AF_LF()_RX_STAT() and NIX_LF_RX_STAT().
+ */
+#define NIX_STAT_LF_RX_E_RX_BCAST (2)
+#define NIX_STAT_LF_RX_E_RX_DROP (4)
+#define NIX_STAT_LF_RX_E_RX_DROP_OCTS (5)
+#define NIX_STAT_LF_RX_E_RX_DRP_BCAST (8)
+#define NIX_STAT_LF_RX_E_RX_DRP_L3BCAST (0xa)
+#define NIX_STAT_LF_RX_E_RX_DRP_L3MCAST (0xb)
+#define NIX_STAT_LF_RX_E_RX_DRP_MCAST (9)
+#define NIX_STAT_LF_RX_E_RX_ERR (7)
+#define NIX_STAT_LF_RX_E_RX_FCS (6)
+#define NIX_STAT_LF_RX_E_RX_MCAST (3)
+#define NIX_STAT_LF_RX_E_RX_OCTS (0)
+#define NIX_STAT_LF_RX_E_RX_UCAST (1)
+
+/**
+ * Enumeration nix_stat_lf_tx_e
+ *
+ * NIX Local Function Transmit Statistics Enumeration Enumerates the
+ * index of NIX_AF_LF()_TX_STAT() and NIX_LF_TX_STAT(). These statistics
+ * do not account for packet replication due to NIX_TX_ACTION_S[OP] =
+ * NIX_TX_ACTIONOP_E::MCAST.
+ */
+#define NIX_STAT_LF_TX_E_TX_BCAST (1)
+#define NIX_STAT_LF_TX_E_TX_DROP (3)
+#define NIX_STAT_LF_TX_E_TX_MCAST (2)
+#define NIX_STAT_LF_TX_E_TX_OCTS (4)
+#define NIX_STAT_LF_TX_E_TX_UCAST (0)
+
+/**
+ * Enumeration nix_stype_e
+ *
+ * NIX SQB Caching Type Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[SQE_STYPE].
+ */
+#define NIX_STYPE_E_STF (0)
+#define NIX_STYPE_E_STP (2)
+#define NIX_STYPE_E_STT (1)
+
+/**
+ * Enumeration nix_subdc_e
+ *
+ * NIX Subdescriptor Operation Enumeration Enumerates send and receive
+ * subdescriptor codes. The codes differentiate subdescriptors within a
+ * NIX send or receive descriptor, excluding NIX_SEND_HDR_S for send and
+ * NIX_CQE_HDR_S/NIX_WQE_HDR_S for receive, which are determined by their
+ * position as the first subdescriptor, and NIX_RX_PARSE_S, which is
+ * determined by its position as the second subdescriptor.
+ */
+#define NIX_SUBDC_E_CRC (2)
+#define NIX_SUBDC_E_EXT (1)
+#define NIX_SUBDC_E_IMM (3)
+#define NIX_SUBDC_E_JUMP (6)
+#define NIX_SUBDC_E_MEM (5)
+#define NIX_SUBDC_E_NOP (0)
+#define NIX_SUBDC_E_SG (4)
+#define NIX_SUBDC_E_SOD (0xf)
+#define NIX_SUBDC_E_WORK (7)
+
+/**
+ * Enumeration nix_tx_actionop_e
+ *
+ * NIX Transmit Action Opcode Enumeration Enumerates the values of
+ * NIX_TX_ACTION_S[OP].
+ */
+#define NIX_TX_ACTIONOP_E_DROP (0)
+#define NIX_TX_ACTIONOP_E_DROP_VIOL (5)
+#define NIX_TX_ACTIONOP_E_MCAST (3)
+#define NIX_TX_ACTIONOP_E_UCAST_CHAN (2)
+#define NIX_TX_ACTIONOP_E_UCAST_DEFAULT (1)
+
+/**
+ * Enumeration nix_tx_vtagop_e
+ *
+ * NIX Transmit Vtag Opcode Enumeration Enumerates the values of
+ * NIX_TX_VTAG_ACTION_S[VTAG0_OP,VTAG1_OP].
+ */
+#define NIX_TX_VTAGOP_E_INSERT (1)
+#define NIX_TX_VTAGOP_E_NOP (0)
+#define NIX_TX_VTAGOP_E_REPLACE (2)
+
+/**
+ * Enumeration nix_txlayer_e
+ *
+ * NIX Transmit Layer Enumeration Enumerates the values of
+ * NIX_AF_LSO_FORMAT()_FIELD()[LAYER].
+ */
+#define NIX_TXLAYER_E_IL3 (2)
+#define NIX_TXLAYER_E_IL4 (3)
+#define NIX_TXLAYER_E_OL3 (0)
+#define NIX_TXLAYER_E_OL4 (1)
+
+/**
+ * Enumeration nix_vtagsize_e
+ *
+ * NIX Vtag Size Enumeration Enumerates the values of
+ * NIX_AF_TX_VTAG_DEF()_CTL[SIZE] and NIX_AF_LF()_RX_VTAG_TYPE()[SIZE].
+ */
+#define NIX_VTAGSIZE_E_T4 (0)
+#define NIX_VTAGSIZE_E_T8 (1)
+
+/**
+ * Enumeration nix_xqe_type_e
+ *
+ * NIX WQE/CQE Type Enumeration Enumerates the values of
+ * NIX_WQE_HDR_S[WQE_TYPE], NIX_CQE_HDR_S[CQE_TYPE].
+ */
+#define NIX_XQE_TYPE_E_INVALID (0)
+#define NIX_XQE_TYPE_E_RX (1)
+#define NIX_XQE_TYPE_E_RX_IPSECD (4)
+#define NIX_XQE_TYPE_E_RX_IPSECH (3)
+#define NIX_XQE_TYPE_E_RX_IPSECS (2)
+#define NIX_XQE_TYPE_E_SEND (8)
+
+/**
+ * Enumeration nix_xqesz_e
+ *
+ * NIX WQE/CQE Size Enumeration Enumerates the values of
+ * NIX_AF_LF()_CFG[XQE_SIZE].
+ */
+#define NIX_XQESZ_E_W16 (1)
+#define NIX_XQESZ_E_W64 (0)
+
+/**
+ * Structure nix_aq_inst_s
+ *
+ * NIX Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
+ * Hardware reads of NIX_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context. For example: * When [CTYPE] = NIX_AQ_CTYPE_E::RQ: use
+ * NIX_AF_LF()_RSS_CFG[CACHING] and NIX_AF_LF()_RSS_CFG[WAY_MASK]. * When
+ * [CTYPE] = NIX_AQ_CTYPE_E::MCE: use NIX_AF_RX_MCAST_CFG[CACHING] and
+ * NIX_AF_RX_MCAST_CFG[WAY_MASK].
+ */
+union nix_aq_inst_s {
+	u64 u[2];
+	struct nix_aq_inst_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 lf                               : 7;
+		u64 reserved_15_23                   : 9;
+		u64 cindex                           : 20;
+		u64 reserved_44_62                   : 19;
+		u64 doneint                          : 1;
+		u64 res_addr                         : 64;
+	} s;
+	/* struct nix_aq_inst_s_s cn; */
+};
+
+/**
+ * Structure nix_aq_res_s
+ *
+ * NIX Admin Queue Result Structure NIX writes this structure after it
+ * completes the NIX_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
+ * When [OP] = NIX_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
+ * immediately followed by context read or write data. See
+ * NIX_AQ_INSTOP_E.  Hardware writes of NIX_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
+ */
+union nix_aq_res_s {
+	u64 u[2];
+	struct nix_aq_res_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 compcode                         : 8;
+		u64 doneint                          : 1;
+		u64 reserved_17_63                   : 47;
+		u64 reserved_64_127                  : 64;
+	} s;
+	/* struct nix_aq_res_s_s cn; */
+};
+
+/**
+ * Structure nix_cint_hw_s
+ *
+ * NIX Completion Interrupt Context Hardware Structure This structure
+ * contains context state maintained by hardware for each completion
+ * interrupt (CINT) in NDC/LLC/DRAM. Software accesses this structure
+ * with the NIX_LF_CINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures per LF
+ * starting at AF IOVA NIX_AF_LF()_CINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union nix_cint_hw_s {
+	u64 u[2];
+	struct nix_cint_hw_s_s {
+		u64 ecount                           : 32;
+		u64 qcount                           : 16;
+		u64 intr                             : 1;
+		u64 ena                              : 1;
+		u64 timer_idx                        : 8;
+		u64 reserved_58_63                   : 6;
+		u64 ecount_wait                      : 32;
+		u64 qcount_wait                      : 16;
+		u64 time_wait                        : 8;
+		u64 reserved_120_127                 : 8;
+	} s;
+	/* struct nix_cint_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_cq_ctx_s
+ *
+ * NIX Completion Queue Context Structure This structure contains context
+ * state maintained by hardware for each CQ in NDC/LLC/DRAM. Software
+ * uses the same structure format to read and write an CQ context with
+ * the NIX admin queue.
+ */
+union nix_cq_ctx_s {
+	u64 u[4];
+	struct nix_cq_ctx_s_s {
+		u64 base                             : 64;
+		u64 reserved_64_67                   : 4;
+		u64 bp_ena                           : 1;
+		u64 reserved_69_71                   : 3;
+		u64 bpid                             : 9;
+		u64 reserved_81_83                   : 3;
+		u64 qint_idx                         : 7;
+		u64 cq_err                           : 1;
+		u64 cint_idx                         : 7;
+		u64 avg_con                          : 9;
+		u64 wrptr                            : 20;
+		u64 tail                             : 20;
+		u64 head                             : 20;
+		u64 avg_level                        : 8;
+		u64 update_time                      : 16;
+		u64 bp                               : 8;
+		u64 drop                             : 8;
+		u64 drop_ena                         : 1;
+		u64 ena                              : 1;
+		u64 reserved_210_211                 : 2;
+		u64 substream                        : 20;
+		u64 caching                          : 1;
+		u64 reserved_233_235                 : 3;
+		u64 qsize                            : 4;
+		u64 cq_err_int                       : 8;
+		u64 cq_err_int_ena                   : 8;
+	} s;
+	/* struct nix_cq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_cqe_hdr_s
+ *
+ * NIX Completion Queue Entry Header Structure This 64-bit structure
+ * defines the first word of every CQE. It is immediately followed by
+ * NIX_RX_PARSE_S in a receive CQE, and by NIX_SEND_COMP_S in a send
+ * completion CQE. Stored in memory as little-endian unless
+ * NIX_AF_LF()_CFG[BE] is set.
+ */
+union nix_cqe_hdr_s {
+	u64 u;
+	struct nix_cqe_hdr_s_s {
+		u64 tag                              : 32;
+		u64 q                                : 20;
+		u64 reserved_52_57                   : 6;
+		u64 node                             : 2;
+		u64 cqe_type                         : 4;
+	} s;
+	/* struct nix_cqe_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_inst_hdr_s
+ *
+ * NIX Instruction Header Structure This structure defines the
+ * instruction header that precedes the packet header supplied to NPC for
+ * packets to be transmitted by NIX.
+ */
+union nix_inst_hdr_s {
+	u64 u;
+	struct nix_inst_hdr_s_s {
+		u64 pf_func                          : 16;
+		u64 sq                               : 20;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct nix_inst_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_iova_s
+ *
+ * NIX I/O Virtual Address Structure
+ */
+union nix_iova_s {
+	u64 u;
+	struct nix_iova_s_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct nix_iova_s_s cn; */
+};
+
+/**
+ * Structure nix_ipsec_dyno_s
+ *
+ * INTERNAL: NIX IPSEC Dynamic Ordering Counter Structure  Internal: Not
+ * used; no IPSEC fast-path.
+ */
+union nix_ipsec_dyno_s {
+	u32 u;
+	struct nix_ipsec_dyno_s_s {
+		u32 count                            : 32;
+	} s;
+	/* struct nix_ipsec_dyno_s_s cn; */
+};
+
+/**
+ * Structure nix_mem_result_s
+ *
+ * NIX Memory Value Structure When
+ * NIX_SEND_MEM_S[ALG]=NIX_SENDMEMALG_E::SETRSLT, the value written to
+ * memory is formed with this structure.
+ */
+union nix_mem_result_s {
+	u64 u;
+	struct nix_mem_result_s_s {
+		u64 v                                : 1;
+		u64 color                            : 2;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct nix_mem_result_s_s cn; */
+};
+
+/**
+ * Structure nix_op_q_wdata_s
+ *
+ * NIX Statistics Operation Write Data Structure This structure specifies
+ * the write data format of an atomic 64-bit load-and-add of some
+ * NIX_LF_RQ_OP_*, NIX_LF_SQ_OP* and NIX_LF_CQ_OP* registers.
+ */
+union nix_op_q_wdata_s {
+	u64 u;
+	struct nix_op_q_wdata_s_s {
+		u64 reserved_0_31                    : 32;
+		u64 q                                : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct nix_op_q_wdata_s_s cn; */
+};
+
+/**
+ * Structure nix_qint_hw_s
+ *
+ * NIX Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NIX_LF_QINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[QINTS] contiguous NIX_QINT_HW_S structures per LF
+ * starting at IOVA NIX_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union nix_qint_hw_s {
+	u32 u;
+	struct nix_qint_hw_s_s {
+		u32 count                            : 22;
+		u32 reserved_22_30                   : 9;
+		u32 ena                              : 1;
+	} s;
+	/* struct nix_qint_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_rq_ctx_hw_s
+ *
+ * NIX Receive Queue Context Structure This structure contains context
+ * state maintained by hardware for each RQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_RQ_CTX_S structure format to read and write an
+ * RQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
+ */
+union nix_rq_ctx_hw_s {
+	u64 u[16];
+	struct nix_rq_ctx_hw_s_s {
+		u64 ena                              : 1;
+		u64 sso_ena                          : 1;
+		u64 ipsech_ena                       : 1;
+		u64 ena_wqwd                         : 1;
+		u64 cq                               : 20;
+		u64 substream                        : 20;
+		u64 wqe_aura                         : 20;
+		u64 spb_aura                         : 20;
+		u64 lpb_aura                         : 20;
+		u64 sso_grp                          : 10;
+		u64 sso_tt                           : 2;
+		u64 pb_caching                       : 2;
+		u64 wqe_caching                      : 1;
+		u64 xqe_drop_ena                     : 1;
+		u64 spb_drop_ena                     : 1;
+		u64 lpb_drop_ena                     : 1;
+		u64 wqe_skip                         : 2;
+		u64 reserved_124_127                 : 4;
+		u64 reserved_128_139                 : 12;
+		u64 spb_sizem1                       : 6;
+		u64 reserved_146_150                 : 5;
+		u64 spb_ena                          : 1;
+		u64 lpb_sizem1                       : 12;
+		u64 first_skip                       : 7;
+		u64 reserved_171                     : 1;
+		u64 later_skip                       : 6;
+		u64 xqe_imm_size                     : 6;
+		u64 reserved_184_189                 : 6;
+		u64 xqe_imm_copy                     : 1;
+		u64 xqe_hdr_split                    : 1;
+		u64 xqe_drop                         : 8;
+		u64 xqe_pass                         : 8;
+		u64 wqe_pool_drop                    : 8;
+		u64 wqe_pool_pass                    : 8;
+		u64 spb_aura_drop                    : 8;
+		u64 spb_aura_pass                    : 8;
+		u64 spb_pool_drop                    : 8;
+		u64 spb_pool_pass                    : 8;
+		u64 lpb_aura_drop                    : 8;
+		u64 lpb_aura_pass                    : 8;
+		u64 lpb_pool_drop                    : 8;
+		u64 lpb_pool_pass                    : 8;
+		u64 reserved_288_319                 : 32;
+		u64 ltag                             : 24;
+		u64 good_utag                        : 8;
+		u64 bad_utag                         : 8;
+		u64 flow_tagw                        : 6;
+		u64 reserved_366_383                 : 18;
+		u64 octs                             : 48;
+		u64 reserved_432_447                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_496_511                 : 16;
+		u64 drop_octs                        : 48;
+		u64 reserved_560_575                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_624_639                 : 16;
+		u64 re_pkts                          : 48;
+		u64 reserved_688_702                 : 15;
+		u64 ena_copy                         : 1;
+		u64 reserved_704_739                 : 36;
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 qint_idx                         : 7;
+		u64 reserved_763_767                 : 5;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct nix_rq_ctx_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_rq_ctx_s
+ *
+ * NIX Receive Queue Context Structure This structure specifies the
+ * format used by software to read and write an RQ context with the NIX
+ * admin queue.
+ */
+union nix_rq_ctx_s {
+	u64 u[16];
+	struct nix_rq_ctx_s_s {
+		u64 ena                              : 1;
+		u64 sso_ena                          : 1;
+		u64 ipsech_ena                       : 1;
+		u64 ena_wqwd                         : 1;
+		u64 cq                               : 20;
+		u64 substream                        : 20;
+		u64 wqe_aura                         : 20;
+		u64 spb_aura                         : 20;
+		u64 lpb_aura                         : 20;
+		u64 sso_grp                          : 10;
+		u64 sso_tt                           : 2;
+		u64 pb_caching                       : 2;
+		u64 wqe_caching                      : 1;
+		u64 xqe_drop_ena                     : 1;
+		u64 spb_drop_ena                     : 1;
+		u64 lpb_drop_ena                     : 1;
+		u64 reserved_122_127                 : 6;
+		u64 reserved_128_139                 : 12;
+		u64 spb_sizem1                       : 6;
+		u64 wqe_skip                         : 2;
+		u64 reserved_148_150                 : 3;
+		u64 spb_ena                          : 1;
+		u64 lpb_sizem1                       : 12;
+		u64 first_skip                       : 7;
+		u64 reserved_171                     : 1;
+		u64 later_skip                       : 6;
+		u64 xqe_imm_size                     : 6;
+		u64 reserved_184_189                 : 6;
+		u64 xqe_imm_copy                     : 1;
+		u64 xqe_hdr_split                    : 1;
+		u64 xqe_drop                         : 8;
+		u64 xqe_pass                         : 8;
+		u64 wqe_pool_drop                    : 8;
+		u64 wqe_pool_pass                    : 8;
+		u64 spb_aura_drop                    : 8;
+		u64 spb_aura_pass                    : 8;
+		u64 spb_pool_drop                    : 8;
+		u64 spb_pool_pass                    : 8;
+		u64 lpb_aura_drop                    : 8;
+		u64 lpb_aura_pass                    : 8;
+		u64 lpb_pool_drop                    : 8;
+		u64 lpb_pool_pass                    : 8;
+		u64 reserved_288_291                 : 4;
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 qint_idx                         : 7;
+		u64 reserved_315_319                 : 5;
+		u64 ltag                             : 24;
+		u64 good_utag                        : 8;
+		u64 bad_utag                         : 8;
+		u64 flow_tagw                        : 6;
+		u64 reserved_366_383                 : 18;
+		u64 octs                             : 48;
+		u64 reserved_432_447                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_496_511                 : 16;
+		u64 drop_octs                        : 48;
+		u64 reserved_560_575                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_624_639                 : 16;
+		u64 re_pkts                          : 48;
+		u64 reserved_688_703                 : 16;
+		u64 reserved_704_767                 : 64;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct nix_rq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_rsse_s
+ *
+ * NIX Receive Side Scaling Entry Structure This structure specifies the
+ * format of each hardware entry in the NIX RSS tables in NDC/LLC/DRAM.
+ * See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP(). Software uses the
+ * same structure format to read and write an RSS table entry with the
+ * NIX admin queue.
+ */
+union nix_rsse_s {
+	u32 u;
+	struct nix_rsse_s_s {
+		u32 rq                               : 20;
+		u32 reserved_20_31                   : 12;
+	} s;
+	/* struct nix_rsse_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_action_s
+ *
+ * NIX Receive Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a receive packet.
+ */
+union nix_rx_action_s {
+	u64 u;
+	struct nix_rx_action_s_s {
+		u64 op                               : 4;
+		u64 pf_func                          : 16;
+		u64 index                            : 20;
+		u64 match_id                         : 16;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_61_63                   : 3;
+	} s;
+	/* struct nix_rx_action_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_imm_s
+ *
+ * NIX Receive Immediate Subdescriptor Structure The receive immediate
+ * subdescriptor indicates that bytes immediately following this
+ * NIX_RX_IMM_S (after skipping [APAD] bytes) were saved from the
+ * received packet. The next subdescriptor following this NIX_RX_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.
+ */
+union nix_rx_imm_s {
+	u64 u;
+	struct nix_rx_imm_s_s {
+		u64 size                             : 16;
+		u64 apad                             : 3;
+		u64 reserved_19_59                   : 41;
+		u64 subdc                            : 4;
+	} s;
+	/* struct nix_rx_imm_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_mce_s
+ *
+ * NIX Receive Multicast/Mirror Entry Structure This structure specifies
+ * the format of entries in the NIX receive multicast/mirror table
+ * maintained by hardware in NDC/LLC/DRAM. See NIX_AF_RX_MCAST_BASE and
+ * NIX_AF_RX_MCAST_CFG. Note the table may contain both multicast and
+ * mirror replication lists. Software uses the same structure format to
+ * read and write a multicast/mirror table entry with the NIX admin
+ * queue.
+ */
+union nix_rx_mce_s {
+	u64 u;
+	struct nix_rx_mce_s_s {
+		u64 op                               : 2;
+		u64 reserved_2                       : 1;
+		u64 eol                              : 1;
+		u64 index                            : 20;
+		u64 reserved_24_31                   : 8;
+		u64 pf_func                          : 16;
+		u64 next                             : 16;
+	} s;
+	/* struct nix_rx_mce_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_parse_s
+ *
+ * NIX Receive Parse Structure This structure contains the receive packet
+ * parse result. It immediately follows NIX_CQE_HDR_S in a receive CQE,
+ * or NIX_WQE_HDR_S in a receive WQE. Stored in memory as little-endian
+ * unless NIX_AF_LF()_CFG[BE] is set.  Header layers are always 2-byte
+ * aligned, so all header pointers in this structure ([EOH_PTR], [LAPTR]
+ * through [LHPTR], [VTAG*_PTR]) are even.
+ */
+union nix_rx_parse_s {
+	u64 u[7];
+	struct nix_rx_parse_s_s {
+		u64 chan                             : 12;
+		u64 desc_sizem1                      : 5;
+		u64 imm_copy                         : 1;
+		u64 express                          : 1;
+		u64 wqwd                             : 1;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 latype                           : 4;
+		u64 lbtype                           : 4;
+		u64 lctype                           : 4;
+		u64 ldtype                           : 4;
+		u64 letype                           : 4;
+		u64 lftype                           : 4;
+		u64 lgtype                           : 4;
+		u64 lhtype                           : 4;
+		u64 pkt_lenm1                        : 16;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 vtag0_valid                      : 1;
+		u64 vtag0_gone                       : 1;
+		u64 vtag1_valid                      : 1;
+		u64 vtag1_gone                       : 1;
+		u64 pkind                            : 6;
+		u64 nix_idx                          : 2;
+		u64 vtag0_tci                        : 16;
+		u64 vtag1_tci                        : 16;
+		u64 laflags                          : 8;
+		u64 lbflags                          : 8;
+		u64 lcflags                          : 8;
+		u64 ldflags                          : 8;
+		u64 leflags                          : 8;
+		u64 lfflags                          : 8;
+		u64 lgflags                          : 8;
+		u64 lhflags                          : 8;
+		u64 eoh_ptr                          : 8;
+		u64 wqe_aura                         : 20;
+		u64 pb_aura                          : 20;
+		u64 match_id                         : 16;
+		u64 laptr                            : 8;
+		u64 lbptr                            : 8;
+		u64 lcptr                            : 8;
+		u64 ldptr                            : 8;
+		u64 leptr                            : 8;
+		u64 lfptr                            : 8;
+		u64 lgptr                            : 8;
+		u64 lhptr                            : 8;
+		u64 vtag0_ptr                        : 8;
+		u64 vtag1_ptr                        : 8;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_341_383                 : 43;
+		u64 reserved_384_447                 : 64;
+	} s;
+	struct nix_rx_parse_s_cn96xx {
+		u64 chan                             : 12;
+		u64 desc_sizem1                      : 5;
+		u64 imm_copy                         : 1;
+		u64 express                          : 1;
+		u64 wqwd                             : 1;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 latype                           : 4;
+		u64 lbtype                           : 4;
+		u64 lctype                           : 4;
+		u64 ldtype                           : 4;
+		u64 letype                           : 4;
+		u64 lftype                           : 4;
+		u64 lgtype                           : 4;
+		u64 lhtype                           : 4;
+		u64 pkt_lenm1                        : 16;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 vtag0_valid                      : 1;
+		u64 vtag0_gone                       : 1;
+		u64 vtag1_valid                      : 1;
+		u64 vtag1_gone                       : 1;
+		u64 pkind                            : 6;
+		u64 reserved_94_95                   : 2;
+		u64 vtag0_tci                        : 16;
+		u64 vtag1_tci                        : 16;
+		u64 laflags                          : 8;
+		u64 lbflags                          : 8;
+		u64 lcflags                          : 8;
+		u64 ldflags                          : 8;
+		u64 leflags                          : 8;
+		u64 lfflags                          : 8;
+		u64 lgflags                          : 8;
+		u64 lhflags                          : 8;
+		u64 eoh_ptr                          : 8;
+		u64 wqe_aura                         : 20;
+		u64 pb_aura                          : 20;
+		u64 match_id                         : 16;
+		u64 laptr                            : 8;
+		u64 lbptr                            : 8;
+		u64 lcptr                            : 8;
+		u64 ldptr                            : 8;
+		u64 leptr                            : 8;
+		u64 lfptr                            : 8;
+		u64 lgptr                            : 8;
+		u64 lhptr                            : 8;
+		u64 vtag0_ptr                        : 8;
+		u64 vtag1_ptr                        : 8;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_341_383                 : 43;
+		u64 reserved_384_447                 : 64;
+	} cn96xx;
+	/* struct nix_rx_parse_s_s cn98xx; */
+	/* struct nix_rx_parse_s_cn96xx cnf95xx; */
+	/* struct nix_rx_parse_s_cn96xx loki; */
+};
+
+/**
+ * Structure nix_rx_sg_s
+ *
+ * NIX Receive Scatter/Gather Subdescriptor Structure The receive
+ * scatter/gather subdescriptor specifies one to three segments of packet
+ * data bytes. There may be multiple NIX_RX_SG_Ss in each NIX receive
+ * descriptor.  NIX_RX_SG_S is immediately followed by one NIX_IOVA_S
+ * word when [SEGS] = 1, three NIX_IOVA_S words when [SEGS] \>= 2. Each
+ * NIX_IOVA_S word specifies the LF IOVA of first packet data byte in the
+ * corresponding segment; first NIX_IOVA_S word for segment 1, second
+ * word for segment 2, third word for segment 3. Note the third word is
+ * present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
+ */
+union nix_rx_sg_s {
+	u64 u;
+	struct nix_rx_sg_s_s {
+		u64 seg1_size                        : 16;
+		u64 seg2_size                        : 16;
+		u64 seg3_size                        : 16;
+		u64 segs                             : 2;
+		u64 reserved_50_59                   : 10;
+		u64 subdc                            : 4;
+	} s;
+	/* struct nix_rx_sg_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_vtag_action_s
+ *
+ * NIX Receive Vtag Action Structure This structure defines the format of
+ * NPC_RESULT_S[VTAG_ACTION] for a receive packet. It specifies up to two
+ * Vtags (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG) for optional capture
+ * and/or stripping.
+ */
+union nix_rx_vtag_action_s {
+	u64 u;
+	struct nix_rx_vtag_action_s_s {
+		u64 vtag0_relptr                     : 8;
+		u64 vtag0_lid                        : 3;
+		u64 reserved_11                      : 1;
+		u64 vtag0_type                       : 3;
+		u64 vtag0_valid                      : 1;
+		u64 reserved_16_31                   : 16;
+		u64 vtag1_relptr                     : 8;
+		u64 vtag1_lid                        : 3;
+		u64 reserved_43                      : 1;
+		u64 vtag1_type                       : 3;
+		u64 vtag1_valid                      : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nix_rx_vtag_action_s_s cn; */
+};
+
+/**
+ * Structure nix_send_comp_s
+ *
+ * NIX Send Completion Structure This structure immediately follows
+ * NIX_CQE_HDR_S in a send completion CQE.
+ */
+union nix_send_comp_s {
+	u64 u;
+	struct nix_send_comp_s_s {
+		u64 status                           : 8;
+		u64 sqe_id                           : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nix_send_comp_s_s cn; */
+};
+
+/**
+ * Structure nix_send_crc_s
+ *
+ * NIX Send CRC Subdescriptor Structure The send CRC subdescriptor
+ * specifies a CRC calculation be performed during transmission. Ignored
+ * when present in a send descriptor with NIX_SEND_EXT_S[LSO] set. There
+ * may be up to two NIX_SEND_CRC_Ss per send descriptor.  NIX_SEND_CRC_S
+ * constraints: * When present, NIX_SEND_CRC_S subdescriptors must
+ * precede all NIX_SEND_SG_S, NIX_SEND_IMM_S and NIX_SEND_MEM_S
+ * subdescriptors in the send descriptor. * NIX_SEND_CRC_S subdescriptors
+ * must follow the same order as their checksum and insert regions in the
+ * packet, i.e. the checksum and insert regions of a NIX_SEND_CRC_S must
+ * come after the checksum and insert regions of a preceding
+ * NIX_SEND_CRC_S. There must be no overlap between any NIX_SEND_CRC_S
+ * checksum and insert regions. * If either
+ * NIX_SEND_HDR_S[OL4TYPE,IL4TYPE] = NIX_SENDL4TYPE_E::SCTP_CKSUM, the
+ * SCTP checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap, and likewise the NIX_SEND_CRC_S checksum region and SCTP
+ * insert region must not overlap. * If either
+ * NIX_SEND_HDR_S[OL3TYPE,IL3TYPE] = NIX_SENDL3TYPE_E::IP4_CKSUM, the
+ * IPv4 header checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap. * Any checksums inserted by
+ * NIX_SEND_HDR_S[OL3TYPE,OL4TYPE,IL3TYPE,IL4TYPE] must be outside of the
+ * NIX_SEND_CRC_S checksum and insert regions.  Hardware adjusts [START],
+ * [SIZE] and [INSERT] as needed to account for any VLAN inserted by
+ * NIX_SEND_EXT_S[VLAN*] or Vtag inserted by NIX_TX_VTAG_ACTION_S.
+ */
+union nix_send_crc_s {
+	u64 u[2];
+	struct nix_send_crc_s_s {
+		u64 size                             : 16;
+		u64 start                            : 16;
+		u64 insert                           : 16;
+		u64 reserved_48_57                   : 10;
+		u64 alg                              : 2;
+		u64 subdc                            : 4;
+		u64 iv                               : 32;
+		u64 reserved_96_127                  : 32;
+	} s;
+	/* struct nix_send_crc_s_s cn; */
+};
+
+/**
+ * Structure nix_send_ext_s
+ *
+ * NIX Send Extended Header Subdescriptor Structure The send extended
+ * header specifies LSO, VLAN insertion, timestamp and/or scheduling
+ * services on the packet. If present, it must immediately follow
+ * NIX_SEND_HDR_S. All fields are assumed to be zero when this
+ * subdescriptor is not present.
+ */
+union nix_send_ext_s {
+	u64 u[2];
+	struct nix_send_ext_s_s {
+		u64 lso_mps                          : 14;
+		u64 lso                              : 1;
+		u64 tstmp                            : 1;
+		u64 lso_sb                           : 8;
+		u64 lso_format                       : 5;
+		u64 reserved_29_31                   : 3;
+		u64 shp_chg                          : 9;
+		u64 shp_dis                          : 1;
+		u64 shp_ra                           : 2;
+		u64 markptr                          : 8;
+		u64 markform                         : 7;
+		u64 mark_en                          : 1;
+		u64 subdc                            : 4;
+		u64 vlan0_ins_ptr                    : 8;
+		u64 vlan0_ins_tci                    : 16;
+		u64 vlan1_ins_ptr                    : 8;
+		u64 vlan1_ins_tci                    : 16;
+		u64 vlan0_ins_ena                    : 1;
+		u64 vlan1_ins_ena                    : 1;
+		u64 reserved_114_127                 : 14;
+	} s;
+	/* struct nix_send_ext_s_s cn; */
+};
+
+/**
+ * Structure nix_send_hdr_s
+ *
+ * NIX Send Header Subdescriptor Structure The send header is the first
+ * subdescriptor of every send descriptor.
+ */
+union nix_send_hdr_s {
+	u64 u[2];
+	struct nix_send_hdr_s_s {
+		u64 total                            : 18;
+		u64 reserved_18                      : 1;
+		u64 df                               : 1;
+		u64 aura                             : 20;
+		u64 sizem1                           : 3;
+		u64 pnc                              : 1;
+		u64 sq                               : 20;
+		u64 ol3ptr                           : 8;
+		u64 ol4ptr                           : 8;
+		u64 il3ptr                           : 8;
+		u64 il4ptr                           : 8;
+		u64 ol3type                          : 4;
+		u64 ol4type                          : 4;
+		u64 il3type                          : 4;
+		u64 il4type                          : 4;
+		u64 sqe_id                           : 16;
+	} s;
+	/* struct nix_send_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_send_imm_s
+ *
+ * NIX Send Immediate Subdescriptor Structure The send immediate
+ * subdescriptor requests that bytes immediately following this
+ * NIX_SEND_IMM_S (after skipping [APAD] bytes) are to be included in the
+ * packet data. The next subdescriptor following this NIX_SEND_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.  There may be multiple
+ * NIX_SEND_IMM_S in one NIX send descriptor. A NIX_SEND_IMM_S is ignored
+ * in a NIX send descriptor if the sum of all prior
+ * NIX_SEND_SG_S[SEG*_SIZE]s and NIX_SEND_IMM_S[SIZE]s meets or exceeds
+ * NIX_SEND_HDR_S[TOTAL].  When NIX_SEND_EXT_S[LSO] is set in the
+ * descriptor, all NIX_SEND_IMM_S bytes must be included in the first
+ * NIX_SEND_EXT_S[LSO_SB] bytes of the source packet.
+ */
+union nix_send_imm_s {
+	u64 u;
+	struct nix_send_imm_s_s {
+		u64 size                             : 16;
+		u64 apad                             : 3;
+		u64 reserved_19_59                   : 41;
+		u64 subdc                            : 4;
+	} s;
+	/* struct nix_send_imm_s_s cn; */
+};
+
+/**
+ * Structure nix_send_jump_s
+ *
+ * NIX Send Jump Subdescriptor Structure The send jump subdescriptor
+ * selects a new address for fetching the remaining subdescriptors of a
+ * send descriptor. This allows software to create a send descriptor
+ * longer than SQE size selected by NIX_SQ_CTX_S[MAX_SQE_SIZE].  There
+ * can be only one NIX_SEND_JUMP_S subdescriptor in a send descriptor. If
+ * present, it must immediately follow NIX_SEND_HDR_S if NIX_SEND_EXT_S
+ * is not present, else it must immediately follow NIX_SEND_EXT_S. In
+ * either case, it must terminate the SQE enqueued by software.
+ */
+union nix_send_jump_s {
+	u64 u[2];
+	struct nix_send_jump_s_s {
+		u64 sizem1                           : 7;
+		u64 reserved_7_13                    : 7;
+		u64 ld_type                          : 2;
+		u64 aura                             : 20;
+		u64 reserved_36_58                   : 23;
+		u64 f                                : 1;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct nix_send_jump_s_s cn; */
+};
+
+/**
+ * Structure nix_send_mem_s
+ *
+ * NIX Send Memory Subdescriptor Structure The send memory subdescriptor
+ * atomically sets, increments or decrements a memory location.
+ * NIX_SEND_MEM_S subdescriptors must follow all NIX_SEND_SG_S and
+ * NIX_SEND_IMM_S subdescriptors in the NIX send descriptor. NIX will not
+ * initiate the memory update for this subdescriptor until after it has
+ * completed all LLC/DRAM fetches that service all prior NIX_SEND_SG_S
+ * subdescriptors. The memory update is executed once, even if the packet
+ * is replicated due to NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ * Performance is best if a memory decrement by one is used rather than
+ * any other memory set/increment/decrement. (Less internal bus bandwidth
+ * is used with memory decrements by one.)  When NIX_SEND_EXT_S[LSO] is
+ * set in the descriptor, NIX executes the memory update only while
+ * processing the last LSO segment, after processing prior segments.
+ */
+union nix_send_mem_s {
+	u64 u[2];
+	struct nix_send_mem_s_s {
+		u64 offset                           : 16;
+		u64 reserved_16_52                   : 37;
+		u64 wmem                             : 1;
+		u64 dsz                              : 2;
+		u64 alg                              : 4;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct nix_send_mem_s_s cn; */
+};
+
+/**
+ * Structure nix_send_sg_s
+ *
+ * NIX Send Scatter/Gather Subdescriptor Structure The send
+ * scatter/gather subdescriptor requests one to three segments of packet
+ * data bytes to be transmitted. There may be multiple NIX_SEND_SG_Ss in
+ * each NIX send descriptor.  NIX_SEND_SG_S is immediately followed by
+ * one NIX_IOVA_S word when [SEGS] = 1, three NIX_IOVA_S words when
+ * [SEGS] \>= 2. Each NIX_IOVA_S word specifies the LF IOVA of first
+ * packet data byte in the corresponding segment; first NIX_IOVA_S word
+ * for segment 1, second word for segment 2, third word for segment 3.
+ * Note the third word is present when [SEGS] \>= 2 but only valid when
+ * [SEGS] = 3.  If the sum of all prior NIX_SEND_SG_S[SEG*_SIZE]s and
+ * NIX_SEND_IMM_S[SIZE]s meets or exceeds NIX_SEND_HDR_S[TOTAL], this
+ * subdescriptor will not contribute any packet data but may free buffers
+ * to NPA (see [I1]).
+ */
+union nix_send_sg_s {
+	u64 u;
+	struct nix_send_sg_s_s {
+		u64 seg1_size                        : 16;
+		u64 seg2_size                        : 16;
+		u64 seg3_size                        : 16;
+		u64 segs                             : 2;
+		u64 reserved_50_54                   : 5;
+		u64 i1                               : 1;
+		u64 i2                               : 1;
+		u64 i3                               : 1;
+		u64 ld_type                          : 2;
+		u64 subdc                            : 4;
+	} s;
+	/* struct nix_send_sg_s_s cn; */
+};
+
+/**
+ * Structure nix_send_work_s
+ *
+ * NIX Send Work Subdescriptor Structure This subdescriptor adds work to
+ * the SSO. At most one NIX_SEND_WORK_S subdescriptor can exist in the
+ * NIX send descriptor. If a NIX_SEND_WORK_S exists in the descriptor, it
+ * must be the last subdescriptor. NIX will not initiate the work add for
+ * this subdescriptor until after (1) it has completed all LLC/DRAM
+ * fetches that service all prior NIX_SEND_SG_S subdescriptors, (2) it
+ * has fetched all subdescriptors in the descriptor, and (3) all
+ * NIX_SEND_MEM_S[WMEM]=1 LLC/DRAM updates have completed.  Provided the
+ * path of descriptors from the SQ through NIX to an output FIFO is
+ * unmodified between the descriptors (as should normally be the case,
+ * but it is possible for software to change the path), NIX also (1) will
+ * submit the SSO add works from all descriptors in the SQ in order, and
+ * (2) will not submit an SSO work add until after all prior descriptors
+ * in the SQ have completed their NIX_SEND_SG_S processing, and (3) will
+ * not submit an SSO work add until after it has fetched all
+ * subdescriptors from prior descriptors in the SQ.  When
+ * NIX_SEND_EXT_S[LSO] is set in the descriptor, NIX executes the
+ * NIX_SEND_WORK_S work add only while processing the last LSO segment,
+ * after processing prior segments.  Hardware ignores NIX_SEND_WORK_S
+ * when NIX_SQ_CTX_S[SSO_ENA] is clear.
+ */
+union nix_send_work_s {
+	u64 u[2];
+	struct nix_send_work_s_s {
+		u64 tag                              : 32;
+		u64 tt                               : 2;
+		u64 grp                              : 10;
+		u64 reserved_44_59                   : 16;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct nix_send_work_s_s cn; */
+};
+
+/**
+ * Structure nix_sq_ctx_hw_s
+ *
+ * NIX SQ Context Hardware Structure This structure contains context
+ * state maintained by hardware for each SQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_SQ_CTX_S structure format to read and write an
+ * SQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
+ */
+union nix_sq_ctx_hw_s {
+	u64 u[16];
+	struct nix_sq_ctx_hw_s_s {
+		u64 ena                              : 1;
+		u64 substream                        : 20;
+		u64 max_sqe_size                     : 2;
+		u64 sqe_way_mask                     : 16;
+		u64 sqb_aura                         : 20;
+		u64 gbl_rsvd1                        : 5;
+		u64 cq_id                            : 20;
+		u64 cq_ena                           : 1;
+		u64 qint_idx                         : 6;
+		u64 gbl_rsvd2                        : 1;
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 xoff                             : 1;
+		u64 sqe_stype                        : 2;
+		u64 gbl_rsvd                         : 17;
+		u64 head_sqb                         : 64;
+		u64 head_offset                      : 6;
+		u64 sqb_dequeue_count                : 16;
+		u64 default_chan                     : 12;
+		u64 sdp_mcast                        : 1;
+		u64 sso_ena                          : 1;
+		u64 dse_rsvd1                        : 28;
+		u64 sqb_enqueue_count                : 16;
+		u64 tail_offset                      : 6;
+		u64 lmt_dis                          : 1;
+		u64 smq_rr_quantum                   : 24;
+		u64 dnq_rsvd1                        : 17;
+		u64 tail_sqb                         : 64;
+		u64 next_sqb                         : 64;
+		u64 mnq_dis                          : 1;
+		u64 smq                              : 9;
+		u64 smq_pend                         : 1;
+		u64 smq_next_sq                      : 20;
+		u64 smq_next_sq_vld                  : 1;
+		u64 scm1_rsvd2                       : 32;
+		u64 smenq_sqb                        : 64;
+		u64 smenq_offset                     : 6;
+		u64 cq_limit                         : 8;
+		u64 smq_rr_count                     : 25;
+		u64 scm_lso_rem                      : 18;
+		u64 scm_dq_rsvd0                     : 7;
+		u64 smq_lso_segnum                   : 8;
+		u64 vfi_lso_total                    : 18;
+		u64 vfi_lso_sizem1                   : 3;
+		u64 vfi_lso_sb                       : 8;
+		u64 vfi_lso_mps                      : 14;
+		u64 vfi_lso_vlan0_ins_ena            : 1;
+		u64 vfi_lso_vlan1_ins_ena            : 1;
+		u64 vfi_lso_vld                      : 1;
+		u64 smenq_next_sqb_vld               : 1;
+		u64 scm_dq_rsvd1                     : 9;
+		u64 smenq_next_sqb                   : 64;
+		u64 seb_rsvd1                        : 64;
+		u64 drop_pkts                        : 48;
+		u64 drop_octs_lsw                    : 16;
+		u64 drop_octs_msw                    : 32;
+		u64 pkts_lsw                         : 32;
+		u64 pkts_msw                         : 16;
+		u64 octs                             : 48;
+	} s;
+	/* struct nix_sq_ctx_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_sq_ctx_s
+ *
+ * NIX Send Queue Context Structure This structure specifies the format
+ * used by software with the NIX admin queue to read and write a send
+ * queue's NIX_SQ_CTX_HW_S structure maintained by hardware in
+ * NDC/LLC/DRAM.  The SQ statistics ([OCTS], [PKTS], [DROP_OCTS],
+ * [DROP_PKTS]) do not account for packet replication due to
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ */
+union nix_sq_ctx_s {
+	u64 u[16];
+	struct nix_sq_ctx_s_s {
+		u64 ena                              : 1;
+		u64 qint_idx                         : 6;
+		u64 substream                        : 20;
+		u64 sdp_mcast                        : 1;
+		u64 cq                               : 20;
+		u64 sqe_way_mask                     : 16;
+		u64 smq                              : 9;
+		u64 cq_ena                           : 1;
+		u64 xoff                             : 1;
+		u64 sso_ena                          : 1;
+		u64 smq_rr_quantum                   : 24;
+		u64 default_chan                     : 12;
+		u64 sqb_count                        : 16;
+		u64 smq_rr_count                     : 25;
+		u64 sqb_aura                         : 20;
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 sqe_stype                        : 2;
+		u64 reserved_191                     : 1;
+		u64 max_sqe_size                     : 2;
+		u64 cq_limit                         : 8;
+		u64 lmt_dis                          : 1;
+		u64 mnq_dis                          : 1;
+		u64 smq_next_sq                      : 20;
+		u64 smq_lso_segnum                   : 8;
+		u64 tail_offset                      : 6;
+		u64 smenq_offset                     : 6;
+		u64 head_offset                      : 6;
+		u64 smenq_next_sqb_vld               : 1;
+		u64 smq_pend                         : 1;
+		u64 smq_next_sq_vld                  : 1;
+		u64 reserved_253_255                 : 3;
+		u64 next_sqb                         : 64;
+		u64 tail_sqb                         : 64;
+		u64 smenq_sqb                        : 64;
+		u64 smenq_next_sqb                   : 64;
+		u64 head_sqb                         : 64;
+		u64 reserved_576_583                 : 8;
+		u64 vfi_lso_total                    : 18;
+		u64 vfi_lso_sizem1                   : 3;
+		u64 vfi_lso_sb                       : 8;
+		u64 vfi_lso_mps                      : 14;
+		u64 vfi_lso_vlan0_ins_ena            : 1;
+		u64 vfi_lso_vlan1_ins_ena            : 1;
+		u64 vfi_lso_vld                      : 1;
+		u64 reserved_630_639                 : 10;
+		u64 scm_lso_rem                      : 18;
+		u64 reserved_658_703                 : 46;
+		u64 octs                             : 48;
+		u64 reserved_752_767                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_816_831                 : 16;
+		u64 reserved_832_895                 : 64;
+		u64 drop_octs                        : 48;
+		u64 reserved_944_959                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_1008_1023               : 16;
+	} s;
+	/* struct nix_sq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_tx_action_s
+ *
+ * NIX Transmit Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a transmit packet.
+ */
+union nix_tx_action_s {
+	u64 u;
+	struct nix_tx_action_s_s {
+		u64 op                               : 4;
+		u64 reserved_4_11                    : 8;
+		u64 index                            : 20;
+		u64 match_id                         : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nix_tx_action_s_s cn; */
+};
+
+/**
+ * Structure nix_tx_vtag_action_s
+ *
+ * NIX Transmit Vtag Action Structure This structure defines the format
+ * of NPC_RESULT_S[VTAG_ACTION] for a transmit packet. It specifies the
+ * optional insertion or replacement of up to two Vtags (e.g.
+ * C-VLAN/S-VLAN tags, 802.1BR E-TAG).  If two Vtags are specified: * The
+ * Vtag 0 byte offset from packet start (see [VTAG0_RELPTR]) must be less
+ * than or equal to the Vtag 1 byte offset. * Hardware executes the Vtag
+ * 0 action first, Vtag 1 action second. * If Vtag 0 is inserted,
+ * hardware adjusts the Vtag 1 byte offset accordingly. Thus, if the two
+ * offsets are equal in the structure, hardware inserts Vtag 1
+ * immediately after Vtag 0 in the packet.  A Vtag must not be inserted
+ * or replaced within an outer or inner L3/L4 header, but may be inserted
+ * or replaced within an outer L4 payload.
+ */
+union nix_tx_vtag_action_s {
+	u64 u;
+	struct nix_tx_vtag_action_s_s {
+		u64 vtag0_relptr                     : 8;
+		u64 vtag0_lid                        : 3;
+		u64 reserved_11                      : 1;
+		u64 vtag0_op                         : 2;
+		u64 reserved_14_15                   : 2;
+		u64 vtag0_def                        : 10;
+		u64 reserved_26_31                   : 6;
+		u64 vtag1_relptr                     : 8;
+		u64 vtag1_lid                        : 3;
+		u64 reserved_43                      : 1;
+		u64 vtag1_op                         : 2;
+		u64 reserved_46_47                   : 2;
+		u64 vtag1_def                        : 10;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct nix_tx_vtag_action_s_s cn; */
+};
+
+/**
+ * Structure nix_wqe_hdr_s
+ *
+ * NIX Work Queue Entry Header Structure This 64-bit structure defines
+ * the first word of every receive WQE generated by NIX. It is
+ * immediately followed by NIX_RX_PARSE_S. Stored in memory as little-
+ * endian unless NIX_AF_LF()_CFG[BE] is set.
+ */
+union nix_wqe_hdr_s {
+	u64 u;
+	struct nix_wqe_hdr_s_s {
+		u64 tag                              : 32;
+		u64 tt                               : 2;
+		u64 grp                              : 10;
+		u64 node                             : 2;
+		u64 q                                : 14;
+		u64 wqe_type                         : 4;
+	} s;
+	/* struct nix_wqe_hdr_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_base
+ *
+ * NIX AF Admin Queue Base Address Register
+ */
+union nixx_af_aq_base {
+	u64 u;
+	struct nixx_af_aq_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 base_addr                        : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_aq_base_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_BASE(void)
+{
+	return 0x410;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_cfg
+ *
+ * NIX AF Admin Queue Configuration Register
+ */
+union nixx_af_aq_cfg {
+	u64 u;
+	struct nixx_af_aq_cfg_s {
+		u64 qsize                            : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_aq_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_CFG(void)
+{
+	return 0x400;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done
+ *
+ * NIX AF Admin Queue Done Count Register
+ */
+union nixx_af_aq_done {
+	u64 u;
+	struct nixx_af_aq_done_s {
+		u64 done                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct nixx_af_aq_done_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE(void)
+{
+	return 0x450;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ack
+ *
+ * NIX AF Admin Queue Done Count Ack Register This register is written by
+ * software to acknowledge interrupts.
+ */
+union nixx_af_aq_done_ack {
+	u64 u;
+	struct nixx_af_aq_done_ack_s {
+		u64 done_ack                         : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct nixx_af_aq_done_ack_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_ACK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_ACK(void)
+{
+	return 0x460;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ena_w1c
+ *
+ * NIX AF Admin Queue Done Interrupt Enable Clear Register
+ */
+union nixx_af_aq_done_ena_w1c {
+	u64 u;
+	struct nixx_af_aq_done_ena_w1c_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_aq_done_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1C(void)
+{
+	return 0x498;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ena_w1s
+ *
+ * NIX AF Admin Queue Done Interrupt Enable Set Register
+ */
+union nixx_af_aq_done_ena_w1s {
+	u64 u;
+	struct nixx_af_aq_done_ena_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_aq_done_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1S(void)
+{
+	return 0x490;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_int
+ *
+ * INTERNAL: NIX AF Admin Queue Done Interrupt Register
+ */
+union nixx_af_aq_done_int {
+	u64 u;
+	struct nixx_af_aq_done_int_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_aq_done_int_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_INT(void)
+{
+	return 0x480;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_int_w1s
+ *
+ * INTERNAL: NIX AF Admin Queue Done Interrupt Set Register
+ */
+union nixx_af_aq_done_int_w1s {
+	u64 u;
+	struct nixx_af_aq_done_int_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_aq_done_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_INT_W1S(void)
+{
+	return 0x488;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_timer
+ *
+ * NIX AF Admin Queue Done Interrupt Timer Register
+ */
+union nixx_af_aq_done_timer {
+	u64 u;
+	struct nixx_af_aq_done_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_aq_done_timer_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_TIMER(void)
+{
+	return 0x470;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_wait
+ *
+ * NIX AF Admin Queue Done Interrupt Coalescing Wait Register Specifies
+ * the queue interrupt coalescing settings.
+ */
+union nixx_af_aq_done_wait {
+	u64 u;
+	struct nixx_af_aq_done_wait_s {
+		u64 num_wait                         : 20;
+		u64 reserved_20_31                   : 12;
+		u64 time_wait                        : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_aq_done_wait_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DONE_WAIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DONE_WAIT(void)
+{
+	return 0x440;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_door
+ *
+ * NIX AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue entries to AQ.
+ */
+union nixx_af_aq_door {
+	u64 u;
+	struct nixx_af_aq_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_aq_door_s cn; */
+};
+
+static inline u64 NIXX_AF_AQ_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_DOOR(void)
+{
+	return 0x430;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_status
+ *
+ * NIX AF Admin Queue Status Register
+ */
+union nixx_af_aq_status {
+	u64 u;
+	struct nixx_af_aq_status_s {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_35                   : 12;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} s;
+	struct nixx_af_aq_status_cn {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} cn;
+};
+
+static inline u64 NIXX_AF_AQ_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AQ_STATUS(void)
+{
+	return 0x420;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_avg_delay
+ *
+ * NIX AF Queue Average Delay Register
+ */
+union nixx_af_avg_delay {
+	u64 u;
+	struct nixx_af_avg_delay_s {
+		u64 avg_dly                          : 19;
+		u64 reserved_19_23                   : 5;
+		u64 avg_timer                        : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_avg_delay_s cn; */
+};
+
+static inline u64 NIXX_AF_AVG_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_AVG_DELAY(void)
+{
+	return 0xe0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_bar2_alias#
+ *
+ * NIX Admin Function  BAR2 Alias Registers These registers alias to the
+ * NIX BAR2 registers for the PF and function selected by
+ * NIX_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union nixx_af_bar2_aliasx {
+	u64 u;
+	struct nixx_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct nixx_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 NIXX_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_bar2_sel
+ *
+ * NIX Admin Function BAR2 Select Register This register configures BAR2
+ * accesses from the NIX_AF_BAR2_ALIAS() registers in BAR0. Internal: Not
+ * implemented. Placeholder for bug33464.
+ */
+union nixx_af_bar2_sel {
+	u64 u;
+	struct nixx_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct nixx_af_bar2_sel_s cn; */
+};
+
+static inline u64 NIXX_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_blk_rst
+ *
+ * NIX AF Block Reset Register
+ */
+union nixx_af_blk_rst {
+	u64 u;
+	struct nixx_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct nixx_af_blk_rst_s cn; */
+};
+
+static inline u64 NIXX_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_BLK_RST(void)
+{
+	return 0xb0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cfg
+ *
+ * NIX AF General Configuration Register
+ */
+union nixx_af_cfg {
+	u64 u;
+	struct nixx_af_cfg_s {
+		u64 force_cond_clk_en                : 1;
+		u64 force_rx_gbl_clk_en              : 1;
+		u64 force_rx_strm_clk_en             : 1;
+		u64 force_cqm_clk_en                 : 1;
+		u64 force_seb_clk_en                 : 1;
+		u64 force_sqm_clk_en                 : 1;
+		u64 force_pse_clk_en                 : 1;
+		u64 reserved_7                       : 1;
+		u64 af_be                            : 1;
+		u64 calibrate_x2p                    : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CFG(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cint_delay
+ *
+ * NIX AF Completion Interrupt Delay Register
+ */
+union nixx_af_cint_delay {
+	u64 u;
+	struct nixx_af_cint_delay_s {
+		u64 cint_dly                         : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cint_timer                       : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_cint_delay_s cn; */
+};
+
+static inline u64 NIXX_AF_CINT_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CINT_DELAY(void)
+{
+	return 0xf0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cint_timer#
+ *
+ * NIX AF Completion Interrupt Timer Registers
+ */
+union nixx_af_cint_timerx {
+	u64 u;
+	struct nixx_af_cint_timerx_s {
+		u64 expir_time                       : 16;
+		u64 cint                             : 7;
+		u64 reserved_23                      : 1;
+		u64 lf                               : 8;
+		u64 active                           : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct nixx_af_cint_timerx_s cn; */
+};
+
+static inline u64 NIXX_AF_CINT_TIMERX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CINT_TIMERX(u64 a)
+{
+	return 0x1a40 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const
+ *
+ * NIX AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_const {
+	u64 u;
+	struct nixx_af_const_s {
+		u64 cgx_lmac_channels                : 8;
+		u64 cgx_lmacs                        : 4;
+		u64 num_cgx                          : 4;
+		u64 lbk_channels                     : 8;
+		u64 num_lbk                          : 4;
+		u64 num_sdp                          : 4;
+		u64 reserved_32_47                   : 16;
+		u64 links                            : 8;
+		u64 intfs                            : 4;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct nixx_af_const_s cn; */
+};
+
+static inline u64 NIXX_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CONST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const1
+ *
+ * NIX AF Constants 1 Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_const1 {
+	u64 u;
+	struct nixx_af_const1_s {
+		u64 sdp_channels                     : 12;
+		u64 rx_bpids                         : 12;
+		u64 lf_tx_stats                      : 8;
+		u64 lf_rx_stats                      : 8;
+		u64 lso_format_fields                : 8;
+		u64 lso_formats                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct nixx_af_const1_s cn; */
+};
+
+static inline u64 NIXX_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CONST1(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const2
+ *
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_const2 {
+	u64 u;
+	struct nixx_af_const2_s {
+		u64 lfs                              : 12;
+		u64 qints                            : 12;
+		u64 cints                            : 12;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct nixx_af_const2_s cn; */
+};
+
+static inline u64 NIXX_AF_CONST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CONST2(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const3
+ *
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_const3 {
+	u64 u;
+	struct nixx_af_const3_s {
+		u64 sq_ctx_log2bytes                 : 4;
+		u64 rq_ctx_log2bytes                 : 4;
+		u64 cq_ctx_log2bytes                 : 4;
+		u64 rsse_log2bytes                   : 4;
+		u64 mce_log2bytes                    : 4;
+		u64 qint_log2bytes                   : 4;
+		u64 cint_log2bytes                   : 4;
+		u64 dyno_log2bytes                   : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_const3_s cn; */
+};
+
+static inline u64 NIXX_AF_CONST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CONST3(void)
+{
+	return 0x38;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cq_const
+ *
+ * NIX AF CQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_cq_const {
+	u64 u;
+	struct nixx_af_cq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_cq_const_s cn; */
+};
+
+static inline u64 NIXX_AF_CQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CQ_CONST(void)
+{
+	return 0x48;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cqm_bp_test
+ *
+ * INTERNAL: NIX AF CQM Backpressure Test Registers
+ */
+union nixx_af_cqm_bp_test {
+	u64 u;
+	struct nixx_af_cqm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 24;
+		u64 enable                           : 12;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct nixx_af_cqm_bp_test_s cn; */
+};
+
+static inline u64 NIXX_AF_CQM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CQM_BP_TEST(void)
+{
+	return 0x48c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cqm_eco
+ *
+ * INTERNAL: AF CQM ECO Register
+ */
+union nixx_af_cqm_eco {
+	u64 u;
+	struct nixx_af_cqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_cqm_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_CQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CQM_ECO(void)
+{
+	return 0x590;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_csi_eco
+ *
+ * INTERNAL: AF CSI ECO Register
+ */
+union nixx_af_csi_eco {
+	u64 u;
+	struct nixx_af_csi_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_csi_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_CSI_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_CSI_ECO(void)
+{
+	return 0x580;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int
+ *
+ * NIX Admin Function Error Interrupt Register
+ */
+union nixx_af_err_int {
+	u64 u;
+	struct nixx_af_err_int_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct nixx_af_err_int_s cn; */
+};
+
+static inline u64 NIXX_AF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_ERR_INT(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1c
+ *
+ * NIX Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union nixx_af_err_int_ena_w1c {
+	u64 u;
+	struct nixx_af_err_int_ena_w1c_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct nixx_af_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_AF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_ERR_INT_ENA_W1C(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1s
+ *
+ * NIX Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union nixx_af_err_int_ena_w1s {
+	u64 u;
+	struct nixx_af_err_int_ena_w1s_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct nixx_af_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_ERR_INT_ENA_W1S(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_w1s
+ *
+ * NIX Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union nixx_af_err_int_w1s {
+	u64 u;
+	struct nixx_af_err_int_w1s_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct nixx_af_err_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_ERR_INT_W1S(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_expr_tx_fifo_status
+ *
+ * INTERNAL: NIX AF Express Transmit FIFO Status Register  Internal:
+ * 802.3br frame preemption/express path is defeatured. Old definition:
+ * Status of FIFO which transmits express packets to CGX and LBK.
+ */
+union nixx_af_expr_tx_fifo_status {
+	u64 u;
+	struct nixx_af_expr_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct nixx_af_expr_tx_fifo_status_s cn; */
+};
+
+static inline u64 NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int
+ *
+ * NIX AF General Interrupt Register
+ */
+union nixx_af_gen_int {
+	u64 u;
+	struct nixx_af_gen_int_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct nixx_af_gen_int_s cn; */
+};
+
+static inline u64 NIXX_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_GEN_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1c
+ *
+ * NIX AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_af_gen_int_ena_w1c {
+	u64 u;
+	struct nixx_af_gen_int_ena_w1c_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct nixx_af_gen_int_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1s
+ *
+ * NIX AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union nixx_af_gen_int_ena_w1s {
+	u64 u;
+	struct nixx_af_gen_int_ena_w1s_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct nixx_af_gen_int_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_w1s
+ *
+ * NIX AF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union nixx_af_gen_int_w1s {
+	u64 u;
+	struct nixx_af_gen_int_w1s_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct nixx_af_gen_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_GEN_INT_W1S(void)
+{
+	return 0x168;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cfg
+ *
+ * NIX AF Local Function Configuration Registers
+ */
+union nixx_af_lfx_cfg {
+	u64 u;
+	struct nixx_af_lfx_cfg_s {
+		u64 npa_pf_func                      : 16;
+		u64 sso_pf_func                      : 16;
+		u64 be                               : 1;
+		u64 xqe_size                         : 2;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_lfx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_CFG(u64 a)
+{
+	return 0x4000 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cints_base
+ *
+ * NIX AF Local Function Completion Interrupts Base Address Registers
+ * This register specifies the base AF IOVA of LF's completion interrupt
+ * context table in NDC/LLC/DRAM. The table consists of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures.
+ */
+union nixx_af_lfx_cints_base {
+	u64 u;
+	struct nixx_af_lfx_cints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_cints_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_CINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_CINTS_BASE(u64 a)
+{
+	return 0x4130 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cints_cfg
+ *
+ * NIX AF Local Function Completion Interrupts Configuration Registers
+ * This register controls access to the LF's completion interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[CINTS]
+ * contiguous NIX_CINT_HW_S structures. The size of each structure is 1
+ * \<\< NIX_AF_CONST3[CINT_LOG2BYTES].
+ */
+union nixx_af_lfx_cints_cfg {
+	u64 u;
+	struct nixx_af_lfx_cints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_cints_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_CINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_CINTS_CFG(u64 a)
+{
+	return 0x4120 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_base
+ *
+ * NIX AF Local Function Completion Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's CQ context table. The
+ * table consists of NIX_AF_LF()_CQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_CQ_CTX_S structures.
+ */
+union nixx_af_lfx_cqs_base {
+	u64 u;
+	struct nixx_af_lfx_cqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_cqs_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_CQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_CQS_BASE(u64 a)
+{
+	return 0x4070 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_cfg
+ *
+ * NIX AF Local Function Completion Queues Configuration Register This
+ * register configures completion queues in the LF.
+ */
+union nixx_af_lfx_cqs_cfg {
+	u64 u;
+	struct nixx_af_lfx_cqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_cqs_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_CQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_CQS_CFG(u64 a)
+{
+	return 0x4060 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_lock#
+ *
+ * NIX AF Local Function Lockdown Registers Internal: The NIX lockdown
+ * depth of 32 bytes is shallow compared to 96 bytes for NIC and meant
+ * for outer MAC and/or VLAN (optionally preceded by a small number of
+ * skip bytes). NPC's MCAM can be used for deeper protocol-aware
+ * lockdown.
+ */
+union nixx_af_lfx_lockx {
+	u64 u;
+	struct nixx_af_lfx_lockx_s {
+		u64 data                             : 32;
+		u64 bit_ena                          : 32;
+	} s;
+	/* struct nixx_af_lfx_lockx_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+{
+	return 0x4300 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_qints_base
+ *
+ * NIX AF Local Function Queue Interrupts Base Address Registers This
+ * register specifies the base AF IOVA of LF's queue interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS]
+ * contiguous NIX_QINT_HW_S structures.
+ */
+union nixx_af_lfx_qints_base {
+	u64 u;
+	struct nixx_af_lfx_qints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_qints_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_QINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_QINTS_BASE(u64 a)
+{
+	return 0x4110 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_qints_cfg
+ *
+ * NIX AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS] contiguous
+ * NIX_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NIX_AF_CONST3[QINT_LOG2BYTES].
+ */
+union nixx_af_lfx_qints_cfg {
+	u64 u;
+	struct nixx_af_lfx_qints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_qints_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_QINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_QINTS_CFG(u64 a)
+{
+	return 0x4100 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_base
+ *
+ * NIX AF Local Function Receive Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's RQ context table. The
+ * table consists of NIX_AF_LF()_RQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_RQ_CTX_S structures.
+ */
+union nixx_af_lfx_rqs_base {
+	u64 u;
+	struct nixx_af_lfx_rqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_rqs_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RQS_BASE(u64 a)
+{
+	return 0x4050 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_cfg
+ *
+ * NIX AF Local Function Receive Queues Configuration Register This
+ * register configures receive queues in the LF.
+ */
+union nixx_af_lfx_rqs_cfg {
+	u64 u;
+	struct nixx_af_lfx_rqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_rqs_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RQS_CFG(u64 a)
+{
+	return 0x4040 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_base
+ *
+ * NIX AF Local Function Receive Size Scaling Table Base Address Register
+ * This register specifies the base AF IOVA of the RSS table per LF. The
+ * table is present when NIX_AF_LF()_RSS_CFG[ENA] is set and consists of
+ * 1 \<\< (NIX_AF_LF()_RSS_CFG[SIZE] + 8) contiguous NIX_RSSE_S
+ * structures, where the size of each structure is 1 \<\<
+ * NIX_AF_CONST3[RSSE_LOG2BYTES]. See NIX_AF_LF()_RSS_GRP().
+ */
+union nixx_af_lfx_rss_base {
+	u64 u;
+	struct nixx_af_lfx_rss_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_rss_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RSS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RSS_BASE(u64 a)
+{
+	return 0x40d0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_cfg
+ *
+ * NIX AF Local Function Receive Size Scaling Table Configuration
+ * Register See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
+ */
+union nixx_af_lfx_rss_cfg {
+	u64 u;
+	struct nixx_af_lfx_rss_cfg_s {
+		u64 size                             : 4;
+		u64 ena                              : 1;
+		u64 adder_is_tag_lsb                 : 1;
+		u64 reserved_6_19                    : 14;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	struct nixx_af_lfx_rss_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 ena                              : 1;
+		u64 reserved_5_19                    : 15;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} cn96xxp1;
+	/* struct nixx_af_lfx_rss_cfg_s cn96xxp3; */
+	/* struct nixx_af_lfx_rss_cfg_s cn98xx; */
+	/* struct nixx_af_lfx_rss_cfg_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_lfx_rss_cfg_s loki; */
+};
+
+static inline u64 NIXX_AF_LFX_RSS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RSS_CFG(u64 a)
+{
+	return 0x40c0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_grp#
+ *
+ * NIX AF Local Function Receive Side Scaling Group Registers A receive
+ * packet targets a LF's RSS group when its NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::RSS, or its target multicast list has an entry with
+ * NIX_RX_MCE_S[OP] = NIX_RX_MCOP_E::RSS. The RSS group index (this
+ * register's last index) is NIX_RX_ACTION_S[INDEX] or
+ * NIX_RX_MCE_S[INDEX].  The RSS computation is as follows: * The
+ * packet's flow_tag (see NIX_LF_RX_SECRET()) and RSS group are used to
+ * select a NIX_RSSE_S entry in the LF's RSS table (see [SIZEM1]). *
+ * NIX_RSSE_S selects the packet's destination RQ.
+ */
+union nixx_af_lfx_rss_grpx {
+	u64 u;
+	struct nixx_af_lfx_rss_grpx_s {
+		u64 offset                           : 11;
+		u64 reserved_11_15                   : 5;
+		u64 sizem1                           : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_lfx_rss_grpx_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+{
+	return 0x4600 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_cfg
+ *
+ * NIX AF Local Function Receive Configuration Register
+ */
+union nixx_af_lfx_rx_cfg {
+	u64 u;
+	struct nixx_af_lfx_rx_cfg_s {
+		u64 reserved_0_31                    : 32;
+		u64 drop_re                          : 1;
+		u64 lenerr_en                        : 1;
+		u64 ip6_udp_opt                      : 1;
+		u64 dis_apad                         : 1;
+		u64 csum_il4                         : 1;
+		u64 csum_ol4                         : 1;
+		u64 len_il4                          : 1;
+		u64 len_il3                          : 1;
+		u64 len_ol4                          : 1;
+		u64 len_ol3                          : 1;
+		u64 reserved_42_63                   : 22;
+	} s;
+	struct nixx_af_lfx_rx_cfg_cn96xxp1 {
+		u64 reserved_0_31                    : 32;
+		u64 reserved_32                      : 1;
+		u64 lenerr_en                        : 1;
+		u64 ip6_udp_opt                      : 1;
+		u64 dis_apad                         : 1;
+		u64 csum_il4                         : 1;
+		u64 csum_ol4                         : 1;
+		u64 len_il4                          : 1;
+		u64 len_il3                          : 1;
+		u64 len_ol4                          : 1;
+		u64 len_ol3                          : 1;
+		u64 reserved_42_63                   : 22;
+	} cn96xxp1;
+	/* struct nixx_af_lfx_rx_cfg_s cn96xxp3; */
+	/* struct nixx_af_lfx_rx_cfg_s cn98xx; */
+	/* struct nixx_af_lfx_rx_cfg_s cnf95xx; */
+	/* struct nixx_af_lfx_rx_cfg_s loki; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_CFG(u64 a)
+{
+	return 0x40a0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_cfg0
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Configuration Registers  Internal:
+ * Not used; no IPSEC fast-path.
+ */
+union nixx_af_lfx_rx_ipsec_cfg0 {
+	u64 u;
+	struct nixx_af_lfx_rx_ipsec_cfg0_s {
+		u64 lenm1_max                        : 14;
+		u64 reserved_14_15                   : 2;
+		u64 sa_pow2_size                     : 4;
+		u64 tag_const                        : 24;
+		u64 tt                               : 2;
+		u64 defcpt                           : 1;
+		u64 hshcpt                           : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_lfx_rx_ipsec_cfg0_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+{
+	return 0x4140 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_cfg1
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Security Association Configuration
+ * Register  Internal: Not used; no IPSEC fast-path.
+ */
+union nixx_af_lfx_rx_ipsec_cfg1 {
+	u64 u;
+	struct nixx_af_lfx_rx_ipsec_cfg1_s {
+		u64 sa_idx_max                       : 32;
+		u64 sa_idx_w                         : 5;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_rx_ipsec_cfg1_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+{
+	return 0x4148 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_dyno_base
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
+ * Registers  Internal: Not used; no IPSEC fast-path.
+ */
+union nixx_af_lfx_rx_ipsec_dyno_base {
+	u64 u;
+	struct nixx_af_lfx_rx_ipsec_dyno_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_rx_ipsec_dyno_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+{
+	return 0x4158 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_dyno_cfg
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
+ * Registers  Internal: Not used; no IPSEC fast-path.
+ */
+union nixx_af_lfx_rx_ipsec_dyno_cfg {
+	u64 u;
+	struct nixx_af_lfx_rx_ipsec_dyno_cfg_s {
+		u64 dyno_idx_w                       : 4;
+		u64 dyno_ena                         : 1;
+		u64 reserved_5_19                    : 15;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_rx_ipsec_dyno_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+{
+	return 0x4150 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_sa_base
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Security Association Base Address
+ * Register  Internal: Not used; no IPSEC fast-path.
+ */
+union nixx_af_lfx_rx_ipsec_sa_base {
+	u64 u;
+	struct nixx_af_lfx_rx_ipsec_sa_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_rx_ipsec_sa_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+{
+	return 0x4170 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_stat#
+ *
+ * NIX AF Local Function Receive Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ */
+union nixx_af_lfx_rx_statx {
+	u64 u;
+	struct nixx_af_lfx_rx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_lfx_rx_statx_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+{
+	return 0x4500 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_vtag_type#
+ *
+ * NIX AF Local Function Receive Vtag Type Registers These registers
+ * specify optional Vtag (e.g. VLAN, E-TAG) actions for received packets.
+ * Indexed by NIX_RX_VTAG_ACTION_S[VTAG*_TYPE].
+ */
+union nixx_af_lfx_rx_vtag_typex {
+	u64 u;
+	struct nixx_af_lfx_rx_vtag_typex_s {
+		u64 size                             : 1;
+		u64 reserved_1_3                     : 3;
+		u64 strip                            : 1;
+		u64 capture                          : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct nixx_af_lfx_rx_vtag_typex_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+{
+	return 0x4200 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_base
+ *
+ * NIX AF Local Function Send Queues Base Address Register This register
+ * specifies the base AF IOVA of the LF's SQ context table. The table
+ * consists of NIX_AF_LF()_SQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_SQ_CTX_HW_S structures.
+ */
+union nixx_af_lfx_sqs_base {
+	u64 u;
+	struct nixx_af_lfx_sqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_lfx_sqs_base_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_SQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_SQS_BASE(u64 a)
+{
+	return 0x4030 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_cfg
+ *
+ * NIX AF Local Function Send Queues Configuration Register This register
+ * configures send queues in the LF.
+ */
+union nixx_af_lfx_sqs_cfg {
+	u64 u;
+	struct nixx_af_lfx_sqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_lfx_sqs_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_SQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_SQS_CFG(u64 a)
+{
+	return 0x4020 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_cfg
+ *
+ * NIX AF Local Function Transmit Configuration Register
+ */
+union nixx_af_lfx_tx_cfg {
+	u64 u;
+	struct nixx_af_lfx_tx_cfg_s {
+		u64 vlan0_ins_etype                  : 16;
+		u64 vlan1_ins_etype                  : 16;
+		u64 send_tstmp_ena                   : 1;
+		u64 lock_viol_cqe_ena                : 1;
+		u64 lock_ena                         : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_lfx_tx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_TX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_TX_CFG(u64 a)
+{
+	return 0x4080 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_cfg2
+ *
+ * NIX AF Local Function Transmit Configuration Register
+ */
+union nixx_af_lfx_tx_cfg2 {
+	u64 u;
+	struct nixx_af_lfx_tx_cfg2_s {
+		u64 lmt_ena                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_lfx_tx_cfg2_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_TX_CFG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_TX_CFG2(u64 a)
+{
+	return 0x4028 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_parse_cfg
+ *
+ * NIX AF Local Function Transmit Parse Configuration Register
+ */
+union nixx_af_lfx_tx_parse_cfg {
+	u64 u;
+	struct nixx_af_lfx_tx_parse_cfg_s {
+		u64 pkind                            : 6;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct nixx_af_lfx_tx_parse_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+{
+	return 0x4090 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_stat#
+ *
+ * NIX AF Local Function Transmit Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ */
+union nixx_af_lfx_tx_statx {
+	u64 u;
+	struct nixx_af_lfx_tx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_lfx_tx_statx_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+{
+	return 0x4400 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_status
+ *
+ * NIX AF LF Transmit Status Register
+ */
+union nixx_af_lfx_tx_status {
+	u64 u;
+	struct nixx_af_lfx_tx_status_s {
+		u64 sq_ctx_err                       : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_lfx_tx_status_s cn; */
+};
+
+static inline u64 NIXX_AF_LFX_TX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LFX_TX_STATUS(u64 a)
+{
+	return 0x4180 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf_rst
+ *
+ * NIX Admin Function LF Reset Register
+ */
+union nixx_af_lf_rst {
+	u64 u;
+	struct nixx_af_lf_rst_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct nixx_af_lf_rst_s cn; */
+};
+
+static inline u64 NIXX_AF_LF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LF_RST(void)
+{
+	return 0x150;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lso_cfg
+ *
+ * NIX AF Large Send Offload Configuration Register
+ */
+union nixx_af_lso_cfg {
+	u64 u;
+	struct nixx_af_lso_cfg_s {
+		u64 tcp_lsf                          : 16;
+		u64 tcp_msf                          : 16;
+		u64 tcp_fsf                          : 16;
+		u64 reserved_48_62                   : 15;
+		u64 enable                           : 1;
+	} s;
+	/* struct nixx_af_lso_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_LSO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LSO_CFG(void)
+{
+	return 0xa8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lso_format#_field#
+ *
+ * NIX AF Large Send Offload Format Field Registers These registers
+ * specify LSO packet modification formats. Each format may modify up to
+ * eight packet fields with the following constraints: * If fewer than
+ * eight fields are modified, [ALG] must be NIX_LSOALG_E::NOP in the
+ * unused field registers. * Modified fields must be specified in
+ * contiguous field registers starting with NIX_AF_LSO_FORMAT()_FIELD(0).
+ * * Modified fields cannot overlap. * Multiple fields with the same
+ * [LAYER] value must be specified in ascending [OFFSET] order. * Fields
+ * in different layers must be specified in ascending [LAYER] order.
+ */
+union nixx_af_lso_formatx_fieldx {
+	u64 u;
+	struct nixx_af_lso_formatx_fieldx_s {
+		u64 offset                           : 8;
+		u64 layer                            : 2;
+		u64 reserved_10_11                   : 2;
+		u64 sizem1                           : 2;
+		u64 reserved_14_15                   : 2;
+		u64 alg                              : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_lso_formatx_fieldx_s cn; */
+};
+
+static inline u64 NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+{
+	return 0x1b00 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mark_format#_ctl
+ *
+ * NIX AF Packet Marking Format Registers Describes packet marking
+ * calculations for YELLOW and for NIX_COLORRESULT_E::RED_SEND packets.
+ * NIX_SEND_EXT_S[MARKFORM] selects the CSR used for the packet
+ * descriptor.  All the packet marking offset calculations assume big-
+ * endian bits within a byte.  For example, if NIX_SEND_EXT_S[MARKPTR] is
+ * 3 and [OFFSET] is 5 and the packet is YELLOW, the NIX marking hardware
+ * would do this:  _  byte[3]\<2:0\> |=   [Y_VAL]\<3:1\> _
+ * byte[3]\<2:0\> &= ~[Y_MASK]\<3:1\> _  byte[4]\<7\>   |=   [Y_VAL]\<0\>
+ * _  byte[4]\<7\>   &= ~[Y_MASK]\<0\>  where byte[3] is the third byte
+ * in the packet, and byte[4] the fourth.  For another example, if
+ * NIX_SEND_EXT_S[MARKPTR] is 3 and [OFFSET] is 0 and the packet is
+ * NIX_COLORRESULT_E::RED_SEND,  _   byte[3]\<7:4\> |=   [R_VAL]\<3:0\> _
+ * byte[3]\<7:4\> &= ~[R_MASK]\<3:0\>
+ */
+union nixx_af_mark_formatx_ctl {
+	u64 u;
+	struct nixx_af_mark_formatx_ctl_s {
+		u64 r_val                            : 4;
+		u64 r_mask                           : 4;
+		u64 y_val                            : 4;
+		u64 y_mask                           : 4;
+		u64 offset                           : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_mark_formatx_ctl_s cn; */
+};
+
+static inline u64 NIXX_AF_MARK_FORMATX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MARK_FORMATX_CTL(u64 a)
+{
+	return 0x900 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mc_mirror_const
+ *
+ * NIX AF Multicast/Mirror Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_mc_mirror_const {
+	u64 u;
+	struct nixx_af_mc_mirror_const_s {
+		u64 buf_size                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_mc_mirror_const_s cn; */
+};
+
+static inline u64 NIXX_AF_MC_MIRROR_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MC_MIRROR_CONST(void)
+{
+	return 0x98;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_cir
+ *
+ * NIX AF Meta Descriptor Queue Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_mdqx_cir {
+	u64 u;
+	struct nixx_af_mdqx_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_mdqx_cir_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_CIR(u64 a)
+{
+	return 0x1420 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_md_debug
+ *
+ * NIX AF Meta Descriptor Queue Meta Descriptor State Debug Registers
+ * This register provides access to the meta descriptor at the front of
+ * the MDQ. An MDQ can hold up to 8 packet meta descriptors (PMD) and one
+ * flush meta descriptor (FMD).
+ */
+union nixx_af_mdqx_md_debug {
+	u64 u;
+	struct nixx_af_mdqx_md_debug_s {
+		u64 pkt_len                          : 16;
+		u64 red_algo_override                : 2;
+		u64 shp_dis                          : 1;
+		u64 reserved_19                      : 1;
+		u64 shp_chg                          : 9;
+		u64 reserved_29_31                   : 3;
+		u64 sqm_pkt_id                       : 13;
+		u64 reserved_45_60                   : 16;
+		u64 md_type                          : 2;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct nixx_af_mdqx_md_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_MD_DEBUG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_MD_DEBUG(u64 a)
+{
+	return 0x14c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_parent
+ *
+ * NIX AF Meta Descriptor Queue Topology Registers
+ */
+union nixx_af_mdqx_parent {
+	u64 u;
+	struct nixx_af_mdqx_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_mdqx_parent_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_PARENT(u64 a)
+{
+	return 0x1480 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_pir
+ *
+ * NIX AF Meta Descriptor Queue Peak Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_mdqx_pir {
+	u64 u;
+	struct nixx_af_mdqx_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_mdqx_pir_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_PIR(u64 a)
+{
+	return 0x1430 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_pointers
+ *
+ * INTERNAL: NIX AF Meta Descriptor 4 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL4()_POINTERS.
+ */
+union nixx_af_mdqx_pointers {
+	u64 u;
+	struct nixx_af_mdqx_pointers_s {
+		u64 next                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 prev                             : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_mdqx_pointers_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_POINTERS(u64 a)
+{
+	return 0x1460 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_ptr_fifo
+ *
+ * INTERNAL: NIX Meta Descriptor Queue Pointer FIFO State Debug Registers
+ */
+union nixx_af_mdqx_ptr_fifo {
+	u64 u;
+	struct nixx_af_mdqx_ptr_fifo_s {
+		u64 tail                             : 4;
+		u64 head                             : 4;
+		u64 p_con                            : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct nixx_af_mdqx_ptr_fifo_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_PTR_FIFO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_PTR_FIFO(u64 a)
+{
+	return 0x14d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_sched_state
+ *
+ * NIX AF Meta Descriptor Queue Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union nixx_af_mdqx_sched_state {
+	u64 u;
+	struct nixx_af_mdqx_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_mdqx_sched_state_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_SCHED_STATE(u64 a)
+{
+	return 0x1440 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_schedule
+ *
+ * NIX AF Meta Descriptor Queue Scheduling Control Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union nixx_af_mdqx_schedule {
+	u64 u;
+	struct nixx_af_mdqx_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_mdqx_schedule_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_SCHEDULE(u64 a)
+{
+	return 0x1400 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_shape
+ *
+ * NIX AF Meta Descriptor Queue Shaping Control Registers This register
+ * has the same bit fields as NIX_AF_TL3()_SHAPE.
+ */
+union nixx_af_mdqx_shape {
+	u64 u;
+	struct nixx_af_mdqx_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct nixx_af_mdqx_shape_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_SHAPE(u64 a)
+{
+	return 0x1410 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_shape_state
+ *
+ * NIX AF Meta Descriptor Queue Shaping State Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must
+ * not be written during normal operation.
+ */
+union nixx_af_mdqx_shape_state {
+	u64 u;
+	struct nixx_af_mdqx_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct nixx_af_mdqx_shape_state_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+{
+	return 0x1450 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_sw_xoff
+ *
+ * NIX AF Meta Descriptor Controlled XOFF Registers This register has the
+ * same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union nixx_af_mdqx_sw_xoff {
+	u64 u;
+	struct nixx_af_mdqx_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_mdqx_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQX_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQX_SW_XOFF(u64 a)
+{
+	return 0x1470 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq_const
+ *
+ * NIX AF Meta Descriptor Queue Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_mdq_const {
+	u64 u;
+	struct nixx_af_mdq_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_mdq_const_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQ_CONST(void)
+{
+	return 0x90;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq_md_count
+ *
+ * NIX AF MDQ MD COUNT Registers
+ */
+union nixx_af_mdq_md_count {
+	u64 u;
+	struct nixx_af_mdq_md_count_s {
+		u64 count                            : 64;
+	} s;
+	/* struct nixx_af_mdq_md_count_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQ_MD_COUNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQ_MD_COUNT(void)
+{
+	return 0xda0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_cfg
+ *
+ * NIX AF General Configuration Register
+ */
+union nixx_af_ndc_cfg {
+	u64 u;
+	struct nixx_af_ndc_cfg_s {
+		u64 ndc_ign_pois                     : 1;
+		u64 byp_sq                           : 1;
+		u64 byp_sqb                          : 1;
+		u64 byp_cqs                          : 1;
+		u64 byp_cints                        : 1;
+		u64 byp_dyno                         : 1;
+		u64 byp_mce                          : 1;
+		u64 byp_rqc                          : 1;
+		u64 byp_rsse                         : 1;
+		u64 byp_mc_data                      : 1;
+		u64 byp_mc_wqe                       : 1;
+		u64 byp_mr_data                      : 1;
+		u64 byp_mr_wqe                       : 1;
+		u64 byp_qints                        : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct nixx_af_ndc_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_NDC_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_NDC_CFG(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_rx_sync
+ *
+ * NIX AF Receive NDC Sync Register Used to synchronize the NIX receive
+ * NDC (NDC_IDX_E::NIX()_RX).
+ */
+union nixx_af_ndc_rx_sync {
+	u64 u;
+	struct nixx_af_ndc_rx_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct nixx_af_ndc_rx_sync_s cn; */
+};
+
+static inline u64 NIXX_AF_NDC_RX_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_NDC_RX_SYNC(void)
+{
+	return 0x3e0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_tx_sync
+ *
+ * NIX AF NDC_TX Sync Register Used to synchronize the NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX).
+ */
+union nixx_af_ndc_tx_sync {
+	u64 u;
+	struct nixx_af_ndc_tx_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct nixx_af_ndc_tx_sync_s cn; */
+};
+
+static inline u64 NIXX_AF_NDC_TX_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_NDC_TX_SYNC(void)
+{
+	return 0x3f0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_norm_tx_fifo_status
+ *
+ * NIX AF Normal Transmit FIFO Status Register Status of FIFO which
+ * transmits normal packets to CGX and LBK.
+ */
+union nixx_af_norm_tx_fifo_status {
+	u64 u;
+	struct nixx_af_norm_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct nixx_af_norm_tx_fifo_status_s cn; */
+};
+
+static inline u64 NIXX_AF_NORM_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_NORM_TX_FIFO_STATUS(void)
+{
+	return 0x648;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_exp
+ *
+ * INTERNAL: NIX AF PQ Arb Link EXPRESS Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_exp {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_exp_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_exp_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_EXP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_EXP(u64 a)
+{
+	return 0xce8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_nrm
+ *
+ * INTERNAL: NIX AF PQ Arb Link NORMAL Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_nrm {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_nrm_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_nrm_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_NRM(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_NRM(u64 a)
+{
+	return 0xce0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_sdp
+ *
+ * INTERNAL: NIX AF PQ Arb Link SDP Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_sdp {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_sdp_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_sdp_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_SDP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_SDP(u64 a)
+{
+	return 0xcf0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_crd_rdy_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Credit Ready Registers  NIX AF PQ ARB
+ * Credit ready register
+ */
+union nixx_af_pq_arb_crd_rdy_debug {
+	u64 u;
+	struct nixx_af_pq_arb_crd_rdy_debug_s {
+		u64 node_crd_rdy                     : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_crd_rdy_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_CRD_RDY_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_CRD_RDY_DEBUG(void)
+{
+	return 0xf10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_dwrr_msk_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB DWRR mask set read only debug Registers
+ */
+union nixx_af_pq_arb_dwrr_msk_debug {
+	u64 u;
+	struct nixx_af_pq_arb_dwrr_msk_debug_s {
+		u64 node_dwrr_mask_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_dwrr_msk_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_DWRR_MSK_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_DWRR_MSK_DEBUG(void)
+{
+	return 0xf30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_node_gnt_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Grant vector Registers
+ */
+union nixx_af_pq_arb_node_gnt_debug {
+	u64 u;
+	struct nixx_af_pq_arb_node_gnt_debug_s {
+		u64 node_grant_vec                   : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_node_gnt_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_NODE_GNT_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_NODE_GNT_DEBUG(void)
+{
+	return 0xf20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_node_req_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Request Debug Registers  NIX AF PQ ARB
+ * Node Request Debug register
+ */
+union nixx_af_pq_arb_node_req_debug {
+	u64 u;
+	struct nixx_af_pq_arb_node_req_debug_s {
+		u64 node_req                         : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_node_req_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_NODE_REQ_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_NODE_REQ_DEBUG(void)
+{
+	return 0xf00;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_shape_vld_dbg
+ *
+ * INTERNAL: NIX AF PQ_ARB shape valid set Register
+ */
+union nixx_af_pq_arb_shape_vld_dbg {
+	u64 u;
+	struct nixx_af_pq_arb_shape_vld_dbg_s {
+		u64 node_shape_vld_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_shape_vld_dbg_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_SHAPE_VLD_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_SHAPE_VLD_DBG(void)
+{
+	return 0xf40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_dbg_arb_0
+ *
+ * INTERNAL: NIX AF PQ Arb Debug 0 Register
+ */
+union nixx_af_pq_dbg_arb_0 {
+	u64 u;
+	struct nixx_af_pq_dbg_arb_0_s {
+		u64 rr_mask_clr                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_pq_dbg_arb_0_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_DBG_ARB_0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_DBG_ARB_0(void)
+{
+	return 0xcf8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_lnk_#_dwrr_msk_dbg
+ *
+ * INTERNAL: NIX AF PQ_ARB Physical Link DWRR MASK Registers
+ */
+union nixx_af_pq_lnk_x_dwrr_msk_dbg {
+	u64 u;
+	struct nixx_af_pq_lnk_x_dwrr_msk_dbg_s {
+		u64 link_dwrr_mask_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_lnk_x_dwrr_msk_dbg_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_LNK_X_DWRR_MSK_DBG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_LNK_X_DWRR_MSK_DBG(u64 a)
+{
+	return 0x1100 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_400_rate_divider
+ *
+ * INTERNAL: NIX AF PSE 400 Rate Divider Register
+ */
+union nixx_af_pse_400_rate_divider {
+	u64 u;
+	struct nixx_af_pse_400_rate_divider_s {
+		u64 rate_div_cfg                     : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct nixx_af_pse_400_rate_divider_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_400_RATE_DIVIDER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_400_RATE_DIVIDER(void)
+{
+	return 0x830;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_active_cycles_pc
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union nixx_af_pse_active_cycles_pc {
+	u64 u;
+	struct nixx_af_pse_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct nixx_af_pse_active_cycles_pc_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+{
+	return 0x8c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test0
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 0 Register
+ */
+union nixx_af_pse_bp_test0 {
+	u64 u;
+	struct nixx_af_pse_bp_test0_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct nixx_af_pse_bp_test0_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test0_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_19                   : 4;
+		u64 bp_cfg                           : 12;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_57                   : 2;
+		u64 enable                           : 6;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test0_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test0_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test0_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_PSE_BP_TEST0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_BP_TEST0(void)
+{
+	return 0x840;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test1
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 1 Register
+ */
+union nixx_af_pse_bp_test1 {
+	u64 u;
+	struct nixx_af_pse_bp_test1_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test1_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test1_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test1_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test1_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test1_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_PSE_BP_TEST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_BP_TEST1(void)
+{
+	return 0x850;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test2
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 2 Register
+ */
+union nixx_af_pse_bp_test2 {
+	u64 u;
+	struct nixx_af_pse_bp_test2_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test2_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test2_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test2_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test2_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test2_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_PSE_BP_TEST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_BP_TEST2(void)
+{
+	return 0x860;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test3
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 3 Register
+ */
+union nixx_af_pse_bp_test3 {
+	u64 u;
+	struct nixx_af_pse_bp_test3_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test3_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test3_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test3_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test3_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test3_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_PSE_BP_TEST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_BP_TEST3(void)
+{
+	return 0x870;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_channel_level
+ *
+ * NIX AF PSE Channel Level Register
+ */
+union nixx_af_pse_channel_level {
+	u64 u;
+	struct nixx_af_pse_channel_level_s {
+		u64 bp_level                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_pse_channel_level_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_CHANNEL_LEVEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_CHANNEL_LEVEL(void)
+{
+	return 0x800;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_const
+ *
+ * NIX AF PSE Constants Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_pse_const {
+	u64 u;
+	struct nixx_af_pse_const_s {
+		u64 levels                           : 4;
+		u64 reserved_4_7                     : 4;
+		u64 mark_formats                     : 8;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_pse_const_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_CONST(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_eco
+ *
+ * INTERNAL: AF PSE ECO Register
+ */
+union nixx_af_pse_eco {
+	u64 u;
+	struct nixx_af_pse_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_pse_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_ECO(void)
+{
+	return 0x5d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_expr_bp_test
+ *
+ * INTERNAL: NIX AF PSE Express Backpressure Test Register  Internal:
+ * 802.3br frame preemption/express path is defeatured.
+ */
+union nixx_af_pse_expr_bp_test {
+	u64 u;
+	struct nixx_af_pse_expr_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} s;
+	/* struct nixx_af_pse_expr_bp_test_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_EXPR_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_EXPR_BP_TEST(void)
+{
+	return 0x890;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_norm_bp_test
+ *
+ * INTERNAL: NIX AF PSE Normal Backpressure Test Register
+ */
+union nixx_af_pse_norm_bp_test {
+	u64 u;
+	struct nixx_af_pse_norm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 reserved_48_63                   : 16;
+	} s;
+	struct nixx_af_pse_norm_bp_test_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} cn96xxp1;
+	struct nixx_af_pse_norm_bp_test_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 12;
+		u64 reserved_28_57                   : 30;
+		u64 enable                           : 6;
+	} cn96xxp3;
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_PSE_NORM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_NORM_BP_TEST(void)
+{
+	return 0x880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_shaper_cfg
+ *
+ * NIX AF PSE Shaper Configuration Register
+ */
+union nixx_af_pse_shaper_cfg {
+	u64 u;
+	struct nixx_af_pse_shaper_cfg_s {
+		u64 red_send_as_yellow               : 1;
+		u64 color_aware                      : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct nixx_af_pse_shaper_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_PSE_SHAPER_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PSE_SHAPER_CFG(void)
+{
+	return 0x810;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras
+ *
+ * NIX AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
+ */
+union nixx_af_ras {
+	u64 u;
+	struct nixx_af_ras_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_ras_s cn; */
+};
+
+static inline u64 NIXX_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RAS(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1c
+ *
+ * NIX AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_af_ras_ena_w1c {
+	u64 u;
+	struct nixx_af_ras_ena_w1c_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_ras_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RAS_ENA_W1C(void)
+{
+	return 0x1b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1s
+ *
+ * NIX AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union nixx_af_ras_ena_w1s {
+	u64 u;
+	struct nixx_af_ras_ena_w1s_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_ras_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RAS_ENA_W1S(void)
+{
+	return 0x1b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_w1s
+ *
+ * NIX AF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union nixx_af_ras_w1s {
+	u64 u;
+	struct nixx_af_ras_w1s_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_ras_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RAS_W1S(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_reb_bp_test#
+ *
+ * INTERNAL: NIX AF REB Backpressure Test Registers
+ */
+union nixx_af_reb_bp_testx {
+	u64 u;
+	struct nixx_af_reb_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_47                   : 24;
+		u64 enable                           : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct nixx_af_reb_bp_testx_s cn; */
+};
+
+static inline u64 NIXX_AF_REB_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_REB_BP_TESTX(u64 a)
+{
+	return 0x4840 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rq_const
+ *
+ * NIX AF RQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_rq_const {
+	u64 u;
+	struct nixx_af_rq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_rq_const_s cn; */
+};
+
+static inline u64 NIXX_AF_RQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RQ_CONST(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rqm_bp_test
+ *
+ * INTERNAL: NIX AF REB Backpressure Test Registers
+ */
+union nixx_af_rqm_bp_test {
+	u64 u;
+	struct nixx_af_rqm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 16;
+		u64 reserved_32_47                   : 16;
+		u64 enable                           : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct nixx_af_rqm_bp_test_s cn; */
+};
+
+static inline u64 NIXX_AF_RQM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RQM_BP_TEST(void)
+{
+	return 0x4880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rqm_eco
+ *
+ * INTERNAL: AF RQM ECO Register
+ */
+union nixx_af_rqm_eco {
+	u64 u;
+	struct nixx_af_rqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_rqm_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_RQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RQM_ECO(void)
+{
+	return 0x5a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int
+ *
+ * NIX AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
+ */
+union nixx_af_rvu_int {
+	u64 u;
+	struct nixx_af_rvu_int_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rvu_int_s cn; */
+};
+
+static inline u64 NIXX_AF_RVU_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RVU_INT(void)
+{
+	return 0x1c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1c
+ *
+ * NIX AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_af_rvu_int_ena_w1c {
+	u64 u;
+	struct nixx_af_rvu_int_ena_w1c_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rvu_int_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_AF_RVU_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RVU_INT_ENA_W1C(void)
+{
+	return 0x1d8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1s
+ *
+ * NIX AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union nixx_af_rvu_int_ena_w1s {
+	u64 u;
+	struct nixx_af_rvu_int_ena_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rvu_int_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_RVU_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RVU_INT_ENA_W1S(void)
+{
+	return 0x1d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_w1s
+ *
+ * NIX AF RVU Interrupt Set Register This register sets interrupt bits.
+ */
+union nixx_af_rvu_int_w1s {
+	u64 u;
+	struct nixx_af_rvu_int_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rvu_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_AF_RVU_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RVU_INT_W1S(void)
+{
+	return 0x1c8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_lf_cfg_debug
+ *
+ * NIX Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NIX_PRIV_LF()_CFG.
+ */
+union nixx_af_rvu_lf_cfg_debug {
+	u64 u;
+	struct nixx_af_rvu_lf_cfg_debug_s {
+		u64 lf                               : 12;
+		u64 lf_valid                         : 1;
+		u64 exec                             : 1;
+		u64 reserved_14_15                   : 2;
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_rvu_lf_cfg_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_RVU_LF_CFG_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RVU_LF_CFG_DEBUG(void)
+{
+	return 0x8000030;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_active_cycles_pc#
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union nixx_af_rx_active_cycles_pcx {
+	u64 u;
+	struct nixx_af_rx_active_cycles_pcx_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct nixx_af_rx_active_cycles_pcx_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+{
+	return 0x4800 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_bpid#_status
+ *
+ * NIX AF Receive Backpressure ID Status Registers
+ */
+union nixx_af_rx_bpidx_status {
+	u64 u;
+	struct nixx_af_rx_bpidx_status_s {
+		u64 aura_cnt                         : 32;
+		u64 cq_cnt                           : 32;
+	} s;
+	/* struct nixx_af_rx_bpidx_status_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_BPIDX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_BPIDX_STATUS(u64 a)
+{
+	return 0x1a20 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cfg
+ *
+ * NIX AF Receive Configuration Register
+ */
+union nixx_af_rx_cfg {
+	u64 u;
+	struct nixx_af_rx_cfg_s {
+		u64 cbp_ena                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_CFG(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_chan#_cfg
+ *
+ * NIX AF Receive Channel Configuration Registers
+ */
+union nixx_af_rx_chanx_cfg {
+	u64 u;
+	struct nixx_af_rx_chanx_cfg_s {
+		u64 bpid                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 bp_ena                           : 1;
+		u64 sw_xoff                          : 1;
+		u64 imp                              : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_rx_chanx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_CHANX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_CHANX_CFG(u64 a)
+{
+	return 0x1a30 + 0x8000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cpt#_credit
+ *
+ * NIX AF Receive CPT Credit Register
+ */
+union nixx_af_rx_cptx_credit {
+	u64 u;
+	struct nixx_af_rx_cptx_credit_s {
+		u64 inst_cred_cnt                    : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct nixx_af_rx_cptx_credit_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_CPTX_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_CPTX_CREDIT(u64 a)
+{
+	return 0x360 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cpt#_inst_qsel
+ *
+ * NIX AF Receive CPT Instruction Queue Select Register Selects the CPT
+ * queue to which instructions (CPT_INST_S) are sent. Internal: NIX sends
+ * CPT_INST_S to the CPT_LF_NQ() physical address for [PF_FUNC] and
+ * [SLOT]: \<pre\> // CPT_LF_NQ() physical address:
+ * chip_pa_defs::io_rvu2a_t cpt_addr; cpt_addr =
+ * RVU_BAR_E::RVU_PF()_FUNC()_BAR2(pf, func); cpt_addr.block =
+ * RVU_BLOCK_ADDR_E::CPT()({a}); // {a} = CPT index cpt_addr.slot =
+ * [SLOT]; cpt_addr.offset = `CPT_LF_NQX__BASE;  // NDC/NCBI command:
+ * ncbi_cmd.paddr = 1; // Physical address ncbi_cmd.addr = cpt_addr;
+ * \</pre\>
+ */
+union nixx_af_rx_cptx_inst_qsel {
+	u64 u;
+	struct nixx_af_rx_cptx_inst_qsel_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_rx_cptx_inst_qsel_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+{
+	return 0x320 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iip4
+ *
+ * NIX AF Receive Inner IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv4 header.
+ * Typically the same as NPC_PCK_DEF_IIP4.
+ */
+union nixx_af_rx_def_iip4 {
+	u64 u;
+	struct nixx_af_rx_def_iip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_iip4_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_IIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_IIP4(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iip6
+ *
+ * NIX AF Receive Inner IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv6 header.
+ */
+union nixx_af_rx_def_iip6 {
+	u64 u;
+	struct nixx_af_rx_def_iip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_iip6_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_IIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_IIP6(void)
+{
+	return 0x240;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_ipsec#
+ *
+ * INTERNAL: NIX AF Receive IPSEC Header Definition Registers  Internal:
+ * Not used; no IPSEC fast-path.
+ */
+union nixx_af_rx_def_ipsecx {
+	u64 u;
+	struct nixx_af_rx_def_ipsecx_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11                      : 1;
+		u64 spi_offset                       : 4;
+		u64 spi_nz                           : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct nixx_af_rx_def_ipsecx_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_IPSECX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_IPSECX(u64 a)
+{
+	return 0x2b0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_isctp
+ *
+ * NIX AF Receive Inner SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner SCTP header.
+ */
+union nixx_af_rx_def_isctp {
+	u64 u;
+	struct nixx_af_rx_def_isctp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_isctp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_ISCTP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_ISCTP(void)
+{
+	return 0x2a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_itcp
+ *
+ * NIX AF Receive Inner TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner TCP header.
+ */
+union nixx_af_rx_def_itcp {
+	u64 u;
+	struct nixx_af_rx_def_itcp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_itcp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_ITCP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_ITCP(void)
+{
+	return 0x260;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iudp
+ *
+ * NIX AF Receive Inner UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner UDP header.
+ */
+union nixx_af_rx_def_iudp {
+	u64 u;
+	struct nixx_af_rx_def_iudp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_iudp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_IUDP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_IUDP(void)
+{
+	return 0x280;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oip4
+ *
+ * NIX AF Receive Outer IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv4 L3 header.
+ * Typically the same as NPC_PCK_DEF_OIP4.
+ */
+union nixx_af_rx_def_oip4 {
+	u64 u;
+	struct nixx_af_rx_def_oip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_oip4_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OIP4(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oip6
+ *
+ * NIX AF Receive Outer IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv6 header.
+ * Typically the same as NPC_PCK_DEF_OIP6.
+ */
+union nixx_af_rx_def_oip6 {
+	u64 u;
+	struct nixx_af_rx_def_oip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_oip6_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OIP6(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_ol2
+ *
+ * NIX AF Receive Outer L2 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer L2/Ethernet header.
+ * Typically the same as NPC_PCK_DEF_OL2.
+ */
+union nixx_af_rx_def_ol2 {
+	u64 u;
+	struct nixx_af_rx_def_ol2_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_ol2_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OL2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OL2(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_osctp
+ *
+ * NIX AF Receive Outer SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer SCTP header.
+ */
+union nixx_af_rx_def_osctp {
+	u64 u;
+	struct nixx_af_rx_def_osctp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_osctp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OSCTP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OSCTP(void)
+{
+	return 0x290;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_otcp
+ *
+ * NIX AF Receive Outer TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer TCP header.
+ */
+union nixx_af_rx_def_otcp {
+	u64 u;
+	struct nixx_af_rx_def_otcp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_otcp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OTCP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OTCP(void)
+{
+	return 0x250;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oudp
+ *
+ * NIX AF Receive Outer UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer UDP header.
+ */
+union nixx_af_rx_def_oudp {
+	u64 u;
+	struct nixx_af_rx_def_oudp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_af_rx_def_oudp_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_DEF_OUDP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_DEF_OUDP(void)
+{
+	return 0x270;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_flow_key_alg#_field#
+ *
+ * NIX AF Receive Flow Key Algorithm Field Registers A flow key algorithm
+ * defines how the 40-byte FLOW_KEY is formed from the received packet
+ * header. FLOW_KEY is formed using up to five header fields (this
+ * register's last index) with up to 16 bytes per field.  The algorithm
+ * (index {a} (ALG) of these registers) is selected by
+ * NIX_RX_ACTION_S[FLOW_KEY_ALG] from the packet's NPC_RESULT_S[ACTION].
+ * Internal: 40-byte FLOW_KEY is wide enough to support an IPv6 5-tuple
+ * that includes a VXLAN/GENEVE/NVGRE tunnel ID, e.g: _ Source IP: 16B. _
+ * Dest IP: 16B. _ Source port: 2B. _ Dest port: 2B. _ Tunnel VNI/VSI:
+ * 3B. _ Total: 39B.
+ */
+union nixx_af_rx_flow_key_algx_fieldx {
+	u64 u;
+	struct nixx_af_rx_flow_key_algx_fieldx_s {
+		u64 key_offset                       : 6;
+		u64 ln_mask                          : 1;
+		u64 fn_mask                          : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 5;
+		u64 lid                              : 3;
+		u64 reserved_24                      : 1;
+		u64 ena                              : 1;
+		u64 sel_chan                         : 1;
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct nixx_af_rx_flow_key_algx_fieldx_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+{
+	return 0x1800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_ipsec_gen_cfg
+ *
+ * INTERNAL: NIX AF Receive IPSEC General Configuration Register
+ * Internal: Not used; no IPSEC fast-path.
+ */
+union nixx_af_rx_ipsec_gen_cfg {
+	u64 u;
+	struct nixx_af_rx_ipsec_gen_cfg_s {
+		u64 param2                           : 16;
+		u64 param1                           : 16;
+		u64 opcode                           : 16;
+		u64 egrp                             : 3;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct nixx_af_rx_ipsec_gen_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_IPSEC_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_IPSEC_GEN_CFG(void)
+{
+	return 0x300;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_cfg
+ *
+ * NIX AF Receive Link Configuration Registers Index enumerated by
+ * NIX_LINK_E.
+ */
+union nixx_af_rx_linkx_cfg {
+	u64 u;
+	struct nixx_af_rx_linkx_cfg_s {
+		u64 minlen                           : 16;
+		u64 maxlen                           : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_rx_linkx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_LINKX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_LINKX_CFG(u64 a)
+{
+	return 0x540 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_sl#_spkt_cnt
+ *
+ * INTERNAL: NIX Receive Software Sync Link Packet Count Registers  For
+ * diagnostic use only for debug of NIX_AF_RX_SW_SYNC[ENA] function. LINK
+ * index is enumerated by NIX_LINK_E. For the internal multicast/mirror
+ * link (NIX_LINK_E::MC), SL index is zero for multicast replay, one for
+ * mirror replay. SL index one is reserved for all other links.
+ * Internal: 802.3br frame preemption/express path is defeatured. Old
+ * definition of SL index: SL index is zero for non-express packets, one
+ * for express packets. For the internal NIX_LINK_E::MC, SL index is zero
+ * for multicast replay, one for mirror replay.
+ */
+union nixx_af_rx_linkx_slx_spkt_cnt {
+	u64 u;
+	struct nixx_af_rx_linkx_slx_spkt_cnt_s {
+		u64 in_cnt                           : 20;
+		u64 reserved_20_31                   : 12;
+		u64 out_cnt                          : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct nixx_af_rx_linkx_slx_spkt_cnt_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+{
+	return 0x500 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_wrr_cfg
+ *
+ * NIX AF Receive Link Weighted Round Robin Configuration Registers Index
+ * enumerated by NIX_LINK_E.
+ */
+union nixx_af_rx_linkx_wrr_cfg {
+	u64 u;
+	struct nixx_af_rx_linkx_wrr_cfg_s {
+		u64 weight                           : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct nixx_af_rx_linkx_wrr_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+{
+	return 0x560 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_base
+ *
+ * NIX AF Receive Multicast/Mirror Table Base Address Register This
+ * register specifies the base AF IOVA of the receive multicast/mirror
+ * table in NDC/LLC/DRAM. The table consists of 1 \<\<
+ * (NIX_AF_RX_MCAST_CFG[SIZE] + 8) contiguous NIX_RX_MCE_S structures.
+ * The size of each structure is 1 \<\< NIX_AF_CONST3[MCE_LOG2BYTES].
+ * The table contains multicast/mirror replication lists. Each list
+ * consists of linked entries with NIX_RX_MCE_S[EOL] = 1 in the last
+ * entry. All lists must reside within the table size specified by
+ * NIX_AF_RX_MCAST_CFG[SIZE]. A mirror replication list will typically
+ * consist of two entries, but that is not checked or enforced by
+ * hardware.  A receive packet is multicast when the action returned by
+ * NPC has NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MCAST. A receive
+ * packet is mirrored when the action returned by NPC has
+ * NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MIRROR. In both cases,
+ * NIX_RX_ACTION_S[INDEX] specifies the index of the replication list's
+ * first NIX_RX_MCE_S in the table, and a linked entry with
+ * NIX_RX_MCE_S[EOL] = 1 indicates the end of list.  If a mirrored flow
+ * is part of a multicast replication list, software should include the
+ * two mirror entries in that list.  Internal: A multicast list may have
+ * multiple entries for the same LF (e.g. for future RoCE/IB multicast).
+ */
+union nixx_af_rx_mcast_base {
+	u64 u;
+	struct nixx_af_rx_mcast_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_rx_mcast_base_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_MCAST_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MCAST_BASE(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_base
+ *
+ * NIX AF Receive Multicast Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive multicast buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::MCAST. The number of buffers is configured by
+ * NIX_AF_RX_MCAST_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MCAST_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
+ */
+union nixx_af_rx_mcast_buf_base {
+	u64 u;
+	struct nixx_af_rx_mcast_buf_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_rx_mcast_buf_base_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_MCAST_BUF_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MCAST_BUF_BASE(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_cfg
+ *
+ * NIX AF Receive Multicast Buffer Configuration Register See
+ * NIX_AF_RX_MCAST_BUF_BASE.
+ */
+union nixx_af_rx_mcast_buf_cfg {
+	u64 u;
+	struct nixx_af_rx_mcast_buf_cfg_s {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 busy                             : 1;
+		u64 ena                              : 1;
+	} s;
+	struct nixx_af_rx_mcast_buf_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 reserved_62                      : 1;
+		u64 ena                              : 1;
+	} cn96xxp1;
+	/* struct nixx_af_rx_mcast_buf_cfg_s cn96xxp3; */
+	/* struct nixx_af_rx_mcast_buf_cfg_s cn98xx; */
+	struct nixx_af_rx_mcast_buf_cfg_cnf95xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} cnf95xxp1;
+	/* struct nixx_af_rx_mcast_buf_cfg_s cnf95xxp2; */
+	/* struct nixx_af_rx_mcast_buf_cfg_s loki; */
+};
+
+static inline u64 NIXX_AF_RX_MCAST_BUF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MCAST_BUF_CFG(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_cfg
+ *
+ * NIX AF Receive Multicast/Mirror Table Configuration Register See
+ * NIX_AF_RX_MCAST_BASE.
+ */
+union nixx_af_rx_mcast_cfg {
+	u64 u;
+	struct nixx_af_rx_mcast_cfg_s {
+		u64 size                             : 4;
+		u64 max_list_lenm1                   : 8;
+		u64 reserved_12_19                   : 8;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct nixx_af_rx_mcast_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_MCAST_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MCAST_CFG(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_base
+ *
+ * NIX AF Receive Mirror Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive mirror buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::MIRROR. The number of buffers is configured by
+ * NIX_AF_RX_MIRROR_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MIRROR_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
+ */
+union nixx_af_rx_mirror_buf_base {
+	u64 u;
+	struct nixx_af_rx_mirror_buf_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_rx_mirror_buf_base_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_MIRROR_BUF_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MIRROR_BUF_BASE(void)
+{
+	return 0x140;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_cfg
+ *
+ * NIX AF Receive Mirror Buffer Configuration Register See
+ * NIX_AF_RX_MIRROR_BUF_BASE.
+ */
+union nixx_af_rx_mirror_buf_cfg {
+	u64 u;
+	struct nixx_af_rx_mirror_buf_cfg_s {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 busy                             : 1;
+		u64 ena                              : 1;
+	} s;
+	struct nixx_af_rx_mirror_buf_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 reserved_62                      : 1;
+		u64 ena                              : 1;
+	} cn96xxp1;
+	/* struct nixx_af_rx_mirror_buf_cfg_s cn96xxp3; */
+	/* struct nixx_af_rx_mirror_buf_cfg_s cn98xx; */
+	struct nixx_af_rx_mirror_buf_cfg_cnf95xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} cnf95xxp1;
+	/* struct nixx_af_rx_mirror_buf_cfg_s cnf95xxp2; */
+	/* struct nixx_af_rx_mirror_buf_cfg_s loki; */
+};
+
+static inline u64 NIXX_AF_RX_MIRROR_BUF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_MIRROR_BUF_CFG(void)
+{
+	return 0x148;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_drop
+ *
+ * NIX AF Multicast Drop Statistics Register The counter increments for
+ * every dropped MC packet marked by the NPC.
+ */
+union nixx_af_rx_npc_mc_drop {
+	u64 u;
+	struct nixx_af_rx_npc_mc_drop_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_rx_npc_mc_drop_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_NPC_MC_DROP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_NPC_MC_DROP(void)
+{
+	return 0x4710;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_rcv
+ *
+ * NIX AF Multicast Receive Statistics Register The counter increments
+ * for every received MC packet marked by the NPC.
+ */
+union nixx_af_rx_npc_mc_rcv {
+	u64 u;
+	struct nixx_af_rx_npc_mc_rcv_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_rx_npc_mc_rcv_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_NPC_MC_RCV(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_NPC_MC_RCV(void)
+{
+	return 0x4700;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_drop
+ *
+ * NIX AF Mirror Drop Statistics Register The counter increments for
+ * every dropped MIRROR packet marked by the NPC.
+ */
+union nixx_af_rx_npc_mirror_drop {
+	u64 u;
+	struct nixx_af_rx_npc_mirror_drop_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_rx_npc_mirror_drop_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_NPC_MIRROR_DROP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_NPC_MIRROR_DROP(void)
+{
+	return 0x4730;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_rcv
+ *
+ * NIX AF Mirror Receive Statistics Register The counter increments for
+ * every received MIRROR packet marked by the NPC.
+ */
+union nixx_af_rx_npc_mirror_rcv {
+	u64 u;
+	struct nixx_af_rx_npc_mirror_rcv_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_rx_npc_mirror_rcv_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_NPC_MIRROR_RCV(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_NPC_MIRROR_RCV(void)
+{
+	return 0x4720;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_sw_sync
+ *
+ * NIX AF Receive Software Sync Register
+ */
+union nixx_af_rx_sw_sync {
+	u64 u;
+	struct nixx_af_rx_sw_sync_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_rx_sw_sync_s cn; */
+};
+
+static inline u64 NIXX_AF_RX_SW_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_RX_SW_SYNC(void)
+{
+	return 0x550;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_hw_xoff#
+ *
+ * NIX AF SDP Transmit Link Hardware Controlled XOFF Registers .
+ */
+union nixx_af_sdp_hw_xoffx {
+	u64 u;
+	struct nixx_af_sdp_hw_xoffx_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct nixx_af_sdp_hw_xoffx_s cn; */
+};
+
+static inline u64 NIXX_AF_SDP_HW_XOFFX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SDP_HW_XOFFX(u64 a)
+{
+	return 0xac0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_link_credit
+ *
+ * NIX AF Transmit Link SDP Credit Register This register tracks SDP link
+ * credits.
+ */
+union nixx_af_sdp_link_credit {
+	u64 u;
+	struct nixx_af_sdp_link_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_62                   : 31;
+		u64 pse_pkt_id_lmt                   : 1;
+	} s;
+	struct nixx_af_sdp_link_credit_cn96xx {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_62                   : 31;
+		u64 reserved_63                      : 1;
+	} cn96xx;
+	/* struct nixx_af_sdp_link_credit_cn96xx cn98xx; */
+	/* struct nixx_af_sdp_link_credit_s cnf95xx; */
+	/* struct nixx_af_sdp_link_credit_cn96xx loki; */
+};
+
+static inline u64 NIXX_AF_SDP_LINK_CREDIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SDP_LINK_CREDIT(void)
+{
+	return 0xa40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_sw_xoff#
+ *
+ * INTERNAL: NIX AF SDP Transmit Link Software Controlled XOFF Registers
+ * Internal: Defeatured registers. Software should use
+ * NIX_AF_TL4()_SW_XOFF registers instead.
+ */
+union nixx_af_sdp_sw_xoffx {
+	u64 u;
+	struct nixx_af_sdp_sw_xoffx_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct nixx_af_sdp_sw_xoffx_s cn; */
+};
+
+static inline u64 NIXX_AF_SDP_SW_XOFFX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SDP_SW_XOFFX(u64 a)
+{
+	return 0xa60 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_tx_fifo_status
+ *
+ * NIX AF SDP Transmit FIFO Status Register Status of FIFO which
+ * transmits packets to SDP.
+ */
+union nixx_af_sdp_tx_fifo_status {
+	u64 u;
+	struct nixx_af_sdp_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct nixx_af_sdp_tx_fifo_status_s cn; */
+};
+
+static inline u64 NIXX_AF_SDP_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SDP_TX_FIFO_STATUS(void)
+{
+	return 0x650;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_active_cycles_pc#
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union nixx_af_seb_active_cycles_pcx {
+	u64 u;
+	struct nixx_af_seb_active_cycles_pcx_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct nixx_af_seb_active_cycles_pcx_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+{
+	return 0x6c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_bp_test
+ *
+ * INTERNAL: NIX AF SEB Backpressure Test Register
+ */
+union nixx_af_seb_bp_test {
+	u64 u;
+	struct nixx_af_seb_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 14;
+		u64 reserved_30_47                   : 18;
+		u64 enable                           : 7;
+		u64 reserved_55_63                   : 9;
+	} s;
+	/* struct nixx_af_seb_bp_test_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_BP_TEST(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_cfg
+ *
+ * NIX SEB Configuration Register
+ */
+union nixx_af_seb_cfg {
+	u64 u;
+	struct nixx_af_seb_cfg_s {
+		u64 sg_ndc_sel                       : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_seb_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_CFG(void)
+{
+	return 0x5f0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_eco
+ *
+ * INTERNAL: AF SEB ECO Register
+ */
+union nixx_af_seb_eco {
+	u64 u;
+	struct nixx_af_seb_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_seb_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_ECO(void)
+{
+	return 0x5c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_pipe_bp_test#
+ *
+ * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
+ */
+union nixx_af_seb_pipe_bp_testx {
+	u64 u;
+	struct nixx_af_seb_pipe_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 24;
+		u64 reserved_40_47                   : 8;
+		u64 enable                           : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct nixx_af_seb_pipe_bp_testx_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+{
+	return 0x600 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_pipeb_bp_test#
+ *
+ * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
+ */
+union nixx_af_seb_pipeb_bp_testx {
+	u64 u;
+	struct nixx_af_seb_pipeb_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 18;
+		u64 reserved_34_47                   : 14;
+		u64 enable                           : 9;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct nixx_af_seb_pipeb_bp_testx_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+{
+	return 0x608 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_wd_tick_divider
+ *
+ * INTERNAL: NIX AF SEB TSTMP Watchdog Tick Divider Register
+ */
+union nixx_af_seb_wd_tick_divider {
+	u64 u;
+	struct nixx_af_seb_wd_tick_divider_s {
+		u64 tick_div_cfg                     : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_seb_wd_tick_divider_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+{
+	return 0x6f0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_cfg
+ *
+ * NIX AF SQM PSE Queue Configuration Registers
+ */
+union nixx_af_smqx_cfg {
+	u64 u;
+	struct nixx_af_smqx_cfg_s {
+		u64 minlen                           : 7;
+		u64 desc_shp_ctl_dis                 : 1;
+		u64 maxlen                           : 16;
+		u64 lf                               : 7;
+		u64 reserved_31_35                   : 5;
+		u64 max_vtag_ins                     : 3;
+		u64 rr_minlen                        : 9;
+		u64 express                          : 1;
+		u64 flush                            : 1;
+		u64 enq_xoff                         : 1;
+		u64 pri_thr                          : 6;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct nixx_af_smqx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_SMQX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SMQX_CFG(u64 a)
+{
+	return 0x700 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_head
+ *
+ * NIX AF SQM SMQ Head Register These registers track the head of the SMQ
+ * linked list.
+ */
+union nixx_af_smqx_head {
+	u64 u;
+	struct nixx_af_smqx_head_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct nixx_af_smqx_head_s cn; */
+};
+
+static inline u64 NIXX_AF_SMQX_HEAD(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SMQX_HEAD(u64 a)
+{
+	return 0x710 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_nxt_head
+ *
+ * NIX AF SQM SMQ Next Head Register These registers track the next head
+ * of the SMQ linked list.
+ */
+union nixx_af_smqx_nxt_head {
+	u64 u;
+	struct nixx_af_smqx_nxt_head_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct nixx_af_smqx_nxt_head_s cn; */
+};
+
+static inline u64 NIXX_AF_SMQX_NXT_HEAD(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SMQX_NXT_HEAD(u64 a)
+{
+	return 0x740 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_status
+ *
+ * NIX AF SQM SMQ Status Register These registers track the status of the
+ * SMQ FIFO.
+ */
+union nixx_af_smqx_status {
+	u64 u;
+	struct nixx_af_smqx_status_s {
+		u64 level                            : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_smqx_status_s cn; */
+};
+
+static inline u64 NIXX_AF_SMQX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SMQX_STATUS(u64 a)
+{
+	return 0x730 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_tail
+ *
+ * NIX AF SQM SMQ Head Register These registers track the tail of SMQ
+ * linked list.
+ */
+union nixx_af_smqx_tail {
+	u64 u;
+	struct nixx_af_smqx_tail_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct nixx_af_smqx_tail_s cn; */
+};
+
+static inline u64 NIXX_AF_SMQX_TAIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SMQX_TAIL(u64 a)
+{
+	return 0x720 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sq_const
+ *
+ * NIX AF SQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union nixx_af_sq_const {
+	u64 u;
+	struct nixx_af_sq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 smq_depth                        : 10;
+		u64 sqb_size                         : 16;
+		u64 reserved_50_63                   : 14;
+	} s;
+	/* struct nixx_af_sq_const_s cn; */
+};
+
+static inline u64 NIXX_AF_SQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SQ_CONST(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_active_cycles_pc
+ *
+ * NIX AF SQM Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union nixx_af_sqm_active_cycles_pc {
+	u64 u;
+	struct nixx_af_sqm_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct nixx_af_sqm_active_cycles_pc_s cn; */
+};
+
+static inline u64 NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+{
+	return 0x770;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_bp_test#
+ *
+ * INTERNAL: NIX AF SQM Backpressure Test Register
+ */
+union nixx_af_sqm_bp_testx {
+	u64 u;
+	struct nixx_af_sqm_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct nixx_af_sqm_bp_testx_s cn; */
+};
+
+static inline u64 NIXX_AF_SQM_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SQM_BP_TESTX(u64 a)
+{
+	return 0x760 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_dbg_ctl_status
+ *
+ * INTERNAL: NIX AF SQM Debug Register  This register is for SQM
+ * diagnostic use only.
+ */
+union nixx_af_sqm_dbg_ctl_status {
+	u64 u;
+	struct nixx_af_sqm_dbg_ctl_status_s {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 tm10                             : 1;
+		u64 tm11                             : 1;
+		u64 tm12                             : 1;
+		u64 tm13                             : 1;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_sqm_dbg_ctl_status_cn96xxp1 {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 reserved_22_63                   : 42;
+	} cn96xxp1;
+	/* struct nixx_af_sqm_dbg_ctl_status_s cn96xxp3; */
+	/* struct nixx_af_sqm_dbg_ctl_status_s cn98xx; */
+	/* struct nixx_af_sqm_dbg_ctl_status_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_sqm_dbg_ctl_status_cnf95xxp2 {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 reserved_22                      : 1;
+		u64 reserved_23                      : 1;
+		u64 reserved_24                      : 1;
+		u64 reserved_25                      : 1;
+		u64 reserved_26_63                   : 38;
+	} cnf95xxp2;
+	/* struct nixx_af_sqm_dbg_ctl_status_s loki; */
+};
+
+static inline u64 NIXX_AF_SQM_DBG_CTL_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SQM_DBG_CTL_STATUS(void)
+{
+	return 0x750;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_eco
+ *
+ * INTERNAL: AF SQM ECO Register
+ */
+union nixx_af_sqm_eco {
+	u64 u;
+	struct nixx_af_sqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct nixx_af_sqm_eco_s cn; */
+};
+
+static inline u64 NIXX_AF_SQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SQM_ECO(void)
+{
+	return 0x5b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_status
+ *
+ * NIX AF General Status Register
+ */
+union nixx_af_status {
+	u64 u;
+	struct nixx_af_status_s {
+		u64 blk_busy                         : 10;
+		u64 calibrate_done                   : 1;
+		u64 reserved_11_15                   : 5;
+		u64 calibrate_status                 : 15;
+		u64 reserved_31_63                   : 33;
+	} s;
+	/* struct nixx_af_status_s cn; */
+};
+
+static inline u64 NIXX_AF_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_STATUS(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tcp_timer
+ *
+ * NIX TCP Timer Register
+ */
+union nixx_af_tcp_timer {
+	u64 u;
+	struct nixx_af_tcp_timer_s {
+		u64 dur_counter                      : 16;
+		u64 lf_counter                       : 8;
+		u64 reserved_24_31                   : 8;
+		u64 duration                         : 16;
+		u64 reserved_48_62                   : 15;
+		u64 ena                              : 1;
+	} s;
+	/* struct nixx_af_tcp_timer_s cn; */
+};
+
+static inline u64 NIXX_AF_TCP_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TCP_TIMER(void)
+{
+	return 0x1e0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_cir
+ *
+ * NIX AF Transmit Level 1 Committed Information Rate Register
+ */
+union nixx_af_tl1x_cir {
+	u64 u;
+	struct nixx_af_tl1x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl1x_cir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_CIR(u64 a)
+{
+	return 0xc20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_bytes
+ *
+ * NIX AF Transmit Level 1 Dropped Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union nixx_af_tl1x_dropped_bytes {
+	u64 u;
+	struct nixx_af_tl1x_dropped_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_tl1x_dropped_bytes_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+{
+	return 0xd30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_packets
+ *
+ * NIX AF Transmit Level 1 Dropped Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union nixx_af_tl1x_dropped_packets {
+	u64 u;
+	struct nixx_af_tl1x_dropped_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl1x_dropped_packets_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+{
+	return 0xd20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green
+ *
+ * INTERNAL: NIX Transmit Level 1 Green State Debug Register
+ */
+union nixx_af_tl1x_green {
+	u64 u;
+	struct nixx_af_tl1x_green_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_19                   : 2;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl1x_green_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_GREEN(u64 a)
+{
+	return 0xc90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green_bytes
+ *
+ * NIX AF Transmit Level 1 Green Sent Bytes Registers
+ */
+union nixx_af_tl1x_green_bytes {
+	u64 u;
+	struct nixx_af_tl1x_green_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_tl1x_green_bytes_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+{
+	return 0xd90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green_packets
+ *
+ * NIX AF Transmit Level 1 Green Sent Packets Registers
+ */
+union nixx_af_tl1x_green_packets {
+	u64 u;
+	struct nixx_af_tl1x_green_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl1x_green_packets_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+{
+	return 0xd80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug0
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 0 Registers
+ * NIX_AF_TL1()_MD_DEBUG0, NIX_AF_TL1()_MD_DEBUG1, NIX_AF_TL1()_MD_DEBUG2
+ * and NIX_AF_TL1()_MD_DEBUG3 provide access to the TLn queue meta
+ * descriptor. A TLn queue can hold up to two packet meta descriptors
+ * (PMD) and one flush meta descriptor (FMD): * PMD0 state is accessed
+ * with [PMD0_VLD], [PMD0_LENGTH] and NIX_AF_TL1()_MD_DEBUG1. * PMD1 is
+ * accessed with [PMD1_VLD], [PMD1_LENGTH] and NIX_AF_TL1()_MD_DEBUG2. *
+ * FMD is accessed with NIX_AF_TL1()_MD_DEBUG3.
+ */
+union nixx_af_tl1x_md_debug0 {
+	u64 u;
+	struct nixx_af_tl1x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct nixx_af_tl1x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl1x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug0_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+{
+	return 0xcc0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug1
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl1x_md_debug1 {
+	u64 u;
+	struct nixx_af_tl1x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl1x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl1x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+{
+	return 0xcc8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug2
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl1x_md_debug2 {
+	u64 u;
+	struct nixx_af_tl1x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl1x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl1x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+{
+	return 0xcd0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug3
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl1x_md_debug3 {
+	u64 u;
+	struct nixx_af_tl1x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct nixx_af_tl1x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl1x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug3_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+{
+	return 0xcd8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red
+ *
+ * INTERNAL: NIX Transmit Level 1 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_YELLOW.
+ */
+union nixx_af_tl1x_red {
+	u64 u;
+	struct nixx_af_tl1x_red_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct nixx_af_tl1x_red_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_RED(u64 a)
+{
+	return 0xcb0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red_bytes
+ *
+ * NIX AF Transmit Level 1 Red Sent Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union nixx_af_tl1x_red_bytes {
+	u64 u;
+	struct nixx_af_tl1x_red_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_tl1x_red_bytes_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_RED_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_RED_BYTES(u64 a)
+{
+	return 0xd50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red_packets
+ *
+ * NIX AF Transmit Level 1 Red Sent Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union nixx_af_tl1x_red_packets {
+	u64 u;
+	struct nixx_af_tl1x_red_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl1x_red_packets_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_RED_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_RED_PACKETS(u64 a)
+{
+	return 0xd40 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_schedule
+ *
+ * NIX AF Transmit Level 1 Scheduling Control Register
+ */
+union nixx_af_tl1x_schedule {
+	u64 u;
+	struct nixx_af_tl1x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tl1x_schedule_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_SCHEDULE(u64 a)
+{
+	return 0xc00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_shape
+ *
+ * NIX AF Transmit Level 1 Shaping Control Register
+ */
+union nixx_af_tl1x_shape {
+	u64 u;
+	struct nixx_af_tl1x_shape_s {
+		u64 adjust                           : 9;
+		u64 reserved_9_23                    : 15;
+		u64 length_disable                   : 1;
+		u64 reserved_25_63                   : 39;
+	} s;
+	struct nixx_af_tl1x_shape_cn {
+		u64 adjust                           : 9;
+		u64 reserved_9_17                    : 9;
+		u64 reserved_18_23                   : 6;
+		u64 length_disable                   : 1;
+		u64 reserved_25_63                   : 39;
+	} cn;
+};
+
+static inline u64 NIXX_AF_TL1X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_SHAPE(u64 a)
+{
+	return 0xc10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_shape_state
+ *
+ * NIX AF Transmit Level 1 Shape State Register This register must not be
+ * written during normal operation.
+ */
+union nixx_af_tl1x_shape_state {
+	u64 u;
+	struct nixx_af_tl1x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 reserved_26_51                   : 26;
+		u64 color                            : 1;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct nixx_af_tl1x_shape_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+{
+	return 0xc50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_sw_xoff
+ *
+ * NIX AF Transmit Level 1 Software Controlled XOFF Registers
+ */
+union nixx_af_tl1x_sw_xoff {
+	u64 u;
+	struct nixx_af_tl1x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_tl1x_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_SW_XOFF(u64 a)
+{
+	return 0xc70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_topology
+ *
+ * NIX AF Transmit Level 1 Topology Registers
+ */
+union nixx_af_tl1x_topology {
+	u64 u;
+	struct nixx_af_tl1x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl1x_topology_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_TOPOLOGY(u64 a)
+{
+	return 0xc80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 1 Yellow State Debug Register
+ */
+union nixx_af_tl1x_yellow {
+	u64 u;
+	struct nixx_af_tl1x_yellow_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct nixx_af_tl1x_yellow_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_YELLOW(u64 a)
+{
+	return 0xca0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_bytes
+ *
+ * NIX AF Transmit Level 1 Yellow Sent Bytes Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union nixx_af_tl1x_yellow_bytes {
+	u64 u;
+	struct nixx_af_tl1x_yellow_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_af_tl1x_yellow_bytes_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+{
+	return 0xd70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_packets
+ *
+ * NIX AF Transmit Level 1 Yellow Sent Packets Registers This register
+ * has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union nixx_af_tl1x_yellow_packets {
+	u64 u;
+	struct nixx_af_tl1x_yellow_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl1x_yellow_packets_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+{
+	return 0xd60 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1_const
+ *
+ * NIX AF Transmit Level 1 Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_tl1_const {
+	u64 u;
+	struct nixx_af_tl1_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_tl1_const_s cn; */
+};
+
+static inline u64 NIXX_AF_TL1_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL1_CONST(void)
+{
+	return 0x70;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_cir
+ *
+ * NIX AF Transmit Level 2 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl2x_cir {
+	u64 u;
+	struct nixx_af_tl2x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl2x_cir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_CIR(u64 a)
+{
+	return 0xe20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_green
+ *
+ * INTERNAL: NIX Transmit Level 2 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_GREEN.
+ */
+union nixx_af_tl2x_green {
+	u64 u;
+	struct nixx_af_tl2x_green_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_19                   : 2;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl2x_green_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_GREEN(u64 a)
+{
+	return 0xe90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug0
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0
+ */
+union nixx_af_tl2x_md_debug0 {
+	u64 u;
+	struct nixx_af_tl2x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct nixx_af_tl2x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl2x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug0_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+{
+	return 0xec0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug1
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl2x_md_debug1 {
+	u64 u;
+	struct nixx_af_tl2x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl2x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl2x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+{
+	return 0xec8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug2
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl2x_md_debug2 {
+	u64 u;
+	struct nixx_af_tl2x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl2x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl2x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+{
+	return 0xed0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug3
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl2x_md_debug3 {
+	u64 u;
+	struct nixx_af_tl2x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct nixx_af_tl2x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl2x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug3_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+{
+	return 0xed8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_parent
+ *
+ * NIX AF Transmit Level 2 Parent Registers
+ */
+union nixx_af_tl2x_parent {
+	u64 u;
+	struct nixx_af_tl2x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 5;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct nixx_af_tl2x_parent_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_PARENT(u64 a)
+{
+	return 0xe88 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_pir
+ *
+ * NIX AF Transmit Level 2 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl2x_pir {
+	u64 u;
+	struct nixx_af_tl2x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl2x_pir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_PIR(u64 a)
+{
+	return 0xe30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 2 Linked List Pointers Debug Register
+ */
+union nixx_af_tl2x_pointers {
+	u64 u;
+	struct nixx_af_tl2x_pointers_s {
+		u64 next                             : 8;
+		u64 reserved_8_15                    : 8;
+		u64 prev                             : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tl2x_pointers_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_POINTERS(u64 a)
+{
+	return 0xe60 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_red
+ *
+ * INTERNAL: NIX Transmit Level 2 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_RED.
+ */
+union nixx_af_tl2x_red {
+	u64 u;
+	struct nixx_af_tl2x_red_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct nixx_af_tl2x_red_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_RED(u64 a)
+{
+	return 0xeb0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_sched_state
+ *
+ * NIX AF Transmit Level 2 Scheduling Control State Registers
+ */
+union nixx_af_tl2x_sched_state {
+	u64 u;
+	struct nixx_af_tl2x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_tl2x_sched_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_SCHED_STATE(u64 a)
+{
+	return 0xe40 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_schedule
+ *
+ * NIX AF Transmit Level 2 Scheduling Control Registers
+ */
+union nixx_af_tl2x_schedule {
+	u64 u;
+	struct nixx_af_tl2x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_tl2x_schedule_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_SCHEDULE(u64 a)
+{
+	return 0xe00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_shape
+ *
+ * NIX AF Transmit Level 2 Shaping Control Registers
+ */
+union nixx_af_tl2x_shape {
+	u64 u;
+	struct nixx_af_tl2x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct nixx_af_tl2x_shape_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_SHAPE(u64 a)
+{
+	return 0xe10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_shape_state
+ *
+ * NIX AF Transmit Level 2 Shape State Registers This register must not
+ * be written during normal operation.
+ */
+union nixx_af_tl2x_shape_state {
+	u64 u;
+	struct nixx_af_tl2x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct nixx_af_tl2x_shape_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+{
+	return 0xe50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_sw_xoff
+ *
+ * NIX AF Transmit Level 2 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF.
+ */
+union nixx_af_tl2x_sw_xoff {
+	u64 u;
+	struct nixx_af_tl2x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_tl2x_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_SW_XOFF(u64 a)
+{
+	return 0xe70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_topology
+ *
+ * NIX AF Transmit Level 2 Topology Registers
+ */
+union nixx_af_tl2x_topology {
+	u64 u;
+	struct nixx_af_tl2x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct nixx_af_tl2x_topology_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_TOPOLOGY(u64 a)
+{
+	return 0xe80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 2 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_YELLOW.
+ */
+union nixx_af_tl2x_yellow {
+	u64 u;
+	struct nixx_af_tl2x_yellow_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct nixx_af_tl2x_yellow_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2X_YELLOW(u64 a)
+{
+	return 0xea0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2_const
+ *
+ * NIX AF Transmit Level 2 Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_tl2_const {
+	u64 u;
+	struct nixx_af_tl2_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_tl2_const_s cn; */
+};
+
+static inline u64 NIXX_AF_TL2_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL2_CONST(void)
+{
+	return 0x78;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_cir
+ *
+ * NIX AF Transmit Level 3 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl3x_cir {
+	u64 u;
+	struct nixx_af_tl3x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl3x_cir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_CIR(u64 a)
+{
+	return 0x1020 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_green
+ *
+ * INTERNAL: NIX Transmit Level 3 Green State Debug Register
+ */
+union nixx_af_tl3x_green {
+	u64 u;
+	struct nixx_af_tl3x_green_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19                      : 1;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl3x_green_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_GREEN(u64 a)
+{
+	return 0x1090 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug0
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl3x_md_debug0 {
+	u64 u;
+	struct nixx_af_tl3x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct nixx_af_tl3x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl3x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug0_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+{
+	return 0x10c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug1
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl3x_md_debug1 {
+	u64 u;
+	struct nixx_af_tl3x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl3x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl3x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+{
+	return 0x10c8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug2
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl3x_md_debug2 {
+	u64 u;
+	struct nixx_af_tl3x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl3x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl3x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+{
+	return 0x10d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug3
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl3x_md_debug3 {
+	u64 u;
+	struct nixx_af_tl3x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct nixx_af_tl3x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl3x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug3_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+{
+	return 0x10d8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_parent
+ *
+ * NIX AF Transmit Level 3 Parent Registers
+ */
+union nixx_af_tl3x_parent {
+	u64 u;
+	struct nixx_af_tl3x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tl3x_parent_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_PARENT(u64 a)
+{
+	return 0x1088 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_pir
+ *
+ * NIX AF Transmit Level 3 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl3x_pir {
+	u64 u;
+	struct nixx_af_tl3x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl3x_pir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_PIR(u64 a)
+{
+	return 0x1030 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 3 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
+ */
+union nixx_af_tl3x_pointers {
+	u64 u;
+	struct nixx_af_tl3x_pointers_s {
+		u64 next                             : 8;
+		u64 reserved_8_15                    : 8;
+		u64 prev                             : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tl3x_pointers_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_POINTERS(u64 a)
+{
+	return 0x1060 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_red
+ *
+ * INTERNAL: NIX Transmit Level 3 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
+ */
+union nixx_af_tl3x_red {
+	u64 u;
+	struct nixx_af_tl3x_red_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_tl3x_red_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_RED(u64 a)
+{
+	return 0x10b0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_sched_state
+ *
+ * NIX AF Transmit Level 3 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union nixx_af_tl3x_sched_state {
+	u64 u;
+	struct nixx_af_tl3x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_tl3x_sched_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_SCHED_STATE(u64 a)
+{
+	return 0x1040 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_schedule
+ *
+ * NIX AF Transmit Level 3 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union nixx_af_tl3x_schedule {
+	u64 u;
+	struct nixx_af_tl3x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_tl3x_schedule_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_SCHEDULE(u64 a)
+{
+	return 0x1000 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_shape
+ *
+ * NIX AF Transmit Level 3 Shaping Control Registers
+ */
+union nixx_af_tl3x_shape {
+	u64 u;
+	struct nixx_af_tl3x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct nixx_af_tl3x_shape_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_SHAPE(u64 a)
+{
+	return 0x1010 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_shape_state
+ *
+ * NIX AF Transmit Level 3 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
+ */
+union nixx_af_tl3x_shape_state {
+	u64 u;
+	struct nixx_af_tl3x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct nixx_af_tl3x_shape_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+{
+	return 0x1050 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_sw_xoff
+ *
+ * NIX AF Transmit Level 3 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union nixx_af_tl3x_sw_xoff {
+	u64 u;
+	struct nixx_af_tl3x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_tl3x_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_SW_XOFF(u64 a)
+{
+	return 0x1070 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_topology
+ *
+ * NIX AF Transmit Level 3 Topology Registers
+ */
+union nixx_af_tl3x_topology {
+	u64 u;
+	struct nixx_af_tl3x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 9;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl3x_topology_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_TOPOLOGY(u64 a)
+{
+	return 0x1080 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 3 Yellow State Debug Register
+ */
+union nixx_af_tl3x_yellow {
+	u64 u;
+	struct nixx_af_tl3x_yellow_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_tl3x_yellow_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3X_YELLOW(u64 a)
+{
+	return 0x10a0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_const
+ *
+ * NIX AF Transmit Level 3 Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_tl3_const {
+	u64 u;
+	struct nixx_af_tl3_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_tl3_const_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3_CONST(void)
+{
+	return 0x80;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_bp_status
+ *
+ * NIX AF Transmit Level 3/2 Backpressure Status Registers
+ */
+union nixx_af_tl3_tl2x_bp_status {
+	u64 u;
+	struct nixx_af_tl3_tl2x_bp_status_s {
+		u64 hw_xoff                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_tl3_tl2x_bp_status_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+{
+	return 0x1610 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_cfg
+ *
+ * NIX AF Transmit Level 3/2 Configuration Registers
+ */
+union nixx_af_tl3_tl2x_cfg {
+	u64 u;
+	struct nixx_af_tl3_tl2x_cfg_s {
+		u64 express                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_tl3_tl2x_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3_TL2X_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3_TL2X_CFG(u64 a)
+{
+	return 0x1600 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_link#_cfg
+ *
+ * NIX AF Transmit Level 3/2 Link Configuration Registers These registers
+ * specify the links and associated channels that a given TL3 or TL2
+ * queue (depending on NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL]) can transmit
+ * on. Each TL3/TL2 queue can be enabled to transmit on and be
+ * backpressured by one or more links and associated channels. The last
+ * index (LINK) is enumerated by NIX_LINK_E.
+ */
+union nixx_af_tl3_tl2x_linkx_cfg {
+	u64 u;
+	struct nixx_af_tl3_tl2x_linkx_cfg_s {
+		u64 relchan                          : 8;
+		u64 reserved_8_11                    : 4;
+		u64 ena                              : 1;
+		u64 bp_ena                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct nixx_af_tl3_tl2x_linkx_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+{
+	return 0x1700 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_bp_status
+ *
+ * NIX AF Transmit Level 4 Backpressure Status Registers
+ */
+union nixx_af_tl4x_bp_status {
+	u64 u;
+	struct nixx_af_tl4x_bp_status_s {
+		u64 hw_xoff                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_tl4x_bp_status_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_BP_STATUS(u64 a)
+{
+	return 0xb00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_cir
+ *
+ * NIX AF Transmit Level 4 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl4x_cir {
+	u64 u;
+	struct nixx_af_tl4x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl4x_cir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_CIR(u64 a)
+{
+	return 0x1220 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_green
+ *
+ * INTERNAL: NIX Transmit Level 4 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_GREEN.
+ */
+union nixx_af_tl4x_green {
+	u64 u;
+	struct nixx_af_tl4x_green_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19                      : 1;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl4x_green_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_GREEN(u64 a)
+{
+	return 0x1290 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug0
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl4x_md_debug0 {
+	u64 u;
+	struct nixx_af_tl4x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct nixx_af_tl4x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl4x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug0_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+{
+	return 0x12c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug1
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl4x_md_debug1 {
+	u64 u;
+	struct nixx_af_tl4x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl4x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl4x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+{
+	return 0x12c8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug2
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl4x_md_debug2 {
+	u64 u;
+	struct nixx_af_tl4x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 reserved_23                      : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	struct nixx_af_tl4x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl4x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+{
+	return 0x12d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug3
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union nixx_af_tl4x_md_debug3 {
+	u64 u;
+	struct nixx_af_tl4x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct nixx_af_tl4x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl4x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug3_cn96xxp3 loki; */
+};
+
+static inline u64 NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+{
+	return 0x12d8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_parent
+ *
+ * NIX AF Transmit Level 4 Parent Registers
+ */
+union nixx_af_tl4x_parent {
+	u64 u;
+	struct nixx_af_tl4x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tl4x_parent_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_PARENT(u64 a)
+{
+	return 0x1288 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_pir
+ *
+ * NIX AF Transmit Level 4 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union nixx_af_tl4x_pir {
+	u64 u;
+	struct nixx_af_tl4x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl4x_pir_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_PIR(u64 a)
+{
+	return 0x1230 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 4 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
+ */
+union nixx_af_tl4x_pointers {
+	u64 u;
+	struct nixx_af_tl4x_pointers_s {
+		u64 next                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 prev                             : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_tl4x_pointers_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_POINTERS(u64 a)
+{
+	return 0x1260 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_red
+ *
+ * INTERNAL: NIX Transmit Level 4 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
+ */
+union nixx_af_tl4x_red {
+	u64 u;
+	struct nixx_af_tl4x_red_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_tl4x_red_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_RED(u64 a)
+{
+	return 0x12b0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sched_state
+ *
+ * NIX AF Transmit Level 4 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union nixx_af_tl4x_sched_state {
+	u64 u;
+	struct nixx_af_tl4x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct nixx_af_tl4x_sched_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SCHED_STATE(u64 a)
+{
+	return 0x1240 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_schedule
+ *
+ * NIX AF Transmit Level 4 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union nixx_af_tl4x_schedule {
+	u64 u;
+	struct nixx_af_tl4x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_tl4x_schedule_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SCHEDULE(u64 a)
+{
+	return 0x1200 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sdp_link_cfg
+ *
+ * NIX AF Transmit Level 4 Link Configuration Registers These registers
+ * specify which TL4 queues transmit to and are optionally backpressured
+ * by SDP.
+ */
+union nixx_af_tl4x_sdp_link_cfg {
+	u64 u;
+	struct nixx_af_tl4x_sdp_link_cfg_s {
+		u64 relchan                          : 8;
+		u64 reserved_8_11                    : 4;
+		u64 ena                              : 1;
+		u64 bp_ena                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct nixx_af_tl4x_sdp_link_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+{
+	return 0xb10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_shape
+ *
+ * NIX AF Transmit Level 4 Shaping Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE.
+ */
+union nixx_af_tl4x_shape {
+	u64 u;
+	struct nixx_af_tl4x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct nixx_af_tl4x_shape_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SHAPE(u64 a)
+{
+	return 0x1210 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_shape_state
+ *
+ * NIX AF Transmit Level 4 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
+ */
+union nixx_af_tl4x_shape_state {
+	u64 u;
+	struct nixx_af_tl4x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct nixx_af_tl4x_shape_state_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+{
+	return 0x1250 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sw_xoff
+ *
+ * NIX AF Transmit Level 4 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union nixx_af_tl4x_sw_xoff {
+	u64 u;
+	struct nixx_af_tl4x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct nixx_af_tl4x_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_SW_XOFF(u64 a)
+{
+	return 0x1270 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_topology
+ *
+ * NIX AF Transmit Level 4 Topology Registers
+ */
+union nixx_af_tl4x_topology {
+	u64 u;
+	struct nixx_af_tl4x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 9;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct nixx_af_tl4x_topology_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_TOPOLOGY(u64 a)
+{
+	return 0x1280 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 4 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_YELLOW
+ */
+union nixx_af_tl4x_yellow {
+	u64 u;
+	struct nixx_af_tl4x_yellow_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct nixx_af_tl4x_yellow_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4X_YELLOW(u64 a)
+{
+	return 0x12a0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4_const
+ *
+ * NIX AF Transmit Level 4 Constants Register This register contains
+ * constants for software discovery.
+ */
+union nixx_af_tl4_const {
+	u64 u;
+	struct nixx_af_tl4_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct nixx_af_tl4_const_s cn; */
+};
+
+static inline u64 NIXX_AF_TL4_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TL4_CONST(void)
+{
+	return 0x88;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_expr_credit
+ *
+ * INTERNAL: NIX AF Transmit Link Express Credit Registers  Internal:
+ * 802.3br frame preemption/express path is defeatured. Old definition:
+ * These registers track credits per link for express packets that may
+ * potentially preempt normal packets. Link index enumerated by
+ * NIX_LINK_E.
+ */
+union nixx_af_tx_linkx_expr_credit {
+	u64 u;
+	struct nixx_af_tx_linkx_expr_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_tx_linkx_expr_credit_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+{
+	return 0xa10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_hw_xoff
+ *
+ * NIX AF Transmit Link Hardware Controlled XOFF Registers Link index
+ * enumerated by NIX_LINK_E.
+ */
+union nixx_af_tx_linkx_hw_xoff {
+	u64 u;
+	struct nixx_af_tx_linkx_hw_xoff_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct nixx_af_tx_linkx_hw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+{
+	return 0xa30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_norm_credit
+ *
+ * NIX AF Transmit Link Normal Credit Registers These registers track
+ * credits per link for normal packets sent to CGX and LBK. Link index
+ * enumerated by NIX_LINK_E.
+ */
+union nixx_af_tx_linkx_norm_credit {
+	u64 u;
+	struct nixx_af_tx_linkx_norm_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_tx_linkx_norm_credit_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+{
+	return 0xa00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_sw_xoff
+ *
+ * INTERNAL: NIX AF Transmit Link Software Controlled XOFF Registers
+ * Link index enumerated by NIX_LINK_E. Internal: Defeatured registers.
+ * Software should instead use NIX_AF_TL3()_SW_XOFF registers when
+ * NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL] is set and NIX_AF_TL2()_SW_XOFF
+ * registers when NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL] is clear.
+ */
+union nixx_af_tx_linkx_sw_xoff {
+	u64 u;
+	struct nixx_af_tx_linkx_sw_xoff_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct nixx_af_tx_linkx_sw_xoff_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+{
+	return 0xa20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_mcast#
+ *
+ * NIX AF Transmit Multicast Registers These registers access transmit
+ * multicast table entries used to specify multicast replication lists.
+ * Each list consists of linked entries with [EOL] = 1 in the last entry.
+ * A transmit packet is multicast when the action returned by NPC has
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST. NIX_TX_ACTION_S[INDEX]
+ * points to the start of the multicast replication list, and [EOL] = 1
+ * indicates the end of list.
+ */
+union nixx_af_tx_mcastx {
+	u64 u;
+	struct nixx_af_tx_mcastx_s {
+		u64 channel                          : 12;
+		u64 eol                              : 1;
+		u64 reserved_13_15                   : 3;
+		u64 next                             : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct nixx_af_tx_mcastx_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_MCASTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_MCASTX(u64 a)
+{
+	return 0x1900 + 0x8000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_config
+ *
+ * NIX AF Transmit NPC Response Capture Configuration Register Configures
+ * the NPC response capture logic for transmit packets. When enabled,
+ * allows NPC responses for selected packets to be captured in
+ * NIX_AF_TX_NPC_CAPTURE_INFO and NIX_AF_TX_NPC_CAPTURE_RESP().
+ */
+union nixx_af_tx_npc_capture_config {
+	u64 u;
+	struct nixx_af_tx_npc_capture_config_s {
+		u64 en                               : 1;
+		u64 continuous                       : 1;
+		u64 lso_segnum_en                    : 1;
+		u64 sqe_id_en                        : 1;
+		u64 sq_id_en                         : 1;
+		u64 lf_id_en                         : 1;
+		u64 reserved_6_11                    : 6;
+		u64 lso_segnum                       : 8;
+		u64 sqe_id                           : 16;
+		u64 sq_id                            : 20;
+		u64 lf_id                            : 8;
+	} s;
+	/* struct nixx_af_tx_npc_capture_config_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+{
+	return 0x660;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_info
+ *
+ * NIX AF Transmit NPC Response Capture Information Register This
+ * register contains captured NPC response information for a transmit
+ * packet. See NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ */
+union nixx_af_tx_npc_capture_info {
+	u64 u;
+	struct nixx_af_tx_npc_capture_info_s {
+		u64 vld                              : 1;
+		u64 reserved_1_11                    : 11;
+		u64 lso_segnum                       : 8;
+		u64 sqe_id                           : 16;
+		u64 sq_id                            : 20;
+		u64 lf_id                            : 8;
+	} s;
+	/* struct nixx_af_tx_npc_capture_info_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+{
+	return 0x668;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_resp#
+ *
+ * NIX AF Transmit NPC Capture Response Registers These registers contain
+ * the captured NPC response for a transmit packet when
+ * NIX_AF_TX_NPC_CAPTURE_INFO[VLD] is set. See also
+ * NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ */
+union nixx_af_tx_npc_capture_respx {
+	u64 u;
+	struct nixx_af_tx_npc_capture_respx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct nixx_af_tx_npc_capture_respx_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+{
+	return 0x680 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_tstmp_cfg
+ *
+ * NIX AF Transmit Timestamp Configuration Register
+ */
+union nixx_af_tx_tstmp_cfg {
+	u64 u;
+	struct nixx_af_tx_tstmp_cfg_s {
+		u64 tstmp_wd_period                  : 4;
+		u64 reserved_4_7                     : 4;
+		u64 express                          : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct nixx_af_tx_tstmp_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_TSTMP_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_TSTMP_CFG(void)
+{
+	return 0xc0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_ctl
+ *
+ * NIX AF Transmit Vtag Definition Control Registers The transmit Vtag
+ * definition table specifies Vtag layers (e.g. VLAN, E-TAG) to
+ * optionally insert or replace in the TX packet header. Indexed by
+ * NIX_TX_VTAG_ACTION_S[VTAG*_DEF].
+ */
+union nixx_af_tx_vtag_defx_ctl {
+	u64 u;
+	struct nixx_af_tx_vtag_defx_ctl_s {
+		u64 size                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_tx_vtag_defx_ctl_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+{
+	return 0x1a00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_data
+ *
+ * NIX AF Transmit Vtag Definition Data Registers See
+ * NIX_AF_TX_VTAG_DEF()_CTL.
+ */
+union nixx_af_tx_vtag_defx_data {
+	u64 u;
+	struct nixx_af_tx_vtag_defx_data_s {
+		u64 data                             : 64;
+	} s;
+	/* struct nixx_af_tx_vtag_defx_data_s cn; */
+};
+
+static inline u64 NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+{
+	return 0x1a10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cfg
+ *
+ * NIX LF Configuration Register
+ */
+union nixx_lf_cfg {
+	u64 u;
+	struct nixx_lf_cfg_s {
+		u64 tcp_timer_int_ena                : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_cfg_s cn; */
+};
+
+static inline u64 NIXX_LF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CFG(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_cnt
+ *
+ * NIX LF Completion Interrupt Count Registers
+ */
+union nixx_lf_cintx_cnt {
+	u64 u;
+	struct nixx_lf_cintx_cnt_s {
+		u64 ecount                           : 32;
+		u64 qcount                           : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_lf_cintx_cnt_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_CNT(u64 a)
+{
+	return 0xd00 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1c
+ *
+ * NIX LF Completion Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union nixx_lf_cintx_ena_w1c {
+	u64 u;
+	struct nixx_lf_cintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_cintx_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_ENA_W1C(u64 a)
+{
+	return 0xd50 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1s
+ *
+ * NIX LF Completion Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union nixx_lf_cintx_ena_w1s {
+	u64 u;
+	struct nixx_lf_cintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_cintx_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_ENA_W1S(u64 a)
+{
+	return 0xd40 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_int
+ *
+ * NIX LF Completion Interrupt Registers
+ */
+union nixx_lf_cintx_int {
+	u64 u;
+	struct nixx_lf_cintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_cintx_int_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_INT(u64 a)
+{
+	return 0xd20 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_int_w1s
+ *
+ * NIX LF Completion Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union nixx_lf_cintx_int_w1s {
+	u64 u;
+	struct nixx_lf_cintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_cintx_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_INT_W1S(u64 a)
+{
+	return 0xd30 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_wait
+ *
+ * NIX LF Completion Interrupt Count Registers
+ */
+union nixx_lf_cintx_wait {
+	u64 u;
+	struct nixx_lf_cintx_wait_s {
+		u64 ecount_wait                      : 32;
+		u64 qcount_wait                      : 16;
+		u64 time_wait                        : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct nixx_lf_cintx_wait_s cn; */
+};
+
+static inline u64 NIXX_LF_CINTX_WAIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CINTX_WAIT(u64 a)
+{
+	return 0xd10 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_door
+ *
+ * NIX LF CQ Doorbell Operation Register A write to this register
+ * dequeues CQEs from a CQ ring within the LF. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union nixx_lf_cq_op_door {
+	u64 u;
+	struct nixx_lf_cq_op_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_31                   : 16;
+		u64 cq                               : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct nixx_lf_cq_op_door_s cn; */
+};
+
+static inline u64 NIXX_LF_CQ_OP_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CQ_OP_DOOR(void)
+{
+	return 0xb30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_int
+ *
+ * NIX LF Completion Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads CQ interrupts and interrupt
+ * enables. A write optionally sets or clears interrupts and interrupt
+ * enables. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_cq_op_int {
+	u64 u;
+	struct nixx_lf_cq_op_int_s {
+		u64 cq_err_int                       : 8;
+		u64 cq_err_int_ena                   : 8;
+		u64 reserved_16_41                   : 26;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 cq                               : 20;
+	} s;
+	/* struct nixx_lf_cq_op_int_s cn; */
+};
+
+static inline u64 NIXX_LF_CQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CQ_OP_INT(void)
+{
+	return 0xb00;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_status
+ *
+ * NIX LF Completion Queue Status Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_CQ_CTX_S[HEAD,TAIL]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the CQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_cq_op_status {
+	u64 u;
+	struct nixx_lf_cq_op_status_s {
+		u64 tail                             : 20;
+		u64 head                             : 20;
+		u64 reserved_40_45                   : 6;
+		u64 cq_err                           : 1;
+		u64 reserved_47_62                   : 16;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_cq_op_status_s cn; */
+};
+
+static inline u64 NIXX_LF_CQ_OP_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_CQ_OP_STATUS(void)
+{
+	return 0xb40;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int
+ *
+ * NIX LF Error Interrupt Register
+ */
+union nixx_lf_err_int {
+	u64 u;
+	struct nixx_lf_err_int_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct nixx_lf_err_int_s cn; */
+};
+
+static inline u64 NIXX_LF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_ERR_INT(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1c
+ *
+ * NIX LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_lf_err_int_ena_w1c {
+	u64 u;
+	struct nixx_lf_err_int_ena_w1c_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct nixx_lf_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_LF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_ERR_INT_ENA_W1C(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1s
+ *
+ * NIX LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union nixx_lf_err_int_ena_w1s {
+	u64 u;
+	struct nixx_lf_err_int_ena_w1s_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct nixx_lf_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_ERR_INT_ENA_W1S(void)
+{
+	return 0x238;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_w1s
+ *
+ * NIX LF Error Interrupt Set Register This register sets interrupt bits.
+ */
+union nixx_lf_err_int_w1s {
+	u64 u;
+	struct nixx_lf_err_int_w1s_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct nixx_lf_err_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_ERR_INT_W1S(void)
+{
+	return 0x228;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint
+ *
+ * NIX LF General Interrupt Register
+ */
+union nixx_lf_gint {
+	u64 u;
+	struct nixx_lf_gint_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct nixx_lf_gint_s cn; */
+};
+
+static inline u64 NIXX_LF_GINT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_GINT(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1c
+ *
+ * NIX LF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_lf_gint_ena_w1c {
+	u64 u;
+	struct nixx_lf_gint_ena_w1c_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct nixx_lf_gint_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_LF_GINT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_GINT_ENA_W1C(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1s
+ *
+ * NIX LF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union nixx_lf_gint_ena_w1s {
+	u64 u;
+	struct nixx_lf_gint_ena_w1s_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct nixx_lf_gint_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_GINT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_GINT_ENA_W1S(void)
+{
+	return 0x218;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_w1s
+ *
+ * NIX LF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union nixx_lf_gint_w1s {
+	u64 u;
+	struct nixx_lf_gint_w1s_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct nixx_lf_gint_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_GINT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_GINT_W1S(void)
+{
+	return 0x208;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_mnq_err_dbg
+ *
+ * NIX LF Meta-descriptor Enqueue Error Debug Register This register
+ * captures debug info for an error detected during send meta-descriptor
+ * enqueue from an SQ to an SMQ. Hardware sets [VALID] when the debug
+ * info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
+ */
+union nixx_lf_mnq_err_dbg {
+	u64 u;
+	struct nixx_lf_mnq_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct nixx_lf_mnq_err_dbg_s cn; */
+};
+
+static inline u64 NIXX_LF_MNQ_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_MNQ_ERR_DBG(void)
+{
+	return 0x270;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_op_ipsec_dyno_cnt
+ *
+ * INTERNAL: NIX LF IPSEC Dynamic Ordering Counter Operation Register
+ * Internal: Not used; no IPSEC fast-path. All accesses are RAZ/WI.
+ */
+union nixx_lf_op_ipsec_dyno_cnt {
+	u64 u;
+	struct nixx_lf_op_ipsec_dyno_cnt_s {
+		u64 count                            : 32;
+		u64 reserved_32_46                   : 15;
+		u64 storeop                          : 1;
+		u64 dyno_sel                         : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_op_ipsec_dyno_cnt_s cn; */
+};
+
+static inline u64 NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+{
+	return 0x980;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_op_send#
+ *
+ * NIX LF Send Operation Registers An LMTST (or large store from CPT) to
+ * this address enqueues one or more SQEs to a send queue.
+ * NIX_SEND_HDR_S[SQ] in the first SQE selects the send queue.The maximum
+ * size of each SQE is specified by NIX_SQ_CTX_S[MAX_SQE_SIZE].  A read
+ * to this address is RAZ.  An RSL access to this address will fault.
+ * The endianness of the instruction write data is controlled by
+ * NIX_AF_LF()_CFG[BE].  When a NIX_SEND_JUMP_S is not present in the
+ * SQE, the SQE consists of the entire send descriptor.  When a
+ * NIX_SEND_JUMP_S is present in the SQE, the SQE must contain exactly
+ * the portion of the send descriptor up to and including the
+ * NIX_SEND_JUMP_S, and the remainder of the send descriptor must be at
+ * LF IOVA NIX_SEND_JUMP_S[ADDR] in LLC/DRAM.  Software must ensure that
+ * all LLC/DRAM locations that will be referenced by NIX while processing
+ * this descriptor, including all packet data and post-jump
+ * subdescriptors contain the latest updates before issuing the LMTST. A
+ * DMB instruction may be required prior to the LMTST to ensure this. A
+ * DMB following the LMTST may be useful if SQ descriptor ordering
+ * matters and more than one CPU core is simultaneously enqueueing to the
+ * same SQ.
+ */
+union nixx_lf_op_sendx {
+	u64 u;
+	struct nixx_lf_op_sendx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct nixx_lf_op_sendx_s cn; */
+};
+
+static inline u64 NIXX_LF_OP_SENDX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_OP_SENDX(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_cnt
+ *
+ * NIX LF Queue Interrupt Count Registers
+ */
+union nixx_lf_qintx_cnt {
+	u64 u;
+	struct nixx_lf_qintx_cnt_s {
+		u64 count                            : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct nixx_lf_qintx_cnt_s cn; */
+};
+
+static inline u64 NIXX_LF_QINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_QINTX_CNT(u64 a)
+{
+	return 0xc00 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1c
+ *
+ * NIX LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union nixx_lf_qintx_ena_w1c {
+	u64 u;
+	struct nixx_lf_qintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_qintx_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_LF_QINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_QINTX_ENA_W1C(u64 a)
+{
+	return 0xc30 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1s
+ *
+ * NIX LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union nixx_lf_qintx_ena_w1s {
+	u64 u;
+	struct nixx_lf_qintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_qintx_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_QINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_QINTX_ENA_W1S(u64 a)
+{
+	return 0xc20 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_int
+ *
+ * NIX LF Queue Interrupt Registers
+ */
+union nixx_lf_qintx_int {
+	u64 u;
+	struct nixx_lf_qintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_qintx_int_s cn; */
+};
+
+static inline u64 NIXX_LF_QINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_QINTX_INT(u64 a)
+{
+	return 0xc10 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_int_w1s
+ *
+ * INTERNAL: NIX LF Queue Interrupt Set Registers
+ */
+union nixx_lf_qintx_int_w1s {
+	u64 u;
+	struct nixx_lf_qintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_lf_qintx_int_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_QINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_QINTX_INT_W1S(u64 a)
+{
+	return 0xc18 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras
+ *
+ * NIX LF RAS Interrupt Register
+ */
+union nixx_lf_ras {
+	u64 u;
+	struct nixx_lf_ras_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_lf_ras_s cn; */
+};
+
+static inline u64 NIXX_LF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RAS(void)
+{
+	return 0x240;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1c
+ *
+ * NIX LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union nixx_lf_ras_ena_w1c {
+	u64 u;
+	struct nixx_lf_ras_ena_w1c_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_lf_ras_ena_w1c_s cn; */
+};
+
+static inline u64 NIXX_LF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RAS_ENA_W1C(void)
+{
+	return 0x250;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1s
+ *
+ * NIX LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union nixx_lf_ras_ena_w1s {
+	u64 u;
+	struct nixx_lf_ras_ena_w1s_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_lf_ras_ena_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RAS_ENA_W1S(void)
+{
+	return 0x258;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_w1s
+ *
+ * NIX LF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union nixx_lf_ras_w1s {
+	u64 u;
+	struct nixx_lf_ras_w1s_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct nixx_lf_ras_w1s_s cn; */
+};
+
+static inline u64 NIXX_LF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RAS_W1S(void)
+{
+	return 0x248;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_octs
+ *
+ * NIX LF Receive Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_RQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_rq_op_drop_octs {
+	u64 u;
+	struct nixx_lf_rq_op_drop_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_rq_op_drop_octs_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_DROP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_DROP_OCTS(void)
+{
+	return 0x930;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_pkts
+ *
+ * NIX LF Receive Queue Dropped Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[DROP_PKTS].
+ * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_rq_op_drop_pkts {
+	u64 u;
+	struct nixx_lf_rq_op_drop_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_rq_op_drop_pkts_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_DROP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_DROP_PKTS(void)
+{
+	return 0x940;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_int
+ *
+ * NIX LF Receive Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads RQ interrupts and interrupt
+ * enables. A 64-bit write optionally sets or clears interrupts and
+ * interrupt enables.  All other accesses to this register (e.g. reads,
+ * 128-bit accesses) are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union nixx_lf_rq_op_int {
+	u64 u;
+	struct nixx_lf_rq_op_int_s {
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 reserved_16_41                   : 26;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 rq                               : 20;
+	} s;
+	/* struct nixx_lf_rq_op_int_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_INT(void)
+{
+	return 0x900;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_octs
+ *
+ * NIX LF Receive Queue Octets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[OCTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_rq_op_octs {
+	u64 u;
+	struct nixx_lf_rq_op_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_rq_op_octs_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_OCTS(void)
+{
+	return 0x910;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_pkts
+ *
+ * NIX LF Receive Queue Packets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[PKTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_rq_op_pkts {
+	u64 u;
+	struct nixx_lf_rq_op_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_rq_op_pkts_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_PKTS(void)
+{
+	return 0x920;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_re_pkts
+ *
+ * NIX LF Receive Queue Errored Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[RE_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_rq_op_re_pkts {
+	u64 u;
+	struct nixx_lf_rq_op_re_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_rq_op_re_pkts_s cn; */
+};
+
+static inline u64 NIXX_LF_RQ_OP_RE_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RQ_OP_RE_PKTS(void)
+{
+	return 0x950;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rx_secret#
+ *
+ * NIX LF Receive Secret Key Registers
+ */
+union nixx_lf_rx_secretx {
+	u64 u;
+	struct nixx_lf_rx_secretx_s {
+		u64 key                              : 64;
+	} s;
+	/* struct nixx_lf_rx_secretx_s cn; */
+};
+
+static inline u64 NIXX_LF_RX_SECRETX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RX_SECRETX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rx_stat#
+ *
+ * NIX LF Receive Statistics Registers The last dimension indicates which
+ * statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ */
+union nixx_lf_rx_statx {
+	u64 u;
+	struct nixx_lf_rx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_lf_rx_statx_s cn; */
+};
+
+static inline u64 NIXX_LF_RX_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_RX_STATX(u64 a)
+{
+	return 0x400 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_send_err_dbg
+ *
+ * NIX LF Send Error Debug Register This register captures debug info an
+ * error detected on packet send after a meta-descriptor is granted by
+ * PSE. Hardware sets [VALID] when the debug info is captured, and
+ * subsequent errors are not captured until software clears [VALID] by
+ * writing a one to it.
+ */
+union nixx_lf_send_err_dbg {
+	u64 u;
+	struct nixx_lf_send_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct nixx_lf_send_err_dbg_s cn; */
+};
+
+static inline u64 NIXX_LF_SEND_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SEND_ERR_DBG(void)
+{
+	return 0x280;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_octs
+ *
+ * NIX LF Send Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_sq_op_drop_octs {
+	u64 u;
+	struct nixx_lf_sq_op_drop_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_sq_op_drop_octs_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_DROP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_DROP_OCTS(void)
+{
+	return 0xa40;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_pkts
+ *
+ * NIX LF Send Queue Dropped Packets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_sq_op_drop_pkts {
+	u64 u;
+	struct nixx_lf_sq_op_drop_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_sq_op_drop_pkts_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_DROP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_DROP_PKTS(void)
+{
+	return 0xa50;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_err_dbg
+ *
+ * NIX LF SQ Operation Error Debug Register This register captures debug
+ * info for an error detected on LMT store to NIX_LF_OP_SEND() or when a
+ * NIX_LF_SQ_OP_* register is accessed. Hardware sets [VALID] when the
+ * debug info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
+ */
+union nixx_lf_sq_op_err_dbg {
+	u64 u;
+	struct nixx_lf_sq_op_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct nixx_lf_sq_op_err_dbg_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_ERR_DBG(void)
+{
+	return 0x260;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_int
+ *
+ * NIX LF Send Queue Interrupt Operation Register A 64-bit atomic load-
+ * and-add to this register reads SQ interrupts, interrupt enables and
+ * XOFF status. A write optionally sets or clears interrupts, interrupt
+ * enables and XOFF status. A read is RAZ.  RSL accesses to this register
+ * are RAZ/WI.
+ */
+union nixx_lf_sq_op_int {
+	u64 u;
+	struct nixx_lf_sq_op_int_s {
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 xoff                             : 1;
+		u64 reserved_17_41                   : 25;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 sq                               : 20;
+	} s;
+	/* struct nixx_lf_sq_op_int_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_INT(void)
+{
+	return 0xa00;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_octs
+ *
+ * NIX LF Send Queue Octets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[OCTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union nixx_lf_sq_op_octs {
+	u64 u;
+	struct nixx_lf_sq_op_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_sq_op_octs_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_OCTS(void)
+{
+	return 0xa10;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_pkts
+ *
+ * NIX LF Send Queue Packets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[PKTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union nixx_lf_sq_op_pkts {
+	u64 u;
+	struct nixx_lf_sq_op_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct nixx_lf_sq_op_pkts_s cn; */
+};
+
+static inline u64 NIXX_LF_SQ_OP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_PKTS(void)
+{
+	return 0xa20;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_status
+ *
+ * NIX LF Send Queue Status Operation Register A 64-bit atomic load-and-
+ * add to this register reads status fields in NIX_SQ_CTX_S. The atomic
+ * write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
+ * Completion of the load-and-add operation also ensures that all
+ * previously issued LMT stores to NIX_LF_OP_SEND() have completed.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union nixx_lf_sq_op_status {
+	u64 u;
+	struct nixx_lf_sq_op_status_s {
+		u64 sqb_count                        : 16;
+		u64 reserved_16_19                   : 4;
+		u64 head_offset                      : 6;
+		u64 reserved_26_27                   : 2;
+		u64 tail_offset                      : 6;
+		u64 reserved_34_62                   : 29;
+		u64 op_err                           : 1;
+	} s;
+	struct nixx_lf_sq_op_status_cn {
+		u64 sqb_count                        : 16;
+		u64 reserved_16_19                   : 4;
+		u64 head_offset                      : 6;
+		u64 reserved_26_27                   : 2;
+		u64 tail_offset                      : 6;
+		u64 reserved_34_35                   : 2;
+		u64 reserved_36_62                   : 27;
+		u64 op_err                           : 1;
+	} cn;
+};
+
+static inline u64 NIXX_LF_SQ_OP_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_SQ_OP_STATUS(void)
+{
+	return 0xa30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_tx_stat#
+ *
+ * NIX LF Transmit Statistics Registers The last dimension indicates
+ * which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ */
+union nixx_lf_tx_statx {
+	u64 u;
+	struct nixx_lf_tx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct nixx_lf_tx_statx_s cn; */
+};
+
+static inline u64 NIXX_LF_TX_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_LF_TX_STATX(u64 a)
+{
+	return 0x300 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_af_int_cfg
+ *
+ * NIX Privileged Admin Function Interrupt Configuration Register
+ */
+union nixx_priv_af_int_cfg {
+	u64 u;
+	struct nixx_priv_af_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct nixx_priv_af_int_cfg_s cn; */
+};
+
+static inline u64 NIXX_PRIV_AF_INT_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_PRIV_AF_INT_CFG(void)
+{
+	return 0x8000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_lf#_cfg
+ *
+ * NIX Privileged Local Function Configuration Registers These registers
+ * allow each NIX local function (LF) to be provisioned to a VF/PF for
+ * RVU. See also NIX_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
+ */
+union nixx_priv_lfx_cfg {
+	u64 u;
+	struct nixx_priv_lfx_cfg_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_62                   : 39;
+		u64 ena                              : 1;
+	} s;
+	/* struct nixx_priv_lfx_cfg_s cn; */
+};
+
+static inline u64 NIXX_PRIV_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_PRIV_LFX_CFG(u64 a)
+{
+	return 0x8000010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_lf#_int_cfg
+ *
+ * NIX Privileged LF Interrupt Configuration Registers
+ */
+union nixx_priv_lfx_int_cfg {
+	u64 u;
+	struct nixx_priv_lfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct nixx_priv_lfx_int_cfg_s cn; */
+};
+
+static inline u64 NIXX_PRIV_LFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_PRIV_LFX_INT_CFG(u64 a)
+{
+	return 0x8000020 + 0x100 * a;
+}
+
+#endif /* __CSRS_NIX_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
new file mode 100644
index 0000000000..19bea0ccd9
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
@@ -0,0 +1,2298 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NPA_H__
+#define __CSRS_NPA_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * NPA.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration npa_af_int_vec_e
+ *
+ * NPA Admin Function Interrupt Vector Enumeration Enumerates the NPA AF
+ * MSI-X interrupt vectors.
+ */
+#define NPA_AF_INT_VEC_E_AF_ERR (3)
+#define NPA_AF_INT_VEC_E_AQ_DONE (2)
+#define NPA_AF_INT_VEC_E_GEN (1)
+#define NPA_AF_INT_VEC_E_POISON (4)
+#define NPA_AF_INT_VEC_E_RVU (0)
+
+/**
+ * Enumeration npa_aq_comp_e
+ *
+ * NPA Admin Queue Completion Enumeration Enumerates the values of
+ * NPA_AQ_RES_S[COMPCODE].
+ */
+#define NPA_AQ_COMP_E_CTX_FAULT (4)
+#define NPA_AQ_COMP_E_CTX_POISON (3)
+#define NPA_AQ_COMP_E_GOOD (1)
+#define NPA_AQ_COMP_E_LOCKERR (5)
+#define NPA_AQ_COMP_E_NOTDONE (0)
+#define NPA_AQ_COMP_E_SWERR (2)
+
+/**
+ * Enumeration npa_aq_ctype_e
+ *
+ * NPA Admin Queue Context Type Enumeration Enumerates
+ * NPA_AQ_INST_S[CTYPE] values.
+ */
+#define NPA_AQ_CTYPE_E_AURA (0)
+#define NPA_AQ_CTYPE_E_POOL (1)
+
+/**
+ * Enumeration npa_aq_instop_e
+ *
+ * NPA Admin Queue Opcode Enumeration Enumerates NPA_AQ_INST_S[OP]
+ * values.
+ */
+#define NPA_AQ_INSTOP_E_INIT (1)
+#define NPA_AQ_INSTOP_E_LOCK (4)
+#define NPA_AQ_INSTOP_E_NOP (0)
+#define NPA_AQ_INSTOP_E_READ (3)
+#define NPA_AQ_INSTOP_E_UNLOCK (5)
+#define NPA_AQ_INSTOP_E_WRITE (2)
+
+/**
+ * Enumeration npa_aura_err_int_e
+ *
+ * NPA Aura Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_AURA_S[ERR_INT], and NPA_AURA_S[ERR_INT_ENA].
+ */
+#define NPA_AURA_ERR_INT_E_AURA_ADD_OVER (1)
+#define NPA_AURA_ERR_INT_E_AURA_ADD_UNDER (2)
+#define NPA_AURA_ERR_INT_E_AURA_FREE_UNDER (0)
+#define NPA_AURA_ERR_INT_E_POOL_DIS (3)
+#define NPA_AURA_ERR_INT_E_RX(a) (0 + (a))
+
+/**
+ * Enumeration npa_bpintf_e
+ *
+ * NPA Backpressure Interface Enumeration Enumerates index of
+ * NPA_AURA_S[BP_ENA].
+ */
+#define NPA_BPINTF_E_NIXX_RX(a) (0 + (a))
+
+/**
+ * Enumeration npa_inpq_e
+ *
+ * NPA Input Queue Enumeration Enumerates ALLOC/FREE input queues from
+ * coprocessors.
+ */
+#define NPA_INPQ_E_AURA_OP (0xe)
+#define NPA_INPQ_E_BPHY (7)
+#define NPA_INPQ_E_DPI (6)
+#define NPA_INPQ_E_DPI0 (6)
+#define NPA_INPQ_E_DPI1 (7)
+#define NPA_INPQ_E_INTERNAL_RSV (0xf)
+#define NPA_INPQ_E_NIXX_RX(a) (0 + 2 * (a))
+#define NPA_INPQ_E_NIXX_TX(a) (1 + 2 * (a))
+#define NPA_INPQ_E_RX(a) (0 + (a))
+#define NPA_INPQ_E_SSO (4)
+#define NPA_INPQ_E_TIM (5)
+
+/**
+ * Enumeration npa_lf_int_vec_e
+ *
+ * NPA Local Function Interrupt Vector Enumeration Enumerates the NPA
+ * MSI-X interrupt vectors per LF.
+ */
+#define NPA_LF_INT_VEC_E_ERR_INT (0x40)
+#define NPA_LF_INT_VEC_E_POISON (0x41)
+#define NPA_LF_INT_VEC_E_QINTX(a) (0 + (a))
+
+/**
+ * Enumeration npa_ndc0_port_e
+ *
+ * NPA NDC0 Port Enumeration Enumerates NPA NDC0 (NDC_IDX_E::NPA_U(0))
+ * ports and the PORT index of NDC_AF_PORT()_RT()_RW()_REQ_PC and
+ * NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define NPA_NDC0_PORT_E_AURA0 (0)
+#define NPA_NDC0_PORT_E_AURA1 (1)
+#define NPA_NDC0_PORT_E_POOL0 (2)
+#define NPA_NDC0_PORT_E_POOL1 (3)
+#define NPA_NDC0_PORT_E_STACK0 (4)
+#define NPA_NDC0_PORT_E_STACK1 (5)
+
+/**
+ * Enumeration npa_pool_err_int_e
+ *
+ * NPA Pool Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_POOL_S[ERR_INT] and NPA_POOL_S[ERR_INT_ENA].
+ */
+#define NPA_POOL_ERR_INT_E_OVFLS (0)
+#define NPA_POOL_ERR_INT_E_PERR (2)
+#define NPA_POOL_ERR_INT_E_RX(a) (0 + (a))
+#define NPA_POOL_ERR_INT_E_RANGE (1)
+
+/**
+ * Structure npa_aq_inst_s
+ *
+ * NPA Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
+ * Hardware reads of NPA_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context, i.e.: * NPA_AURA_HW_S reads and writes use
+ * NPA_AF_LF()_AURAS_CFG[CACHING] and NPA_AF_LF()_AURAS_CFG[WAY_MASK]. *
+ * NPA_POOL_HW_S reads and writes use NPA_AURA_HW_S[POOL_CACHING] and
+ * NPA_AURA_HW_S[POOL_WAY_MASK].
+ */
+union npa_aq_inst_s {
+	u64 u[2];
+	struct npa_aq_inst_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 lf                               : 9;
+		u64 reserved_17_23                   : 7;
+		u64 cindex                           : 20;
+		u64 reserved_44_62                   : 19;
+		u64 doneint                          : 1;
+		u64 res_addr                         : 64;
+	} s;
+	/* struct npa_aq_inst_s_s cn; */
+};
+
+/**
+ * Structure npa_aq_res_s
+ *
+ * NPA Admin Queue Result Structure NPA writes this structure after it
+ * completes the NPA_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
+ * When [OP] = NPA_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
+ * immediately followed by context read or write data. See
+ * NPA_AQ_INSTOP_E.  Hardware writes of NPA_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
+ */
+union npa_aq_res_s {
+	u64 u[2];
+	struct npa_aq_res_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 compcode                         : 8;
+		u64 doneint                          : 1;
+		u64 reserved_17_63                   : 47;
+		u64 reserved_64_127                  : 64;
+	} s;
+	/* struct npa_aq_res_s_s cn; */
+};
+
+/**
+ * Structure npa_aura_op_wdata_s
+ *
+ * NPA Aura Operation Write Data Structure This structure specifies the
+ * write data format of a 64-bit atomic load-and-add to
+ * NPA_LF_AURA_OP_ALLOC() and NPA_LF_POOL_OP_PC, and a 128-bit atomic
+ * CASP operation to NPA_LF_AURA_OP_ALLOC().
+ */
+union npa_aura_op_wdata_s {
+	u64 u;
+	struct npa_aura_op_wdata_s_s {
+		u64 aura                             : 20;
+		u64 reserved_20_62                   : 43;
+		u64 drop                             : 1;
+	} s;
+	/* struct npa_aura_op_wdata_s_s cn; */
+};
+
+/**
+ * Structure npa_aura_s
+ *
+ * NPA Aura Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write an aura's
+ * NPA_AURA_HW_S structure maintained by hardware in LLC/DRAM.
+ */
+union npa_aura_s {
+	u64 u[8];
+	struct npa_aura_s_s {
+		u64 pool_addr                        : 64;
+		u64 ena                              : 1;
+		u64 reserved_65_66                   : 2;
+		u64 pool_caching                     : 1;
+		u64 pool_way_mask                    : 16;
+		u64 avg_con                          : 9;
+		u64 reserved_93                      : 1;
+		u64 pool_drop_ena                    : 1;
+		u64 aura_drop_ena                    : 1;
+		u64 bp_ena                           : 2;
+		u64 reserved_98_103                  : 6;
+		u64 aura_drop                        : 8;
+		u64 shift                            : 6;
+		u64 reserved_118_119                 : 2;
+		u64 avg_level                        : 8;
+		u64 count                            : 36;
+		u64 reserved_164_167                 : 4;
+		u64 nix0_bpid                        : 9;
+		u64 reserved_177_179                 : 3;
+		u64 nix1_bpid                        : 9;
+		u64 reserved_189_191                 : 3;
+		u64 limit                            : 36;
+		u64 reserved_228_231                 : 4;
+		u64 bp                               : 8;
+		u64 reserved_240_243                 : 4;
+		u64 fc_ena                           : 1;
+		u64 fc_up_crossing                   : 1;
+		u64 fc_stype                         : 2;
+		u64 fc_hyst_bits                     : 4;
+		u64 reserved_252_255                 : 4;
+		u64 fc_addr                          : 64;
+		u64 pool_drop                        : 8;
+		u64 update_time                      : 16;
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 thresh_up                        : 1;
+		u64 reserved_363                     : 1;
+		u64 thresh_qint_idx                  : 7;
+		u64 reserved_371                     : 1;
+		u64 err_qint_idx                     : 7;
+		u64 reserved_379_383                 : 5;
+		u64 thresh                           : 36;
+		u64 reserved_420_447                 : 28;
+		u64 reserved_448_511                 : 64;
+	} s;
+	/* struct npa_aura_s_s cn; */
+};
+
+/**
+ * Structure npa_pool_s
+ *
+ * NPA Pool Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write a pool's
+ * NPA_POOL_HW_S structure maintained by hardware in LLC/DRAM.
+ */
+union npa_pool_s {
+	u64 u[16];
+	struct npa_pool_s_s {
+		u64 stack_base                       : 64;
+		u64 ena                              : 1;
+		u64 nat_align                        : 1;
+		u64 reserved_66_67                   : 2;
+		u64 stack_caching                    : 1;
+		u64 reserved_69_71                   : 3;
+		u64 stack_way_mask                   : 16;
+		u64 buf_offset                       : 12;
+		u64 reserved_100_103                 : 4;
+		u64 buf_size                         : 11;
+		u64 reserved_115_127                 : 13;
+		u64 stack_max_pages                  : 32;
+		u64 stack_pages                      : 32;
+		u64 op_pc                            : 48;
+		u64 reserved_240_255                 : 16;
+		u64 stack_offset                     : 4;
+		u64 reserved_260_263                 : 4;
+		u64 shift                            : 6;
+		u64 reserved_270_271                 : 2;
+		u64 avg_level                        : 8;
+		u64 avg_con                          : 9;
+		u64 fc_ena                           : 1;
+		u64 fc_stype                         : 2;
+		u64 fc_hyst_bits                     : 4;
+		u64 fc_up_crossing                   : 1;
+		u64 reserved_297_299                 : 3;
+		u64 update_time                      : 16;
+		u64 reserved_316_319                 : 4;
+		u64 fc_addr                          : 64;
+		u64 ptr_start                        : 64;
+		u64 ptr_end                          : 64;
+		u64 reserved_512_535                 : 24;
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 thresh_up                        : 1;
+		u64 reserved_555                     : 1;
+		u64 thresh_qint_idx                  : 7;
+		u64 reserved_563                     : 1;
+		u64 err_qint_idx                     : 7;
+		u64 reserved_571_575                 : 5;
+		u64 thresh                           : 36;
+		u64 reserved_612_639                 : 28;
+		u64 reserved_640_703                 : 64;
+		u64 reserved_704_767                 : 64;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct npa_pool_s_s cn; */
+};
+
+/**
+ * Structure npa_qint_hw_s
+ *
+ * NPA Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NPA_LF_QINT()_* registers. Hardware maintains a table of
+ * NPA_AF_CONST[QINTS] contiguous NPA_QINT_HW_S structures per LF
+ * starting at IOVA NPA_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union npa_qint_hw_s {
+	u32 u;
+	struct npa_qint_hw_s_s {
+		u32 count                            : 22;
+		u32 reserved_22_30                   : 9;
+		u32 ena                              : 1;
+	} s;
+	/* struct npa_qint_hw_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_active_cycles_pc
+ *
+ * NPA AF Active Cycles Register
+ */
+union npa_af_active_cycles_pc {
+	u64 u;
+	struct npa_af_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct npa_af_active_cycles_pc_s cn; */
+};
+
+static inline u64 NPA_AF_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ACTIVE_CYCLES_PC(void)
+{
+	return 0xf0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_base
+ *
+ * NPA AF Admin Queue Base Address Register
+ */
+union npa_af_aq_base {
+	u64 u;
+	struct npa_af_aq_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 base_addr                        : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct npa_af_aq_base_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_BASE(void)
+{
+	return 0x610;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_cfg
+ *
+ * NPA AF Admin Queue Configuration Register
+ */
+union npa_af_aq_cfg {
+	u64 u;
+	struct npa_af_aq_cfg_s {
+		u64 qsize                            : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npa_af_aq_cfg_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_CFG(void)
+{
+	return 0x600;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done
+ *
+ * NPA AF AQ Done Count Register
+ */
+union npa_af_aq_done {
+	u64 u;
+	struct npa_af_aq_done_s {
+		u64 done                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_af_aq_done_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE(void)
+{
+	return 0x650;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ack
+ *
+ * NPA AF AQ Done Count Ack Register This register is written by software
+ * to acknowledge interrupts.
+ */
+union npa_af_aq_done_ack {
+	u64 u;
+	struct npa_af_aq_done_ack_s {
+		u64 done_ack                         : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_af_aq_done_ack_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_ACK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_ACK(void)
+{
+	return 0x660;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1c
+ *
+ * NPA AF AQ Done Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_af_aq_done_ena_w1c {
+	u64 u;
+	struct npa_af_aq_done_ena_w1c_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_aq_done_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_ENA_W1C(void)
+{
+	return 0x698;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1s
+ *
+ * NPA AF AQ Done Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union npa_af_aq_done_ena_w1s {
+	u64 u;
+	struct npa_af_aq_done_ena_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_aq_done_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_ENA_W1S(void)
+{
+	return 0x690;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_int
+ *
+ * NPA AF AQ Done Interrupt Register
+ */
+union npa_af_aq_done_int {
+	u64 u;
+	struct npa_af_aq_done_int_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_aq_done_int_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_INT(void)
+{
+	return 0x680;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_int_w1s
+ *
+ * INTERNAL: NPA AF AQ Done Interrupt Set Register
+ */
+union npa_af_aq_done_int_w1s {
+	u64 u;
+	struct npa_af_aq_done_int_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_aq_done_int_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_INT_W1S(void)
+{
+	return 0x688;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_timer
+ *
+ * NPA AF Admin Queue Done Interrupt Timer Register Used to debug the
+ * queue interrupt coalescing timer.
+ */
+union npa_af_aq_done_timer {
+	u64 u;
+	struct npa_af_aq_done_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_af_aq_done_timer_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_TIMER(void)
+{
+	return 0x670;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_wait
+ *
+ * NPA AF AQ Done Interrupt Coalescing Wait Register Specifies the queue
+ * interrupt coalescing settings.
+ */
+union npa_af_aq_done_wait {
+	u64 u;
+	struct npa_af_aq_done_wait_s {
+		u64 num_wait                         : 20;
+		u64 reserved_20_31                   : 12;
+		u64 time_wait                        : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npa_af_aq_done_wait_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DONE_WAIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DONE_WAIT(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_door
+ *
+ * NPA AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue one or more entries to AQ.
+ */
+union npa_af_aq_door {
+	u64 u;
+	struct npa_af_aq_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_af_aq_door_s cn; */
+};
+
+static inline u64 NPA_AF_AQ_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_DOOR(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_status
+ *
+ * NPA AF Admin Queue Status Register
+ */
+union npa_af_aq_status {
+	u64 u;
+	struct npa_af_aq_status_s {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_35                   : 12;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} s;
+	struct npa_af_aq_status_cn {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} cn;
+};
+
+static inline u64 NPA_AF_AQ_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AQ_STATUS(void)
+{
+	return 0x620;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_avg_delay
+ *
+ * NPA AF Queue Average Delay Register
+ */
+union npa_af_avg_delay {
+	u64 u;
+	struct npa_af_avg_delay_s {
+		u64 avg_dly                          : 19;
+		u64 reserved_19_23                   : 5;
+		u64 avg_timer                        : 16;
+		u64 reserved_40_62                   : 23;
+		u64 avg_timer_dis                    : 1;
+	} s;
+	/* struct npa_af_avg_delay_s cn; */
+};
+
+static inline u64 NPA_AF_AVG_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_AVG_DELAY(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bar2_alias#
+ *
+ * INTERNAL: NPA Admin Function  BAR2 Alias Registers  These registers
+ * alias to the NPA BAR2 registers for the PF and function selected by
+ * NPA_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union npa_af_bar2_aliasx {
+	u64 u;
+	struct npa_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct npa_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 NPA_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bar2_sel
+ *
+ * INTERNAL: NPA Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the NPA_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ */
+union npa_af_bar2_sel {
+	u64 u;
+	struct npa_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct npa_af_bar2_sel_s cn; */
+};
+
+static inline u64 NPA_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_blk_rst
+ *
+ * NPA AF Block Reset Register
+ */
+union npa_af_blk_rst {
+	u64 u;
+	struct npa_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct npa_af_blk_rst_s cn; */
+};
+
+static inline u64 NPA_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_BLK_RST(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bp_test
+ *
+ * INTERNAL: NPA AF Backpressure Test Register
+ */
+union npa_af_bp_test {
+	u64 u;
+	struct npa_af_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} s;
+	/* struct npa_af_bp_test_s cn; */
+};
+
+static inline u64 NPA_AF_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_BP_TEST(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_const
+ *
+ * NPA AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union npa_af_const {
+	u64 u;
+	struct npa_af_const_s {
+		u64 stack_page_bytes                 : 8;
+		u64 stack_page_ptrs                  : 8;
+		u64 lfs                              : 12;
+		u64 qints                            : 12;
+		u64 num_ndc                          : 3;
+		u64 reserved_43_63                   : 21;
+	} s;
+	/* struct npa_af_const_s cn; */
+};
+
+static inline u64 NPA_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_CONST(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_const1
+ *
+ * NPA AF Constants Register 1 This register contains constants for
+ * software discovery.
+ */
+union npa_af_const1 {
+	u64 u;
+	struct npa_af_const1_s {
+		u64 aura_log2bytes                   : 4;
+		u64 pool_log2bytes                   : 4;
+		u64 qint_log2bytes                   : 4;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct npa_af_const1_s cn; */
+};
+
+static inline u64 NPA_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_CONST1(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_dtx_filter_ctl
+ *
+ * NPA AF DTX LF Filter Control Register
+ */
+union npa_af_dtx_filter_ctl {
+	u64 u;
+	struct npa_af_dtx_filter_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_3                     : 3;
+		u64 lf                               : 7;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct npa_af_dtx_filter_ctl_s cn; */
+};
+
+static inline u64 NPA_AF_DTX_FILTER_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_DTX_FILTER_CTL(void)
+{
+	return 0x10040;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_eco
+ *
+ * INTERNAL: NPA AF ECO Register
+ */
+union npa_af_eco {
+	u64 u;
+	struct npa_af_eco_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct npa_af_eco_s cn; */
+};
+
+static inline u64 NPA_AF_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ECO(void)
+{
+	return 0x300;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int
+ *
+ * NPA Admin Function Error Interrupt Register
+ */
+union npa_af_err_int {
+	u64 u;
+	struct npa_af_err_int_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npa_af_err_int_s cn; */
+};
+
+static inline u64 NPA_AF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ERR_INT(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1c
+ *
+ * NPA Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union npa_af_err_int_ena_w1c {
+	u64 u;
+	struct npa_af_err_int_ena_w1c_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npa_af_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_AF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ERR_INT_ENA_W1C(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1s
+ *
+ * NPA Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union npa_af_err_int_ena_w1s {
+	u64 u;
+	struct npa_af_err_int_ena_w1s_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npa_af_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ERR_INT_ENA_W1S(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_w1s
+ *
+ * NPA Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union npa_af_err_int_w1s {
+	u64 u;
+	struct npa_af_err_int_w1s_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npa_af_err_int_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_ERR_INT_W1S(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_cfg
+ *
+ * NPA AF General Configuration Register This register provides NPA
+ * control and status information.
+ */
+union npa_af_gen_cfg {
+	u64 u;
+	struct npa_af_gen_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 af_be                            : 1;
+		u64 reserved_2                       : 1;
+		u64 force_cond_clk_en                : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_5_9                     : 5;
+		u64 ocla_bp                          : 1;
+		u64 reserved_11                      : 1;
+		u64 ratem1                           : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_af_gen_cfg_s cn; */
+};
+
+static inline u64 NPA_AF_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_GEN_CFG(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int
+ *
+ * NPA AF General Interrupt Register This register contains general error
+ * interrupt summary bits.
+ */
+union npa_af_gen_int {
+	u64 u;
+	struct npa_af_gen_int_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct npa_af_gen_int_s cn; */
+};
+
+static inline u64 NPA_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_GEN_INT(void)
+{
+	return 0x140;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1c
+ *
+ * NPA AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_af_gen_int_ena_w1c {
+	u64 u;
+	struct npa_af_gen_int_ena_w1c_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct npa_af_gen_int_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x158;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1s
+ *
+ * NPA AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union npa_af_gen_int_ena_w1s {
+	u64 u;
+	struct npa_af_gen_int_ena_w1s_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct npa_af_gen_int_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x150;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_w1s
+ *
+ * NPA AF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union npa_af_gen_int_w1s {
+	u64 u;
+	struct npa_af_gen_int_w1s_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct npa_af_gen_int_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_GEN_INT_W1S(void)
+{
+	return 0x148;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_inp_ctl
+ *
+ * NPA AF Input Control Register
+ */
+union npa_af_inp_ctl {
+	u64 u;
+	struct npa_af_inp_ctl_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct npa_af_inp_ctl_s cn; */
+};
+
+static inline u64 NPA_AF_INP_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_INP_CTL(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_auras_cfg
+ *
+ * NPA AF Local Function Auras Configuration Registers
+ */
+union npa_af_lfx_auras_cfg {
+	u64 u;
+	struct npa_af_lfx_auras_cfg_s {
+		u64 way_mask                         : 16;
+		u64 loc_aura_size                    : 4;
+		u64 loc_aura_offset                  : 14;
+		u64 caching                          : 1;
+		u64 be                               : 1;
+		u64 rmt_aura_size                    : 4;
+		u64 rmt_aura_offset                  : 14;
+		u64 rmt_lf                           : 7;
+		u64 reserved_61_63                   : 3;
+	} s;
+	struct npa_af_lfx_auras_cfg_cn96xxp1 {
+		u64 way_mask                         : 16;
+		u64 loc_aura_size                    : 4;
+		u64 loc_aura_offset                  : 14;
+		u64 caching                          : 1;
+		u64 reserved_35                      : 1;
+		u64 rmt_aura_size                    : 4;
+		u64 rmt_aura_offset                  : 14;
+		u64 rmt_lf                           : 7;
+		u64 reserved_61_63                   : 3;
+	} cn96xxp1;
+	/* struct npa_af_lfx_auras_cfg_s cn96xxp3; */
+	/* struct npa_af_lfx_auras_cfg_s cn98xx; */
+	/* struct npa_af_lfx_auras_cfg_s cnf95xx; */
+	/* struct npa_af_lfx_auras_cfg_s loki; */
+};
+
+static inline u64 NPA_AF_LFX_AURAS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_LFX_AURAS_CFG(u64 a)
+{
+	return 0x4000 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_loc_auras_base
+ *
+ * NPA AF Local Function Auras Base Registers
+ */
+union npa_af_lfx_loc_auras_base {
+	u64 u;
+	struct npa_af_lfx_loc_auras_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct npa_af_lfx_loc_auras_base_s cn; */
+};
+
+static inline u64 NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+{
+	return 0x4010 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_qints_base
+ *
+ * NPA AF Local Function Queue Interrupts Base Registers
+ */
+union npa_af_lfx_qints_base {
+	u64 u;
+	struct npa_af_lfx_qints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct npa_af_lfx_qints_base_s cn; */
+};
+
+static inline u64 NPA_AF_LFX_QINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_LFX_QINTS_BASE(u64 a)
+{
+	return 0x4110 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_qints_cfg
+ *
+ * NPA AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * LLC/DRAM. The table consists of NPA_AF_CONST[QINTS] contiguous
+ * NPA_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NPA_AF_CONST1[QINT_LOG2BYTES] bytes.
+ */
+union npa_af_lfx_qints_cfg {
+	u64 u;
+	struct npa_af_lfx_qints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 2;
+		u64 reserved_38_63                   : 26;
+	} s;
+	/* struct npa_af_lfx_qints_cfg_s cn; */
+};
+
+static inline u64 NPA_AF_LFX_QINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_LFX_QINTS_CFG(u64 a)
+{
+	return 0x4100 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf_rst
+ *
+ * NPA Admin Function LF Reset Register
+ */
+union npa_af_lf_rst {
+	u64 u;
+	struct npa_af_lf_rst_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct npa_af_lf_rst_s cn; */
+};
+
+static inline u64 NPA_AF_LF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_LF_RST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ndc_cfg
+ *
+ * NDC AF General Configuration Register This register provides NDC
+ * control.
+ */
+union npa_af_ndc_cfg {
+	u64 u;
+	struct npa_af_ndc_cfg_s {
+		u64 ndc_bypass                       : 1;
+		u64 ndc_ign_pois                     : 1;
+		u64 byp_aura                         : 1;
+		u64 byp_pool                         : 1;
+		u64 byp_stack                        : 1;
+		u64 byp_qint                         : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct npa_af_ndc_cfg_s cn; */
+};
+
+static inline u64 NPA_AF_NDC_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_NDC_CFG(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ndc_sync
+ *
+ * NPA AF NDC Sync Register Used to synchronize the NPA NDC.
+ */
+union npa_af_ndc_sync {
+	u64 u;
+	struct npa_af_ndc_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct npa_af_ndc_sync_s cn; */
+};
+
+static inline u64 NPA_AF_NDC_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_NDC_SYNC(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras
+ *
+ * NPA AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
+ */
+union npa_af_ras {
+	u64 u;
+	struct npa_af_ras_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct npa_af_ras_s cn; */
+};
+
+static inline u64 NPA_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RAS(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_ena_w1c
+ *
+ * NPA AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_af_ras_ena_w1c {
+	u64 u;
+	struct npa_af_ras_ena_w1c_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct npa_af_ras_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RAS_ENA_W1C(void)
+{
+	return 0x1b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_ena_w1s
+ *
+ * NPA AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union npa_af_ras_ena_w1s {
+	u64 u;
+	struct npa_af_ras_ena_w1s_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct npa_af_ras_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RAS_ENA_W1S(void)
+{
+	return 0x1b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_w1s
+ *
+ * NPA AF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union npa_af_ras_w1s {
+	u64 u;
+	struct npa_af_ras_w1s_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct npa_af_ras_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RAS_W1S(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int
+ *
+ * NPA AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
+ */
+union npa_af_rvu_int {
+	u64 u;
+	struct npa_af_rvu_int_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_rvu_int_s cn; */
+};
+
+static inline u64 NPA_AF_RVU_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RVU_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1c
+ *
+ * NPA AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_af_rvu_int_ena_w1c {
+	u64 u;
+	struct npa_af_rvu_int_ena_w1c_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_rvu_int_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_AF_RVU_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RVU_INT_ENA_W1C(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1s
+ *
+ * NPA AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union npa_af_rvu_int_ena_w1s {
+	u64 u;
+	struct npa_af_rvu_int_ena_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_rvu_int_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_RVU_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RVU_INT_ENA_W1S(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_w1s
+ *
+ * NPA AF RVU Interrupt Set Register This register sets interrupt bits.
+ */
+union npa_af_rvu_int_w1s {
+	u64 u;
+	struct npa_af_rvu_int_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_af_rvu_int_w1s_s cn; */
+};
+
+static inline u64 NPA_AF_RVU_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RVU_INT_W1S(void)
+{
+	return 0x168;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_lf_cfg_debug
+ *
+ * NPA Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NPA_PRIV_LF()_CFG.
+ */
+union npa_af_rvu_lf_cfg_debug {
+	u64 u;
+	struct npa_af_rvu_lf_cfg_debug_s {
+		u64 lf                               : 12;
+		u64 lf_valid                         : 1;
+		u64 exec                             : 1;
+		u64 reserved_14_15                   : 2;
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct npa_af_rvu_lf_cfg_debug_s cn; */
+};
+
+static inline u64 NPA_AF_RVU_LF_CFG_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_AF_RVU_LF_CFG_DEBUG(void)
+{
+	return 0x10030;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_alloc#
+ *
+ * NPA Aura Allocate Operation Registers These registers are used to
+ * allocate one or two pointers from a given aura's pool. A 64-bit atomic
+ * load-and-add to NPA_LF_AURA_OP_ALLOC(0) allocates a single pointer. A
+ * 128-bit atomic CASP operation to NPA_LF_AURA_OP_ALLOC(0..1) allocates
+ * two pointers. The atomic write data format is NPA_AURA_OP_WDATA_S. For
+ * CASP, the first SWAP word in the write data contains
+ * NPA_AURA_OP_WDATA_S and the remaining write data words are ignored.
+ * All other accesses to this register (e.g. reads and writes) are
+ * RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_aura_op_allocx {
+	u64 u;
+	struct npa_lf_aura_op_allocx_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct npa_lf_aura_op_allocx_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_ALLOCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_ALLOCX(u64 a)
+{
+	return 0x10 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_cnt
+ *
+ * NPA LF Aura Count Register A 64-bit atomic load-and-add to this
+ * register returns a given aura's count. A write sets or adds the aura's
+ * count. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_aura_op_cnt {
+	u64 u;
+	struct npa_lf_aura_op_cnt_s {
+		u64 count                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 cnt_add                          : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_aura_op_cnt_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_CNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_CNT(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free0
+ *
+ * NPA LF Aura Free Operation Register 0 A 128-bit write (STP) to
+ * NPA_LF_AURA_OP_FREE0 and NPA_LF_AURA_OP_FREE1 frees a pointer into a
+ * given aura's pool. All other accesses to these registers (e.g. reads
+ * and 64-bit writes) are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union npa_lf_aura_op_free0 {
+	u64 u;
+	struct npa_lf_aura_op_free0_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct npa_lf_aura_op_free0_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_FREE0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_FREE0(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free1
+ *
+ * NPA LF Aura Free Operation Register 1 See NPA_LF_AURA_OP_FREE0.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union npa_lf_aura_op_free1 {
+	u64 u;
+	struct npa_lf_aura_op_free1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_62                   : 43;
+		u64 fabs                             : 1;
+	} s;
+	/* struct npa_lf_aura_op_free1_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_FREE1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_FREE1(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_int
+ *
+ * NPA LF Aura Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
+ * NPA_AURA_HW_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
+ */
+union npa_lf_aura_op_int {
+	u64 u;
+	struct npa_lf_aura_op_int_s {
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 reserved_18_41                   : 24;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_aura_op_int_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_INT(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_limit
+ *
+ * NPA LF Aura Allocation Limit Register A 64-bit atomic load-and-add to
+ * this register returns a given aura's limit. A write sets the aura's
+ * limit. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_aura_op_limit {
+	u64 u;
+	struct npa_lf_aura_op_limit_s {
+		u64 limit                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 reserved_43                      : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_aura_op_limit_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_LIMIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_LIMIT(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_thresh
+ *
+ * NPA LF Aura Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_AURA_HW_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_AURA_HW_S[THRESH_UP,THRESH] and recomputes
+ * NPA_AURA_HW_S[THRESH_INT]. A read is RAZ.  RSL accesses to this
+ * register are RAZ/WI.
+ */
+union npa_lf_aura_op_thresh {
+	u64 u;
+	struct npa_lf_aura_op_thresh_s {
+		u64 thresh                           : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 thresh_up                        : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_aura_op_thresh_s cn; */
+};
+
+static inline u64 NPA_LF_AURA_OP_THRESH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_AURA_OP_THRESH(void)
+{
+	return 0x70;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int
+ *
+ * NPA LF Error Interrupt Register
+ */
+union npa_lf_err_int {
+	u64 u;
+	struct npa_lf_err_int_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_lf_err_int_s cn; */
+};
+
+static inline u64 NPA_LF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_ERR_INT(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1c
+ *
+ * NPA LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_lf_err_int_ena_w1c {
+	u64 u;
+	struct npa_lf_err_int_ena_w1c_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_lf_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_LF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_ERR_INT_ENA_W1C(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1s
+ *
+ * NPA LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union npa_lf_err_int_ena_w1s {
+	u64 u;
+	struct npa_lf_err_int_ena_w1s_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_lf_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_ERR_INT_ENA_W1S(void)
+{
+	return 0x218;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_w1s
+ *
+ * NPA LF Error Interrupt Set Register This register sets interrupt bits.
+ */
+union npa_lf_err_int_w1s {
+	u64 u;
+	struct npa_lf_err_int_w1s_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct npa_lf_err_int_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_ERR_INT_W1S(void)
+{
+	return 0x208;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_available
+ *
+ * NPA LF Pool Available Count Operation Register A 64-bit atomic load-
+ * and-add to this register returns a given pool's free pointer count.
+ * Reads and writes are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union npa_lf_pool_op_available {
+	u64 u;
+	struct npa_lf_pool_op_available_s {
+		u64 count                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 reserved_43                      : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_pool_op_available_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_AVAILABLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_AVAILABLE(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_int
+ *
+ * NPA LF Pool Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
+ * NPA_POOL_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_int {
+	u64 u;
+	struct npa_lf_pool_op_int_s {
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 reserved_18_41                   : 24;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_pool_op_int_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_pc
+ *
+ * NPA LF Pool Performance Count Register A 64-bit atomic load-and-add to
+ * this register reads NPA_POOL_S[OP_PC] from a given aura's pool. The
+ * aura is selected by the atomic write data, whose format is
+ * NPA_AURA_OP_WDATA_S. Reads and writes are RAZ/WI.  RSL accesses to
+ * this register are RAZ/WI.
+ */
+union npa_lf_pool_op_pc {
+	u64 u;
+	struct npa_lf_pool_op_pc_s {
+		u64 op_pc                            : 48;
+		u64 op_err                           : 1;
+		u64 reserved_49_63                   : 15;
+	} s;
+	/* struct npa_lf_pool_op_pc_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_PC(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end0
+ *
+ * NPA LF Pool Pointer End Operation Register 0 A 128-bit write (STP) to
+ * the NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1 registers
+ * writes to a given pool's pointer end value. All other accesses to
+ * these registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_ptr_end0 {
+	u64 u;
+	struct npa_lf_pool_op_ptr_end0_s {
+		u64 ptr_end                          : 64;
+	} s;
+	/* struct npa_lf_pool_op_ptr_end0_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_PTR_END0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_PTR_END0(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end1
+ *
+ * NPA LF Pool Pointer End Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_END0.  RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_ptr_end1 {
+	u64 u;
+	struct npa_lf_pool_op_ptr_end1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_lf_pool_op_ptr_end1_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_PTR_END1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_PTR_END1(void)
+{
+	return 0x138;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start0
+ *
+ * NPA LF Pool Pointer Start Operation Register 0 A 128-bit write (STP)
+ * to the NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1
+ * registers writes to a given pool's pointer start value. All other
+ * accesses to these registers (e.g. reads and 64-bit writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_ptr_start0 {
+	u64 u;
+	struct npa_lf_pool_op_ptr_start0_s {
+		u64 ptr_start                        : 64;
+	} s;
+	/* struct npa_lf_pool_op_ptr_start0_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_PTR_START0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_PTR_START0(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start1
+ *
+ * NPA LF Pool Pointer Start Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_START0.  RSL accesses to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_ptr_start1 {
+	u64 u;
+	struct npa_lf_pool_op_ptr_start1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_lf_pool_op_ptr_start1_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_PTR_START1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_PTR_START1(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_thresh
+ *
+ * NPA LF Pool Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_POOL_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_POOL_S[THRESH_UP,THRESH]. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union npa_lf_pool_op_thresh {
+	u64 u;
+	struct npa_lf_pool_op_thresh_s {
+		u64 thresh                           : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 thresh_up                        : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct npa_lf_pool_op_thresh_s cn; */
+};
+
+static inline u64 NPA_LF_POOL_OP_THRESH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_POOL_OP_THRESH(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_cnt
+ *
+ * NPA LF Queue Interrupt Count Registers
+ */
+union npa_lf_qintx_cnt {
+	u64 u;
+	struct npa_lf_qintx_cnt_s {
+		u64 count                            : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct npa_lf_qintx_cnt_s cn; */
+};
+
+static inline u64 NPA_LF_QINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_QINTX_CNT(u64 a)
+{
+	return 0x300 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1c
+ *
+ * NPA LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union npa_lf_qintx_ena_w1c {
+	u64 u;
+	struct npa_lf_qintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_lf_qintx_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_LF_QINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_QINTX_ENA_W1C(u64 a)
+{
+	return 0x330 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1s
+ *
+ * NPA LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union npa_lf_qintx_ena_w1s {
+	u64 u;
+	struct npa_lf_qintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_lf_qintx_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_QINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_QINTX_ENA_W1S(u64 a)
+{
+	return 0x320 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_int
+ *
+ * NPA LF Queue Interrupt Registers
+ */
+union npa_lf_qintx_int {
+	u64 u;
+	struct npa_lf_qintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_lf_qintx_int_s cn; */
+};
+
+static inline u64 NPA_LF_QINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_QINTX_INT(u64 a)
+{
+	return 0x310 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_int_w1s
+ *
+ * INTERNAL: NPA LF Queue Interrupt Set Registers
+ */
+union npa_lf_qintx_int_w1s {
+	u64 u;
+	struct npa_lf_qintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npa_lf_qintx_int_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_QINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_QINTX_INT_W1S(u64 a)
+{
+	return 0x318 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras
+ *
+ * NPA LF RAS Interrupt Register
+ */
+union npa_lf_ras {
+	u64 u;
+	struct npa_lf_ras_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npa_lf_ras_s cn; */
+};
+
+static inline u64 NPA_LF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_RAS(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1c
+ *
+ * NPA LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union npa_lf_ras_ena_w1c {
+	u64 u;
+	struct npa_lf_ras_ena_w1c_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npa_lf_ras_ena_w1c_s cn; */
+};
+
+static inline u64 NPA_LF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_RAS_ENA_W1C(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1s
+ *
+ * NPA LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union npa_lf_ras_ena_w1s {
+	u64 u;
+	struct npa_lf_ras_ena_w1s_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npa_lf_ras_ena_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_RAS_ENA_W1S(void)
+{
+	return 0x238;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_w1s
+ *
+ * NPA LF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union npa_lf_ras_w1s {
+	u64 u;
+	struct npa_lf_ras_w1s_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npa_lf_ras_w1s_s cn; */
+};
+
+static inline u64 NPA_LF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_LF_RAS_W1S(void)
+{
+	return 0x228;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_af_int_cfg
+ *
+ * NPA Privileged AF Interrupt Configuration Register
+ */
+union npa_priv_af_int_cfg {
+	u64 u;
+	struct npa_priv_af_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_priv_af_int_cfg_s cn; */
+};
+
+static inline u64 NPA_PRIV_AF_INT_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_PRIV_AF_INT_CFG(void)
+{
+	return 0x10000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_lf#_cfg
+ *
+ * NPA Privileged Local Function Configuration Registers These registers
+ * allow each NPA local function (LF) to be provisioned to a VF/PF slot
+ * for RVU. See also NPA_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
+ */
+union npa_priv_lfx_cfg {
+	u64 u;
+	struct npa_priv_lfx_cfg_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_62                   : 39;
+		u64 ena                              : 1;
+	} s;
+	/* struct npa_priv_lfx_cfg_s cn; */
+};
+
+static inline u64 NPA_PRIV_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_PRIV_LFX_CFG(u64 a)
+{
+	return 0x10010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_lf#_int_cfg
+ *
+ * NPA Privileged LF Interrupt Configuration Registers
+ */
+union npa_priv_lfx_int_cfg {
+	u64 u;
+	struct npa_priv_lfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npa_priv_lfx_int_cfg_s cn; */
+};
+
+static inline u64 NPA_PRIV_LFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPA_PRIV_LFX_INT_CFG(u64 a)
+{
+	return 0x10020 + 0x100 * a;
+}
+
+#endif /* __CSRS_NPA_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
new file mode 100644
index 0000000000..6fe5bfa8b0
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
@@ -0,0 +1,1936 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NPC_H__
+#define __CSRS_NPC_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * NPC.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration npc_errlev_e
+ *
+ * NPC Error Level Enumeration Enumerates the lowest protocol layer
+ * containing an error.
+ */
+#define NPC_ERRLEV_E_LA (1)
+#define NPC_ERRLEV_E_LB (2)
+#define NPC_ERRLEV_E_LC (3)
+#define NPC_ERRLEV_E_LD (4)
+#define NPC_ERRLEV_E_LE (5)
+#define NPC_ERRLEV_E_LF (6)
+#define NPC_ERRLEV_E_LG (7)
+#define NPC_ERRLEV_E_LH (8)
+#define NPC_ERRLEV_E_NIX (0xf)
+#define NPC_ERRLEV_E_RX(a) (0 + (a))
+#define NPC_ERRLEV_E_RE (0)
+
+/**
+ * Enumeration npc_intf_e
+ *
+ * NPC Interface Enumeration Enumerates the NPC interfaces.
+ */
+#define NPC_INTF_E_NIXX_RX(a) (0 + 2 * (a))
+#define NPC_INTF_E_NIXX_TX(a) (1 + 2 * (a))
+
+/**
+ * Enumeration npc_lid_e
+ *
+ * NPC Layer ID Enumeration Enumerates layers parsed by NPC.
+ */
+#define NPC_LID_E_LA (0)
+#define NPC_LID_E_LB (1)
+#define NPC_LID_E_LC (2)
+#define NPC_LID_E_LD (3)
+#define NPC_LID_E_LE (4)
+#define NPC_LID_E_LF (5)
+#define NPC_LID_E_LG (6)
+#define NPC_LID_E_LH (7)
+
+/**
+ * Enumeration npc_lkupop_e
+ *
+ * NPC Lookup Operation Enumeration Enumerates the lookup operation for
+ * NPC_AF_LKUP_CTL[OP].
+ */
+#define NPC_LKUPOP_E_KEY (1)
+#define NPC_LKUPOP_E_PKT (0)
+
+/**
+ * Enumeration npc_mcamkeyw_e
+ *
+ * NPC MCAM Search Key Width Enumeration
+ */
+#define NPC_MCAMKEYW_E_X1 (0)
+#define NPC_MCAMKEYW_E_X2 (1)
+#define NPC_MCAMKEYW_E_X4 (2)
+
+/**
+ * Structure npc_layer_info_s
+ *
+ * NPC Layer Parse Information Structure This structure specifies the
+ * format of NPC_RESULT_S[LA,LB,...,LH].
+ */
+union npc_layer_info_s {
+	u32 u;
+	struct npc_layer_info_s_s {
+		u32 lptr                             : 8;
+		u32 flags                            : 8;
+		u32 ltype                            : 4;
+		u32 reserved_20_31                   : 12;
+	} s;
+	/* struct npc_layer_info_s_s cn; */
+};
+
+/**
+ * Structure npc_layer_kex_s
+ *
+ * NPC Layer MCAM Search Key Extract Structure This structure specifies
+ * the format of each of the NPC_PARSE_KEX_S[LA,LB,...,LH] fields. It
+ * contains the subset of NPC_LAYER_INFO_S fields that can be included in
+ * the MCAM search key. See NPC_PARSE_KEX_S and NPC_AF_INTF()_KEX_CFG.
+ */
+union npc_layer_kex_s {
+	u32 u;
+	struct npc_layer_kex_s_s {
+		u32 flags                            : 8;
+		u32 ltype                            : 4;
+		u32 reserved_12_31                   : 20;
+	} s;
+	/* struct npc_layer_kex_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x1_s
+ *
+ * NPC MCAM Search Key X1 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1.
+ */
+union npc_mcam_key_x1_s {
+	u64 u[3];
+	struct npc_mcam_key_x1_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 48;
+		u64 reserved_176_191                 : 16;
+	} s;
+	/* struct npc_mcam_key_x1_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x2_s
+ *
+ * NPC MCAM Search Key X2 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2.
+ */
+union npc_mcam_key_x2_s {
+	u64 u[5];
+	struct npc_mcam_key_x2_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 64;
+		u64 kw2                              : 64;
+		u64 kw3                              : 32;
+		u64 reserved_288_319                 : 32;
+	} s;
+	/* struct npc_mcam_key_x2_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x4_s
+ *
+ * NPC MCAM Search Key X4 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4.
+ */
+union npc_mcam_key_x4_s {
+	u64 u[8];
+	struct npc_mcam_key_x4_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 64;
+		u64 kw2                              : 64;
+		u64 kw3                              : 64;
+		u64 kw4                              : 64;
+		u64 kw5                              : 64;
+		u64 kw6                              : 64;
+	} s;
+	/* struct npc_mcam_key_x4_s_s cn; */
+};
+
+/**
+ * Structure npc_parse_kex_s
+ *
+ * NPC Parse Key Extract Structure This structure contains the subset of
+ * NPC_RESULT_S fields that can be included in the MCAM search key. See
+ * NPC_AF_INTF()_KEX_CFG.
+ */
+union npc_parse_kex_s {
+	u64 u[2];
+	struct npc_parse_kex_s_s {
+		u64 chan                             : 12;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 la                               : 12;
+		u64 lb                               : 12;
+		u64 lc                               : 12;
+		u64 ld                               : 12;
+		u64 le                               : 12;
+		u64 lf                               : 12;
+		u64 lg                               : 12;
+		u64 lh                               : 12;
+		u64 reserved_124_127                 : 4;
+	} s;
+	/* struct npc_parse_kex_s_s cn; */
+};
+
+/**
+ * Structure npc_result_s
+ *
+ * NPC Result Structure This structure contains a packet's parse and flow
+ * identification information.
+ */
+union npc_result_s {
+	u64 u[6];
+	struct npc_result_s_s {
+		u64 intf                             : 2;
+		u64 pkind                            : 6;
+		u64 chan                             : 12;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 eoh_ptr                          : 8;
+		u64 reserved_44_63                   : 20;
+		u64 action                           : 64;
+		u64 vtag_action                      : 64;
+		u64 la                               : 20;
+		u64 lb                               : 20;
+		u64 lc                               : 20;
+		u64 reserved_252_255                 : 4;
+		u64 ld                               : 20;
+		u64 le                               : 20;
+		u64 lf                               : 20;
+		u64 reserved_316_319                 : 4;
+		u64 lg                               : 20;
+		u64 lh                               : 20;
+		u64 reserved_360_383                 : 24;
+	} s;
+	/* struct npc_result_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_active_pc
+ *
+ * NPC Interrupt-Timer Configuration Register
+ */
+union npc_af_active_pc {
+	u64 u;
+	struct npc_af_active_pc_s {
+		u64 active_pc                        : 64;
+	} s;
+	/* struct npc_af_active_pc_s cn; */
+};
+
+static inline u64 NPC_AF_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_ACTIVE_PC(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_blk_rst
+ *
+ * NPC AF Block Reset Register
+ */
+union npc_af_blk_rst {
+	u64 u;
+	struct npc_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct npc_af_blk_rst_s cn; */
+};
+
+static inline u64 NPC_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_BLK_RST(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_cfg
+ *
+ * NPC AF General Configuration Register
+ */
+union npc_af_cfg {
+	u64 u;
+	struct npc_af_cfg_s {
+		u64 reserved_0_1                     : 2;
+		u64 cclk_force                       : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npc_af_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CFG(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const
+ *
+ * NPC AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const {
+	u64 u;
+	struct npc_af_const_s {
+		u64 intfs                            : 4;
+		u64 lids                             : 4;
+		u64 kpus                             : 5;
+		u64 reserved_13_15                   : 3;
+		u64 mcam_bank_width                  : 10;
+		u64 reserved_26_27                   : 2;
+		u64 mcam_bank_depth                  : 16;
+		u64 mcam_banks                       : 4;
+		u64 match_stats                      : 16;
+	} s;
+	/* struct npc_af_const_s cn; */
+};
+
+static inline u64 NPC_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const1
+ *
+ * NPC AF Constants 1 Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const1 {
+	u64 u;
+	struct npc_af_const1_s {
+		u64 kpu_entries                      : 12;
+		u64 pkinds                           : 8;
+		u64 cpi_size                         : 16;
+		u64 reserved_36_62                   : 27;
+		u64 have_const2                      : 1;
+	} s;
+	struct npc_af_const1_cn96xx {
+		u64 kpu_entries                      : 12;
+		u64 pkinds                           : 8;
+		u64 cpi_size                         : 16;
+		u64 reserved_36_63                   : 28;
+	} cn96xx;
+	/* struct npc_af_const1_s cn98xx; */
+	/* struct npc_af_const1_cn96xx cnf95xx; */
+	/* struct npc_af_const1_cn96xx loki; */
+};
+
+static inline u64 NPC_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST1(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const2
+ *
+ * NPC AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const2 {
+	u64 u;
+	struct npc_af_const2_s {
+		u64 mcam_bank_depth_ext              : 16;
+		u64 match_stats_ext                  : 16;
+		u64 reserved_32_62                   : 31;
+		u64 have_const3                      : 1;
+	} s;
+	/* struct npc_af_const2_s cn; */
+};
+
+static inline u64 NPC_AF_CONST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST2(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const3
+ *
+ * NPC AF Constants 3 Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const3 {
+	u64 u;
+	struct npc_af_const3_s {
+		u64 reserved_0_63                    : 64;
+	} s;
+	/* struct npc_af_const3_s cn; */
+};
+
+static inline u64 NPC_AF_CONST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST3(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_cpi#_cfg
+ *
+ * NPC AF Channel Parse Index Table Registers
+ */
+union npc_af_cpix_cfg {
+	u64 u;
+	struct npc_af_cpix_cfg_s {
+		u64 padd                             : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct npc_af_cpix_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_CPIX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CPIX_CFG(u64 a)
+{
+	return 0x200000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_ctl
+ *
+ * NPC AF Debug Control Register This register controls the capture of
+ * debug information in NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG,
+ * NPC_AF_DBG_DATA() and NPC_AF_DBG_RESULT().
+ */
+union npc_af_dbg_ctl {
+	u64 u;
+	struct npc_af_dbg_ctl_s {
+		u64 continuous                       : 1;
+		u64 lkup_dbg                         : 1;
+		u64 intf_dbg                         : 4;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct npc_af_dbg_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_DBG_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_DBG_CTL(void)
+{
+	return 0x3000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_data#
+ *
+ * NPC AF Debug Data Registers These registers contain the packet header
+ * data of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union npc_af_dbg_datax {
+	u64 u;
+	struct npc_af_dbg_datax_s {
+		u64 data                             : 64;
+	} s;
+	/* struct npc_af_dbg_datax_s cn; */
+};
+
+static inline u64 NPC_AF_DBG_DATAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_DBG_DATAX(u64 a)
+{
+	return 0x3001400 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_result#
+ *
+ * NPC AF Debug Result Registers These registers contain the result data
+ * of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union npc_af_dbg_resultx {
+	u64 u;
+	struct npc_af_dbg_resultx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct npc_af_dbg_resultx_s cn; */
+};
+
+static inline u64 NPC_AF_DBG_RESULTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_DBG_RESULTX(u64 a)
+{
+	return 0x3001800 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_status
+ *
+ * NPC AF Debug Status Register
+ */
+union npc_af_dbg_status {
+	u64 u;
+	struct npc_af_dbg_status_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_dbg_status_s cn; */
+};
+
+static inline u64 NPC_AF_DBG_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_DBG_STATUS(void)
+{
+	return 0x3000010;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dv_fc_scratch
+ *
+ * INTERNAL: NPC AF Scratch Register  Internal: This register is for
+ * internal DV purpose.
+ */
+union npc_af_dv_fc_scratch {
+	u64 u;
+	struct npc_af_dv_fc_scratch_s {
+		u64 it                               : 64;
+	} s;
+	/* struct npc_af_dv_fc_scratch_s cn; */
+};
+
+static inline u64 NPC_AF_DV_FC_SCRATCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_DV_FC_SCRATCH(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_eco0
+ *
+ * INTERNAL: ECO 0 Register
+ */
+union npc_af_eco0 {
+	u64 u;
+	struct npc_af_eco0_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct npc_af_eco0_s cn; */
+};
+
+static inline u64 NPC_AF_ECO0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_ECO0(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_ikpu_err_ctl
+ *
+ * NPC AF Initial KPU Error Control Registers Similar to
+ * NPC_AF_KPU()_ERR_CTL, but specifies values captured in
+ * NPC_RESULT_S[ERRLEV,ERRCODE] for errors detected by the PKIND-based
+ * initial actions from NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1. [DP_OFFSET_ERRCODE] from this register is
+ * never used.
+ */
+union npc_af_ikpu_err_ctl {
+	u64 u;
+	struct npc_af_ikpu_err_ctl_s {
+		u64 errlev                           : 4;
+		u64 dp_offset_errcode                : 8;
+		u64 ptr_advance_errcode              : 8;
+		u64 var_len_offset_errcode           : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct npc_af_ikpu_err_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_IKPU_ERR_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_IKPU_ERR_CTL(void)
+{
+	return 0x3000080;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_kex_cfg
+ *
+ * NPC AF Interface Key Extract Configuration Registers
+ */
+union npc_af_intfx_kex_cfg {
+	u64 u;
+	struct npc_af_intfx_kex_cfg_s {
+		u64 parse_nibble_ena                 : 31;
+		u64 reserved_31                      : 1;
+		u64 keyw                             : 3;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct npc_af_intfx_kex_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_KEX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_KEX_CFG(u64 a)
+{
+	return 0x1010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_ldata#_flags#_cfg
+ *
+ * NPC AF Interface Layer Data Flags Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface based on the FLAGS\<3:0\> bits of two
+ * layers selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
+ */
+union npc_af_intfx_ldatax_flagsx_cfg {
+	u64 u;
+	struct npc_af_intfx_ldatax_flagsx_cfg_s {
+		u64 key_offset                       : 6;
+		u64 reserved_6                       : 1;
+		u64 ena                              : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npc_af_intfx_ldatax_flagsx_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+{
+	return 0x980000 + 0x10000 * a + 0x1000 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_lid#_lt#_ld#_cfg
+ *
+ * NPC AF Interface Layer Data Extract Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface. Up to two LDATA fields can be extracted
+ * per layer (LID(0..7) indexed by NPC_LID_E), with up to 16 bytes per
+ * LDATA field. For each layer, the corresponding NPC_LAYER_INFO_S[LTYPE]
+ * value in NPC_RESULT_S is used as the LTYPE(0..15) index and select the
+ * associated LDATA(0..1) registers.  NPC_LAYER_INFO_S[LTYPE]=0x0 means
+ * the corresponding layer not parsed (invalid), so software should keep
+ * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction
+ * when LTYPE is zero.
+ */
+union npc_af_intfx_lidx_ltx_ldx_cfg {
+	u64 u;
+	struct npc_af_intfx_lidx_ltx_ldx_cfg_s {
+		u64 key_offset                       : 6;
+		u64 flags_ena                        : 1;
+		u64 ena                              : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npc_af_intfx_lidx_ltx_ldx_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+{
+	return 0x900000 + 0x10000 * a + 0x1000 * b + 0x20 * c + 8 * d;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_act
+ *
+ * NPC AF Interface MCAM Miss Action Data Registers When a combination of
+ * NPC_AF_MCAME()_BANK()_CAM()_* and NPC_AF_MCAME()_BANK()_CFG[ENA]
+ * yields an MCAM miss for a packet, this register specifies the packet's
+ * match action captured in NPC_RESULT_S[ACTION].
+ */
+union npc_af_intfx_miss_act {
+	u64 u;
+	struct npc_af_intfx_miss_act_s {
+		u64 action                           : 64;
+	} s;
+	/* struct npc_af_intfx_miss_act_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_MISS_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_MISS_ACT(u64 a)
+{
+	return 0x1a00000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_stat_act
+ *
+ * NPC AF Interface MCAM Miss Stat Action Data Registers Used to
+ * optionally increment a NPC_AF_MATCH_STAT() counter when a packet
+ * misses an MCAM entry.
+ */
+union npc_af_intfx_miss_stat_act {
+	u64 u;
+	struct npc_af_intfx_miss_stat_act_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
+	} s;
+	struct npc_af_intfx_miss_stat_act_cn96xx {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} cn96xx;
+	/* struct npc_af_intfx_miss_stat_act_s cn98xx; */
+	/* struct npc_af_intfx_miss_stat_act_cn96xx cnf95xx; */
+	/* struct npc_af_intfx_miss_stat_act_cn96xx loki; */
+};
+
+static inline u64 NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+{
+	return 0x1880040 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_tag_act
+ *
+ * NPC AF Interface MCAM Miss VTag Action Data Registers When a
+ * combination of NPC_AF_MCAME()_BANK()_CAM()_* and
+ * NPC_AF_MCAME()_BANK()_CFG[ENA] yields an MCAM miss for a packet, this
+ * register specifies the packet's match Vtag action captured in
+ * NPC_RESULT_S[VTAG_ACTION].
+ */
+union npc_af_intfx_miss_tag_act {
+	u64 u;
+	struct npc_af_intfx_miss_tag_act_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct npc_af_intfx_miss_tag_act_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+{
+	return 0x1b00008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_stat
+ *
+ * NPC AF Interface Statistics Registers Statistics per interface. Index
+ * enumerated by NPC_INTF_E.
+ */
+union npc_af_intfx_stat {
+	u64 u;
+	struct npc_af_intfx_stat_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_intfx_stat_s cn; */
+};
+
+static inline u64 NPC_AF_INTFX_STAT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_INTFX_STAT(u64 a)
+{
+	return 0x2000800 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kcam_scrub_ctl
+ *
+ * NPC AF KCAM Scrub Control Register
+ */
+union npc_af_kcam_scrub_ctl {
+	u64 u;
+	struct npc_af_kcam_scrub_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_7                     : 7;
+		u64 lp_dis                           : 1;
+		u64 reserved_9_15                    : 7;
+		u64 toth                             : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npc_af_kcam_scrub_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_KCAM_SCRUB_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KCAM_SCRUB_CTL(void)
+{
+	return 0xb0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kex_ldata#_flags_cfg
+ *
+ * NPC AF Key Extract Layer Data Flags Configuration Register
+ */
+union npc_af_kex_ldatax_flags_cfg {
+	u64 u;
+	struct npc_af_kex_ldatax_flags_cfg_s {
+		u64 lid                              : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct npc_af_kex_ldatax_flags_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_cfg
+ *
+ * NPC AF KPU Configuration Registers
+ */
+union npc_af_kpux_cfg {
+	u64 u;
+	struct npc_af_kpux_cfg_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_kpux_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_CFG(u64 a)
+{
+	return 0x500 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_dbg
+ *
+ * NPC AF KPU Debug Registers This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG]. The register contents are undefined
+ * when debug information is captured for a software key lookup
+ * (NPC_AF_LKUP_CTL[OP] = NPC_LKUPOP_E::KEY).
+ */
+union npc_af_kpux_dbg {
+	u64 u;
+	struct npc_af_kpux_dbg_s {
+		u64 hit_entry                        : 8;
+		u64 byp                              : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct npc_af_kpux_dbg_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_DBG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_DBG(u64 a)
+{
+	return 0x3000020 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action0
+ *
+ * NPC AF KPU Entry Action Data 0 Registers When a KPU's search data
+ * matches a KPU CAM entry in NPC_AF_KPU()_ENTRY()_CAM(), the
+ * corresponding entry action in NPC_AF_KPU()_ENTRY()_ACTION0 and
+ * NPC_AF_KPU()_ENTRY()_ACTION1 specifies the next state and operations
+ * to perform before exiting the KPU.
+ */
+union npc_af_kpux_entryx_action0 {
+	u64 u;
+	struct npc_af_kpux_entryx_action0_s {
+		u64 var_len_shift                    : 3;
+		u64 var_len_right                    : 1;
+		u64 var_len_mask                     : 8;
+		u64 var_len_offset                   : 8;
+		u64 ptr_advance                      : 8;
+		u64 capture_flags                    : 8;
+		u64 capture_ltype                    : 4;
+		u64 capture_lid                      : 3;
+		u64 reserved_43                      : 1;
+		u64 next_state                       : 8;
+		u64 parse_done                       : 1;
+		u64 capture_ena                      : 1;
+		u64 byp_count                        : 3;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct npc_af_kpux_entryx_action0_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+{
+	return 0x100020 + 0x4000 * a + 0x40 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action1
+ *
+ * NPC AF KPU Entry Action Data 0 Registers See
+ * NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union npc_af_kpux_entryx_action1 {
+	u64 u;
+	struct npc_af_kpux_entryx_action1_s {
+		u64 dp0_offset                       : 8;
+		u64 dp1_offset                       : 8;
+		u64 dp2_offset                       : 8;
+		u64 errcode                          : 8;
+		u64 errlev                           : 4;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct npc_af_kpux_entryx_action1_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+{
+	return 0x100028 + 0x4000 * a + 0x40 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_cam#
+ *
+ * NPC AF KPU Entry CAM Registers KPU comparison ternary data. The field
+ * values in NPC_AF_KPU()_ENTRY()_CAM() are ternary, where  each data bit
+ * of the search key matches as follows: _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=0: Always match; search key data\<n\> don't care. _
+ * [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=1: Match when search key data\<n\> ==
+ * 0. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\>
+ * == 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * The reset value for all non-reserved fields is all zeros for CAM(1)
+ * and all ones for CAM(0), matching a search key of all zeros.  Software
+ * must program a default entry for each KPU, e.g. by programming each
+ * KPU's last entry {b} (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match
+ * all bits.
+ */
+union npc_af_kpux_entryx_camx {
+	u64 u;
+	struct npc_af_kpux_entryx_camx_s {
+		u64 dp0_data                         : 16;
+		u64 dp1_data                         : 16;
+		u64 dp2_data                         : 16;
+		u64 state                            : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct npc_af_kpux_entryx_camx_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+{
+	return 0x100000 + 0x4000 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry_dis#
+ *
+ * NPC AF KPU Entry Disable Registers See NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union npc_af_kpux_entry_disx {
+	u64 u;
+	struct npc_af_kpux_entry_disx_s {
+		u64 dis                              : 64;
+	} s;
+	/* struct npc_af_kpux_entry_disx_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+{
+	return 0x180000 + 0x40 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_err_ctl
+ *
+ * NPC AF KPU Error Control Registers This register specifies values
+ * captured in NPC_RESULT_S[ERRLEV,ERRCODE] when errors are detected by a
+ * KPU.
+ */
+union npc_af_kpux_err_ctl {
+	u64 u;
+	struct npc_af_kpux_err_ctl_s {
+		u64 errlev                           : 4;
+		u64 dp_offset_errcode                : 8;
+		u64 ptr_advance_errcode              : 8;
+		u64 var_len_offset_errcode           : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct npc_af_kpux_err_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_KPUX_ERR_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPUX_ERR_CTL(u64 a)
+{
+	return 0x30000a0 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu_diag
+ *
+ * INTERNAL : NPC AF Debug Result Registers
+ */
+union npc_af_kpu_diag {
+	u64 u;
+	struct npc_af_kpu_diag_s {
+		u64 skip_dis                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_kpu_diag_s cn; */
+};
+
+static inline u64 NPC_AF_KPU_DIAG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPU_DIAG(void)
+{
+	return 0x3002000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_ctl
+ *
+ * NPC AF Software Lookup Control Registers
+ */
+union npc_af_lkup_ctl {
+	u64 u;
+	struct npc_af_lkup_ctl_s {
+		u64 intf                             : 2;
+		u64 pkind                            : 6;
+		u64 chan                             : 12;
+		u64 hdr_sizem1                       : 8;
+		u64 op                               : 3;
+		u64 exec                             : 1;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct npc_af_lkup_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_LKUP_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_LKUP_CTL(void)
+{
+	return 0x2000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_data#
+ *
+ * NPC AF Software Lookup Data Registers
+ */
+union npc_af_lkup_datax {
+	u64 u;
+	struct npc_af_lkup_datax_s {
+		u64 data                             : 64;
+	} s;
+	/* struct npc_af_lkup_datax_s cn; */
+};
+
+static inline u64 NPC_AF_LKUP_DATAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_LKUP_DATAX(u64 a)
+{
+	return 0x2000200 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_result#
+ *
+ * NPC AF Software Lookup Result Registers
+ */
+union npc_af_lkup_resultx {
+	u64 u;
+	struct npc_af_lkup_resultx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct npc_af_lkup_resultx_s cn; */
+};
+
+static inline u64 NPC_AF_LKUP_RESULTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_LKUP_RESULTX(u64 a)
+{
+	return 0x2000400 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_match_stat#
+ *
+ * NPC AF Match Statistics Registers
+ */
+union npc_af_match_statx {
+	u64 u;
+	struct npc_af_match_statx_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_match_statx_s cn; */
+};
+
+static inline u64 NPC_AF_MATCH_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MATCH_STATX(u64 a)
+{
+	return 0x1880008 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_match_stat#_ext
+ *
+ * NPC AF Match Statistics Registers
+ */
+union npc_af_match_statx_ext {
+	u64 u;
+	struct npc_af_match_statx_ext_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_match_statx_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MATCH_STATX_EXT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MATCH_STATX_EXT(u64 a)
+{
+	return 0x8000078 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_bank#_hit#
+ *
+ * NPC AF MCAM Bank Hit Registers
+ */
+union npc_af_mcam_bankx_hitx {
+	u64 u;
+	struct npc_af_mcam_bankx_hitx_s {
+		u64 hit                              : 64;
+	} s;
+	/* struct npc_af_mcam_bankx_hitx_s cn; */
+};
+
+static inline u64 NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+{
+	return 0x1c80000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_bank#_hit#_ext
+ *
+ * NPC AF MCAM Bank Hit Registers
+ */
+union npc_af_mcam_bankx_hitx_ext {
+	u64 u;
+	struct npc_af_mcam_bankx_hitx_ext_s {
+		u64 hit                              : 64;
+	} s;
+	/* struct npc_af_mcam_bankx_hitx_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAM_BANKX_HITX_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAM_BANKX_HITX_EXT(u64 a, u64 b)
+{
+	return 0x8000070 + 0x1000000 * a + 0x100 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_dbg
+ *
+ * NPC AF MCAM Debug Register This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union npc_af_mcam_dbg {
+	u64 u;
+	struct npc_af_mcam_dbg_s {
+		u64 hit_entry                        : 10;
+		u64 reserved_10_11                   : 2;
+		u64 hit_bank                         : 2;
+		u64 reserved_14_15                   : 2;
+		u64 miss                             : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct npc_af_mcam_dbg_s cn; */
+};
+
+static inline u64 NPC_AF_MCAM_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAM_DBG(void)
+{
+	return 0x3001000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_scrub_ctl
+ *
+ * NPC AF MCAM Scrub Control Register
+ */
+union npc_af_mcam_scrub_ctl {
+	u64 u;
+	struct npc_af_mcam_scrub_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_7                     : 7;
+		u64 lp_dis                           : 1;
+		u64 reserved_9_15                    : 7;
+		u64 toth                             : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct npc_af_mcam_scrub_ctl_s cn; */
+};
+
+static inline u64 NPC_AF_MCAM_SCRUB_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAM_SCRUB_CTL(void)
+{
+	return 0xa0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_action
+ *
+ * NPC AF MCAM Entry Bank Action Data Registers Specifies a packet's
+ * match action captured in NPC_RESULT_S[ACTION].  When an interface is
+ * configured to use the NPC_MCAM_KEY_X2_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used.  When
+ * an interface is configured to use the NPC_MCAM_KEY_X4_S search key
+ * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4): *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
+ */
+union npc_af_mcamex_bankx_action {
+	u64 u;
+	struct npc_af_mcamex_bankx_action_s {
+		u64 action                           : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_action_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+{
+	return 0x1900000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_action_ext
+ *
+ * NPC AF MCAM Entry Bank Action Data Registers
+ */
+union npc_af_mcamex_bankx_action_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_action_ext_s {
+		u64 action                           : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_action_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION_EXT(u64 a, u64 b)
+{
+	return 0x8000040 + 0x100 * a + 0x1000000 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf
+ *
+ * NPC AF MCAM Entry Bank CAM Data Interface Registers MCAM comparison
+ * ternary data interface word. The field values in
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where  each data bit of
+ * the search key matches as follows: _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=0:
+ * Always match; search key data\<n\> don't care. _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=1: Match when search key data\<n\> == 0. _
+ * [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\> ==
+ * 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * The reset value for all non-reserved fields in
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 is all zeros for CAM(1) and all ones
+ * for CAM(0), matching a search key of all zeros.  When an interface is
+ * configured to use the NPC_MCAM_KEY_X1_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the four banks of
+ * every MCAM entry are used as individual entries, each of which is
+ * independently compared with the search key as follows: _
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X1_S[INTF]. _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X1_S[KW0]. _
+ * NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X1_S[KW1].  When an interface is configured to use the
+ * NPC_MCAM_KEY_X2_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
+ * NPC_MCAMKEYW_E::X2), banks 0-1 of every MCAM entry are used as one
+ * double-wide entry, banks 2-3 as a second double-wide entry, and each
+ * double-wide entry is independently compared with the search key as
+ * follows: _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X2_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW3]\<31:0\>.  When an interface is configured to
+ * use the NPC_MCAM_KEY_X4_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4), the four banks of
+ * every MCAM entry are used as a single quad-wide entry that is compared
+ * with the search key as follows: _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X4_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<15:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW3]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<31:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW3]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<63:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<31:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<47:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW5]\<15:0\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<47:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW5]\<63:16\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<63:48\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW6]\<15:0\>. _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW6]\<63:16\>.  Note that for the X2
+ * and X4 formats, a wide entry will not match unless the INTF fields
+ * from the associated two or four banks match the INTF value from the
+ * search key.  For the X1 and X2 formats, a match in a lower-numbered
+ * bank takes priority over a match in any higher numbered banks. Within
+ * each bank, the lowest numbered matching entry takes priority over any
+ * higher numbered entry.
+ */
+union npc_af_mcamex_bankx_camx_intf {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_intf_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_intf_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+{
+	return 0x1000000 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf_ext
+ *
+ * NPC AF Extended MCAM Entry Bank CAM Data Interface Registers
+ */
+union npc_af_mcamex_bankx_camx_intf_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_intf_ext_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_intf_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000000 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0
+ *
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers MCAM comparison
+ * ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union npc_af_mcamex_bankx_camx_w0 {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w0_s {
+		u64 md                               : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w0_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+{
+	return 0x1000010 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0_ext
+ *
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers
+ */
+union npc_af_mcamex_bankx_camx_w0_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w0_ext_s {
+		u64 md                               : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w0_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000010 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1
+ *
+ * NPC AF MCAM Entry Bank Data Word 1 Registers MCAM comparison ternary
+ * data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union npc_af_mcamex_bankx_camx_w1 {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w1_s {
+		u64 md                               : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w1_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+{
+	return 0x1000020 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1_ext
+ *
+ * NPC AF MCAM Entry Bank Data Word 1 Registers
+ */
+union npc_af_mcamex_bankx_camx_w1_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w1_ext_s {
+		u64 md                               : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w1_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000020 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cfg
+ *
+ * NPC AF MCAM Entry Bank Configuration Registers
+ */
+union npc_af_mcamex_bankx_cfg {
+	u64 u;
+	struct npc_af_mcamex_bankx_cfg_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_mcamex_bankx_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+{
+	return 0x1800000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cfg_ext
+ *
+ * NPC AF MCAM Entry Bank Configuration Registers
+ */
+union npc_af_mcamex_bankx_cfg_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_cfg_ext_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_mcamex_bankx_cfg_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG_EXT(u64 a, u64 b)
+{
+	return 0x8000038 + 0x100 * a + 0x1000000 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act
+ *
+ * NPC AF MCAM Entry Bank Statistics Action Registers Used to optionally
+ * increment a NPC_AF_MATCH_STAT() counter when a packet matches an MCAM
+ * entry. See also NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union npc_af_mcamex_bankx_stat_act {
+	u64 u;
+	struct npc_af_mcamex_bankx_stat_act_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
+	} s;
+	struct npc_af_mcamex_bankx_stat_act_cn96xx {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} cn96xx;
+	/* struct npc_af_mcamex_bankx_stat_act_s cn98xx; */
+	/* struct npc_af_mcamex_bankx_stat_act_cn96xx cnf95xx; */
+	/* struct npc_af_mcamex_bankx_stat_act_cn96xx loki; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+{
+	return 0x1880000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act_ext
+ *
+ * NPC AF MCAM Entry Bank Statistics Action Registers
+ */
+union npc_af_mcamex_bankx_stat_act_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_stat_act_ext_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npc_af_mcamex_bankx_stat_act_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT_EXT(u64 a, u64 b)
+{
+	return 0x8000050 + 0x100 * a + 0x1000000 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act
+ *
+ * NPC AF MCAM Entry Bank VTag Action Data Registers Specifies a packet's
+ * match Vtag action captured in NPC_RESULT_S[VTAG_ACTION]. See also
+ * NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union npc_af_mcamex_bankx_tag_act {
+	u64 u;
+	struct npc_af_mcamex_bankx_tag_act_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_tag_act_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+{
+	return 0x1900008 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act_ext
+ *
+ * NPC AF MCAM Entry Bank VTag Action Data Registers
+ */
+union npc_af_mcamex_bankx_tag_act_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_tag_act_ext_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_tag_act_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT_EXT(u64 a, u64 b)
+{
+	return 0x8000048 + 0x100 * a + 0x1000000 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_nife_bp_test
+ *
+ * INTERNAL: NPC AF NIFE Backpressure Test Register
+ */
+union npc_af_nife_bp_test {
+	u64 u;
+	struct npc_af_nife_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct npc_af_nife_bp_test_s cn; */
+};
+
+static inline u64 NPC_AF_NIFE_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_NIFE_BP_TEST(void)
+{
+	return 0x3003008;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_nifi_bp_test
+ *
+ * INTERNAL: NPC AF NIFI Backpressure Test Register
+ */
+union npc_af_nifi_bp_test {
+	u64 u;
+	struct npc_af_nifi_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct npc_af_nifi_bp_test_s cn; */
+};
+
+static inline u64 NPC_AF_NIFI_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_NIFI_BP_TEST(void)
+{
+	return 0x3003000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_cfg
+ *
+ * NPC AF Protocol Check Configuration Register
+ */
+union npc_af_pck_cfg {
+	u64 u;
+	struct npc_af_pck_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 iip4_cksum                       : 1;
+		u64 oip4_cksum                       : 1;
+		u64 reserved_3                       : 1;
+		u64 l3b                              : 1;
+		u64 l3m                              : 1;
+		u64 l2b                              : 1;
+		u64 l2m                              : 1;
+		u64 reserved_8_23                    : 16;
+		u64 iip4_cksum_errcode               : 8;
+		u64 oip4_cksum_errcode               : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct npc_af_pck_cfg_s cn; */
+};
+
+static inline u64 NPC_AF_PCK_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PCK_CFG(void)
+{
+	return 0x600;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_iip4
+ *
+ * NPC AF Protocol Check Inner IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an inner IPv4
+ * header.
+ */
+union npc_af_pck_def_iip4 {
+	u64 u;
+	struct npc_af_pck_def_iip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct npc_af_pck_def_iip4_s cn; */
+};
+
+static inline u64 NPC_AF_PCK_DEF_IIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PCK_DEF_IIP4(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_oip4
+ *
+ * NPC AF Protocol Check Outer IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv4
+ * header.
+ */
+union npc_af_pck_def_oip4 {
+	u64 u;
+	struct npc_af_pck_def_oip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct npc_af_pck_def_oip4_s cn; */
+};
+
+static inline u64 NPC_AF_PCK_DEF_OIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PCK_DEF_OIP4(void)
+{
+	return 0x620;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_oip6
+ *
+ * NPC AF Protocol Check Outer IPv6 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv6
+ * header. [LID] must have the same value as NPC_AF_PCK_DEF_OIP4[LID].
+ */
+union npc_af_pck_def_oip6 {
+	u64 u;
+	struct npc_af_pck_def_oip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct npc_af_pck_def_oip6_s cn; */
+};
+
+static inline u64 NPC_AF_PCK_DEF_OIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PCK_DEF_OIP6(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_ol2
+ *
+ * NPC AF Protocol Check Outer L2 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer L2
+ * header.
+ */
+union npc_af_pck_def_ol2 {
+	u64 u;
+	struct npc_af_pck_def_ol2_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct npc_af_pck_def_ol2_s cn; */
+};
+
+static inline u64 NPC_AF_PCK_DEF_OL2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PCK_DEF_OL2(void)
+{
+	return 0x610;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_action0
+ *
+ * NPC AF Port Kind Action Data 0 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
+ */
+union npc_af_pkindx_action0 {
+	u64 u;
+	struct npc_af_pkindx_action0_s {
+		u64 var_len_shift                    : 3;
+		u64 var_len_right                    : 1;
+		u64 var_len_mask                     : 8;
+		u64 var_len_offset                   : 8;
+		u64 ptr_advance                      : 8;
+		u64 capture_flags                    : 8;
+		u64 capture_ltype                    : 4;
+		u64 capture_lid                      : 3;
+		u64 reserved_43                      : 1;
+		u64 next_state                       : 8;
+		u64 parse_done                       : 1;
+		u64 capture_ena                      : 1;
+		u64 byp_count                        : 3;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct npc_af_pkindx_action0_s cn; */
+};
+
+static inline u64 NPC_AF_PKINDX_ACTION0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PKINDX_ACTION0(u64 a)
+{
+	return 0x80000 + 0x40 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_action1
+ *
+ * NPC AF Port Kind Action Data 1 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
+ */
+union npc_af_pkindx_action1 {
+	u64 u;
+	struct npc_af_pkindx_action1_s {
+		u64 dp0_offset                       : 8;
+		u64 dp1_offset                       : 8;
+		u64 dp2_offset                       : 8;
+		u64 errcode                          : 8;
+		u64 errlev                           : 4;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct npc_af_pkindx_action1_s cn; */
+};
+
+static inline u64 NPC_AF_PKINDX_ACTION1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PKINDX_ACTION1(u64 a)
+{
+	return 0x80008 + 0x40 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_cpi_def#
+ *
+ * NPC AF Port Kind Channel Parse Index Definition Registers These
+ * registers specify the layer information and algorithm to compute a
+ * packet's channel parse index (CPI), which provides a port to channel
+ * adder for calculating NPC_RESULT_S[CHAN].  There are two CPI
+ * definitions per port kind, allowing the CPI computation to use two
+ * possible layer definitions in the parsed packet, e.g. DiffServ DSCP
+ * from either IPv4 or IPv6 header.  CPI pseudocode: \<pre\> for (i = 0;
+ * i \< 2; i++) {    cpi_def = NPC_AF_PKIND()_CPI_DEF(i);    LX = LA, LB,
+ * ..., or LH as selected by cpi_def[LID];     if (cpi_def[ENA]        &&
+ * ((cpi_def[LTYPE_MATCH] & cpi_def[LTYPE_MASK])             ==
+ * (NPC_RESULT_S[LX[LTYPE]] & cpi_def[LTYPE_MASK]))        &&
+ * ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])             ==
+ * (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))    {       // Found
+ * matching layer       nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) +
+ * cpi_def[ADD_OFFSET];       add_byte = byte at nibble_offset from start
+ * of packet;       cpi_add = (add_byte & cpi_def[ADD_MASK]) \>\>
+ * cpi_def[ADD_SHIFT];       cpi = cpi_def[CPI_BASE] + cpi_add;
+ * NPC_RESULT_S[CHAN] += NPC_AF_CPI(cpi)_CFG[PADD];       break;    } }
+ * \</pre\>
+ */
+union npc_af_pkindx_cpi_defx {
+	u64 u;
+	struct npc_af_pkindx_cpi_defx_s {
+		u64 cpi_base                         : 10;
+		u64 reserved_10_11                   : 2;
+		u64 add_shift                        : 3;
+		u64 reserved_15                      : 1;
+		u64 add_mask                         : 8;
+		u64 add_offset                       : 8;
+		u64 flags_mask                       : 8;
+		u64 flags_match                      : 8;
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_59_62                   : 4;
+		u64 ena                              : 1;
+	} s;
+	/* struct npc_af_pkindx_cpi_defx_s cn; */
+};
+
+static inline u64 NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+{
+	return 0x80020 + 0x40 * a + 8 * b;
+}
+
+#endif /* __CSRS_NPC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
new file mode 100644
index 0000000000..df64199350
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
@@ -0,0 +1,2480 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_RVU_H__
+#define __CSRS_RVU_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * RVU.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration rvu_af_int_vec_e
+ *
+ * RVU Admin Function Interrupt Vector Enumeration Enumerates the MSI-X
+ * interrupt vectors. Internal: RVU maintains the state of these vectors
+ * internally, and generates GIB messages for it without accessing the
+ * MSI-X table region in LLC/DRAM.
+ */
+#define RVU_AF_INT_VEC_E_GEN (3)
+#define RVU_AF_INT_VEC_E_MBOX (4)
+#define RVU_AF_INT_VEC_E_PFFLR (1)
+#define RVU_AF_INT_VEC_E_PFME (2)
+#define RVU_AF_INT_VEC_E_POISON (0)
+
+/**
+ * Enumeration rvu_bar_e
+ *
+ * RVU Base Address Register Enumeration Enumerates the base address
+ * registers. Internal: For documentation only.
+ */
+#define RVU_BAR_E_RVU_PFX_BAR0(a) (0x840000000000ll + 0x1000000000ll * (a))
+#define RVU_BAR_E_RVU_PFX_BAR0_SIZE 0x10000000ull
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR2(a, b)	\
+	(0x840200000000ll + 0x1000000000ll * (a) + 0x2000000ll * (b))
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR2_SIZE 0x100000ull
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR4(a, b)	\
+	(0x840400000000ll + 0x1000000000ll * (a) + 0x2000000ll * (b))
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR4_SIZE 0x10000ull
+
+/**
+ * Enumeration rvu_block_addr_e
+ *
+ * RVU Block Address Enumeration Enumerates addressing of RVU resource
+ * blocks within each RVU BAR, i.e. values of RVU_FUNC_ADDR_S[BLOCK] and
+ * RVU_AF_ADDR_S[BLOCK].  CNXXXX may not implement all enumerated blocks.
+ * Software can read RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[IMP] to discover
+ * which blocks are implemented and enabled.
+ */
+#define RVU_BLOCK_ADDR_E_CPTX(a) (0xa + (a))
+#define RVU_BLOCK_ADDR_E_LMT (1)
+#define RVU_BLOCK_ADDR_E_NDCX(a) (0xc + (a))
+#define RVU_BLOCK_ADDR_E_NIXX(a) (4 + (a))
+#define RVU_BLOCK_ADDR_E_NPA (3)
+#define RVU_BLOCK_ADDR_E_NPC (6)
+#define RVU_BLOCK_ADDR_E_RX(a) (0 + (a))
+#define RVU_BLOCK_ADDR_E_REEX(a) (0x14 + (a))
+#define RVU_BLOCK_ADDR_E_RVUM (0)
+#define RVU_BLOCK_ADDR_E_SSO (7)
+#define RVU_BLOCK_ADDR_E_SSOW (8)
+#define RVU_BLOCK_ADDR_E_TIM (9)
+
+/**
+ * Enumeration rvu_block_type_e
+ *
+ * RVU Block Type Enumeration Enumerates values of
+ * RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[BTYPE].
+ */
+#define RVU_BLOCK_TYPE_E_CPT (9)
+#define RVU_BLOCK_TYPE_E_DDF (0xb)
+#define RVU_BLOCK_TYPE_E_LMT (2)
+#define RVU_BLOCK_TYPE_E_NDC (0xa)
+#define RVU_BLOCK_TYPE_E_NIX (3)
+#define RVU_BLOCK_TYPE_E_NPA (4)
+#define RVU_BLOCK_TYPE_E_NPC (5)
+#define RVU_BLOCK_TYPE_E_RAD (0xd)
+#define RVU_BLOCK_TYPE_E_REE (0xe)
+#define RVU_BLOCK_TYPE_E_RVUM (0)
+#define RVU_BLOCK_TYPE_E_SSO (6)
+#define RVU_BLOCK_TYPE_E_SSOW (7)
+#define RVU_BLOCK_TYPE_E_TIM (8)
+#define RVU_BLOCK_TYPE_E_ZIP (0xc)
+
+/**
+ * Enumeration rvu_bus_lf_e
+ *
+ * INTERNAL: RVU Bus LF Range Enumeration  Enumerates the LF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define RVU_BUS_LF_E_RVU_BUS_LFX(a) (0 + 0x2000000 * (a))
+
+/**
+ * Enumeration rvu_bus_lf_slot_e
+ *
+ * INTERNAL: RVU Bus LF Slot Range Enumeration  Enumerates the LF and
+ * Slot range for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
+ */
+#define RVU_BUS_LF_SLOT_E_RVU_BUS_LFX_SLOTX(a, b)	\
+	(0 + 0x2000000 * (a) + 0x1000 * (b))
+
+/**
+ * Enumeration rvu_bus_pf_e
+ *
+ * INTERNAL: RVU Bus PF Range Enumeration  Enumerates the PF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define RVU_BUS_PF_E_RVU_BUS_PFX(a) (0ll + 0x1000000000ll * (a))
+
+/**
+ * Enumeration rvu_bus_pfvf_e
+ *
+ * INTERNAL: RVU Bus PFVF Range Enumeration  Enumerates the PF and VF
+ * ranges for the RVU bus. Internal: This is an enum used in csr3 virtual
+ * equations.
+ */
+#define RVU_BUS_PFVF_E_RVU_BUS_PFX(a) (0 + 0x2000000 * (a))
+#define RVU_BUS_PFVF_E_RVU_BUS_VFX(a) (0 + 0x2000000 * (a))
+
+/**
+ * Enumeration rvu_busbar_e
+ *
+ * INTERNAL: RVU Bus Base Address Region Enumeration  Enumerates the base
+ * address region for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
+ */
+#define RVU_BUSBAR_E_RVU_BUSBAR0 (0)
+#define RVU_BUSBAR_E_RVU_BUSBAR2 (0x200000000ll)
+
+/**
+ * Enumeration rvu_busdid_e
+ *
+ * INTERNAL: RVU Bus DID Enumeration  Enumerates the DID offset for the
+ * RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define RVU_BUSDID_E_RVU_BUSDID (0x840000000000ll)
+
+/**
+ * Enumeration rvu_pf_int_vec_e
+ *
+ * RVU PF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
+ */
+#define RVU_PF_INT_VEC_E_AFPF_MBOX (6)
+#define RVU_PF_INT_VEC_E_VFFLRX(a) (0 + (a))
+#define RVU_PF_INT_VEC_E_VFMEX(a) (2 + (a))
+#define RVU_PF_INT_VEC_E_VFPF_MBOXX(a) (4 + (a))
+
+/**
+ * Enumeration rvu_vf_int_vec_e
+ *
+ * RVU VF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
+ */
+#define RVU_VF_INT_VEC_E_MBOX (0)
+
+/**
+ * Structure rvu_af_addr_s
+ *
+ * RVU Admin Function Register Address Structure Address format for
+ * accessing shared Admin Function (AF) registers in RVU PF BAR0. These
+ * registers may be accessed by all RVU PFs whose
+ * RVU_PRIV_PF()_CFG[AF_ENA] bit is set.
+ */
+union rvu_af_addr_s {
+	u64 u;
+	struct rvu_af_addr_s_s {
+		u64 addr                             : 28;
+		u64 block                            : 5;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct rvu_af_addr_s_s cn; */
+};
+
+/**
+ * Structure rvu_func_addr_s
+ *
+ * RVU Function-unique Address Structure Address format for accessing
+ * function-unique registers in RVU PF/FUNC BAR2.
+ */
+union rvu_func_addr_s {
+	u32 u;
+	struct rvu_func_addr_s_s {
+		u32 addr                             : 12;
+		u32 lf_slot                          : 8;
+		u32 block                            : 5;
+		u32 reserved_25_31                   : 7;
+	} s;
+	/* struct rvu_func_addr_s_s cn; */
+};
+
+/**
+ * Structure rvu_msix_vec_s
+ *
+ * RVU MSI-X Vector Structure Format of entries in the RVU MSI-X table
+ * region in LLC/DRAM. See RVU_PRIV_PF()_MSIX_CFG.
+ */
+union rvu_msix_vec_s {
+	u64 u[2];
+	struct rvu_msix_vec_s_s {
+		u64 addr                             : 64;
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 pend                             : 1;
+		u64 reserved_98_127                  : 30;
+	} s;
+	/* struct rvu_msix_vec_s_s cn; */
+};
+
+/**
+ * Structure rvu_pf_func_s
+ *
+ * RVU PF Function Identification Structure Identifies an RVU PF/VF, and
+ * format of *_PRIV_LF()_CFG[PF_FUNC] in RVU resource blocks, e.g.
+ * NPA_PRIV_LF()_CFG[PF_FUNC].  Internal: Also used for PF/VF
+ * identification on inter-coprocessor hardware interfaces (NPA, SSO,
+ * CPT, ...).
+ */
+union rvu_pf_func_s {
+	u32 u;
+	struct rvu_pf_func_s_s {
+		u32 func                             : 10;
+		u32 pf                               : 6;
+		u32 reserved_16_31                   : 16;
+	} s;
+	/* struct rvu_pf_func_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_afpf#_mbox#
+ *
+ * RVU Admin Function AF/PF Mailbox Registers
+ */
+union rvu_af_afpfx_mboxx {
+	u64 u;
+	struct rvu_af_afpfx_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct rvu_af_afpfx_mboxx_s cn; */
+};
+
+static inline u64 RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+{
+	return 0x2000 + 0x10 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bar2_alias#
+ *
+ * INTERNAL: RVU Admin Function  BAR2 Alias Registers  These registers
+ * alias to the RVU BAR2 registers for the PF and function selected by
+ * RVU_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union rvu_af_bar2_aliasx {
+	u64 u;
+	struct rvu_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct rvu_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 RVU_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bar2_sel
+ *
+ * INTERNAL: RVU Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the RVU_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ */
+union rvu_af_bar2_sel {
+	u64 u;
+	struct rvu_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct rvu_af_bar2_sel_s cn; */
+};
+
+static inline u64 RVU_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_blk_rst
+ *
+ * RVU Master Admin Function Block Reset Register
+ */
+union rvu_af_blk_rst {
+	u64 u;
+	struct rvu_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct rvu_af_blk_rst_s cn; */
+};
+
+static inline u64 RVU_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_BLK_RST(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bp_test
+ *
+ * INTERNAL: RVUM Backpressure Test Registers
+ */
+union rvu_af_bp_test {
+	u64 u;
+	struct rvu_af_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 16;
+		u64 enable                           : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct rvu_af_bp_test_s cn; */
+};
+
+static inline u64 RVU_AF_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_BP_TEST(void)
+{
+	return 0x4000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_eco
+ *
+ * INTERNAL: RVU Admin Function ECO Register
+ */
+union rvu_af_eco {
+	u64 u;
+	struct rvu_af_eco_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct rvu_af_eco_s cn; */
+};
+
+static inline u64 RVU_AF_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_ECO(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int
+ *
+ * RVU Admin Function General Interrupt Register This register contains
+ * General interrupt summary bits.
+ */
+union rvu_af_gen_int {
+	u64 u;
+	struct rvu_af_gen_int_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	struct rvu_af_gen_int_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_s cn98xx; */
+	/* struct rvu_af_gen_int_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_GEN_INT(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1c
+ *
+ * RVU Admin Function General Interrupt Enable Clear Register This
+ * register clears interrupt enable bits.
+ */
+union rvu_af_gen_int_ena_w1c {
+	u64 u;
+	struct rvu_af_gen_int_ena_w1c_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	struct rvu_af_gen_int_ena_w1c_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_gen_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_ena_w1c_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x138;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1s
+ *
+ * RVU Admin Function General Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union rvu_af_gen_int_ena_w1s {
+	u64 u;
+	struct rvu_af_gen_int_ena_w1s_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	struct rvu_af_gen_int_ena_w1s_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_gen_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_ena_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_w1s
+ *
+ * RVU Admin Function General Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union rvu_af_gen_int_w1s {
+	u64 u;
+	struct rvu_af_gen_int_w1s_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	struct rvu_af_gen_int_w1s_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_w1s_s cn98xx; */
+	/* struct rvu_af_gen_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_GEN_INT_W1S(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_hwvf_rst
+ *
+ * RVU Admin Function Hardware VF Reset Register
+ */
+union rvu_af_hwvf_rst {
+	u64 u;
+	struct rvu_af_hwvf_rst_s {
+		u64 hwvf                             : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct rvu_af_hwvf_rst_s cn; */
+};
+
+static inline u64 RVU_AF_HWVF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_HWVF_RST(void)
+{
+	return 0x2850;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_msixtr_base
+ *
+ * RVU Admin Function MSI-X Table Region Base-Address Register
+ */
+union rvu_af_msixtr_base {
+	u64 u;
+	struct rvu_af_msixtr_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct rvu_af_msixtr_base_s cn; */
+};
+
+static inline u64 RVU_AF_MSIXTR_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_MSIXTR_BASE(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf#_vf_bar4_addr
+ *
+ * RVU Admin Function PF/VF BAR4 Address Registers
+ */
+union rvu_af_pfx_vf_bar4_addr {
+	u64 u;
+	struct rvu_af_pfx_vf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct rvu_af_pfx_vf_bar4_addr_s cn; */
+};
+
+static inline u64 RVU_AF_PFX_VF_BAR4_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFX_VF_BAR4_ADDR(u64 a)
+{
+	return 0x1000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf_bar4_addr
+ *
+ * RVU Admin Function PF BAR4 Address Registers
+ */
+union rvu_af_pf_bar4_addr {
+	u64 u;
+	struct rvu_af_pf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct rvu_af_pf_bar4_addr_s cn; */
+};
+
+static inline u64 RVU_AF_PF_BAR4_ADDR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PF_BAR4_ADDR(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf_rst
+ *
+ * RVU Admin Function PF Reset Register
+ */
+union rvu_af_pf_rst {
+	u64 u;
+	struct rvu_af_pf_rst_s {
+		u64 pf                               : 5;
+		u64 reserved_5_11                    : 7;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	struct rvu_af_pf_rst_cn96xx {
+		u64 pf                               : 4;
+		u64 reserved_4_11                    : 8;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} cn96xx;
+	/* struct rvu_af_pf_rst_s cn98xx; */
+	/* struct rvu_af_pf_rst_cn96xx cnf95xx; */
+	/* struct rvu_af_pf_rst_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PF_RST(void)
+{
+	return 0x2840;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Registers
+ */
+union rvu_af_pfaf_mbox_int {
+	u64 u;
+	struct rvu_af_pfaf_mbox_int_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_cn96xx {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFAF_MBOX_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFAF_MBOX_INT(void)
+{
+	return 0x2880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_ena_w1c
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Enable Clear Registers
+ * This register clears interrupt enable bits.
+ */
+union rvu_af_pfaf_mbox_int_ena_w1c {
+	u64 u;
+	struct rvu_af_pfaf_mbox_int_ena_w1c_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+{
+	return 0x2898;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_ena_w1s
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Enable Set Registers
+ * This register sets interrupt enable bits.
+ */
+union rvu_af_pfaf_mbox_int_ena_w1s {
+	u64 u;
+	struct rvu_af_pfaf_mbox_int_ena_w1s_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+{
+	return 0x2890;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_w1s
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Set Registers This
+ * register sets interrupt bits.
+ */
+union rvu_af_pfaf_mbox_int_w1s {
+	u64 u;
+	struct rvu_af_pfaf_mbox_int_w1s_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_w1s_cn96xx {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFAF_MBOX_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFAF_MBOX_INT_W1S(void)
+{
+	return 0x2888;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Registers
+ */
+union rvu_af_pfflr_int {
+	u64 u;
+	struct rvu_af_pfflr_int_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_cn96xx {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_s cn98xx; */
+	/* struct rvu_af_pfflr_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFFLR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFFLR_INT(void)
+{
+	return 0x28a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1c
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
+ */
+union rvu_af_pfflr_int_ena_w1c {
+	u64 u;
+	struct rvu_af_pfflr_int_ena_w1c_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_ena_w1c_cn96xx {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfflr_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_ena_w1c_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1C(void)
+{
+	return 0x28b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1s
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Set
+ * Registers This register sets interrupt enable bits.
+ */
+union rvu_af_pfflr_int_ena_w1s {
+	u64 u;
+	struct rvu_af_pfflr_int_ena_w1s_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_ena_w1s_cn96xx {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfflr_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_ena_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1S(void)
+{
+	return 0x28b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_w1s
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Set Registers
+ * This register sets interrupt bits.
+ */
+union rvu_af_pfflr_int_w1s {
+	u64 u;
+	struct rvu_af_pfflr_int_w1s_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_w1s_cn96xx {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfflr_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFFLR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFFLR_INT_W1S(void)
+{
+	return 0x28a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Registers
+ */
+union rvu_af_pfme_int {
+	u64 u;
+	struct rvu_af_pfme_int_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_cn96xx {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfme_int_s cn98xx; */
+	/* struct rvu_af_pfme_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFME_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFME_INT(void)
+{
+	return 0x28c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_ena_w1c
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
+ */
+union rvu_af_pfme_int_ena_w1c {
+	u64 u;
+	struct rvu_af_pfme_int_ena_w1c_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_ena_w1c_cn96xx {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfme_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfme_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_ena_w1c_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFME_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFME_INT_ENA_W1C(void)
+{
+	return 0x28d8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_ena_w1s
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Enable Set Registers
+ * This register sets interrupt enable bits.
+ */
+union rvu_af_pfme_int_ena_w1s {
+	u64 u;
+	struct rvu_af_pfme_int_ena_w1s_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_ena_w1s_cn96xx {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfme_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfme_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_ena_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFME_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFME_INT_ENA_W1S(void)
+{
+	return 0x28d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_w1s
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Set Registers This
+ * register sets interrupt bits.
+ */
+union rvu_af_pfme_int_w1s {
+	u64 u;
+	struct rvu_af_pfme_int_w1s_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_w1s_cn96xx {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfme_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfme_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFME_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFME_INT_W1S(void)
+{
+	return 0x28c8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_status
+ *
+ * RVU Admin Function PF Bus Master Enable Status Registers
+ */
+union rvu_af_pfme_status {
+	u64 u;
+	struct rvu_af_pfme_status_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_status_cn96xx {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pfme_status_s cn98xx; */
+	/* struct rvu_af_pfme_status_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_status_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFME_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFME_STATUS(void)
+{
+	return 0x2800;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pftrpend
+ *
+ * RVU Admin Function PF Transaction Pending Registers
+ */
+union rvu_af_pftrpend {
+	u64 u;
+	struct rvu_af_pftrpend_s {
+		u64 trpend                           : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pftrpend_cn96xx {
+		u64 trpend                           : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pftrpend_s cn98xx; */
+	/* struct rvu_af_pftrpend_cn96xx cnf95xx; */
+	/* struct rvu_af_pftrpend_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFTRPEND(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFTRPEND(void)
+{
+	return 0x2810;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pftrpend_w1s
+ *
+ * RVU Admin Function PF Transaction Pending Set Registers This register
+ * reads or sets bits.
+ */
+union rvu_af_pftrpend_w1s {
+	u64 u;
+	struct rvu_af_pftrpend_w1s_s {
+		u64 trpend                           : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pftrpend_w1s_cn96xx {
+		u64 trpend                           : 16;
+		u64 reserved_16_63                   : 48;
+	} cn96xx;
+	/* struct rvu_af_pftrpend_w1s_s cn98xx; */
+	/* struct rvu_af_pftrpend_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pftrpend_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_PFTRPEND_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFTRPEND_W1S(void)
+{
+	return 0x2820;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras
+ *
+ * RVU Admin Function RAS Interrupt Register This register is intended
+ * for delivery of RAS events to the SCP, so should be ignored by OS
+ * drivers.
+ */
+union rvu_af_ras {
+	u64 u;
+	struct rvu_af_ras_s {
+		u64 msix_poison                      : 1;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	struct rvu_af_ras_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_s cn98xx; */
+	/* struct rvu_af_ras_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_RAS(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1c
+ *
+ * RVU Admin Function RAS Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union rvu_af_ras_ena_w1c {
+	u64 u;
+	struct rvu_af_ras_ena_w1c_s {
+		u64 msix_poison                      : 1;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	struct rvu_af_ras_ena_w1c_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_ena_w1c_s cn98xx; */
+	/* struct rvu_af_ras_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_ena_w1c_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_RAS_ENA_W1C(void)
+{
+	return 0x118;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1s
+ *
+ * RVU Admin Function RAS Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union rvu_af_ras_ena_w1s {
+	u64 u;
+	struct rvu_af_ras_ena_w1s_s {
+		u64 msix_poison                      : 1;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	struct rvu_af_ras_ena_w1s_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_ena_w1s_s cn98xx; */
+	/* struct rvu_af_ras_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_ena_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_RAS_ENA_W1S(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_w1s
+ *
+ * RVU Admin Function RAS Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union rvu_af_ras_w1s {
+	u64 u;
+	struct rvu_af_ras_w1s_s {
+		u64 msix_poison                      : 1;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	struct rvu_af_ras_w1s_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_w1s_s cn98xx; */
+	/* struct rvu_af_ras_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_w1s_cn96xx loki; */
+};
+
+static inline u64 RVU_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_RAS_W1S(void)
+{
+	return 0x108;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_block_addr#_disc
+ *
+ * RVU PF Block Address Discovery Registers These registers allow each PF
+ * driver to discover block resources that are provisioned to its PF. The
+ * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
+ */
+union rvu_pf_block_addrx_disc {
+	u64 u;
+	struct rvu_pf_block_addrx_disc_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_10                    : 2;
+		u64 imp                              : 1;
+		u64 rid                              : 8;
+		u64 btype                            : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct rvu_pf_block_addrx_disc_s cn; */
+};
+
+static inline u64 RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int
+ *
+ * RVU PF Interrupt Registers
+ */
+union rvu_pf_int {
+	u64 u;
+	struct rvu_pf_int_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_pf_int_s cn; */
+};
+
+static inline u64 RVU_PF_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_INT(void)
+{
+	return 0xc20;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1c
+ *
+ * RVU PF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union rvu_pf_int_ena_w1c {
+	u64 u;
+	struct rvu_pf_int_ena_w1c_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_pf_int_ena_w1c_s cn; */
+};
+
+static inline u64 RVU_PF_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_INT_ENA_W1C(void)
+{
+	return 0xc38;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1s
+ *
+ * RVU PF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union rvu_pf_int_ena_w1s {
+	u64 u;
+	struct rvu_pf_int_ena_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_pf_int_ena_w1s_s cn; */
+};
+
+static inline u64 RVU_PF_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_INT_ENA_W1S(void)
+{
+	return 0xc30;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_w1s
+ *
+ * RVU PF Interrupt Set Register This register sets interrupt bits.
+ */
+union rvu_pf_int_w1s {
+	u64 u;
+	struct rvu_pf_int_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_pf_int_w1s_s cn; */
+};
+
+static inline u64 RVU_PF_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_INT_W1S(void)
+{
+	return 0xc28;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_pba#
+ *
+ * RVU PF MSI-X Pending-Bit-Array Registers This register is the MSI-X PF
+ * PBA table.
+ */
+union rvu_pf_msix_pbax {
+	u64 u;
+	struct rvu_pf_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct rvu_pf_msix_pbax_s cn; */
+};
+
+static inline u64 RVU_PF_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_addr
+ *
+ * RVU PF MSI-X Vector-Table Address Registers These registers and
+ * RVU_PF_MSIX_VEC()_CTL form the PF MSI-X vector table. The number of
+ * MSI-X vectors for a given PF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[PF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
+ * vectors.
+ */
+union rvu_pf_msix_vecx_addr {
+	u64 u;
+	struct rvu_pf_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct rvu_pf_msix_vecx_addr_s cn; */
+};
+
+static inline u64 RVU_PF_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_MSIX_VECX_ADDR(u64 a)
+{
+	return 0x80000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_ctl
+ *
+ * RVU PF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_PF_MSIX_VEC()_ADDR form the PF MSI-X vector table.
+ */
+union rvu_pf_msix_vecx_ctl {
+	u64 u;
+	struct rvu_pf_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct rvu_pf_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 RVU_PF_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_MSIX_VECX_CTL(u64 a)
+{
+	return 0x80008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_pfaf_mbox#
+ *
+ * RVU PF/AF Mailbox Registers
+ */
+union rvu_pf_pfaf_mboxx {
+	u64 u;
+	struct rvu_pf_pfaf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct rvu_pf_pfaf_mboxx_s cn; */
+};
+
+static inline u64 RVU_PF_PFAF_MBOXX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_PFAF_MBOXX(u64 a)
+{
+	return 0xc00 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vf#_pfvf_mbox#
+ *
+ * RVU PF/VF Mailbox Registers
+ */
+union rvu_pf_vfx_pfvf_mboxx {
+	u64 u;
+	struct rvu_pf_vfx_pfvf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct rvu_pf_vfx_pfvf_mboxx_s cn; */
+};
+
+static inline u64 RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+{
+	return 0 + 0x1000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vf_bar4_addr
+ *
+ * RVU PF VF BAR4 Address Registers
+ */
+union rvu_pf_vf_bar4_addr {
+	u64 u;
+	struct rvu_pf_vf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct rvu_pf_vf_bar4_addr_s cn; */
+};
+
+static inline u64 RVU_PF_VF_BAR4_ADDR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VF_BAR4_ADDR(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int#
+ *
+ * RVU PF VF Function Level Reset Interrupt Registers
+ */
+union rvu_pf_vfflr_intx {
+	u64 u;
+	struct rvu_pf_vfflr_intx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct rvu_pf_vfflr_intx_s cn; */
+};
+
+static inline u64 RVU_PF_VFFLR_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFFLR_INTX(u64 a)
+{
+	return 0x900 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1c#
+ *
+ * RVU PF VF Function Level Reset Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
+ */
+union rvu_pf_vfflr_int_ena_w1cx {
+	u64 u;
+	struct rvu_pf_vfflr_int_ena_w1cx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct rvu_pf_vfflr_int_ena_w1cx_s cn; */
+};
+
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+{
+	return 0x960 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1s#
+ *
+ * RVU PF VF Function Level Reset Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
+ */
+union rvu_pf_vfflr_int_ena_w1sx {
+	u64 u;
+	struct rvu_pf_vfflr_int_ena_w1sx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct rvu_pf_vfflr_int_ena_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+{
+	return 0x940 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_w1s#
+ *
+ * RVU PF VF Function Level Reset Interrupt Set Registers This register
+ * sets interrupt bits.
+ */
+union rvu_pf_vfflr_int_w1sx {
+	u64 u;
+	struct rvu_pf_vfflr_int_w1sx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct rvu_pf_vfflr_int_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFFLR_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFFLR_INT_W1SX(u64 a)
+{
+	return 0x920 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Registers
+ */
+union rvu_pf_vfme_intx {
+	u64 u;
+	struct rvu_pf_vfme_intx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct rvu_pf_vfme_intx_s cn; */
+};
+
+static inline u64 RVU_PF_VFME_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFME_INTX(u64 a)
+{
+	return 0x980 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1c#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
+ */
+union rvu_pf_vfme_int_ena_w1cx {
+	u64 u;
+	struct rvu_pf_vfme_int_ena_w1cx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct rvu_pf_vfme_int_ena_w1cx_s cn; */
+};
+
+static inline u64 RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+{
+	return 0x9e0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1s#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
+ */
+union rvu_pf_vfme_int_ena_w1sx {
+	u64 u;
+	struct rvu_pf_vfme_int_ena_w1sx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct rvu_pf_vfme_int_ena_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+{
+	return 0x9c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_w1s#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union rvu_pf_vfme_int_w1sx {
+	u64 u;
+	struct rvu_pf_vfme_int_w1sx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct rvu_pf_vfme_int_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFME_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFME_INT_W1SX(u64 a)
+{
+	return 0x9a0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_status#
+ *
+ * RVU PF VF Bus Master Enable Status Registers
+ */
+union rvu_pf_vfme_statusx {
+	u64 u;
+	struct rvu_pf_vfme_statusx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct rvu_pf_vfme_statusx_s cn; */
+};
+
+static inline u64 RVU_PF_VFME_STATUSX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFME_STATUSX(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int#
+ *
+ * RVU VF to PF Mailbox Interrupt Registers
+ */
+union rvu_pf_vfpf_mbox_intx {
+	u64 u;
+	struct rvu_pf_vfpf_mbox_intx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct rvu_pf_vfpf_mbox_intx_s cn; */
+};
+
+static inline u64 RVU_PF_VFPF_MBOX_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFPF_MBOX_INTX(u64 a)
+{
+	return 0x880 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1c#
+ *
+ * RVU VF to PF Mailbox Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union rvu_pf_vfpf_mbox_int_ena_w1cx {
+	u64 u;
+	struct rvu_pf_vfpf_mbox_int_ena_w1cx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct rvu_pf_vfpf_mbox_int_ena_w1cx_s cn; */
+};
+
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+{
+	return 0x8e0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1s#
+ *
+ * RVU VF to PF Mailbox Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union rvu_pf_vfpf_mbox_int_ena_w1sx {
+	u64 u;
+	struct rvu_pf_vfpf_mbox_int_ena_w1sx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct rvu_pf_vfpf_mbox_int_ena_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+{
+	return 0x8c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_w1s#
+ *
+ * RVU VF to PF Mailbox Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union rvu_pf_vfpf_mbox_int_w1sx {
+	u64 u;
+	struct rvu_pf_vfpf_mbox_int_w1sx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct rvu_pf_vfpf_mbox_int_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+{
+	return 0x8a0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vftrpend#
+ *
+ * RVU PF VF Transaction Pending Registers
+ */
+union rvu_pf_vftrpendx {
+	u64 u;
+	struct rvu_pf_vftrpendx_s {
+		u64 trpend                           : 64;
+	} s;
+	/* struct rvu_pf_vftrpendx_s cn; */
+};
+
+static inline u64 RVU_PF_VFTRPENDX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFTRPENDX(u64 a)
+{
+	return 0x820 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vftrpend_w1s#
+ *
+ * RVU PF VF Transaction Pending Set Registers This register reads or
+ * sets bits.
+ */
+union rvu_pf_vftrpend_w1sx {
+	u64 u;
+	struct rvu_pf_vftrpend_w1sx_s {
+		u64 trpend                           : 64;
+	} s;
+	/* struct rvu_pf_vftrpend_w1sx_s cn; */
+};
+
+static inline u64 RVU_PF_VFTRPEND_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PF_VFTRPEND_W1SX(u64 a)
+{
+	return 0x840 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_active_pc
+ *
+ * RVU Active Program Counter Register
+ */
+union rvu_priv_active_pc {
+	u64 u;
+	struct rvu_priv_active_pc_s {
+		u64 active_pc                        : 64;
+	} s;
+	/* struct rvu_priv_active_pc_s cn; */
+};
+
+static inline u64 RVU_PRIV_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_ACTIVE_PC(void)
+{
+	return 0x8000030;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_block_type#_rev
+ *
+ * RVU Privileged Block Type Revision Registers These registers are used
+ * by configuration software to specify the revision ID of each block
+ * type enumerated by RVU_BLOCK_TYPE_E, to assist VF/PF software
+ * discovery.
+ */
+union rvu_priv_block_typex_rev {
+	u64 u;
+	struct rvu_priv_block_typex_rev_s {
+		u64 rid                              : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct rvu_priv_block_typex_rev_s cn; */
+};
+
+static inline u64 RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+{
+	return 0x8000400 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_clk_cfg
+ *
+ * RVU Privileged General Configuration Register
+ */
+union rvu_priv_clk_cfg {
+	u64 u;
+	struct rvu_priv_clk_cfg_s {
+		u64 blk_clken                        : 1;
+		u64 ncbi_clken                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct rvu_priv_clk_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_CLK_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_CLK_CFG(void)
+{
+	return 0x8000020;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_const
+ *
+ * RVU Privileged Constants Register This register contains constants for
+ * software discovery.
+ */
+union rvu_priv_const {
+	u64 u;
+	struct rvu_priv_const_s {
+		u64 max_msix                         : 20;
+		u64 hwvfs                            : 12;
+		u64 pfs                              : 8;
+		u64 max_vfs_per_pf                   : 8;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct rvu_priv_const_s cn; */
+};
+
+static inline u64 RVU_PRIV_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_CONST(void)
+{
+	return 0x8000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_gen_cfg
+ *
+ * RVU Privileged General Configuration Register
+ */
+union rvu_priv_gen_cfg {
+	u64 u;
+	struct rvu_priv_gen_cfg_s {
+		u64 lock                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_priv_gen_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_GEN_CFG(void)
+{
+	return 0x8000010;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_cpt#_cfg
+ *
+ * RVU Privileged Hardware VF CPT Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for CPT({a}) block.
+ */
+union rvu_priv_hwvfx_cptx_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_cptx_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_cptx_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+{
+	return 0x8001350 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_int_cfg
+ *
+ * RVU Privileged Hardware VF Interrupt Configuration Registers
+ */
+union rvu_priv_hwvfx_int_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct rvu_priv_hwvfx_int_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_INT_CFG(u64 a)
+{
+	return 0x8001280 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_nix#_cfg
+ *
+ * RVU Privileged Hardware VF NIX Configuration Registers These registers
+ * are used to assist VF software discovery. For each HWVF, if the HWVF
+ * is mapped to a VF by RVU_PRIV_PF()_CFG[FIRST_HWVF,NVF], software
+ * writes NIX block's resource configuration for the VF in this register.
+ * The VF driver can read RVU_VF_BLOCK_ADDR()_DISC to discover the
+ * configuration.
+ */
+union rvu_priv_hwvfx_nixx_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_nixx_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_priv_hwvfx_nixx_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+{
+	return 0x8001300 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_npa_cfg
+ *
+ * RVU Privileged Hardware VF NPA Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for NPA block.
+ */
+union rvu_priv_hwvfx_npa_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_npa_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_priv_hwvfx_npa_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+{
+	return 0x8001310 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_ree#_cfg
+ *
+ * RVU Privileged Hardware VF REE Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for REE({a}) block.
+ */
+union rvu_priv_hwvfx_reex_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_reex_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_reex_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_REEX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_REEX_CFG(u64 a, u64 b)
+{
+	return 0x8001360 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_sso_cfg
+ *
+ * RVU Privileged Hardware VF SSO Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for SSO block.
+ */
+union rvu_priv_hwvfx_sso_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_sso_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_sso_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+{
+	return 0x8001320 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_ssow_cfg
+ *
+ * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
+ * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for SSOW block.
+ */
+union rvu_priv_hwvfx_ssow_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_ssow_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_ssow_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+{
+	return 0x8001330 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_tim_cfg
+ *
+ * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
+ * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for TIM block.
+ */
+union rvu_priv_hwvfx_tim_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_tim_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_tim_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+{
+	return 0x8001340 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_cfg
+ *
+ * RVU Privileged PF Configuration Registers
+ */
+union rvu_priv_pfx_cfg {
+	u64 u;
+	struct rvu_priv_pfx_cfg_s {
+		u64 first_hwvf                       : 12;
+		u64 nvf                              : 8;
+		u64 ena                              : 1;
+		u64 af_ena                           : 1;
+		u64 me_flr_ena                       : 1;
+		u64 pf_vf_io_bar4                    : 1;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_priv_pfx_cfg_cn96xxp1 {
+		u64 first_hwvf                       : 12;
+		u64 nvf                              : 8;
+		u64 ena                              : 1;
+		u64 af_ena                           : 1;
+		u64 me_flr_ena                       : 1;
+		u64 reserved_23_63                   : 41;
+	} cn96xxp1;
+	/* struct rvu_priv_pfx_cfg_s cn96xxp3; */
+	/* struct rvu_priv_pfx_cfg_s cn98xx; */
+	/* struct rvu_priv_pfx_cfg_cn96xxp1 cnf95xx; */
+	/* struct rvu_priv_pfx_cfg_s loki; */
+};
+
+static inline u64 RVU_PRIV_PFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_CFG(u64 a)
+{
+	return 0x8000100 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_cpt#_cfg
+ *
+ * RVU Privileged PF CPT Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for CPT({a}) block.
+ */
+union rvu_priv_pfx_cptx_cfg {
+	u64 u;
+	struct rvu_priv_pfx_cptx_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_cptx_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+{
+	return 0x8000350 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_id_cfg
+ *
+ * RVU Privileged PF ID Configuration Registers
+ */
+union rvu_priv_pfx_id_cfg {
+	u64 u;
+	struct rvu_priv_pfx_id_cfg_s {
+		u64 pf_devid                         : 8;
+		u64 vf_devid                         : 8;
+		u64 class_code                       : 24;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct rvu_priv_pfx_id_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_ID_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_ID_CFG(u64 a)
+{
+	return 0x8000120 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_int_cfg
+ *
+ * RVU Privileged PF Interrupt Configuration Registers
+ */
+union rvu_priv_pfx_int_cfg {
+	u64 u;
+	struct rvu_priv_pfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct rvu_priv_pfx_int_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_INT_CFG(u64 a)
+{
+	return 0x8000200 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_msix_cfg
+ *
+ * RVU Privileged PF MSI-X Configuration Registers These registers
+ * specify MSI-X table sizes and locations for RVU PFs and associated
+ * VFs. Hardware maintains all RVU MSI-X tables in a contiguous memory
+ * region in LLC/DRAM called the MSI-X table region. The table region's
+ * base AF IOVA is specified by RVU_AF_MSIXTR_BASE, and its size as a
+ * multiple of 16-byte RVU_MSIX_VEC_S structures must be less than or
+ * equal to RVU_PRIV_CONST[MAX_MSIX].  A PF's MSI-X table consists of the
+ * following range of RVU_MSIX_VEC_S structures in the table region: *
+ * First index: [PF_MSIXT_OFFSET]. * Last index: [PF_MSIXT_OFFSET] +
+ * [PF_MSIXT_SIZEM1].  If a PF has enabled VFs (associated
+ * RVU_PRIV_PF()_CFG[NVF] is nonzero), then each VF's MSI-X table
+ * consumes the following range of RVU_MSIX_VEC_S structures: * First
+ * index: [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1). * Last index:
+ * [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1) + [VF_MSIXT_SIZEM1].
+ * N=0 for the first VF, N=1 for the second VF, etc.  Different PFs and
+ * VFs must have non-overlapping vector ranges, and the last index of any
+ * range must be less than RVU_PRIV_CONST[MAX_MSIX].
+ */
+union rvu_priv_pfx_msix_cfg {
+	u64 u;
+	struct rvu_priv_pfx_msix_cfg_s {
+		u64 vf_msixt_sizem1                  : 12;
+		u64 vf_msixt_offset                  : 20;
+		u64 pf_msixt_sizem1                  : 12;
+		u64 pf_msixt_offset                  : 20;
+	} s;
+	/* struct rvu_priv_pfx_msix_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_MSIX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_MSIX_CFG(u64 a)
+{
+	return 0x8000110 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_nix#_cfg
+ *
+ * RVU Privileged PF NIX Configuration Registers These registers are used
+ * to assist PF software discovery. For each enabled RVU PF, software
+ * writes the block's resource configuration for the PF in this register.
+ * The PF driver can read RVU_PF_BLOCK_ADDR()_DISC to discover the
+ * configuration.
+ */
+union rvu_priv_pfx_nixx_cfg {
+	u64 u;
+	struct rvu_priv_pfx_nixx_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_priv_pfx_nixx_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+{
+	return 0x8000300 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_npa_cfg
+ *
+ * RVU Privileged PF NPA Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for NPA block.
+ */
+union rvu_priv_pfx_npa_cfg {
+	u64 u;
+	struct rvu_priv_pfx_npa_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_priv_pfx_npa_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_NPA_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_NPA_CFG(u64 a)
+{
+	return 0x8000310 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_ree#_cfg
+ *
+ * RVU Privileged PF REE Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for REE({a}) block.
+ */
+union rvu_priv_pfx_reex_cfg {
+	u64 u;
+	struct rvu_priv_pfx_reex_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_reex_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_REEX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_REEX_CFG(u64 a, u64 b)
+{
+	return 0x8000360 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_sso_cfg
+ *
+ * RVU Privileged PF SSO Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSO block.
+ */
+union rvu_priv_pfx_sso_cfg {
+	u64 u;
+	struct rvu_priv_pfx_sso_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_sso_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_SSO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_SSO_CFG(u64 a)
+{
+	return 0x8000320 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_ssow_cfg
+ *
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSOW block.
+ */
+union rvu_priv_pfx_ssow_cfg {
+	u64 u;
+	struct rvu_priv_pfx_ssow_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_ssow_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_SSOW_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_SSOW_CFG(u64 a)
+{
+	return 0x8000330 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_tim_cfg
+ *
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for TIM block.
+ */
+union rvu_priv_pfx_tim_cfg {
+	u64 u;
+	struct rvu_priv_pfx_tim_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_tim_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_TIM_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_TIM_CFG(u64 a)
+{
+	return 0x8000340 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_block_addr#_disc
+ *
+ * RVU VF Block Address Discovery Registers These registers allow each VF
+ * driver to discover block resources that are provisioned to its VF. The
+ * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
+ */
+union rvu_vf_block_addrx_disc {
+	u64 u;
+	struct rvu_vf_block_addrx_disc_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_10                    : 2;
+		u64 imp                              : 1;
+		u64 rid                              : 8;
+		u64 btype                            : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct rvu_vf_block_addrx_disc_s cn; */
+};
+
+static inline u64 RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int
+ *
+ * RVU VF Interrupt Registers
+ */
+union rvu_vf_int {
+	u64 u;
+	struct rvu_vf_int_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_vf_int_s cn; */
+};
+
+static inline u64 RVU_VF_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_INT(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1c
+ *
+ * RVU VF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union rvu_vf_int_ena_w1c {
+	u64 u;
+	struct rvu_vf_int_ena_w1c_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_vf_int_ena_w1c_s cn; */
+};
+
+static inline u64 RVU_VF_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_INT_ENA_W1C(void)
+{
+	return 0x38;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1s
+ *
+ * RVU VF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union rvu_vf_int_ena_w1s {
+	u64 u;
+	struct rvu_vf_int_ena_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_vf_int_ena_w1s_s cn; */
+};
+
+static inline u64 RVU_VF_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_INT_ENA_W1S(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_w1s
+ *
+ * RVU VF Interrupt Set Register This register sets interrupt bits.
+ */
+union rvu_vf_int_w1s {
+	u64 u;
+	struct rvu_vf_int_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct rvu_vf_int_w1s_s cn; */
+};
+
+static inline u64 RVU_VF_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_INT_W1S(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_pba#
+ *
+ * RVU VF MSI-X Pending-Bit-Array Registers This register is the MSI-X VF
+ * PBA table.
+ */
+union rvu_vf_msix_pbax {
+	u64 u;
+	struct rvu_vf_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct rvu_vf_msix_pbax_s cn; */
+};
+
+static inline u64 RVU_VF_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_addr
+ *
+ * RVU VF MSI-X Vector-Table Address Registers These registers and
+ * RVU_VF_MSIX_VEC()_CTL form the VF MSI-X vector table. The number of
+ * MSI-X vectors for a given VF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[VF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
+ * vectors.
+ */
+union rvu_vf_msix_vecx_addr {
+	u64 u;
+	struct rvu_vf_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct rvu_vf_msix_vecx_addr_s cn; */
+};
+
+static inline u64 RVU_VF_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_MSIX_VECX_ADDR(u64 a)
+{
+	return 0x80000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_ctl
+ *
+ * RVU VF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_VF_MSIX_VEC()_ADDR form the VF MSI-X vector table.
+ */
+union rvu_vf_msix_vecx_ctl {
+	u64 u;
+	struct rvu_vf_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct rvu_vf_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 RVU_VF_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_MSIX_VECX_CTL(u64 a)
+{
+	return 0x80008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_vfpf_mbox#
+ *
+ * RVU VF/PF Mailbox Registers
+ */
+union rvu_vf_vfpf_mboxx {
+	u64 u;
+	struct rvu_vf_vfpf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct rvu_vf_vfpf_mboxx_s cn; */
+};
+
+static inline u64 RVU_VF_VFPF_MBOXX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_VF_VFPF_MBOXX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+#endif /* __CSRS_RVU_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/gpio.h b/arch/arm/include/asm/arch-octeontx2/gpio.h
new file mode 100644
index 0000000000..3943ffd952
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/gpio.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
diff --git a/arch/arm/include/asm/arch-octeontx2/lock.h b/arch/arm/include/asm/arch-octeontx2/lock.h
new file mode 100644
index 0000000000..65fab6865f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/lock.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ */
+
+#ifndef __OCTEONTX2_LOCK_H__
+#define __OCTEONTX2_LOCK_H__
+
+/**
+ * U-Boot doesn't implement spinlocks but we need them here since
+ * we could be sharing with other processes (i.e. ATF)
+ *
+ * This is copied from the Linux kernel arm64 implementation.
+ */
+typedef struct octeontx_spinlock {
+	u16 next;
+	u16 owner;
+} __aligned(4) octeontx_spinlock_t;
+
+/**
+ * Atomic compare and exchange, derived from atomic_ll_sc.h in Linux
+ *
+ * @param	ptr	pointer to 128 bits to compare and exchange
+ * @param	old_hi	expected old value first 64 bits
+ * @param	old_lo	expected old value second 64 bits
+ * @param	new_hi	new first 64-bit value to set
+ * @param	new_lo	new second 64-bit value to set
+ * @param	last_hi	pointer to previous first 64-bit value
+ * @param	last_lo	pointer previous second 64-bit value
+ *
+ * @return	true if successful, false if the old values mismatched
+ *
+ * last_hi and last_lo may be NULL.
+ */
+static inline bool octeontx_cmpxchg_atomic128(volatile void *ptr,
+					      u64 old_hi, u64 old_lo,
+					      u64 new_hi, u64 new_lo,
+					      u64 *last_hi, u64 *last_lo)
+{
+	u64 tmp_hi, tmp_lo, oldval_hi, oldval_lo;
+	u32 tmp;
+
+	asm volatile (
+		"	prfm	pstl1strm, %[v]				\n"
+		"1:	ldaxp	%[oldval_lo], %[oldval_hi], %[v]	\n"
+		"	eor	%[tmp_lo], %[oldval_lo], %[old_lo]	\n"
+		"	eor	%[tmp_hi], %[oldval_hi], %[old_hi]	\n"
+		"	cbnz	%[tmp_lo], 2f				\n"
+		"	cbnz	%[tmp_hi], 2f				\n"
+		"	stxp	%w[tmp],  %[new_hi], %[new_lo], %[v]	\n"
+		"	cbnz	%w[tmp], 1b				\n"
+		"2:							\n"
+		: [tmp] "=&r" (tmp),
+		  [oldval_lo] "=&r" (oldval_lo),
+		  [oldval_hi] "=&r" (oldval_hi),
+		  [v] "+Q" (*(u64 *)ptr),
+		  [tmp_lo] "=&r" (tmp_lo), [tmp_hi] "=&r" (tmp_hi)
+		: [old_lo] "Lr" (old_lo), [old_hi] "Lr" (old_hi),
+		  [new_lo] "r" (new_lo), [new_hi] "r" (new_hi)
+		: "memory");
+	if (last_hi)
+		*last_hi = oldval_hi;
+	if (last_lo)
+		*last_lo = oldval_lo;
+	return !(tmp_hi | tmp_lo);
+}
+
+static inline void octeontx_init_spin_lock(octeontx_spinlock_t *lock)
+{
+	*(u32 *)lock = 0;
+	__iowmb();
+}
+
+/**
+ * Acquires a spinlock
+ *
+ * @param	lock	pointer to lock
+ *
+ * This code is copied from the Linux aarch64 spinlock.h file
+ * and is compatible with it.
+ */
+static inline void octeontx_spin_lock(octeontx_spinlock_t *lock)
+{
+	unsigned int tmp;
+	octeontx_spinlock_t lockval, newval;
+
+	asm volatile (
+	/* Atomically increment the next ticket. */
+	/* LL/SC */
+"	prfm	pstl1strm, %3		\n"
+"1:	ldaxr	%w0, %3			\n"
+"	add	%w1, %w0, %w5		\n"
+"	stxr	%w2, %w1, %3		\n"
+"	cbnz	%w2, 1b			\n"
+
+	/* Did we get the lock? */
+"	eor	%w1, %w0, %w0, ror #16	\n"
+"	cbz	%w1, 3f			\n"
+	/*
+	 * No: spin on the owner. Send a local event to avoid missing an
+	 * unlock before the exclusive load.
+	 */
+"	sevl				\n"
+"2:	wfe				\n"
+"	ldaxrh	%w2, %4			\n"
+"	eor	%w1, %w2, %w0, lsr #16	\n"
+"	cbnz	%w1, 2b			\n"
+	/* We got the lock. Critical section starts here. */
+"3:"
+	: "=&r" (lockval), "=&r" (newval), "=&r" (tmp), "+Q" (*lock)
+	: "Q" (lock->owner), "I" (1 << 16)
+	: "memory");
+}
+
+/**
+ * Releases a spinlock
+ *
+ * @param	lock	pointer to lock
+ *
+ * This code is copied from the Linux aarch64 spinlock.h file.
+ */
+static inline void octeontx_spin_unlock(octeontx_spinlock_t *lock)
+{
+	unsigned long tmp;
+
+	asm volatile (
+		"	ldrh	%w1, %0		\n"
+		"	add	%w1, %w1, #1	\n"
+		"	stlrh	%w1, %0		\n"
+		"	nop			\n"
+		: "=Q" (lock->owner), "=&r" (tmp)
+		:
+		: "memory"
+
+	);
+}
+
+#endif /* __OCTEONTX2_LOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/smc-id.h b/arch/arm/include/asm/arch-octeontx2/smc-id.h
new file mode 100644
index 0000000000..c7f9fa73fc
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/smc-id.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SMC_ID_H__
+#define __SMC_ID_H__
+
+/* SMC function IDs for general purpose queries */
+
+#define OCTEONTX2_SVC_CALL_COUNT	0xc200ff00
+#define OCTEONTX2_SVC_UID		0xc200ff01
+
+#define OCTEONTX2_SVC_VERSION		0xc200ff03
+
+/* OcteonTX Service Calls version numbers */
+#define OCTEONTX2_VERSION_MAJOR	0x1
+#define OCTEONTX2_VERSION_MINOR	0x0
+
+/* x1 - node number */
+#define OCTEONTX2_DRAM_SIZE		0xc2000301
+#define OCTEONTX2_NODE_COUNT		0xc2000601
+#define OCTEONTX2_DISABLE_RVU_LFS	0xc2000b01
+
+#define OCTEONTX2_CONFIG_OOO		0xc2000b04
+
+/* fail safe */
+#define OCTEONTX2_FSAFE_PR_BOOT_SUCCESS	0xc2000b02
+#define OCTEONTX2_FSAFE_CLR_FORCE_SEC	0xc2000b03
+
+#define OCTEONTX2_MDIO_DBG_READ		0xc2000d01
+#define OCTEONTX2_MDIO_DBG_WRITE	0xc2000d02
+
+#define OCTEONTX_ATTESTATION_QUERY	0xc2000d03
+#define OCTEONTX_ATTESTATION_QUERY_SUBCMD_LEGACY 0
+#define OCTEONTX_ATTESTATION_QUERY_SUBCMD_BUFFER 1
+#define OCTEONTX_ATTESTATION_QUERY_SUBCMD_INFO   2
+
+#endif /* __SMC_ID_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/smc.h b/arch/arm/include/asm/arch-octeontx2/smc.h
new file mode 100644
index 0000000000..ecbed3882c
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/smc.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SMC_H__
+#define __SMC_H__
+
+#include <asm/arch/smc-id.h>
+
+ssize_t smc_configure_ooo(unsigned int val);
+ssize_t smc_dram_size(unsigned int node);
+ssize_t smc_disable_rvu_lfs(unsigned int node);
+ssize_t smc_flsf_fw_booted(void);
+ssize_t smc_flsf_clr_force_2ndry(void);
+ssize_t smc_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+			  int reg);
+ssize_t smc_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+			   int reg, int val);
+#ifdef CONFIG_CMD_ATTEST
+ssize_t smc_attest(long subcmd, long ctx_arg);
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/soc.h b/arch/arm/include/asm/arch-octeontx2/soc.h
new file mode 100644
index 0000000000..63d792c46a
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/soc.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __SOC_H__
+#define __SOC_H__
+
+/* Product PARTNUM */
+#define CN98XX	0xB1
+#define CN96XX	0xB2
+#define CN95XX	0xB3
+#define LOKI	0xB4
+#define F95MM	0xB5
+
+/* Register defines */
+
+#define otx_is_soc(soc)	(read_partnum() == (soc))
+#define otx_is_board(model) (!strcmp(read_board_name(), model))
+#define otx_is_platform(platform) (read_platform() == (platform))
+
+typedef enum {
+	PLATFORM_HW = 0,
+	PLATFORM_EMULATOR = 1,
+	PLATFORM_ASIM = 3,
+} platform_t;
+
+platform_t read_platform(void);
+u8 read_partnum(void);
+u8 read_partvar(void);
+const char *read_board_name(void);
+
+#endif /* __SOC_H */
diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
index e6d27b69f9..0f51552018 100644
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -226,6 +226,14 @@ static inline void __raw_readsl(unsigned long addr, void *data, int longlen)
 #define setbits_8(addr, set) setbits(8, addr, set)
 #define clrsetbits_8(addr, clear, set) clrsetbits(8, addr, clear, set)
 
+#define clrbits_be64(addr, clear) clrbits(be64, addr, clear)
+#define setbits_be64(addr, set) setbits(be64, addr, set)
+#define clrsetbits_be64(addr, clear, set) clrsetbits(be64, addr, clear, set)
+
+#define clrbits_le64(addr, clear) clrbits(le64, addr, clear)
+#define setbits_le64(addr, set) setbits(le64, addr, set)
+#define clrsetbits_le64(addr, clear, set) clrsetbits(le64, addr, clear, set)
+
 /*
  * Now, pick up the machine-defined IO definitions
  */
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index a1a5e35ef6..8a99ed39da 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -253,6 +253,11 @@ void mmu_change_region_attr(phys_addr_t start, size_t size, u64 attrs);
  */
 void smc_call(struct pt_regs *args);
 
+/* Return codes defined in ARM DEN 0070A */
+#define SMCCC_RET_SUCCESS			0
+#define SMCCC_RET_NOT_SUPPORTED			-1
+#define SMCCC_RET_NOT_REQUIRED			-2
+
 void __noreturn psci_system_reset(void);
 void __noreturn psci_system_off(void);
 
diff --git a/arch/arm/lib/interrupts_64.c b/arch/arm/lib/interrupts_64.c
index 0bfdb8d93d..33ec856087 100644
--- a/arch/arm/lib/interrupts_64.c
+++ b/arch/arm/lib/interrupts_64.c
@@ -94,6 +94,10 @@ void do_bad_error(struct pt_regs *pt_regs, unsigned int esr)
 	panic("Resetting CPU ...\n");
 }
 
+__weak void plat_do_sync(void)
+{
+}
+
 /*
  * do_sync handles the Synchronous Abort exception.
  */
@@ -101,6 +105,8 @@ void do_sync(struct pt_regs *pt_regs, unsigned int esr)
 {
 	efi_restore_gd();
 	printf("\"Synchronous Abort\" handler, esr 0x%08x\n", esr);
+
+	plat_do_sync();
 	show_regs(pt_regs);
 	show_efi_loaded_images(pt_regs);
 	panic("Resetting CPU ...\n");
diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig
index fdd39685b7..09d871ee27 100644
--- a/arch/arm/mach-mvebu/Kconfig
+++ b/arch/arm/mach-mvebu/Kconfig
@@ -16,10 +16,6 @@ config ARMADA_32BIT
 	select SUPPORT_SPL
 	select TRANSLATION_OFFSET
 
-config ARMADA_64BIT
-	bool
-	select ARM64
-
 # ARMv7 SoCs...
 config ARMADA_375
 	bool
@@ -43,6 +39,7 @@ config ARMADA_3700
 config ARMADA_8K
 	bool
 	select ARM64
+	select HAVE_MVEBU_EFUSE
 
 # Armada PLL frequency (used for NAND clock generation)
 config SYS_MVEBU_PLL_CLOCK
@@ -113,6 +110,10 @@ config TARGET_DB_88F6820_AMC
 	bool "Support DB-88F6820-AMC"
 	select 88F6820
 
+config TARGET_DB_88F6820_AP
+	bool "Support DB-88F6820-AP"
+	select 88F6820
+
 config TARGET_TURRIS_OMNIA
 	bool "Support Turris Omnia"
 	select 88F6820
@@ -134,6 +135,12 @@ config TARGET_MVEBU_ARMADA_8K
 	select BOARD_LATE_INIT
 	imply SCSI
 
+config TARGET_OCTEONTX2_CN913x
+	bool "Support CN913x"
+	select ARMADA_8K
+	select BOARD_LATE_INIT
+	imply SCSI
+
 config TARGET_DB_MV784MP_GP
 	bool "Support db-mv784mp-gp"
 	select MV78460
@@ -177,9 +184,11 @@ config SYS_BOARD
 	default "db-88f6720" if TARGET_DB_88F6720
 	default "db-88f6820-gp" if TARGET_DB_88F6820_GP
 	default "db-88f6820-amc" if TARGET_DB_88F6820_AMC
+	default "db-88f6820-ap" if TARGET_DB_88F6820_AP
 	default "turris_omnia" if TARGET_TURRIS_OMNIA
 	default "turris_mox" if TARGET_TURRIS_MOX
 	default "mvebu_armada-8k" if TARGET_MVEBU_ARMADA_8K
+	default "octeontx2_cn913x" if TARGET_OCTEONTX2_CN913x
 	default "db-mv784mp-gp" if TARGET_DB_MV784MP_GP
 	default "ds414" if TARGET_DS414
 	default "maxbcm" if TARGET_MAXBCM
@@ -196,7 +205,9 @@ config SYS_CONFIG_NAME
 	default "db-88f6720" if TARGET_DB_88F6720
 	default "db-88f6820-gp" if TARGET_DB_88F6820_GP
 	default "db-88f6820-amc" if TARGET_DB_88F6820_AMC
+	default "db-88f6820-ap" if TARGET_DB_88F6820_AP
 	default "mvebu_armada-8k" if TARGET_MVEBU_ARMADA_8K
+	default "octeontx2_cn913x" if TARGET_OCTEONTX2_CN913x
 	default "db-mv784mp-gp" if TARGET_DB_MV784MP_GP
 	default "ds414" if TARGET_DS414
 	default "maxbcm" if TARGET_MAXBCM
@@ -214,9 +225,11 @@ config SYS_VENDOR
 	default "Marvell" if TARGET_DB_88F6720
 	default "Marvell" if TARGET_DB_88F6820_GP
 	default "Marvell" if TARGET_DB_88F6820_AMC
+	default "Marvell" if TARGET_DB_88F6820_AP
 	default "Marvell" if TARGET_MVEBU_ARMADA_8K
 	default "Marvell" if TARGET_DB_XC3_24G4XG
 	default "Marvell" if TARGET_MVEBU_DB_88F7040
+	default "Marvell" if TARGET_OCTEONTX2_CN913x
 	default "solidrun" if TARGET_CLEARFOG
 	default "kobol" if TARGET_HELIOS4
 	default "Synology" if TARGET_DS414
@@ -235,6 +248,9 @@ choice
 config MVEBU_SPL_BOOT_DEVICE_SPI
 	bool "SPI NOR flash"
 
+config MVEBU_SPL_BOOT_DEVICE_NAND
+	bool "NAND flash"
+
 config MVEBU_SPL_BOOT_DEVICE_MMC
 	bool "SDIO/MMC card"
 	select SPL_LIBDISK_SUPPORT
@@ -249,23 +265,6 @@ config MVEBU_SPL_BOOT_DEVICE_UART
 
 endchoice
 
-config MVEBU_EFUSE
-	bool "Enable eFuse support"
-	default n
-	depends on HAVE_MVEBU_EFUSE
-	help
-	  Enable support for reading and writing eFuses on mvebu SoCs.
-
-config MVEBU_EFUSE_FAKE
-	bool "Fake eFuse access (dry run)"
-	default n
-	depends on MVEBU_EFUSE
-	help
-	  This enables a "dry run" mode where eFuses are not really programmed.
-	  Instead the eFuse accesses are emulated by writing to and reading
-	  from a memory block.
-	  This is can be used for testing prog scripts.
-
 config SECURED_MODE_IMAGE
 	bool "Build image for trusted boot"
 	default false
@@ -279,4 +278,6 @@ config SECURED_MODE_CSK_INDEX
 	default 0
 	depends on SECURED_MODE_IMAGE
 
+source "arch/arm/mach-mvebu/armada3700/Kconfig"
+
 endif
diff --git a/arch/arm/mach-mvebu/Makefile b/arch/arm/mach-mvebu/Makefile
index 8228a17972..1bf147440b 100644
--- a/arch/arm/mach-mvebu/Makefile
+++ b/arch/arm/mach-mvebu/Makefile
@@ -26,7 +26,6 @@ obj-$(CONFIG_ARMADA_375) += ../../../drivers/ddr/marvell/axp/xor.o
 obj-$(CONFIG_ARMADA_38X) += ../../../drivers/ddr/marvell/a38x/xor.o
 obj-$(CONFIG_ARMADA_XP) += ../../../drivers/ddr/marvell/axp/xor.o
 obj-$(CONFIG_ARMADA_MSYS) += ../../../drivers/ddr/marvell/axp/xor.o
-obj-$(CONFIG_MVEBU_EFUSE) += efuse.o
 
 extra-y += kwbimage.cfg
 
@@ -34,6 +33,9 @@ KWB_REPLACE += BOOT_FROM
 ifneq ($(CONFIG_MVEBU_SPL_BOOT_DEVICE_SPI),)
 	KWB_CFG_BOOT_FROM=spi
 endif
+ifneq ($(CONFIG_MVEBU_SPL_BOOT_DEVICE_NAND),)
+	KWB_CFG_BOOT_FROM=nand
+endif
 ifneq ($(CONFIG_MVEBU_SPL_BOOT_DEVICE_MMC),)
 	KWB_CFG_BOOT_FROM=sdio
 endif
diff --git a/arch/arm/mach-mvebu/arm64-common.c b/arch/arm/mach-mvebu/arm64-common.c
index aaf7b7c447..2809db8c51 100644
--- a/arch/arm/mach-mvebu/arm64-common.c
+++ b/arch/arm/mach-mvebu/arm64-common.c
@@ -14,6 +14,8 @@
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <power/regulator.h>
+#include <mach/fw_info.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -84,10 +86,44 @@ static void a8k_dram_init_banksize(void)
 	}
 }
 
+static u64 a3700_dram_scan_ap_sz(void)
+{
+	struct pt_regs pregs;
+
+	pregs.regs[0] = MV_SIP_DRAM_SIZE;
+	smc_call(&pregs);
+
+	return pregs.regs[0];
+}
+
+static void a3700_dram_init_banksize(void)
+{
+	/* If ddr size is below 2GB there is only one ddr bank used */
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size <= SZ_2G) {
+		gd->bd->bi_dram[0].size = gd->ram_size;
+		return;
+	}
+
+	/*
+	 * If ddr size is above 2GB there is only one case 4GB but the firmware
+	 * uses 4 decoding windows for describing it in way reflected below.
+	 */
+	gd->bd->bi_dram[0].size = SZ_2G;
+	gd->bd->bi_dram[1].start = SZ_2G;
+	gd->bd->bi_dram[1].size = SZ_1G;
+	gd->bd->bi_dram[2].start = SZ_2G + SZ_1G;
+	gd->bd->bi_dram[2].size = SZ_256M;
+	gd->bd->bi_dram[3].start = 0xe0000000;
+	gd->bd->bi_dram[3].size = SZ_128M;
+}
+
 __weak int dram_init_banksize(void)
 {
 	if (CONFIG_IS_ENABLED(ARMADA_8K))
 		a8k_dram_init_banksize();
+	else if (CONFIG_IS_ENABLED(ARMADA_3700))
+		a3700_dram_init_banksize();
 	else
 		fdtdec_setup_memory_banksize();
 
@@ -96,11 +132,13 @@ __weak int dram_init_banksize(void)
 
 __weak int dram_init(void)
 {
-	if (CONFIG_IS_ENABLED(ARMADA_8K)) {
+	if (CONFIG_IS_ENABLED(ARMADA_8K))
 		gd->ram_size = a8k_dram_scan_ap_sz();
-		if (gd->ram_size != 0)
-			return 0;
-	}
+	else if (CONFIG_IS_ENABLED(ARMADA_3700))
+		gd->ram_size = a3700_dram_scan_ap_sz();
+
+	if (gd->ram_size != 0)
+		return 0;
 
 	if (fdtdec_setup_mem_size_base() != 0)
 		return -EINVAL;
@@ -120,6 +158,8 @@ int arch_early_init_r(void)
 	int ret;
 	int i;
 
+	printf("Running in RAM - U-Boot at: 0x%08lx\n", gd->relocaddr);
+	printf("                 Env at:    0x%08lx\n", gd->env_addr);
 	/*
 	 * Loop over all MISC uclass drivers to call the comphy code
 	 * and init all CP110 devices enabled in the DT
@@ -134,6 +174,16 @@ int arch_early_init_r(void)
 			break;
 	}
 
+	i = 0;
+	while (1) {
+		/* Call the pinctrl code via the PINCTRL uclass driver */
+		ret = uclass_get_device(UCLASS_PINCTRL, i++, &dev);
+
+		/* We're done, once no further CP110 device is found */
+		if (ret)
+			break;
+	}
+
 	/* Cause the SATA device to do its early init */
 	uclass_first_device(UCLASS_AHCI, &dev);
 
@@ -144,3 +194,24 @@ int arch_early_init_r(void)
 
 	return 0;
 }
+
+void plat_do_sync(void)
+{
+	u32 far, el;
+
+	el = current_el();
+
+	if (el == 1)
+		asm volatile("mrs %0, far_el1" : "=r" (far));
+	else if (el == 2)
+		asm volatile("mrs %0, far_el2" : "=r" (far));
+	else
+		asm volatile("mrs %0, far_el3" : "=r" (far));
+
+	if (far >= ATF_REGION_START && far <= ATF_REGION_END) {
+		pr_err("\n\tAttempt to access RT service or TEE region (addr: 0x%x, el%d)\n",
+		       far, el);
+		pr_err("\tDo not use address range 0x%x-0x%x\n\n",
+		       ATF_REGION_START, ATF_REGION_END);
+	}
+}
diff --git a/arch/arm/mach-mvebu/armada3700/Kconfig b/arch/arm/mach-mvebu/armada3700/Kconfig
new file mode 100644
index 0000000000..2bd127fe59
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada3700/Kconfig
@@ -0,0 +1,12 @@
+menu "eFuse support"
+
+config MVEBU_EFUSE_SUPPORT
+	bool "eFuse support"
+	depends on TARGET_MVEBU_ARMADA_37XX && CMD_MVEBU_EFUSE
+	default n
+	help
+	  Choose this option to add support
+	  for eFuse access driver and enable
+	  mailbox for eFuse read/write actions
+
+endmenu
diff --git a/arch/arm/mach-mvebu/armada3700/Makefile b/arch/arm/mach-mvebu/armada3700/Makefile
index 031b3e854e..7a638de8c8 100644
--- a/arch/arm/mach-mvebu/armada3700/Makefile
+++ b/arch/arm/mach-mvebu/armada3700/Makefile
@@ -3,3 +3,6 @@
 # Copyright (C) 2016 Stefan Roese <sr@denx.de>
 
 obj-y = cpu.o
+obj-y += clock.o
+obj-$(CONFIG_MVEBU_EFUSE_SUPPORT) += efuse.o
+obj-$(CONFIG_MVEBU_EFUSE_SUPPORT) += mbox.o
diff --git a/arch/arm/mach-mvebu/armada3700/clock.c b/arch/arm/mach-mvebu/armada3700/clock.c
new file mode 100644
index 0000000000..f81ba48305
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada3700/clock.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+#include <asm/arch/soc.h>
+#include <mach/clock.h>
+
+#define NB_CLOCK_REGS_BASE	(MVEBU_REGISTER(0x13000))
+#define NB_PLL_BASE		(NB_CLOCK_REGS_BASE + 0x200)
+#define NB_TBG_CTRL0		(NB_PLL_BASE + 0x4)
+ #define NB_TBG_CTRL0_TBG_A_FBDIV_OFFSET		2
+ #define NB_TBG_CTRL0_TBG_A_FBDIV_MASK			0x1FFUL
+ #define NB_TBG_CTRL0_TBG_B_FBDIV_OFFSET		18
+ #define NB_TBG_CTRL0_TBG_B_FBDIV_MASK			0x1FFUL
+
+#define NB_TBG_CTRL1		(NB_PLL_BASE + 0x8)
+ #define NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_OFFSET	16
+ #define NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_MASK		0x1FFUL
+ #define NB_TBG_CTRL1_TBG_A_VCODIV_SEL_SE_MASK		0x1FFUL
+
+#define NB_TBG_CTRL7		(NB_PLL_BASE + 0x20)
+ #define NB_TBG_CTRL7_TBG_B_REFDIV_OFFSET		16
+ #define NB_TBG_CTRL7_TBG_B_REFDIV_MASK			0x1FFUL
+ #define NB_TBG_CTRL7_TBG_A_REFDIV_MASK			0x1FFUL
+
+#define NB_TBG_CTRL8		(NB_PLL_BASE + 0x30)
+ #define NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_OFFSET	1
+ #define NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_MASK	0x1FFUL
+ #define NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_OFFSET	17
+ #define NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_MASK	0x1FFUL
+
+#define NB_CLOCK_TBG_SELECT_REG	NB_CLOCK_REGS_BASE
+ #define NB_CLOCK_TBG_SEL_A53_CPU_PCLK_OFFSET		22
+ #define NB_CLOCK_TBG_SEL_A53_CPU_PCLK_MASK		0x3
+
+/* north bridge clock divider select registers */
+#define NB_CLOCK_DIV_SEL0_REG	(NB_CLOCK_REGS_BASE + 0x4)
+ #define NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_OFFSET	28
+ #define NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_MASK	0x7
+
+/* north bridge clock source register */
+#define NB_CLOCK_SELECT_REG	(NB_CLOCK_REGS_BASE + 0x10)
+ #define NB_CLOCK_SEL_DDR_PHY_CLK_SEL_OFFSET		10
+ #define NB_CLOCK_SEL_DDR_PHY_CLK_SEL_MASK		0x1
+ #define NB_CLOCK_SEL_A53_CPU_CLK_OFFSET		15
+ #define NB_CLOCK_SEL_A53_CPU_CLK_MASK			0x1
+
+#define TBG_A_REFDIV_GET(reg_val)	((reg_val >> 0) &\
+					NB_TBG_CTRL7_TBG_A_REFDIV_MASK)
+#define TBG_B_REFDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL7_TBG_B_REFDIV_OFFSET) &\
+					NB_TBG_CTRL7_TBG_B_REFDIV_MASK)
+#define	TBG_A_FBDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL0_TBG_A_FBDIV_OFFSET) &\
+					NB_TBG_CTRL0_TBG_A_FBDIV_MASK)
+#define TBG_B_FBDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL0_TBG_B_FBDIV_OFFSET) &\
+					NB_TBG_CTRL0_TBG_B_FBDIV_MASK)
+#define TBG_A_VCODIV_SEL_SE_GET(reg_val)	((reg_val >> 0) &\
+					NB_TBG_CTRL1_TBG_A_VCODIV_SEL_SE_MASK)
+#define TBG_B_VCODIV_SEL_SE_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_OFFSET) &\
+				NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_MASK)
+#define TBG_A_VCODIV_SEL_DIFF_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_OFFSET) &\
+				NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_MASK)
+#define TBG_B_VCODIV_SEL_DIFF_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_OFFSET) &\
+				NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_MASK)
+#define A53_CPU_CLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_SEL_A53_CPU_CLK_OFFSET) &\
+					NB_CLOCK_SEL_A53_CPU_CLK_MASK)
+#define A53_CPU_PCLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_TBG_SEL_A53_CPU_PCLK_OFFSET) &\
+					NB_CLOCK_TBG_SEL_A53_CPU_PCLK_MASK)
+#define A53_CPU_CLK_PRSCL_GET(reg_val)	((reg_val >>\
+				NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_OFFSET) &\
+				NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_MASK)
+#define DDR_PHY_CLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_SEL_DDR_PHY_CLK_SEL_OFFSET) &\
+					NB_CLOCK_SEL_DDR_PHY_CLK_SEL_MASK)
+
+#define TCLK		200
+#define L2_CLK		800
+#define TIMER_CLK	800
+
+enum a3700_clock_line {
+	TBG_A_P = 0,
+	TBG_B_P = 1,
+	TBG_A_S = 2,
+	TBG_B_S = 3
+};
+
+/* Clock source selection */
+enum a3700_clk_select {
+	CLK_SEL_OSC = 0,
+	CLK_SEL_TBG,
+};
+
+/* TBG divider */
+enum a3700_tbg_divider {
+	TBG_DIVIDER_1 = 1,
+	TBG_DIVIDER_2,
+	TBG_DIVIDER_3,
+	TBG_DIVIDER_4,
+	TBG_DIVIDER_5,
+	TBG_DIVIDER_6,
+	TBG_DIVIDER_NUM
+};
+
+static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
+{
+	u32 tbg_M, tbg_N, vco_div;
+	u32 ref, reg_val;
+
+	/* get ref clock */
+	ref = get_ref_clk();
+
+	/* get M, N */
+	reg_val = readl(NB_TBG_CTRL7);
+	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		TBG_A_REFDIV_GET(reg_val) : TBG_B_REFDIV_GET(reg_val);
+	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
+
+	reg_val = readl(NB_TBG_CTRL0);
+	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		TBG_A_FBDIV_GET(reg_val) : TBG_B_FBDIV_GET(reg_val);
+
+	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
+		/* get SE VCODIV */
+		reg_val = readl(NB_TBG_CTRL1);
+		reg_val = (tbg_typ == TBG_A_S) ?
+			  TBG_A_VCODIV_SEL_SE_GET(reg_val) :
+			  TBG_B_VCODIV_SEL_SE_GET(reg_val);
+	} else {
+		/* get DIFF VCODIV */
+		reg_val = readl(NB_TBG_CTRL8);
+		reg_val = (tbg_typ == TBG_A_P) ?
+			  TBG_A_VCODIV_SEL_DIFF_GET(reg_val) :
+			  TBG_B_VCODIV_SEL_DIFF_GET(reg_val);
+	}
+	if (reg_val > 7)
+		return 0; /*invalid*/
+
+	vco_div = 0x1 << reg_val;
+
+	return ((tbg_N * ref) << 2) / (tbg_M * vco_div);
+}
+
+u32 soc_cpu_clk_get(void)
+{
+	u32 tbg, cpu_prscl;
+	enum a3700_clock_line tbg_typ;
+
+	/* 1. check cpu clock select */
+	if (!A53_CPU_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return 0; /* CPU clock is using XTAL output*/
+
+	/* 2. get TBG select */
+	tbg_typ = A53_CPU_PCLK_SEL_GET(readl(NB_CLOCK_TBG_SELECT_REG));
+
+	/* 3. get TBG clock */
+	tbg = get_tbg_clk(tbg_typ);
+	if (tbg == 0)
+		return 0;
+
+	/* 4. get CPU clk divider */
+	cpu_prscl = A53_CPU_CLK_PRSCL_GET(readl(NB_CLOCK_DIV_SEL0_REG));
+	if (cpu_prscl == 7)
+		return 0; /* divider value error */
+
+	return tbg / cpu_prscl;
+}
+
+u32 soc_ddr_clk_get(void)
+{
+	u32 tbg;
+
+	/* 1. check DDR clock select */
+	if (!DDR_PHY_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return 0; /* DDR clock is using XTAL output*/
+
+	/* 2. get TBG_A clock */
+	tbg = get_tbg_clk(TBG_A_S);
+	if (tbg == 0)
+		return 0;
+
+	return tbg >> 1;
+}
+
+/******************************************************************************
+ * Name: get_cpu_clk_src_div
+ *
+ * Description: Get CPU clock source selection and prescaling divider
+ *
+ * Input:	None
+ * Output:	cpu_clk_sel: CPU clock source selection
+ *		cpu_clk_prscl: CPU clock prescaling divider
+ * Return:	Non-zero if failed to get the CPU clock selection and prescaling
+ *******************************************************************************
+ */
+int get_cpu_clk_src_div(u32 *cpu_clk_sel, u32 *cpu_clk_prscl)
+{
+	/* 1. check cpu clock select */
+	if (!A53_CPU_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return -1; /* CPU clock is using XTAL output*/
+
+	/* 2. get TBG select */
+	*cpu_clk_sel = A53_CPU_PCLK_SEL_GET(readl(NB_CLOCK_TBG_SELECT_REG));
+
+	/* 3. get CPU clk divider */
+	*cpu_clk_prscl = A53_CPU_CLK_PRSCL_GET(readl(NB_CLOCK_DIV_SEL0_REG));
+
+	return 0;
+}
+
+u32 soc_tclk_get(void)
+{
+	return TCLK;
+}
+
+u32 soc_l2_clk_get(void)
+{
+	return L2_CLK;
+}
+
+u32 soc_timer_clk_get(void)
+{
+	return TIMER_CLK;
+}
+
+void soc_print_clock_info(void)
+{
+	printf("       CPU     %d [MHz]\n", soc_cpu_clk_get());
+	printf("       L2      %d [MHz]\n", soc_l2_clk_get());
+	printf("       TClock  %d [MHz]\n", soc_tclk_get());
+	printf("       DDR     %d [MHz]\n", soc_ddr_clk_get());
+}
diff --git a/arch/arm/mach-mvebu/armada3700/cpu.c b/arch/arm/mach-mvebu/armada3700/cpu.c
index 7c8e4cade1..4ca8cc4cb9 100644
--- a/arch/arm/mach-mvebu/armada3700/cpu.c
+++ b/arch/arm/mach-mvebu/armada3700/cpu.c
@@ -12,6 +12,8 @@
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <mach/fw_info.h>
+#include <mach/clock.h>
 
 /* Armada 3700 */
 #define MVEBU_GPIO_NB_REG_BASE		(MVEBU_REGISTER(0x13800))
@@ -30,6 +32,15 @@ static struct mm_region mvebu_mem_map[] = {
 		/* RAM */
 		.phys = 0x0UL,
 		.virt = 0x0UL,
+		.size = ATF_REGION_START,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	},
+	/* ATF and TEE region 0x4000000-0x5400000 not mapped */
+	{
+		/* RAM */
+		.phys = ATF_REGION_END,
+		.virt = ATF_REGION_END,
 		.size = 0x80000000UL,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_INNER_SHARE
@@ -84,3 +95,12 @@ u32 get_ref_clk(void)
 	else
 		return 40;
 }
+
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+int print_cpuinfo(void)
+{
+	soc_print_clock_info();
+
+	return 0;
+}
+#endif
diff --git a/arch/arm/mach-mvebu/armada3700/efuse.c b/arch/arm/mach-mvebu/armada3700/efuse.c
new file mode 100644
index 0000000000..2857eb471e
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada3700/efuse.c
@@ -0,0 +1,448 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <vsprintf.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch-armada3700/mbox.h>
+#include <asm/arch-armada3700/efuse.h>
+
+enum a3700_boot_dev {
+	AUTO		= 0,
+	SPINOR		= 1,
+	EMMCNORM	= 2,
+	EMMCALT		= 3,
+	SATA		= 4,
+	SPINAND		= 5,
+	UART		= 6,
+	INVALID		= 7,
+	VECTOR_DIV	= 8,
+	VECTOR_XTAL	= 9,
+
+	MAX_BOOT_DEVS
+};
+
+#define A3700_BOOT_DEV_NAMES	{"AUTO", "SPINOR", "EMMCNORM", "EMMCALT", \
+			"SATA", "SPINAND", "UART", "", "", ""}
+
+struct a3700_efuse_info {
+	/* efuse ID */
+	enum efuse_id		id;
+	/* mailbox operation size bit/byte/word, etc. */
+	enum mbox_opsize	mbopsz;
+	/* efuse row or start row for multi-row values */
+	uint32_t		row;
+	/* number of write operations required for setting the field */
+	uint32_t		numops;
+	/* efuse bit offset within the row for bit size efuses */
+	int32_t			bitoffs[4];
+};
+
+#define A3700_EFUSE_INFO	{ \
+	{ EFUSE_ID_BOOT_DEVICE,       MB_OPSZ_BIT,   1,   4, { 48, 52, 56, 60 } }, \
+	{ EFUSE_ID_KAK_DIGEST,        MB_OPSZ_256B,  8,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_CSK_INDEX,         MB_OPSZ_DWORD, 3,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_AES_KEY,           MB_OPSZ_256B,  26,  1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_ENCRYPTION_EN,     MB_OPSZ_BIT,   0,   2, { 56, 60, 0, 0 } }, \
+	{ EFUSE_ID_JTAG_DIGECT,       MB_OPSZ_256B,  16,  1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_SEC_JTAG_DIS,      MB_OPSZ_BIT,   0,   1, { 24, 0, 0, 0 } }, \
+	{ EFUSE_ID_SEC_JTAG_PERM_DIS, MB_OPSZ_BIT,   0,   1, { 28, 0, 0, 0 } }, \
+	{ EFUSE_ID_AP_JTAG_DIS,       MB_OPSZ_BIT,   0,   1, { 16, 0, 0, 0 } }, \
+	{ EFUSE_ID_AP_JTAG_PERM_DIS,  MB_OPSZ_BIT,   0,   1, { 20, 0, 0, 0 } }, \
+	{ EFUSE_ID_SPI_NAND_CFG,      MB_OPSZ_DWORD, 6,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_PIN,               MB_OPSZ_DWORD, 4,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_TOKEN,             MB_OPSZ_DWORD, 5,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_SPI_CS,            MB_OPSZ_BIT,   1,   2, { 40, 44, 0, 0 } }, \
+	{ EFUSE_ID_EMMC_CLOCK,        MB_OPSZ_BIT,   1,   2, { 32, 36, 0, 0 } }, \
+	{ EFUSE_ID_OPERATION_MODE,    MB_OPSZ_BIT,   1,   2, { 0, 4, 0, 0 } }, \
+	{ EFUSE_ID_UART_DIS,          MB_OPSZ_BIT,   0,   1, { 32, 0, 0, 0 } }, \
+	{ EFUSE_ID_UART_PERM_DIS,     MB_OPSZ_BIT,   0,   1, { 36, 0, 0, 0 } }, \
+	{ EFUSE_ID_ESC_SEQ_DIS,       MB_OPSZ_BIT,   1,   1, { 20, 0, 0, 0 } }, \
+	{ EFUSE_ID_GPIO_TOGGLE_DIS,   MB_OPSZ_BIT,   1,   1, { 16, 0, 0, 0 } }, \
+	{ EFUSE_ID_LONG_KEY_EN,       MB_OPSZ_BIT,   1,   1, { 12, 0, 0, 0 } } \
+}
+
+static struct a3700_efuse_info efuse_info[EFUSE_ID_MAX] = A3700_EFUSE_INFO;
+static char *bdnames[] = A3700_BOOT_DEV_NAMES;
+
+/******************************************************************************
+ *	efuse_id_valid
+ ******************************************************************************/
+int efuse_id_valid(enum efuse_id fid)
+{
+	if (fid < EFUSE_ID_MAX)
+		return 1;
+	else
+		return 0;
+}
+
+/******************************************************************************
+ *	efuse_write
+ ******************************************************************************/
+int efuse_write(enum efuse_id fid, const char *value)
+{
+	uint32_t		args[MBOX_MAX_ARGS];
+	enum a3700_boot_dev	bdev;
+	uint32_t		info_idx, numval = 0;
+	uint32_t		numwords, ascii_words;
+	char			buf[9];
+	int			status, n;
+	enum mbox_status	cmd_stat;
+	uint64_t		fullrow;
+	char			*str, *strcopy, *substr;
+	uint32_t		val[4];
+
+	/* Find efuse info with length and offset */
+	for (info_idx = 0; info_idx < EFUSE_ID_MAX; info_idx++) {
+		if (efuse_info[info_idx].id == fid)
+			break;
+	}
+
+	if (info_idx == EFUSE_ID_MAX) {
+		printf("%s: Unsupported eFuse ID\n", __func__);
+		return 1;
+	}
+
+	/* Each word is coded by 8 ASCII characters, one character per nibble */
+	numwords = strlen(value) >> 3;
+	memset(buf, 0, 9);
+	memset(args, 0, MBOX_MAX_ARGS * sizeof(uint32_t));
+
+	/* parse input parameter */
+	switch (fid) {
+	case EFUSE_ID_BOOT_DEVICE:
+		for (bdev = 0; bdev < MAX_BOOT_DEVS; bdev++) {
+			if (strcmp(value, bdnames[bdev]) == 0)
+				break;
+		}
+		if (bdev == MAX_BOOT_DEVS) {
+			printf("%s: Unsupported Boot Device\n", __func__);
+			return 1;
+		}
+		numval = bdev;
+		break;
+
+	case EFUSE_ID_KAK_DIGEST:
+	case EFUSE_ID_AES_KEY:
+	case EFUSE_ID_JTAG_DIGECT:
+	case EFUSE_ID_PIN:
+	case EFUSE_ID_TOKEN:
+		/* TODO - add support for 512b keys if needed */
+		if (efuse_info[info_idx].mbopsz == MB_OPSZ_256B) {
+			ascii_words = 8;
+		} else if (efuse_info[info_idx].mbopsz == MB_OPSZ_DWORD) {
+			ascii_words = 2;
+		} else {
+			printf("Bad operation size for this key!\n");
+			return 1;
+		}
+		if (numwords != ascii_words) {
+			printf("%s: Unsupported digest length (%d) - expected %d bytes\n",
+			       __func__, numwords << 3, ascii_words << 3);
+			return 1;
+		}
+		/* Convert ASCII representation to WORD integer arguments
+		   The eFuse has to have LSB part in lower rows */
+		for (n = 0; n < numwords; n++) {
+			/* 8 ASCII characters in WORD argument */
+			memcpy(buf, &value[n * 8], 8);
+			args[numwords - n - 1] = simple_strtoul(buf, 0, 16);
+		}
+		break;
+
+	case EFUSE_ID_CSK_INDEX:
+		numval = simple_strtoul(value, 0, 10);
+		if (numval > 15) {
+			printf("%s: Invalid CSK index %d, expected [0..15]\n",
+			       __func__, numval);
+			return 1;
+		}
+		/* The CSK key validity is stored in a single efuse row,
+		   but the bit offset depends on CSK index.
+		   Each index is selected by majority vote out of 3 bits.
+		   In order to set single index, 2 or 3 physical bits should
+		   be programmed. Gap between index start positions is 4 bits.
+		 */
+		fullrow = 0x7 << (4 * numval);
+		args[0] = fullrow & 0xFFFFFFFF;
+		args[1] = (fullrow >> 32) & 0xFFFFFFFF;
+		break;
+
+	case EFUSE_ID_ENCRYPTION_EN:
+		numval = simple_strtoul(value, 0, 16);
+		if ((numval != 0x11) && (numval != 0x10) && (numval != 0x1)) {
+			printf("%s: Invalid value %x, expected 1, 10 or 11\n",
+			       __func__, numval);
+			return 1;
+		}
+		numval = (numval & 1) | ((numval & 0x10) >> 3);
+		break;
+
+	case EFUSE_ID_SEC_JTAG_DIS:
+	case EFUSE_ID_SEC_JTAG_PERM_DIS:
+	case EFUSE_ID_AP_JTAG_DIS:
+	case EFUSE_ID_AP_JTAG_PERM_DIS:
+	case EFUSE_ID_UART_DIS:
+	case EFUSE_ID_UART_PERM_DIS:
+	case EFUSE_ID_ESC_SEQ_DIS:
+	case EFUSE_ID_GPIO_TOGGLE_DIS:
+	case EFUSE_ID_LONG_KEY_EN:
+	case EFUSE_ID_EMMC_CLOCK:
+		numval = simple_strtoul(value, 0, 10);
+		if (numval != 1) {
+			printf("%s: Invalid value %d, expected 1\n",
+			       __func__, numval);
+			return 1;
+		}
+		break;
+
+	case EFUSE_ID_OPERATION_MODE:
+	case EFUSE_ID_SPI_CS:
+		numval = simple_strtoul(value, 0, 10);
+		if (numval > 3) {
+			printf("%s: Invalid value %d, expected [0..3]\n",
+			       __func__, numval);
+			return 1;
+		}
+		break;
+
+	case EFUSE_ID_SPI_NAND_CFG:
+		strcopy = strdup(value);
+		if (strcopy == NULL) {
+			printf("%s: Unable to duplicate parameters list!\n",
+			       __func__);
+			return 1;
+		}
+		str = strcopy;
+		for (n = 0; n < 4; n++) {
+			if (str == NULL) {
+				printf("%s: Invalid parameters list, expected PZ.BP.SO.SN\n",
+				       __func__);
+				return 1;
+			}
+			substr = strsep(&str, ".");
+			val[n] = simple_strtoul(substr, 0, 10);
+			if (((n == 0) && (val[n] > 0xFFFF)) ||
+			    ((n > 0) && (val[n] > 0xFF))) {
+				printf("%s: Invalid value[%d] %d, expected %s\n",
+				       __func__, n, val[n], n == 0 ?
+				       "0 - 65535" : "0 - 255");
+				return 1;
+			}
+		}
+		free(strcopy);
+		/* PZ - bit[15:0], PB - bit[23:16] */
+		args[0] = (val[1] << 16) | val[0];
+		/* SO - bit[39:32], SN - bit[55:48] */
+		args[1] = (val[3] << 16) | val[2];
+		break;
+
+	default:
+		printf("%s: This eFuse ID write function is not implemented\n",
+		       __func__);
+		return 1;
+	}
+
+	/* Send command to the remote CPU */
+	for (n = 0; n < efuse_info[info_idx].numops; n++) {
+		/* for bit fields write 1 bit a time */
+		if (efuse_info[info_idx].mbopsz == MB_OPSZ_BIT)
+			args[0] = (numval >> n) & 1;
+
+		status = mbox_send(efuse_info[info_idx].mbopsz,
+				   MB_OP_WRITE,
+				   efuse_info[info_idx].row,
+				   efuse_info[info_idx].bitoffs[n],
+				   args);
+
+		if (status != 0) {
+			printf("%s: Failed to dispatch command to remote CPU (n=%d)\n",
+			       __func__, n);
+			break;
+		}
+
+		/* Ensure the command execution ended on remote CPU */
+		cmd_stat = MB_STAT_SUCCESS;
+		status = mbox_receive(&cmd_stat, args, MBOX_CMD_TIMEOUT);
+		if (status != 0 || cmd_stat != MB_STAT_SUCCESS) {
+			printf("%s: Remote command execution failed (n=%d). Error local=%d, remote=%d\n",
+			       __func__, n, status, cmd_stat);
+			break;
+		}
+	}
+
+	return status;
+}
+
+/******************************************************************************
+ *	efuse_read
+ ******************************************************************************/
+int efuse_read(enum efuse_id fid, char *value)
+{
+	uint32_t		args[MBOX_MAX_ARGS];
+	uint32_t		info_idx, n;
+	uint32_t		count;
+	int			status;
+	enum mbox_status	cmd_stat;
+	uint32_t		numval = 0;
+	uint32_t		page_sz, page_block, spare_offs, spare_page;
+	uint32_t		numwords;
+	uint64_t		fullrow;
+
+	/* Find efuse info with length and offset */
+	for (info_idx = 0; info_idx < EFUSE_ID_MAX; info_idx++) {
+		if (efuse_info[info_idx].id == fid)
+			break;
+	}
+	if (info_idx == EFUSE_ID_MAX) {
+		printf("%s: Unsupported eFuse ID\n", __func__);
+		return 1;
+	}
+
+	memset(args, 0, MBOX_MAX_ARGS * sizeof(uint32_t));
+
+	/* Send command to the remote CPU */
+	for (n = 0; n < efuse_info[info_idx].numops; n++) {
+		status = mbox_send(efuse_info[info_idx].mbopsz,
+				   MB_OP_READ,
+				   efuse_info[info_idx].row,
+				   efuse_info[info_idx].bitoffs[n],
+				   args);
+
+		if (status != 0) {
+			printf("%s: Failed to dispatch command to remote CPU (n=%d)\n",
+			       __func__, n);
+			return status;
+		}
+
+		/*
+		 * Ensure the command execution ended
+		 * on remote CPU and get the result
+		 */
+		cmd_stat = MB_STAT_SUCCESS;
+		status = mbox_receive(&cmd_stat, args, MBOX_CMD_TIMEOUT);
+		if (status != 0) {
+			printf("%s: Failed locally (n=%d). Error=%d\n",
+			       __func__, n, status);
+			return status;
+		} else if (cmd_stat != MB_STAT_SUCCESS) {
+			printf("%s: Failed on remote (n=%d). Error=%d\n",
+			       __func__, n, cmd_stat);
+			return 1;
+		}
+
+		/* for bit fields collect 1 bit a time */
+		if (efuse_info[info_idx].mbopsz == MB_OPSZ_BIT)
+			numval |= (args[0] & 1) << n;
+	}
+
+	/* format the output value */
+	switch (fid) {
+	case EFUSE_ID_BOOT_DEVICE:
+		if (numval >= MAX_BOOT_DEVS || numval == INVALID)
+			sprintf(value, "INVALID VALUE (%d)", numval);
+		else
+			sprintf(value, "%s (%d)", bdnames[numval], numval);
+		break;
+
+	case EFUSE_ID_KAK_DIGEST:
+	case EFUSE_ID_AES_KEY:
+	case EFUSE_ID_JTAG_DIGECT:
+	case EFUSE_ID_PIN:
+	case EFUSE_ID_TOKEN:
+		/* TODO - add support for 512b keys if needed */
+		if (efuse_info[info_idx].mbopsz == MB_OPSZ_256B) {
+			numwords = 8;
+		} else if (efuse_info[info_idx].mbopsz == MB_OPSZ_DWORD) {
+			numwords = 2;
+		} else {
+			printf("Bad operation size for this key!\n");
+			return 1;
+		}
+		/* The eFuse has LSB part in lower rows */
+		for (n = 0; n < numwords; n++)
+			sprintf(value + n * 8, "%08X", args[numwords - n - 1]);
+		break;
+
+	case EFUSE_ID_CSK_INDEX:
+		/* show all valid CSK IDs */
+		count = 0;
+		fullrow = args[1];	/* MSB */
+		fullrow <<= 32;
+		fullrow |= args[0];	/* LSB */
+		for (n = 0; n < 15; n++) {
+			/* Each CSK validity is a 3 bit majority vote
+			   The distance between fileds is 4 bits */
+			numval = (fullrow >> (n * 4)) & 0x7;
+			/* Two or more bits set - CSK is valid */
+			if (numval > 4 || numval == 3)
+				count += sprintf(value + count, "%d ", n);
+		}
+		if (count == 0)
+			sprintf(value, "NONE");
+		break;
+
+	case EFUSE_ID_ENCRYPTION_EN:
+		sprintf(value, "%01d%01d", (numval >> 1) & 1, numval & 1);
+		break;
+
+	case EFUSE_ID_LONG_KEY_EN:
+		sprintf(value, "%s (%d)", numval == 0 ?
+			"DISABLED" : "ENABLED", numval);
+		break;
+
+	case EFUSE_ID_SEC_JTAG_DIS:
+	case EFUSE_ID_SEC_JTAG_PERM_DIS:
+	case EFUSE_ID_AP_JTAG_DIS:
+	case EFUSE_ID_AP_JTAG_PERM_DIS:
+	case EFUSE_ID_UART_DIS:
+	case EFUSE_ID_UART_PERM_DIS:
+	case EFUSE_ID_ESC_SEQ_DIS:
+	case EFUSE_ID_GPIO_TOGGLE_DIS:
+		sprintf(value, "%s (%d)", numval == 1 ?
+			"DISABLED" : "ENABLED", numval);
+		break;
+
+	case EFUSE_ID_OPERATION_MODE:
+	case EFUSE_ID_SPI_CS:
+		sprintf(value, "%d", numval);
+		break;
+
+	case EFUSE_ID_EMMC_CLOCK:
+		sprintf(value, "%s (%d)", numval == 0 ?
+			"12.5MHz" : "50MHz", numval);
+		break;
+
+	case EFUSE_ID_SPI_NAND_CFG:
+		page_sz = args[0] & 0xFFFF;		/* bit[15:0] */
+		page_block = (args[0] >> 16) & 0xFF;	/* bit[23:16] */
+		/* bit[39:32], value 1 means byte 0 */
+		spare_offs = args[1] & 0xFF;
+		/* bit[55:48], value 1 means page 0 */
+		spare_page = (args[1] >> 16) & 0xFF;
+		sprintf(value, "%04d.%02d.%02d.%02d", page_sz,
+			page_block, spare_offs, spare_page);
+		break;
+
+	default:
+		sprintf(value, "NOT IMPLEMENTED");
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ *	efuse_raw_dump
+ ******************************************************************************/
+void efuse_raw_dump(void)
+{
+	printf("Raw eFuse dump is not supported on this platform\n");
+	return;
+}
diff --git a/arch/arm/mach-mvebu/armada3700/mbox.c b/arch/arm/mach-mvebu/armada3700/mbox.c
new file mode 100644
index 0000000000..e7071e7d5a
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada3700/mbox.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-armada3700/mbox.h>
+#include <asm/arch-armada3700/efuse.h>
+
+enum a3700_boot_dev {
+	AUTO		= 0,
+	SPINOR		= 1,
+	EMMCNORM	= 2,
+	EMMCALT		= 3,
+	SATA		= 4,
+	SPINAND		= 5,
+	UART		= 6,
+	INVALID		= 7,
+	VECTOR_DIV	= 8,
+	VECTOR_XTAL	= 9,
+
+	MAX_BOOT_DEVS
+};
+
+#define A3700_BOOT_DEV_NAMES	{"AUTO", "SPINOR", "EMMCNORM", "EMMCALT", \
+			"SATA", "SPINAND", "UART", "", "", ""}
+
+struct a3700_efuse_info {
+	/* efuse ID */
+	enum efuse_id		id;
+	/* mailbox operation size bit/byte/word, etc. */
+	enum mbox_opsize	mbopsz;
+	/* efuse row or start row for multi-row values */
+	uint32_t		row;
+	/* number of write operations required for setting the field */
+	uint32_t		numops;
+	/* efuse bit offset within the row for bit size efuses */
+	int32_t			bitoffs[4];
+};
+
+#define A3700_EFUSE_INFO	{ \
+	{ EFUSE_ID_BOOT_DEVICE,       MB_OPSZ_BIT,   1,   4, { 48, 52, 56, 60 } }, \
+	{ EFUSE_ID_KAK_DIGEST,        MB_OPSZ_256B,  8,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_CSK_INDEX,         MB_OPSZ_DWORD, 3,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_AES_KEY,           MB_OPSZ_256B,  26,  1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_ENCRYPTION_EN,     MB_OPSZ_BIT,   0,   2, { 56, 60, 0, 0 } }, \
+	{ EFUSE_ID_JTAG_DIGECT,       MB_OPSZ_256B,  16,  1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_SEC_JTAG_DIS,      MB_OPSZ_BIT,   0,   1, { 24, 0, 0, 0 } }, \
+	{ EFUSE_ID_SEC_JTAG_PERM_DIS, MB_OPSZ_BIT,   0,   1, { 28, 0, 0, 0 } }, \
+	{ EFUSE_ID_AP_JTAG_DIS,       MB_OPSZ_BIT,   0,   1, { 16, 0, 0, 0 } }, \
+	{ EFUSE_ID_AP_JTAG_PERM_DIS,  MB_OPSZ_BIT,   0,   1, { 20, 0, 0, 0 } }, \
+	{ EFUSE_ID_SPI_NAND_CFG,      MB_OPSZ_DWORD, 6,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_PIN,               MB_OPSZ_DWORD, 4,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_TOKEN,             MB_OPSZ_DWORD, 5,   1, { 0, 0, 0, 0 } }, \
+	{ EFUSE_ID_SPI_CS,            MB_OPSZ_BIT,   1,   2, { 40, 44, 0, 0 } }, \
+	{ EFUSE_ID_EMMC_CLOCK,        MB_OPSZ_BIT,   1,   2, { 32, 36, 0, 0 } }, \
+	{ EFUSE_ID_OPERATION_MODE,    MB_OPSZ_BIT,   1,   2, { 0, 4, 0, 0 } }, \
+	{ EFUSE_ID_UART_DIS,          MB_OPSZ_BIT,   0,   1, { 32, 0, 0, 0 } }, \
+	{ EFUSE_ID_UART_PERM_DIS,     MB_OPSZ_BIT,   0,   1, { 36, 0, 0, 0 } }, \
+	{ EFUSE_ID_ESC_SEQ_DIS,       MB_OPSZ_BIT,   1,   1, { 20, 0, 0, 0 } }, \
+	{ EFUSE_ID_GPIO_TOGGLE_DIS,   MB_OPSZ_BIT,   1,   1, { 16, 0, 0, 0 } }, \
+	{ EFUSE_ID_LONG_KEY_EN,       MB_OPSZ_BIT,   1,   1, { 12, 0, 0, 0 } } \
+}
+
+/*****************************************************************************
+ *	mbox_send
+ *****************************************************************************/
+int mbox_send(enum mbox_opsize opsz, enum mbox_op op, uint32_t row,
+	      uint32_t offs, uint32_t *args)
+{
+	uint32_t	params[MBOX_MAX_ARGS];
+	uint32_t	n, params_to_send;
+
+	if (args == 0) {
+		printf("%s: Invalid argument\n", __func__);
+		return 1;
+	}
+
+	if (op != MB_OP_READ && op != MB_OP_WRITE) {
+		printf("%s: Invalid operation\n", __func__);
+		return 1;
+	}
+
+	memset(params, 0, MBOX_MAX_ARGS * sizeof(uint32_t));
+
+	/* First parameter in the list describes eFuse row */
+	params[0] = row;
+
+	switch (opsz) {
+	case MB_OPSZ_BIT:
+	case MB_OPSZ_BYTE:
+	case MB_OPSZ_WORD:
+		params_to_send = 3;
+		params[1] = offs;
+		params[2] = args[0];
+		break;
+	case MB_OPSZ_DWORD:
+		params_to_send = 3;
+		params[1] = args[0];
+		params[2] = args[1];
+		break;
+	case MB_OPSZ_256B:
+		params_to_send = 9;
+		memcpy(&params[1], args, 8 * sizeof(uint32_t));
+		break;
+	default:
+		printf("%s: Invalid size\n", __func__);
+		return 1;
+	}
+
+
+	/* First, fill all command arguments */
+	for (n = 0; n < params_to_send; n++) {
+		debug("=>MBOX WRITE PARAM[%d] = %08X\n", n, params[n]);
+		writel(params[n], (long)MBOX_SEND_ARG_OFFS(n));
+	}
+
+	/* Writing command triggers mailbox dispatch and
+	   intarrupt on secure CPU side */
+	debug("=>MBOX WRITE CMD = %08X\n", MBOX_COMMAND(opsz, op));
+	writel(MBOX_COMMAND(opsz, op), MBOX_SEND_CMD_OFFS);
+
+	return 0;
+}
+
+/*****************************************************************************
+ *	mbox_receive - BLOCKING
+ *****************************************************************************/
+int mbox_receive(enum mbox_status *stat, uint32_t *args,
+		 uint32_t timeout_us)
+{
+	uint32_t n;
+	uint32_t regval;
+
+	if (args == 0) {
+		*stat = MB_STAT_BAD_ARGUMENT;
+		return 1;
+	}
+
+	/* Poll for secure CPU command completion */
+	for (n = 0; n < timeout_us; n++) {
+		regval = readl(MBOX_SEC_CPU_INT_STAT_REG);
+		if (regval & MBOX_SEC_CPU_CMD_SET)
+			break;
+		mdelay(100);
+	}
+
+	if (n == timeout_us) {
+		printf("%s: MB timeout\n", __func__);
+		return 1;
+	}
+
+	/* Read comamnd status and arguments */
+	for (n = 0; n < MBOX_MAX_ARGS; n++) {
+		args[n] = readl((long)MBOX_RECEIVE_ARG_OFFS(n));
+		debug("<=MBOX READ ARG[%d] = %08X\n", n, args[n]);
+	}
+
+	*stat = readl(MBOX_RECEIVE_STAT_OFFS);
+	debug("<=MBOX READ STATUS = %08X\n", *stat);
+
+	/* Reset host interrupt */
+	regval = readl(MBOX_HOST_INT_RESET) | MBOX_SEC_CPU_CMD_COMPLETE;
+	writel(regval, MBOX_HOST_INT_RESET);
+
+	return 0;
+}
diff --git a/arch/arm/mach-mvebu/armada8k/Makefile b/arch/arm/mach-mvebu/armada8k/Makefile
index 82cb25b417..4391a0199c 100644
--- a/arch/arm/mach-mvebu/armada8k/Makefile
+++ b/arch/arm/mach-mvebu/armada8k/Makefile
@@ -3,4 +3,6 @@
 # Copyright (C) 2016 Stefan Roese <sr@denx.de>
 
 obj-y = cpu.o
+obj-y += soc.o
+obj-y += clock.o
 obj-y += cache_llc.o
diff --git a/arch/arm/mach-mvebu/armada8k/clock.c b/arch/arm/mach-mvebu/armada8k/clock.c
new file mode 100644
index 0000000000..3b02bea127
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada8k/clock.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <mach/clock.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#ifndef CONFIG_PALLADIUM
+#define CONFIG_MSS_FREQUENCY    (200 * 1000000)
+#else
+#define CONFIG_MSS_FREQUENCY    (384000)
+#endif
+
+u32 soc_ring_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_AP_FABRIC_FREQ, &sar);
+	return sar.freq;
+}
+
+u32 soc_mss_clk_get(void)
+{
+	return CONFIG_MSS_FREQUENCY;
+}
+
+u32 soc_cpu_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_CPU_FREQ, &sar);
+	return sar.freq;
+}
+
+u32 soc_ddr_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_DDR_FREQ, &sar);
+	return sar.freq;
+}
+
+void soc_print_clock_info(void)
+{
+	printf("Clock:  CPU     %-4d [MHz]\n", soc_cpu_clk_get() / MHz);
+	printf("\tDDR     %-4d [MHz]\n", soc_ddr_clk_get() / MHz);
+	printf("\tFABRIC  %-4d [MHz]\n", soc_ring_clk_get() / MHz);
+	printf("\tMSS     %-4d [MHz]\n", soc_mss_clk_get() / MHz);
+}
diff --git a/arch/arm/mach-mvebu/armada8k/cpu.c b/arch/arm/mach-mvebu/armada8k/cpu.c
index 959a7cff76..fe216c2c4a 100644
--- a/arch/arm/mach-mvebu/armada8k/cpu.c
+++ b/arch/arm/mach-mvebu/armada8k/cpu.c
@@ -7,11 +7,15 @@
 #include <dm.h>
 #include <fdtdec.h>
 #include <linux/libfdt.h>
+#include <linux/sizes.h>
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <mach/clock.h>
+#include <mach/soc.h>
+#include <mach/fw_info.h>
 
 /* Armada 7k/8k */
 #define MVEBU_RFU_BASE			(MVEBU_REGISTER(0x6f0000))
@@ -22,65 +26,45 @@
 #define BOOT_MODE_MASK			0x3f
 #define BOOT_MODE_OFFSET		4
 
-/*
- * The following table includes all memory regions for Armada 7k and
- * 8k SoCs. The Armada 7k is missing the CP110 slave regions here. Lets
- * define these regions at the beginning of the struct so that they
- * can be easier removed later dynamically if an Armada 7k device is detected.
- * For a detailed memory map, please see doc/mvebu/armada-8k-memory.txt
- */
-#define ARMADA_7K8K_COMMON_REGIONS_START	2
 static struct mm_region mvebu_mem_map[] = {
 	/* Armada 80x0 memory regions include the CP1 (slave) units */
 	{
-		/* SRAM, MMIO regions - CP110 slave region */
-		.phys = 0xf4000000UL,
-		.virt = 0xf4000000UL,
-		.size = 0x02000000UL,	/* 32MiB internal registers */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
-	},
-	{
-		/* PCI CP1 regions */
-		.phys = 0xfa000000UL,
-		.virt = 0xfa000000UL,
-		.size = 0x04000000UL,	/* 64MiB CP110 slave PCI space */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
-	},
-	/* Armada 80x0 and 70x0 common memory regions start here */
-	{
-		/* RAM */
+		/* RAM 0-64MB */
 		.phys = 0x0UL,
 		.virt = 0x0UL,
-		.size = 0x80000000UL,
+		.size = ATF_REGION_START,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_INNER_SHARE
 	},
+	/* ATF and TEE region 0x4000000-0x5400000 not mapped */
 	{
-		/* SRAM, MMIO regions - AP806 region */
-		.phys = 0xf0000000UL,
-		.virt = 0xf0000000UL,
-		.size = 0x01000000UL,	/* 16MiB internal registers */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
+		/* RAM 66MB-2GB */
+		.phys = ATF_REGION_END,
+		.virt = ATF_REGION_END,
+		.size = SZ_2G,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
 	},
 	{
-		/* SRAM, MMIO regions - CP110 master region */
-		.phys = 0xf2000000UL,
-		.virt = 0xf2000000UL,
-		.size = 0x02000000UL,	/* 32MiB internal registers */
+		/* MMIO regions */
+		.phys = MMIO_REGS_PHY_BASE,
+		.virt = MMIO_REGS_PHY_BASE,
+		.size = SZ_1G,
+
 		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
 			 PTE_BLOCK_NON_SHARE
 	},
+#if defined(CONFIG_PCIE_DW_MVEBU_EP)
 	{
-		/* PCI CP0 regions */
-		.phys = 0xf6000000UL,
-		.virt = 0xf6000000UL,
-		.size = 0x04000000UL,	/* 64MiB CP110 master PCI space */
+		/* PCIe OCP regions */
+		.phys = MV_PCIE_EP_REGION_BASE,
+		.virt = MV_PCIE_EP_REGION_BASE,
+		.size = MV_PCIE_EP_REGION_SIZE,
+
 		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
 			 PTE_BLOCK_NON_SHARE
 	},
+#endif
 	{
 		0,
 	}
@@ -90,15 +74,6 @@ struct mm_region *mem_map = mvebu_mem_map;
 
 void enable_caches(void)
 {
-	/*
-	 * Armada 7k is not equipped with the CP110 slave CP. In case this
-	 * code runs on an Armada 7k device, lets remove the CP110 slave
-	 * entries from the memory mapping by moving the start to the
-	 * common regions.
-	 */
-	if (of_machine_is_compatible("marvell,armada7040"))
-		mem_map = &mvebu_mem_map[ARMADA_7K8K_COMMON_REGIONS_START];
-
 	icache_enable();
 	dcache_enable();
 }
@@ -112,24 +87,6 @@ void reset_cpu(ulong ignored)
 	writel(reg, RFU_GLOBAL_SW_RST);
 }
 
-/*
- * TODO - implement this functionality using platform
- *        clock driver once it gets available
- * Return NAND clock in Hz
- */
-u32 mvebu_get_nand_clock(void)
-{
-	unsigned long NAND_FLASH_CLK_CTRL = 0xF2440700UL;
-	unsigned long NF_CLOCK_SEL_MASK = 0x1;
-	u32 reg;
-
-	reg = readl(NAND_FLASH_CLK_CTRL);
-	if (reg & NF_CLOCK_SEL_MASK)
-		return 400 * 1000000;
-	else
-		return 250 * 1000000;
-}
-
 int mmc_get_env_dev(void)
 {
 	u32 reg;
@@ -149,3 +106,13 @@ int mmc_get_env_dev(void)
 
 	return CONFIG_SYS_MMC_ENV_DEV;
 }
+
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+int print_cpuinfo(void)
+{
+	soc_print_device_info();
+	soc_print_clock_info();
+	soc_print_system_cache_info();
+	return 0;
+}
+#endif
diff --git a/arch/arm/mach-mvebu/armada8k/soc.c b/arch/arm/mach-mvebu/armada8k/soc.c
new file mode 100644
index 0000000000..6ace53a9dd
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada8k/soc.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/arch-armada8k/cache_llc.h>
+#include <asm/io.h>
+#include <asm/arch/soc.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <dm/device.h>
+
+#define CP_DEV_ID_STATUS_REG		(MVEBU_REGISTER(0x2400240))
+#define DEVICE_ID_STATUS_MASK		0xffff
+#define AP_DEV_ID_STATUS_REG		(SOC_REGS_PHY_BASE + 0x6F8240)
+#define JTAG_DEV_ID_STATUS_REG		(SOC_REGS_PHY_BASE + 0x6F8244)
+#define AP_DEV_ID_STATUS_MASK		0xfff
+#define AP_DEV_REV_ID_STATUS_MASK	0xf0000000
+#define SW_REV_STATUS_OFFSET		16
+#define AP_REV_STATUS_OFFSET		28
+#define SW_REV_STATUS_MASK		0xf
+
+#define A8040_DEVICE_ID			0x8040
+#define CN9130_DEVICE_ID		0x7025
+
+#define AP807_ID			0x807
+
+/* to differentiate differnet SOC with similar DEVICE_ID */
+#define AP807_SHARED_DEVICE_ID_A0	0x7045
+#define AP807_SHARED_DEVICE_ID_A1	0x6025
+
+#define DEVICE_ID_SUB_REV		(MVEBU_REGISTER(0x2400230))
+#define DEVICE_ID_SUB_REV_OFFSET	7
+#define DEVICE_ID_SUB_REV_MASK		(0xffff << DEVICE_ID_SUB_REV_OFFSET)
+
+#define NF_CLOCK_SEL_MASK		0x1
+#define SOC_MUX_NAND_EN_MASK		0x1
+#define CLOCK_1Mhz			1000000
+
+struct mochi_module {
+	u32 module_type;
+	u32 module_rev;
+};
+
+struct soc_info {
+	struct mochi_module soc;
+	char *soc_name;
+	struct mochi_module ap;
+	struct mochi_module cp;
+	u32 ap_num;
+	u32 cp_num;
+	u32 sub_rev;
+};
+
+static struct soc_info soc_info_table[] = {
+	{ {0x7025, 0}, "cn9130-A1",	{0x807, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x7025, 0}, "cn9131-A1",	{0x807, 2}, {0x115, 0}, 1, 2, 0},
+	{ {0x7025, 0}, "cn9132-A1",	{0x807, 2}, {0x115, 0}, 1, 3, 0},
+	{ {0x6025, 0}, "Armada3900-A1",	{0x807, 1}, {0x115, 0}, 1, 1, 0},
+	{ {0x6025, 0}, "Armada3900-A3",	{0x807, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x7045, 0}, "Armada3900-A0", {0x807, 0}, {0x115, 0}, 1, 1, 0},
+	{ {0x7040, 1}, "Armada7040-A1", {0x806, 1}, {0x110, 1}, 1, 1, 0},
+	{ {0x7040, 2}, "Armada7040-A2", {0x806, 1}, {0x110, 2}, 1, 1, 0},
+	{ {0x7045, 0}, "Armada7040-B0", {0x806, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x8040, 1}, "Armada8040-A1", {0x806, 1}, {0x110, 1}, 1, 2, 0},
+	{ {0x8040, 2}, "Armada8040-A2", {0x806, 1}, {0x110, 2}, 1, 2, 0},
+	{ {0x8045, 0}, "Armada8040-B0", {0x806, 2}, {0x115, 0}, 1, 2, 0},
+};
+
+int mvebu_dfx_smc(u32 subfid, u32 *reg, u32 addr, u32 val)
+{
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = MV_SIP_DFX;
+	pregs.regs[1] = subfid;
+	pregs.regs[2] = addr;
+	pregs.regs[3] = val;
+
+	smc_call(&pregs);
+
+	if (pregs.regs[0] == 0 && reg)
+		*reg = pregs.regs[1];
+
+	debug("%s: sub-fid %d, reg_val 0x%x, addr 0x%x, val 0x%x, ret %ld\n",
+	      __func__, subfid, reg ? *reg : -1, addr, val, pregs.regs[0]);
+
+	return pregs.regs[0];
+}
+
+static int get_soc_type_rev(u32 *type, u32 *rev)
+{
+	*type = readl(CP_DEV_ID_STATUS_REG) & DEVICE_ID_STATUS_MASK;
+	*rev = (readl(CP_DEV_ID_STATUS_REG) >> SW_REV_STATUS_OFFSET) &
+		SW_REV_STATUS_MASK;
+
+	return 0;
+}
+
+static int get_ap_soc_type(u32 *type)
+{
+	int ret;
+
+	/* Try read it with firmware use, if fails try legacy */
+	ret = mvebu_dfx_sread(type, AP_DEV_ID_STATUS_REG);
+	if (ret != SMCCC_RET_SUCCESS)
+		*type = readl(AP_DEV_ID_STATUS_REG);
+
+	*type &= AP_DEV_ID_STATUS_MASK;
+
+	return 0;
+}
+
+static int get_ap_soc_rev(u32 *rev)
+{
+	int ret;
+
+	/* Try read it with firmware use, if fails try legacy */
+	ret = mvebu_dfx_sread(rev, JTAG_DEV_ID_STATUS_REG);
+	if (ret != SMCCC_RET_SUCCESS)
+		*rev = readl(JTAG_DEV_ID_STATUS_REG);
+
+	*rev = (*rev & AP_DEV_REV_ID_STATUS_MASK) >> AP_REV_STATUS_OFFSET;
+	return 0;
+}
+
+static int get_soc_sub_rev(u32 *sub_rev)
+{
+	u32 soc_type, rev, ap_type;
+
+	get_soc_type_rev(&soc_type, &rev);
+	get_ap_soc_type(&ap_type);
+
+	if (ap_type == AP807_ID) {
+		*sub_rev = readl(DEVICE_ID_SUB_REV) & DEVICE_ID_SUB_REV_MASK;
+		*sub_rev >>= DEVICE_ID_SUB_REV_OFFSET;
+		return 0;
+	}
+
+	*sub_rev = 0;
+
+	return -1;
+}
+
+static int get_soc_table_index(u32 *index)
+{
+	u32 soc_type;
+	u32 rev, i, ret = 1;
+	u32 ap_type, sub_rev, ap_rev;
+
+	*index = 0;
+	get_soc_type_rev(&soc_type, &rev);
+	get_ap_soc_type(&ap_type);
+	get_ap_soc_rev(&ap_rev);
+
+	/* specific checks needed for 9131,9132, */
+	/* since their soc+ap characteristics same as 9130*/
+	if ((of_machine_is_compatible("marvell,cn9131-db"))) {
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if (strcmp(soc_info_table[i].soc_name,
+				   "cn9131-A1") != 0)
+				continue;
+			*index = i;
+			ret = 0;
+		}
+	} else if ((of_machine_is_compatible("marvell,cn9132-db"))) {
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if (strcmp(soc_info_table[i].soc_name,
+				   "cn9132-A1") != 0)
+				continue;
+			*index = i;
+			ret = 0;
+		}
+	} else	{
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if ((soc_type != soc_info_table[i].soc.module_type) ||
+			    (rev != soc_info_table[i].soc.module_rev) ||
+				ap_type != soc_info_table[i].ap.module_type ||
+				(ap_rev != soc_info_table[i].ap.module_rev))
+				continue;
+
+			if (!get_soc_sub_rev(&sub_rev) &&
+			    (sub_rev != soc_info_table[i].sub_rev))
+				continue;
+
+			*index = i;
+			ret = 0;
+		}
+	}
+
+	if (ret)
+		pr_err("using default SoC info: %s\n",
+		       soc_info_table[*index].soc_name);
+
+	return ret;
+}
+
+static int get_soc_name(char **soc_name)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*soc_name = soc_info_table[index].soc_name;
+
+	return 0;
+}
+
+int soc_get_ap_cp_num(void *ap_num, void *cp_num)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*((u32 *)ap_num) = soc_info_table[index].ap_num;
+	*((u32 *)cp_num) = soc_info_table[index].cp_num;
+
+	return 0;
+}
+
+/* Get SoC's Application Processor (AP) module type and revision */
+static int get_ap_type_rev(u32 *type, u32 *rev)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*type = soc_info_table[index].ap.module_type;
+	*rev = soc_info_table[index].ap.module_rev;
+
+	return 0;
+}
+
+/* Get SoC's Communication Processor (CP) module type and revision */
+static int get_cp_type_rev(u32 *type, u32 *rev)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*type = soc_info_table[index].cp.module_type;
+	*rev = soc_info_table[index].cp.module_rev;
+
+	return 0;
+}
+
+/* Print device's SoC name and AP & CP information */
+void soc_print_device_info(void)
+{
+	u32 ap_num, cp_num, ap_type, ap_rev, cp_type, cp_rev;
+	char *soc_name = NULL;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+
+	get_soc_name(&soc_name);
+	get_ap_type_rev(&ap_type, &ap_rev);
+	get_cp_type_rev(&cp_type, &cp_rev);
+
+	if (ap_rev > 1)
+		printf("SoC: %s; AP%x-B0; ", soc_name, ap_type);
+	else
+		printf("SoC: %s; AP%x-A%d; ", soc_name, ap_type, ap_rev);
+
+	/* more than one cp module */
+	if (cp_num > 1)
+		printf("%dxCP%x-A%d\n", cp_num, cp_type, cp_rev);
+	else
+		printf("CP%x-A%d\n", cp_type, cp_rev);
+}
+
+/* Print System cache (LLC) status and mode */
+void soc_print_system_cache_info(void)
+{
+	u32 val;
+	int llc_en = 0, excl = 0;
+
+	val = readl(MVEBU_LLC_BASE + LLC_CTRL_REG_OFFSET);
+	if (val & LLC_EN) {
+		llc_en = 1;
+		if (val & LLC_EXCL_EN)
+			excl = 1;
+	}
+
+	printf("LLC %s%s\n", llc_en ? "Enabled" : "Disabled",
+	       excl ? " (Exclusive Mode)" : "");
+}
+
+#ifdef CONFIG_NAND_PXA3XX
+/* Return NAND clock in Hz */
+u32 mvebu_get_nand_clock(void __iomem *nand_flash_clk_ctrl_reg)
+{
+	u32 reg;
+
+	if (!nand_flash_clk_ctrl_reg)
+		return 0;
+
+	reg = readl(nand_flash_clk_ctrl_reg);
+	if (reg & NF_CLOCK_SEL_MASK)
+		return 400 * CLOCK_1Mhz;
+	else
+		return 250 * CLOCK_1Mhz;
+}
+
+/* Select NAND in the device bus multiplexer */
+void mvebu_nand_select(void __iomem *soc_dev_multiplex_reg)
+{
+	if (!soc_dev_multiplex_reg)
+		return;
+
+	setbits_le32(soc_dev_multiplex_reg, SOC_MUX_NAND_EN_MASK);
+}
+#endif
+
+int soc_early_init_f(void)
+{
+#ifdef CONFIG_MVEBU_SAR
+	/* Sample at reset register init */
+	mvebu_sar_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_ARCH_MISC_INIT
+int arch_misc_init(void)
+{
+	u32 type, rev;
+
+	get_soc_type_rev(&type, &rev);
+
+	/* A8040 A1/A2 doesn't support linux kernel cpuidle feautre,
+	 * so U-boot needs to update Linux bootargs according
+	 * to the device id:
+	 *
+	 * Device	Device_ID
+	 * -------------------------------
+	 * A8040 A1	0x18040
+	 * A8040 A2	0x28040
+	 * A8040 B0	0x08045
+	 *
+	 * So we need to check if 16 LSB bits are 0x8040.
+	 * The variable 'type', which is returned by
+	 * get_soc_type_rev() holds these bits.
+	 */
+	if (type == A8040_DEVICE_ID)
+		env_set("cpuidle", "cpuidle.off=1");
+
+	return 0;
+}
+#endif
diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
index f4b7a4fa80..c14eae58c0 100644
--- a/arch/arm/mach-mvebu/cpu.c
+++ b/arch/arm/mach-mvebu/cpu.c
@@ -4,6 +4,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <ahci.h>
 #include <linux/mbus.h>
 #include <asm/io.h>
@@ -12,9 +13,15 @@
 #include <asm/arch/soc.h>
 #include <sdhci.h>
 
+#if defined(CONFIG_MVEBU_EFUSE)
+#include <mvebu/fuse-mvebu.h>
+#endif
+
 #define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
 #define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
 
+#define SOC_MUX_NAND_EN_MASK		0x1
+
 static struct mbus_win windows[] = {
 	/* SPI */
 	{ MBUS_SPI_BASE, MBUS_SPI_SIZE,
@@ -489,11 +496,22 @@ int arch_cpu_init(void)
 	/* Disable MBUS error propagation */
 	clrsetbits_le32(SOC_COHERENCY_FABRIC_CTRL_REG, MBUS_ERR_PROP_EN, 0);
 
+#if defined(CONFIG_MVEBU_EFUSE)
+	if (mvebu_soc_family() == MVEBU_SOC_A38X) {
+		struct fuse_ops a38x_ops;
+
+		a38x_ops.fuse_init = mvebu_efuse_init_hw;
+		a38x_ops.fuse_hd_read = NULL;
+		a38x_ops.fuse_hd_prog = NULL;
+		reg_fuse_ops(&a38x_ops);
+	}
+#endif
+
 	return 0;
 }
 #endif /* CONFIG_ARCH_CPU_INIT */
 
-u32 mvebu_get_nand_clock(void)
+u32 mvebu_get_nand_clock(void __iomem *unused)
 {
 	u32 reg;
 
@@ -509,6 +527,14 @@ u32 mvebu_get_nand_clock(void)
 		  NAND_ECC_DIVCKL_RATIO_MASK) >> NAND_ECC_DIVCKL_RATIO_OFFS);
 }
 
+void mvebu_nand_select(void __iomem *soc_dev_multiplex_reg)
+{
+	if (!soc_dev_multiplex_reg)
+		return;
+
+	setbits_le32(soc_dev_multiplex_reg, SOC_MUX_NAND_EN_MASK);
+}
+
 /*
  * SOC specific misc init
  */
@@ -682,3 +708,28 @@ void v7_outer_cache_disable(void)
 
 	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
 }
+
+int arch_early_init_r(void)
+{
+	struct udevice *dev;
+	int ret;
+	int i;
+
+	/* Loop over all MISC uclass drivers */
+	i = 0;
+	while (1) {
+		/* Call relevant driver code via the MISC uclass driver */
+		ret = uclass_get_device(UCLASS_MISC, i++, &dev);
+
+		/* We're done, once no further MISC device node is found */
+		if (ret)
+			break;
+	}
+
+#ifdef CONFIG_DM_PCI
+	/* Trigger PCIe devices detection */
+	pci_init();
+#endif
+
+	return 0;
+}
diff --git a/arch/arm/mach-mvebu/efuse.c b/arch/arm/mach-mvebu/efuse.c
deleted file mode 100644
index 16ccfec933..0000000000
--- a/arch/arm/mach-mvebu/efuse.c
+++ /dev/null
@@ -1,263 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2015-2016 Reinhard Pfau <reinhard.pfau@gdsys.cc>
- */
-
-#include <config.h>
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/cpu.h>
-#include <asm/arch/efuse.h>
-#include <asm/arch/soc.h>
-#include <linux/mbus.h>
-
-#if defined(CONFIG_MVEBU_EFUSE_FAKE)
-#define DRY_RUN
-#else
-#undef DRY_RUN
-#endif
-
-#define MBUS_EFUSE_BASE 0xF6000000
-#define MBUS_EFUSE_SIZE BIT(20)
-
-#define MVEBU_EFUSE_CONTROL (MVEBU_REGISTER(0xE4008))
-
-enum {
-	MVEBU_EFUSE_CTRL_PROGRAM_ENABLE = (1 << 31),
-};
-
-struct mvebu_hd_efuse {
-	u32 bits_31_0;
-	u32 bits_63_32;
-	u32 bit64;
-	u32 reserved0;
-};
-
-#ifndef DRY_RUN
-static struct mvebu_hd_efuse *efuses =
-	(struct mvebu_hd_efuse *)(MBUS_EFUSE_BASE + 0xF9000);
-#else
-static struct mvebu_hd_efuse efuses[EFUSE_LINE_MAX + 1];
-#endif
-
-static int efuse_initialised;
-
-static struct mvebu_hd_efuse *get_efuse_line(int nr)
-{
-	if (nr < 0 || nr > 63 || !efuse_initialised)
-		return NULL;
-
-	return efuses + nr;
-}
-
-static void enable_efuse_program(void)
-{
-#ifndef DRY_RUN
-	setbits_le32(MVEBU_EFUSE_CONTROL, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
-#endif
-}
-
-static void disable_efuse_program(void)
-{
-#ifndef DRY_RUN
-	clrbits_le32(MVEBU_EFUSE_CONTROL, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
-#endif
-}
-
-static int do_prog_efuse(struct mvebu_hd_efuse *efuse,
-			 struct efuse_val *new_val, u32 mask0, u32 mask1)
-{
-	struct efuse_val val;
-
-	val.dwords.d[0] = readl(&efuse->bits_31_0);
-	val.dwords.d[1] = readl(&efuse->bits_63_32);
-	val.lock = readl(&efuse->bit64);
-
-	if (val.lock & 1)
-		return -EPERM;
-
-	val.dwords.d[0] |= (new_val->dwords.d[0] & mask0);
-	val.dwords.d[1] |= (new_val->dwords.d[1] & mask1);
-	val.lock |= new_val->lock;
-
-	writel(val.dwords.d[0], &efuse->bits_31_0);
-	mdelay(1);
-	writel(val.dwords.d[1], &efuse->bits_63_32);
-	mdelay(1);
-	writel(val.lock, &efuse->bit64);
-	mdelay(5);
-
-	return 0;
-}
-
-static int prog_efuse(int nr, struct efuse_val *new_val, u32 mask0, u32 mask1)
-{
-	struct mvebu_hd_efuse *efuse;
-	int res = 0;
-
-	res = mvebu_efuse_init_hw();
-	if (res)
-		return res;
-
-	efuse = get_efuse_line(nr);
-	if (!efuse)
-		return -ENODEV;
-
-	if (!new_val)
-		return -EINVAL;
-
-	/* only write a fuse line with lock bit */
-	if (!new_val->lock)
-		return -EINVAL;
-
-	/* according to specs ECC protection bits must be 0 on write */
-	if (new_val->bytes.d[7] & 0xFE)
-		return -EINVAL;
-
-	if (!new_val->dwords.d[0] && !new_val->dwords.d[1] && (mask0 | mask1))
-		return 0;
-
-	enable_efuse_program();
-
-	res = do_prog_efuse(efuse, new_val, mask0, mask1);
-
-	disable_efuse_program();
-
-	return res;
-}
-
-int mvebu_efuse_init_hw(void)
-{
-	int ret;
-
-	if (efuse_initialised)
-		return 0;
-
-	ret = mvebu_mbus_add_window_by_id(
-		CPU_TARGET_SATA23_DFX, 0xA, MBUS_EFUSE_BASE, MBUS_EFUSE_SIZE);
-
-	if (ret)
-		return ret;
-
-	efuse_initialised = 1;
-
-	return 0;
-}
-
-int mvebu_read_efuse(int nr, struct efuse_val *val)
-{
-	struct mvebu_hd_efuse *efuse;
-	int res;
-
-	res = mvebu_efuse_init_hw();
-	if (res)
-		return res;
-
-	efuse = get_efuse_line(nr);
-	if (!efuse)
-		return -ENODEV;
-
-	if (!val)
-		return -EINVAL;
-
-	val->dwords.d[0] = readl(&efuse->bits_31_0);
-	val->dwords.d[1] = readl(&efuse->bits_63_32);
-	val->lock = readl(&efuse->bit64);
-	return 0;
-}
-
-int mvebu_write_efuse(int nr, struct efuse_val *val)
-{
-	return prog_efuse(nr, val, ~0, ~0);
-}
-
-int mvebu_lock_efuse(int nr)
-{
-	struct efuse_val val = {
-		.lock = 1,
-	};
-
-	return prog_efuse(nr, &val, 0, 0);
-}
-
-/*
- * wrapper funcs providing the fuse API
- *
- * we use the following mapping:
- *   "bank" ->	eFuse line
- *   "word" ->	0: bits 0-31
- *		1: bits 32-63
- *		2: bit 64 (lock)
- */
-
-static struct efuse_val prog_val;
-static int valid_prog_words;
-
-int fuse_read(u32 bank, u32 word, u32 *val)
-{
-	struct efuse_val fuse_line;
-	int res;
-
-	if (bank < EFUSE_LINE_MIN || bank > EFUSE_LINE_MAX || word > 2)
-		return -EINVAL;
-
-	res = mvebu_read_efuse(bank, &fuse_line);
-	if (res)
-		return res;
-
-	if (word < 2)
-		*val = fuse_line.dwords.d[word];
-	else
-		*val = fuse_line.lock;
-
-	return res;
-}
-
-int fuse_sense(u32 bank, u32 word, u32 *val)
-{
-	/* not supported */
-	return -ENOSYS;
-}
-
-int fuse_prog(u32 bank, u32 word, u32 val)
-{
-	int res = 0;
-
-	/*
-	 * NOTE: Fuse line should be written as whole.
-	 * So how can we do that with this API?
-	 * For now: remember values for word == 0 and word == 1 and write the
-	 * whole line when word == 2.
-	 * This implies that we always require all 3 fuse prog cmds (one for
-	 * for each word) to write a single fuse line.
-	 * Exception is a single write to word 2 which will lock the fuse line.
-	 *
-	 * Hope that will be OK.
-	 */
-
-	if (bank < EFUSE_LINE_MIN || bank > EFUSE_LINE_MAX || word > 2)
-		return -EINVAL;
-
-	if (word < 2) {
-		prog_val.dwords.d[word] = val;
-		valid_prog_words |= (1 << word);
-	} else if ((valid_prog_words & 3) == 0 && val) {
-		res = mvebu_lock_efuse(bank);
-		valid_prog_words = 0;
-	} else if ((valid_prog_words & 3) != 3 || !val) {
-		res = -EINVAL;
-	} else {
-		prog_val.lock = val != 0;
-		res = mvebu_write_efuse(bank, &prog_val);
-		valid_prog_words = 0;
-	}
-
-	return res;
-}
-
-int fuse_override(u32 bank, u32 word, u32 val)
-{
-	/* not supported */
-	return -ENOSYS;
-}
diff --git a/arch/arm/mach-mvebu/include/mach/clock.h b/arch/arm/mach-mvebu/include/mach/clock.h
new file mode 100644
index 0000000000..9cfd757e55
--- /dev/null
+++ b/arch/arm/mach-mvebu/include/mach/clock.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_CLOCK_H_
+#define _MVEBU_CLOCK_H_
+
+#define KHz			1000
+#define MHz			1000000
+#define GHz			1000000000
+
+u32 soc_cpu_clk_get(void);
+u32 soc_ddr_clk_get(void);
+u32 soc_tclk_get(void);
+u32 soc_l2_clk_get(void);
+u32 soc_timer_clk_get(void);
+
+void soc_print_clock_info(void);
+
+#endif /* _MVEBU_CLOCK_H_ */
diff --git a/arch/arm/mach-mvebu/include/mach/cpu.h b/arch/arm/mach-mvebu/include/mach/cpu.h
index 2e2d72aac8..7723150188 100644
--- a/arch/arm/mach-mvebu/include/mach/cpu.h
+++ b/arch/arm/mach-mvebu/include/mach/cpu.h
@@ -140,7 +140,8 @@ unsigned int mvebu_sdram_bs(enum memory_bank bank);
 void mvebu_sdram_size_adjust(enum memory_bank bank);
 int mvebu_mbus_probe(struct mbus_win windows[], int count);
 int mvebu_soc_family(void);
-u32 mvebu_get_nand_clock(void);
+u32 mvebu_get_nand_clock(void __iomem *maybe_unused);
+void mvebu_nand_select(void __iomem *maybe_unused);
 
 void return_to_bootrom(void);
 
diff --git a/arch/arm/mach-mvebu/include/mach/efuse.h b/arch/arm/mach-mvebu/include/mach/efuse.h
deleted file mode 100644
index bbc5844d84..0000000000
--- a/arch/arm/mach-mvebu/include/mach/efuse.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (C) 2015 Reinhard Pfau <reinhard.pfau@gdsys.cc>
- */
-
-#ifndef _MVEBU_EFUSE_H
-#define _MVEBU_EFUSE_H
-
-#include <common.h>
-
-struct efuse_val {
-	union {
-		struct {
-			u8 d[8];
-		} bytes;
-		struct {
-			u16 d[4];
-		} words;
-		struct {
-			u32 d[2];
-		} dwords;
-	};
-	u32 lock;
-};
-
-#if defined(CONFIG_ARMADA_38X)
-
-enum efuse_line {
-	EFUSE_LINE_SECURE_BOOT = 24,
-	EFUSE_LINE_PUBKEY_DIGEST_0 = 26,
-	EFUSE_LINE_PUBKEY_DIGEST_1 = 27,
-	EFUSE_LINE_PUBKEY_DIGEST_2 = 28,
-	EFUSE_LINE_PUBKEY_DIGEST_3 = 29,
-	EFUSE_LINE_PUBKEY_DIGEST_4 = 30,
-	EFUSE_LINE_CSK_0_VALID = 31,
-	EFUSE_LINE_CSK_1_VALID = 32,
-	EFUSE_LINE_CSK_2_VALID = 33,
-	EFUSE_LINE_CSK_3_VALID = 34,
-	EFUSE_LINE_CSK_4_VALID = 35,
-	EFUSE_LINE_CSK_5_VALID = 36,
-	EFUSE_LINE_CSK_6_VALID = 37,
-	EFUSE_LINE_CSK_7_VALID = 38,
-	EFUSE_LINE_CSK_8_VALID = 39,
-	EFUSE_LINE_CSK_9_VALID = 40,
-	EFUSE_LINE_CSK_10_VALID = 41,
-	EFUSE_LINE_CSK_11_VALID = 42,
-	EFUSE_LINE_CSK_12_VALID = 43,
-	EFUSE_LINE_CSK_13_VALID = 44,
-	EFUSE_LINE_CSK_14_VALID = 45,
-	EFUSE_LINE_CSK_15_VALID = 46,
-	EFUSE_LINE_FLASH_ID = 47,
-	EFUSE_LINE_BOX_ID = 48,
-
-	EFUSE_LINE_MIN = 0,
-	EFUSE_LINE_MAX = 63,
-};
-
-#endif
-
-int mvebu_efuse_init_hw(void);
-
-int mvebu_read_efuse(int nr, struct efuse_val *val);
-
-int mvebu_write_efuse(int nr, struct efuse_val *val);
-
-int mvebu_lock_efuse(int nr);
-
-#endif
diff --git a/arch/arm/mach-mvebu/include/mach/fw_info.h b/arch/arm/mach-mvebu/include/mach/fw_info.h
new file mode 100644
index 0000000000..3ee35ec348
--- /dev/null
+++ b/arch/arm/mach-mvebu/include/mach/fw_info.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+#ifndef _FW_INFO_H_
+#define _FW_INFO_H_
+
+/* Protected ATF and TEE region */
+#define ATF_REGION_START		0x4000000
+#define ATF_REGION_END			0x5400000
+
+/* PCIe EP mappings */
+#define MV_PCIE_EP_REGION_BASE		0x8000000000ULL
+#define MV_PCIE_EP_REGION_SIZE		0x800000000ULL
+
+/* Firmware related definition used for SMC calls */
+#define MV_SIP_DRAM_SIZE		0x82000010
+
+#define MMIO_REGS_PHY_BASE		0xc0000000
+
+#endif /* _FW_INFO_H_ */
diff --git a/arch/arm/mach-mvebu/include/mach/soc.h b/arch/arm/mach-mvebu/include/mach/soc.h
index acb9257c90..56ad6aa059 100644
--- a/arch/arm/mach-mvebu/include/mach/soc.h
+++ b/arch/arm/mach-mvebu/include/mach/soc.h
@@ -36,7 +36,33 @@
 
 /* SOC specific definations */
 #define INTREG_BASE		0xd0000000
+
+#if defined(CONFIG_ARMADA_8K_PLUS)
+/*=============== A8K+ =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xe8000000ULL - (ap) * 0x04000000)
+#define MVEBU_REGS_BASE_CP(ap, cp)	(0x8100000000ULL + \
+						(ap) * 0x1d00000000ULL + \
+						(cp) * 0x700000000ULL)
+#define MVEBU_CCU_MAX_WINS		(5)
+#define MVEBU_IO_WIN_MAX_WINS		(11)
+#define MVEBU_IO_WIN_GCR_OFFSET		(0xF0)
+#define MVEBU_GWIN_MAX_WINS		(16)
+#elif defined(CONFIG_ARMADA_8K)
+/*=============== A8K =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xf0000000ULL)
+#define MVEBU_REGS_BASE_CP(ap, cp)	(0xf2000000ULL + (cp) * 0x02000000)
+#define MVEBU_CCU_MAX_WINS		(8)
+#define MVEBU_IO_WIN_MAX_WINS		(7)
+#define MVEBU_IO_WIN_GCR_OFFSET		(0x70)
+#endif
+
 #define INTREG_BASE_ADDR_REG	(INTREG_BASE + 0x20080)
+
+#if defined(CONFIG_ARMADA_8K)
+/*=============== A8K =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xf0000000ULL)
+#endif
+
 #if defined(CONFIG_SPL_BUILD) || defined(CONFIG_ARMADA_3700)
 /*
  * The SPL U-Boot version still runs with the default
@@ -159,6 +185,7 @@
 #define BOOT_DEV_SEL_MASK	(0x3f << BOOT_DEV_SEL_OFFS)
 
 #define BOOT_FROM_NAND		0x0A
+#define BOOT_FROM_NAND_ALT	0x0E
 #define BOOT_FROM_SATA		0x22
 #define BOOT_FROM_UART		0x28
 #define BOOT_FROM_SATA_ALT	0x2A
@@ -203,4 +230,31 @@
 #define BOOT_FROM_SPI		0x3
 #endif
 
+/* FW related definitions */
+#define MV_SIP_DFX			0x82000014
+#define MV_SIP_DDR_PHY_WRITE		0x82000015
+#define MV_SIP_DDR_PHY_READ		0x82000016
+
+#define MV_SIP_DFX_THERMAL_INIT		1
+#define MV_SIP_DFX_THERMAL_READ		2
+#define MV_SIP_DFX_THERMAL_IS_VALID	3
+
+#define MV_SIP_DFX_SREAD		20
+#define MV_SIP_DFX_SWRITE		21
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+int mvebu_dfx_smc(u32 subfid, u32 *reg, u32 addr, u32 val);
+void soc_print_device_info(void);
+int soc_get_ap_cp_num(void *ap_num, void *cp_num);
+void soc_print_system_cache_info(void);
+
+#define mvebu_dfx_smc_thermal(subfid, preg)	\
+				mvebu_dfx_smc(subfid, preg, 0, 0)
+#define mvebu_dfx_sread(preg, addr)		\
+				mvebu_dfx_smc(MV_SIP_DFX_SREAD, preg, addr, 0)
+#define mvebu_dfx_swrite(addr, val)		\
+				mvebu_dfx_smc(MV_SIP_DFX_SWRITE, 0, addr, val)
+#endif /* __ASSEMBLY__ */
 #endif /* _MVEBU_SOC_H */
diff --git a/arch/arm/mach-mvebu/spl.c b/arch/arm/mach-mvebu/spl.c
index 3cb27b7f4b..f4c8b419da 100644
--- a/arch/arm/mach-mvebu/spl.c
+++ b/arch/arm/mach-mvebu/spl.c
@@ -47,6 +47,7 @@ static u32 get_boot_device(void)
 	switch (boot_device) {
 #if defined(CONFIG_ARMADA_38X)
 	case BOOT_FROM_NAND:
+	case BOOT_FROM_NAND_ALT:
 		return BOOT_DEVICE_NAND;
 #endif
 #ifdef CONFIG_SPL_MMC_SUPPORT
diff --git a/arch/arm/mach-octeontx/Kconfig b/arch/arm/mach-octeontx/Kconfig
new file mode 100644
index 0000000000..28ecf9821f
--- /dev/null
+++ b/arch/arm/mach-octeontx/Kconfig
@@ -0,0 +1,23 @@
+if ARCH_OCTEONTX
+
+choice
+	prompt "OcteonTX board select"
+	optional
+
+config TARGET_OCTEONTX_81XX
+	bool "Marvell OcteonTX CN81XX"
+
+config TARGET_OCTEONTX_83XX
+	bool "Marvell OcteonTX CN83XX"
+
+endchoice
+
+config SYS_SOC
+	string
+	default "octeontx"
+
+config SYS_PCI_64BIT
+	bool
+	default y
+
+endif
diff --git a/arch/arm/mach-octeontx/Makefile b/arch/arm/mach-octeontx/Makefile
new file mode 100644
index 0000000000..8706becd0f
--- /dev/null
+++ b/arch/arm/mach-octeontx/Makefile
@@ -0,0 +1,8 @@
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * https://spdx.org/licenses
+# */
+
+obj-y += lowlevel_init.o clock.o cpu.o
diff --git a/arch/arm/mach-octeontx/clock.c b/arch/arm/mach-octeontx/clock.c
new file mode 100644
index 0000000000..9da21077ec
--- /dev/null
+++ b/arch/arm/mach-octeontx/clock.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+#include <asm/arch/clock.h>
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void)
+{
+	union rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.pnr_mul * PLL_REF_CLK;
+}
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void)
+{
+	union rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.c_mul * PLL_REF_CLK;
+}
diff --git a/arch/arm/mach-octeontx/cpu.c b/arch/arm/mach-octeontx/cpu.c
new file mode 100644
index 0000000000..0f4f73286e
--- /dev/null
+++ b/arch/arm/mach-octeontx/cpu.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/armv8/mmu.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OTX_MEM_MAP_USED 3
+
+/* 1 for 83xx, +1 is end of list which needs to be empty */
+#define OTX_MEM_MAP_MAX (OTX_MEM_MAP_USED + 1 + CONFIG_NR_DRAM_BANKS + 1)
+
+static struct mm_region otx_mem_map[OTX_MEM_MAP_MAX] = {
+	{
+		.virt = 0x800000000000UL,
+		.phys = 0x800000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x840000000000UL,
+		.phys = 0x840000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x880000000000UL,
+		.phys = 0x880000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}
+
+};
+
+struct mm_region *mem_map = otx_mem_map;
+
+void mem_map_fill(void)
+{
+	int banks = OTX_MEM_MAP_USED;
+	u32 dram_start = CONFIG_SYS_TEXT_BASE;
+
+	if (otx_is_soc(CN83XX)) {
+		/* Add 4K pci bootcmd buffer range */
+		dram_start -= 0x1000;
+		otx_mem_map[banks].virt = 0x8c0000000000UL;
+		otx_mem_map[banks].phys = 0x8c0000000000UL;
+		otx_mem_map[banks].size = 0x40000000000UL;
+		otx_mem_map[banks].attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+					   PTE_BLOCK_NON_SHARE;
+		banks = banks + 1;
+	}
+
+	for (int i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		otx_mem_map[banks].virt = dram_start;
+		otx_mem_map[banks].phys = dram_start;
+		otx_mem_map[banks].size = gd->ram_size;
+		otx_mem_map[banks].attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+					   PTE_BLOCK_NON_SHARE;
+		banks = banks + 1;
+	}
+}
+
+u64 get_page_table_size(void)
+{
+	return 0x80000;
+}
+
+void reset_cpu(ulong addr)
+{
+}
diff --git a/arch/arm/mach-octeontx/lowlevel_init.S b/arch/arm/mach-octeontx/lowlevel_init.S
new file mode 100644
index 0000000000..41a9f08aed
--- /dev/null
+++ b/arch/arm/mach-octeontx/lowlevel_init.S
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+#include <asm/macro.h>
+
+.align 8
+.global fdt_base_addr
+fdt_base_addr:
+	.dword 0x0
+
+.global save_boot_params
+save_boot_params:
+	/* Read FDT base from x1 register passed by ATF */
+	adr	x21, fdt_base_addr
+	str	x1, [x21]
+
+	/* Returns */
+	b	save_boot_params_ret
+
+ENTRY(lowlevel_init)
+	mov	x29, lr			/* Save LR */
+
+	/* any lowlevel init should go here */
+
+	mov	lr, x29			/* Restore LR */
+	ret
+ENDPROC(lowlevel_init)
diff --git a/arch/arm/mach-octeontx2/Kconfig b/arch/arm/mach-octeontx2/Kconfig
new file mode 100644
index 0000000000..951dec72f6
--- /dev/null
+++ b/arch/arm/mach-octeontx2/Kconfig
@@ -0,0 +1,32 @@
+if ARCH_OCTEONTX2
+
+choice
+	prompt "OcteonTX2 board select"
+	optional
+
+config TARGET_OCTEONTX2_95XX
+	bool "Marvell OcteonTX2 CN95XX"
+
+config TARGET_OCTEONTX2_96XX
+	bool "Marvell OcteonTX2 CN96XX"
+
+config TARGET_OCTEONTX2_LOKI
+	bool "Marvell OcteonTX2 LOKI"
+
+config TARGET_OCTEONTX2_98XX
+	bool "Marvell OcteonTX2 CN98XX"
+
+config TARGET_OCTEONTX2_95MM
+	bool "Marvell OcteonTX2 CN95MM"
+
+endchoice
+
+config SYS_SOC
+	string
+	default "octeontx2"
+
+config SYS_PCI_64BIT
+	bool
+	default y
+
+endif
diff --git a/arch/arm/mach-octeontx2/Makefile b/arch/arm/mach-octeontx2/Makefile
new file mode 100644
index 0000000000..b3073a84b1
--- /dev/null
+++ b/arch/arm/mach-octeontx2/Makefile
@@ -0,0 +1,8 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y += lowlevel_init.o clock.o cpu.o
diff --git a/arch/arm/mach-octeontx2/clock.c b/arch/arm/mach-octeontx2/clock.c
new file mode 100644
index 0000000000..9da21077ec
--- /dev/null
+++ b/arch/arm/mach-octeontx2/clock.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+#include <asm/arch/clock.h>
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void)
+{
+	union rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.pnr_mul * PLL_REF_CLK;
+}
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void)
+{
+	union rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.c_mul * PLL_REF_CLK;
+}
diff --git a/arch/arm/mach-octeontx2/config.mk b/arch/arm/mach-octeontx2/config.mk
new file mode 100644
index 0000000000..9214f6b742
--- /dev/null
+++ b/arch/arm/mach-octeontx2/config.mk
@@ -0,0 +1,4 @@
+ifeq ($(CONFIG_ARCH_OCTEONTX2),y)
+PLATFORM_CPPFLAGS += $(call cc-option,-march=armv8.2-a,)
+PLATFORM_CPPFLAGS += $(call cc-option,-mtune=octeontx2,)
+endif
diff --git a/arch/arm/mach-octeontx2/cpu.c b/arch/arm/mach-octeontx2/cpu.c
new file mode 100644
index 0000000000..a8039d6a35
--- /dev/null
+++ b/arch/arm/mach-octeontx2/cpu.c
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/armv8/mmu.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OTX2_MEM_MAP_USED 4
+
+/* +1 is end of list which needs to be empty */
+#define OTX2_MEM_MAP_MAX (OTX2_MEM_MAP_USED + CONFIG_NR_DRAM_BANKS + 1)
+
+static struct mm_region otx2_mem_map[OTX2_MEM_MAP_MAX] = {
+	{
+		.virt = 0x800000000000UL,
+		.phys = 0x800000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x840000000000UL,
+		.phys = 0x840000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x880000000000UL,
+		.phys = 0x880000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x8c0000000000UL,
+		.phys = 0x8c0000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}
+};
+
+struct mm_region *mem_map = otx2_mem_map;
+
+void mem_map_fill(void)
+{
+	int banks = OTX2_MEM_MAP_USED;
+	u32 dram_start = CONFIG_SYS_TEXT_BASE;
+
+	/* Add 4K pci bootcmd buffer range for 96xx boards */
+	if (otx_is_soc(CN96XX))
+		dram_start -= 0x1000;
+	for (int i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		otx2_mem_map[banks].virt = dram_start;
+		otx2_mem_map[banks].phys = dram_start;
+		otx2_mem_map[banks].size = gd->ram_size;
+		otx2_mem_map[banks].attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+					    PTE_BLOCK_NON_SHARE;
+		banks = banks + 1;
+	}
+}
+
+u64 get_page_table_size(void)
+{
+	return 0x80000;
+}
+
+void reset_cpu(ulong addr)
+{
+}
diff --git a/arch/arm/mach-octeontx2/lowlevel_init.S b/arch/arm/mach-octeontx2/lowlevel_init.S
new file mode 100644
index 0000000000..41a9f08aed
--- /dev/null
+++ b/arch/arm/mach-octeontx2/lowlevel_init.S
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+#include <asm/macro.h>
+
+.align 8
+.global fdt_base_addr
+fdt_base_addr:
+	.dword 0x0
+
+.global save_boot_params
+save_boot_params:
+	/* Read FDT base from x1 register passed by ATF */
+	adr	x21, fdt_base_addr
+	str	x1, [x21]
+
+	/* Returns */
+	b	save_boot_params_ret
+
+ENTRY(lowlevel_init)
+	mov	x29, lr			/* Save LR */
+
+	/* any lowlevel init should go here */
+
+	mov	lr, x29			/* Restore LR */
+	ret
+ENDPROC(lowlevel_init)
diff --git a/board/Marvell/common/Kconfig b/board/Marvell/common/Kconfig
new file mode 100644
index 0000000000..ec9d115ecc
--- /dev/null
+++ b/board/Marvell/common/Kconfig
@@ -0,0 +1,22 @@
+menu "MVEBU Development Board Utilities"
+	depends on ARCH_MVEBU
+
+config BOARD_CONFIG_EEPROM
+	bool "Support configuration EEPROM"
+	default n
+	help
+	  If this option is enabled, U-Boot will initialize
+	  configuration EEPROM on board.
+	  It will be enabled once the CMD_MVEBU_BOX_INFO or
+	  MULTI_DT_FILE is enabled
+
+config MVEBU_SAR
+	bool "Support MVEBU SAR Utility"
+	default n
+	help
+	  Say Y here to add support for Sample
+	  at Reset Utility. You need this only if
+	  you work on a Marvell development board.
+	  If not, keep this off to reduce code size
+
+endmenu
diff --git a/board/Marvell/common/Makefile b/board/Marvell/common/Makefile
new file mode 100644
index 0000000000..1adfef4246
--- /dev/null
+++ b/board/Marvell/common/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2018 Marvell International Ltd.
+#
+# SPDX-License-Identifier: GPL-2.0+
+# https://spdx.org/licenses
+#
+
+obj-$(CONFIG_BOARD_CONFIG_EEPROM)	+= cfg_eeprom.o
+obj-$(CONFIG_MVEBU_SAR)	+= sar.o
diff --git a/board/Marvell/common/cfg_eeprom.c b/board/Marvell/common/cfg_eeprom.c
new file mode 100644
index 0000000000..1986e4e949
--- /dev/null
+++ b/board/Marvell/common/cfg_eeprom.c
@@ -0,0 +1,385 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <mvebu/cfg_eeprom.h>
+
+struct eeprom_struct board_config_val = CFG_DEFAULT_VALUE;
+struct config_types_info config_types_info[] = MV_EEPROM_CONFIG_INFO;
+int eeprom_initialized = -1;
+int g_board_hw_info = -1;
+
+static char hw_info_param_list[][HW_INFO_MAX_NAME_LEN] = {
+	"pcb_slm",
+	"pcb_rev",
+	"eco_rev",
+	"pcb_sn",
+	"ethaddr",
+	"eth1addr",
+	"eth2addr",
+	"eth3addr",
+	"eth4addr",
+	"eth5addr",
+	"eth6addr",
+	"eth7addr",
+	"eth8addr",
+	"eth9addr"
+};
+
+static int hw_info_param_num = (sizeof(hw_info_param_list) /
+				sizeof(hw_info_param_list[0]));
+
+static u32 cfg_eeprom_checksum8(u8 *start, u32 len)
+{
+	u32 sum = 0;
+	u8 *startp = start;
+
+	do {
+		sum += *startp;
+		startp++;
+		len--;
+	} while (len > 0);
+	return sum;
+}
+
+/* cfg_eeprom_get_config_type
+ * config_info input pointer receive the mapping of the
+ * required field in the local struct
+ */
+static bool cfg_eeprom_get_config_type(enum mv_config_type_id id,
+				       struct config_types_info *config_info)
+{
+	int i;
+
+	/* verify existence of requested config type, pull its data */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION ; i++)
+		if (config_types_info[i].config_id == id) {
+			*config_info = config_types_info[i];
+			return true;
+		}
+	pr_err("requested MV_CONFIG_TYPE_ID was not found (%d)\n", id);
+
+	return false;
+}
+
+/* read specific field from EEPROM
+ * @data_length: if equal to -1 read number of bytes as the length of the field.
+ */
+static void read_field_from_eeprom(enum mv_config_type_id id,
+				   u8 *data, int data_length)
+{
+	struct config_types_info config_info;
+	struct udevice *dev;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return;
+	}
+
+	if (!cfg_eeprom_get_config_type(id, &config_info)) {
+		pr_err("Could not find field %x in EEPROM struct\n", id);
+		return;
+	}
+
+	if (data_length == READ_SPECIFIC_FIELD)
+		data_length = config_info.byte_cnt;
+
+	dm_i2c_read(dev, config_info.byte_num, data, data_length);
+}
+
+/* cfg_eeprom_write_to_eeprom - write the global struct to EEPROM. */
+int cfg_eeprom_write_to_eeprom(int length)
+{
+	int reserve_length, size_of_loop, i;
+	struct udevice *dev;
+	u8 *pattern = (u8 *)&board_config_val.pattern;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return err;
+	}
+
+	/* calculate checksum and save it in struct */
+	board_config_val.checksum = cfg_eeprom_checksum8(pattern,
+							 EEPROM_STRUCT_SIZE -
+							 4);
+
+	/* write fdt struct to EEPROM */
+	size_of_loop = length / I2C_PAGE_WRITE_SIZE;
+	reserve_length = length % I2C_PAGE_WRITE_SIZE;
+
+	/* i2c support on page write with size 32-byets */
+	for (i = 0; i < size_of_loop; i++) {
+		u8 *buffer = (u8 *)&(board_config_val) +
+						i * I2C_PAGE_WRITE_SIZE;
+		dm_i2c_write(dev, i * I2C_PAGE_WRITE_SIZE,
+			     buffer,
+			     I2C_PAGE_WRITE_SIZE);
+#ifdef CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS
+		/* EEPROM write need delay, or cause write operation fail */
+		udelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
+#endif
+	}
+
+	/* write the reserve data from 32-bytes */
+	if (reserve_length) {
+		u8 *buffer = (u8 *)&(board_config_val) +
+						i * I2C_PAGE_WRITE_SIZE;
+		dm_i2c_write(dev, i * I2C_PAGE_WRITE_SIZE,
+			     buffer,
+			     reserve_length);
+#ifdef CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS
+		/* EEPROM write need delay */
+		udelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
+#endif
+	}
+
+	return 0;
+}
+
+/* cfg_eeprom_save - write the local struct to EEPROM */
+void cfg_eeprom_save(int length)
+{
+	/* write local struct with fdt blob to EEPROM */
+	cfg_eeprom_write_to_eeprom(length);
+	/* reset g_board_id so it will get board ID from EEPROM again */
+	g_board_hw_info = -1;
+}
+
+/* cfg_eeprom_get_board_config - return the whole board config
+ * It is assumed the cfg_eeprom_init must be called prior to this routine,
+ * otherwise static default configuration will be used.
+ */
+struct eeprom_struct *cfg_eeprom_get_board_config(void)
+{
+	return &board_config_val;
+}
+
+/* cfg_eeprom_get_hw_info_str - copy hw_info from cfg_eeprom to destination */
+void cfg_eeprom_get_hw_info_str(uchar *hw_info_str)
+{
+	int len;
+
+	/* hw_info isn't initialized, need to read hw_info from EEPROM */
+	if (g_board_hw_info == -1) {
+		u8 *hw_info = (u8 *)board_config_val.man_info.hw_info;
+		/* read hw_info config from EEPROM */
+		read_field_from_eeprom(MV_CONFIG_HW_INFO,
+				       hw_info,
+				       READ_SPECIFIC_FIELD);
+	}
+	len = strlen((const char *)board_config_val.man_info.hw_info);
+	if (len >= MVEBU_HW_INFO_LEN)
+		len = MVEBU_HW_INFO_LEN - 1;
+
+	memcpy(hw_info_str, board_config_val.man_info.hw_info, len);
+}
+
+/* cfg_eeprom_set_hw_info_str - copy hw_info sting to cfg_eeprom module
+ * It is assumed the cfg_eeprom_init must be called prior to this routine,
+ * otherwise static default configuration will be used.
+ */
+void cfg_eeprom_set_hw_info_str(uchar *hw_info_str)
+{
+	int len;
+	struct config_types_info config_info;
+
+	/* read hw_info config from EEPROM */
+	if (!cfg_eeprom_get_config_type(MV_CONFIG_HW_INFO, &config_info)) {
+		pr_err("Could not find MV_CONFIG_hw_info\n");
+		return;
+	}
+
+	len = strlen((const char *)hw_info_str);
+	if (len >= config_info.byte_cnt)
+		len = config_info.byte_cnt - 1;
+
+	/* need to set all value to 0 at first for later string operation */
+	memset(board_config_val.man_info.hw_info, 0, config_info.byte_cnt);
+	memcpy(board_config_val.man_info.hw_info, hw_info_str, len);
+}
+
+/* cfg_eeprom_skip_space - skip the space character */
+static char *cfg_eeprom_skip_space(char *buf)
+{
+	while ((buf[0] == ' ' || buf[0] == '\t'))
+		++buf;
+	return buf;
+}
+
+/*
+ * cfg_eeprom_parse_hw_info
+ * - parse the hw_info from string to name/value pairs
+ */
+int cfg_eeprom_parse_hw_info(struct hw_info_data_struct *hw_info_data_array)
+{
+	int count;
+	char *name;
+	char *value;
+	int len;
+	uchar hw_info_str[MVEBU_HW_INFO_LEN];
+
+	/* need to set all to 0 for later string operation */
+	memset(hw_info_str, 0, sizeof(hw_info_str));
+
+	cfg_eeprom_get_hw_info_str(hw_info_str);
+	name = (char *)hw_info_str;
+	name = cfg_eeprom_skip_space(name);
+	/* return 0 in case the string is empty */
+	if (!name)
+		return 0;
+
+	for (count = 0; name; count++) {
+		value = strchr(name, '=');
+
+		if (!value)
+			return count;
+
+		*value = '\0';
+		len = strlen(name);
+		memcpy(hw_info_data_array[count].name, name, len);
+		hw_info_data_array[count].name[len] = '\0';
+		value++;
+
+		name = strchr(value, ' ');
+		if (!name)
+			return ++count;
+
+		*name = '\0';
+		len = strlen(value);
+		memcpy(hw_info_data_array[count].value, value, len);
+		hw_info_data_array[count].value[len] = '\0';
+		name = cfg_eeprom_skip_space(name + 1);
+	}
+	count++;
+
+	return count;
+}
+
+/* cfg_eeprom_validate_name - check parameter's name is valid or not
+ * valid - return 0
+ * invalid - return -1
+ */
+int cfg_eeprom_validate_name(char *name)
+{
+	int idx;
+
+	for (idx = 0; idx < hw_info_param_num; idx++) {
+		if (strcmp(name, hw_info_param_list[idx]) == 0)
+			return 0;
+	}
+
+	return -1;
+}
+
+/* cfg_eeprom_parse_env - parse the env from env to name/value pairs */
+int cfg_eeprom_parse_env(struct hw_info_data_struct *data_array,
+			 int size)
+{
+	int param_num = 0;
+	int idx;
+	int len;
+	char *name;
+	char *value;
+
+	/* need to memset to 0 for later string operation */
+	memset(data_array, 0, size);
+	for (idx = 0; idx < hw_info_param_num; idx++) {
+		name = hw_info_param_list[idx];
+		value = env_get(name);
+
+		if (!value) {
+			printf("miss %s in env, please set it at first\n",
+			       hw_info_param_list[idx]);
+			continue;
+		}
+
+		len = strlen(name);
+		if (len > HW_INFO_MAX_NAME_LEN)
+			len  = HW_INFO_MAX_NAME_LEN;
+		memcpy(data_array[param_num].name, name, len);
+		len = strlen(value);
+		if (len > HW_INFO_MAX_NAME_LEN)
+			len  = HW_INFO_MAX_NAME_LEN;
+		memcpy(data_array[param_num].value, value, len);
+
+		param_num++;
+	}
+
+	return param_num;
+}
+
+/*
+ * cfg_eeprom_init - initialize FDT configuration struct
+ * The EEPROM FDT is used if 1) the checksum is valid, 2) the system
+ * is not in recovery mode, 3) validation_counter < AUTO_RECOVERY_RETRY_TIMES
+ * Otherwise the default FDT is used.
+ */
+int cfg_eeprom_init(void)
+{
+	struct eeprom_struct eeprom_buffer;
+	u32 calculate_checksum;
+	struct udevice *dev;
+	u8 *pattern = (u8 *)&eeprom_buffer.pattern;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return err;
+	}
+
+	/* It is possible that this init will be called by several
+	 * modules during init, however only need to initialize it
+	 * for one time
+	 */
+	if (eeprom_initialized == 1)
+		return 0;
+
+	/* read pattern from EEPROM */
+	read_field_from_eeprom(MV_CONFIG_PATTERN,
+			       pattern,
+			       READ_SPECIFIC_FIELD);
+
+	/* check if pattern in EEPROM is invalid */
+	if (eeprom_buffer.pattern != board_config_val.pattern) {
+		printf("EEPROM configuration pattern not detected.\n");
+		goto init_done;
+	}
+
+	/* read struct from EEPROM */
+	err = dm_i2c_read(dev, 0,
+			  (u8 *)&eeprom_buffer,
+			  EEPROM_STRUCT_SIZE);
+	if (err) {
+		pr_err("read error from device: %p", dev);
+		return err;
+	}
+
+	/* calculate checksum */
+	calculate_checksum = cfg_eeprom_checksum8(pattern,
+						  EEPROM_STRUCT_SIZE - 4);
+	if (calculate_checksum == eeprom_buffer.checksum) {
+		/* update board_config_val struct with read from EEPROM */
+		board_config_val = eeprom_buffer;
+	}
+
+init_done:
+	eeprom_initialized = 1;
+	return 0;
+}
diff --git a/board/Marvell/common/sar.c b/board/Marvell/common/sar.c
new file mode 100644
index 0000000000..6e94196304
--- /dev/null
+++ b/board/Marvell/common/sar.c
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include <fdtdec.h>
+#include <mvebu/sar.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sar_data  __attribute__((section(".data"))) sar_board;
+#define board_get_sar() (&sar_board)
+#define board_get_sar_table() (sar_board.sar_lookup)
+
+static u32 swap_value(u32 val, u32 bit_length)
+{
+	u32 var_mask = (1 << bit_length) - 1;
+
+	val = (val & 0xFFFF0000) >> 16 | (val & 0x0000FFFF) << 16;
+	val = (val & 0xFF00FF00) >> 8 | (val & 0x00FF00FF) << 8;
+	val = (val & 0xF0F0F0F0) >> 4 | (val & 0x0F0F0F0F) << 4;
+	val = (val & 0xCCCCCCCC) >> 2 | (val & 0x33333333) << 2;
+	val = (val & 0xAAAAAAAA) >> 1 | (val & 0x55555555) << 1;
+	val = (val >> (32 - bit_length)) & var_mask;
+	debug("value is swaped, new value = 0x%x\n", val);
+
+	return val;
+}
+
+static int sar_read_reg(u32 *reg)
+{
+	struct udevice *dev;
+	uchar byte = 0;
+	int ret, chip;
+	u32 sar_reg = 0;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		ret = i2c_get_chip_for_busnum(0, sar->chip_addr[chip], 1, &dev);
+		if (ret) {
+			printf("Error: %s: Failed getting chip busnum 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+		ret = dm_i2c_read(dev, 0, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed reading from chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+		sar_reg |= (byte & reg_mask) << (chip * reg_width);
+	}
+	debug("read: sar register = 0x%08x\n", sar_reg);
+	*reg = sar_reg;
+
+	return 0;
+}
+
+int sar_write_reg(u32 sar_reg)
+{
+	struct udevice *dev;
+	uchar byte = 0;
+	int ret, chip;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		byte = (sar_reg >> (chip * reg_width)) & reg_mask;
+		ret = i2c_get_chip_for_busnum(0, sar->chip_addr[chip], 1, &dev);
+		if (ret) {
+			printf("Error: %s: Failed getting chip busnum 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+
+		ret = dm_i2c_write(dev, 0, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed writing to chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+	}
+	debug("write: sar register = 0x%08x\n", sar_reg);
+	/*
+	 * Wait for the write to complete. The write can take
+	 * up to 10mSec (we allow a little more time).
+	 */
+	mdelay(11);
+
+	return 0;
+}
+
+int sar_read_var(struct sar_var *var, int *val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	(*val) = (sar_reg >> var->start_bit) & var_mask;
+	if (var->swap_bit)
+		(*val) = swap_value(*val, var->bit_length);
+
+	debug("var offset = %d len = %d val = 0x%x\n", var->start_bit,
+	      var->bit_length, (*val));
+
+	return 0;
+}
+
+int sar_write_var(struct sar_var *var, int val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	/* Update the bitfield inside the sar register */
+	if (var->swap_bit)
+		val = swap_value(val, var->bit_length);
+	val &= var_mask;
+	sar_reg &= ~(var_mask << var->start_bit);
+	sar_reg |= (val << var->start_bit);
+
+	/* Write the full sar register back to i2c */
+	if (sar_write_reg(sar_reg))
+		return -1;
+
+	return 0;
+}
+
+static int sar_default_var(struct sar_var *var)
+{
+	struct var_opts *opts;
+	struct var_opts *dflt =	NULL;
+	int i;
+
+	opts = var->option_desc;
+
+	for (i = 0; i < var->option_cnt; i++, opts++) {
+		if (opts->flags & VAR_IS_DEFAULT)
+			dflt = opts;
+	}
+
+	if (!dflt) {
+		printf("Error: Failed to find default option");
+		return -1;
+	}
+
+	if (sar_write_var(var, dflt->value)) {
+		printf("Error: Failed to write default value");
+		return -1;
+	}
+
+	debug("Wrote default value 0x%x = %s\n", dflt->value, dflt->desc);
+	return 0;
+}
+
+int sar_get_key_id(const char *key)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+	int id;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		if (strcmp(key, sar_table[id].key) == 0)
+			return id;
+	}
+	return -1;
+}
+
+int sar_is_var_active(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	return sar_table[id].active;
+}
+
+struct var_opts *sar_get_var_opts(int id, int *cnt)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	(*cnt) = sar_table[id].option_cnt;
+
+	return sar_table[id].option_desc;
+}
+
+int sar_validate_key(const char *key)
+{
+	int id = sar_get_key_id(key);
+
+	if (id  == -1) {
+		printf("Satr: Error: Unknown key \"%s\"\n", key);
+		return -1;
+	}
+	if (sar_is_var_active(id) == 0) {
+		printf("Satr: Error: Key \"%s\" is inactive on this board\n",
+		       key);
+		return -1;
+	}
+	return id;
+}
+
+struct sar_var *sar_id_to_var(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	sar_table += id;
+	return sar_table;
+}
+
+/* Interface to SatR command */
+int sar_is_available(void)
+{
+	if (!board_get_sar_table())
+		return 0;
+	else
+		return 1;
+}
+
+void sar_print_var(int id, bool print_opts)
+{
+	int cnt;
+	struct var_opts *opts;
+	struct sar_var *sar_table = board_get_sar_table();
+
+	printf("%-10s %s\n", sar_table[id].key, sar_table[id].desc);
+
+	if (print_opts) {
+		opts = sar_get_var_opts(id, &cnt);
+		while (cnt--) {
+			printf("\t0x%-2x %s ", opts->value, opts->desc);
+			if (opts->flags & VAR_IS_DEFAULT)
+				printf("[Default]");
+			printf("\n");
+			opts++;
+		}
+	}
+}
+
+int sar_read_all(void)
+{
+	struct sar_var *var;
+	int id;
+
+	for (id = 0; id < MAX_SAR; id++)
+		if (sar_is_var_active(id)) {
+			var = sar_id_to_var(id);
+			sar_print_key(var->key);
+		}
+
+	return 0;
+}
+
+void sar_list_keys(void)
+{
+	int id;
+
+	printf("\n");
+	for (id = 0; id < MAX_SAR; id++) {
+		if (sar_is_var_active(id))
+			sar_print_var(id, 0);
+	}
+	printf("\n");
+}
+
+int sar_list_key_opts(const char *key)
+{
+	int id = sar_validate_key(key);
+
+	if (id == -1)
+		return -EINVAL;
+
+	printf("\n");
+	sar_print_var(id, 1);
+	printf("\n");
+
+	return 0;
+}
+
+int  sar_print_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int val, ret, cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_read_var(var, &val);
+	if (ret)
+		return ret;
+
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (!desc)
+		printf("%s = 0x%x  ERROR: UNKNOWN OPTION\n", key, val);
+	else
+		printf("%s = 0x%x  %s\n", key, val, desc);
+
+	return 0;
+}
+
+int  sar_write_key(const char *key, int val)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (!desc) {
+		printf("ERROR: value 0x%x not supported for key %s\n",
+		       val, key);
+		printf("use \"SatR list %s\" to print supported values\n",
+		       key);
+		return -1;
+	}
+
+	if (sar_write_var(var, val))
+		return -1;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
+int sar_default_all(void)
+{
+	struct sar_var *var;
+	int id;
+	int ret = 0;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		if (sar_is_var_active(id)) {
+			var = sar_id_to_var(id);
+			ret |= sar_default_var(var);
+			sar_print_key(var->key);
+		}
+	}
+
+	return ret;
+}
+
+int  sar_default_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	int ret;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_default_var(var);
+	if (ret)
+		return ret;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
+static void sar_dump(void)
+{
+#ifdef DEBUG
+	struct sar_data *sar = board_get_sar();
+	struct sar_var *sar_var;
+	int i, id;
+
+	printf("Sample at reset Dumper:\n");
+	printf("\tSatR had %d chip addresses: ", sar->chip_count);
+	for (i = 0; i < sar->chip_count; i++)
+		printf("0x%x ", sar->chip_addr[i]);
+	printf("\n\tBit width for the I2C chip is: 0x%x\n", sar->bit_width);
+	printf("\tAll SatR variables thet available:\n");
+	for (i = 0, sar_var = sar->sar_lookup; i < MAX_SAR; i++, sar_var++) {
+		if (sar_var->active == 0)
+			continue;
+		printf("\t\tID = %d, ", i);
+		printf("Key = %s, ", sar_var->key);
+		printf("Desc. = %s", sar_var->desc);
+		if (sar_var->swap_bit)
+			printf(", BIT is swapped");
+		printf("\n\t\tStart bit = 0x%x, ", sar_var->start_bit);
+		printf("Bit length = %d\n", sar_var->bit_length);
+		printf("\t\tThis variable had %d options:\n",
+		       sar_var->option_cnt);
+		for (id = 0; id < sar_var->option_cnt; id++) {
+			printf("\t\t\tValue = 0x%x, ",
+			       sar_var->option_desc[id].value);
+			printf("Desc. = %s, ", sar_var->option_desc[id].desc);
+			printf("Is Default = %d\n",
+			       sar_var->option_desc[id].flags);
+		}
+	}
+#endif
+}
+
+void sar_init(void)
+{
+	int i, var_default;
+	int node, var, len, lenp;
+	const char *str;
+	const void *blob = gd->fdt_blob;
+	struct sar_var *sar_var;
+	struct sar_data *sar = board_get_sar();
+
+	/* Get sar node from the FDT blob */
+	node = fdt_node_offset_by_compatible(blob, -1,
+					     fdtdec_get_compatible(
+					     COMPAT_MVEBU_SAR));
+	if (node < 0) {
+		debug("No sar node found in FDT blob\n");
+		return;
+	}
+
+	/* Get the bit width of the sapmple at reset i2c register */
+	sar->bit_width = fdtdec_get_int(blob, node, "bit_width", 1);
+	/* Get the address count of sample at reset i2c */
+	sar->chip_count = fdtdec_get_int(blob, node, "chip_count", 1);
+	/* get the address in array */
+	if (fdtdec_get_int_array(blob, node, "reg",
+				 sar->chip_addr, sar->chip_count) != 0) {
+		pr_err("No sample at reset addresses found in FDT blob\n");
+		return;
+	}
+	/* Get the fisrt variable in sample at reset */
+	var = fdt_first_subnode(blob, node);
+	if (!var) {
+		pr_err("No sample at reset variables found in FDT\n");
+		return;
+	}
+	sar_var = sar->sar_lookup;
+	/* Find the variables under sample at reset node */
+	while (var > 0) {
+		/* if the variable is disabled skip it */
+		if (!fdtdec_get_is_enabled(blob, var)) {
+			/* Get the offset of the next subnode */
+			var = fdt_next_subnode(blob, var);
+			sar_var++;
+			continue;
+		}
+		/* Get the key of the var option */
+		sar_var->key = (char *)fdt_stringlist_get(blob, var, "key",
+							  0, &lenp);
+		/* Get the description of the var */
+		sar_var->desc = (char *)fdt_stringlist_get(blob, var,
+							   "description", 0,
+							   &lenp);
+		/* set the different options of the var */
+		sar_var->active = 1;
+		sar_var->start_bit = fdtdec_get_int(blob, var, "start-bit", 0);
+		sar_var->bit_length = fdtdec_get_int(blob, var,
+						     "bit-length", 0);
+		sar_var->option_cnt = fdtdec_get_int(blob, var,
+						     "option-cnt", 0);
+		sar_var->swap_bit = fdtdec_get_bool(blob, var, "swap-bit");
+		/* Get the options list */
+		len = fdt_stringlist_count(blob, var, "options");
+		if ((len < 0) || (sar_var->option_cnt * 2 != len)) {
+			pr_err("%s: failed to parse the \"options\" property",
+			       __func__);
+			return;
+		}
+		var_default = fdtdec_get_int(blob, var, "default", 0);
+		/* Fill the struct with the options from the FDT */
+		for (i = 0; i < len; i += 2) {
+			str = fdt_stringlist_get(blob, var, "options", i,
+						 &lenp);
+			sar_var->option_desc[i / 2].value = simple_strtoul(
+							  str, NULL, 16);
+			sar_var->option_desc[i / 2].desc =
+			(char *)fdt_stringlist_get(blob, var, "options",
+						   i + 1, &lenp);
+			if (sar_var->option_desc[i / 2].value == var_default)
+				sar_var->option_desc[i / 2].flags =
+				VAR_IS_DEFAULT;
+		}
+		/* Get the offset of the next subnode */
+		var = fdt_next_subnode(blob, var);
+		sar_var++;
+	}
+
+	sar_dump();
+}
diff --git a/board/Marvell/db-88f6820-ap/Makefile b/board/Marvell/db-88f6820-ap/Makefile
new file mode 100644
index 0000000000..8d565ec718
--- /dev/null
+++ b/board/Marvell/db-88f6820-ap/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2018 Grzegorz Jaszczyk <jaz@semihalf.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ccflags-y += -Idrivers/ddr/marvell/a38x/ -Iarch/arm/mach-mvebu/serdes/a38x/
+obj-y	:= db-88f6820-ap.o
diff --git a/board/Marvell/db-88f6820-ap/db-88f6820-ap.c b/board/Marvell/db-88f6820-ap/db-88f6820-ap.c
new file mode 100644
index 0000000000..ac35832e9a
--- /dev/null
+++ b/board/Marvell/db-88f6820-ap/db-88f6820-ap.c
@@ -0,0 +1,140 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+
+#include "../drivers/ddr/marvell/a38x/ddr3_init.h"
+#include <high_speed_env_spec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ETH_PHY_CTRL_REG		0
+#define ETH_PHY_CTRL_POWER_DOWN_MASK	BIT(11)
+
+/*
+ * Those values and defines are taken from the Marvell U-Boot version
+ * "u-boot-2013.01-2014_T3.0"
+ */
+
+#define DB_AP_88F68XX_GPP_OUT_ENA_LOW					\
+	(~(BIT(21)))
+#define DB_AP_88F68XX_GPP_OUT_ENA_MID					\
+	(~(BIT(1) | BIT(2) | BIT(3) | BIT(5) | BIT(15)))
+#define DB_AP_88F68XX_GPP_OUT_ENA_HIGH	(~(BIT(1)))
+
+#define DB_AP_88F68XX_GPP_OUT_VAL_LOW	0x0
+#define DB_AP_88F68XX_GPP_OUT_VAL_MID	BIT(15)
+#define DB_AP_88F68XX_GPP_OUT_VAL_HIGH	0x0
+#define DB_AP_88F68XX_GPP_POL_LOW	0x0
+#define DB_AP_88F68XX_GPP_POL_MID	0x0
+#define DB_AP_88F68XX_GPP_POL_HIGH	0x0
+
+static struct serdes_map board_serdes_map[] = {
+	{PEX0, SERDES_SPEED_5_GBPS, PEX_ROOT_COMPLEX_X1, 0, 0},
+	{SGMII1, SERDES_SPEED_3_125_GBPS, SERDES_DEFAULT_MODE, 0, 0},
+	{PEX1, SERDES_SPEED_5_GBPS, SERDES_DEFAULT_MODE, 0, 0},
+	{SGMII2, SERDES_SPEED_3_125_GBPS, SERDES_DEFAULT_MODE, 0, 0},
+	{USB3_HOST0, SERDES_SPEED_5_GBPS, SERDES_DEFAULT_MODE, 0, 0},
+	{PEX2, SERDES_SPEED_5_GBPS, SERDES_DEFAULT_MODE, 0, 0}
+};
+
+int hws_board_topology_load(struct serdes_map **serdes_map_array, u8 *count)
+{
+	*serdes_map_array = board_serdes_map;
+	*count = ARRAY_SIZE(board_serdes_map);
+	return 0;
+}
+
+/*
+ * Define the DDR layout / topology here in the board file. This will
+ * be used by the DDR3 init code in the SPL U-Boot version to configure
+ * the DDR3 controller.
+ */
+static struct mv_ddr_topology_map board_topology_map = {
+	DEBUG_LEVEL_ERROR,
+	0x1, /* active interfaces */
+	/* cs_mask, mirror, dqs_swap, ck_swap X PUPs */
+	{ { { {0x1, 0, 0, 0},
+	      {0x1, 0, 0, 0},
+	      {0x1, 0, 0, 0},
+	      {0x1, 0, 0, 0},
+	      {0x1, 0, 0, 0} },
+	    SPEED_BIN_DDR_1866L,	/* speed_bin */
+	    MV_DDR_DEV_WIDTH_8BIT,	/* memory_width */
+	    MV_DDR_DIE_CAP_4GBIT,	/* mem_size */
+	    MV_DDR_FREQ_800,		/* frequency */
+	    0, 0,			/* cas_l cas_wl */
+	    MV_DDR_TEMP_LOW,		/* temperature */
+	    MV_DDR_TIM_DEFAULT} },	/* timing */
+	BUS_MASK_32BIT,			/* Busses mask */
+	MV_DDR_CFG_DEFAULT,		/* ddr configuration data source */
+	{ {0} },			/* raw spd data */
+	{0}				/* timing parameters */
+};
+
+struct mv_ddr_topology_map *mv_ddr_topology_map_get(void)
+{
+	/* Return the board topology as defined in the board code */
+	return &board_topology_map;
+}
+
+int board_early_init_f(void)
+{
+	/* Configure MPP */
+	writel(0x11111111, MVEBU_MPP_BASE + 0x00);
+	writel(0x11111111, MVEBU_MPP_BASE + 0x04);
+	writel(0x55066011, MVEBU_MPP_BASE + 0x08);
+	writel(0x05050050, MVEBU_MPP_BASE + 0x0c);
+	writel(0x05055555, MVEBU_MPP_BASE + 0x10);
+	writel(0x01100565, MVEBU_MPP_BASE + 0x14);
+	writel(0x00000000, MVEBU_MPP_BASE + 0x18);
+	writel(0x00004444, MVEBU_MPP_BASE + 0x1c);
+
+	/* Set GPP Out value */
+	writel(DB_AP_88F68XX_GPP_OUT_VAL_LOW, MVEBU_GPIO0_BASE + 0x00);
+	writel(DB_AP_88F68XX_GPP_OUT_VAL_MID, MVEBU_GPIO1_BASE + 0x00);
+	writel(DB_AP_88F68XX_GPP_OUT_VAL_HIGH, MVEBU_GPIO1_BASE + 0x40 + 0x00);
+
+	/* Set GPP Polarity */
+	writel(DB_AP_88F68XX_GPP_POL_LOW, MVEBU_GPIO0_BASE + 0x0c);
+	writel(DB_AP_88F68XX_GPP_POL_MID, MVEBU_GPIO1_BASE + 0x0c);
+	writel(DB_AP_88F68XX_GPP_POL_HIGH, (MVEBU_GPIO1_BASE + 0x40) + 0x0c);
+
+	/* Set GPP Out Enable */
+	writel(DB_AP_88F68XX_GPP_OUT_ENA_LOW, MVEBU_GPIO0_BASE + 0x04);
+	writel(DB_AP_88F68XX_GPP_OUT_ENA_MID, MVEBU_GPIO1_BASE + 0x04);
+	writel(DB_AP_88F68XX_GPP_OUT_ENA_HIGH, (MVEBU_GPIO1_BASE + 0x40) +
+	       0x04);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = mvebu_sdram_bar(0) + 0x100;
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: Marvell DB-88F6820-AP\n");
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	cpu_eth_init(bis); /* Built in controller(s) come first */
+	return pci_eth_init(bis);
+}
diff --git a/board/Marvell/db-88f6820-ap/kwbimage.cfg b/board/Marvell/db-88f6820-ap/kwbimage.cfg
new file mode 100644
index 0000000000..9d271469d3
--- /dev/null
+++ b/board/Marvell/db-88f6820-ap/kwbimage.cfg
@@ -0,0 +1,12 @@
+#
+# Copyright (C) 2018 Grzegorz Jaszczyk <jaz@semihalf.com>
+#
+
+# Armada XP uses version 1 image format
+VERSION		1
+
+# Boot Media configurations
+BOOT_FROM	nand
+
+# Binary Header (bin_hdr) with DDR3 training code
+BINARY spl/u-boot-spl-dtb.bin 0000005b 00000068
diff --git a/board/Marvell/mvebu_armada-37xx/board.c b/board/Marvell/mvebu_armada-37xx/board.c
index bef4e1767c..3d5ce8f36c 100644
--- a/board/Marvell/mvebu_armada-37xx/board.c
+++ b/board/Marvell/mvebu_armada-37xx/board.c
@@ -10,15 +10,29 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
+/* on Armada3700 rev2 devel-board, IO expander (with I2C address 0x22) bit
+ * 14 is used as Serdes Lane 2 muxing, which could be used as SATA PHY or
+ * USB3 PHY.
+ */
+enum COMPHY_LANE2_MUXING {
+	COMPHY_LANE2_MUX_USB3,
+	COMPHY_LANE2_MUX_SATA
+};
+
 /* IO expander I2C device */
 #define I2C_IO_EXP_ADDR		0x22
 #define I2C_IO_CFG_REG_0	0x6
 #define I2C_IO_DATA_OUT_REG_0	0x2
 #define I2C_IO_REG_0_SATA_OFF	2
 #define I2C_IO_REG_0_USB_H_OFF	1
+#define I2C_IO_COMPHY_SATA3_USB_MUX_BIT	14
 
 /* The pin control values are the same for DB and Espressobin */
 #define PINCTRL_NB_REG_VALUE	0x000173fa
@@ -47,8 +61,73 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MVEBU_G2_SMI_PHY_CMD_REG	(24)
 #define MVEBU_G2_SMI_PHY_DATA_REG	(25)
 
+/*
+* For Armada3700 A0 chip, comphy serdes lane 2 could be used as PHY for SATA
+* or USB3.
+* For Armada3700 rev2 devel-board, pin 14 of IO expander PCA9555 with I2C
+* address 0x22 is used as Serdes Lane 2 muxing; the pin needs to be set in
+* output mode: high level is for SATA while low level is for USB3;
+*/
+static int board_comphy_usb3_sata_mux(enum COMPHY_LANE2_MUXING comphy_mux)
+{
+	int ret;
+	u8 buf[8];
+	struct udevice *i2c_dev;
+	int i2c_byte, i2c_bit_in_byte;
+
+	if (!of_machine_is_compatible("marvell,armada-3720-db-v2") &&
+	    !of_machine_is_compatible("marvell,armada-3720-db-v3"))
+		return 0;
+
+	ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &i2c_dev);
+	if (ret) {
+		printf("Cannot find PCA9555: %d\n", ret);
+		return 0;
+	}
+
+	ret = dm_i2c_read(i2c_dev, I2C_IO_CFG_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to read IO expander value via I2C\n");
+		return ret;
+	}
+
+	i2c_byte = I2C_IO_COMPHY_SATA3_USB_MUX_BIT / 8;
+	i2c_bit_in_byte = I2C_IO_COMPHY_SATA3_USB_MUX_BIT % 8;
+
+	/* Configure IO exander bit 14 of address 0x22 in output mode */
+	buf[i2c_byte] &= ~(1 << i2c_bit_in_byte);
+	ret = dm_i2c_write(i2c_dev, I2C_IO_CFG_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to set IO expander via I2C\n");
+		return ret;
+	}
+
+	ret = dm_i2c_read(i2c_dev, I2C_IO_DATA_OUT_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to read IO expander value via I2C\n");
+		return ret;
+	}
+
+	/* Configure output level for IO exander bit 14 of address 0x22 */
+	if (comphy_mux == COMPHY_LANE2_MUX_SATA)
+		buf[i2c_byte] |= (1 << i2c_bit_in_byte);
+	else
+		buf[i2c_byte] &= ~(1 << i2c_bit_in_byte);
+
+	ret = dm_i2c_write(i2c_dev, I2C_IO_DATA_OUT_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to set IO expander via I2C\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 int board_early_init_f(void)
 {
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
 	return 0;
 }
 
@@ -57,6 +136,9 @@ int board_init(void)
 	/* adress of boot parameters */
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 
+	/* enable serdes lane 2 mux for sata phy */
+	board_comphy_usb3_sata_mux(COMPHY_LANE2_MUX_SATA);
+
 	return 0;
 }
 
diff --git a/board/Marvell/mvebu_armada-8k/board.c b/board/Marvell/mvebu_armada-8k/board.c
index e927e338ea..c348b8c630 100644
--- a/board/Marvell/mvebu_armada-8k/board.c
+++ b/board/Marvell/mvebu_armada-8k/board.c
@@ -4,158 +4,129 @@
  */
 
 #include <common.h>
+#include <console.h>
 #include <dm.h>
 #include <i2c.h>
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
+
+#define CP_USB20_BASE_REG(cp, p)	(MVEBU_REGS_BASE_CP(0, cp) + \
+						0x00580000 + 0x1000 * (p))
+#define CP_USB20_TX_CTRL_REG(cp, p)	(CP_USB20_BASE_REG(cp, p) + 0xC)
+#define CP_USB20_TX_OUT_AMPL_MASK	(0x7 << 20)
+#define CP_USB20_TX_OUT_AMPL_VALUE	(0x3 << 20)
 
 DECLARE_GLOBAL_DATA_PTR;
 
-/*
- * Information specific to the DB-88F7040 eval board. We strive to use
- * DT for such platform specfic configurations. At some point, this
- * might be removed here and implemented via DT.
- */
-/* IO expander I2C device */
-#define I2C_IO_EXP_ADDR		0x21
-#define I2C_IO_CFG_REG_0	0x6
-#define I2C_IO_DATA_OUT_REG_0	0x2
-/* VBus enable */
-#define I2C_IO_REG_0_USB_H0_OFF	0
-#define I2C_IO_REG_0_USB_H1_OFF	1
-#define I2C_IO_REG_VBUS		((1 << I2C_IO_REG_0_USB_H0_OFF) | \
-				 (1 << I2C_IO_REG_0_USB_H1_OFF))
-/* Current limit */
-#define I2C_IO_REG_0_USB_H0_CL	4
-#define I2C_IO_REG_0_USB_H1_CL	5
-#define I2C_IO_REG_CL		((1 << I2C_IO_REG_0_USB_H0_CL) | \
-				 (1 << I2C_IO_REG_0_USB_H1_CL))
-
-static int usb_enabled = 0;
-
-/* Board specific xHCI dis-/enable code */
+#define BOOTCMD_NAME	"pci-bootcmd"
 
-/*
- * Set USB VBUS signals (via I2C IO expander/GPIO) as output and set
- * output value as disabled
- *
- * Set USB Current Limit signals (via I2C IO expander/GPIO) as output
- * and set output value as enabled
- */
-int board_xhci_config(void)
+int __soc_early_init_f(void)
 {
-	struct udevice *dev;
-	int ret;
-	u8 buf[8];
-
-	if (of_machine_is_compatible("marvell,armada7040-db")) {
-		/* Configure IO exander PCA9555: 7bit address 0x21 */
-		ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &dev);
-		if (ret) {
-			printf("Cannot find PCA9555: %d\n", ret);
-			return 0;
-		}
-
-		/*
-		 * Read configuration (direction) and set VBUS pin as output
-		 * (reset pin = output)
-		 */
-		ret = dm_i2c_read(dev, I2C_IO_CFG_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-		buf[0] &= ~I2C_IO_REG_VBUS;
-		buf[0] &= ~I2C_IO_REG_CL;
-		ret = dm_i2c_write(dev, I2C_IO_CFG_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		/* Read output value and configure it */
-		ret = dm_i2c_read(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-		buf[0] &= ~I2C_IO_REG_VBUS;
-		buf[0] |= I2C_IO_REG_CL;
-		ret = dm_i2c_write(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		mdelay(500); /* required delay to let output value settle */
-	}
-
 	return 0;
 }
 
-int board_xhci_enable(fdt_addr_t base)
+int soc_early_init_f(void) __attribute__((weak, alias("__soc_early_init_f")));
+
+int board_early_init_f(void)
 {
-	struct udevice *dev;
-	int ret;
-	u8 buf[8];
-
-	if (of_machine_is_compatible("marvell,armada7040-db")) {
-		/*
-		 * This function enables all USB ports simultaniously,
-		 * it only needs to get called once
-		 */
-		if (usb_enabled)
-			return 0;
-
-		/* Configure IO exander PCA9555: 7bit address 0x21 */
-		ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &dev);
-		if (ret) {
-			printf("Cannot find PCA9555: %d\n", ret);
-			return 0;
-		}
-
-		/* Read VBUS output value */
-		ret = dm_i2c_read(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-
-		/* Enable VBUS power: Set output value of VBUS pin as enabled */
-		buf[0] |= I2C_IO_REG_VBUS;
-		ret = dm_i2c_write(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		mdelay(500); /* required delay to let output value settle */
-		usb_enabled = 1;
-	}
+	soc_early_init_f();
 
 	return 0;
 }
 
-int board_early_init_f(void)
+int board_early_init_r(void)
 {
-	/* Nothing to do (yet), perhaps later some pin-muxing etc */
+#ifdef CONFIG_DM_REGULATOR
+	/* Check if any existing regulator should be turned down */
+	regulators_enable_boot_off(false);
+#endif
 
 	return 0;
 }
 
 int board_init(void)
 {
-	/* adress of boot parameters */
+	/* address of boot parameters */
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+
 	return 0;
 }
 
+#if (CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD) ||	\
+	CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)) &&	\
+	!CONFIG_IS_ENABLED(CONSOLE_MUX)
+# error CONFIG_CONSOLE_MUX must be enabled!
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+static int init_bootcmd_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	struct udevice *bootcmd_dev = NULL;
+	bool stdin_set;
+	char iomux_name[128];
+
+	debug("%s: stdin before: %s\n", __func__,
+	      stdinname ? stdinname : "NONE");
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	stdin_set = !!strstr(stdinname, BOOTCMD_NAME);
+	ret = uclass_get_device_by_driver(UCLASS_SERIAL,
+					  DM_GET_DRIVER(octeontx_bootcmd),
+					  &bootcmd_dev);
+	if (ret) {
+		pr_err("%s: Error getting %s serial class\n", __func__,
+		       BOOTCMD_NAME);
+	} else if (bootcmd_dev) {
+		if (stdin_set)
+			strncpy(iomux_name, stdinname, sizeof(iomux_name));
+		else
+			snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+				 stdinname, bootcmd_dev->name);
+		ret = iomux_doenv(stdin, iomux_name);
+		if (ret)
+			pr_err("%s: Error %d enabling the PCI bootcmd input console \"%s\"\n",
+			       __func__, ret, iomux_name);
+		if (!stdin_set)
+			env_set("stdin", iomux_name);
+	}
+	debug("%s: Set iomux and stdin to %s (ret: %d)\n",
+	      __func__, iomux_name, ret);
+	return ret;
+}
+#endif
+
 int board_late_init(void)
 {
 	/* Pre-configure the USB ports (overcurrent, VBus) */
-	board_xhci_config();
 
+	/* Adjust the USB 2.0 port TX output driver amplitude
+	 * for passing compatibility tests
+	 */
+	if (of_machine_is_compatible("marvell,armada3900-vd")) {
+		u32 port;
+
+		for (port = 0; port < 2; port++)
+			clrsetbits_le32(CP_USB20_TX_CTRL_REG(0, port),
+					CP_USB20_TX_OUT_AMPL_MASK,
+					CP_USB20_TX_OUT_AMPL_VALUE);
+	}
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+	if (init_bootcmd_console())
+		printf("Failed to init bootcmd input\n");
+#endif
 	return 0;
 }
diff --git a/board/Marvell/octeontx/Kconfig b/board/Marvell/octeontx/Kconfig
new file mode 100644
index 0000000000..45d115916c
--- /dev/null
+++ b/board/Marvell/octeontx/Kconfig
@@ -0,0 +1,14 @@
+if TARGET_OCTEONTX_81XX || TARGET_OCTEONTX_83XX
+
+config SYS_VENDOR
+	string
+	default	"Marvell"
+
+config SYS_BOARD
+	string
+	default "octeontx"
+
+config SYS_CONFIG_NAME
+	default "octeontx_common"
+
+endif
diff --git a/board/Marvell/octeontx/MAINTAINERS b/board/Marvell/octeontx/MAINTAINERS
new file mode 100644
index 0000000000..10816c7a03
--- /dev/null
+++ b/board/Marvell/octeontx/MAINTAINERS
@@ -0,0 +1,9 @@
+OCTEONTX BOARD
+M:	Suneel Garapati <sgarapati@marvell.com>
+M:	Aaron Williams <awilliams@marvell.com>
+S:	Maintained
+F:	board/Marvell/octeontx/
+F:	include/configs/octeontx_81xx.h
+F:	include/configs/octeontx_83xx.h
+F:	configs/octeontx_81xx_defconfig
+F:	configs/octeontx_83xx_defconfig
diff --git a/board/Marvell/octeontx/Makefile b/board/Marvell/octeontx/Makefile
new file mode 100644
index 0000000000..fbe32ae003
--- /dev/null
+++ b/board/Marvell/octeontx/Makefile
@@ -0,0 +1,9 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y	:= board.o smc.o soc-utils.o
+obj-$(CONFIG_OF_LIBFDT) += board-fdt.o
diff --git a/board/Marvell/octeontx/board-fdt.c b/board/Marvell/octeontx/board-fdt.c
new file mode 100644
index 0000000000..8124e9e4b9
--- /dev/null
+++ b/board/Marvell/octeontx/board-fdt.c
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <env.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+#ifdef CONFIG_NET_OCTEONTX
+static int fdt_get_mdio_bus(const void *fdt, int phy_offset)
+{
+	int node, bus = -1;
+	const u64 *reg;
+	u64 addr;
+
+	if (phy_offset < 0)
+		return -1;
+	/* obtain mdio node and get the reg prop */
+	node = fdt_parent_offset(fdt, phy_offset);
+	if (node < 0)
+		return -1;
+
+	reg = fdt_getprop(fdt, node, "reg", NULL);
+	addr = fdt64_to_cpu(*reg);
+	bus = (addr & (1 << 7)) ? 1 : 0;
+	return bus;
+}
+
+static int fdt_get_phy_addr(const void *fdt, int phy_offset)
+{
+	const u32 *reg;
+	int addr = -1;
+
+	if (phy_offset < 0)
+		return -1;
+	reg = fdt_getprop(fdt, phy_offset, "reg", NULL);
+	addr = fdt32_to_cpu(*reg);
+	return addr;
+}
+
+void fdt_parse_phy_info(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int offset = 0, node, bgx_id = 0, lmacid = 0;
+	const u32 *val;
+	char bgxname[24];
+	int len, rgx_id = 0, eth_id = 0;
+	int phandle, phy_offset;
+	int subnode, i;
+	int bdknode;
+
+	bdknode = fdt_path_offset(fdt, "/cavium,bdk");
+	if (bdknode < 0) {
+		printf("%s: bdk node is missing from device tree: %s\n",
+		       __func__, fdt_strerror(bdknode));
+	}
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 1)
+		return;
+
+	for (bgx_id = 0; bgx_id < MAX_BGX_PER_NODE; bgx_id++) {
+		int phy_addr[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
+		bool autoneg_dis[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+		int mdio_bus[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = -1};
+		bool lmac_reg[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+		bool lmac_enable[LMAC_CNT] = {[0 ... LMAC_CNT - 1] = 0};
+
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx_id);
+		node = fdt_subnode_offset(fdt, offset, bgxname);
+		if (node < 0) {
+			/* check if it is rgx node */
+			snprintf(bgxname, sizeof(bgxname), "rgx%d", rgx_id);
+			node = fdt_subnode_offset(fdt, offset, bgxname);
+			if (node < 0) {
+				debug("bgx%d/rgx0 node not found\n", bgx_id);
+				return;
+			}
+		}
+		debug("bgx%d node found\n", bgx_id);
+
+		/*
+		 * loop through each of the bgx/rgx nodes
+		 * to find PHY nodes
+		 */
+		fdt_for_each_subnode(subnode, fdt, node) {
+			/* Check for reg property */
+			val = fdt_getprop(fdt, subnode, "reg", &len);
+			if (val) {
+				debug("lmacid = %d\n", lmacid);
+				lmac_reg[lmacid] = 1;
+			}
+			/* check for phy-handle property */
+			val = fdt_getprop(fdt, subnode, "phy-handle", &len);
+			if (val) {
+				phandle = fdt32_to_cpu(*val);
+				if (!phandle) {
+					debug("phandle not valid %d\n", lmacid);
+				} else {
+					phy_offset = fdt_node_offset_by_phandle
+							(fdt, phandle);
+					phy_addr[lmacid] = fdt_get_phy_addr
+							(fdt, phy_offset);
+					mdio_bus[lmacid] = fdt_get_mdio_bus
+							(fdt, phy_offset);
+					}
+				} else {
+					debug("phy-handle prop not found %d\n",
+					      lmacid);
+				}
+				/* check for autonegotiation property */
+				val = fdt_getprop(fdt, subnode,
+						  "cavium,disable-autonegotiation",
+						  &len);
+				if (val)
+					autoneg_dis[lmacid] = 1;
+
+				eth_id++;
+				lmacid++;
+			}
+
+			for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
+				const char *str;
+
+				snprintf(bgxname, sizeof(bgxname),
+					 "BGX-ENABLE.N0.BGX%d.P%d", bgx_id, i);
+				if (bdknode >= 0) {
+					str = fdt_getprop(fdt, bdknode,
+							  bgxname, &len);
+					if (str)
+						lmac_enable[i] =
+							simple_strtol(str, NULL,
+								      10);
+				}
+			}
+
+			lmacid = 0;
+			bgx_set_board_info(bgx_id, mdio_bus, phy_addr,
+					   autoneg_dis, lmac_reg, lmac_enable);
+		}
+}
+#endif
+
+static int fdt_get_bdk_node(void)
+{
+	int node, ret;
+	const void *fdt = gd->fdt_blob;
+
+	if (!fdt) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return 0;
+	}
+
+	ret = fdt_check_header(fdt);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return 0;
+	}
+
+	node = fdt_path_offset(fdt, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return 0;
+	}
+	return node;
+}
+
+const char *fdt_get_board_serial(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int node, len = 64;
+	const char *str = NULL;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+
+	str = fdt_getprop(fdt, node, "BOARD-SERIAL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board serial from fdt\n");
+	return str;
+}
+
+const char *fdt_get_board_revision(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int node, len = 64;
+	const char *str = NULL;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+
+	str = fdt_getprop(fdt, node, "BOARD-REVISION", &len);
+	if (!str)
+		printf("Error: cannot retrieve board revision from fdt\n");
+	return str;
+}
+
+const char *fdt_get_board_model(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int node, len = 16;
+	const char *str = NULL;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+
+	str = fdt_getprop(fdt, node, "BOARD-MODEL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board model from fdt\n");
+	return str;
+}
+
+void fdt_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
+{
+	const void *fdt = gd->fdt_blob;
+	const char *mac = NULL;
+	int offset = 0, node, len;
+	int subnode, i = 0;
+	char bgxname[24];
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 0) {
+		printf("%s couldn't find mrml bridge node in fdt\n",
+		       __func__);
+		return;
+	}
+	if (bgx == 2 && otx_is_soc(CN81XX)) {
+		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
+		lmac = 0;
+	} else {
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx);
+	}
+
+	node = fdt_subnode_offset(fdt, offset, bgxname);
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		if (i++ != lmac)
+			continue;
+		/* check for local-mac-address */
+		mac = fdt_getprop(fdt, subnode, "local-mac-address", &len);
+		if (mac) {
+			debug("%s mac %pM\n", __func__, mac);
+			memcpy(eth, mac, ARP_HLEN);
+		} else {
+			memset(eth, 0, ARP_HLEN);
+		}
+		debug("%s eth %pM\n", __func__, eth);
+		return;
+	}
+}
+
+#ifdef ALLOW_USER_MAC_ADDR
+void fdt_board_update_macaddr(int bgxid, int lmacid, char *mac)
+{
+	void *fdt = (void *)gd->fdt_blob;
+	int offset = 0, node;
+	int subnode, i = 0;
+	char bgxname[24], macaddr[ARP_HLEN];
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 0) {
+		printf("%s couldn't find mrml bridge node in fdt\n",
+		       __func__);
+		return;
+	}
+	if (bgxid == 2 && otx_is_soc(CN81XX)) {
+		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
+		lmacid = 0;
+	} else {
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgxid);
+	}
+
+	node = fdt_subnode_offset(fdt, offset, bgxname);
+
+	memcpy(macaddr, mac, ARP_HLEN);
+	fdt_for_each_subnode(subnode, fdt, node) {
+		/* update lmac node's local-mac-address */
+		if (i++ == lmacid)
+			fdt_setprop(fdt, subnode, "local-mac-address",
+				    (void *)macaddr, sizeof(macaddr));
+	}
+}
+#endif
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* remove "cavium, bdk" node from DT */
+	int ret = 0, offset;
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob) {
+		offset = fdt_path_offset(blob, "/cavium,bdk");
+		if (offset < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return offset;
+		}
+
+		/* delete node */
+		ret = fdt_del_node(blob, offset);
+		if (ret < 0) {
+			printf("WARNING : could not remove bdk node\n");
+			return ret;
+		}
+
+		debug("%s deleted bdk node\n", __func__);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx/board.c b/board/Marvell/octeontx/board.c
new file mode 100644
index 0000000000..123d35d2cc
--- /dev/null
+++ b/board/Marvell/octeontx/board.c
@@ -0,0 +1,321 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <console.h>
+#include <dm.h>
+#include <dm/uclass-internal.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BOOTCMD_NAME	"pci-bootcmd"
+#define CONSOLE_NAME	"pci-console@0"
+
+extern unsigned long fdt_base_addr;
+
+void octeontx_cleanup_ethaddr(void)
+{
+	char ename[32];
+
+	for (int i = 0; i < 20; i++) {
+		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
+		if (env_get(ename))
+			env_set(ename, NULL);
+	}
+}
+
+int octeontx_board_has_pmp(void)
+{
+	return (otx_is_board("sff8104") || otx_is_board("nas8104"));
+}
+
+int board_early_init_r(void)
+{
+	pci_init();
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_NET_OCTEONTX
+	fdt_parse_phy_info();
+#endif
+	return 0;
+}
+
+int timer_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = smc_dram_size(0);
+	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
+	mem_map_fill();
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_OCTEONTX
+void board_late_probe_devices(void)
+{
+	struct udevice *dev;
+	int err, bgx_cnt, i;
+
+	/* Probe MAC(BGX) and NIC PF devices before Network stack init */
+	bgx_cnt = otx_is_soc(CN81XX) ? 2 : 4;
+	for (i = 0; i < bgx_cnt; i++) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA026, i,
+					 &dev);
+		if (err)
+			debug("%s BGX%d device not found\n", __func__, i);
+	}
+	if (otx_is_soc(CN81XX)) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA054, 0,
+					 &dev);
+		if (err)
+			debug("%s RGX device not found\n", __func__);
+	}
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA01E, 0, &dev);
+	if (err)
+		debug("NIC PF device not found\n");
+}
+#endif
+
+#if (CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD) ||	\
+	CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)) &&	\
+	!CONFIG_IS_ENABLED(CONSOLE_MUX)
+# error CONFIG_CONSOLE_MUX must be enabled!
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+static int init_bootcmd_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	struct udevice *bootcmd_dev = NULL;
+	bool stdin_set;
+	char iomux_name[128];
+
+	debug("%s: stdin before: %s\n", __func__,
+	      stdinname ? stdinname : "NONE");
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	stdin_set = !!strstr(stdinname, BOOTCMD_NAME);
+	ret = uclass_get_device_by_driver(UCLASS_SERIAL,
+					  DM_GET_DRIVER(octeontx_bootcmd),
+					  &bootcmd_dev);
+	if (ret) {
+		pr_err("%s: Error getting %s serial class\n", __func__,
+		       BOOTCMD_NAME);
+	} else if (bootcmd_dev) {
+		if (stdin_set)
+			strncpy(iomux_name, stdinname, sizeof(iomux_name));
+		else
+			snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+				 stdinname, bootcmd_dev->name);
+		ret = iomux_doenv(stdin, iomux_name);
+		if (ret)
+			pr_err("%s: Error %d enabling the PCI bootcmd input console \"%s\"\n",
+			       __func__, ret, iomux_name);
+		if (!stdin_set)
+			env_set("stdin", iomux_name);
+	}
+	debug("%s: Set iomux and stdin to %s (ret: %d)\n",
+	      __func__, iomux_name, ret);
+	return ret;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)
+static int init_pcie_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	char *stdoutname = env_get("stdout");
+	char *stderrname = env_get("stderr");
+	struct udevice *pcie_console_dev = NULL;
+	bool stdin_set, stdout_set, stderr_set;
+	char iomux_name[128];
+
+	debug("%s: stdin: %s, stdout: %s, stderr: %s\n", __func__, stdinname,
+	      stdoutname, stderrname);
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	if (!stdoutname) {
+		env_set("stdout", "serial");
+		stdoutname = env_get("stdout");
+	}
+	if (!stderrname) {
+		env_set("stderr", "serial");
+		stderrname = env_get("stderr");
+	}
+
+	if (!stdinname || !stdoutname || !stderrname) {
+		printf("%s: Error setting environment variables for serial\n",
+		       __func__);
+		return -1;
+	}
+
+	stdin_set = !!strstr(stdinname, CONSOLE_NAME);
+	stdout_set = !!strstr(stdoutname, CONSOLE_NAME);
+	stderr_set = !!strstr(stderrname, CONSOLE_NAME);
+
+	pr_debug("stdin: %d, \"%s\", stdout: %d, \"%s\", stderr: %d, \"%s\"\n",
+		 stdin_set, stdinname, stdout_set, stdoutname,
+		 stderr_set, stderrname);
+	ret = uclass_get_device_by_name(UCLASS_SERIAL, CONSOLE_NAME,
+					&pcie_console_dev);
+	if (ret || !pcie_console_dev) {
+		debug("%s: No PCI console device %s found\n", __func__,
+		      CONSOLE_NAME);
+		return 0;
+	}
+
+	if (stdin_set)
+		strncpy(iomux_name, stdinname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+			 stdinname, pcie_console_dev->name);
+
+	ret = iomux_doenv(stdin, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stdin MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+
+	if (!stdin_set)
+		env_set("stdin", iomux_name);
+
+	if (stdout_set)
+		strncpy(iomux_name, stdoutname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s", stdoutname,
+			 pcie_console_dev->name);
+
+	ret = iomux_doenv(stdout, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stdout MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+	if (!stdout_set)
+		env_set("stdout", iomux_name);
+
+	if (stderr_set)
+		strncpy(iomux_name, stderrname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s", stderrname,
+			 pcie_console_dev->name);
+
+	ret = iomux_doenv(stderr, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stderr MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+
+	if (!stderr_set)
+		env_set("stderr", iomux_name);
+
+	debug("%s: stdin: %s, stdout: %s, stderr: %s, ret: %d\n",
+	      __func__, env_get("stdin"), env_get("stdout"),
+	      env_get("stderr"), ret);
+
+	return ret;
+}
+#endif
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[32];
+	char boardserial[150], boardrev[150];
+	bool save_env = false;
+	const char *str;
+
+	/*
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of network interfaces can change.
+	 */
+	octeontx_cleanup_ethaddr();
+
+	snprintf(boardname, sizeof(boardname), "%s> ", fdt_get_board_model());
+	env_set("prompt", boardname);
+
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+
+	str = fdt_get_board_revision();
+	if (str) {
+		snprintf(boardrev, sizeof(boardrev), "%s", str);
+		if (env_get("boardrev") &&
+		    strcmp(boardrev, env_get("boardrev")))
+			save_env = true;
+		env_set("boardrev", boardrev);
+	}
+
+	str = fdt_get_board_serial();
+	if (str) {
+		snprintf(boardserial, sizeof(boardserial), "%s", str);
+		if (env_get("serial#") &&
+		    strcmp(boardserial, env_get("serial#")))
+			save_env = true;
+		env_set("serial#", boardserial);
+	}
+
+#ifdef CONFIG_NET_OCTEONTX
+	board_late_probe_devices();
+#endif
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+	if (init_bootcmd_console())
+		printf("Failed to init bootcmd input\n");
+#endif
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)
+	if (init_pcie_console())
+		printf("Failed to init pci console\n");
+#endif
+	if (save_env)
+		env_save();
+	return 0;
+}
+
+/*
+ * Invoked before relocation, so limit to stack variables.
+ */
+int show_board_info(void)
+{
+	char *str = NULL;
+
+	if (otx_is_soc(CN81XX))
+		str = "CN81XX";
+	if (otx_is_soc(CN83XX))
+		str = "CN83XX";
+	printf("OcteonTX %s ARM V8 Core\n", str);
+
+	printf("Board: %s\n", fdt_get_board_model());
+
+	return 0;
+}
diff --git a/board/Marvell/octeontx/smc.c b/board/Marvell/octeontx/smc.c
new file mode 100644
index 0000000000..e74f6794fa
--- /dev/null
+++ b/board/Marvell/octeontx/smc.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include <asm/system.h>
+#include <asm/arch/smc.h>
+
+#include <asm/psci.h>
+
+#include <malloc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ssize_t smc_dram_size(unsigned int node)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX_DRAM_SIZE;
+	regs.regs[1] = node;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
diff --git a/board/Marvell/octeontx/soc-utils.c b/board/Marvell/octeontx/soc-utils.c
new file mode 100644
index 0000000000..33f8ae27c9
--- /dev/null
+++ b/board/Marvell/octeontx/soc-utils.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+platform_t read_platform(void)
+{
+	platform_t plat = PLATFORM_HW;
+
+	const char *model = fdt_get_board_model();
+
+	if (model && !strncmp(model, "ASIM-", 5))
+		plat = PLATFORM_ASIM;
+	if (model && !strncmp(model, "EMUL-", 5))
+		plat = PLATFORM_EMULATOR;
+	return plat;
+}
+
+static inline u64 read_midr(void)
+{
+	u64 result;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (result));
+	return result;
+}
+
+u8 read_partnum(void)
+{
+	return ((read_midr() >> 4) & 0xFF);
+}
+
+const char *read_board_name(void)
+{
+	return fdt_get_board_model();
+}
+
+bool read_alt_pkg(void)
+{
+	union mio_fus_dat2 fus_dat2;
+
+	fus_dat2.u = readq(MIO_FUS_DAT2);
+	if (fus_dat2.s.chip_id >> 6)
+		return true;
+	/* Some parts only have lmc_mode32 set */
+	if (read_partnum() == CN81XX && fus_dat2.s.lmc_mode32)
+		return true;
+	return false;
+}
diff --git a/board/Marvell/octeontx2/Kconfig b/board/Marvell/octeontx2/Kconfig
new file mode 100644
index 0000000000..ff09050f5a
--- /dev/null
+++ b/board/Marvell/octeontx2/Kconfig
@@ -0,0 +1,18 @@
+if TARGET_OCTEONTX2_95XX || TARGET_OCTEONTX2_96XX || TARGET_OCTEONTX2_LOKI || TARGET_OCTEONTX2_98XX || TARGET_OCTEONTX2_95MM
+
+config SYS_VENDOR
+	string
+	default	"Marvell"
+
+config SYS_BOARD
+	string
+	default "octeontx2"
+
+config SYS_CONFIG_NAME
+	default "octeontx2_96xx" if TARGET_OCTEONTX2_96XX
+	default "octeontx2_95xx" if TARGET_OCTEONTX2_95XX
+	default "octeontx2_loki" if TARGET_OCTEONTX2_LOKI
+	default "octeontx2_98xx" if TARGET_OCTEONTX2_98XX
+	default "octeontx2_95mm" if TARGET_OCTEONTX2_95MM
+
+endif
diff --git a/board/Marvell/octeontx2/MAINTAINERS b/board/Marvell/octeontx2/MAINTAINERS
new file mode 100644
index 0000000000..73026ccdc6
--- /dev/null
+++ b/board/Marvell/octeontx2/MAINTAINERS
@@ -0,0 +1,9 @@
+OCTEONTX2 BOARD
+M:	Suneel Garapati <sgarapati@marvell.com>
+M:	Aaron Williams <awilliams@marvell.com>
+S:	Maintained
+F:	board/Marvell/octeontx2/
+F:	include/configs/octeontx2_96xx.h
+F:	include/configs/octeontx2_95xx.h
+F:	configs/octeontx2_96xx_defconfig
+F:	configs/octeontx2_95xx_defconfig
diff --git a/board/Marvell/octeontx2/Makefile b/board/Marvell/octeontx2/Makefile
new file mode 100644
index 0000000000..1f763b197b
--- /dev/null
+++ b/board/Marvell/octeontx2/Makefile
@@ -0,0 +1,9 @@
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * https://spdx.org/licenses
+# */
+
+obj-y	:= board.o smc.o soc-utils.o
+obj-$(CONFIG_OF_LIBFDT) += board-fdt.o
diff --git a/board/Marvell/octeontx2/board-fdt.c b/board/Marvell/octeontx2/board-fdt.c
new file mode 100644
index 0000000000..c975bcdf71
--- /dev/null
+++ b/board/Marvell/octeontx2/board-fdt.c
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <env.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/board.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+static int fdt_get_bdk_node(void)
+{
+	int node, ret;
+	const void *fdt = gd->fdt_blob;
+
+	if (!fdt) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return 0;
+	}
+
+	ret = fdt_check_header(fdt);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return 0;
+	}
+
+	node = fdt_path_offset(fdt, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return 0;
+	}
+	return node;
+}
+
+u64 fdt_get_board_mac_addr(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+	u64 mac_addr = 0;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return mac_addr;
+	str = fdt_getprop(fdt, node, "BOARD-MAC-ADDRESS", &len);
+	if (str)
+		mac_addr = simple_strtol(str, NULL, 16);
+	return mac_addr;
+}
+
+int fdt_get_board_mac_cnt(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+	int mac_count = 0;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return mac_count;
+	str = fdt_getprop(fdt, node, "BOARD-MAC-ADDRESS-NUM", &len);
+	if (str) {
+		mac_count = simple_strtol(str, NULL, 10);
+		if (!mac_count)
+			mac_count = simple_strtol(str, NULL, 16);
+		debug("fdt: MAC_NUM %d\n", mac_count);
+	} else {
+		printf("Error: cannot retrieve mac count prop from fdt\n");
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM-OVERRIDE",
+			  &len);
+	if (str) {
+		if (simple_strtol(str, NULL, 10) >= 0)
+			mac_count = simple_strtol(str, NULL, 10);
+		debug("fdt: MAC_NUM %d\n", mac_count);
+	} else {
+		printf("Error: cannot retrieve mac num override prop\n");
+	}
+	return mac_count;
+}
+
+const char *fdt_get_board_serial(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int node, len = 64;
+	const char *str = NULL;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+
+	str = fdt_getprop(fdt, node, "BOARD-SERIAL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board serial from fdt\n");
+	return str;
+}
+
+const char *fdt_get_board_revision(void)
+{
+	const void *fdt = gd->fdt_blob;
+	int node, len = 64;
+	const char *str = NULL;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+
+	str = fdt_getprop(fdt, node, "BOARD-REVISION", &len);
+	if (!str)
+		printf("Error: cannot retrieve board revision from fdt\n");
+	return str;
+}
+
+const char *fdt_get_board_model(void)
+{
+	int node, len = 16;
+	const char *str = NULL;
+	const void *fdt = gd->fdt_blob;
+
+	node = fdt_get_bdk_node();
+	if (!node)
+		return NULL;
+	str = fdt_getprop(fdt, node, "BOARD-MODEL", &len);
+	if (!str)
+		printf("Error: cannot retrieve board model from fdt\n");
+	return str;
+}
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	int nodeoff, node, ret, i;
+	const char *temp;
+
+	static const char * const
+		octeontx_brd_nodes[] = {"BOARD-MODEL",
+					"BOARD-SERIAL",
+					"BOARD-MAC-ADDRESS",
+					"BOARD-REVISION",
+					"BOARD-MAC-ADDRESS-NUM"
+					};
+	char nodes[ARRAY_SIZE(octeontx_brd_nodes)][32];
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob) {
+		nodeoff = fdt_path_offset(blob, "/cavium,bdk");
+		if (nodeoff < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return nodeoff;
+		}
+
+		/* Read properties in temporary variables */
+		for (i = 0; i < ARRAY_SIZE(octeontx_brd_nodes); i++) {
+			temp = fdt_getprop(blob, nodeoff,
+					   octeontx_brd_nodes[i], NULL);
+			strncpy(nodes[i], temp, sizeof(nodes[i]));
+		}
+
+		/* Delete cavium,bdk node */
+		ret = fdt_del_node(blob, nodeoff);
+		if (ret < 0) {
+			printf("WARNING : could not remove cavium, bdk node\n");
+			return ret;
+		}
+		debug("%s deleted 'cavium,bdk' node\n", __func__);
+		/*
+		 * Add a new node at root level which would have
+		 * necessary info
+		 */
+		node = fdt_add_subnode(blob, 0, "octeontx_brd");
+		if (node < 0) {
+			printf("Cannot create node octeontx_brd: %s\n",
+			       fdt_strerror(node));
+			return -EIO;
+		}
+
+		/* Populate properties in node */
+		for (i = 0; i < ARRAY_SIZE(octeontx_brd_nodes); i++) {
+			if (fdt_setprop_string(blob, node,
+					       octeontx_brd_nodes[i],
+					       nodes[i])) {
+				printf("Can't set %s\n", nodes[i]);
+				return -EIO;
+			}
+		}
+	}
+
+	return 0;
+}
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx2/board.c b/board/Marvell/octeontx2/board.c
new file mode 100644
index 0000000000..39eca2349f
--- /dev/null
+++ b/board/Marvell/octeontx2/board.c
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <console.h>
+#include <dm.h>
+#include <dm/uclass-internal.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BOOTCMD_NAME	"pci-bootcmd"
+#define CONSOLE_NAME	"pci-console@0"
+
+extern unsigned long fdt_base_addr;
+extern void cgx_intf_shutdown(void);
+
+void cleanup_env_ethaddr(void)
+{
+	char ename[32];
+
+	for (int i = 0; i < 20; i++) {
+		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
+		if (env_get(ename))
+			env_set(ename, NULL);
+	}
+}
+
+void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr)
+{
+	u64 tmp_mac, board_mac_addr = fdt_get_board_mac_addr();
+	static int board_mac_num;
+
+	board_mac_num = fdt_get_board_mac_cnt();
+	if ((!is_zero_ethaddr((u8 *)&board_mac_addr)) && board_mac_num) {
+		tmp_mac = board_mac_addr;
+		tmp_mac += index;
+		tmp_mac = swab64(tmp_mac) >> 16;
+		memcpy(mac_addr, (u8 *)&tmp_mac, ARP_HLEN);
+		board_mac_num--;
+	} else {
+		memset(mac_addr, 0, ARP_HLEN);
+	}
+	debug("%s mac %pM\n", __func__, mac_addr);
+}
+
+void board_get_env_spi_bus_cs(int *bus, int *cs)
+{
+	const void *blob = gd->fdt_blob;
+	int env_bus, env_cs;
+	int node, preg;
+
+	env_bus = -1;
+	env_cs = -1;
+	node = fdt_node_offset_by_compatible(blob, -1, "spi-flash");
+	while (node > 0) {
+		if (fdtdec_get_bool(blob, node, "u-boot,env")) {
+			env_cs = fdtdec_get_int(blob, node, "reg", -1);
+			preg = fdtdec_get_int(blob,
+					      fdt_parent_offset(blob, node),
+					      "reg", -1);
+			/* SPI node will have PCI addr, so map it */
+			if (preg == 0x3000)
+				env_bus = 0;
+			if (preg == 0x3800)
+				env_bus = 1;
+			debug("\n Env SPI [bus:cs] [%d:%d]\n",
+			      env_bus, env_cs);
+			break;
+		}
+		node = fdt_node_offset_by_compatible(blob, node, "spi-flash");
+	}
+	if (env_bus == -1)
+		debug("\'u-boot,env\' property not found in fdt\n");
+
+	*bus = env_bus;
+	*cs = env_cs;
+}
+
+void board_quiesce_devices(void)
+{
+	struct uclass *uc_dev;
+	int ret;
+
+	/* Removes all RVU PF devices */
+	ret = uclass_get(UCLASS_ETH, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove rvu pf devices\n");
+
+#ifdef CONFIG_OCTEONTX2_CGX_INTF
+	/* Bring down all cgx lmac links */
+	cgx_intf_shutdown();
+#endif
+
+	/* Removes all CGX and RVU AF devices */
+	ret = uclass_get(UCLASS_MISC, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove misc (cgx/rvu_af) devices\n");
+
+	/* SMC call - removes all LF<->PF mappings */
+	smc_disable_rvu_lfs(0);
+}
+
+int board_early_init_r(void)
+{
+	pci_init();
+	return 0;
+}
+
+int board_init(void)
+{
+	return 0;
+}
+
+int timer_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = smc_dram_size(0);
+	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
+
+	mem_map_fill();
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_OCTEONTX2
+void board_late_probe_devices(void)
+{
+	struct udevice *dev;
+	int err, cgx_cnt, i;
+
+	switch (read_partnum()) {
+	case CN98XX:
+		cgx_cnt = 5;
+		break;
+	case F95MM:
+		cgx_cnt = 2;
+		break;
+	case LOKI:
+		cgx_cnt = 4;
+		break;
+	default:
+		cgx_cnt = 3;
+		break;
+	}
+	/* Probe MAC(CGX) and NIC AF devices before Network stack init */
+	for (i = 0; i < cgx_cnt; i++) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA059, i,
+					 &dev);
+		if (err)
+			debug("%s CGX%d device not found\n", __func__, i);
+	}
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA065, 0, &dev);
+	if (err)
+		debug("NIC AF device not found\n");
+}
+#endif
+
+#if (CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD) ||	\
+	CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)) &&	\
+	!CONFIG_IS_ENABLED(CONSOLE_MUX)
+# error CONFIG_CONSOLE_MUX must be enabled!
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+static int init_bootcmd_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	struct udevice *bootcmd_dev = NULL;
+	bool stdin_set;
+	char iomux_name[128];
+
+	debug("%s: stdin before: %s\n", __func__,
+	      stdinname ? stdinname : "NONE");
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	stdin_set = !!strstr(stdinname, BOOTCMD_NAME);
+	ret = uclass_get_device_by_driver(UCLASS_SERIAL,
+					  DM_GET_DRIVER(octeontx_bootcmd),
+					  &bootcmd_dev);
+	if (ret) {
+		pr_err("%s: Error getting %s serial class\n", __func__,
+		       BOOTCMD_NAME);
+	} else if (bootcmd_dev) {
+		if (stdin_set)
+			strncpy(iomux_name, stdinname, sizeof(iomux_name));
+		else
+			snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+				 stdinname, bootcmd_dev->name);
+		ret = iomux_doenv(stdin, iomux_name);
+		if (ret)
+			pr_err("%s: Error %d enabling the PCI bootcmd input console \"%s\"\n",
+			       __func__, ret, iomux_name);
+		if (!stdin_set)
+			env_set("stdin", iomux_name);
+	}
+	debug("%s: Set iomux and stdin to %s (ret: %d)\n",
+	      __func__, iomux_name, ret);
+	return ret;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)
+static int init_pcie_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	char *stdoutname = env_get("stdout");
+	char *stderrname = env_get("stderr");
+	struct udevice *pcie_console_dev = NULL;
+	bool stdin_set, stdout_set, stderr_set;
+	char iomux_name[128];
+
+	debug("%s: stdin: %s, stdout: %s, stderr: %s\n", __func__, stdinname,
+	      stdoutname, stderrname);
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	if (!stdoutname) {
+		env_set("stdout", "serial");
+		stdoutname = env_get("stdout");
+	}
+	if (!stderrname) {
+		env_set("stderr", "serial");
+		stderrname = env_get("stderr");
+	}
+
+	if (!stdinname || !stdoutname || !stderrname) {
+		printf("%s: Error setting environment variables for serial\n",
+		       __func__);
+		return -1;
+	}
+
+	stdin_set = !!strstr(stdinname, CONSOLE_NAME);
+	stdout_set = !!strstr(stdoutname, CONSOLE_NAME);
+	stderr_set = !!strstr(stderrname, CONSOLE_NAME);
+
+	pr_debug("stdin: %d, \"%s\", stdout: %d, \"%s\", stderr: %d, \"%s\"\n",
+		 stdin_set, stdinname, stdout_set, stdoutname,
+		 stderr_set, stderrname);
+	ret = uclass_get_device_by_name(UCLASS_SERIAL, CONSOLE_NAME,
+					&pcie_console_dev);
+	if (ret || !pcie_console_dev) {
+		debug("%s: No PCI console device %s found\n", __func__,
+		      CONSOLE_NAME);
+		return 0;
+	}
+
+	if (stdin_set)
+		strncpy(iomux_name, stdinname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+			 stdinname, pcie_console_dev->name);
+
+	ret = iomux_doenv(stdin, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stdin MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+
+	if (!stdin_set)
+		env_set("stdin", iomux_name);
+
+	if (stdout_set)
+		strncpy(iomux_name, stdoutname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s", stdoutname,
+			 pcie_console_dev->name);
+
+	ret = iomux_doenv(stdout, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stdout MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+	if (!stdout_set)
+		env_set("stdout", iomux_name);
+
+	if (stderr_set)
+		strncpy(iomux_name, stderrname, sizeof(iomux_name));
+	else
+		snprintf(iomux_name, sizeof(iomux_name), "%s,%s", stderrname,
+			 pcie_console_dev->name);
+
+	ret = iomux_doenv(stderr, iomux_name);
+	if (ret) {
+		pr_err("%s: Error setting I/O stderr MUX to %s\n",
+		       __func__, iomux_name);
+		return ret;
+	}
+
+	if (!stderr_set)
+		env_set("stderr", iomux_name);
+
+	debug("%s: stdin: %s, stdout: %s, stderr: %s, ret: %d\n",
+	      __func__, env_get("stdin"), env_get("stdout"),
+	      env_get("stderr"), ret);
+
+	return ret;
+}
+#endif
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[32];
+	char boardserial[150], boardrev[150];
+	long val;
+	bool save_env = false;
+	const char *str;
+
+	debug("%s()\n", __func__);
+
+	/*
+	 * Now that pci_init initializes env device.
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of QLM can change.
+	 */
+	cleanup_env_ethaddr();
+
+	snprintf(boardname, sizeof(boardname), "%s> ", fdt_get_board_model());
+	env_set("prompt", boardname);
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+
+	str = fdt_get_board_revision();
+	if (str) {
+		snprintf(boardrev, sizeof(boardrev), "%s", str);
+		if (env_get("boardrev") &&
+		    strcmp(boardrev, env_get("boardrev")))
+			save_env = true;
+		env_set("boardrev", boardrev);
+	}
+
+	str = fdt_get_board_serial();
+	if (str) {
+		snprintf(boardserial, sizeof(boardserial), "%s", str);
+		if (env_get("serial#") &&
+		    strcmp(boardserial, env_get("serial#")))
+			save_env = true;
+		env_set("serial#", boardserial);
+	}
+
+	val = env_get_hex("disable_ooo", 0);
+	smc_configure_ooo(val);
+
+#ifdef CONFIG_NET_OCTEONTX2
+	board_late_probe_devices();
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+	if (init_bootcmd_console())
+		printf("Failed to init bootcmd input\n");
+#endif
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)
+	if (init_pcie_console())
+		printf("Failed to init pci console\n");
+#endif
+	if (save_env)
+		env_save();
+
+	return 0;
+}
+
+/*
+ * Invoked before relocation, so limit to stack variables.
+ */
+int show_board_info(void)
+{
+	char *str = NULL;
+
+	if (otx_is_soc(CN96XX))
+		str = "CN96XX";
+	if (otx_is_soc(CN95XX))
+		str = "CN95XX";
+	if (otx_is_soc(LOKI))
+		str = "LOKI";
+	if (otx_is_soc(CN98XX))
+		str = "CN98XX";
+	if (otx_is_soc(F95MM))
+		str = "F95MM";
+	printf("OcteonTX2 %s ARM V8 Core\n", str);
+
+	printf("Board: %s\n", fdt_get_board_model());
+
+	return 0;
+}
+
+void acquire_flash_arb(bool acquire)
+{
+	union cpc_boot_ownerx ownerx;
+
+	if (!acquire) {
+		ownerx.u = readl(CPC_BOOT_OWNERX(3));
+		ownerx.s.boot_req = 0;
+		writel(ownerx.u, CPC_BOOT_OWNERX(3));
+	} else {
+		ownerx.u = 0;
+		ownerx.s.boot_req = 1;
+		writel(ownerx.u, CPC_BOOT_OWNERX(3));
+		udelay(1);
+		do {
+			ownerx.u = readl(CPC_BOOT_OWNERX(3));
+		} while (ownerx.s.boot_wait);
+	}
+}
+
+#ifdef CONFIG_LAST_STAGE_INIT
+int last_stage_init(void)
+{
+	(void)smc_flsf_fw_booted();
+	return 0;
+}
+#endif
diff --git a/board/Marvell/octeontx2/smc.c b/board/Marvell/octeontx2/smc.c
new file mode 100644
index 0000000000..3ae428d726
--- /dev/null
+++ b/board/Marvell/octeontx2/smc.c
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include <asm/system.h>
+#include <asm/arch/smc.h>
+
+#include <asm/psci.h>
+
+#include <malloc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ssize_t smc_dram_size(unsigned int node)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_DRAM_SIZE;
+	regs.regs[1] = node;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_disable_rvu_lfs(unsigned int node)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_DISABLE_RVU_LFS;
+	regs.regs[1] = node;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_configure_ooo(unsigned int val)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_CONFIG_OOO;
+	regs.regs[1] = val;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_flsf_fw_booted(void)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_FSAFE_PR_BOOT_SUCCESS;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_flsf_clr_force_2ndry(void)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_FSAFE_CLR_FORCE_SEC;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+			  int reg)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_MDIO_DBG_READ;
+	regs.regs[1] = cgx_lmac;
+	regs.regs[2] = mode;
+	regs.regs[3] = phyaddr;
+	regs.regs[4] = devad;
+	regs.regs[5] = reg;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t smc_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+			   int reg, int val)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_MDIO_DBG_WRITE;
+	regs.regs[1] = cgx_lmac;
+	regs.regs[2] = mode;
+	regs.regs[3] = phyaddr;
+	regs.regs[4] = devad;
+	regs.regs[5] = reg;
+	regs.regs[6] = val;
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+/*
+ * on entry,
+ *   subcmd:  one of OCTEONTX_ATTESTATION_QUERY_SUBCMD_xxx
+ *   ctx_arg: subcmd-specific argument
+ *
+ * returns,
+ *   signed value: <0 - error code
+ *                  0 - success
+ */
+#ifdef CONFIG_CMD_ATTEST
+ssize_t smc_attest(long subcmd, long ctx_arg)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX_ATTESTATION_QUERY;
+	regs.regs[1] = ctx_arg;
+	regs.regs[2] = subcmd;
+
+	switch (subcmd) {
+	/* deprecated sub-command */
+	case OCTEONTX_ATTESTATION_QUERY_SUBCMD_LEGACY:
+		return -1;
+
+	case OCTEONTX_ATTESTATION_QUERY_SUBCMD_BUFFER:
+	case OCTEONTX_ATTESTATION_QUERY_SUBCMD_INFO:
+		/* no args */
+		break;
+
+	default:
+		return -1;
+	}
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+#endif // CONFIG_CMD_ATTEST
diff --git a/board/Marvell/octeontx2/soc-utils.c b/board/Marvell/octeontx2/soc-utils.c
new file mode 100644
index 0000000000..7fc7ae7e90
--- /dev/null
+++ b/board/Marvell/octeontx2/soc-utils.c
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/board.h>
+#include <dm/util.h>
+
+platform_t read_platform(void)
+{
+	platform_t plat = PLATFORM_HW;
+
+	const char *model = fdt_get_board_model();
+
+	if (model && !strncmp(model, "ASIM-", 5))
+		plat = PLATFORM_ASIM;
+	if (model && !strncmp(model, "EMUL-", 5))
+		plat = PLATFORM_EMULATOR;
+
+	return plat;
+}
+
+static inline u64 read_midr(void)
+{
+	u64 result;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (result));
+	return result;
+}
+
+u8 read_partvar(void)
+{
+	return ((read_midr() >> 20) & 0xF);
+}
+
+u8 read_partnum(void)
+{
+	return ((read_midr() >> 4) & 0xFF);
+}
+
+const char *read_board_name(void)
+{
+	return fdt_get_board_model();
+}
diff --git a/board/Marvell/octeontx2_cn913x/MAINTAINERS b/board/Marvell/octeontx2_cn913x/MAINTAINERS
new file mode 100644
index 0000000000..9e390a22b1
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/MAINTAINERS
@@ -0,0 +1,4 @@
+OCTEONTX2_CN913x BOARD
+F:	board/Marvell/octeontx2_cn913x/
+F:	include/configs/octeontx2_cn913x.h
+F:	configs/mvebu_db_cn91xx_defconfig
diff --git a/board/Marvell/octeontx2_cn913x/Makefile b/board/Marvell/octeontx2_cn913x/Makefile
new file mode 100644
index 0000000000..8c6ffb9328
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2016 Stefan Roese <sr@denx.de>
+# Copyright (C) 2019 Marvell International Ltd.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= board.o
diff --git a/board/Marvell/octeontx2_cn913x/board.c b/board/Marvell/octeontx2_cn913x/board.c
new file mode 100644
index 0000000000..00b475769b
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/board.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <console.h>
+#include <dm.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
+
+#define CP_USB20_BASE_REG(cp, p)	(MVEBU_REGS_BASE_CP(0, cp) + \
+						0x00580000 + 0x1000 * (p))
+#define CP_USB20_TX_CTRL_REG(cp, p)	(CP_USB20_BASE_REG(cp, p) + 0xC)
+#define CP_USB20_TX_OUT_AMPL_MASK	(0x7 << 20)
+#define CP_USB20_TX_OUT_AMPL_VALUE	(0x3 << 20)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BOOTCMD_NAME	"pci-bootcmd"
+
+int __soc_early_init_f(void)
+{
+	return 0;
+}
+
+int soc_early_init_f(void)
+			__attribute__((weak, alias("__soc_early_init_f")));
+
+int board_early_init_f(void)
+{
+	soc_early_init_f();
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+#ifdef CONFIG_DM_REGULATOR
+	/* Check if any existing regulator should be turned down */
+	regulators_enable_boot_off(false);
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+
+	return 0;
+}
+
+#if (CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD) ||	\
+	CONFIG_IS_ENABLED(OCTEONTX_SERIAL_PCIE_CONSOLE)) &&	\
+	!CONFIG_IS_ENABLED(CONSOLE_MUX)
+# error CONFIG_CONSOLE_MUX must be enabled!
+#endif
+
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+static int init_bootcmd_console(void)
+{
+	int ret = 0;
+	char *stdinname = env_get("stdin");
+	struct udevice *bootcmd_dev = NULL;
+	bool stdin_set;
+	char iomux_name[128];
+
+	debug("%s: stdin before: %s\n", __func__,
+	      stdinname ? stdinname : "NONE");
+	if (!stdinname) {
+		env_set("stdin", "serial");
+		stdinname = env_get("stdin");
+	}
+	stdin_set = !!strstr(stdinname, BOOTCMD_NAME);
+	ret = uclass_get_device_by_driver(UCLASS_SERIAL,
+					  DM_GET_DRIVER(octeontx_bootcmd),
+					  &bootcmd_dev);
+	if (ret) {
+		pr_err("%s: Error getting %s serial class\n", __func__,
+		       BOOTCMD_NAME);
+	} else if (bootcmd_dev) {
+		if (stdin_set)
+			strncpy(iomux_name, stdinname, sizeof(iomux_name));
+		else
+			snprintf(iomux_name, sizeof(iomux_name), "%s,%s",
+				 stdinname, bootcmd_dev->name);
+		ret = iomux_doenv(stdin, iomux_name);
+		if (ret)
+			pr_err("%s: Error %d enabling the PCI bootcmd input console \"%s\"\n",
+			       __func__, ret, iomux_name);
+		if (!stdin_set)
+			env_set("stdin", iomux_name);
+	}
+	debug("%s: Set iomux and stdin to %s (ret: %d)\n",
+	      __func__, iomux_name, ret);
+	return ret;
+}
+#endif
+
+int board_late_init(void)
+{
+#if CONFIG_IS_ENABLED(OCTEONTX_SERIAL_BOOTCMD)
+	if (init_bootcmd_console())
+		printf("Failed to init bootcmd input\n");
+#endif
+	return 0;
+}
diff --git a/board/cavium/thunderx/Kconfig b/board/cavium/thunderx/Kconfig
deleted file mode 100644
index 927d8765d6..0000000000
--- a/board/cavium/thunderx/Kconfig
+++ /dev/null
@@ -1,27 +0,0 @@
-if TARGET_THUNDERX_88XX
-
-config SYS_CPU
-	string
-	default "armv8"
-
-config SYS_BOARD
-	string
-	default "thunderx"
-
-config SYS_VENDOR
-	string
-	default "cavium"
-
-config SYS_CONFIG_NAME
-	string
-	default "thunderx_88xx"
-
-config CMD_ATF
-	bool "Enable ATF query commands"
-	default y
-	help
-	  Enable vendor specific ATF query commands such as SPI and SD/MMC
-	  devices access, low level environment query, boot device layout
-	  and node count.
-
-endif
diff --git a/board/cavium/thunderx/MAINTAINERS b/board/cavium/thunderx/MAINTAINERS
deleted file mode 100644
index c84d3b553d..0000000000
--- a/board/cavium/thunderx/MAINTAINERS
+++ /dev/null
@@ -1,6 +0,0 @@
-THUNDERX BOARD
-M:	Sergey Temerkhanov <s.temerkhanov@gmail.com>
-S:	Maintained
-F:	board/cavium/thunderx/
-F:	include/configs/thunderx_88xx.h
-F:	configs/thunderx_88xx_defconfig
diff --git a/board/cavium/thunderx/Makefile b/board/cavium/thunderx/Makefile
deleted file mode 100644
index 4088c7678d..0000000000
--- a/board/cavium/thunderx/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0+
-# (C) Copyright 2014, Cavium Inc.
-#
-#
-
-obj-y	:= thunderx.o atf.o
diff --git a/board/cavium/thunderx/atf.c b/board/cavium/thunderx/atf.c
deleted file mode 100644
index 2e7ba69d76..0000000000
--- a/board/cavium/thunderx/atf.c
+++ /dev/null
@@ -1,309 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/**
- * (C) Copyright 2014, Cavium Inc.
-**/
-
-#include <common.h>
-#include <asm/io.h>
-
-#include <asm/system.h>
-#include <cavium/thunderx_svc.h>
-#include <cavium/atf.h>
-#include <cavium/atf_part.h>
-
-#include <asm/psci.h>
-
-#include <malloc.h>
-
-ssize_t atf_read_mmc(uintptr_t offset, void *buffer, size_t size)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_MMC_READ;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_read_nor(uintptr_t offset, void *buffer, size_t size)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_NOR_READ;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_get_pcount(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_PART_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_get_part(struct storage_partition *part, unsigned int index)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_GET_PART;
-	regs.regs[1] = (uintptr_t)part;
-	regs.regs[2] = index;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_erase_nor(uintptr_t offset, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_NOR_ERASE;
-	regs.regs[1] = offset;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_write_nor(uintptr_t offset, const void *buffer, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_NOR_WRITE;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_write_mmc(uintptr_t offset, const void *buffer, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_MMC_WRITE;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_dram_size(unsigned int node)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_DRAM_SIZE;
-	regs.regs[1] = node;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_node_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_NODE_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_env_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_ENV_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_env_string(size_t index, char *str)
-{
-	uint64_t *buf = (void *)str;
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_ENV_STRING;
-	regs.regs[1] = index;
-
-	smc_call(&regs);
-
-	if (regs.regs > 0) {
-		buf[0] = regs.regs[0];
-		buf[1] = regs.regs[1];
-		buf[2] = regs.regs[2];
-		buf[3] = regs.regs[3];
-
-		return 1;
-	} else {
-		return regs.regs[0];
-	}
-}
-
-#ifdef CONFIG_CMD_ATF
-
-static void atf_print_ver(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = ARM_STD_SVC_VERSION;
-
-	smc_call(&regs);
-
-	printf("ARM Std FW version: %ld.%ld\n", regs.regs[0], regs.regs[1]);
-
-	regs.regs[0] = THUNDERX_SVC_VERSION;
-
-	smc_call(&regs);
-
-	printf("ThunderX OEM ver: %ld.%ld\n", regs.regs[0], regs.regs[1]);
-}
-
-static void atf_print_uid(void)
-{
-}
-
-static void atf_print_part_table(void)
-{
-	size_t pcount;
-	unsigned long i;
-	int ret;
-	char *ptype;
-
-	struct storage_partition *part = (void *)CONFIG_SYS_LOWMEM_BASE;
-
-	pcount = atf_get_pcount();
-
-	printf("Partition count: %lu\n\n", pcount);
-	printf("%10s %10s %10s\n", "Type", "Size", "Offset");
-
-	for (i = 0; i < pcount; i++) {
-		ret = atf_get_part(part, i);
-
-		if (ret < 0) {
-			printf("Uknown error while reading partition: %d\n",
-			       ret);
-			return;
-		}
-
-		switch (part->type) {
-		case PARTITION_NBL1FW_REST:
-			ptype = "NBL1FW";
-			break;
-		case PARTITION_BL2_BL31:
-			ptype = "BL2_BL31";
-			break;
-		case PARTITION_UBOOT:
-			ptype = "BOOTLDR";
-			break;
-		case PARTITION_KERNEL:
-			ptype = "KERNEL";
-			break;
-		case PARTITION_DEVICE_TREE:
-			ptype = "DEVTREE";
-			break;
-		default:
-			ptype = "UNKNOWN";
-		}
-		printf("%10s %10d %10lx\n", ptype, part->size, part->offset);
-	}
-}
-
-int do_atf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	ssize_t ret;
-	size_t size, offset;
-	void *buffer = 0;
-	unsigned int index, node;
-	char str[4 * sizeof(uint64_t)];
-
-	if ((argc == 5) && !strcmp(argv[1], "readmmc")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_read_mmc(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "readnor")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_read_nor(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "writemmc")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_write_mmc(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "writenor")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_write_nor(offset, buffer, size);
-	} else if ((argc == 2) && !strcmp(argv[1], "part")) {
-		atf_print_part_table();
-	} else if ((argc == 4) && !strcmp(argv[1], "erasenor")) {
-		offset = simple_strtoul(argv[2], NULL, 10);
-		size = simple_strtoul(argv[3], NULL, 10);
-
-		ret = atf_erase_nor(offset, size);
-	} else if ((argc == 2) && !strcmp(argv[1], "envcount")) {
-		ret = atf_env_count();
-		printf("Number of environment strings: %zd\n", ret);
-	} else if ((argc == 3) && !strcmp(argv[1], "envstring")) {
-		index = simple_strtoul(argv[2], NULL, 10);
-		ret = atf_env_string(index, str);
-		if (ret > 0)
-			printf("Environment string %d: %s\n", index, str);
-		else
-			printf("Return code: %zd\n", ret);
-	} else if ((argc == 3) && !strcmp(argv[1], "dramsize")) {
-		node = simple_strtoul(argv[2], NULL, 10);
-		ret = atf_dram_size(node);
-		printf("DRAM size: %zd Mbytes\n", ret >> 20);
-	} else if ((argc == 2) && !strcmp(argv[1], "nodes")) {
-		ret = atf_node_count();
-		printf("Nodes count: %zd\n", ret);
-	} else if ((argc == 2) && !strcmp(argv[1], "ver")) {
-		atf_print_ver();
-	} else if ((argc == 2) && !strcmp(argv[1], "uid")) {
-		atf_print_uid();
-	} else {
-		return CMD_RET_USAGE;
-	}
-
-	return 0;
-}
-
-U_BOOT_CMD(
-	atf,   10,   1,     do_atf,
-	"issue calls to ATF",
-	"\t readmmc addr offset size - read MMC card\n"
-	"\t readnor addr offset size - read NOR flash\n"
-	"\t writemmc addr offset size - write MMC card\n"
-	"\t writenor addr offset size - write NOR flash\n"
-	"\t erasenor offset size - erase NOR flash\n"
-	"\t nodes - number of nodes\n"
-	"\t dramsize node - size of DRAM attached to node\n"
-	"\t envcount - number of environment strings\n"
-	"\t envstring index - print the environment string\n"
-	"\t part - print MMC partition table\n"
-	"\t ver - print ATF call set versions\n"
-);
-
-#endif
diff --git a/board/cavium/thunderx/thunderx.c b/board/cavium/thunderx/thunderx.c
deleted file mode 100644
index cf55b633c3..0000000000
--- a/board/cavium/thunderx/thunderx.c
+++ /dev/null
@@ -1,128 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/**
- * (C) Copyright 2014, Cavium Inc.
-**/
-
-#include <common.h>
-#include <dm.h>
-#include <malloc.h>
-#include <errno.h>
-#include <linux/compiler.h>
-
-#include <cavium/atf.h>
-#include <asm/armv8/mmu.h>
-
-#if !CONFIG_IS_ENABLED(OF_CONTROL)
-#include <dm/platform_data/serial_pl01x.h>
-
-static const struct pl01x_serial_platdata serial0 = {
-	.base = CONFIG_SYS_SERIAL0,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial0) = {
-	.name = "serial_pl01x",
-	.platdata = &serial0,
-};
-
-static const struct pl01x_serial_platdata serial1 = {
-	.base = CONFIG_SYS_SERIAL1,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial1) = {
-	.name = "serial_pl01x",
-	.platdata = &serial1,
-};
-#endif
-
-DECLARE_GLOBAL_DATA_PTR;
-
-static struct mm_region thunderx_mem_map[] = {
-	{
-		.virt = 0x000000000000UL,
-		.phys = 0x000000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_NON_SHARE,
-	}, {
-		.virt = 0x800000000000UL,
-		.phys = 0x800000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE,
-	}, {
-		.virt = 0x840000000000UL,
-		.phys = 0x840000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE,
-	}, {
-		/* List terminator */
-		0,
-	}
-};
-
-struct mm_region *mem_map = thunderx_mem_map;
-
-int board_init(void)
-{
-	return 0;
-}
-
-int timer_init(void)
-{
-	return 0;
-}
-
-int dram_init(void)
-{
-	ssize_t node_count = atf_node_count();
-	ssize_t dram_size;
-	int node;
-
-	printf("Initializing\nNodes in system: %zd\n", node_count);
-
-	gd->ram_size = 0;
-
-	for (node = 0; node < node_count; node++) {
-		dram_size = atf_dram_size(node);
-		printf("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
-		gd->ram_size += dram_size;
-	}
-
-	gd->ram_size -= MEM_BASE;
-
-	*(unsigned long *)CPU_RELEASE_ADDR = 0;
-
-	puts("DRAM size:");
-
-	return 0;
-}
-
-/*
- * Board specific reset that is system reset.
- */
-void reset_cpu(ulong addr)
-{
-}
-
-/*
- * Board specific ethernet initialization routine.
- */
-int board_eth_init(bd_t *bis)
-{
-	int rc = 0;
-
-	return rc;
-}
-
-#ifdef CONFIG_PCI
-void pci_init_board(void)
-{
-	printf("DEBUG: PCI Init TODO *****\n");
-}
-#endif
diff --git a/board/raspberrypi/rpi/rpi.c b/board/raspberrypi/rpi/rpi.c
index 9e0abdda31..98a07deaa4 100644
--- a/board/raspberrypi/rpi/rpi.c
+++ b/board/raspberrypi/rpi/rpi.c
@@ -516,6 +516,16 @@ void *board_fdt_blob_setup(void)
 	return (void *)fw_dtb_pointer;
 }
 
+/*
+ * If the firmware passed a device tree use it for U-Boot.
+ */
+void *board_fdt_blob_setup(void)
+{
+	if (fdt_magic(fw_dtb_pointer) != FDT_MAGIC)
+		return NULL;
+	return (void *)fw_dtb_pointer;
+}
+
 int ft_board_setup(void *blob, bd_t *bd)
 {
 	/*
diff --git a/cmd/Kconfig b/cmd/Kconfig
index a87bcfffbb..1ccd09aead 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -188,6 +188,13 @@ comment "Commands"
 
 menu "Info commands"
 
+config CMD_MVEBU_SAR
+	bool "sar"
+	depends on MVEBU_SAR
+	default n
+	help
+	  sar - Modify SOC's sample at reset (SAR) values
+
 config CMD_BDI
 	bool "bdinfo"
 	default y
@@ -1393,6 +1400,15 @@ config BOOTP_PREFER_SERVERIP
 	  takes precedence over DHCP server IP and will only be set by the DHCP
 	  server if not already set in the environment.
 
+config BOOTP_TFTP_SERVERIP
+	bool "Allow DHCP server to specify tftp server address"
+	depends on CMD_BOOTP
+	default y
+	help
+	  With this option enabled, the DHCP server can specify the IP address
+	  of a TFTP server to load images from by using option 150 as specified
+	  in RFC5859.
+
 config BOOTP_SUBNETMASK
 	bool "Request & store 'netmask' from BOOTP/DHCP server"
 	default y
@@ -1680,6 +1696,7 @@ config CMD_QFW
 	  via -kernel / -initrd
 
 source "cmd/mvebu/Kconfig"
+source "cmd/marvell/Kconfig"
 
 config CMD_TERMINAL
 	bool "terminal - provides a way to attach a serial terminal"
diff --git a/cmd/Makefile b/cmd/Makefile
index c10f2e308b..5aef55249c 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -178,6 +178,10 @@ obj-$(CONFIG_RISCV) += riscv/
 obj-$(CONFIG_X86) += x86/
 
 obj-$(CONFIG_ARCH_MVEBU) += mvebu/
+
+obj-$(CONFIG_ARCH_OCTEONTX2) += marvell/
+obj-$(CONFIG_ARCH_OCTEONTX) += marvell/
+
 endif # !CONFIG_SPL_BUILD
 
 obj-$(CONFIG_$(SPL_)CMD_TLV_EEPROM) += tlv_eeprom.o
diff --git a/cmd/fdt.c b/cmd/fdt.c
index 25a6ed40d2..92fece9ecb 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -1090,7 +1090,8 @@ static int fdt_print(const char *pathp, char *prop, int depth)
 			}
 			break;
 		case FDT_NOP:
-			printf("%s/* NOP */\n", &tabs[MAX_LEVEL - level]);
+			if (!env_get("fdt_hide_nop"))
+				printf("%s/* NOP */\n", &tabs[MAX_LEVEL - level]);
 			break;
 		case FDT_END:
 			return 1;
diff --git a/cmd/marvell/Kconfig b/cmd/marvell/Kconfig
new file mode 100644
index 0000000000..27d1293d6c
--- /dev/null
+++ b/cmd/marvell/Kconfig
@@ -0,0 +1,41 @@
+menu "Marvell specific command line interface"
+
+config CMD_FAILSAFE
+	depends on ARCH_OCTEONTX2
+	bool "Command for supporting fail safe boot"
+	help
+	   Support for fail safe boot on Marvell's OcteonTX2 platforms.
+	   Disables forced secondary boot and reports if boot from
+	   primary device was successful.
+
+config CMD_ETH
+	depends on NET_OCTEONTX2
+	bool "Command to change fec and phy-mod type"
+	help
+	   Support for change of fec and phy-mod type for some specific
+	   LMAC modes on RVU PF [CGX] network interfaces on Marvell
+	   OcteonTX2 platforms.
+
+config CMD_MDIO_DBG
+	depends on ARCH_OCTEONTX2
+	bool "PHY registers read/write support on mdio bus"
+	help
+	   Support to debug phy registers over MDIO bus using SMC interface
+	   to ATF for RVU PF [CGX] network interfaces on Marvell OcteonTX2
+	   platforms.
+
+config CMD_ATTEST
+	depends on ARCH_OCTEONTX2
+	bool "Command for supporting Software Attestation"
+	help
+	   Support for Software Attestation on Marvell's OcteonTX2 platforms.
+	   Displays Secure Boot software component version information.
+
+config CMD_BOOTIMGUP
+	depends on ARCH_OCTEONTX || ARCH_OCTEONTX2
+	depends on MMC_OCTEONTX || SPI_FLASH
+	bool "bootimgup"
+	help
+	  bootimgup command support
+
+endmenu
diff --git a/cmd/marvell/Makefile b/cmd/marvell/Makefile
new file mode 100644
index 0000000000..0f0bf73355
--- /dev/null
+++ b/cmd/marvell/Makefile
@@ -0,0 +1,16 @@
+# Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_ARCH_OCTEONTX2
+obj-$(CONFIG_CMD_BOOTIMGUP) += bootimgup.o
+obj-$(CONFIG_CMD_FAILSAFE) += octeontx2_failsafe_cmds.o
+obj-$(CONFIG_CMD_ETH) += eth_cmds.o
+obj-$(CONFIG_CMD_MDIO_DBG) += mdio_dbg.o
+obj-$(CONFIG_OCTEONTX2_CGX_INTF) += octeontx2_qlm_cmds.o
+obj-$(CONFIG_CMD_ATTEST) += octeontx2_attest_cmds.o
+endif
+ifdef CONFIG_ARCH_OCTEONTX
+obj-$(CONFIG_CMD_BOOTIMGUP) += bootimgup.o
+endif
diff --git a/cmd/marvell/bootimgup.c b/cmd/marvell/bootimgup.c
new file mode 100644
index 0000000000..e9f8b4dc1a
--- /dev/null
+++ b/cmd/marvell/bootimgup.c
@@ -0,0 +1,1251 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <div64.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <malloc.h>
+#include <mapmem.h>
+#include <memalign.h>
+#include <mmc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <jffs2/jffs2.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+
+/* Offsets and sizes to various structures in the image */
+#define SCR_MAX_SIZE			0x40000
+#define MAX_FW_SIZE			0x5C0000
+#define MIN_SIZE			0x500000
+#define INFO_SIZE			0x100
+#define SIG_SIZE			0x100
+#define AP_NB1FW_INFO			0x10000
+#define SCP_NB1FW_INFO			0x10400
+#define SCP_NB1FW_INFO_BLK		(SCP_NB1FW_INFO / 512)
+#define SCP_TBL1FW_INFO			0x10600
+#define SCP_TBL1FW_INFO_BLK		(SCP_TBL1FW_INFO / 512)
+#define AP_NBL1FW_OPAQUE		0x20000
+#define AP_NBL1FW_OPAQUE_SIZE		0x30000
+#define AP_TBL1FW_OPAQUE		0x50000
+#define AP_TBL1FW_OPAQUE_SIZE		0x30000
+#define INFO_MAGIC			"CVM_CLIB"
+#define INFO_MAGIC_SIZE			8
+#define INFO_MAX_OFFSET			0x1000000
+#define INFO_VERSION			0
+#define AP_NBL1FW_HEADER		"OCTEONTX"
+#define ATF_BL2_STAGE1			0x400000	/** uses bdk_header */
+#define ATF_BL2_STAGE1_SIZE		0x40000
+#define ATF_FIP_ADDRESS			0x440000
+#define ATF_FIP_NAME			0xAA640001
+
+/**
+ * The BDK is located inAP_NBL1FW
+ */
+struct bdk_header {
+	u32	skip_insn;
+	u32	length;		/** Length, including header */
+	char	magic[8];	/** OCTEONTX */
+	u32	crc32;		/** CRC32 */
+	u32	zero;
+	char	name[64];	/** Zero terminated name */
+	char	version[32];	/** Zero terminated version */
+	char	pad[136];
+};
+
+/** ROM Code Load Information-Block Structure, all fields are little-endian */
+struct rom_clib {
+	u8	magic[8];	/** CVM_CLIB */
+	u8	pad[7];		/** 0 */
+	u8	ver;		/** 0 */
+	u64	offset;
+	u64	size;
+	u32	rom_script_size;
+	u32	rom_script_offset;
+	u32	rom_script_chksum;
+	u32	pad2[5];
+	u64	csib_sig[8];
+	u64	pad3[12];
+};
+
+/**
+ * Information saved to later restore the buffer when preserving the ROM
+ * script area
+ *
+ * @param	desc		block descriptor if mmc is used
+ * @param	flash		SPI flash descriptor if flash is used
+ * @param	bak_nb1fw_scr	Pointer to backup of script in new image,
+ *				NULL if not present.
+ * @param	nb1fw_scr_size	Size of SCP NB1FW script, 0 if not present
+ * @param	nb1fw_scr_offset Offset of SCP NB1FW script in image
+ * @param	bak_tbl1fw_scr	Pointer to backup of script in new image,
+ *				NULL if not present.
+ * @param	tbl1fw_scr_size	Size of SCP TBL1FW script, 0 if not present
+ * @param	tbl1fw_scr_offset	Offset of SCP TBL1FW script in image
+ * @param	bak_scp_nb1fw_info	SCP NB1FW INFO from new image
+ * @param	bak_scp_tbl1fw_info	SCP TBL1FW INFO from new image
+ */
+struct rom_scr_info {
+	struct blk_desc		*desc;
+	struct spi_flash	*flash;
+	u8			*bak_nb1fw_scr;
+	u32			nb1fw_scr_size;
+	u32			nb1fw_scr_offset;
+	u8			*bak_tbl1fw_scr;
+	u32			tbl1fw_scr_size;
+	u32			tbl1fw_scr_offset;
+	struct rom_clib		bak_scp_nb1fw_info;
+	struct rom_clib		bak_scp_tbl1fw_info;
+};
+
+struct dos_partition {
+	unsigned char boot_ind;		/* 0x80 - active			*/
+	unsigned char head;		/* starting head			*/
+	unsigned char sector;		/* starting sector			*/
+	unsigned char cyl;		/* starting cylinder			*/
+	unsigned char sys_ind;		/* What partition type			*/
+	unsigned char end_head;		/* end head				*/
+	unsigned char end_sector;	/* end sector				*/
+	unsigned char end_cyl;		/* end cylinder				*/
+	unsigned int  start4;		/* starting sector counting from 0	*/
+	unsigned int  size4;		/* nr of sectors in partition		*/
+};
+
+static struct spi_flash *flash;
+
+/**
+ * Validates the BDK headers
+ *
+ * @param	addr	address of BDK image
+ *
+ * @return	0 for success or !0 for error
+ */
+static int validate_bdk(unsigned long addr, size_t size)
+{
+	struct bdk_header *bhdr = (struct bdk_header *)addr;
+	u32 crc;
+	const u32 zero = 0;
+	u32 len = le32_to_cpu(bhdr->length);
+
+	if (len > size) {
+		printf("Invalid header length %#x for BDK type image at %#lx\n",
+		       len, addr);
+		return 1;
+	}
+
+	if (strncmp(bhdr->magic, AP_NBL1FW_HEADER, 8)) {
+		printf("%s: Invalid header \"%8s\"\n", __func__, bhdr->magic);
+		return 1;
+	}
+	crc = crc32(0, (u8 *)bhdr, 0x10);
+	crc = crc32(crc, (u8 *)&zero, sizeof(zero));
+	crc = crc32(crc, (u8 *)&bhdr->zero, bhdr->length - 0x14);
+	debug("%s: calculated CRC: %#x, CRC: %#x, length: %#x\n",
+	      __func__, crc, bhdr->crc32, bhdr->length);
+	return crc != bhdr->crc32;
+}
+
+/**
+ * Validates a CLIB header
+ *
+ * @param	addr	address of CLIB header
+ *
+ * @return	0 for success, !0 for error
+ */
+static int validate_clib(unsigned long addr)
+{
+	struct rom_clib *clib = (struct rom_clib *)addr;
+
+	if (memcmp(clib->magic, INFO_MAGIC, sizeof(clib->magic))) {
+		printf("Invalid CLIB magic value for CLIB at %#lx\n", addr);
+		return 1;
+	}
+	if (clib->ver != INFO_VERSION) {
+		printf("CLIB version %#x invalid, should be %#x\n",
+		       clib->ver, INFO_VERSION);
+		return 1;
+	}
+	if (le32_to_cpu(clib->offset) + le32_to_cpu(clib->size) >
+							INFO_MAX_OFFSET) {
+		printf("Image offset %#llx and size %#llx out of range for CLIB at %#lx\n",
+		       le64_to_cpu(clib->offset), le64_to_cpu(clib->size),
+		       addr);
+		return 1;
+	}
+	if ((le32_to_cpu(clib->rom_script_offset) +
+	     le32_to_cpu(clib->rom_script_size) > INFO_MAX_OFFSET) ||
+	    (le32_to_cpu(clib->rom_script_offset) % 512)) {
+		printf("Invalid CLIB ROM script offset %#x, size %#x for CLIP at %#lx\n",
+		       le32_to_cpu(clib->rom_script_offset),
+		       le32_to_cpu(clib->rom_script_size), addr);
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * Validate a number of headers in the image to make sure it's sane
+ *
+ * @param	addr	Base address of the image
+ *
+ * @return	0 for success, !0 for error
+ */
+static int validate_bootimg_header(unsigned long addr)
+{
+	u32  fip_toc_header = *(u32 *)(addr + ATF_FIP_ADDRESS);
+
+	if (validate_clib(addr + AP_NB1FW_INFO)) {
+		printf("%s: AP NB1FW INFO CLIB bad\n", __func__);
+		return 1;
+	}
+	if (validate_clib(addr + SCP_NB1FW_INFO)) {
+		printf("%s: SCP NB1FW INFO CLIB bad\n", __func__);
+		return 1;
+	}
+	if (validate_clib(addr + SCP_TBL1FW_INFO)) {
+		printf("%s: SCP TBL1FW INFO CLIB bad\n", __func__);
+		return 1;
+	}
+
+	if (validate_bdk(addr + AP_NBL1FW_OPAQUE, AP_NBL1FW_OPAQUE_SIZE)) {
+		printf("Invalid BDK image at %#lx\n", addr + AP_NBL1FW_OPAQUE);
+		return 1;
+	}
+	if (validate_bdk(addr + AP_TBL1FW_OPAQUE, AP_TBL1FW_OPAQUE_SIZE)) {
+		printf("Invalid BDK image at %#lx\n", addr + AP_TBL1FW_OPAQUE);
+		return 1;
+	}
+	if (le32_to_cpu(fip_toc_header) != ATF_FIP_NAME) {
+		printf("Invalid FIP TOC header\n");
+		return 1;
+	}
+	return 0;
+}
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+/**
+ * Calculate checksum for ROM script
+ *
+ * @param[in]	rom_script	pointer to ROM script
+ * @param	len		length of script in bytes
+ *
+ * @return	checksum of ROM script
+ */
+static u32 scr_chksum(const void *rom_script, u32 len)
+{
+	u32 csum = 0;
+	const u32 *ptr;
+
+	debug("%s(%p, %u)\n", __func__, rom_script, len);
+	for (ptr = (u32 *)rom_script;
+	     ptr < (u32 *)(rom_script + len);
+	     ptr++) {
+		csum += le32_to_cpu(*ptr);
+		/* Wrap overflow. */
+		csum += (csum < le32_to_cpu(*ptr)) ? 1 : 0;
+	}
+	debug("%s: csum: %#x, ptr: %p\n", __func__, csum, ptr);
+	return csum;
+}
+#endif
+
+/**
+ * This function takes a byte length and a delta unit of time to compute the
+ * approximate bytes per second
+ *
+ * @param len		amount of bytes currently processed
+ * @param start_ms	start time of processing in ms
+ * @return bytes per second if OK, 0 on error
+ */
+static ulong bytes_per_second(unsigned int len, ulong start_ms)
+{
+	/* less accurate but avoids overflow */
+	if (len >= ((unsigned int)-1) / 1024)
+		return len / (max(get_timer(start_ms) / 1024, 1UL));
+	else
+		return 1024 * len / max(get_timer(start_ms), 1UL);
+}
+
+/**
+ * Write a block of data to SPI flash, first checking if it is different from
+ * what is already there.
+ *
+ * If the data being written is the same, then *skipped is incremented by len.
+ *
+ * @param flash		flash context pointer
+ * @param offset	flash offset to write
+ * @param len		number of bytes to write
+ * @param buf		buffer to write from
+ * @return NULL if OK, else a string containing the stage which failed
+ */
+static const char *spi_flash_update_block(struct spi_flash *flash, u32 offset,
+					  size_t len, const char *buf,
+					  char *cmp_buf)
+{
+	char *ret = NULL;
+	char *ptr = (char *)buf;
+	char *rbuf = cmp_buf;
+
+	/* Read the entire sector so to allow for rewriting */
+	if (spi_flash_read(flash, offset, flash->sector_size, rbuf)) {
+		ret = "read";
+		debug("%s: Read at offset %#x, len: %#lx\n",
+		      __func__, offset, len);
+		goto error;
+	}
+	/* Compare only what is meaningful (len) */
+	if (memcmp(rbuf, buf, len) == 0) {
+		return ret;
+	}
+
+	/* Erase the entire sector */
+	if (spi_flash_erase(flash, offset, flash->sector_size)) {
+		ret = "erase";
+		goto error;
+	}
+
+	/* Write one complete sector */
+	if (spi_flash_write(flash, offset, len, ptr)) {
+		ret = "write";
+		goto error;
+	}
+
+	if (spi_flash_read(flash, offset, len, rbuf)) {
+		ret = "read";
+		goto error;
+	}
+
+	if (memcmp(ptr, rbuf, len)) {
+		ret = "compare";
+		debug("%s: Comparison at offset %#x, len: %#lx\n",
+		      __func__, offset, len);
+#ifdef DEBUG
+		debug("Written values:\n");
+		print_buffer(offset, ptr, 1, min(len, 1024UL), 0);
+		debug("Read values:\n");
+		print_buffer(offset, rbuf, 1, min(len, 1024UL), 0);
+#endif
+	}
+
+error:
+	return ret;
+}
+
+/**
+ * Update an area of SPI flash by erasing and writing any blocks which need
+ * to change. Existing blocks with the correct data are left unchanged.
+ *
+ * @param flash		flash context pointer
+ * @param offset	flash offset to write
+ * @param len		number of bytes to write
+ * @param buf		buffer to write from
+ * @return 0 if ok, 1 on error
+ */
+static int spi_flash_update(struct spi_flash *flash, u32 offset,
+			    size_t len, const char *buf)
+{
+	const char *err_oper = NULL;
+	const char *end = buf + len;
+	size_t todo;		/* number of bytes to do in this pass */
+	const ulong start_time = get_timer(0);
+	size_t scale = 1;
+	const char *start_buf = buf;
+	char *cmp_buf;
+	ulong delta;
+
+	if (end - buf >= 200)
+		scale = (end - buf) / 100;
+	cmp_buf = memalign(ARCH_DMA_MINALIGN, flash->sector_size);
+	if (!cmp_buf) {
+		printf("%s: Out of memory\n", __func__);
+		return 1;
+	}
+	ulong last_update = get_timer(0);
+
+	for (; (buf < end) && (!err_oper); buf += todo, offset += todo) {
+		todo = min_t(size_t, end - buf, flash->sector_size);
+		if (get_timer(last_update) > 100) {
+			printf("   \rUpdating, %zu%% %lu B/s",
+			       100 - (end - buf) / scale,
+				bytes_per_second(buf - start_buf,
+						 start_time));
+			last_update = get_timer(0);
+		}
+		err_oper = spi_flash_update_block(flash, offset, todo, buf,
+						  cmp_buf);
+		if (err_oper)
+			break;
+	}
+	free(cmp_buf);
+	putc('\r');
+	if (err_oper) {
+		printf("SPI flash failed in %s step\n", err_oper);
+		return 1;
+	}
+
+	delta = get_timer(start_time);
+	printf("%zu bytes written", len);
+	printf(" in %ld.%lds, speed %ld B/s\n",
+	       delta / 1000, delta % 1000, bytes_per_second(len, start_time));
+
+	return 0;
+}
+
+static int do_spi_flash_probe(unsigned int bus, unsigned int cs)
+{
+	unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
+	unsigned int mode = CONFIG_SF_DEFAULT_MODE;
+	struct udevice *new;
+	int ret;
+
+	ret = spi_flash_probe_bus_cs(bus, cs, speed, mode, &new);
+	if (ret) {
+		printf("Failed to initialize SPI flash at %u:%u (error %d)\n",
+		       bus, cs, ret);
+		return 1;
+	}
+
+	flash = dev_get_uclass_priv(new);
+
+	return flash ? 0 : 1;
+}
+
+/**
+ * Converts a length into the number of mmc blocks
+ */
+static inline size_t get_num_blocks(size_t len)
+{
+	return DIV_ROUND_UP(len, 512);
+}
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+/**
+ * Extract any ROM scripts present for the SCP NB1FW and SCP TBL1FW blocks
+ *
+ * @param[in]	buf			pointer to input buffer
+ * @param[out]	scp_nb1fw_info		data structure with the NB1FW CLIB
+ * @param[out]	scp_nb1fw		Pointer to buffer with ROM script
+ *					or NULL if no NB1FW ROM script.
+ * @param[out]	scp_nb1fw_size		size of firmware, 0 if no firmware
+ * @param[out]	scp_nb1fw_offset	offset of NB1FW ROM script
+ * @param[out]	scp_tbl1fw_info		data structure with the SBL1FW CLIB
+ * @param[out]	scp_tbl1fw		Pointer to buffer with ROM script
+ *					or NULL if no SBL1FW ROM script.
+ * @param[out]	scp_tbl1fw_size		size of firmware, 0 if no firmware
+ * @param[out]	scp_tbl1fw_offset	offset of SBL1FW ROM script
+ *
+ * @return	0 for success or -ENOMEM or -EINVAL on error
+ *
+ * NOTE: The allocated script data buffer will be rounded up to the nearest
+ * 512 bytes for eMMC support.  No data is copied into the sec_data field.
+ */
+static int get_rom_script(struct rom_clib *clib,
+			  u8 **scr_data,
+			  u32 *scr_size,
+			  u32 *scr_offset,
+			  u32 *scr_chksum)
+{
+	*scr_size = le32_to_cpu(clib->rom_script_size);
+	*scr_offset = le32_to_cpu(clib->rom_script_offset);
+	*scr_chksum = le32_to_cpu(clib->rom_script_chksum);
+	if (*scr_size > SCR_MAX_SIZE) {
+		printf("%s: CLIB at %p script size %#x exceeds maximum size %#x\n",
+		       __func__, clib, *scr_size, SCR_MAX_SIZE);
+		return -EINVAL;
+	}
+	if (*scr_size) {
+		/* Round size up for eMMC */
+		*scr_data = malloc(roundup(*scr_size, 512));
+		if (!(*scr_data))
+			return -ENOMEM;
+	} else {
+		*scr_data = NULL;
+	}
+	return 0;
+}
+
+/**
+ * Preserve the original ROM script for updating
+ *
+ * @param	si	script information pointer
+ * @param	buf	pointer to file buffer
+ *
+ * @return	0 for success, !0 for error
+ *
+ * NOTE: This will modify the contents of the buffer.  Use finish_rom_scr()
+ * when finished to restore the buffer.  On error the buffer may be
+ * modified and may not be able to be restored.
+ */
+static int prepare_rom_scr(struct rom_scr_info *si, u8 *buf)
+{
+	bool is_mmc = !!si->desc;
+	u8 buffer[512];
+	u32 chksum;
+	int n;
+	int nb;
+	int ret = 1;
+	u8 *nb1fw_scr = NULL;
+	u8 *tbl1fw_scr = NULL;
+	u32 nb1fw_scr_chksum;
+	u32 tbl1fw_scr_chksum;
+	struct rom_clib old_scp_nb1fw_info;
+	struct rom_clib *new_scp_nb1fw_info;
+	struct rom_clib old_scp_tbl1fw_info;
+	struct rom_clib *new_scp_tbl1fw_info;
+
+	si->bak_nb1fw_scr = NULL;
+	si->bak_tbl1fw_scr = NULL;
+	memset(&si->bak_scp_nb1fw_info, 0, sizeof(si->bak_scp_nb1fw_info));
+	memset(&si->bak_scp_tbl1fw_info, 0, sizeof(si->bak_scp_tbl1fw_info));
+
+	if ((!si->flash && !si->desc) || (si->flash && si->desc)) {
+		printf("%s: Error: either SPI flash or MMC must be passed\n",
+		       __func__);
+		return -1;
+	}
+
+	/*
+	 * If we're preserving the SCP ROM data then we first read
+	 * this section from the SPI NOR and copy it to the buffer
+	 * after preserving the original contents of the buffer
+	 * before writing it.
+	 */
+	/* Read the NB1FW CLIB descriptor */
+	if (is_mmc) {
+		n = blk_dread(si->desc, SCP_NB1FW_INFO_BLK, 1, buffer);
+		ret = n != 1;
+		memcpy(&old_scp_nb1fw_info, buffer,
+		       sizeof(old_scp_nb1fw_info));
+	} else {
+		ret = spi_flash_read(si->flash, SCP_NB1FW_INFO,
+				     sizeof(old_scp_nb1fw_info),
+				     &old_scp_nb1fw_info);
+	}
+	if (ret) {
+		printf("%s: Error reading SCP NB1FW info descriptor\n",
+		       __func__);
+		goto error;
+	}
+
+	/* Parse it for ROM scripts */
+	ret = get_rom_script(&old_scp_nb1fw_info,
+			     &nb1fw_scr, &si->nb1fw_scr_size,
+			     &si->nb1fw_scr_offset,
+			     &nb1fw_scr_chksum);
+	if (ret) {
+		printf("%s: Error parsing SCP NB1FW info descriptor\n",
+		       __func__);
+		goto error;
+	}
+
+	debug("%s: old rom SCP NB1FW script size: %u, offset: %#x, checksum: %#x\n",
+	      __func__, si->nb1fw_scr_size, si->nb1fw_scr_offset,
+	      nb1fw_scr_chksum);
+
+	/* Backup the info field */
+	memcpy(&si->bak_scp_nb1fw_info, buf + SCP_NB1FW_INFO,
+	       sizeof(si->bak_scp_nb1fw_info));
+
+	/* Read the TBL1FW CLIB descriptor */
+	if (is_mmc) {
+		n = blk_dread(si->desc, SCP_TBL1FW_INFO_BLK, 1, buffer);
+		ret = n != 1;
+		memcpy(&old_scp_tbl1fw_info, buffer,
+		       sizeof(old_scp_tbl1fw_info));
+	} else {
+		ret = spi_flash_read(si->flash, SCP_TBL1FW_INFO,
+				     sizeof(old_scp_tbl1fw_info),
+				     &old_scp_tbl1fw_info);
+	}
+	if (ret) {
+		printf("%s: Error reading SFP TBL1FW info descriptor\n",
+		       __func__);
+		goto error;
+	}
+	/* Parse it for ROM scripts */
+	ret = get_rom_script(&old_scp_tbl1fw_info,
+			     &tbl1fw_scr, &si->tbl1fw_scr_size,
+			     &si->tbl1fw_scr_offset, &tbl1fw_scr_chksum);
+	if (ret) {
+		printf("%s: Error parsing SCP TBL1FW info descriptor\n",
+		       __func__);
+		goto error;
+	}
+
+	debug("%s: old rom SCP TBL1FW script size: %u, offset: %#x, checksum: %#x\n",
+	      __func__, si->tbl1fw_scr_size, si->tbl1fw_scr_offset,
+	      tbl1fw_scr_chksum);
+
+	/* Back up the info field */
+	memcpy(&si->bak_scp_tbl1fw_info, buf + SCP_TBL1FW_INFO,
+	       sizeof(si->bak_scp_tbl1fw_info));
+
+	if (si->nb1fw_scr_size) {
+		/* Save area for NB1FW ROM script to restore later */
+		si->bak_nb1fw_scr = malloc(si->nb1fw_scr_size);
+		debug("%s: Allocated bak_nb1fw_scr at %p, size: %#x\n",
+		      __func__, si->bak_nb1fw_scr, si->nb1fw_scr_size);
+
+		if (!si->bak_nb1fw_scr) {
+			printf("%s: Could not allocate %u bytes for SCP NB1FW ROM script\n",
+			       __func__, si->nb1fw_scr_size);
+			ret = -ENOMEM;
+			goto error;
+		}
+		memcpy(si->bak_nb1fw_scr, buf + si->nb1fw_scr_offset,
+		       si->nb1fw_scr_size);
+#ifdef DEBUG
+		print_buffer(0, si->bak_nb1fw_scr, 4,
+			     si->nb1fw_scr_size / 4, 0);
+#endif
+	}
+
+	if (si->tbl1fw_scr_size) {
+		/* Save area for NB1FW ROM script to restore later */
+		si->bak_tbl1fw_scr = malloc(si->tbl1fw_scr_size);
+		debug("%s: Allocated bak_tbl1fw_scr at %p, size: %#x\n",
+		      __func__, si->bak_tbl1fw_scr, si->tbl1fw_scr_size);
+		if (!si->bak_tbl1fw_scr) {
+			printf("%s: Could not allocate %u bytes for SCP TBL1FW ROM script\n",
+			       __func__, si->tbl1fw_scr_size);
+			if (si->bak_nb1fw_scr) {
+				/* Don't later restore this */
+				free(si->bak_nb1fw_scr);
+				si->bak_nb1fw_scr = NULL;
+			}
+			ret = -ENOMEM;
+			goto error;
+		}
+		memcpy(si->bak_tbl1fw_scr, buf + si->tbl1fw_scr_offset,
+		       si->tbl1fw_scr_size);
+#ifdef DEBUG
+		print_buffer(0, si->bak_tbl1fw_scr, 4,
+			     si->tbl1fw_scr_size / 4, 0);
+#endif
+	}
+
+	/* Read NB1FW ROM script if present */
+	if (si->nb1fw_scr_size) {
+		debug("%s: Reading nb1fw script at offset: %#x, size: %u\n",
+		      __func__, si->nb1fw_scr_offset, si->nb1fw_scr_size);
+		if (is_mmc) {
+			nb = get_num_blocks(si->nb1fw_scr_size);
+			n = blk_dread(si->desc, si->nb1fw_scr_offset / 512,
+				      nb, nb1fw_scr);
+			ret = n != nb;
+		} else {
+			ret = spi_flash_read(si->flash, si->nb1fw_scr_offset,
+					     si->nb1fw_scr_size, nb1fw_scr);
+		}
+		if (ret) {
+			printf("%s: Error reading %u bytes for NB1FW script at %#x\n",
+			       __func__, si->nb1fw_scr_size,
+			       si->nb1fw_scr_offset);
+			goto error;
+		}
+		chksum = scr_chksum(nb1fw_scr, si->nb1fw_scr_size);
+		if (chksum != nb1fw_scr_chksum) {
+			printf("Error: invalid checksum in SCP NB1FW ROM script, old checksum: %#x, calculated: %#x\n",
+			       nb1fw_scr_chksum, chksum);
+			ret = -EINVAL;
+			goto error;
+		}
+
+		/* Copy old ROM script into buffer */
+		memcpy(buf + si->nb1fw_scr_offset, nb1fw_scr,
+		       si->nb1fw_scr_size);
+
+#ifdef DEBUG
+		print_buffer(0, nb1fw_scr, 4, si->nb1fw_scr_size / 4, 0);
+#endif
+		new_scp_nb1fw_info =
+				(struct rom_clib *)(buf + SCP_NB1FW_INFO);
+		/* Update ROM CLIB to old ROM script info */
+		new_scp_nb1fw_info->rom_script_offset =
+					cpu_to_le32(si->nb1fw_scr_offset);
+		new_scp_nb1fw_info->rom_script_size =
+					cpu_to_le32(si->nb1fw_scr_size);
+		new_scp_nb1fw_info->rom_script_chksum =
+					cpu_to_le32(nb1fw_scr_chksum);
+		printf("Preserving SCP NB1FW ROM script at offset: %#x, size: %u, checksum: %#x\n",
+		       si->nb1fw_scr_offset, si->nb1fw_scr_size,
+		       nb1fw_scr_chksum);
+	}
+
+	/* Read TBL1FW ROM script if present */
+	if (si->tbl1fw_scr_size) {
+		if (is_mmc) {
+			nb = get_num_blocks(si->tbl1fw_scr_size);
+			n = blk_dread(si->desc, si->tbl1fw_scr_offset / 512,
+				      nb, tbl1fw_scr);
+			ret = n != nb;
+		} else {
+			ret = spi_flash_read(flash, si->tbl1fw_scr_offset,
+					     si->tbl1fw_scr_size,
+					     tbl1fw_scr);
+		}
+		if (ret) {
+			printf("%s: Error reading %u bytes for TBL1FW script at %#x\n",
+			       __func__, si->tbl1fw_scr_size,
+			       si->tbl1fw_scr_offset);
+			goto error;
+		}
+		chksum = scr_chksum(tbl1fw_scr, si->tbl1fw_scr_size);
+		if (chksum != tbl1fw_scr_chksum) {
+			printf("Error: invalid checksum in SCP TBL1FW ROM script.  Old checksum: %#x, calculated: %#x\n",
+			       tbl1fw_scr_chksum, chksum);
+			ret = -EINVAL;
+			goto error;
+		}
+
+		/* Copy old ROM script to buffer */
+		memcpy(buf + si->tbl1fw_scr_offset, tbl1fw_scr,
+		       si->tbl1fw_scr_size);
+#ifdef DEBUG
+		print_buffer(0, nb1fw_scr, 4, si->nb1fw_scr_size / 4, 0);
+#endif
+		new_scp_tbl1fw_info =
+				(struct rom_clib *)(buf + SCP_TBL1FW_INFO);
+		debug("%s: scp tbl1fw info: %p\n", __func__,
+		      new_scp_tbl1fw_info);
+		/* Update ROM CLIB to old ROM script info */
+		new_scp_tbl1fw_info->rom_script_offset =
+					cpu_to_le32(si->tbl1fw_scr_offset);
+		new_scp_tbl1fw_info->rom_script_size =
+					cpu_to_le32(si->tbl1fw_scr_size);
+		new_scp_tbl1fw_info->rom_script_chksum =
+					cpu_to_le32(tbl1fw_scr_chksum);
+		printf("Preserving SCP TBL1FW ROM script at offset: %#x, size: %u, checksum: %#x\n",
+		       si->tbl1fw_scr_offset, si->tbl1fw_scr_size,
+		       tbl1fw_scr_chksum);
+	}
+
+error:
+	/* Free up any memory */
+	if (nb1fw_scr)
+		free(nb1fw_scr);
+	if (tbl1fw_scr)
+		free(tbl1fw_scr);
+
+	if (ret) {
+		/* Attempt cleanup */
+		if (si->bak_nb1fw_scr) {
+			if (!memcmp(si->bak_scp_nb1fw_info.magic, INFO_MAGIC,
+				    INFO_MAGIC_SIZE))
+				memcpy(buf + SCP_NB1FW_INFO,
+				       &si->bak_scp_nb1fw_info,
+				       INFO_SIZE);
+			memcpy(buf + si->nb1fw_scr_offset, si->bak_nb1fw_scr,
+			       si->nb1fw_scr_size);
+			free(si->bak_nb1fw_scr);
+			si->bak_nb1fw_scr = NULL;
+		}
+		if (si->bak_tbl1fw_scr) {
+			if (!memcmp(si->bak_scp_tbl1fw_info.magic, INFO_MAGIC,
+				    INFO_MAGIC_SIZE))
+				memcpy(buf + SCP_TBL1FW_INFO,
+				       &si->bak_scp_tbl1fw_info,
+				       INFO_SIZE);
+			memcpy(buf + SCP_NB1FW_INFO, &si->bak_scp_nb1fw_info,
+			       INFO_SIZE);
+			memcpy(buf + si->tbl1fw_scr_offset, si->bak_tbl1fw_scr,
+			       si->tbl1fw_scr_size);
+			free(si->bak_tbl1fw_scr);
+			si->bak_tbl1fw_scr = NULL;
+		}
+	}
+	return ret;
+}
+
+/**
+ * Restores the file buffer to its original state
+ *
+ * @param	si	script info pointer
+ * @param	buf	pointer to buffer file was loaded to
+ *
+ * @return	0 for success
+ */
+static int finish_rom_scr(struct rom_scr_info *si, u8 *buf)
+{
+	if (si->bak_nb1fw_scr) {
+		memcpy(buf + si->nb1fw_scr_offset,
+		       si->bak_nb1fw_scr, si->nb1fw_scr_size);
+		memcpy(buf + SCP_NB1FW_INFO, &si->bak_scp_nb1fw_info,
+		       sizeof(si->bak_scp_nb1fw_info));
+		free(si->bak_nb1fw_scr);
+	}
+	if (si->bak_tbl1fw_scr) {
+		memcpy(buf + si->tbl1fw_scr_offset, si->bak_tbl1fw_scr,
+		       si->tbl1fw_scr_size);
+		memcpy(buf + SCP_TBL1FW_INFO, &si->bak_scp_tbl1fw_info,
+		       sizeof(si->bak_scp_tbl1fw_info));
+		free(si->bak_tbl1fw_scr);
+	}
+	return 0;
+}
+#endif
+
+static int do_bootu_spi(int argc, char * const argv[], bool update_scr)
+{
+	unsigned long addr, offset, len;
+	void *buf;
+	char *env1, *env2;
+	char *endp;
+	int ret = 1;
+	unsigned int bus = 0, cs;
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	struct rom_scr_info si;
+#endif
+
+	if ((argc < 1) || (argc > 4))
+		return -1;
+
+	if (argc == 1) {
+		bus = cs = 0;
+		env1 = env_get("fileaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables fileaddr/filesize\n");
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 2) {
+		cs = simple_strtoul(argv[1], &endp, 0);
+		if (*argv[1] == 0 || (*endp != 0 && *endp != ':'))
+			return -1;
+		if (*endp == ':') {
+			if (endp[1] == 0)
+				return CMD_RET_USAGE;
+
+			bus = cs;
+			cs = simple_strtoul(endp + 1, &endp, 0);
+			if (*endp != 0)
+				return CMD_RET_USAGE;
+		}
+		env1 = env_get("fileaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables fileaddr/filesize\n");
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 4) {
+		cs = simple_strtoul(argv[1], &endp, 0);
+		if (*argv[1] == 0 || (*endp != 0 && *endp != ':'))
+			return -1;
+		if (*endp == ':') {
+			if (endp[1] == 0)
+				return CMD_RET_USAGE;
+
+			bus = cs;
+			cs = simple_strtoul(endp + 1, &endp, 0);
+			if (*endp != 0)
+				return CMD_RET_USAGE;
+		}
+		debug("%s argv0 %s argv1 %s\n", __func__, argv[0], argv[1]);
+		debug("%s argv2 %s argv3 %s\n", __func__, argv[2], argv[3]);
+		env1 = argv[2];
+		env2 = argv[3];
+	} else {
+		printf("Missing args\n");
+		return CMD_RET_USAGE;
+	}
+	debug("%s update SCP: %s\n", __func__, update_scr ? "yes" : "no");
+	debug("%s fileaddr %s filesize %s\n", __func__, env1, env2);
+	debug("%s bus %d cs %d\n", __func__, bus, cs);
+
+	offset = 0;
+	ret = strict_strtoul(env1, 16, &addr);
+	if (ret)
+		return CMD_RET_USAGE;
+	debug("%s addr %#lx\n", __func__, addr);
+
+	ret = strict_strtoul(env2, 16, &len);
+	if (ret)
+		return CMD_RET_USAGE;
+	debug("%s len %#lx\n", __func__, len);
+
+	if( !addr || !len) {
+		printf("image address or length is 0\n");
+		return CMD_RET_USAGE;
+	}
+	buf = (u8 *)addr;
+
+	if (validate_bootimg_header(addr)) {
+		printf("\n No valid boot image header found \n");
+		return CMD_RET_FAILURE;
+	}
+
+	ret = do_spi_flash_probe(bus, cs);
+	if (ret) {
+		printf("Could not probe SPI flash %d:%d\n", bus, cs);
+		return CMD_RET_FAILURE;
+	}
+
+	/* Consistency checking */
+	if (offset + len > flash->size) {
+		printf("ERROR: attempting %s past flash size (%#x)\n",
+		       argv[0], flash->size);
+		return CMD_RET_FAILURE;
+	}
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	if (!update_scr) {
+		si.desc = NULL;
+		si.flash = flash;
+		ret = prepare_rom_scr(&si, buf);
+		if (ret) {
+			printf("%s: Error preparing ROM script info.\n",
+			       __func__);
+			goto error;
+		}
+	}
+#endif
+
+	ret = spi_flash_update(flash, offset, len, buf);
+
+	printf("bootu SPI : %zu bytes @ %#x Written ",
+	       (size_t)len, (u32)offset);
+	if (ret)
+		printf("ERROR %d\n", ret);
+	else
+		printf("OK\n");
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	if (!update_scr)
+		ret = finish_rom_scr(&si, buf);
+error:
+#endif
+	if (ret)
+		debug("%s: Return code: %d\n", __func__, ret);
+
+	return ret == 0 ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
+/**
+ * Make sure the partition table is sane
+ *
+ * @param[in]	buf	pointer to buffer with partition table
+ *
+ * @return	0 for success, !0 for error
+ */
+static int validate_partition_table(const unsigned char *buf)
+{
+	struct dos_partition *p;
+
+	if ((buf[510] != 0x55) || (buf[511] != 0xaa)) {
+		printf("No valid MBR signature in first sector\n");
+		return 1; /* no DOS Signature at all */
+	}
+
+	/* checks for FAT12 as partition 1 */
+	p = (struct dos_partition *)&buf[446];
+	if (p->sys_ind != 0x01) {
+		printf("%s Invalid first partition type %x"
+			 " expected FAT12 \n", __func__, p->sys_ind);
+		return 1;
+	}
+	/* check for second partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+
+	// FIXME below checks really needed?
+	/* check for third partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16 * 2];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+	/* check for fourth partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16 * 3];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+	return 0;
+}
+
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		printf("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+	if (force_init)
+		mmc->has_init = 0;
+	if (mmc_init(mmc))
+		return NULL;
+	return mmc;
+}
+
+static int do_bootu_mmc(int argc, char * const argv[],
+			bool update_scp, bool overwrite_part)
+{
+	static int curr_device = -1;
+	struct mmc *mmc;
+	struct blk_desc *desc;
+	char *env1, *env2, *endp;
+	unsigned long blk, len, n, blk_cnt = 0;
+	unsigned long addr;
+	u8 *buf;
+	int ret = 0;
+	u32 num_blks;
+	u8 buffer[512];
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	struct rom_scr_info si;
+#endif
+
+	if ((argc < 1) || (argc > 4)) {
+		printf("Invalid # args \n");
+		return CMD_RET_USAGE;
+	}
+	if (argc == 1) {
+		curr_device = 0;
+		env1 = env_get("fileaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables fileaddr/filesize\n");
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 2) {
+		curr_device = simple_strtoul(argv[1], &endp, 0);
+		env1 = env_get("fileaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables fileaddr/filesize\n");
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 3) {
+			printf("Missing args - image addr or image size\n");
+			return CMD_RET_USAGE;
+	} else if (argc == 4) {
+		curr_device = simple_strtoul(argv[1], &endp, 0);
+		debug("%s argv0 %s argv1 %s\n", __func__, argv[0], argv[1]);
+		env1 = argv[2];
+		env2 = argv[3];
+	}
+	debug("%s update scp: %s, overwrite partition table: %s\n",
+	      __func__, update_scp ? "yes" : "no",
+	      overwrite_part ? "yes" : "no");
+	debug("%s loadaddr %s filesize %s\n", __func__, env1, env2);
+	debug("%s curr_device %d\n", __func__, curr_device);
+	blk = 0;
+
+	ret = strict_strtoul(env1, 16, &addr);
+	if (ret)
+		return -1;
+	debug("%s addr %ld\n", __func__, addr);
+
+	ret = strict_strtoul(env2, 16, &len);
+	if (ret)
+		return -1;
+	debug("%s len %ld\n", __func__, len);
+	if( !addr || !len) {
+		printf("image address or length is 0\n");
+		return CMD_RET_USAGE;
+	}
+	len = DIV_ROUND_UP(len, 512);
+	debug("%s len %ld\n", __func__, len);
+
+	if ((blk + 512 * len) > 0x1000000) {
+		printf("\nBoot Image size exceeding 16MB\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (validate_bootimg_header(addr)) {
+		printf("\nNo valid boot image header found\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (get_mmc_num() < curr_device) {
+		puts("No MMC device available\n");
+		return CMD_RET_FAILURE;
+	}
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	desc = mmc_get_blk_desc(mmc);
+	if (!desc)
+		return CMD_RET_FAILURE;
+
+	buf = (u8 *)addr;
+
+	n = blk_dread(desc, 0, 1, buffer);
+	if (n != 1) {
+		printf("ERROR: read partition table failed\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (!overwrite_part && validate_partition_table(buffer)) {
+		printf("Invalid partition setup, can't write bootimg\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (mmc_getwp(mmc) == 1) {
+		printf("Error: card is write protected!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (len <= get_num_blocks(MIN_SIZE)) {
+		printf("\nError: Image size is too small, missing SCP section\n");
+		return CMD_RET_FAILURE;
+	}
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	if (!update_scp) {
+		si.flash = NULL;
+		si.desc = desc;
+		ret = prepare_rom_scr(&si, buf);
+		if (ret)
+			goto error;
+	}
+#endif
+
+	printf("\nMMC write: dev # %d, block # %ld, count %ld ... ",
+	       curr_device, blk, len);
+
+	num_blks = len - blk;
+	n = blk_dwrite(desc, blk, num_blks, buf);
+	blk_cnt += n;
+	if (n != num_blks)
+		goto error;
+
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	if (!update_scp)
+		ret = finish_rom_scr(&si, buf);
+#endif
+
+error:
+
+	printf("%lu blocks written: %s\n", blk_cnt,
+	       (blk_cnt == len && !ret) ? "OK" : "ERROR");
+
+	if (blk_cnt != len || ret)
+		return CMD_RET_FAILURE;
+
+	if (!overwrite_part) {
+		/* Update partition table with FAT entry of boot image */
+		memcpy(&buffer[446], (void *)(addr + 446), 16);
+
+		/* Update partition table with read boot sector */
+		n = blk_dwrite(desc, 0, 1, (void *)buffer);
+		printf("%lu blocks written: %s\n", n,
+		       (n == 1) ? "OK" : "ERROR");
+		if (n != 1)
+			return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_bootimgup(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	const char *cmd;
+	int ret;
+	int i;
+	bool overwrite_part = false;
+#if CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	/* OcteonTX does not have a SCP section so it is always updated */
+	const bool update_scp = true;
+#else
+	bool update_scp = false;
+#endif
+
+	/* Check flags at the beginning */
+	if (argc > 1) {
+		for (i = 1; i < min(argc, 3); i++) {
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+			if (!strcmp(argv[1], "-s")) {
+				update_scp = true;
+				argv++;
+				argc--;
+			}
+#endif
+			if (!strcmp(argv[1], "-p")) {
+				overwrite_part = true;
+				argv++;
+				argc--;
+			}
+		}
+	}
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	cmd = argv[1];
+	--argc;
+	++argv;
+
+	if (strcmp(cmd, "spi") == 0) {
+		if (overwrite_part)
+			puts("-p is ignored for SPI\n");
+		ret = do_bootu_spi(argc, argv, update_scp);
+	}
+	else if (strcmp(cmd, "mmc") == 0)
+		ret = do_bootu_mmc(argc, argv, update_scp, overwrite_part);
+	else
+		ret = -1;
+
+	if (ret != -1)
+		return ret;
+
+usage:
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+#if !CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+	bootimgup, 7, 1, do_bootimgup, "Updates Boot Image",
+	" <[-s]> <[-p]> <mmc | spi> <[devid] | [bus:cs]> [image_address] [image_size]\n"
+	" where: \n"
+	" -s - overwrite SCP ROM area\n"
+#else
+	bootimgup, 6, 1, do_bootimgup, "Updates Boot Image",
+	" <[-p]> <mmc | spi> <[devid] | [bus:cs]> [image_address] [image_size]\n"
+#endif
+	" -p - (MMC only) overwrite the partition table\n"
+	" spi - updates boot image on spi flash \n"
+	" bus and cs should be passed together, passing only one \n"
+	" of them treated as invalid. If [bus:cs] not given, 0:0 is used \n"
+	" image_address - address at which image is located in RAM \n"
+	" image_size    - size of image in hex \n"
+	" eg. to load on spi0 chipselect 0 \n"
+	" bootimgup spi 0:0 $loadaddr $filesize \n"
+	" eg. to load on spi1 chipselect 1 \n"
+	" bootimgup spi 1:1 $loadaddr $filesize \n"
+	" \n"
+	" mmc - updates boot image on mmc card/chip \n"
+	" eg. to load on device 0 \n"
+	" bootimgup mmc 0 $loadaddr $filesize \n"
+	" eg. to load on device 1. If device id not given, 0 is used \n"
+	" bootimgup mmc 1 $loadaddr $filesize \n"
+	" image_address - address at which image is located in RAM \n"
+	" image_size    - size of image in hex \n"
+	" image_address, image_size should be passed together, \n"
+	" passing only one of them treated as invalid. \n"
+	" \n"
+	" If not given, then $loadaddr and $filesize values in \n"
+	" environment are used, otherwise fail to update. \n"
+);
diff --git a/cmd/marvell/eth_cmds.c b/cmd/marvell/eth_cmds.c
new file mode 100644
index 0000000000..2f971625fa
--- /dev/null
+++ b/cmd/marvell/eth_cmds.c
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <dm/uclass-internal.h>
+#include <net.h>
+
+extern int cgx_intf_set_fec(struct udevice *ethdev, int type);
+extern int cgx_intf_get_fec(struct udevice *ethdev);
+extern int cgx_intf_get_phy_mod_type(struct udevice *ethdev);
+extern int cgx_intf_set_phy_mod_type(struct udevice *ethdev, int type);
+extern int cgx_intf_set_mode(struct udevice *ethdev, int mode);
+extern int cgx_intf_set_an_lbk(struct udevice *ethdev, int enable);
+extern int cgx_intf_set_ignore(struct udevice *ethdev, int cgxid, int lmacid,
+			       int ignore);
+extern int cgx_intf_get_ignore(struct udevice *ethdev, int cgxid, int lmacid);
+extern int cgx_intf_get_mode(struct udevice *ethdev);
+extern void nix_print_mac_info(struct udevice *dev);
+
+static int do_ethlist(cmd_tbl_t *cmdtp, int flag, int argc,
+		      char *const argv[])
+{
+	struct udevice *dev;
+
+	for (uclass_find_first_device(UCLASS_ETH, &dev); dev;
+	     uclass_find_next_device(&dev)) {
+		printf("eth%d [%s]", dev->seq, dev->name);
+		if (!strncmp(dev->name, "rvu_", 4))
+			nix_print_mac_info(dev);
+		printf("\n");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	ethlist, 1, 1, do_ethlist, "Display ethernet interface list",
+	"Prints all detected ethernet interfaces with below format\n"
+	"ethX [device name] [LMAC info for RVU PF devices]\n"
+);
+
+static int do_ethparam_common(cmd_tbl_t *cmdtp, int flag, int argc,
+			      char *const argv[])
+{
+	const char *cmd;
+	char *endp;
+	const char *devname;
+	int ret = CMD_RET_USAGE, arg, cgx = -1, lmac = -1;
+	struct udevice *dev = NULL;
+
+	if (argc < 2)
+		return ret;
+
+	cmd = argv[0];
+
+	if (strncmp(argv[1], "eth", 3)) {
+		if (strcmp(cmd, "set_ignore") == 0) {
+			if (argc != 4)
+				return ret;
+			cgx = simple_strtol(argv[1], &endp, 0);
+			if (cgx < 0 || cgx > 4)
+				return ret;
+			lmac = simple_strtol(argv[2], &endp, 0);
+			if (lmac < 0 || lmac > 3)
+				return ret;
+		} else if (strcmp(cmd, "get_ignore") == 0) {
+			if (argc != 3)
+				return ret;
+			cgx = simple_strtol(argv[1], &endp, 0);
+			if (cgx < 0 || cgx > 4)
+				return ret;
+			lmac = simple_strtol(argv[2], &endp, 0);
+			if (lmac < 0 || lmac > 3)
+				return ret;
+		} else {
+			return ret;
+		}
+	} else {
+		devname = argv[1];
+		dev = eth_get_dev_by_name(devname);
+		if (!dev) {
+			printf("device interface %s not found\n", devname);
+			return CMD_RET_FAILURE;
+		}
+		if (strncmp(dev->name, "rvu_", 4)) {
+			printf("Invalid eth interface choose RVU PF device\n");
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	if (strcmp(cmd, "set_fec") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		arg = simple_strtol(argv[2], &endp, 0);
+		if (arg < 0 || arg > 2)
+			return ret;
+		ret = cgx_intf_set_fec(dev, arg);
+	} else if (strcmp(cmd, "get_fec") == 0) {
+		ret = cgx_intf_get_fec(dev);
+	} else if (strcmp(cmd, "set_an_lbk") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		arg = simple_strtol(argv[2], &endp, 0);
+		if (arg < 0 || arg > 1)
+			return CMD_RET_USAGE;
+		ret = cgx_intf_set_an_lbk(dev, arg);
+	} else if (strcmp(cmd, "set_ignore") == 0) {
+		if (dev)
+			arg = simple_strtol(argv[2], &endp, 0);
+		else
+			arg = simple_strtol(argv[3], &endp, 0);
+		if (arg < 0 || arg > 1)
+			return ret;
+		ret = cgx_intf_set_ignore(dev, cgx, lmac, arg);
+	} else if (strcmp(cmd, "get_ignore") == 0) {
+		ret = cgx_intf_get_ignore(dev, cgx, lmac);
+	} else if (strcmp(cmd, "set_phymod") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		arg = simple_strtol(argv[2], &endp, 0);
+		if (arg < 0 || arg > 1)
+			return ret;
+		ret = cgx_intf_set_phy_mod_type(dev, arg);
+	} else if (strcmp(cmd, "get_phymod") == 0) {
+		ret = cgx_intf_get_phy_mod_type(dev);
+	} else if (strcmp(cmd, "get_mode") == 0) {
+		ret = cgx_intf_get_mode(dev);
+	} else if (strcmp(cmd, "set_mode") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		arg = simple_strtol(argv[2], &endp, 0);
+		if (arg < 0 || arg > 6)
+			return ret;
+		ret = cgx_intf_set_mode(dev, arg);
+	}
+	return (ret == 0) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(
+	set_fec, 3, 1, do_ethparam_common,
+	"Modify fec type for selected ethernet interface",
+	"Example - set_fec <ethX> [type]\n"
+	"Set FEC type for any of RVU PF based network interfaces\n"
+	"- where type - 0 [NO FEC] 1 [BASER_FEC] 2 [RS_FEC]\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	get_fec, 2, 1, do_ethparam_common,
+	"Display fec type for selected ethernet interface",
+	"Example - get_fec <ethX>\n"
+	"Get FEC type for any of RVU PF based network interfaces\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(set_an_lbk, 3, 1, do_ethparam_common,
+	   "Set or clear Auto-neg loopback for ethernet interface",
+	   "Example - set_an_lbk <ethX> [value]\n"
+	   "0 [clear] or 1 [set]\n"
+	   "Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(set_ignore, 4, 1, do_ethparam_common,
+	   "Set or clear ignore param in persist storage for eth interface",
+	   "Example - set_ignore <ethX> [value]\n"
+	   "0 [clear ignore] or 1 [set ignore]\n"
+	   "Example - set_ignore <cgx#> <lmac#> [value]\n"
+	   "For CGX0 LMAC3 - set_ignore 0 3 [value]\n"
+	   "0 [clear ignore] or 1 [set ignore]\n"
+	   "Helps to ignore all persist settings for selected ethernet\n"
+	   "interface on next boot\n"
+	   "Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(get_ignore, 3, 1, do_ethparam_common,
+	   "Display ignore param in persist storage for ethernet interface",
+	   "Example - get_ignore <ethX> or\n"
+	   "Example - get_ignore <cgx#> <lmac#>\n"
+	   "For CGX0 LMAC3 - get_ignore 0 3\n"
+	   "Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	set_phymod, 3, 1, do_ethparam_common,
+	"Modify line side phy-mod type for selected ethernet interface",
+	"Example - set_phymod <ethX> [type]\n"
+	"Set PHY MOD type for any of RVU PF based network interfaces\n"
+	"Currently, only 50G_R mode supports type 0 [NRZ] or 1 [PAM4]\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	get_phymod, 2, 1, do_ethparam_common,
+	"Display line side phy-mod type for selected ethernet interface",
+	"Example - get_phymod <ethX>\n"
+	"Get PHY MOD type for any of RVU PF based network interfaces\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(get_mode, 2, 1, do_ethparam_common,
+	   "Display Interface mode for selected ethernet interface",
+	   "Example - get_mode <ethX>\n"
+	   "Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(set_mode, 3, 1, do_ethparam_common,
+	   "Modify Interface mode for selected ethernet interface",
+	   "Example - set_mode <ethX> [mode]\n"
+	   "Change mode of selected network interface\n"
+	   "\n"
+	   "mode encoding -\n"
+	   "	0 - 10G_C2C\n"
+	   "	1 - 10G_C2M\n"
+	   "	2 - 10G_KR\n"
+	   "	3 - 25G_C2C\n"
+	   "	4 - 25G_2_C2C\n"
+	   "	5 - 50G_C2C\n"
+	   "	6 - 50G_4_C2C\n"
+	   "Use 'ethlist' command to display network interface names\n"
+);
diff --git a/cmd/marvell/mdio_dbg.c b/cmd/marvell/mdio_dbg.c
new file mode 100644
index 0000000000..5378293a1c
--- /dev/null
+++ b/cmd/marvell/mdio_dbg.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <asm/arch/smc.h>
+
+extern void nix_get_cgx_lmac_id(struct udevice *dev, int *cgxid, int *lmacid);
+
+static int do_mdio_dbg(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char *const argv[])
+{
+	const char *cmd;
+	char *endp;
+	const char *devname;
+	int ret = -1;
+	int mode, phyaddr, devaddr, regaddr, data, cgx, lmac, cgx_lmac;
+	struct udevice *dev;
+
+	if (argc < 7)
+		return CMD_RET_USAGE;
+
+	devaddr = -1;
+	cmd = argv[1];
+	devname = argv[2];
+
+	dev = eth_get_dev_by_name(devname);
+	if (!dev) {
+		printf("device interface %s not found\n", devname);
+		return CMD_RET_FAILURE;
+	}
+	if (strncmp(dev->name, "rvu_", 4)) {
+		printf("Invalid eth interface, choose RVU PF device\n");
+		return CMD_RET_FAILURE;
+	}
+	nix_get_cgx_lmac_id(dev, &cgx, &lmac);
+	cgx_lmac = (lmac & 0xF) | ((cgx & 0xF) << 4);
+
+	mode = simple_strtol(argv[3], &endp, 0);
+	if (mode < 0 || mode > 1) {
+		printf("Invalid clause selection\n");
+		return CMD_RET_FAILURE;
+	}
+	phyaddr = simple_strtol(argv[4], &endp, 0);
+
+	if (strcmp(cmd, "read") == 0) {
+		if (mode)
+			devaddr = simple_strtol(argv[5], &endp, 0);
+		regaddr = simple_strtol(argv[6], &endp, 0);
+		ret = smc_mdio_dbg_read(cgx_lmac, mode, phyaddr, devaddr,
+					regaddr);
+		printf("Read register 0x%x devad[%d] of PHY@0x%x => 0x%x\n",
+		       regaddr, devaddr, phyaddr, ret);
+	} else if (strcmp(cmd, "write") == 0) {
+		if (mode)
+			devaddr = simple_strtol(argv[5], &endp, 0);
+		regaddr = simple_strtol(argv[6], &endp, 0);
+		data = simple_strtol(argv[7], &endp, 0);
+		ret = smc_mdio_dbg_write(cgx_lmac, mode, phyaddr, devaddr,
+					 regaddr, data);
+		printf("Write register 0x%x devad[%d] of PHY@0x%x <= 0x%x\n",
+		       regaddr, devaddr, phyaddr, data);
+	}
+	return (ret == 0) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(
+	mdio_dbg,	8,	1,	do_mdio_dbg,
+	"MDIO Debug utility commands",
+	"mdio_dbg read <ethX> <mode> <addr> <devad> <reg>\n"
+	" - read register of PHY@addr using <mode> at <devad>.<reg>\n"
+	"mdio_dbg write <ethX> <mode> <addr> <devad> <reg> <data>\n"
+	" - write register of PHY@addr using <mode> at <devad>.<reg>\n"
+	"\n"
+	" - mode 0 [CLAUSE22] and 1 [CLAUSE45]\n"
+	" - devad should be -1 for clause22 and device address for clause45\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
diff --git a/cmd/marvell/octeontx2_attest_cmds.c b/cmd/marvell/octeontx2_attest_cmds.c
new file mode 100644
index 0000000000..6824b4c699
--- /dev/null
+++ b/cmd/marvell/octeontx2_attest_cmds.c
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <image.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/board.h>
+#include <asm/arch/smc-id.h>
+
+static int get_fit_image_ids(const char *img_str,
+			     sw_attestation_tlv_t **tlv_ptr, void *tlv_limit);
+
+static void hexdump(const char *prefix, unsigned char *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if ((i % 16) == 0)
+			printf("%s%s%08lx: ", i ? "\n" : "",
+			       prefix ? prefix : "",
+			       (unsigned long)i /* i.e. offset */);
+		printf("%02x ", buf[i]);
+	}
+	printf("\n");
+}
+
+static const char *tlv_type_name(enum sw_attestation_tlv_type type)
+{
+	static const char *tlv_types[ATT_TLV_TYPE_COUNT] = {
+		[ATT_IMG_INIT_BIN] = "ATT_IMG_INIT_BIN",
+		[ATT_IMG_ATF_BL1] = "ATT_IMG_ATF_BL1",
+		[ATT_IMG_BOARD_DT] = "ATT_IMG_BOARD_DT",
+		[ATT_IMG_LINUX_DT] = "ATT_IMG_LINUX_DT",
+		[ATT_IMG_SCP_TBL1FW] = "ATT_IMG_SCP_TBL1FW",
+		[ATT_IMG_MCP_TBL1FW] = "ATT_IMG_MCP_TBL1FW",
+		[ATT_IMG_AP_TBL1FW] = "ATT_IMG_AP_TBL1FW",
+		[ATT_IMG_ATF_BL2] = "ATT_IMG_ATF_BL2",
+		[ATT_IMG_ATF_BL31] = "ATT_IMG_ATF_BL31",
+		[ATT_IMG_ATF_BL33] = "ATT_IMG_ATF_BL33",
+		[ATT_SIG_NONCE] = "ATT_SIG_NONCE",
+		[ATT_IMG_FIT_KERNEL] = "ATT_IMG_FIT_KERNEL",
+	};
+	if (type < 0 || type >= ATT_TLV_TYPE_COUNT)
+		return "Unknown";
+	else
+		return tlv_types[type];
+}
+
+static int do_attest(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	ssize_t len;
+	uintptr_t attest_ret;
+	const char *img_str;
+	sw_attestation_info_hdr_t *att_info;
+	sw_attestation_tlv_t *tlv;
+	void *tlv_limit, *next_tlv, *cert, *sig;
+	unsigned long nonce_len;
+
+	if (argc < 2) {
+		printf("Please specify nonce string & optional FIT address.\n");
+		return CMD_RET_USAGE;
+	}
+
+	nonce_len = strlen(argv[1]);
+	if (nonce_len > SW_ATT_INFO_NONCE_MAX_LEN) {
+		printf("Input nonce too large (%lu vs %u)\n",
+		       nonce_len, SW_ATT_INFO_NONCE_MAX_LEN);
+		return CMD_RET_USAGE;
+	}
+
+	if (argc > 2)
+		img_str = argv[2];
+	else
+		img_str = NULL;
+
+	/* query for buffer address & len */
+	attest_ret = smc_attest(OCTEONTX_ATTESTATION_QUERY_SUBCMD_BUFFER, 0);
+
+	if ((ssize_t)attest_ret <= 0) {
+		printf("Error: unable to obtain buffer address.\n");
+		return CMD_RET_FAILURE;
+	}
+
+	att_info = (void *)attest_ret;
+
+	if (ntohl(att_info->magic_be) != ATTESTATION_MAGIC_ID) {
+		printf("Error: invalid buffer magic ID.\n");
+		return CMD_RET_FAILURE;
+	}
+
+	tlv = att_info->tlv_list;
+	tlv_limit = (void *)tlv + (long)(ntohs(att_info->tlv_len_be));
+
+	/* Pass nonce data & optional FIT image data to service */
+	len = nonce_len;
+	tlv->type_be = htons(ATT_SIG_NONCE);
+	tlv->length_be = htons(len);
+	memcpy(tlv->value, argv[1], len);
+	tlv = (sw_attestation_tlv_t *)&tlv->value[len];
+
+	if (img_str) {
+		if (get_fit_image_ids(img_str, &tlv, tlv_limit) != 0) {
+			printf("Error parsing FIT image attestation IDs\n");
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	len = (uintptr_t)tlv - (uintptr_t)att_info->tlv_list;
+
+	attest_ret = smc_attest(OCTEONTX_ATTESTATION_QUERY_SUBCMD_INFO, len);
+
+	if ((ssize_t)attest_ret != 0) {
+		printf("Error %ld from attest command\n", attest_ret);
+		return CMD_RET_FAILURE;
+	}
+
+	printf("Attestation decode:\n");
+	printf("\tMagic: %08x\n", ntohl(att_info->magic_be));
+	tlv = att_info->tlv_list;
+	tlv_limit = (void *)tlv + (long)(ntohs(att_info->tlv_len_be));
+	while ((uintptr_t)tlv < (uintptr_t)tlv_limit) {
+		next_tlv = (void *)tlv + ntohs(tlv->length_be) +
+			   sizeof(*tlv);
+		if ((uintptr_t)next_tlv > (uintptr_t)tlv_limit) {
+			printf("Error: invalid TLV construct\n");
+			break;
+		}
+		printf("\t%s:\n", tlv_type_name(ntohs(tlv->type_be)));
+		hexdump("\t   ", tlv->value, ntohs(tlv->length_be));
+		tlv = (sw_attestation_tlv_t *)next_tlv;
+	}
+
+	/* command returned successfully, but with malformed data */
+	if (tlv != tlv_limit)
+		return CMD_RET_SUCCESS;
+
+	/* Certificate is contiguous to TLV date */
+	cert = tlv_limit;
+	printf("\tCertificate:\n");
+	hexdump("\t   ", (unsigned char *)cert,
+		ntohs(att_info->certificate_len_be));
+
+	len = ntohs(att_info->total_len_be);
+	len -= ntohs(att_info->signature_len_be);
+	printf("\tAttestation [Signed] Image:\n");
+	hexdump("\t   ", (unsigned char *)att_info, len);
+
+	/* Authentication signature is contiguous to certificate */
+	sig = (void *)cert + ntohs(att_info->certificate_len_be);
+	printf("\tAuthentication signature:\n");
+	hexdump("\t   ", sig, htons(att_info->signature_len_be));
+
+	return CMD_RET_SUCCESS;
+}
+
+/*
+ * get_fit_image_ids()
+ *
+ * This extracts the kernel image hash from within a FIT image and
+ * adds it as a TLV entry to be submitted to ATF as part of the
+ * Software Attestation information.
+ *
+ * on entry,
+ *   img_str:   FIT image specifier; this supports syntax <addr>:kernel@x.
+ *              If not kernel is specified, the first one will be used.
+ *   tlv_ptr:   address of TLV entries to be filled-in
+ *   tlv_limit: limit of TLV data
+ *
+ * returns,
+ *   0 upon success
+ *   -1 upon error
+ */
+static int get_fit_image_ids(const char *img_str,
+			     sw_attestation_tlv_t **tlv_ptr, void *tlv_limit)
+{
+	int images_noffset, ndepth, count, ret, len, fit_value_len;
+	int subnoffset, noffset;
+	u8 img_type;
+	u8 *fit_value;
+	void *fit_hdr;
+	const char *name, *img_name;
+	uintptr_t img_addr;
+	sw_attestation_tlv_t *tlv;
+
+	if (!tlv_ptr)
+		return -1;
+
+	tlv = *tlv_ptr;
+
+	/* default to error */
+	ret = -1;
+
+	img_addr = simple_strtoul(img_str, NULL, 16);
+	fit_parse_subimage(img_str, img_addr, &img_addr, &img_name);
+	fit_hdr = (void *)img_addr;
+
+	if ((genimg_get_format(fit_hdr) != IMAGE_FORMAT_FIT) ||
+	    !fit_check_format(fit_hdr))
+		return ret;
+
+	/* Find images parent node offset */
+	images_noffset = fdt_path_offset(fit_hdr, FIT_IMAGES_PATH);
+	if (images_noffset < 0)
+		return ret;
+
+	for (ndepth = 0, count = 0,
+	     noffset = fdt_next_node(fit_hdr, images_noffset, &ndepth);
+			(noffset >= 0) && (ndepth > 0);
+			noffset = img_name ? -1 :
+				  fdt_next_node(fit_hdr, noffset, &ndepth)) {
+		/* if image was specified, use its offset */
+		if (img_name) {
+			noffset = fdt_subnode_offset(fit_hdr, images_noffset,
+						     img_name);
+			if (noffset < 0) {
+				printf("Unable to locate '%s'...\n", img_name);
+				continue;
+			}
+			ndepth = 1;
+		}
+
+		if (ndepth == 1) {
+			/*
+			 * Direct child node of the images parent node,
+			 * i.e. component image node.
+			 */
+			count++;
+
+			fit_image_get_type(fit_hdr, noffset, &img_type);
+			if (img_type != IH_TYPE_KERNEL) {
+				printf("img type not KERNEL (%d)\n", img_type);
+				continue;
+			}
+
+			/* locate the HASH for this image */
+			fdt_for_each_subnode(subnoffset, fit_hdr, noffset) {
+				name = fit_get_name(fit_hdr, subnoffset, NULL);
+				if (strncmp(name, FIT_HASH_NODENAME,
+					    strlen(FIT_HASH_NODENAME)))
+					continue;
+
+				if (fit_image_hash_get_value(fit_hdr,
+							     subnoffset,
+							     &fit_value,
+							     &fit_value_len))
+					continue;
+
+				len = fit_value_len;
+				tlv->type_be = htons(ATT_IMG_FIT_KERNEL);
+				tlv->length_be = htons(len);
+				if (((uintptr_t)tlv + len) > (uintptr_t)
+				    tlv_limit)
+					break;
+
+				memcpy(tlv->value, fit_value, len);
+				tlv = (sw_attestation_tlv_t *)&tlv->value[len];
+				ret = 0;
+				break;
+			}
+			break;
+		}
+	}
+
+	*tlv_ptr = tlv;
+
+	return ret;
+}
+
+U_BOOT_CMD(attest, 3, 0, do_attest,
+	   "Retrieve attestation information",
+	   "<nonce_string> [<FIT_addr>]\n"
+	   "    - <nonce_string> consists of ASCII characters.\n"
+	   "    - <FIT_addr> specifies FIT image containing Linux kernel.\n"
+	   "      This supports the FIT syntax <address:kernel@x>.\n"
+	   "\nExample: attest ABCDEF0123\n"
+);
diff --git a/cmd/marvell/octeontx2_failsafe_cmds.c b/cmd/marvell/octeontx2_failsafe_cmds.c
new file mode 100644
index 0000000000..785f300095
--- /dev/null
+++ b/cmd/marvell/octeontx2_failsafe_cmds.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/smc.h>
+
+static int do_fsafe_clr(
+	cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	(void)smc_flsf_clr_force_2ndry();
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	fsafe_clr, 1, 0, do_fsafe_clr,
+	"Marvell OcteonTX2 Fail Safe: clear secondary boot", ""
+);
diff --git a/cmd/marvell/octeontx2_qlm_cmds.c b/cmd/marvell/octeontx2_qlm_cmds.c
new file mode 100644
index 0000000000..caa40abcbf
--- /dev/null
+++ b/cmd/marvell/octeontx2_qlm_cmds.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * https://spdx.org/licenses
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <command.h>
+
+extern int cgx_intf_prbs(u8 qlm, u8 mode, u32 time, u32 lane);
+extern int cgx_intf_display_eye(u8 qlm, u8 lane);
+extern int cgx_intf_display_serdes(u8 qlm, u8 lane);
+
+static int do_prbs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong time;
+	ulong mode;
+	ulong qlm;
+	ulong lane;
+
+	if (argc == 5) {
+		qlm = simple_strtoul(argv[1], NULL, 10);
+		lane = simple_strtoul(argv[2], NULL, 10);
+		mode = simple_strtoul(argv[3], NULL, 10);
+		time = simple_strtoul(argv[4], NULL, 10);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	cgx_intf_prbs(qlm, mode, time, lane);
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(prbs,    5,    1,     do_prbs,
+	   "command to run PRBS on slected QLM",
+	   "<qlm> <lane> <mode> <time> \n"
+	   "    - run PRBS with pattern indicated by 'mode' on selected 'qlm'\n"
+	   "      PRBS will be enabled by 'time' seconds\n"
+	   "      PRBS is performed on a particular 'lane'"
+);
+
+static int do_eye(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong lane;
+	ulong qlm;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	qlm = simple_strtoul(argv[1], NULL, 10);
+	lane = simple_strtoul(argv[2], NULL, 10);
+
+	cgx_intf_display_eye(qlm, lane);
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(eye,    3,    1,     do_eye,
+	   "command to display eye on slected QLM",
+	   "<qlm> <lane>\n"
+	   "    - run eye by 'lane'  'qlm'\n"
+);
+
+static int do_serdes(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong lane;
+	ulong qlm;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	qlm = simple_strtoul(argv[1], NULL, 10);
+	lane = simple_strtoul(argv[2], NULL, 10);
+
+	cgx_intf_display_serdes(qlm, lane);
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(serdes,    3,    1,     do_serdes,
+	   "command to display serdes state of a lane in a given QLM",
+	   "<qlm> <lane>\n"
+	   "    - display serdes state of 'lane' in 'qlm'\n"
+);
diff --git a/cmd/mem.c b/cmd/mem.c
index c6b8038fc9..5d4546a738 100644
--- a/cmd/mem.c
+++ b/cmd/mem.c
@@ -1125,6 +1125,89 @@ static int do_random(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 }
 #endif
 
+#ifdef CONFIG_ARCH_MVEBU
+int do_ir(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 offset = 0x0;
+	u32 reg, tmp_val, residue;
+	char binary[40];
+	char cmd[40];
+	int i, j = 0;
+	int is_modified = 0;
+	u8 *regs_base = (u8 *)INTREG_BASE;
+
+	/* using base command, the u-boot can change the base address */
+	if (base_address != 0)
+		regs_base = (u8 *)base_address;
+
+	if (argc == 2) {
+		offset = simple_strtoul(argv[1], NULL, 16);
+	} else {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 0;
+	}
+
+	reg = readl(regs_base + offset);
+	tmp_val = reg;
+	printf("Internal register 0x%x value : 0x%x\n", offset, reg);
+	printf("\n    31      24        16         8         0");
+	printf("\n     |       |         |         |         |\nOLD: ");
+
+	/* Convert the value to binary string */
+	/* Be endianes safe so don't use shifts */
+	for (i = 31; i >= 0; i--) {
+		if (tmp_val > 0) {
+			residue = tmp_val % 2;
+			tmp_val = (tmp_val - residue) / 2;
+			if (residue == 0)
+				binary[i] = '0';
+			else
+				binary[i] = '1';
+		} else {
+			binary[i] = '0';
+		}
+	}
+
+	/* Print the binary string */
+	for (i = 0; i < 32; i++) {
+		printf("%c", binary[i]);
+		if ((((i+1) % 4) == 0) && (i > 1) && (i < 31))
+			printf("-");
+	}
+
+	cli_readline("\nNEW: ");
+	strcpy(cmd, console_buffer);
+	if ((cmd[0] == '0') && (cmd[1] == 'x')) {
+		reg = simple_strtoul(cmd, NULL, 16);
+		is_modified = 1;
+	} else {
+		/* Read binary input */
+		for (i = 0; i < 40; i++) {
+			if (cmd[i] == '\0')
+				break;
+			if (i == 4 || i == 9 || i == 14 || i == 19 ||
+			    i == 24 || i == 29 || i == 34)
+				continue;
+			if (cmd[i] == '1') {
+				reg = reg | (0x80000000 >> j);
+				is_modified = 1;
+			} else if (cmd[i] == '0') {
+				reg = reg & (~(0x80000000 >> j));
+				is_modified = 1;
+			}
+			j++;
+		}
+	}
+
+	/* Update the register value if modified */
+	if (is_modified == 1) {
+		writel(reg, regs_base + offset);
+		printf("\nNew value = 0x%x\n\n", readl(regs_base + offset));
+	}
+	return 0;
+}
+#endif
+
 /**************************************************/
 U_BOOT_CMD(
 	md,	3,	1,	do_mem_md,
@@ -1302,3 +1385,15 @@ U_BOOT_CMD(
 	"   - Fill 'len' bytes of memory starting at 'addr' with random data\n"
 );
 #endif
+
+#ifdef CONFIG_ARCH_MVEBU
+U_BOOT_CMD(
+	ir,      2,     1,      do_ir,
+	"ir	- Reading and changing internal register values.\n",
+	" Address - offset inside internal registers space\n"
+	"\tDisplays the contents of the internal register in 2 forms, hex and binary.\n"
+	"\tIt's possible to change the value by writing a hex value beginning with 0x\n"
+	"\tor by writing 0 or 1 in the required place.\n"
+	"\tPressing enter without any value keeps the value unchanged.\n"
+);
+#endif
diff --git a/cmd/mii.c b/cmd/mii.c
index 23ee1e6cfa..ce74a4cea1 100644
--- a/cmd/mii.c
+++ b/cmd/mii.c
@@ -476,3 +476,22 @@ U_BOOT_CMD(
 	"mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n"
 	"Addr and/or reg may be ranges, e.g. 2-7."
 );
+
+#ifdef CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD
+int phy_fw_down_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return mvebu_phy_firmware_download(
+			(u8)simple_strtoul(argv[5], NULL, 10),
+			(u8 *)simple_strtoul(argv[1], NULL, 16),
+			(u32)simple_strtoul(argv[2], NULL, 10),
+			(u8 *)simple_strtoul(argv[3], NULL, 16),
+			(u32)simple_strtoul(argv[4], NULL, 10));
+}
+
+U_BOOT_CMD(
+	phy_fw_down,      6,     0,      phy_fw_down_cmd,
+	"phy_fw_down - Downloads x3220/3310 Ethernet transceiver PHY firmware.\n",
+	"\t<FW Image Addr, Hex> <FW Image Size, Bytes> <Slave Image Addr, Hex> <Slave Image Size, Bytes> <XSMI Port Number>\n"
+	"\t(Marvell>> phy_fw_down 0x2010000 167972 0x2000000 9948 8\n"
+);
+#endif
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 6f3cb85cc0..633bcbbf10 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -92,6 +92,7 @@ static void print_mmcinfo(struct mmc *mmc)
 		}
 	}
 }
+
 static struct mmc *init_mmc_device(int dev, bool force_init)
 {
 	struct mmc *mmc;
@@ -510,7 +511,8 @@ static int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,
 		printf("mmc%d is current device\n", curr_device);
 	else
 		printf("mmc%d(part %d) is current device\n",
-		       curr_device, mmc_get_blk_desc(mmc)->hwpart);
+		       curr_device,
+		       mmc_get_blk_desc(mmc)->hwpart);
 
 	return CMD_RET_SUCCESS;
 }
diff --git a/cmd/mtdparts.c b/cmd/mtdparts.c
index 46155cabf6..467838a3ee 100644
--- a/cmd/mtdparts.c
+++ b/cmd/mtdparts.c
@@ -1553,7 +1553,7 @@ static const char *env_get_mtdparts(char *buf)
 static int parse_mtdparts(const char *const mtdparts)
 {
 	const char *p;
-	struct mtd_device *dev;
+	struct mtd_device *dev = NULL;
 	int err = 1;
 	char tmp_parts[MTDPARTS_MAXLEN];
 
diff --git a/cmd/mvebu/Kconfig b/cmd/mvebu/Kconfig
index ad10a572a3..72822eb104 100644
--- a/cmd/mvebu/Kconfig
+++ b/cmd/mvebu/Kconfig
@@ -9,6 +9,51 @@ config CMD_MVEBU_BUBT
 	  For details about bubt command please see the documentation
 	  in doc/mvebu/cmd/bubt.txt
 
+config CMD_MV88E6XXX_UTIL
+	bool "mvswitch"
+	depends on MV88E6XXX_SWITCH
+	default y
+	help
+	  mvswitch command handle mv88e6xxx
+	  assist with switch init
+	  display switch info and link state
+
+config CMD_MVEBU_MV_FW_INFO
+	bool "mv_fw_info"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  mv_fw_info command prints FreeRTOS version and firmware information
+	  for the FW running on CM3 CPUs of AP and connected CPs.
+
+config CMD_MVEBU_PHY_FW_DOWNLOAD
+	bool "phy_fw_down"
+	depends on MVMDIO
+	default n
+	help
+	  phy_fw_down - This command download
+	  PHY firmware header to the PHY flash.
+	  This command is used for Marvell PHYs
+	  88X3220/88X3310
+
+config CMD_MVEBU_TSEN
+	bool "tsen"
+	depends on MVEBU_THERMAL_SENSOR
+	default y
+	help
+	  tsen - Display the SoC temperature
+	  as read from the on chip thermal sensor
+
+config CMD_MVEBU_HW_INFO
+	bool "hw_info"
+	select BOARD_CONFIG_EEPROM
+	default n
+	help
+	  hw_info - load HW information such as board ID, PCB SLM number,
+	  MAC addresses from EEPROM and apply them to environment variables.
+	  And update the MAC address in FDT file for Linux.
+	  When save the box information, it will be saved to EEPROM.
+
 choice
 	prompt "Flash for image"
 	default MVEBU_SPI_BOOT
@@ -33,7 +78,7 @@ config MVEBU_SPI_BOOT
 
 config MVEBU_MMC_BOOT
 	bool "eMMC flash boot"
-	depends on MVEBU_MMC
+	depends on (MVEBU_MMC || MMC_SDHCI_XENON)
 	help
 	  Enable boot from eMMC boot partition
 	  Allow usage of eMMC/SD device as a target for "bubt" command
@@ -42,6 +87,21 @@ config MVEBU_MMC_BOOT
 
 endchoice
 
+config MVEBU_BOOT_PART
+	int "boot partition"
+	default 0
+	help
+	  sets boot partition, and sets a specific
+	  partition as a target for "bubt" command.
+	  For details about bubt command please see the documentation
+	  in doc/mvebu/cmd/bubt.txt
+
+config MVEBU_BOOT_DEVICE
+	int "boot device id"
+	default 0
+	help
+	  Used for setting boot device id.
+
 config MVEBU_UBOOT_DFLT_NAME
 	string "Default image name for bubt command"
 	default "flash-image.bin"
@@ -49,4 +109,89 @@ config MVEBU_UBOOT_DFLT_NAME
 	  This option should contain a default file name to be used with
 	  MVEBU "bubt" command if the source file name is omitted
 
+config CMD_MVEBU_EFUSE
+	bool "efuse"
+	depends on TARGET_MVEBU_ARMADA_37XX
+	select MVEBU_EFUSE_SUPPORT
+	default n
+	help
+	  eFuse - allow access to SoC eFuse entries
+	  eFuse commands to support efuse list/dump/read/write
+	  For details about eFuse command please see help of eFuse
+	  in uboot
+
+config CMD_MVEBU_DDR_PHY
+	bool "enable ddr_phy register access"
+	depends on TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  Write/Read Phy registers
+
+config CMD_MVEBU_RX_TRAINING
+	bool "rx_training"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default n
+	help
+	  Perform RX training sequence
+
+config CMD_MVEBU_AVS
+	bool "avs"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  Set/Get the Adaptive Voltage Scaling (AVS) value
+
+config CMD_MVEBU_MAP
+	bool "map"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  Dump address translation tables
+
+config CMD_MVEBU_NAND_OEM
+	bool "nand"
+	depends on (TARGET_MVEBU_ARMADA_8K || TARGET_DB_88F6820_AP || TARGET_OCTEONTX2_CN913x) && CMD_NAND
+	default y
+	help
+	  Introduction: NAND vendors conducts tests to verify if all blocks are
+	  OK. In case of failure block, the NAND manufacturer will mark this
+	  block as bad (BBM) by setting 0x00 somewhere in the spare area.
+	  Moreover NAND manufacturer can pre-programmed the chip with provided
+	  image using external burner.
+
+	  Issue: Marvell NFC employ optimized cost/performance ECC mechanism.
+	  This results in an unique ECC layout implementation. Marvell NFC sets
+	  different layouts according to page size/ECC strength combinations.
+
+	  Therefore after preparing image for the NAND manufacturer for board
+	  with Marvell NFC, due to the layout differences used by Marvell NFC
+	  and physical NAND chip layout, some valid data will be put on BBM
+	  position.  This will result on false bad block indicator and will
+	  affect the BBT which is created automatically (by U-Boot or Linux)
+	  during first run.
+
+	  To prevent from that kind of situations, the NAND oem command was
+	  introduced.
+
+	  The "prepare" part of the command runs once per device data partition
+	  in NAND and prepares image which is next send to manufacturer. It
+	  checks if under BBM position there is no data which could be then
+	  mistakenly taken as a BBM. If so the data together with tracking
+	  information is copied to "meta-data" partition and BBM position is
+	  overwritten with good indicator.
+
+	  The "restore" part of the command runs once per "prepared" partition
+	  and restores its original data. It supposed to run on new boards, on
+	  which the NAND manufacturer pre-programmed earlier prepared image.
+
+config CMD_MVEBU_MV_GET_COUNTERS
+	bool "mv_get_counters"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  mv_get_counters print MIB Counters.
+	  First argument select eth port to print.
+	  When no argument is given default port is Ethact.
+	  Wrong port being selected could cause crash.
+
 endmenu
diff --git a/cmd/mvebu/Makefile b/cmd/mvebu/Makefile
index 96829c48eb..3b44d99bef 100644
--- a/cmd/mvebu/Makefile
+++ b/cmd/mvebu/Makefile
@@ -4,5 +4,18 @@
 #
 # https://spdx.org/licenses
 
+ccflags-y += -Idrivers/mtd/nand/raw/
 
 obj-$(CONFIG_CMD_MVEBU_BUBT) += bubt.o
+obj-$(CONFIG_CMD_MVEBU_RX_TRAINING) += rx_training.o
+obj-$(CONFIG_CMD_MVEBU_AVS) += avs.o
+obj-$(CONFIG_CMD_MVEBU_EFUSE) += efuse.o
+obj-$(CONFIG_CMD_MVEBU_MAP) += map.o
+obj-$(CONFIG_CMD_MVEBU_NAND_OEM) += pxa3xx_nand_oem.o
+obj-$(CONFIG_CMD_MVEBU_TSEN) += thermal.o
+obj-$(CONFIG_CMD_MVEBU_HW_INFO) += hw_info.o
+obj-$(CONFIG_CMD_MVEBU_SAR) += sar.o
+obj-$(CONFIG_CMD_MVEBU_MV_FW_INFO) += mv_fw_info.o
+obj-$(CONFIG_CMD_MVEBU_MV_GET_COUNTERS) += mv_get_counters.o
+obj-$(CONFIG_CMD_MVEBU_DDR_PHY) += ddr_phy.o
+obj-$(CONFIG_CMD_MV88E6XXX_UTIL) += mv88e6xxx-util.o
\ No newline at end of file
diff --git a/cmd/mvebu/avs.c b/cmd/mvebu/avs.c
new file mode 100644
index 0000000000..c19c4f98d6
--- /dev/null
+++ b/cmd/mvebu/avs.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <mach/soc.h>
+
+#define MV_TO_AVS_VAL(mv)	((mv) * 1024 / 1189)
+#define AVS_VAL_TO_MV(avs)	((avs) * 1189 / 1024)
+
+#define MIN_AVS_VAL_MV		600
+#define MAX_AVS_VAL_MV		1000
+
+#define AVS_VAL_MASK		(0x3ff)
+#define AVS_LOW_LIMIT_SHIFT	(3)
+#define AVS_HIGH_LIMIT_SHIFT	(13)
+#define AVS_ENABLE_MASK		BIT(0)
+#define AVS_SOFT_RESET_MASK	BIT(2)
+#define AVS_CFG_DEBUG_SELECT	BIT(29)
+
+#define MVEBU_AR_RFU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x6F0000)
+#define MVEBU_AVS_SRV_CTRL_REG(ap)	(MVEBU_AR_RFU_BASE(ap) + 0x8120)
+#define MVEBU_AVS_CTRL_REG(ap)		(MVEBU_AR_RFU_BASE(ap) + 0x8130)
+#define MVEBU_AVS_STAT_REG(ap)		(MVEBU_AR_RFU_BASE(ap) + 0x8134)
+
+static void do_get_avs(void)
+{
+	int ap, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+	for (ap = 0; ap < ap_num; ap++) {
+		u32 reg_val;
+
+		/* Cause the AVS configuration to be
+		 * reflected by AV status register
+		 */
+		writel(AVS_CFG_DEBUG_SELECT, MVEBU_AVS_SRV_CTRL_REG(ap));
+		/* Read and format the result */
+		reg_val = readl(MVEBU_AVS_STAT_REG(ap));
+		reg_val &= AVS_VAL_MASK;
+		printf("AP-%d: returned AVS value is %d mV\n",
+		       ap, AVS_VAL_TO_MV(reg_val));
+	}
+}
+
+static void do_set_avs(unsigned long val_mv)
+{
+	unsigned int avs_val = MV_TO_AVS_VAL(val_mv) & AVS_VAL_MASK;
+	int ap, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+	for (ap = 0; ap < ap_num; ap++) {
+		u32 reg_val;
+
+		printf("AP-%d: setting the AVS to %ld mV (0x%x)\n",
+		       ap, val_mv, avs_val);
+		reg_val = avs_val << AVS_LOW_LIMIT_SHIFT;
+		reg_val |= avs_val << AVS_HIGH_LIMIT_SHIFT;
+		reg_val |= AVS_SOFT_RESET_MASK | AVS_ENABLE_MASK;
+		writel(reg_val, MVEBU_AVS_CTRL_REG(ap));
+	}
+	mdelay(1000);
+	do_get_avs();
+}
+
+int do_avs_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	if (strncmp(argv[1], "get", 3) == 0) {
+		do_get_avs();
+	} else if ((argc == 3) && (strncmp(argv[1], "set", 3) == 0)) {
+		unsigned long val_mv = simple_strtoul(argv[2], NULL, 10);
+
+		if ((val_mv < MIN_AVS_VAL_MV) || (val_mv > MAX_AVS_VAL_MV)) {
+			printf("Requested value %ldmV is ",  val_mv);
+			printf("out of the supported range\n");
+			return 0;
+		}
+		do_set_avs(val_mv);
+	} else {
+		printf("Bad format. Use \"help avs\" for more info");
+		printf("about this command\n");
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	avs,      3,     1,      do_avs_cmd,
+	"Set/Get Adaptive Voltage Scaling (AVS) value\n",
+	"[operation] [value]\n"
+	"\t-operation     Either \"set\" or \"get\"\n"
+	"\t-value         AVS value in mV. Valid only for \"set\" operation\n"
+	"\t               Valid AVS range is 600mV - 1000mV\n"
+);
diff --git a/cmd/mvebu/bubt.c b/cmd/mvebu/bubt.c
index 84d2d531f0..0e15425ed6 100644
--- a/cmd/mvebu/bubt.c
+++ b/cmd/mvebu/bubt.c
@@ -25,8 +25,12 @@
 #include <u-boot/sha256.h>
 
 #ifndef CONFIG_SYS_MMC_ENV_DEV
+#ifdef CONFIG_TARGET_MVEBU_ARMADA_37XX
+#define CONFIG_SYS_MMC_ENV_DEV	1
+#else
 #define CONFIG_SYS_MMC_ENV_DEV	0
 #endif
+#endif
 
 #if defined(CONFIG_ARMADA_8K)
 #define MAIN_HDR_MAGIC		0xB105B002
@@ -84,6 +88,33 @@ struct mvebu_image_info {
 	u32	encrypt_start_offset;
 	u32	encrypt_size;
 };
+
+#else /* Older Armada SoCs - A38x, A39x, ... */
+
+#define	LEGACY_HDR_VERSION	1
+
+struct legacy_image_header {
+/*	type	name			byte order */
+	u8	block_id;		/*   0   */
+	u8	flags;			/*   1   */
+	u16	nand_pge_size;		/*  2-3  */
+	u32	block_size;		/*  4-7  */
+	u8	version;		/*   8   */
+	u8	hdr_size_msb;		/*   9   */
+	u16	hdr_size_lsb;		/* 10-11 */
+	u32	source_addr;		/* 12-15 */
+	u32	destination_addr;	/* 16-19 */
+	u32	execution_addr;		/* 20-23 */
+	u8	options;		/*  24   */
+	u8	nand_block_size;	/*  25   */
+	u8	nand_technology;	/*  26   */
+	u8	rsvd4;			/*  27   */
+	u16	rsvd2;			/* 28-29 */
+	u8	ext;			/*  30   */
+	u8	checksum;		/*  31   */
+
+};
+
 #endif /* CONFIG_ARMADA_XXX */
 
 struct bubt_dev {
@@ -136,8 +167,8 @@ static int mmc_burn_image(size_t image_size)
 	}
 
 #ifdef CONFIG_SYS_MMC_ENV_PART
-	if (mmc->part_num != CONFIG_SYS_MMC_ENV_PART) {
-		err = mmc_switch_part(mmc_dev_num, CONFIG_SYS_MMC_ENV_PART);
+	if (mmc_get_blk_desc(mmc)->hwpart != CONFIG_SYS_MMC_ENV_PART) {
+		err = mmc_switch_part(mmc, CONFIG_SYS_MMC_ENV_PART);
 		if (err) {
 			printf("MMC partition switch failed\n");
 			return err;
@@ -177,8 +208,8 @@ static int mmc_burn_image(size_t image_size)
 	printf("Done!\n");
 
 #ifdef CONFIG_SYS_MMC_ENV_PART
-	if (mmc->part_num != CONFIG_SYS_MMC_ENV_PART)
-		mmc_switch_part(mmc_dev_num, mmc->part_num);
+	if (mmc_get_blk_desc(mmc)->hwpart != CONFIG_SYS_MMC_ENV_PART)
+		mmc_switch_part(mmc, mmc_get_blk_desc(mmc)->hwpart);
 #endif
 
 	return 0;
@@ -619,11 +650,53 @@ static int check_image_header(void)
 	return 0;
 }
 
-#else /* Not ARMADA? */
+#else /* Legacy SoCs */
+u8 do_checksum8(u8 *start, u32 len)
+{
+	u8 sum = 0;
+	u8 *startp = start;
+
+	do {
+		sum += *startp;
+		startp++;
+	} while (--len);
+
+	return sum;
+}
+
 static int check_image_header(void)
 {
-	printf("bubt cmd does not support this SoC device or family!\n");
-	return -ENOEXEC;
+	struct legacy_image_header *hdr =
+			(struct legacy_image_header *)get_load_addr();
+	u32 header_len = hdr->hdr_size_lsb + (hdr->hdr_size_msb << 16);
+	u8 checksum;
+	u8 checksum_ref = hdr->checksum;
+
+	/*
+	 * For now compare checksum, and header version. Later we can
+	 * verify more stuff on the header like interface type, etc
+	 */
+	if (hdr->version != LEGACY_HDR_VERSION) {
+		printf("ERROR: Bad HDR Version 0x%x != 0x%x\n",
+		       hdr->version, LEGACY_HDR_VERSION);
+		return -ENOEXEC;
+	}
+
+	/* The checksum value is discarded from checksum calculation */
+	hdr->checksum = 0;
+
+	checksum = do_checksum8((u8 *)hdr, header_len);
+	if (checksum != checksum_ref) {
+		printf("Error: Bad Image checksum. 0x%x != 0x%x\n",
+		       checksum, checksum_ref);
+		return -ENOEXEC;
+	}
+
+	/* Restore the checksum before writing */
+	hdr->checksum = checksum_ref;
+	printf("Image checksum...OK!\n");
+
+	return 0;
 }
 #endif
 
@@ -698,7 +771,7 @@ struct bubt_dev *find_bubt_dev(char *dev_name)
 #define DEFAULT_BUBT_DST "nand"
 #elif defined(CONFIG_MVEBU_MMC_BOOT)
 #define DEFAULT_BUBT_DST "mmc"
-else
+#else
 #define DEFAULT_BUBT_DST "error"
 #endif
 #endif /* DEFAULT_BUBT_DST */
diff --git a/cmd/mvebu/ddr_phy.c b/cmd/mvebu/ddr_phy.c
new file mode 100644
index 0000000000..2d58bc9857
--- /dev/null
+++ b/cmd/mvebu/ddr_phy.c
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * https://spdx.org/licenses
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/soc.h>
+
+/*
+ *	Usage example:
+ *	The PHY register data width is 16 bits.
+ *
+ *	In order to write some value to the phy register need to do first:
+ *	ddr_phy write D0000 0 //take ownership on the PHY CSR
+ *	ddr_phy write C0080 3 //enable phy init engine clk
+ *
+ *	Then:
+ *	ddr_phy write 100c0 5 //for example: writing 5 taps of LCDL
+ *	to the centralization TX byte0 bit 0
+ */
+
+/* this routine reads/writes 'data' from/to specified 'address' offset */
+int ddr_phy_access_smc(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc != 3 && argc != 4)
+		goto EXIT;
+
+	if (strcmp(argv[1], "read") == 0) {
+		struct pt_regs pregs = {0};
+
+		u32 offset = simple_strtoul(argv[2], NULL, 16);
+
+		pregs.regs[0] = MV_SIP_DDR_PHY_READ;
+		pregs.regs[1] = offset;
+
+		smc_call(&pregs);
+
+		printf("\nread val = 0x%x\n", (unsigned int)pregs.regs[1]);
+		return CMD_RET_SUCCESS;
+	} else if (strcmp(argv[1], "write") == 0) {
+		struct pt_regs pregs = {0};
+
+		u32 offset = simple_strtoul(argv[2], NULL, 16);
+		u32 data = simple_strtoul(argv[3], NULL, 16);
+
+		pregs.regs[0] = MV_SIP_DDR_PHY_WRITE;
+		pregs.regs[1] = offset;
+		pregs.regs[2] = data;
+
+		smc_call(&pregs);
+		printf("\nsnps_fw_write: data written\n");
+
+		return CMD_RET_SUCCESS;
+	}
+EXIT:
+	printf("usage: ddr_phy <read | write> <offset> [data]\n");
+	return CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(ddr_phy, 4, 0, ddr_phy_access_smc,
+	   "Access ddr_phy registers",
+	   "command <read | write> <offset> [data]\n"
+	   "\t-offset- hex value of the address offset"
+	   "\t-datd-hex value of the data to write"
+	   "Usage Example:\n"
+	   "\t-ddr_phy write D0000 3"
+	   "\t-ddr_phy read 100c0");
diff --git a/cmd/mvebu/efuse.c b/cmd/mvebu/efuse.c
new file mode 100644
index 0000000000..310e3ccca4
--- /dev/null
+++ b/cmd/mvebu/efuse.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+ #include <config.h>
+ #include <common.h>
+ #include <command.h>
+ #include <vsprintf.h>
+ #include <errno.h>
+ #include <asm/arch-armada3700/efuse.h>
+
+int do_efuse_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char		*cmd = NULL;
+	const char		*efuse = NULL;
+	const char		*writeval = NULL;
+	char			readval[MVEBU_EFUSE_MAX_STRLEN];
+	enum efuse_id		fid = EFUSE_ID_MAX;
+	struct efuse_info	finfo[] = MVEBU_EFUSE_INFO;
+	int			status = CMD_RET_SUCCESS;
+
+	if (argc < 2) {
+		printf("Error: No command supplied\n");
+		return CMD_RET_USAGE;
+	} else {
+		cmd = argv[1];
+	}
+
+	if ((strcmp(cmd, "read") == 0) && argc < 3) {
+		printf("Error: Please specify eFuse ID\n");
+		return CMD_RET_USAGE;
+	}
+
+	if ((strcmp(cmd, "write") == 0) && argc < 4) {
+		printf("Error: Please specify eFuse ID and value\n");
+		return CMD_RET_USAGE;
+	}
+
+	if (argc > 2) {
+		efuse = argv[2];
+		for (fid = EFUSE_ID_BOOT_DEVICE; fid < EFUSE_ID_MAX; fid++) {
+			if (strcmp(efuse, finfo[fid].name) == 0)
+				break;
+		}
+		if (fid == EFUSE_ID_MAX) {
+			printf("%s - Invalid eFuse ID\n", efuse);
+			return CMD_RET_USAGE;
+		} else if (efuse_id_valid(fid) != 1) {
+			printf("%s - Unsupported eFuse ID\n", efuse);
+			return CMD_RET_USAGE;
+		}
+	}
+
+	if (argc > 3)
+		writeval = argv[3];
+
+	if (strcmp(cmd, "list") == 0) {
+		/* LIST */
+		printf("  EFUSE ID\t\tDESCRIPTION\n");
+		printf("---------------------------------------------------------\n");
+		for (fid = EFUSE_ID_BOOT_DEVICE; fid < EFUSE_ID_MAX; fid++) {
+			if (efuse_id_valid(fid))
+				printf("%s\t%s\n", finfo[fid].name,
+				       finfo[fid].note);
+		}
+
+	} else if (strcmp(cmd, "dump") == 0) {
+		/* DUMP */
+		printf("  EFUSE ID\t\tVALUE\n");
+		printf("---------------------------------------------------------\n");
+		for (fid = EFUSE_ID_BOOT_DEVICE; fid < EFUSE_ID_MAX; fid++) {
+			if (efuse_id_valid(fid)) {
+				if (efuse_read(fid, readval) == 0) {
+					printf("%s\t%s%s\n", finfo[fid].name,
+					       strlen(finfo[fid].name) < 8 ?
+					       "\t" : "", readval);
+				} else {
+					printf("%s\t=== ERROR READING EFUSE VALUE ===\n",
+					       finfo[fid].name);
+					status = CMD_RET_FAILURE;
+				}
+			}
+		}
+
+	} else if (strcmp(cmd, "read") == 0) {
+		/* READ */
+		if (efuse_read(fid, readval) == 0) {
+			printf("%s\t%s%s\n", finfo[fid].name,
+			       strlen(finfo[fid].name) < 8 ? "\t" : "",
+				readval);
+		} else {
+			printf("%s\t=== ERROR READING EFUSE VALUE ===\n",
+			       finfo[fid].name);
+			status = CMD_RET_FAILURE;
+		}
+
+	} else if (strcmp(cmd, "write") == 0) {
+		/* WRITE */
+		if (efuse_write(fid, writeval) == 0) {
+			if (efuse_read(fid, readval) == 0) {
+				printf("Returned EFUSE value after write:\n");
+				printf("%s\t%s\n", finfo[fid].name, readval);
+			} else {
+				printf("%s\t=== ERROR READING BACK EFUSE VALUE ===\n",
+				       finfo[fid].name);
+				status = CMD_RET_FAILURE;
+			}
+		} else {
+			printf("%s\t=== ERROR WRITING EFUSE VALUE ===\n",
+			       finfo[fid].name);
+			status = CMD_RET_FAILURE;
+		}
+	} else if (strcmp(cmd, "raw") == 0) {
+		/* RAW DUMP */
+		efuse_raw_dump();
+	} else {
+		/* ERROR */
+		printf("Usupported command \"%s\"\n", cmd);
+		status = CMD_RET_USAGE;
+	}
+
+	return status;
+}
+
+U_BOOT_CMD(
+	efuse,      4,     1,      do_efuse_cmd,
+	"efuse - read/Write SoC eFuse entries\n",
+	"\n"
+	"Access to SoC eFuse entry values\n"
+	"\tlist         - Display all supported eFuse entry ids\n"
+	"\tdump         - Dump all supported eFuse entries\n"
+	"\traw          - Dump all eFuses in raw format\n"
+	"\tread id      - Read eFuse entry \"id\"\n"
+	"\twrite id val - Write \"val\" to eFuse entry \"id\"\n"
+);
diff --git a/cmd/mvebu/hw_info.c b/cmd/mvebu/hw_info.c
new file mode 100644
index 0000000000..7a7659258e
--- /dev/null
+++ b/cmd/mvebu/hw_info.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <config.h>
+#include <command.h>
+#include <common.h>
+#include <errno.h>
+#include <console.h>
+#include <env.h>
+#include <mvebu/cfg_eeprom.h>
+
+/* load the HW configuration from cfg_eeprom module and dump them */
+static int cmd_hw_info_dump(char *name)
+{
+	int idx;
+	int hw_param_num;
+	struct hw_info_data_struct hw_info_data_array[HW_INFO_MAX_PARAM_NUM];
+
+	hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_array);
+
+	/* it is possible the HW configuration is empty */
+	if (hw_param_num == 0)
+		return 0;
+
+	if (hw_param_num > MVEBU_HW_INFO_LEN) {
+		pr_err("hw_info internal error, counter should not exceed %d\n",
+		       MVEBU_HW_INFO_LEN);
+		return -EINVAL;
+	}
+
+	printf("\nname               value\n");
+	printf("------------------------------------\n");
+	for (idx = 0; idx < hw_param_num; idx++) {
+		if (name) {
+			if (strcmp(name, hw_info_data_array[idx].name) == 0) {
+				printf("%-16s   %-s\n",
+				       hw_info_data_array[idx].name,
+				       hw_info_data_array[idx].value);
+				break;
+			}
+		} else {
+			printf("%-16s   %-s\n",
+			       hw_info_data_array[idx].name,
+			       hw_info_data_array[idx].value);
+		}
+	}
+
+	return 0;
+}
+
+int cmd_hw_info_load(char *name, int silence)
+{
+	int idx;
+	int hw_param_num;
+	struct hw_info_data_struct hw_info_data_array[HW_INFO_MAX_PARAM_NUM];
+
+	/* get hw_info from system
+	 * need to memset the hw_info to 0 for later string operation
+	 */
+	hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_array);
+
+	/* it is possible the HW configuration is empty */
+	if (hw_param_num == 0)
+		return 0;
+
+	if (hw_param_num > MVEBU_HW_INFO_LEN) {
+		pr_err("HW info: variables from EEPROM can not exceed %d\n",
+		       MVEBU_HW_INFO_LEN);
+		return -EINVAL;
+	}
+
+	/* save the HW parameter to env varibles one by one */
+	for (idx = 0; idx < hw_param_num; idx++) {
+		/* if customer input a specific and valid HW parameter name,
+		 * only save this HW parameter from EEPROM to env variables.
+		 * otherwise save all the HW parameters from EEPROM to env.
+		 */
+		if (name) {
+			if (strcmp(name, hw_info_data_array[idx].name) == 0) {
+				env_set(hw_info_data_array[idx].name,
+					hw_info_data_array[idx].value);
+				break;
+			}
+		} else {
+			env_set(hw_info_data_array[idx].name,
+				hw_info_data_array[idx].value);
+		}
+	}
+
+	printf("HW information is loaded to environment variables\n");
+	cmd_hw_info_dump(name);
+
+	/* just print indication to ask user to perform saveenv manually in
+	 * silence mode, which is used when restore the HW configuration to env
+	 * variables with env reset. to ask confirmation that if need to save
+	 * env in non-silence mode, which is used by hw_info cmd.
+	 */
+	if (silence) {
+		printf("To save the changes, please run the command saveenv\n");
+	} else {
+		printf("Do you want to save environment variables? <y/N> ");
+		if (confirm_yesno())
+			env_save();
+		else
+			printf("To save changes, please run command saveenv\n");
+	}
+
+	return 0;
+}
+
+static int cmd_hw_info_store(char *name)
+{
+	int idx;
+	int str_len = 0;
+	int total_str_len = 0;
+	int ret;
+	int hw_param_num;
+	int name_in_eeprom_flag = 0;
+	char *target_value;
+	uchar hw_info_str[MVEBU_HW_INFO_LEN];
+	struct hw_info_data_struct hw_info_data_arry[HW_INFO_MAX_PARAM_NUM];
+
+	printf("Are you sure to override factory settings in EEPROM? <y/N>");
+	if (!confirm_yesno())
+		return 0;
+
+	/* need to memset the arry to 0 for later string operation */
+	memset(hw_info_data_arry, 0, sizeof(hw_info_data_arry));
+
+	if (!name) {
+		/* get hw_info from env */
+		hw_param_num = cfg_eeprom_parse_env(&hw_info_data_arry[0],
+						    sizeof(hw_info_data_arry));
+		/* return in case no valid env variables */
+		if (hw_param_num == 0) {
+			printf("There is no supported HW configuration ");
+			printf("in env\n");
+
+			return 0;
+		}
+	} else {
+		/* get hw_info from eeprom */
+		hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_arry);
+
+		/* name valid check */
+		ret = cfg_eeprom_validate_name(name);
+		if (ret) {
+			printf("The HW parameter is invalid\n");
+
+			return 0;
+		}
+		/* check the name in hw_info_data_arry */
+		for (idx = 0; idx < hw_param_num; idx++) {
+			if (strcmp(name, hw_info_data_arry[idx].name) == 0) {
+				target_value = env_get(name);
+				str_len = strlen(target_value);
+				/* clear value */
+				memset(hw_info_data_arry[idx].value, 0,
+				       sizeof(hw_info_data_arry[idx].value));
+				/* overwrite value */
+				memcpy(hw_info_data_arry[idx].value,
+				       target_value, str_len);
+				name_in_eeprom_flag = 1;
+			}
+		}
+		/* name is not in hw_info_data_arry */
+		if (!name_in_eeprom_flag) {
+			target_value = env_get(name);
+			str_len = strlen(name);
+			/* clear name */
+			memset(hw_info_data_arry[idx].name, 0,
+			       sizeof(hw_info_data_arry[idx].name));
+			/* add name */
+			memcpy(hw_info_data_arry[idx].name, name, str_len);
+
+			str_len = strlen(target_value);
+			/* clear value */
+			memset(hw_info_data_arry[idx].value, 0,
+			       sizeof(hw_info_data_arry[idx].value));
+			/* add value */
+			memcpy(hw_info_data_arry[idx].value, target_value,
+			       str_len);
+
+			hw_param_num++;
+		}
+	}
+
+	 /* need to memset the hw_info to 0 for later string operation */
+	memset(hw_info_str, 0, sizeof(hw_info_str));
+	for (idx = 0;
+	     (idx < hw_param_num) && (total_str_len < MVEBU_HW_INFO_LEN);
+	     idx++) {
+		str_len = strlen(hw_info_data_arry[idx].name);
+		if (str_len > HW_INFO_MAX_NAME_LEN)
+			str_len = HW_INFO_MAX_NAME_LEN;
+
+		if ((total_str_len + str_len) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW info string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		memcpy(hw_info_str + total_str_len,
+		       hw_info_data_arry[idx].name, str_len);
+		total_str_len += str_len;
+
+		if ((total_str_len + 1) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		hw_info_str[total_str_len++] = '=';
+
+		str_len = strlen(hw_info_data_arry[idx].value);
+		if (str_len > HW_INFO_MAX_VALUE_LEN)
+			str_len = HW_INFO_MAX_VALUE_LEN;
+
+		if ((total_str_len + str_len) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		memcpy(hw_info_str + total_str_len,
+		       hw_info_data_arry[idx].value, str_len);
+		total_str_len += str_len;
+
+		if ((total_str_len + 1) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+		hw_info_str[total_str_len++] = ' ';
+	}
+
+	cfg_eeprom_set_hw_info_str(hw_info_str);
+	/* save hw_info to EEPROM, and also the rest without changing */
+	cfg_eeprom_save(EEPROM_STRUCT_SIZE);
+
+	printf("hw_info is saved to EEPROM\n");
+	cmd_hw_info_dump(name);
+
+	return 0;
+}
+
+int do_hw_info(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char *cmd = argv[1];
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(cmd, "dump")) {
+		if (cmd_hw_info_dump(argv[2]))
+			return -EINVAL;
+	} else if (!strcmp(cmd, "load")) {
+		if (cmd_hw_info_load(argv[2], 0))
+			return -EINVAL;
+	} else if (!strcmp(cmd, "store")) {
+		if (cmd_hw_info_store(argv[2]))
+			return -EINVAL;
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	hw_info,      3,     0,      do_hw_info,
+	"hw_info\n",
+	"\n"
+	"Load/Store HW information environment variables from/to EEPROM\n"
+	"HW information includes predefined list of Env. variables (such as PCB SLM number, MAC addresses, etc).\n"
+	"\tdump  <evn_name>            - Dump all (or specific <env_name>) HW parameter from EEPROM\n"
+	"\tload  <env_name>            - Load all (or specific <env_name>) HW parameter from EEPROM to env variables\n"
+	"\tstore <env_name>            - Store all or specific HW parameter from env variables to EEPROM\n"
+	"\t				 usage of 'hw_info store' requires proper values to be set for the variables listed below\n"
+	"Supported HW information parameters\n"
+	"\tpcb_slm       PCB SLM number\n"
+	"\tpcb_rev       PCB revision number\n"
+	"\teco_rev       ECO revision number\n"
+	"\tpcb_sn        PCB SN\n"
+	"\tethaddr       first MAC address\n"
+	"\teth1addr      second MAC address\n"
+	"\teth2addr      third MAC address\n"
+	"\teth3addr      fourth MAC address\n"
+	"\teth4addr      fifth MAC address\n"
+	"\teth5addr      sixth MAC address\n"
+	"\teth6addr      seventh MAC address\n"
+	"\teth7addr      eighth MAC address\n"
+	"\teth8addr      ninth MAC address\n"
+	"\teth9addr      tenth MAC address\n"
+);
diff --git a/cmd/mvebu/map.c b/cmd/mvebu/map.c
new file mode 100644
index 0000000000..4ffa2e3974
--- /dev/null
+++ b/cmd/mvebu/map.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <mach/soc.h>
+
+#define ADDRESS_SHIFT			(20 - 4)
+#define WIN_ENABLE_BIT			(0x1)
+#define ADDRESS_RSHIFT			(26)
+#define ADDRESS_LSHIFT			(10)
+
+#define MVEBU_CCU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x4000)
+#define MVEBU_AR_RFU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x6F0000)
+#define MVEBU_IO_WIN_BASE(ap)		(MVEBU_AR_RFU_BASE(ap))
+#define MVEBU_GWIN_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x5400)
+
+/* CCU registers definitions */
+#define CCU_WIN_CR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0x0 + (0x10 * win))
+#define CCU_TARGET_ID_OFFSET		(8)
+#define CCU_TARGET_ID_MASK		(0x7F)
+
+#define CCU_WIN_ALR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0x8 + (0x10 * win))
+#define CCU_WIN_AHR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0xC + (0x10 * win))
+#define CCU_WIN_GCR_OFFSET(ap)		(MVEBU_CCU_BASE(ap) + 0xD0)
+#define CCU_GCR_TARGET_OFFSET		(8)
+#define CCU_GCR_TARGET_MASK		(0xFF)
+
+/* IO Win registers definitions */
+#define IO_WIN_ALR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0x0 + (0x10 * win))
+#define IO_WIN_AHR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0x8 + (0x10 * win))
+#define IO_WIN_CR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0xC + (0x10 * win))
+
+/* GWin registers definitions */
+#define GWIN_CR_OFFSET(ap, win)		(MVEBU_GWIN_BASE(ap) + \
+						0x0 + (0x10 * (win)))
+#define GWIN_ALR_OFFSET(ap, win)	(MVEBU_GWIN_BASE(ap) + \
+						0x8 + (0x10 * (win)))
+#define GWIN_AHR_OFFSET(ap, win)	(MVEBU_GWIN_BASE(ap) + \
+						0xc + (0x10 * (win)))
+/* IOB registers definitions */
+#define MVEBU_IOB_OFFSET		(0x190000)
+#define MVEBU_IOB_BASE(ap, cp)		(MVEBU_REGS_BASE_CP(ap, cp) + \
+						MVEBU_IOB_OFFSET)
+#define MVEBU_IOB_MAX_WINS		(16)
+
+#define IOB_WIN_CR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0x0 + (0x20 * win))
+#define IOB_TARGET_ID_OFFSET		(8)
+#define IOB_TARGET_ID_MASK		(0xF)
+#define IOB_WIN_ALR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0x8 + (0x20 * win))
+#define IOB_WIN_AHR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0xC + (0x20 * win))
+
+/* AMB address decoding registers definitions */
+#define MVEBU_AMB_ADEC_OFFSET		(0x70ff00)
+#define MVEBU_AMB_ADEC_BASE(ap, cp)	(MVEBU_REGS_BASE_CP(ap, cp) + \
+						MVEBU_AMB_ADEC_OFFSET)
+#define AMB_MAX_WIN_ID			(7)
+#define AMB_WIN_CR_OFFSET(ap, cp, win)	(MVEBU_AMB_ADEC_BASE(ap, cp) \
+						+ 0x0 + (0x8 * win))
+#define AMB_ATTR_OFFSET			8
+#define AMB_ATTR_MASK			0xFF
+#define AMB_SIZE_OFFSET			16
+#define AMB_SIZE_MASK			0xFF
+
+#define AMB_WIN_BASE_OFFSET(ap, cp, win) (MVEBU_AMB_ADEC_BASE(ap, cp) + \
+						0x4 + 0x8 * (win))
+#define AMB_BASE_OFFSET			(16)
+#define AMB_BASE_ADDR_MASK		((1 << (32 - AMB_BASE_OFFSET)) - 1)
+
+static void dump_ccu(int ap)
+{
+	u32 win_id, win_cr, alr, ahr;
+	u8 target_id;
+	u64 start, end;
+
+	/* Dump all CCU windows */
+	printf("-----------\n");
+	printf("AP-%d CCU:\n", ap);
+	printf("bank  id target   start		     end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_CCU_MAX_WINS; win_id++) {
+		win_cr = readl(CCU_WIN_CR_OFFSET(ap, win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			printf("ccu   %02x", win_id);
+			target_id = (win_cr >> CCU_TARGET_ID_OFFSET) &
+						CCU_TARGET_ID_MASK;
+			alr = readl(CCU_WIN_ALR_OFFSET(ap, win_id));
+			ahr = readl(CCU_WIN_AHR_OFFSET(ap, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			printf(" %02x  0x%016llx 0x%016llx\n",
+			       target_id, start, end);
+		}
+	}
+	win_cr = readl(CCU_WIN_GCR_OFFSET(ap));
+	target_id = (win_cr >> CCU_GCR_TARGET_OFFSET) & CCU_GCR_TARGET_MASK;
+	printf("ccu   GCR 0x%x\n", target_id);
+}
+
+static void dump_io_win(int ap)
+{
+	u32 trgt_id, win_id;
+	u32 alr, ahr;
+	u64 start, end;
+
+	/* Dump all IO windows */
+	printf("-----------\n");
+	printf("AP-%d IOW:\n", ap);
+	printf("bank  target     start              end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_IO_WIN_MAX_WINS; win_id++) {
+		alr = readl(IO_WIN_ALR_OFFSET(ap, win_id));
+		if (alr & WIN_ENABLE_BIT) {
+			alr &= ~WIN_ENABLE_BIT;
+			ahr = readl(IO_WIN_AHR_OFFSET(ap, win_id));
+			trgt_id = readl(IO_WIN_CR_OFFSET(ap, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			printf("io-win %d  0x%016llx 0x%016llx\n",
+			       trgt_id, start, end);
+		}
+	}
+	printf("io-win GCR - 0x%x\n",
+	       readl(MVEBU_IO_WIN_BASE(ap) + MVEBU_IO_WIN_GCR_OFFSET));
+}
+
+static void dump_gwin(int ap)
+{
+#if defined(CONFIG_ARMADA_8K_PLUS)
+	u32 win_num;
+
+	/* Dump all GWIN windows */
+	printf("-----------\n");
+	printf("AP-%d GWIN:\n", ap);
+	printf("win\ttarget\tstart\t\t\tend\n");
+	printf("----------------------------------------------------\n");
+	for (win_num = 0; win_num < MVEBU_GWIN_MAX_WINS; win_num++) {
+		u32 cr;
+		u64 alr, ahr;
+
+		cr  = readl(GWIN_CR_OFFSET(ap, win_num));
+		/* Window enabled */
+		if (cr & WIN_ENABLE_BIT) {
+			printf("%02d\t %02d\t ", win_num, (cr >> 8) & 0xF);
+			alr = readl(GWIN_ALR_OFFSET(ap, win_num));
+			alr = (alr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
+			ahr = readl(GWIN_AHR_OFFSET(ap, win_num));
+			ahr = (ahr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
+			printf("0x%016llx 0x%016llx\n", alr, ahr);
+		}
+	}
+#endif
+}
+
+static void dump_iob(int ap, int cp)
+{
+	u32 win_id, win_cr, alr, ahr;
+	u8 target_id;
+	u64 start, end;
+
+	static const char * const iob_target_name[] = {"CFG  ", "MCI0 ",
+			"PEX1 ", "PEX2 ", "PEX0 ", "NAND ", "RUNIT", "MCI1 "};
+
+	/* Dump all IOB windows */
+	printf("AP-%d CP-%d IOB:\n", ap, cp);
+	printf("bank  id target  start              end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_IOB_MAX_WINS; win_id++) {
+		win_cr = readl(IOB_WIN_CR_OFFSET(ap, cp, win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			target_id = (win_cr >> IOB_TARGET_ID_OFFSET) &
+						IOB_TARGET_ID_MASK;
+			alr = readl(IOB_WIN_ALR_OFFSET(ap, cp, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			if (win_id != 0) {
+				ahr = readl(IOB_WIN_AHR_OFFSET(ap, cp, win_id));
+				end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			} else {
+				/* Window #0 size is hardcoded to 16MB, as it's
+				 * reserved for CP configuration space.
+				 */
+				end = start + (16 << 20);
+			}
+			printf("iob   %02d %s   0x%016llx 0x%016llx\n",
+			       win_id, iob_target_name[target_id], start, end);
+		}
+	}
+}
+
+static void dump_amb_adec(int ap, int cp)
+{
+	u32 ctrl, base, win_id, attr;
+	u32 size, size_count;
+
+	/* Dump all AMB windows */
+	printf("AP-%d CP-%d AMB addr.decode:\n", ap, cp);
+	printf("bank  attribute     base          size\n");
+	printf("--------------------------------------------\n");
+	for (win_id = 0; win_id < AMB_MAX_WIN_ID; win_id++) {
+		ctrl = readl(AMB_WIN_CR_OFFSET(ap, cp, win_id));
+		if (ctrl & WIN_ENABLE_BIT) {
+			base = readl(AMB_WIN_BASE_OFFSET(ap, cp, win_id));
+			attr = (ctrl >> AMB_ATTR_OFFSET) & AMB_ATTR_MASK;
+			size_count = (ctrl >> AMB_SIZE_OFFSET) & AMB_SIZE_MASK;
+			size = (size_count + 1) * SZ_64K;
+			printf("amb   0x%04x        0x%08x    0x%08x\n",
+			       attr, base, size);
+		}
+	}
+}
+
+int do_map_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	int ap, cp, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+
+	for (ap = 0; ap < ap_num; ap++) {
+		printf("AP-%d address decoding:\n", ap);
+		dump_ccu(ap);
+		dump_io_win(ap);
+		dump_gwin(ap);
+		for (cp = 0; cp < (cp_num / ap_num); cp++) {
+			printf("\nAP-%d CP-%d address decoding:\n", ap, cp);
+			dump_iob(ap, cp);
+			dump_amb_adec(ap, cp);
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	map,      1,     1,      do_map_cmd,
+	"Display address decode windows\n",
+	"\tDisplay address decode windows\n"
+);
diff --git a/cmd/mvebu/mv88e6xxx-util.c b/cmd/mvebu/mv88e6xxx-util.c
new file mode 100644
index 0000000000..ceb2558ac2
--- /dev/null
+++ b/cmd/mvebu/mv88e6xxx-util.c
@@ -0,0 +1,633 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ */
+
+#include "mv88e6xxx-util.h"
+/* If the switch's ADDR[4:0] strap pins are strapped to zero, it will
+ * use all 32 SMI bus addresses on its SMI bus, and all switch registers
+ * will be directly accessible on some {device address,register address}
+ * pair.  If the ADDR[4:0] pins are not strapped to zero, the switch
+ * will only respond to SMI transactions to that specific address, and
+ * an indirect addressing mechanism needs to be used to access its
+ * registers.
+ */
+
+static struct mv88e6xxx_dev soho_dev;
+static struct mv88e6xxx_dev *soho_dev_handle;
+static int REG_PORT_BASE = REG_PORT_BASE_UNDEFINED;
+
+static int mv88e6xxx_reg_wait_ready(struct mv88e6xxx_dev *dev)
+{
+	int ret;
+	int i;
+	int loop_timeout = 50;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = miiphy_read(name, dev->phy_addr, SMI_CMD, &val);
+		if (ret < 0)
+			return ret;
+		if ((val & SMI_CMD_BUSY) == 0)
+			return 0;
+
+		mdelay(10);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int mv88e6xxx_read_register(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0) {
+		ret = miiphy_read(name, port, reg, &val);
+		if (ret < 0)
+			return ret;
+		else
+			return (int)val;
+	}
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the read command. */
+	ret = miiphy_write(name, dev->phy_addr, SMI_CMD,
+			   SMI_CMD_OP_22_READ |
+			   ((port & SMI_CMD_DEV_ADDR_MASK)
+			   << SMI_CMD_DEV_ADDR_SIZE) |
+			   (reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Read the data. */
+	ret = miiphy_read(name, dev->phy_addr, SMI_DATA, &val);
+	if (ret < 0)
+		return ret;
+
+	return (int)val;
+}
+
+static int mv88e6xxx_reg_wait_ready_indirect(struct mv88e6xxx_dev *dev)
+{
+	int ret, i;
+	int loop_timeout = 50;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP);
+		if (ret < 0)
+			return ret;
+		if (!(ret & GLOBAL2_SMI_OP_BUSY))
+			return 0;
+		mdelay(10);
+	}
+	return -ETIMEDOUT;
+}
+
+static int mv88e6xxx_write_register(struct mv88e6xxx_dev *dev, int port,
+				    int reg, unsigned short val)
+{
+	int ret;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0) {
+	/* Need wait for indriect ready before write command.*/
+		ret = mv88e6xxx_reg_wait_ready_indirect(dev);
+		if (ret < 0)
+			return ret;
+		else
+			return miiphy_write(name, port, reg, val);
+	}
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit data to write. */
+	ret = miiphy_write(name, dev->phy_addr, SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the write command. */
+	ret = miiphy_write(name, dev->phy_addr, SMI_CMD,
+			   SMI_CMD_OP_22_WRITE |
+			   ((port & SMI_CMD_DEV_ADDR_MASK)
+			   << SMI_CMD_DEV_ADDR_SIZE) |
+			   (reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mv88e6xxx_read_indirect(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(dev,
+				       REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_22_READ |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_reg_wait_ready_indirect(dev);
+	if (ret < 0)
+		return ret;
+
+	return mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA);
+}
+
+static int mv88e6xxx_write_indirect(struct mv88e6xxx_dev *dev, int port,
+				    int reg, unsigned short val)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_write_register(dev,
+				       REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_22_WRITE |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (reg & SMI_CMD_REG_ADDR_MASK));
+
+	return mv88e6xxx_reg_wait_ready_indirect(dev);
+}
+
+static int mv88e6xxx_read_phy_register(struct mv88e6xxx_dev *dev, int port,
+				       int page, int reg)
+{
+	int ret;
+
+	if (!dev)
+		return -ENODEV;
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret >= 0)
+		/* read if page loaded successfully  */
+		ret = mv88e6xxx_read_indirect(dev, port, reg);
+	/* restore page 0  */
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+static int mv88e6xxx_write_phy_register(struct mv88e6xxx_dev *dev, int port,
+					int page, int reg, unsigned short val)
+{
+	int ret;
+
+	if (!dev) {
+		printf("Soho dev not initialized\n");
+		return -1;
+	}
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret >= 0)
+		/* write if page loaded successfully  */
+		ret = mv88e6xxx_write_indirect(dev, port, reg, val);
+	/* restore page 0  */
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+static int mv88e6xxx_read_dev_register(struct mv88e6xxx_dev *dev, int port,
+				       int devic, int reg)
+{
+	int ret;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* Write address. */
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA, reg);
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_45_WRITE_ADDR |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (devic & SMI_CMD_REG_ADDR_MASK));
+
+	/* Write read commdand.*/
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_45_READ_DATA |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (devic & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_reg_wait_ready_indirect(dev);
+	if (ret < 0)
+		return ret;
+
+	return mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA);
+}
+
+static int mv88e6xxx_write_dev_register(struct mv88e6xxx_dev *dev, int port,
+					int devic, int reg, unsigned short val)
+{
+	int ret;
+
+	/* Write address. */
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2,
+				       GLOBAL2_SMI_DATA, reg);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_45_WRITE_ADDR |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (devic & SMI_CMD_REG_ADDR_MASK));
+
+	/* write data. */
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+				       GLOBAL2_SMI_OP_45_WRITE_DATA |
+				       ((port & SMI_CMD_DEV_ADDR_MASK)
+				       << SMI_CMD_DEV_ADDR_SIZE) |
+				       (devic & SMI_CMD_REG_ADDR_MASK));
+
+	return mv88e6xxx_reg_wait_ready_indirect(dev);
+}
+
+static void mv88e6xxx_display_switch_info(struct mv88e6xxx_dev *dev)
+{
+	unsigned int product_num;
+
+	if (dev->id < 0) {
+		printf("No Switch Device Found\n");
+		return;
+	}
+
+	product_num = ((unsigned int)dev->id) >> 4;
+	if (product_num == PORT_SWITCH_ID_PROD_NUM_6390 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6390X ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6290 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6190 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6193) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Amethyst\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Topaz\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+	} else {
+		printf("Unknown switch with Device ID: 0x%X\n", dev->id);
+	}
+}
+
+/* We expect the switch to perform auto negotiation if there is a real phy. */
+static int mv88e6xxx_get_link_status(struct mv88e6xxx_dev *dev, int port)
+{
+int ret;
+
+	ret = mv88e6xxx_read_register(dev, REG_PORT(port), PORT_STATUS);
+	if (ret < 0)
+		return ret;
+
+	printf("Port: 0x%X, ", port);
+	if (ret & PORT_STATUS_LINK) {
+		printf("Link: UP, ");
+	} else {
+		printf("Link: Down\n");
+		return 0;
+	}
+
+	if (ret & PORT_STATUS_DUPLEX)
+		printf("Duplex: FULL, ");
+	else
+		printf("Duplex: HALF, ");
+
+	if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_10) {
+		printf("Speed: 10 Mbps\n");
+	} else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_100) {
+		if (ret & PORT_STATUS_HD_FLOW)
+			printf("Speed: 200 Mbps\n");
+		else
+			printf("Speed: 100 Mbps\n");
+	} else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_1000) {
+		if (ret & PORT_STATUS_HD_FLOW)
+			printf("Speed: 2500 Mbps\n");
+		else
+			printf("Speed: 1000 Mbps\n");
+	} else if ((ret & PORT_STATUS_SPEED_MASK) ==
+		 PORT_STATUS_SPEED_2500_10G) {
+		if (ret & PORT_STATUS_HD_FLOW)
+			printf("Speed: 5 Gbps\n");
+		else
+			printf("Speed: 10 Gbps\n");
+	} else {
+		printf("Speed: Unknown\n");
+	}
+
+	return 0;
+}
+
+static int mv88e6xxx_get_switch_id(struct mv88e6xxx_dev *dev)
+{
+	int id, product_num;
+
+	/* Peridot switch port device address starts from 0
+	 * Legacy switch port device address starts from 0x10
+	 *
+	 * In order to determine which switch is used, we need to
+	 * read the ID, but inorder to read the ID, we need to know
+	 * the port device address - classic chicken or the egg case.
+	 *
+	 * Let's read with both port device addresses, if we get 0xFFFF,
+	 * the address is incorrect and we need to ready with the second
+	 * address.
+	 */
+	id = mv88e6xxx_read_register(dev, REG_PORT_BASE_LEGACY,
+				     PORT_SWITCH_ID);
+	if (id == 0xFFFF)
+		id = mv88e6xxx_read_register(dev, REG_PORT_BASE_PERIDOT,
+					     PORT_SWITCH_ID);
+
+	if (id < 0)
+		return id;
+
+	product_num = id >> 4;
+	if (product_num == PORT_SWITCH_ID_PROD_NUM_6190 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6193 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6290 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6390 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6390X) {
+		/* Peridot switch port device address starts from 0 */
+		REG_PORT_BASE = REG_PORT_BASE_PERIDOT;
+		return id;
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		/* Legacy switch port device address starts from 0x10 */
+		REG_PORT_BASE = REG_PORT_BASE_LEGACY;
+		return id;
+	}
+	printf("Unknown product_num:0x%X\n", product_num);
+	return -ENODEV;
+}
+
+static int sw_resolve_options(char *str)
+{
+	if (strcmp(str, "info") == 0)
+		return SW_INFO;
+	else if (strcmp(str, "read") == 0)
+		return SW_READ;
+	else if (strcmp(str, "write") == 0)
+		return SW_WRITE;
+	else if (strcmp(str, "phy_read") == 0)
+		return SW_PHY_READ;
+	else if (strcmp(str, "phy_write") == 0)
+		return SW_PHY_WRITE;
+	else if (strcmp(str, "dev_read") == 0)
+		return SW_DEV_READ;
+	else if (strcmp(str, "dev_write") == 0)
+		return SW_DEV_WRITE;
+	else if (strcmp(str, "link") == 0)
+		return SW_LINK;
+	else
+		return SW_NA;
+}
+
+static int do_sw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct mv88e6xxx_dev *dev;
+	int port, reg, page, val = 0, ret = 0;
+
+	if (argc < 3)
+		return CMD_RET_USAGE;
+
+	soho_dev.phy_addr = (int)simple_strtoul(argv[1], NULL, 16);
+
+	if (soho_dev.phy_addr == 0)
+		soho_dev.addr_mode = 0;  /* Single Addressing mode */
+	else
+		soho_dev.addr_mode = 1;  /* Multi Addressing mode */
+
+	soho_dev.id = mv88e6xxx_get_switch_id(&soho_dev);
+
+	soho_dev_handle = &soho_dev;
+	dev = soho_dev_handle;
+
+	if (soho_dev.id < 0) {
+		printf("Switch Device not found\n");
+		return -ENODEV;
+	}
+
+	switch (sw_resolve_options(argv[2])) {
+	case SW_INFO:
+		mv88e6xxx_display_switch_info(dev);
+		break;
+	case SW_READ:
+		if (argc < 5) {
+			printf("Syntax Error: switch read <port> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		ret = mv88e6xxx_read_register(dev, REG_PORT(port), reg);
+		if (ret < 0) {
+			printf("Failed: Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, ret: %d\n", reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n", reg, ret);
+		}
+		break;
+
+	case SW_WRITE:
+		if (argc < 6) {
+			printf("Syntax Error: ");
+			printf("switch write <port> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		val  = (int)simple_strtoul(argv[5], NULL, 16);
+		ret = mv88e6xxx_write_register(dev, REG_PORT(port), reg,
+					       (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X, ret: %d\n",
+			       reg, val, ret);
+		} else {
+			printf("Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n",
+			       reg, val);
+		}
+		break;
+
+	case SW_PHY_READ:
+		if (argc < 6) {
+			printf("Syntax Error: ");
+			printf("switch phy_read <port> <page> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[3], NULL, 16);
+		page = (int)simple_strtoul(argv[4], NULL, 16);
+		reg  = (int)simple_strtoul(argv[5], NULL, 16);
+		ret = mv88e6xxx_read_phy_register(dev, REG_PORT(port),
+						  page, reg);
+		if (ret < 0) {
+			printf("Failed: Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X\n, ret: %d",
+			       page, reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, ret);
+		}
+		break;
+
+	case SW_PHY_WRITE:
+		if (argc < 7) {
+			printf("Syntax Error: ");
+			printf("switch phy_write <port> <page> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[3], NULL, 16);
+		page = (int)simple_strtoul(argv[4], NULL, 16);
+		reg  = (int)simple_strtoul(argv[5], NULL, 16);
+		val  = (int)simple_strtoul(argv[6], NULL, 16);
+		ret = mv88e6xxx_write_phy_register(dev, REG_PORT(port),
+						   page, reg,
+						   (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X, ret: %d\n",
+			       page, reg, val, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, val);
+		}
+		break;
+
+	case SW_DEV_READ:
+		if (argc < 6) {
+			printf("Syntax Error: ");
+			printf("mvswitch <mii_add> dev_read  ");
+			printf("<port> <dev> <reg>\n");
+			return 1;
+		}
+		port = (int)strtoul(argv[3], NULL, 16);
+		page = (int)strtoul(argv[4], NULL, 16);
+		reg  = (int)strtoul(argv[5], NULL, 16);
+		ret = mv88e6xxx_read_dev_register(dev, REG_PORT(port),
+						  page, reg);
+		if (ret < 0) {
+			printf("Failed: Read - switch port: 0x%X, ", port);
+			printf("dev: 0x%X, reg: 0x%X\n, ret: %d",
+			       page, reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("dev: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, ret);
+		}
+		break;
+
+	case SW_DEV_WRITE:
+		if (argc < 7) {
+			printf("Syntax Error: ");
+			printf("mvswitch <mii_add> dev_write ");
+			printf("<port> <dev> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)strtoul(argv[3], NULL, 16);
+		page = (int)strtoul(argv[4], NULL, 16);
+		reg  = (int)strtoul(argv[5], NULL, 16);
+		val  = (int)strtoul(argv[6], NULL, 16);
+		ret = mv88e6xxx_write_dev_register(dev, REG_PORT(port),
+						   page, reg,
+						   (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("dev: 0x%X, reg: 0x%X, val: 0x%X, ret: %d\n",
+			       page, reg, val, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("dev: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, val);
+		}
+		break;
+
+	case SW_LINK:
+		if (argc < 4) {
+			printf("Error: Too few arguments\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[3], NULL, 16);
+		ret = mv88e6xxx_get_link_status(dev, port);
+		break;
+
+	case SW_NA:
+		printf("\"switch %s\" - Wrong command. Try \"help switch\"\n",
+		       argv[1]);
+
+	default:
+		return CMD_RET_USAGE;
+	}
+	return 0;
+}
+
+/***************************************************/
+U_BOOT_CMD(
+	mvswitch,	7,	1,	do_sw,
+	"MV88e6xxx Switch Access commands",
+	"mvswitch <mii_add> info  - Display switch information\n"
+	"mvswitch <mii_add> read   <port> <reg>       - read switch register <reg> of a <port>\n"
+	"mvswitch <mii_add> write  <port> <reg> <val> - write <val> to switch register <reg> of a <port>\n"
+	"mvswitch <mii_add> phy_read  <port> <page> <reg>         - read internal switch phy register <reg> at <page> of a switch <port>\n"
+	"mvswitch <mii_add> phy_write <port> <page> <reg> <val>   - write <val> to internal phy register at <page> of a <port>\n"
+	"mvswitch <mii_add> dev_read  <port> <device> <reg>       - read internal switch dev register <reg> at <dev> of a switch <port>\n"
+	"mvswitch <mii_add> dev_write <port> <device> <reg> <val> - write <val> to internal dev register at <dev> of a <port>\n"
+	"mvswitch <mii_add> link  <port> - Display link state and speed of a <port>\n"
+);
diff --git a/cmd/mvebu/mv88e6xxx-util.h b/cmd/mvebu/mv88e6xxx-util.h
new file mode 100644
index 0000000000..9746ee0df8
--- /dev/null
+++ b/cmd/mvebu/mv88e6xxx-util.h
@@ -0,0 +1,397 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ *
+ * Copyright (C) 2020 Marvell International Ltd.
+ *
+ */
+
+#ifndef _MV88E6XXX_UTIL_H__
+#define _MV88E6XXX_UTIL_H__
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <config/arch/mvebu.h>
+#include <fdtdec.h>
+#include <fdt.h>
+#include <linux/compat.h>
+#include <linux/mbus.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <net.h>
+#include <netdev.h>
+#include <pci.h>
+#include <phy.h>
+#include <watchdog.h>
+
+#define SMI_CMD					0x00
+#define SMI_CMD_BUSY				BIT(15)
+#define SMI_CMD_CLAUSE_22			BIT(12)
+#define SMI_CMD_OP_22_WRITE			\
+			((1 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_22_READ			\
+			((2 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_45_WRITE_ADDR		((0 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_WRITE_DATA		((1 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA			((2 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA_INC		((3 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_DEV_ADDR_MASK			0x1f
+#define SMI_CMD_DEV_ADDR_SIZE			5
+#define SMI_CMD_REG_ADDR_MASK			0x1f
+#define SMI_DATA				0x01
+
+#define SMI_PHY_PAGE_REG			0x16
+
+/* Fiber/SERDES Registers are located at SMI address F, page 1 */
+#define REG_FIBER_SERDES			0x0f
+#define PAGE_FIBER_SERDES			0x01
+
+#define REG_PORT_BASE_UNDEFINED			0xFFFF
+#define REG_PORT_BASE_LEGACY			0x10
+#define REG_PORT_BASE_PERIDOT			0
+#define REG_PORT(p)				(REG_PORT_BASE + (p))
+#define PORT_STATUS				0x00
+#define PORT_STATUS_PAUSE_EN			BIT(15)
+#define PORT_STATUS_MY_PAUSE			BIT(14)
+#define PORT_STATUS_HD_FLOW			BIT(13)
+#define PORT_STATUS_PHY_DETECT			BIT(12)
+#define PORT_STATUS_LINK			BIT(11)
+#define PORT_STATUS_DUPLEX			BIT(10)
+#define PORT_STATUS_SPEED_MASK			0x0300
+#define PORT_STATUS_SPEED_10			0x0000
+#define PORT_STATUS_SPEED_100			0x0100
+#define PORT_STATUS_SPEED_1000			0x0200
+#define PORT_STATUS_SPEED_2500_10G		0x0300
+#define PORT_STATUS_EEE				BIT(6) /* 6352 */
+#define PORT_STATUS_AM_DIS			BIT(6) /* 6165 */
+#define PORT_STATUS_MGMII			BIT(6) /* 6185 */
+#define PORT_STATUS_TX_PAUSED			BIT(5)
+#define PORT_STATUS_FLOW_CTRL			BIT(4)
+#define PORT_STATUS_CMODE_MASK			0x0f
+#define PORT_STATUS_CMODE_100BASE_X		0x8
+#define PORT_STATUS_CMODE_1000BASE_X		0x9
+#define PORT_STATUS_CMODE_SGMII			0xa
+#define PORT_STATUS_CMODE_2500BASE_X		0xb
+#define PORT_PCS_CTRL				0x01
+#define PORT_PCS_CTRL_RGMII_DELAY_RXCLK		BIT(15)
+#define PORT_PCS_CTRL_RGMII_DELAY_TXCLK		BIT(14)
+#define PORT_PCS_CTRL_FORCE_SPEED		BIT(13)
+
+#define PORT_PCS_CTRL_FC				BIT(7)
+#define PORT_PCS_CTRL_FORCE_FC			BIT(6)
+#define PORT_PCS_CTRL_LINK_UP			BIT(5)
+#define PORT_PCS_CTRL_FORCE_LINK		BIT(4)
+#define PORT_PCS_CTRL_DUPLEX_FULL		BIT(3)
+#define PORT_PCS_CTRL_FORCE_DUPLEX		BIT(2)
+#define PORT_PCS_CTRL_10			0x00
+#define PORT_PCS_CTRL_100			0x01
+#define PORT_PCS_CTRL_1000			0x02
+#define PORT_PCS_CTRL_UNFORCED		0x03
+
+#define PORT_PAUSE_CTRL				0x02
+#define PORT_SWITCH_ID				0x03
+
+#define PORT_SWITCH_ID_PROD_NUM_6190		0x190
+#define PORT_SWITCH_ID_PROD_NUM_6193		0x193
+#define PORT_SWITCH_ID_PROD_NUM_6290		0x290
+#define PORT_SWITCH_ID_PROD_NUM_6390		0x390
+#define PORT_SWITCH_ID_PROD_NUM_6390X		0x0a1
+#define PORT_SWITCH_ID_PROD_NUM_6141		0x141
+#define PORT_SWITCH_ID_PROD_NUM_6341		0x341
+
+#define PORT_CONTROL				0x04
+#define PORT_CONTROL_USE_CORE_TAG		BIT(15)
+#define PORT_CONTROL_DROP_ON_LOCK		BIT(14)
+#define PORT_CONTROL_EGRESS_UNMODIFIED		(0x0 << 12)
+#define PORT_CONTROL_EGRESS_UNTAGGED		(0x1 << 12)
+#define PORT_CONTROL_EGRESS_TAGGED		(0x2 << 12)
+#define PORT_CONTROL_EGRESS_ADD_TAG		(0x3 << 12)
+#define PORT_CONTROL_HEADER			BIT(11)
+#define PORT_CONTROL_IGMP_MLD_SNOOP		BIT(10)
+#define PORT_CONTROL_DOUBLE_TAG			BIT(9)
+#define PORT_CONTROL_FRAME_MODE_NORMAL		(0x0 << 8)
+#define PORT_CONTROL_FRAME_MODE_DSA		(0x1 << 8)
+#define PORT_CONTROL_FRAME_MODE_PROVIDER	(0x2 << 8)
+#define PORT_CONTROL_FRAME_ETHER_TYPE_DSA	(0x3 << 8)
+#define PORT_CONTROL_DSA_TAG			BIT(8)
+#define PORT_CONTROL_VLAN_TUNNEL		BIT(7)
+#define PORT_CONTROL_TAG_IF_BOTH		BIT(6)
+#define PORT_CONTROL_USE_IP			BIT(5)
+#define PORT_CONTROL_USE_TAG			BIT(4)
+#define PORT_CONTROL_FORWARD_UNKNOWN_MC		BIT(3)
+#define PORT_CONTROL_FORWARD_UNKNOWN		BIT(2)
+#define PORT_CONTROL_STATE_MASK			0x03
+#define PORT_CONTROL_STATE_DISABLED		0x00
+#define PORT_CONTROL_STATE_BLOCKING		0x01
+#define PORT_CONTROL_STATE_LEARNING		0x02
+#define PORT_CONTROL_STATE_FORWARDING		0x03
+#define PORT_CONTROL_1				0x05
+#define PORT_CONTROL_1_FID_11_4_MASK		(0xff << 0)
+#define PORT_BASE_VLAN				0x06
+#define PORT_BASE_VLAN_FID_3_0_MASK		(0xf << 12)
+#define PORT_DEFAULT_VLAN			0x07
+#define PORT_DEFAULT_VLAN_MASK			0xfff
+#define PORT_CONTROL_2				0x08
+#define PORT_CONTROL_2_IGNORE_FCS		BIT(15)
+#define PORT_CONTROL_2_VTU_PRI_OVERRIDE		BIT(14)
+#define PORT_CONTROL_2_SA_PRIO_OVERRIDE		BIT(13)
+#define PORT_CONTROL_2_DA_PRIO_OVERRIDE		BIT(12)
+#define PORT_CONTROL_2_JUMBO_1522		(0x00 << 12)
+#define PORT_CONTROL_2_JUMBO_2048		(0x01 << 12)
+#define PORT_CONTROL_2_JUMBO_10240		(0x02 << 12)
+#define PORT_CONTROL_2_8021Q_MASK		(0x03 << 10)
+#define PORT_CONTROL_2_8021Q_DISABLED		(0x00 << 10)
+#define PORT_CONTROL_2_8021Q_FALLBACK		(0x01 << 10)
+#define PORT_CONTROL_2_8021Q_CHECK		(0x02 << 10)
+#define PORT_CONTROL_2_8021Q_SECURE		(0x03 << 10)
+#define PORT_CONTROL_2_DISCARD_TAGGED		BIT(9)
+#define PORT_CONTROL_2_DISCARD_UNTAGGED		BIT(8)
+#define PORT_CONTROL_2_MAP_DA			BIT(7)
+#define PORT_CONTROL_2_DEFAULT_FORWARD		BIT(6)
+#define PORT_CONTROL_2_FORWARD_UNKNOWN		BIT(6)
+#define PORT_CONTROL_2_EGRESS_MONITOR		BIT(5)
+#define PORT_CONTROL_2_INGRESS_MONITOR		BIT(4)
+#define PORT_RATE_CONTROL			0x09
+#define PORT_RATE_CONTROL_2			0x0a
+#define PORT_ASSOC_VECTOR			0x0b
+#define PORT_ASSOC_VECTOR_HOLD_AT_1		BIT(15)
+#define PORT_ASSOC_VECTOR_INT_AGE_OUT		BIT(14)
+#define PORT_ASSOC_VECTOR_LOCKED_PORT		BIT(13)
+#define PORT_ASSOC_VECTOR_IGNORE_WRONG		BIT(12)
+#define PORT_ASSOC_VECTOR_REFRESH_LOCKED	BIT(11)
+#define PORT_ATU_CONTROL			0x0c
+#define PORT_PRI_OVERRIDE			0x0d
+#define PORT_ETH_TYPE				0x0f
+#define PORT_IN_DISCARD_LO			0x10
+#define PORT_IN_DISCARD_HI			0x11
+#define PORT_IN_FILTERED			0x12
+#define PORT_OUT_FILTERED			0x13
+#define PORT_TAG_REGMAP_0123			0x18
+#define PORT_TAG_REGMAP_4567			0x19
+
+#define REG_GLOBAL				0x1b
+#define GLOBAL_STATUS				0x00
+#define GLOBAL_STATUS_PPU_STATE			BIT(15) /* 6351 and 6171 */
+/* Two bits for 6165, 6185 etc */
+#define GLOBAL_STATUS_PPU_MASK			(0x3 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED_RST		(0x0 << 14)
+#define GLOBAL_STATUS_PPU_INITIALIZING		(0x1 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED		(0x2 << 14)
+#define GLOBAL_STATUS_PPU_POLLING		(0x3 << 14)
+#define GLOBAL_MAC_01				0x01
+#define GLOBAL_MAC_23				0x02
+#define GLOBAL_MAC_45				0x03
+#define GLOBAL_ATU_FID				0x01 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID				0x02 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID_MASK			0xfff
+#define GLOBAL_VTU_SID				0x03 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_SID_MASK			0x3f
+#define GLOBAL_CONTROL				0x04
+#define GLOBAL_CONTROL_SW_RESET			BIT(15)
+#define GLOBAL_CONTROL_PPU_ENABLE		BIT(14)
+#define GLOBAL_CONTROL_DISCARD_EXCESS		BIT(13) /* 6352 */
+#define GLOBAL_CONTROL_SCHED_PRIO		BIT(11) /* 6152 */
+#define GLOBAL_CONTROL_MAX_FRAME_1632		BIT(10) /* 6152 */
+#define GLOBAL_CONTROL_RELOAD_EEPROM		BIT(9)	/* 6152 */
+#define GLOBAL_CONTROL_DEVICE_EN		BIT(7)
+#define GLOBAL_CONTROL_STATS_DONE_EN		BIT(6)
+#define GLOBAL_CONTROL_VTU_PROBLEM_EN		BIT(5)
+#define GLOBAL_CONTROL_VTU_DONE_EN		BIT(4)
+#define GLOBAL_CONTROL_ATU_PROBLEM_EN		BIT(3)
+#define GLOBAL_CONTROL_ATU_DONE_EN		BIT(2)
+#define GLOBAL_CONTROL_TCAM_EN			BIT(1)
+#define GLOBAL_CONTROL_EEPROM_DONE_EN		BIT(0)
+#define GLOBAL_VTU_OP				0x05
+#define GLOBAL_VTU_OP_BUSY			BIT(15)
+#define GLOBAL_VTU_OP_FLUSH_ALL			\
+					((0x01 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_LOAD_PURGE		\
+					((0x03 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_GET_NEXT		\
+					((0x04 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_LOAD_PURGE		\
+					((0x05 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_GET_NEXT		\
+					((0x06 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_VID				0x06
+#define GLOBAL_VTU_VID_MASK			0xfff
+#define GLOBAL_VTU_VID_VALID			BIT(12)
+#define GLOBAL_VTU_DATA_0_3			0x07
+#define GLOBAL_VTU_DATA_4_7			0x08
+#define GLOBAL_VTU_DATA_8_11			0x09
+#define GLOBAL_VTU_STU_DATA_MASK		0x03
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNMODIFIED	0x00
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNTAGGED	0x01
+#define GLOBAL_VTU_DATA_MEMBER_TAG_TAGGED	0x02
+#define GLOBAL_VTU_DATA_MEMBER_TAG_NON_MEMBER	0x03
+#define GLOBAL_STU_DATA_PORT_STATE_DISABLED	0x00
+#define GLOBAL_STU_DATA_PORT_STATE_BLOCKING	0x01
+#define GLOBAL_STU_DATA_PORT_STATE_LEARNING	0x02
+#define GLOBAL_STU_DATA_PORT_STATE_FORWARDING	0x03
+#define GLOBAL_ATU_CONTROL			0x0a
+#define GLOBAL_ATU_CONTROL_LEARN2ALL		BIT(3)
+#define GLOBAL_ATU_OP				0x0b
+#define GLOBAL_ATU_OP_BUSY			BIT(15)
+#define GLOBAL_ATU_OP_NOP			(0 << 12)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL		\
+					((1 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC	\
+					((2 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_LOAD_DB			\
+					((3 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_NEXT_DB		\
+					((4 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL_DB		\
+					((5 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC_DB	\
+					((6 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_CLR_VIOLATION		\
+					((7 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_DATA				0x0c
+#define GLOBAL_ATU_DATA_TRUNK			BIT(15)
+#define GLOBAL_ATU_DATA_TRUNK_ID_MASK		0x00f0
+#define GLOBAL_ATU_DATA_TRUNK_ID_SHIFT		4
+#define GLOBAL_ATU_DATA_PORT_VECTOR_MASK	0x3ff0
+#define GLOBAL_ATU_DATA_PORT_VECTOR_SHIFT	4
+#define GLOBAL_ATU_DATA_STATE_MASK		0x0f
+#define GLOBAL_ATU_DATA_STATE_UNUSED		0x00
+#define GLOBAL_ATU_DATA_STATE_UC_MGMT		0x0d
+#define GLOBAL_ATU_DATA_STATE_UC_STATIC		0x0e
+#define GLOBAL_ATU_DATA_STATE_UC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_DATA_STATE_MC_NONE_RATE	0x05
+#define GLOBAL_ATU_DATA_STATE_MC_STATIC		0x07
+#define GLOBAL_ATU_DATA_STATE_MC_MGMT		0x0e
+#define GLOBAL_ATU_DATA_STATE_MC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_MAC_01			0x0d
+#define GLOBAL_ATU_MAC_23			0x0e
+#define GLOBAL_ATU_MAC_45			0x0f
+#define GLOBAL_IP_PRI_0				0x10
+#define GLOBAL_IP_PRI_1				0x11
+#define GLOBAL_IP_PRI_2				0x12
+#define GLOBAL_IP_PRI_3				0x13
+#define GLOBAL_IP_PRI_4				0x14
+#define GLOBAL_IP_PRI_5				0x15
+#define GLOBAL_IP_PRI_6				0x16
+#define GLOBAL_IP_PRI_7				0x17
+#define GLOBAL_IEEE_PRI				0x18
+#define GLOBAL_CORE_TAG_TYPE			0x19
+#define GLOBAL_MONITOR_CONTROL			0x1a
+#define GLOBAL_MONITOR_CONTROL_INGRESS_SHIFT	12
+#define GLOBAL_MONITOR_CONTROL_EGRESS_SHIFT	8
+#define GLOBAL_MONITOR_CONTROL_ARP_SHIFT	4
+#define GLOBAL_MONITOR_CONTROL_MIRROR_SHIFT	0
+#define GLOBAL_MONITOR_CONTROL_ARP_DISABLED	(0xf0)
+#define GLOBAL_CONTROL_2			0x1c
+#define GLOBAL_CONTROL_2_NO_CASCADE		0xe000
+#define GLOBAL_CONTROL_2_MULTIPLE_CASCADE	0xf000
+
+#define GLOBAL_STATS_OP			0x1d
+#define GLOBAL_STATS_OP_BUSY		BIT(15)
+#define GLOBAL_STATS_OP_NOP		(0 << 12)
+#define GLOBAL_STATS_OP_FLUSH_ALL	((1 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_FLUSH_PORT	((2 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_READ_CAPTURED	((4 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_CAPTURE_PORT	((5 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX		((1 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_TX		((2 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX_TX	((3 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_BANK_1		BIT(9)
+#define GLOBAL_STATS_COUNTER_32		0x1e
+#define GLOBAL_STATS_COUNTER_01		0x1f
+
+#define REG_GLOBAL2				0x1c
+#define GLOBAL2_INT_SOURCE			0x00
+#define GLOBAL2_INT_MASK			0x01
+#define GLOBAL2_MGMT_EN_2X			0x02
+#define GLOBAL2_MGMT_EN_0X			0x03
+#define GLOBAL2_FLOW_CONTROL			0x04
+#define GLOBAL2_SWITCH_MGMT			0x05
+#define GLOBAL2_SWITCH_MGMT_USE_DOUBLE_TAG_DATA	BIT(15)
+#define GLOBAL2_SWITCH_MGMT_PREVENT_LOOPS	BIT(14)
+#define GLOBAL2_SWITCH_MGMT_FLOW_CONTROL_MSG	BIT(13)
+#define GLOBAL2_SWITCH_MGMT_FORCE_FLOW_CTRL_PRI	BIT(7)
+#define GLOBAL2_SWITCH_MGMT_RSVD2CPU		BIT(3)
+#define GLOBAL2_DEVICE_MAPPING			0x06
+#define GLOBAL2_DEVICE_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_DEVICE_MAPPING_TARGET_SHIFT	8
+#define GLOBAL2_DEVICE_MAPPING_PORT_MASK	0x0f
+#define GLOBAL2_TRUNK_MASK			0x07
+#define GLOBAL2_TRUNK_MASK_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MASK_NUM_SHIFT		12
+#define GLOBAL2_TRUNK_MAPPING			0x08
+#define GLOBAL2_TRUNK_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MAPPING_ID_SHIFT		11
+#define GLOBAL2_INGRESS_OP			0x09
+#define GLOBAL2_INGRESS_DATA			0x0a
+#define GLOBAL2_PVT_ADDR			0x0b
+#define GLOBAL2_PVT_DATA			0x0c
+#define GLOBAL2_SWITCH_MAC			0x0d
+#define GLOBAL2_SWITCH_MAC_BUSY			BIT(15)
+#define GLOBAL2_ATU_STATS			0x0e
+#define GLOBAL2_PRIO_OVERRIDE			0x0f
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_SNOOP	BIT(7)
+#define GLOBAL2_PRIO_OVERRIDE_SNOOP_SHIFT	4
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_ARP		BIT(3)
+#define GLOBAL2_PRIO_OVERRIDE_ARP_SHIFT		0
+#define GLOBAL2_EEPROM_OP			0x14
+#define GLOBAL2_EEPROM_OP_BUSY			BIT(15)
+#define GLOBAL2_EEPROM_OP_WRITE			\
+		((3 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_READ			\
+		((4 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_LOAD			BIT(11)
+#define GLOBAL2_EEPROM_OP_WRITE_EN		BIT(10)
+#define GLOBAL2_EEPROM_OP_ADDR_MASK		0xff
+#define GLOBAL2_EEPROM_DATA			0x15
+#define GLOBAL2_PTP_AVB_OP			0x16
+#define GLOBAL2_PTP_AVB_DATA			0x17
+#define GLOBAL2_SMI_OP				0x18
+#define GLOBAL2_SMI_OP_BUSY			BIT(15)
+#define GLOBAL2_SMI_OP_CLAUSE_22		BIT(12)
+#define GLOBAL2_SMI_OP_22_WRITE			\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_22_READ			\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_45_WRITE_ADDR		\
+		((0 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_WRITE_DATA		\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_READ_DATA		\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_DATA			0x19
+#define GLOBAL2_SCRATCH_MISC			0x1a
+#define GLOBAL2_SCRATCH_BUSY			BIT(15)
+#define GLOBAL2_SCRATCH_REGISTER_SHIFT		8
+#define GLOBAL2_SCRATCH_VALUE_MASK		0xff
+#define GLOBAL2_WDOG_CONTROL			0x1b
+#define GLOBAL2_QOS_WEIGHT			0x1c
+#define GLOBAL2_MISC				0x1d
+
+#define PHY_COPPER_CONTROL		0x0
+#define PHY_COPPER_CONTROL_SPEED_1G	BIT(6)
+#define PHY_COPPER_CONTROL_DUPLEX	BIT(8)
+#define PHY_COPPER_CONTROL_POWER_DOWN	BIT(11)
+#define PHY_COPPER_CONTROL_AUTO_NEG_EN	BIT(12)
+#define PHY_COPPER_CONTROL_SPEED_100M	BIT(13)
+
+struct mv88e6xxx_dev {
+	unsigned int phy_addr;
+	unsigned int port_mask;
+	unsigned int addr_mode;
+	int id;
+	int cpu_port;	/* The switch port to which the CPU is attached */
+};
+
+enum sw_opts {
+	SW_INFO,
+	SW_READ,
+	SW_WRITE,
+	SW_PHY_READ,
+	SW_PHY_WRITE,
+	SW_DEV_READ,
+	SW_DEV_WRITE,
+	SW_LINK,
+	SW_NA
+};
+
+#endif /* _MV88E6XXX_H__*/
diff --git a/cmd/mvebu/mv_fw_info.c b/cmd/mvebu/mv_fw_info.c
new file mode 100644
index 0000000000..b4d211f64d
--- /dev/null
+++ b/cmd/mvebu/mv_fw_info.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <mach/soc.h>
+
+#define MSS_CP_CM3_SRAM_BASE		0x220000
+#define RTOS_VERS_OFSSET		0x1000
+#define	FW_INFO_OFFS			(MVEBU_REGS_BASE_CP(0, 0) + \
+	MSS_CP_CM3_SRAM_BASE + RTOS_VERS_OFSSET)
+#define	UNIT_FW_INFO(n_cp)		(FW_INFO_OFFS + (n_cp) * 0x40)
+
+typedef struct{
+	u8 unit_name[4];
+	u32 mss_pm;
+	u32 mci_link_mgmt;
+	u32 fca;
+	u8 rtos_version[32];
+	u8 rtos_kernel_version[12];
+} FW_INFO;
+
+void mv_print_fw_info(const FW_INFO * const info)
+{
+	u32 first_flag = true;
+
+	printf("Unit: %s\n FreeROTS release: %s\n Kernel: %s\n Flags:",
+	       info->unit_name, info->rtos_version, info->rtos_kernel_version);
+
+	if (info->mci_link_mgmt) {
+		printf(" MCI link management");
+		first_flag = false;
+	}
+
+	if (info->fca) {
+		if (!first_flag)
+			printf(",");
+		printf(" PPv2 Flow Control");
+		first_flag = false;
+	}
+
+	if (info->mss_pm) {
+		if (!first_flag)
+			printf(",");
+		printf(" MSS Power Management");
+	}
+	printf("\n------------------------------------\n");
+}
+
+int mv_do_fw_info_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	FW_INFO info;
+	u32 num_of_cps;
+	u32 num_of_aps;
+	u32 num_of_units;
+	u32 i;
+
+	soc_get_ap_cp_num(&num_of_aps, &num_of_cps);
+	num_of_units = num_of_aps + num_of_cps;
+
+	for (i = 0; i < num_of_units; ++i) {
+		memcpy(&info, (void *)UNIT_FW_INFO(i), sizeof(FW_INFO));
+		mv_print_fw_info(&info);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	mv_fw_info, 1, 0, mv_do_fw_info_cmd,
+	"Prints service CPU firmware information",
+	"");
diff --git a/cmd/mvebu/mv_get_counters.c b/cmd/mvebu/mv_get_counters.c
new file mode 100644
index 0000000000..579bb9f1e5
--- /dev/null
+++ b/cmd/mvebu/mv_get_counters.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <linux/ctype.h>
+#include <mach/soc.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+/* GMAC_MIB Counters register definitions */
+#define MV_MIB_GOOD_OCTETS_RECEIVED_LOW		0x0
+#define MV_MIB_GOOD_OCTETS_RECEIVED_HIGH	0x4
+#define MV_MIB_BAD_OCTETS_RECEIVED		0x8
+#define MV_MIB_CRC_ERRORS_SENT			0xc
+#define MV_MIB_UNICAST_FRAMES_RECEIVED		0x10
+/* Reserved					0x14 */
+#define MV_MIB_BROADCAST_FRAMES_RECEIVED	0x18
+#define MV_MIB_MULTICAST_FRAMES_RECEIVED	0x1c
+#define MV_MIB_FRAMES_64_OCTETS			0x20
+#define MV_MIB_FRAMES_65_TO_127_OCTETS		0x24
+#define MV_MIB_FRAMES_128_TO_255_OCTETS		0x28
+#define MV_MIB_FRAMES_256_TO_511_OCTETS		0x2c
+#define MV_MIB_FRAMES_512_TO_1023_OCTETS	0x30
+#define MV_MIB_FRAMES_1024_TO_MAX_OCTETS	0x34
+#define MV_MIB_GOOD_OCTETS_SENT_LOW		0x38
+#define MV_MIB_GOOD_OCTETS_SENT_HIGH		0x3c
+#define MV_MIB_UNICAST_FRAMES_SENT		0x40
+/* Reserved					0x44 */
+#define MV_MIB_MULTICAST_FRAMES_SENT		0x48
+#define MV_MIB_BROADCAST_FRAMES_SENT		0x4c
+/* Reserved					0x50 */
+#define MV_MIB_FC_SENT				0x54
+#define MV_MIB_FC_RECEIVED			0x58
+#define MV_MIB_RX_FIFO_OVERRUN			0x5c
+#define MV_MIB_UNDERSIZE_RECEIVED		0x60
+#define MV_MIB_FRAGMENTS_RECEIVED		0x64
+#define MV_MIB_OVERSIZE_RECEIVED		0x68
+#define MV_MIB_JABBER_RECEIVED			0x6c
+#define MV_MIB_MAC_RECEIVE_ERROR		0x70
+#define MV_MIB_BAD_CRC_EVENT			0x74
+#define MV_MIB_COLLISION			0x78
+#define MV_MIB_LATE_COLLISION			0x7c
+
+#define COUNTERS_BASE		0x129000
+#define GOP_OFFSET		(((gop) + ((gop) != 0)) * 0x100)
+#define COUNTERS_ADDRESS(cp, gop_p) \
+	(COUNTERS_BASE + MVEBU_REGS_BASE_CP(0, (cp)) + GOP_OFFSET)
+#define PORT_NUM_STR		(sizeof("mvpp2-") - 1)
+#define IS_MVPP2		((memcmp(name, "mvpp2-", PORT_NUM_STR) == 0) &&\
+	(isdigit(name[PORT_NUM_STR])))
+
+u64 mv_gop110_mib_read64(u64 counters_address, unsigned int offset)
+{
+	u64 val, val2;
+
+	val = readl(counters_address + offset);
+	if (offset == MV_MIB_GOOD_OCTETS_RECEIVED_LOW ||
+	    offset == MV_MIB_GOOD_OCTETS_SENT_LOW) {
+		val2 = readl(counters_address + offset + 4);
+		val += (val2 << 32);
+	}
+
+	return val;
+}
+
+static void mv_gop110_mib_print(u64 counters_address, u32 offset,
+				char *mib_name)
+{
+	u64 val;
+
+	val = mv_gop110_mib_read64(counters_address, offset);
+	printf("  %-32s: 0x%02x = %lld\n", mib_name, offset, val);
+}
+
+void mv_print_counter_regs(char *port_name, u64 addr)
+{
+	printf("%s MiB Counters:\n", port_name);
+	printf("\n[Rx]\n");
+	mv_gop110_mib_print(addr, MV_MIB_GOOD_OCTETS_RECEIVED_LOW,
+			    "GOOD_OCTETS_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_BAD_OCTETS_RECEIVED,
+			    "BAD_OCTETS_RECEIVED");
+
+	mv_gop110_mib_print(addr, MV_MIB_UNICAST_FRAMES_RECEIVED,
+			    "UNCAST_FRAMES_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_BROADCAST_FRAMES_RECEIVED,
+			    "BROADCAST_FRAMES_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_MULTICAST_FRAMES_RECEIVED,
+			    "MULTICAST_FRAMES_RECEIVED");
+
+	printf("\n[RMON]\n");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_64_OCTETS,
+			    "FRAMES_64_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_65_TO_127_OCTETS,
+			    "FRAMES_65_TO_127_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_128_TO_255_OCTETS,
+			    "FRAMES_128_TO_255_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_256_TO_511_OCTETS,
+			    "FRAMES_256_TO_511_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_512_TO_1023_OCTETS,
+			    "FRAMES_512_TO_1023_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_1024_TO_MAX_OCTETS,
+			    "FRAMES_1024_TO_MAX_OCTETS");
+
+	printf("\n[Tx]\n");
+	mv_gop110_mib_print(addr, MV_MIB_GOOD_OCTETS_SENT_LOW,
+			    "GOOD_OCTETS_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_UNICAST_FRAMES_SENT,
+			    "UNICAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_MULTICAST_FRAMES_SENT,
+			    "MULTICAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_BROADCAST_FRAMES_SENT,
+			    "BROADCAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_CRC_ERRORS_SENT,
+			    "CRC_ERRORS_SENT");
+
+	printf("\n[FC control]\n");
+	mv_gop110_mib_print(addr, MV_MIB_FC_RECEIVED,
+			    "FC_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_FC_SENT,
+			    "FC_SENT");
+
+	printf("\n[Errors]\n");
+	mv_gop110_mib_print(addr, MV_MIB_RX_FIFO_OVERRUN,
+			    "RX_FIFO_OVERRUN");
+	mv_gop110_mib_print(addr, MV_MIB_UNDERSIZE_RECEIVED,
+			    "UNDERSIZE_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_FRAGMENTS_RECEIVED,
+			    "FRAGMENTS_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_OVERSIZE_RECEIVED,
+			    "OVERSIZE_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_JABBER_RECEIVED,
+			    "JABBER_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_MAC_RECEIVE_ERROR,
+			    "MAC_RECEIVE_ERROR");
+	mv_gop110_mib_print(addr, MV_MIB_BAD_CRC_EVENT,
+			    "BAD_CRC_EVENT");
+	mv_gop110_mib_print(addr, MV_MIB_COLLISION,
+			    "COLLISION");
+	/* This counter must be read last. Read it clear all the counters */
+	mv_gop110_mib_print(addr, MV_MIB_LATE_COLLISION,
+			    "LATE_COLLISION");
+}
+
+int mv_do_get_counters_cmd(cmd_tbl_t *cmdtp, int flag,
+			   int argc, char *const argv[])
+{
+	char *name = NULL;
+
+	if (argc == 2)
+		name = argv[1];
+	else
+		name = env_get("ethact");
+	if (name && IS_MVPP2) {
+		u32 num = simple_strtoul(&name[PORT_NUM_STR],
+					 NULL, 0);
+		u32 cp_max;
+		u32 ap_max;
+		u32 cp = num / 3;
+		u32 gop = num % 3;
+
+		soc_get_ap_cp_num(&ap_max, &cp_max);
+		if (cp_max <= cp) {
+			pr_err("Error: Port: %s does not exist\n", name);
+			return 0;
+		}
+		mv_print_counter_regs(name, COUNTERS_ADDRESS(cp, gop));
+	} else {
+		pr_err("Error: Bad port name: %s\n", name);
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	mv_get_counters, 2, 1, mv_do_get_counters_cmd,
+	"Get gop counters",
+	"mv_get_counters <port_name:default=ethact>\n");
diff --git a/cmd/mvebu/pxa3xx_nand_oem.c b/cmd/mvebu/pxa3xx_nand_oem.c
new file mode 100644
index 0000000000..61762d4cc2
--- /dev/null
+++ b/cmd/mvebu/pxa3xx_nand_oem.c
@@ -0,0 +1,587 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <linux/mtd/mtd.h>
+#include <command.h>
+#include <nand.h>
+#include <pxa3xx_nand.h>
+
+#define NDCR_SPARE_EN		(0x1 << 31)
+
+static char nand_oem_help_text[] =
+	"use \"nand_oem prepare m-offs m-size p-offs p-size\" to prepare oem image\n"
+	"use \"nand_oem restore m-offs m-size\" to restore original data\n"
+	"\tm-offs - meta-data partition offset in bytes\n"
+	"\tm-size - meta-data partition size in bytes\n"
+	"\tp-offs - device data partition offset in bytes\n"
+	"\tp-size - device data partition size in bytes\n"
+	"";
+
+	/*
+	 * Consider to add optional parameter to get a type of non-empty/-blank
+	 * block to skip such a block during "prepare" stage.
+	 */
+
+#define AUX_TBL_MAGIC_LEN	8
+struct aux_tbl_header {
+	char magic[AUX_TBL_MAGIC_LEN];
+	loff_t off;
+	loff_t sz;
+	size_t blk_cnt;
+};
+
+enum blank_block_type {
+	NAND_EMPTY_BLOCK,
+	NAND_UBI_BLANK_BLOCK
+};
+
+static int is_block_blank(const uchar *nand_blk, const uchar *blank_blk,
+			  size_t blk_sz, enum blank_block_type type)
+{
+	int rval = 0;
+
+	switch (type) {
+	case NAND_EMPTY_BLOCK:
+		if (!memcmp(nand_blk, blank_blk, blk_sz))
+			rval = 1;
+		break;
+	case NAND_UBI_BLANK_BLOCK:
+		/* add ubi blank block skipping logic here */
+		break;
+	default:
+		printf("found unsupported blank block type\n");
+	}
+
+	return rval;
+}
+
+static int nand_prepare(struct mtd_info *nand, char * const argv[],
+			loff_t meta_off, loff_t meta_sz, size_t bb_pos,
+			loff_t bb_pg_off)
+{
+	struct aux_tbl_header *aux_tbl_hdr_rd, aux_tbl_hdr = {
+		.magic = {'l', 'l', 'e', 'v', 'r', 'a', 'm', '@'},
+		.off = 0,
+		.sz = 0,
+		.blk_cnt = 0
+	};
+	size_t rw_sz;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t aux_tbl_idx = 0;
+	size_t aux_tbl_delta = 0;
+	size_t aux_tbl_pg = 0;
+	loff_t off, part_off = 0;
+	loff_t part_sz = 0;
+	loff_t aux_tbl_off = -1;
+	u_char *aux_tbl, *rw_blk, *r_pg, *e_blk;
+	nand_erase_options_t opts;
+	int ret = 1;
+
+	/* allocate memory for an empty block */
+	e_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the empty block */
+	memset(e_blk, 0xff, blk_sz);
+	/* allocate memory for page handling */
+	r_pg = memalign(ARCH_DMA_MINALIGN, pg_sz);
+	/* allocate memory for block handling */
+	rw_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* allocate memory for oem image meta-data handling */
+	aux_tbl = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the meta-data */
+	memset(aux_tbl, 0xff, blk_sz);
+
+	/* device data partition size in bytes */
+	part_sz = simple_strtoul(argv[5], NULL, 0);
+	if (part_sz >= nand->size || part_sz < blk_sz) {
+		printf("%s: incorrect device data partition size: 0x%llx\n",
+		       __func__, part_sz);
+		goto oem_prepare_fail;
+	}
+	aux_tbl_hdr.sz = part_sz;
+
+	/* device data partition offset in bytes */
+	part_off = simple_strtoul(argv[4], NULL, 0);
+	if (part_off + part_sz >= nand->size) {
+		printf("%s: partition exceeding nand size: 0x%llx\n", __func__,
+		       part_off + part_sz);
+		goto oem_prepare_fail;
+	}
+	if ((u64)part_off % blk_sz) {
+		printf("%s: partition offset should be block-aligned\n",
+		       __func__);
+		goto oem_prepare_fail;
+	}
+	aux_tbl_hdr.off = part_off;
+
+	printf("device data partition offset = %llu bytes\n", part_off);
+	printf("device data partition size = %llu bytes\n", part_sz);
+	printf("device data partition blocks number = %llu blocks\n",
+	       ((u64)part_sz - 1) / blk_sz + 1);
+
+	/*
+	 * Consider to add optional parameter to get a type of non-empty/-blank
+	 * block to skip such a block during "prepare" stage.
+	 */
+
+	/* pass through meta-data partition in nand */
+	for (off = meta_off; off < meta_off + meta_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* read the first page */
+		rw_sz = pg_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, pg_sz, r_pg)) {
+			printf("failed to read page at offset 0x%llx\n", off);
+			goto oem_prepare_fail;
+		}
+
+		/* cast the meta-data header */
+		aux_tbl_hdr_rd = (struct aux_tbl_header *)r_pg;
+
+		/* look for the meta-data signature */
+		if (!strncmp(aux_tbl_hdr_rd->magic, aux_tbl_hdr.magic,
+			     sizeof(aux_tbl_hdr.magic))) {
+			/* found allocated meta-data block */
+			/* check for overlapping partitions */
+			if ((part_off < aux_tbl_hdr_rd->off &&
+			     part_off + part_sz <= aux_tbl_hdr_rd->off) ||
+			    (part_off >= aux_tbl_hdr_rd->off +
+					 aux_tbl_hdr_rd->sz &&
+			     part_off + part_sz > aux_tbl_hdr_rd->off +
+						  aux_tbl_hdr_rd->sz)) {
+				/* no overlapping; continue looking for free
+				 * meta-data block
+				 */
+				continue;
+			} else { /* overlapping */
+				printf("%s: partition overlaps at off 0x%llx\n",
+				       __func__, part_off);
+				goto oem_prepare_fail;
+			}
+		} else { /* found free meta-data block */
+			aux_tbl_off = off;
+			break;
+		} /* free or allocated block? */
+	}  /* partition's passthrough */
+
+	if (aux_tbl_off == -1) {
+		printf("free meta-data block wasn't found\n");
+		goto oem_prepare_fail;
+	}
+
+	/* pass through device data partition in nand */
+	for (off = part_off; off < part_off + part_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* found a good block; read it */
+		rw_sz = blk_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+				       rw_blk)) {
+			printf("failed to read block at offset 0x%llx\n", off);
+			goto oem_prepare_fail;
+		}
+
+		/* skip empty block */
+		if (is_block_blank(rw_blk, e_blk, blk_sz, NAND_EMPTY_BLOCK))
+			continue;
+
+		/* skip ubi blank block */
+		if (is_block_blank(rw_blk, e_blk, blk_sz, NAND_UBI_BLANK_BLOCK))
+			continue;
+
+		/* check two bytes at bbm locations in the bbm page */
+		if (rw_blk[bb_pg_off + bb_pos] != 0xff ||
+		    rw_blk[bb_pg_off + bb_pos + 1] != 0xff) {
+			/* found the bbm to mask in a good block */
+			printf("found falsy bad block marks (0x%x), (0x%x) ",
+			       rw_blk[bb_pg_off + bb_pos],
+			       rw_blk[bb_pg_off + bb_pos + 1]);
+			printf("in block[%llu]\n", ((u64)off / blk_sz));
+
+			/* Save the two bbm bytes in the buffer with the
+			 * meta-data
+			 */
+			aux_tbl_idx = aux_tbl_hdr.blk_cnt  * 2 +
+				      sizeof(aux_tbl_hdr);
+			aux_tbl_pg = (aux_tbl_idx + aux_tbl_delta) / pg_sz;
+			/* calculate delta to skip bbm location in meta-data */
+			if (aux_tbl_idx && !((aux_tbl_idx + aux_tbl_delta) %
+					     (aux_tbl_pg * pg_sz + bb_pos)))
+				aux_tbl_delta += 2;
+			aux_tbl[aux_tbl_idx + aux_tbl_delta] =
+						     rw_blk[bb_pg_off + bb_pos];
+			aux_tbl[aux_tbl_idx + aux_tbl_delta + 1] =
+						 rw_blk[bb_pg_off + bb_pos + 1];
+
+			/* mask the data indicating the bad block mark */
+			rw_blk[bb_pg_off + bb_pos] = 0xff;
+			rw_blk[bb_pg_off + bb_pos + 1] = 0xff;
+
+			/* erase the block to write its modified version */
+			memset(&opts, 0, sizeof(opts));
+			opts.offset = off;
+			opts.length = blk_sz;
+			opts.quiet  = 1;
+			if (nand_erase_opts(nand, &opts)) {
+				printf("failed to erase block at off 0x%llx\n",
+				       off);
+				goto oem_prepare_fail;
+			}
+
+			/* write the modified block to nand */
+			rw_sz = blk_sz;
+			if (nand_write_skip_bad(nand, off, &rw_sz, NULL,
+						blk_sz, rw_blk, 0)) {
+				printf("failed to write block to off 0x%llx\n",
+				       off);
+				goto oem_prepare_fail;
+			}
+		} /* falsy bb mark? */
+
+		/*
+		 * update the meta-data header for the found good
+		 * non-empty/-blank block
+		 */
+		aux_tbl_hdr.blk_cnt++;
+	} /* partition's passthrough */
+
+	/* erase the block to write the meta-data */
+	memset(&opts, 0, sizeof(opts));
+	opts.offset = aux_tbl_off;
+	opts.length = blk_sz;
+	opts.quiet  = 1;
+	if (nand_erase_opts(nand, &opts)) {
+		printf("failed to erase block at offset 0x%llx\n", aux_tbl_off);
+		goto oem_prepare_fail;
+	}
+
+	/* copy the meta-data signature to the buffer */
+	memcpy(aux_tbl, &aux_tbl_hdr, sizeof(aux_tbl_hdr));
+
+	/* write the buffer with the meta-data to nand */
+	rw_sz = blk_sz;
+	if (nand_write_skip_bad(nand, aux_tbl_off, &rw_sz, NULL, blk_sz,
+				aux_tbl, 0)) {
+		printf("failed to write block to offset 0x%llx\n", aux_tbl_off);
+		goto oem_prepare_fail;
+	}
+
+	ret = 0;
+
+oem_prepare_fail:
+	free(e_blk);
+	free(aux_tbl);
+	free(r_pg);
+	free(rw_blk);
+
+	if (ret == 0)
+		printf("\"nand oem\" command completed successfully\n");
+	else
+		printf("\"nand oem\" command failed\n");
+
+	return ret;
+}
+
+static int nand_restore(struct mtd_info *nand, char * const argv[],
+			loff_t meta_off, loff_t meta_sz, size_t bb_pos,
+			loff_t bb_pg_off)
+{
+	struct aux_tbl_header *aux_tbl_hdr_rd, aux_tbl_hdr = {
+		.magic = {'l', 'l', 'e', 'v', 'r', 'a', 'm', '@'},
+		.off = 0,
+		.sz = 0,
+		.blk_cnt = 0
+	};
+	size_t rw_sz;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t gd_blk_cnt = 0;
+	size_t aux_tbl_idx = 0;
+	size_t aux_tbl_delta = 0;
+	size_t aux_tbl_pg = 0;
+	loff_t off, aux_tbl_off = -1;
+	u_char *aux_tbl, *rw_blk, *r_pg;
+	nand_erase_options_t opts;
+	int ret = 1;
+
+	/* allocate memory for page handling */
+	r_pg = memalign(ARCH_DMA_MINALIGN, pg_sz);
+	/* allocate memory for block handling */
+	rw_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* allocate memory for oem image meta-data handling */
+	aux_tbl = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the meta-data */
+	memset(aux_tbl, 0xff, blk_sz);
+
+	/* pass through meta-data partition in nand */
+	for (off = meta_off; off < meta_off + meta_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+		/* read the first page */
+		rw_sz = pg_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, pg_sz, r_pg)) {
+			printf("failed to read page at offset 0x%llx\n", off);
+			goto oem_restore_fail;
+		}
+
+		/* cast the meta-data header */
+		aux_tbl_hdr_rd = (struct aux_tbl_header *)r_pg;
+
+		/* look for the meta-data signature */
+		if (!strncmp(aux_tbl_hdr_rd->magic, aux_tbl_hdr.magic,
+			     sizeof(aux_tbl_hdr.magic))) {
+			aux_tbl_off = off;
+			break;
+		}
+		/* continue looking for allocated meta-data block */
+	}  /* partition's passthrough */
+
+	if (aux_tbl_off == -1) {
+		printf("allocated meta-data block wasn't found\n");
+		goto oem_restore_fail;
+	}
+
+	/* the meta-data block is found; read it */
+	rw_sz = blk_sz;
+	if (nand_read_skip_bad(nand, aux_tbl_off, &rw_sz, NULL, blk_sz,
+			       rw_blk)) {
+		printf("failed to read block at offset 0x%llx\n", off);
+		goto oem_restore_fail;
+	}
+
+	/* copy the meta-data to the buffer */
+	memcpy(aux_tbl, rw_blk, blk_sz);
+
+	/* cast the meta-data header */
+	aux_tbl_hdr_rd = (struct aux_tbl_header *)aux_tbl;
+
+	/* pass through device data partition in nand */
+	for (off = aux_tbl_hdr_rd->off;
+	     off < aux_tbl_hdr_rd->off + aux_tbl_hdr_rd->sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* check if restore is completed */
+		if (gd_blk_cnt >= aux_tbl_hdr_rd->blk_cnt) {
+			printf("scanned %zu partition blocks",
+			       aux_tbl_hdr_rd->blk_cnt);
+			break;
+		}
+		/* a good block is found; check if to restore */
+		aux_tbl_idx = gd_blk_cnt * 2 + sizeof(struct aux_tbl_header);
+		aux_tbl_pg = (aux_tbl_idx + aux_tbl_delta) / pg_sz;
+		/* calculate delta to skip bbm location in meta-data */
+		if (aux_tbl_idx && !((aux_tbl_idx + aux_tbl_delta) %
+				     (aux_tbl_pg * pg_sz + bb_pos)))
+			aux_tbl_delta += 2;
+		if (aux_tbl[aux_tbl_idx + aux_tbl_delta] != 0xff ||
+		    aux_tbl[aux_tbl_idx + aux_tbl_delta + 1] != 0xff) {
+			/* read the entire block to be restored */
+			rw_sz = blk_sz;
+			if (nand_read_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+					       rw_blk)) {
+				printf("failed to read block at off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+
+			/* simple check prior to restore */
+			if (rw_blk[bb_pg_off + bb_pos] != 0xff ||
+			    rw_blk[bb_pg_off + bb_pos + 1] != 0xff) {
+				printf("bb marks: expected 0xff, 0xff, ");
+				printf("got 0x%x, 0x%x at offset 0x%llx\n",
+				       rw_blk[bb_pg_off + bb_pos],
+				       rw_blk[bb_pg_off + bb_pos + 1],
+				       off + bb_pg_off + bb_pos);
+				goto oem_restore_fail;
+			}
+
+			/* restore the original data at the bbm position */
+			rw_blk[bb_pg_off + bb_pos] =
+					   aux_tbl[aux_tbl_idx + aux_tbl_delta];
+			rw_blk[bb_pg_off + bb_pos + 1] =
+				       aux_tbl[aux_tbl_idx + 1 + aux_tbl_delta];
+
+			printf("restored data %x at pos %llu in block[%llu]\n",
+			       rw_blk[bb_pg_off + bb_pos],
+			       bb_pg_off + bb_pos,
+			       ((u64)off / blk_sz));
+			printf("restored data %x at pos %llu in block[%llu]\n",
+			       rw_blk[bb_pg_off + bb_pos + 1],
+			       bb_pg_off + bb_pos + 1,
+			       ((u64)off / blk_sz));
+
+			/* erase the block to write its original version */
+			memset(&opts, 0, sizeof(opts));
+			opts.offset = off;
+			opts.length = blk_sz;
+			opts.quiet  = 1;
+			if (nand_erase_opts(nand, &opts)) {
+				printf("failed to erase block at off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+
+			/* write the restored block to nand */
+			rw_sz = blk_sz;
+			if (nand_write_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+						rw_blk, 0)) {
+				printf("failed to write block to off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+		} /* to restore? */
+		gd_blk_cnt++;
+	} /* partition's passthrough */
+
+	/* erase the block with the meta-data */
+	memset(&opts, 0, sizeof(opts));
+	opts.offset = aux_tbl_off;
+	opts.length = blk_sz;
+	opts.quiet  = 1;
+	if (nand_erase_opts(nand, &opts)) {
+		printf("failed to erase block at offset 0x%llx\n", aux_tbl_off);
+		goto oem_restore_fail;
+	}
+
+	ret = 0;
+
+oem_restore_fail:
+	free(aux_tbl);
+	free(r_pg);
+	free(rw_blk);
+
+	if (ret == 0)
+		printf("\"nand oem\" command completed successfully\n");
+	else
+		printf("\"nand oem\" command failed\n");
+
+	return ret;
+}
+
+static int do_nand_oem(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	int dev = nand_curr_device;
+	struct mtd_info *nand = get_nand_dev_by_index(dev);
+	char *cmd = argv[1];
+	struct nand_chip *chip = mtd_to_nand(nand);
+	struct pxa3xx_nand_host *host = nand_get_controller_data(chip);
+	struct pxa3xx_nand_info *info = host->info_data;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t bb_pos;
+	loff_t bb_pg_off, meta_off, meta_sz;
+	unsigned int spare_size = 0;
+
+	/*
+	 * Since the pxa nfc uses different page layout (logical layout) than
+	 * chip has (physical layout), the bad block marker logical offset is
+	 * different than physical one and need to be calculated. It is
+	 * different when spare area (NDCR_SPARE_EN) is enabled.
+	 */
+	if (info->reg_ndcr & (NDCR_SPARE_EN))
+		spare_size = info->spare_size;
+
+	bb_pos = pg_sz - ((pg_sz / info->chunk_size - 1) * (30 + spare_size));
+
+	/*
+	 * Bad block marking page can be placed on first, second or last
+	 * page, depending on the manufacturer. Calculate the offset
+	 * based on proper flag set by generic nand_decode_bbm_options.
+	 *
+	 * It seems that for some nand chip id. u-boot may have
+	 * incorrect information since different patterns are used by
+	 * one vendor.  E.g. in Toshiba chips it can be stored in first,
+	 * second or last (0x98DE948276560420 it is "first or last"),
+	 * while currently u-boot never set NAND_BBT_SCANLASTPAGE flag
+	 * for THOSIBA maf_id. More info can be found in:
+	 * http://www.linux-mtd.infradead.org/nand-data/nanddata.html
+	 *
+	 * In case of any problems the chip->badblockpos should be
+	 * fixed. Other solution is to align with new Linux framework
+	 * which registers nand_manufacturer_ops for each manufacturer,
+	 * where bbt_options (_SCANLASTPAGE, _SCAN2NDPAGE) is determined
+	 * in per chip .init
+	 */
+	if (chip->bbt_options & NAND_BBT_SCANLASTPAGE)
+		bb_pg_off = blk_sz - pg_sz;
+	else if (chip->options & NAND_BBT_SCAN2NDPAGE)
+		bb_pg_off = 2 * pg_sz;
+	else /* first page */
+		bb_pg_off = 0;
+
+	if (!bb_pos) {
+		printf("bbm location can't be zero\n");
+		return 1;
+	}
+
+	if (!pg_sz) {
+		printf("page size can't be zero\n");
+		return 1;
+	}
+
+	if (!blk_sz) {
+		printf("block size can't be zero\n");
+		return 1;
+	}
+
+	/* meta-data partition size in bytes */
+	meta_sz = simple_strtoul(argv[3], NULL, 0);
+	if (meta_sz >= nand->size || meta_sz < blk_sz) {
+		printf("found incorrect meta-data partition size: 0x%llx\n",
+		       meta_sz);
+		return 1;
+	}
+
+	/* meta-data partition offset in bytes */
+	meta_off = simple_strtoul(argv[2], NULL, 0);
+	if (meta_off + meta_sz >= nand->size) {
+		printf("meta-data partition exceeding nand size: 0x%llx\n",
+		       meta_off + meta_sz);
+		return 1;
+	}
+	if ((u64)meta_off % blk_sz) {
+		printf("meta-data partition offset should be block-aligned\n");
+		return 0;
+	}
+
+	printf("meta-data partition offset = %llu bytes\n", meta_off);
+	printf("meta-data partition size = %llu bytes\n", meta_sz);
+	printf("meta-data partition blocks number = %llu blocks\n",
+	       ((u64)meta_sz - 1) / blk_sz + 1);
+
+	/* read suffix of "oem" command */
+	if (!strncmp(cmd, "prepare", 7)) {  /* prepare oem image */
+		if (argc < 6) {
+			printf("%s", nand_oem_help_text);
+			return 1;
+		}
+		nand_prepare(nand, argv, meta_off, meta_sz, bb_pos, bb_pg_off);
+	} else if (!strncmp(cmd, "restore", 7)) { /* restore original data */
+		if (argc < 4) {
+			printf("%s", nand_oem_help_text);
+			return 1;
+		}
+		nand_restore(nand, argv, meta_off, meta_sz, bb_pos, bb_pg_off);
+	} else { /* nand oem cmd provided with incorrect or without suffix */
+		printf("%s", nand_oem_help_text);
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(nand_oem, 6, 0, do_nand_oem,
+	   "NAND oem cmd", nand_oem_help_text);
diff --git a/cmd/mvebu/rx_training.c b/cmd/mvebu/rx_training.c
new file mode 100644
index 0000000000..90136a8f5a
--- /dev/null
+++ b/cmd/mvebu/rx_training.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <dm/device-internal.h>
+#include <mvebu/comphy.h>
+
+int rx_training_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret, cp_index, comphy_index, i = 0;
+
+	if (argc != 3) {
+		printf("missing arguments\n");
+		return -1;
+	}
+
+	cp_index = simple_strtoul(argv[1], NULL, 16);
+	comphy_index = simple_strtoul(argv[2], NULL, 16);
+
+	ret = uclass_get(UCLASS_MISC, &uc);
+	if (ret) {
+		printf("Couldn't find UCLASS_MISC\n");
+		return ret;
+	}
+
+	uclass_foreach_dev(dev, uc) {
+		if (!(memcmp(dev->name, "comphy", 5))) {
+			if (i == cp_index) {
+				comphy_rx_training(dev, comphy_index);
+				return 0;
+			}
+
+			i++;
+		}
+	}
+
+	printf("Coudn't find comphy %d\n", cp_index);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	rx_training, 3, 0, rx_training_cmd,
+	"rx_training <cp id> <comphy id>\n",
+	"\n\tRun RX training sequence, the user must state CP index (0/1) and comphy ID (0/5)"
+);
diff --git a/cmd/mvebu/sar.c b/cmd/mvebu/sar.c
new file mode 100644
index 0000000000..d7707fc2e6
--- /dev/null
+++ b/cmd/mvebu/sar.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <vsprintf.h>
+#include <errno.h>
+#include <i2c.h>
+#include <mvebu/sar.h>
+
+static int sar_initialized;
+
+int do_sar_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	const char *cmd = argv[1];
+	const char *key = NULL;
+	int value = 0;
+
+	/* initialize sar driver variables from the device tree */
+	if (!sar_initialized) {
+		sar_init();
+		sar_initialized = 1;
+	}
+
+	if (sar_is_available() == 0) {
+		printf("Error: SAR variables not available for this board\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "read") == 0) && (argc < 2)) {
+		printf("Error: Please specify SAR key\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "write") == 0) && (argc < 4)) {
+		printf("Error: Please specify SAR key and value\n");
+		return 1;
+	}
+
+	if (argc > 2)
+		key = argv[2];
+	if (argc > 3)
+		value = (int)simple_strtoul(argv[3], NULL, 16);
+
+	if (strcmp(cmd, "list") == 0) {
+		if (argc < 3) {
+			sar_list_keys();
+		} else {
+			if (sar_list_key_opts(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "default") == 0) {
+		if (argc < 3) {
+			sar_default_all();
+		} else {
+			if (sar_default_key(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "read") == 0) {
+		if (!key)
+			sar_read_all();
+		else
+			if (sar_print_key(key))
+				return -EINVAL;
+	} else if (strcmp(cmd, "write") == 0) {
+		if (sar_write_key(key, value))
+			return -EINVAL;
+	} else {
+		printf("ERROR: unknown command to sar: \"%s\"\n", cmd);
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	sar,      6,     1,      do_sar_cmd,
+	"sar - Modify SOC's sample at reset (SAR) values",
+	"\n"
+	"Modify SOC's sample at reset values\n"
+	"\tlist		- Display all available SAR variables\n"
+	"\tlist <x>	- Display options for SAR variable x\n"
+	"\tdefault	- Set all SAR variable to default value\n"
+	"\tdefault <x>	- Set SAR variable x default value\n"
+	"\twrite x y	- Write y to SAR variable x\n"
+	"\tread		- Read all SAR variables\n"
+	"\tread <x>	- Read SAR variable x\n"
+);
+
+U_BOOT_CMD(
+	SatR,      6,     1,      do_sar_cmd,
+	"SatR - Modify SOC's sample at reset (SAR) values",
+	"\n"
+	"Modify SOC's sample at reset values\n"
+	"\tlist		- Display all available SAR variables\n"
+	"\tlist <x>	- Display options for SAR variable x\n"
+	"\tdefault	- Set all SAR variable to default value\n"
+	"\tdefault <x>	- Set SAR variable x default value\n"
+	"\twrite x y	- Write y to SAR variable x\n"
+	"\tread		- Read all SAR variables\n"
+	"\tread <x>	- Read SAR variable x\n"
+);
diff --git a/cmd/mvebu/thermal.c b/cmd/mvebu/thermal.c
new file mode 100644
index 0000000000..f2d38da3de
--- /dev/null
+++ b/cmd/mvebu/thermal.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <dm.h>
+#include <asm/arch-mvebu/thermal.h>
+#include <fdtdec.h>
+#include <thermal.h>
+#include <dm/device-internal.h>
+
+int thermal_sensor_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret, temperature;
+
+	ret = uclass_get(UCLASS_THERMAL, &uc);
+
+	if (ret)
+		return ret;
+
+	uclass_foreach_dev(dev, uc) {
+		struct thermal_unit_config *thermal_cfg;
+
+		ret = device_probe(dev);
+		if (ret)
+			continue;
+
+		thermal_cfg = dev_get_priv(dev);
+		thermal_get_temp(dev, &temperature);
+		printf("Thermal.%8p = %d\n", thermal_cfg->regs_base,
+		       temperature);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	tsen, 1, 1, thermal_sensor_cmd,
+	"tsen - Display the SoC temperature.\n",
+	"\n\tDisplay the SoC temperature as read from the on chip thermal sensor.\n"
+);
diff --git a/common/board_f.c b/common/board_f.c
index 591f18f391..cbc78aed27 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -900,6 +900,7 @@ static const init_fnc_t init_sequence_f[] = {
 #if defined(CONFIG_PPC) || defined(CONFIG_SH) || defined(CONFIG_X86)
 	checkcpu,
 #endif
+
 #if defined(CONFIG_SYSRESET)
 	print_resetinfo,
 #endif
@@ -911,6 +912,9 @@ static const init_fnc_t init_sequence_f[] = {
 #endif
 #if defined(CONFIG_DISPLAY_BOARDINFO)
 	show_board_info,
+#endif
+#if defined(CONFIG_DISPLAY_BOARDINFO) && defined(CONFIG_ARCH_MVEBU)
+	print_cpuinfo,		/* display cpu info (and speed) */
 #endif
 	INIT_FUNC_WATCHDOG_INIT
 #if defined(CONFIG_MISC_INIT_F)
diff --git a/common/board_r.c b/common/board_r.c
index d6fb5047a2..ce8b12c071 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -579,6 +579,14 @@ static int initr_net(void)
 }
 #endif
 
+#ifdef CONFIG_MV88E6XXX_SWITCH
+static int initr_mv88e6xxx(void)
+{
+	mv88e6xxx_initialize(gd->fdt_blob);
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_POST
 static int initr_post(void)
 {
@@ -812,6 +820,11 @@ static init_fnc_t init_sequence_r[] = {
 	INIT_FUNC_WATCHDOG_RESET
 	initr_net,
 #endif
+
+#ifdef CONFIG_MV88E6XXX_SWITCH
+	initr_mv88e6xxx,
+#endif
+
 #ifdef CONFIG_POST
 	initr_post,
 #endif
diff --git a/common/fdt_support.c b/common/fdt_support.c
index baf7924ff6..f9e31bd517 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -955,7 +955,9 @@ void fdt_del_node_and_alias(void *blob, const char *alias)
 
 /* Max address size we deal with */
 #define OF_MAX_ADDR_CELLS	4
+#ifndef OF_BAD_ADDR
 #define OF_BAD_ADDR	FDT_ADDR_T_NONE
+#endif
 #define OF_CHECK_COUNTS(na, ns)	((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && \
 			(ns) > 0)
 
diff --git a/common/usb_hub.c b/common/usb_hub.c
index 25c2ac4345..befcb75f1f 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -41,7 +41,7 @@
 
 #define USB_BUFSIZ	512
 
-#define HUB_SHORT_RESET_TIME	20
+#define HUB_SHORT_RESET_TIME	100
 #define HUB_LONG_RESET_TIME	200
 
 #define PORT_OVERCURRENT_MAX_SCAN_COUNT		3
@@ -208,6 +208,7 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	debug("devnum=%d poweron: query_delay=%d connect_timeout=%d\n",
 	      dev->devnum, max(100, (int)pgood_delay),
 	      max(100, (int)pgood_delay) + 1000);
+	mdelay(pgood_delay + 2000);
 }
 
 #if !CONFIG_IS_ENABLED(DM_USB)
diff --git a/configs/clearfog_defconfig b/configs/clearfog_defconfig
index ebfe3cf158..9071dd75fe 100644
--- a/configs/clearfog_defconfig
+++ b/configs/clearfog_defconfig
@@ -35,7 +35,6 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 # CONFIG_SPL_PARTITION_UUIDS is not set
diff --git a/configs/db-88f6720_defconfig b/configs/db-88f6720_defconfig
index 78c025596f..afa3cb4861 100644
--- a/configs/db-88f6720_defconfig
+++ b/configs/db-88f6720_defconfig
@@ -24,6 +24,7 @@ CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_SPL_I2C_SUPPORT=y
 CONFIG_SPL_SPI_LOAD=y
 CONFIG_SYS_SPI_U_BOOT_OFFS=0x20000
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_SF=y
diff --git a/configs/db-88f6820-amc_defconfig b/configs/db-88f6820-amc_defconfig
index 3d23c12aec..db05b4edd6 100644
--- a/configs/db-88f6820-amc_defconfig
+++ b/configs/db-88f6820-amc_defconfig
@@ -25,6 +25,7 @@ CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_SPL_I2C_SUPPORT=y
 CONFIG_SPL_SPI_LOAD=y
 CONFIG_SYS_SPI_U_BOOT_OFFS=0x24000
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_PCI=y
diff --git a/configs/db-88f6820-ap_defconfig b/configs/db-88f6820-ap_defconfig
new file mode 100644
index 0000000000..4ba8961b5c
--- /dev/null
+++ b/configs/db-88f6820-ap_defconfig
@@ -0,0 +1,66 @@
+CONFIG_ARM=y
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00800000
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_TARGET_DB_88F6820_AP=y
+CONFIG_MVEBU_SPL_BOOT_DEVICE_NAND=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL=y
+CONFIG_DEBUG_UART_BASE=0xd0012000
+CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_DEBUG_UART=y
+CONFIG_SPL_TEXT_BASE=0x40000030
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_NAND_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SYS_PROMPT="Marvell>> "
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_I2C=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_MVEBU_NAND_BOOT=y
+# CONFIG_SPL_PARTITION_UUIDS is not set
+CONFIG_DEFAULT_DEVICE_TREE="armada-385-ap"
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_SPL_OF_TRANSLATE=y
+# CONFIG_MMC is not set
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVNETA=y
+CONFIG_PCI=y
+CONFIG_PCI_MVEBU=y
+CONFIG_SCSI=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_LAN75XX=y
+CONFIG_USB_ETHER_LAN78XX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
diff --git a/configs/db-88f6820-gp_defconfig b/configs/db-88f6820-gp_defconfig
index 04bfbc4735..5e14940f01 100644
--- a/configs/db-88f6820-gp_defconfig
+++ b/configs/db-88f6820-gp_defconfig
@@ -16,15 +16,19 @@ CONFIG_SPL_SPI_SUPPORT=y
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_SPL_TEXT_BASE=0x40000030
+CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=3
+# CONFIG_USE_BOOTCOMMAND is not set
 CONFIG_USE_PREBOOT=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_DISPLAY_BOARDINFO_LATE=y
+CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION=y
 CONFIG_SPL_I2C_SUPPORT=y
 CONFIG_SPL_SPI_LOAD=y
 CONFIG_SYS_SPI_U_BOOT_OFFS=0x24000
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
@@ -33,18 +37,11 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_DHCP=y
 CONFIG_CMD_TFTPPUT=y
-CONFIG_CMD_MII=y
-CONFIG_CMD_PING=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
-CONFIG_CMD_EXT2=y
-CONFIG_CMD_EXT4=y
-CONFIG_CMD_FAT=y
-CONFIG_CMD_FS_GENERIC=y
-CONFIG_EFI_PARTITION=y
-# CONFIG_PARTITION_UUIDS is not set
+CONFIG_CMD_MVEBU_BUBT=y
+# CONFIG_ISO_PARTITION is not set
 # CONFIG_SPL_PARTITION_UUIDS is not set
 CONFIG_DEFAULT_DEVICE_TREE="armada-388-gp"
 CONFIG_ENV_IS_IN_SPI_FLASH=y
@@ -61,6 +58,7 @@ CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_PHY_MARVELL=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
 CONFIG_MVNETA=y
 CONFIG_MII=y
 CONFIG_PCI=y
@@ -72,4 +70,3 @@ CONFIG_KIRKWOOD_SPI=y
 CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_STORAGE=y
diff --git a/configs/mvebu_comexpress-88f7020_defconfig b/configs/mvebu_comexpress-88f7020_defconfig
new file mode 100644
index 0000000000..52b23f1527
--- /dev/null
+++ b/configs/mvebu_comexpress-88f7020_defconfig
@@ -0,0 +1,97 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_MVEBU_ARMADA_8K=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_NAND_BOOT=y
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_MVEBU_NAND_BOOT=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_DEFAULT_DEVICE_TREE="armada-7020-comexp"
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_crb_cn9130_defconfig b/configs/mvebu_crb_cn9130_defconfig
new file mode 100644
index 0000000000..835f93e442
--- /dev/null
+++ b/configs/mvebu_crb_cn9130_defconfig
@@ -0,0 +1,102 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_OCTEONTX2_CN913x=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MVEBU_MMC_BOOT=y
+CONFIG_MVEBU_BOOT_DEVICE=1
+CONFIG_MVEBU_BOOT_PART=0
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MMC_BROKEN_CD=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_crb_ep_cn9130_defconfig b/configs/mvebu_crb_ep_cn9130_defconfig
new file mode 100644
index 0000000000..9d0726f20f
--- /dev/null
+++ b/configs/mvebu_crb_ep_cn9130_defconfig
@@ -0,0 +1,105 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_OCTEONTX2_CN913x=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_PL011_SERIAL=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MVEBU_MMC_BOOT=y
+CONFIG_MVEBU_BOOT_DEVICE=1
+CONFIG_MVEBU_BOOT_PART=0
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MMC_BROKEN_CD=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_db-88f3720_defconfig b/configs/mvebu_db-88f3720_defconfig
index f6bc97f5ab..2cfe6cd0b7 100644
--- a/configs/mvebu_db-88f3720_defconfig
+++ b/configs/mvebu_db-88f3720_defconfig
@@ -4,20 +4,21 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_MVEBU_ARMADA_37XX=y
-CONFIG_NR_DRAM_BANKS=1
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=25804800
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
 CONFIG_USE_PREBOOT=y
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
@@ -27,40 +28,49 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_EFUSE=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_MAC_PARTITION=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-3720-db"
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_AHCI_MVEBU=y
 CONFIG_CLK=y
 CONFIG_CLK_MVEBU=y
 CONFIG_DM_GPIO=y
 # CONFIG_MVEBU_GPIO is not set
+CONFIG_DM_PCA953X=y
 CONFIG_DM_I2C=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_SDMA=y
 CONFIG_MMC_SDHCI_XENON=y
 CONFIG_SPI_FLASH=y
 CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
-CONFIG_PHYLIB=y
 CONFIG_PHY_MARVELL=y
+CONFIG_DM_MDIO=y
 CONFIG_PHY_GIGE=y
 CONFIG_E1000=y
+CONFIG_MVNETA=y
+CONFIG_MVMDIO=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
 CONFIG_PCI_AARDVARK=y
 CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DEBUG_MVEBU_A3700_UART=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_DEBUG_UART_ANNOUNCE=y
diff --git a/configs/mvebu_db_armada8k_defconfig b/configs/mvebu_db_armada8k_defconfig
index 97077e11a2..d4ca810b89 100644
--- a/configs/mvebu_db_armada8k_defconfig
+++ b/configs/mvebu_db_armada8k_defconfig
@@ -7,49 +7,77 @@ CONFIG_TARGET_MVEBU_ARMADA_8K=y
 CONFIG_NR_DRAM_BANKS=2
 CONFIG_DEBUG_UART_BASE=0xf0512000
 CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
 CONFIG_SMBIOS_PRODUCT_NAME=""
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
 CONFIG_USE_PREBOOT=y
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
 # CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
 CONFIG_CMD_PCI=y
 CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
 CONFIG_MAC_PARTITION=y
 CONFIG_DEFAULT_DEVICE_TREE="armada-8040-db"
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
 CONFIG_DM_I2C=y
 CONFIG_SYS_I2C_MVTWSI=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
 CONFIG_SPI_FLASH=y
 CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_MTD=y
 CONFIG_PHY_MARVELL=y
+CONFIG_DM_MDIO=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
 CONFIG_MVPP2=y
+CONFIG_MVMDIO=y
 CONFIG_NVME=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
@@ -57,10 +85,17 @@ CONFIG_PCIE_DW_MVEBU=y
 CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_DEBUG_UART_ANNOUNCE=y
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
 CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_XHCI_HCD=y
diff --git a/configs/mvebu_db_cn91xx_defconfig b/configs/mvebu_db_cn91xx_defconfig
new file mode 100644
index 0000000000..4cceb9df54
--- /dev/null
+++ b/configs/mvebu_db_cn91xx_defconfig
@@ -0,0 +1,98 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_OCTEONTX2_CN913x=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_db_ep_cn91xx_defconfig b/configs/mvebu_db_ep_cn91xx_defconfig
new file mode 100644
index 0000000000..72756724ab
--- /dev/null
+++ b/configs/mvebu_db_ep_cn91xx_defconfig
@@ -0,0 +1,102 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_OCTEONTX2_CN913x=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_PL011_SERIAL=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_espressobin-88f3720_defconfig b/configs/mvebu_espressobin-88f3720_defconfig
index 9375daf590..60f8dea13f 100644
--- a/configs/mvebu_espressobin-88f3720_defconfig
+++ b/configs/mvebu_espressobin-88f3720_defconfig
@@ -4,20 +4,21 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_MVEBU_ARMADA_37XX=y
-CONFIG_NR_DRAM_BANKS=1
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=25804800
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
 CONFIG_USE_PREBOOT=y
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
@@ -27,13 +28,12 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_EFUSE=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_MAC_PARTITION=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-3720-espressobin"
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_AHCI_MVEBU=y
 CONFIG_CLK=y
@@ -42,25 +42,35 @@ CONFIG_DM_GPIO=y
 CONFIG_DM_I2C=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_SDMA=y
 CONFIG_MMC_SDHCI_XENON=y
 CONFIG_SPI_FLASH=y
 CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_ISSI=y
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_SPI_FLASH_WINBOND=y
-CONFIG_PHYLIB=y
+CONFIG_MV88E6XXX_SWITCH=y
 CONFIG_PHY_MARVELL=y
+CONFIG_DM_MDIO=y
 CONFIG_PHY_GIGE=y
 CONFIG_E1000=y
+CONFIG_MVNETA=y
+CONFIG_MVMDIO=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
 CONFIG_PCI_AARDVARK=y
 CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DEBUG_MVEBU_A3700_UART=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_DEBUG_UART_ANNOUNCE=y
diff --git a/configs/mvebu_mcbin-88f8040_defconfig b/configs/mvebu_mcbin-88f8040_defconfig
index 7ce24b0029..24bb9eb938 100644
--- a/configs/mvebu_mcbin-88f8040_defconfig
+++ b/configs/mvebu_mcbin-88f8040_defconfig
@@ -7,34 +7,40 @@ CONFIG_TARGET_MVEBU_ARMADA_8K=y
 CONFIG_NR_DRAM_BANKS=2
 CONFIG_DEBUG_UART_BASE=0xf0512000
 CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
 CONFIG_USE_PREBOOT=y
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_DISPLAY_BOARDINFO_LATE=y
 CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
 CONFIG_CMD_PCI=y
 CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
 CONFIG_MAC_PARTITION=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-8040-mcbin"
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_AHCI_MVEBU=y
@@ -43,17 +49,26 @@ CONFIG_DM_I2C=y
 CONFIG_SYS_I2C_MVTWSI=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
 CONFIG_SPI_FLASH=y
 CONFIG_SF_DEFAULT_MODE=0
+CONFIG_SF_DEFAULT_SPEED=40000000
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
 CONFIG_PHY_MARVELL=y
+CONFIG_DM_MDIO=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
 CONFIG_MVPP2=y
+CONFIG_MVMDIO=y
 CONFIG_NVME=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
@@ -62,10 +77,15 @@ CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_8K=y
 CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_DEBUG_UART_ANNOUNCE=y
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
 CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_XHCI_HCD=y
diff --git a/configs/mvebu_ocp-88f8040_defconfig b/configs/mvebu_ocp-88f8040_defconfig
new file mode 100644
index 0000000000..f991b6e9ee
--- /dev/null
+++ b/configs/mvebu_ocp-88f8040_defconfig
@@ -0,0 +1,93 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x0
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_MVEBU_ARMADA_8K=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_PL011_SERIAL=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_DEFAULT_DEVICE_TREE="armada-8040-ocp"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_MARVELL=y
+CONFIG_MVPP2=y
+CONFIG_DM_PCI=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_ucpe-88f8040_defconfig b/configs/mvebu_ucpe-88f8040_defconfig
new file mode 100644
index 0000000000..806cd4f7f4
--- /dev/null
+++ b/configs/mvebu_ucpe-88f8040_defconfig
@@ -0,0 +1,86 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_MVEBU_ARMADA_8K=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MTD=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_UBI=y
+CONFIG_MAC_PARTITION=y
+CONFIG_DEFAULT_DEVICE_TREE="armada-8040-ucpe"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DEVRES=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MTD=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_MV88E6XXX_SWITCH=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_RTC=y
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/octeontx2_95mm_defconfig b/configs/octeontx2_95mm_defconfig
new file mode 100644
index 0000000000..545f05b18c
--- /dev/null
+++ b/configs/octeontx2_95mm_defconfig
@@ -0,0 +1,108 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX2_95MM=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=6 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_FAILSAFE=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=125000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=125000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_DM_ETH=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
diff --git a/configs/octeontx2_95xx_defconfig b/configs/octeontx2_95xx_defconfig
new file mode 100644
index 0000000000..c3c5056fa4
--- /dev/null
+++ b/configs/octeontx2_95xx_defconfig
@@ -0,0 +1,109 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX2_95XX=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=6 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_FAILSAFE=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=125000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=125000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_DM_ETH=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
diff --git a/configs/octeontx2_96xx_defconfig b/configs/octeontx2_96xx_defconfig
new file mode 100644
index 0000000000..3a3613e2e1
--- /dev/null
+++ b/configs/octeontx2_96xx_defconfig
@@ -0,0 +1,140 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX2_96XX=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=24 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_FAILSAFE=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_ATTEST=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=125000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=125000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_NVME=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE=y
diff --git a/configs/octeontx2_98xx_defconfig b/configs/octeontx2_98xx_defconfig
new file mode 100644
index 0000000000..eeac2b1efc
--- /dev/null
+++ b/configs/octeontx2_98xx_defconfig
@@ -0,0 +1,133 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX2_98XX=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=36 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=125000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=125000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_NVME=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
diff --git a/configs/octeontx2_loki_defconfig b/configs/octeontx2_loki_defconfig
new file mode 100644
index 0000000000..4b58a89803
--- /dev/null
+++ b/configs/octeontx2_loki_defconfig
@@ -0,0 +1,112 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX2_LOKI=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=6 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_FAILSAFE=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=125000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=125000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_NVME=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
diff --git a/configs/octeontx_81xx_defconfig b/configs/octeontx_81xx_defconfig
new file mode 100644
index 0000000000..4505fe17b1
--- /dev/null
+++ b/configs/octeontx_81xx_defconfig
@@ -0,0 +1,136 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX=y
+CONFIG_SYS_TEXT_BASE=0x2800000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX_81XX=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=4 rootwait rw root=/dev/sda2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=16000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_OCTEONTX=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=16000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHYLIB_10G=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_BROADCOM=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_MICREL=y
+CONFIG_PHY_REALTEK=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX=y
+CONFIG_OCTEONTX_SMI=y
+CONFIG_NVME=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
diff --git a/configs/octeontx_83xx_defconfig b/configs/octeontx_83xx_defconfig
new file mode 100644
index 0000000000..c412ce1d15
--- /dev/null
+++ b/configs/octeontx_83xx_defconfig
@@ -0,0 +1,137 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX=y
+CONFIG_SYS_TEXT_BASE=0x2800000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_OCTEONTX_83XX=y
+CONFIG_NR_DRAM_BANKS=1
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=24 rootwait rw root=/dev/sda2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SF_TEST=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_USE_ENV_SPI_BUS=y
+CONFIG_ENV_SPI_BUS=0
+CONFIG_USE_ENV_SPI_CS=y
+CONFIG_ENV_SPI_CS=0
+CONFIG_USE_ENV_SPI_MAX_HZ=y
+CONFIG_ENV_SPI_MAX_HZ=16000000
+CONFIG_USE_ENV_SPI_MODE=y
+CONFIG_ENV_SPI_MODE=0x0
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_OCTEONTX=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x0
+CONFIG_SF_DEFAULT_SPEED=16000000
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHYLIB_10G=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_BROADCOM=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_MICREL=y
+CONFIG_PHY_REALTEK=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX=y
+CONFIG_OCTEONTX_SMI=y
+CONFIG_NVME=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_REGION_MULTI_ENTRY=y
+CONFIG_PCI_OCTEONTX=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_WDT=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE=y
diff --git a/configs/thunderx_88xx_defconfig b/configs/thunderx_88xx_defconfig
deleted file mode 100644
index 5065845475..0000000000
--- a/configs/thunderx_88xx_defconfig
+++ /dev/null
@@ -1,29 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_THUNDERX_88XX=y
-CONFIG_SYS_TEXT_BASE=0x00500000
-CONFIG_NR_DRAM_BANKS=1
-CONFIG_DEBUG_UART_BASE=0x87e024000000
-CONFIG_DEBUG_UART_CLOCK=24000000
-CONFIG_IDENT_STRING=" for Cavium Thunder CN88XX ARM v8 Multi-Core"
-CONFIG_DEBUG_UART=y
-CONFIG_BOOTDELAY=5
-CONFIG_USE_BOOTARGS=y
-CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e024000000 debug maxcpus=48 rootwait rw root=/dev/sda2 coherent_pool=16M"
-# CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
-CONFIG_HUSH_PARSER=y
-# CONFIG_AUTO_COMPLETE is not set
-CONFIG_SYS_PROMPT="ThunderX_88XX> "
-# CONFIG_CMD_EXPORTENV is not set
-# CONFIG_CMD_IMPORTENV is not set
-# CONFIG_CMD_EDITENV is not set
-# CONFIG_CMD_SAVEENV is not set
-# CONFIG_CMD_ENV_EXISTS is not set
-# CONFIG_CMD_FLASH is not set
-# CONFIG_CMD_NET is not set
-CONFIG_DEFAULT_DEVICE_TREE="thunderx-88xx"
-CONFIG_DM=y
-# CONFIG_MMC is not set
-CONFIG_DM_SERIAL=y
-CONFIG_DEBUG_UART_PL011=y
-CONFIG_DEBUG_UART_SKIP_INIT=y
diff --git a/doc/device-tree-bindings/mmc/xenon-mmc.txt b/doc/device-tree-bindings/mmc/xenon-mmc.txt
new file mode 100644
index 0000000000..a5559b37b8
--- /dev/null
+++ b/doc/device-tree-bindings/mmc/xenon-mmc.txt
@@ -0,0 +1,46 @@
+* Marvell Xenon MMC controller
+This file documents the properties used by the sdhci-xenon drivers.
+
+Required properties:
+- compatible: Should be "marvell,armada-3700-sdhci".
+- reg: Base register offset for the SDHCI registers and pad control registers.
+- status: Enable or disable this node
+
+Optional properties:
+- bus-width: Number of data lines, can be <1>, <4>, or <8>.  The default
+  will be <1> if the property is absent.
+- vqmmc-supply: The signal voltage supplier for SDIO if needed. For example,
+  on port0 it needs a gpio regulator to supply signal voltage.
+- marvell,pad-type: The property indicates the pad tye for sdio port, for example,
+  the port1 is emmc and the pad type is fixed with voltage of 1.8V.
+
+Example:
+sdhci0: sdhci@d0000 {
+       compatible = "marvell,armada-3700-sdhci",
+       reg = <0xd0000 0x300
+              0x1e808 0x4>;
+       bus-width = <4>;
+       vqmmc-supply = <&vcc_sd_reg0>;
+       status = "disabled";
+};
+
+sdhci1: sdhci@d8000 {
+       compatible = "marvell,armada-3700-sdhci",
+       reg = <0xd8000 0x300
+              0x17808 0x4>;
+       bus-width = <8>;
+       marvell,pad-type = "fixed-1-8v";
+       status = "disabled";
+};
+
+The vqmmc-supply example on sdio port0:
+vcc_sd_reg0: regulator@0 {
+       compatible = "regulator-gpio";
+       regulator-name = "vcc_sd0";
+       regulator-min-microvolt = <1800000>;
+       regulator-max-microvolt = <3300000>;
+       regulator-type = "voltage";
+       states = <1800000 0x1
+                 3300000 0x0>;
+       gpios = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+};
diff --git a/doc/device-tree-bindings/net/ethernet.txt b/doc/device-tree-bindings/net/ethernet.txt
index 3fc360523b..ecea8f2f9f 100644
--- a/doc/device-tree-bindings/net/ethernet.txt
+++ b/doc/device-tree-bindings/net/ethernet.txt
@@ -11,8 +11,8 @@ The following properties are common to the Ethernet controllers:
   the maximum frame size (there's contradiction in ePAPR).
 - phy-mode: string, operation mode of the PHY interface; supported values are
   "mii", "gmii", "sgmii", "qsgmii", "tbi", "rev-mii", "rmii", "rgmii", "rgmii-id",
-  "rgmii-rxid", "rgmii-txid", "rtbi", "smii", "xgmii"; this is now a de-facto
-  standard property;
+  "rgmii-rxid", "rgmii-txid", "rtbi", "smii", "xgmii", "sfi", "ap"; this is now
+  a de-facto standard property;
 - phy-connection-type: the same as "phy-mode" property but described in ePAPR;
 - phy-handle: phandle, specifies a reference to a node representing a PHY
   device; this property is described in ePAPR and so preferred;
diff --git a/doc/device-tree-bindings/phy/mvebu_comphy.txt b/doc/device-tree-bindings/phy/mvebu_comphy.txt
new file mode 100644
index 0000000000..65b8384859
--- /dev/null
+++ b/doc/device-tree-bindings/phy/mvebu_comphy.txt
@@ -0,0 +1,68 @@
+Marvell COMPHY SerDes lane bindings
+=====================================
+
+The COMPHY node includes a description of the COMPHY SerDes lane configuration.
+The COMPHY driver initializes the MUX of the SerDes lanes, and powers up the SerDes
+by dependencies on the FDT blob configurations
+
+Mandatory properties:
+SoC specific:
+	- compatible:
+		The compatible should include "marvell,mvebu-comphy"
+		and the COMPHY per chip compatible:
+		"marvell,comphy-cp110" for CP110 available in Aramda70x0/80x0.
+		The COMPHY per chip used to set which MUX configuration to use, and COMPHY power-up revision.
+	- reg: Base address and size of the COMPHY and hpipe units.
+	- max-lanes: Maximum number of comphy lanes.
+	- mux-bitcount: Number of bits that are allocated for every MUX in the COMPHY-selector register.
+Board specific:
+	- PHY: Entry that include the configuration of the PHY.
+	  Every PHY should have the below parameters:
+	  - phy-type: the mode of the PHY
+	    Possible modes located in include/dt-bindings/comphy/comphy_data.h
+	Optional properties:
+	  - phy-speed: the speed of the PHY
+	    Possible speeds values located in include/dt-bindings/comphy/comphy_data.h
+	  - phy-invert: Polarity invert (COMPHY_POLARITY_TXD_INVERT/COMPHY_POLARITY_RXD_INVERT)
+	    the possible bits under include/dt-bindings/comphy/comphy_data.h
+	  - clk-src: Set the clock source of PCIe, if configured to PCIe clock output
+	    This relevant for SerDes lane 5 only (by default, lane 4 is the clock source)
+	    for Armada-7040 boards.
+	  - endpoint: Optional boolean specifying this SerDes should be configured as PCIe endpoint.
+
+Example:
+	cpm_comphy: comphy@441000 {
+		compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
+		reg = <0x441000 0x8>, <0x120000 0x8>;
+		mux-bitcount = <4>;
+		max-lanes = <6>;
+
+		/*
+		 * CP110 Serdes Configuration:
+		 * Lane 0: SGMII1
+		 * Lane 1: SATA 0
+		 * Lane 2: USB HOST 0
+		 * Lane 3: SATA1
+		 * Lane 4: SFI (10G)
+		 * Lane 5: SGMII2
+		 */
+		phy0 {
+			phy-type = <COMPHY_TYPE_SGMII1>;
+			phy-speed = <COMPHY_SPEED_1_25G>;
+		};
+		phy1 {
+			phy-type = <COMPHY_TYPE_SATA0>;
+		};
+		phy2 {
+			phy-type = <COMPHY_TYPE_USB3_HOST0>;
+		};
+		phy3 {
+			phy-type = <COMPHY_TYPE_SATA1>;
+		};
+		phy4 {
+			phy-type = <COMPHY_TYPE_SFI>;
+		};
+		phy5 {
+			phy-type = <COMPHY_TYPE_SGMII2>;
+		};
+	};
diff --git a/doc/device-tree-bindings/regulator/regulator.txt b/doc/device-tree-bindings/regulator/regulator.txt
index 4ba642b7c7..e87e417fa9 100644
--- a/doc/device-tree-bindings/regulator/regulator.txt
+++ b/doc/device-tree-bindings/regulator/regulator.txt
@@ -36,6 +36,7 @@ Optional properties:
 - regulator-always-on: regulator should never be disabled
 - regulator-boot-on: enabled by bootloader/firmware
 - regulator-ramp-delay: ramp delay for regulator (in uV/us)
+- regulator-force-boot-off: disabled during the boot stage
 
 Note
 The "regulator-name" constraint is used for setting the device's uclass
diff --git a/doc/device-tree-bindings/rtc/marvell-rtc.txt b/doc/device-tree-bindings/rtc/marvell-rtc.txt
new file mode 100644
index 0000000000..cdc0d57cd0
--- /dev/null
+++ b/doc/device-tree-bindings/rtc/marvell-rtc.txt
@@ -0,0 +1,23 @@
+* Real Time Clock of the Armada 7K/8K/3900 SoCs
+
+RTC controller for the Armada 7K/8K/3900 SoCs
+
+Required properties:
+- compatible : Should be one of the following:
+	"marvell,armada-8k-rtc" for Aramda 7K/8K/3900 SoCs
+- reg: a list of base address and size pairs, one for each entry in
+  reg-names
+- reg names: should contain:
+  * "rtc" for the RTC registers
+  * "rtc-soc" for the SoC related registers and among them the one
+    related to the interrupt.
+- interrupts: IRQ line for the RTC.
+
+Example:
+
+rtc@a8040 {
+	compatible = "marvell,armada-8k-rtc";
+	reg = <0xa8040 0x20>, <0x184a0 0x0c>;
+	reg-names = "rtc", "rtc-soc";
+	interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+};
diff --git a/doc/device-tree-bindings/spi/mvebu-spi.txt b/doc/device-tree-bindings/spi/mvebu-spi.txt
new file mode 100644
index 0000000000..95840fd24d
--- /dev/null
+++ b/doc/device-tree-bindings/spi/mvebu-spi.txt
@@ -0,0 +1,73 @@
+Marvell SPI binding
+===================
+
+Binding for SPI Driver Marvell's Armada familiy SoCs (Apart from A37x0).
+
+Mandatory properties:
+SoC specific:
+- compatible: 		Should be one of the following options:
+				"marvell,armada-375-spi"
+				"marvell,armada-380-spi"
+				"marvell,armada-xp-spi"
+- reg:			Base address of SPI host controllers
+- reg : 		offset and length of the register set for the device.
+			This property can optionally have additional entries to configure
+			the SPI direct access mode that some of the Marvell SoCs support
+			additionally to the normal indirect access (PIO) mode. The values
+			for the MBus "target" and "attribute" are defined in the Marvell
+			SoC "Functional Specifications" Manual in the chapter "Marvell
+			Core Processor Address Decoding".
+			The register sets following the control registers refer to
+			chip-select lines 0 through n(n<=7) respectively.
+- clocks:		This property points to the used clock for the SPI interface.
+- cell-index:		SPI unit id.
+- #address-cells: 	Must be <1>, as required by generic SPI binding.
+- #size-cells:		Must be <0>, also as required by generic SPI binding.
+
+
+Board specific:
+- spi-max-frequency:	SPI max bus frequency.
+
+Example: For SPI-0 node:
+	cpm_spi0: spi@700600 {
+		compatible = "marvell,armada-380-spi";
+			reg = <0x700600 0x50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			cell-index = <1>;
+			clocks = <&cpm_syscon0 0 3>;
+	};
+
+Example with SPI direct mode support in armada 7040 DB boards(optionally):
+	&cp0_spi1: spi@700680 {
+		compatible = "marvell,armada-380-spi";
+		pinctrl-names = "default";
+		pinctrl-0 = <&cp0_spi0_pins>;
+		reg = <0x700680 0x50>,		/* control */
+		      <0x2000000 0x1000000>,	/* CS0 */
+		      <0 0xffffffff>,		/* CS1 */
+		      <0 0xffffffff>,		/* CS2 */
+		      <0 0xffffffff>;		/* CS3 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		cell-index = <2>;
+	};
+
+To enable the direct mode, the board specific 'ranges' property needs
+to add the entries for the desired SPI controllers and its chip-selects
+that are used in the direct mode instead of PIO mode. Here an example
+for this (SPI controller 1, device 0 is used in direct mode. All other
+SPI device are used in the default indirect (PIO) mode):
+
+#define SPI_DIRECT_BASE                                (0xf9000000)
+
+	cp0 {
+		config-space {
+			/*
+			* Enable the SPI direct access by configuring an entry
+			* here in the board-specific ranges property
+			*/
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+		}
+	};
diff --git a/doc/device-tree-bindings/thermal/mvebu-thermal.txt b/doc/device-tree-bindings/thermal/mvebu-thermal.txt
new file mode 100644
index 0000000000..ffa98e30db
--- /dev/null
+++ b/doc/device-tree-bindings/thermal/mvebu-thermal.txt
@@ -0,0 +1,63 @@
+Marvell Thermal Sensor binding
+==============================
+
+The thermal node includes a description of the Thermal Sensor External Unit.
+The thernal sensor is an on-chip temperature sensor that reads the temperature of
+every core and returns the average or the maximum between them.
+
+Mandatory properties:
+SoC specific:
+	- compatible: should contain two compatibles:
+		- first: "marvell,mvebu-thermal"
+		- second: indicate the thermal sensor type
+		"marvell,thermal-sensor" or "marvell,thermal-ext-sensor"
+	- reg: the base address of thermal unit
+	- gain, offset: parameters of the temperature equation
+		which are:
+		T(in Celsius) = T(read value) * gain + offset
+
+	- divisor: the value that multiply with gain and offset; see Note.
+		Note: in the Tsen spec the default value of gain equals 0.425
+		In the u-boot we cannot calculate a real number (no floating point).
+		For this reason, set the gain and offset by multiplying them by divisor
+		value (usually 1000 or 10000).
+		This helps to calculate the equation; see example below.
+
+
+- In Armada80x0/70x0 there are 2 types of thermal sensor:
+	- regular sensor (integrated in CP)
+	- external sensor (integrated in AP)
+
+Example for external sensor (integrated in AP):
+
+The required calculation:
+T(in Celsius) = T(read value) * 0.425 + 153.4
+The calculation in u-boot:
+T(in Celsius) = (T(read value) * 425 + 153400) / 1000
+
+Example:
+	thermal: thermal@6f8084 {
+		compatible = "marvell,mvebu-thermal", "marvell,thermal-ext-sensor";
+		reg = <0x6f8084 0x12>;
+		gain = <425>;
+		offset = <153400>;
+		divisor = <1000>;
+		status = "okay";
+	};
+
+Example for regular sensor (integrated in CP):
+
+The required calculation:
+T(in Celsius) = T(read value) * 0.4761 - 279.1
+The calculation in u-boot:
+T(in Celsius) = (T(read value) * 4761 - 2791000) / 10000
+
+Example:
+	thermal@400070 {
+		compatible = "marvell,mvebu-thermal", "marvell,thermal-sensor";
+		reg = <0x400070 0x12>;
+		gain = <4761>;
+		offset = <2791000>;
+		divisor = <10000>;
+		status = "okay";
+	};
diff --git a/doc/device-tree-bindings/usb/marvell.ehci-usb.txt b/doc/device-tree-bindings/usb/marvell.ehci-usb.txt
new file mode 100644
index 0000000000..3c26403d5d
--- /dev/null
+++ b/doc/device-tree-bindings/usb/marvell.ehci-usb.txt
@@ -0,0 +1,22 @@
+Marvell SOC USB controllers
+
+This controller is integrated in Armada 3700.
+It uses the same properties as a generic EHCI host controller
+
+Required properties :
+ - compatible: should be one or more of:
+   - "marvell,armada3700-ehci", "marvell,orion-ehci"
+ - reg: should contain address and length of the standard EHCI
+   register set for the device.
+
+Optional properties:
+ - vbus-supply : If present, specifies the fixed regulator to be turned on
+   for providing power to the USB VBUS rail.
+
+Example:
+	usb2: usb@5e000 {
+		compatible = "marvell,armada3700-ehci";
+		reg = <0x5e000 0x450>;
+		vbus-supply = <&reg_usb2_vbus>;
+		status = "disabled";
+	};
\ No newline at end of file
diff --git a/doc/device-tree-bindings/usb/marvell.xhci-usb.txt b/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
index e042d1b966..61734040a4 100644
--- a/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
+++ b/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
@@ -15,6 +15,8 @@ Optional properties:
  - clocks: phandle to system controller clock driving this unit
  - vbus-supply : If present, specifies the fixed regulator to be turned on
    for providing power to the USB VBUS rail.
+ - current-limiter : If present, specifies the fixed regulator to be turned on
+   for providing current limitation to the USB.
 
 Example:
 	cpm_usb3_0: usb3@500000 {
@@ -24,5 +26,6 @@ Example:
 		interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&cpm_syscon0 1 22>;
 		vbus-supply = <&reg_usb3h0_vbus>;
+		current-limiter = <&reg_usb3h0_current_limiter>;
 		status = "disabled";
 	};
diff --git a/doc/mvebu/a3700/armada-3700-db-setup.txt b/doc/mvebu/a3700/armada-3700-db-setup.txt
new file mode 100644
index 0000000000..5f82e3218c
--- /dev/null
+++ b/doc/mvebu/a3700/armada-3700-db-setup.txt
@@ -0,0 +1,76 @@
+Armada-3700 Development Board
+=============================
+
+The Armada-3700 Development Board (DB) is a configurable board designed to test
+several combinations of SOC configurations. U-BOOT supports a predefined set of
+those configurations via device tree files.
+
+.. _fig_a3700-ddr3-db:
+
+.. figure:: /images/a3700-ddr3-db.*
+   :align: center
+
+   DB-88F3720-DDR3-Modular Board (Rev2.x)
+
+.. _fig_a3700-ddr4-db:
+
+.. figure:: /images/a3700-ddr4-db.*
+   :align: center
+
+   DB-88F3720-DDR4-Modular Board (Rev3.x)
+
+There are two kinds of DBs, DB-88F3720-DDR3-Modular and DB-88F3720-DDR4-Modular, the only
+difference is DDR type: one is DDR3, the other is DDR4. They are identical concerning the
+following Board Physical Setups.
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch to a different configuration, follow the instructions in the "board setup" section.
+Once completed, build u-boot image with dts file of target configuration.
+
+Board Setup Options
+-------------------
+
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| Connector	| Setup-1: Default			| Setup-2: SGMII1			| Setup-3: SGMII1-SFP2.5G		|
++===============+=======================================+=======================================+=======================================+
+| CON14		| SDcard module		(SLM1505-v1)	| SDcard module		(SLM1505-v1)	| SDcard module		(SLM1505-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON15(PCIe)	| PCIe-mPCIe-Jumper: SLM-1496(Optional*)| PCIe-mPCIe-Jumper: SLM-1496(Optional*)| PCIe-mPCIe-Jumper: SLM-1496(Optional*)|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON17		| SerDes-Jumper 	(SLM1502-v1)	| 88E1512 Module 	(SLM-1496-v1)	| 88F3720-2xSFP Module 	(SLM-1504-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON19		| 88E1512 Module 	(SLM-1496-v1)	| 88E1512 Module 	(SLM-1496-v1)	| 88E1512 Module 	(SLM-1496-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+
+  * PCIe-mPCIe-Jumper is used to enable mini PCIe0 port (CON11)
+
+The table below summarizes the interface configuration of each setup.
+
++---------------+-------------------------------+-----------------------+-------------------------------+
+| DB File	| armada-3720-db-v(x)-A		| armada-3720-db-v(x)-B	| armada-3720-db-v(x)-C		|
++===============+===============================+=======================+===============================+
+| Interface	| Setup-1: Default		| Setup-2: SGMII1	| Setup-3: SGMII1-SFP2.5G	|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY0	| USB3_H0			| SGMII1		| SGMII1-SFP2.5G		|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY1	| PCIe0				| PCIe0			| PCIe0				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY2	| SATA				| SATA			| SATA				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SATA		| CON3				| CON3			| CON3				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| PCIe		| CON15				| CON15			| CON15				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| USB3		| CON29				| N/A			| N/A				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SGMII1	| N/A				| PHY1 (CON17)		| PHY1 (CON17)			|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| RGMII		| PHY0 (CON19)			| PHY0 (CON19)		| PHY0 (CON19)			|
++---------------+-------------------------------+-----------------------+-------------------------------+
+
+
+.. Note::
+	The armada-3720-ddr3-db-v2-A.dts is still named armada-3720-db.dts.
+	Because the armada-3720-db.dts is mainlined, the name must be kept.
diff --git a/doc/mvebu/a7k-a8k/armada3900-db-setup.txt b/doc/mvebu/a7k-a8k/armada3900-db-setup.txt
new file mode 100644
index 0000000000..0e334ce7fc
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada3900-db-setup.txt
@@ -0,0 +1,126 @@
+Armada-3900 Development Board Setup
+===================================
+
+The Armada 3900 Development Board are a series of configurable boards with different
+configuations for different purposes
+U-Boot supports a defined set of those configurations via different device tree files.
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db_armada8k_defconfig           - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Board Setup Options
+~~~~~~~~~~~~~~~~~~~
+
++---------------+-----------------------+-----------------------+
+|		| 4: VD-A		| 4: VD-B		|
++===============+=======================+=======================+
+|Device tree	| armada-3900-vd-A.dts  | armada-3900-vd-B.dts	|
++---------------+-----------------------+-----------------------+
+
+The tables below summarize the interface configuration of each setup.
+
+SerDes Configuration
+~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+
+| CP0 Lane	| 3: VD-A	| 4: VD-B	|
++===============+===============+===============+
+| 0		| PCIE0 (x1)    | PCIE0 (x1)    |
++---------------+---------------+---------------+
+| 1		| USB3_HOST0	| USB3_HOST0	|
++---------------+---------------+---------------+
+| 2		| SFI0 (5G)     | SFI0 (5G)	|
++---------------+---------------+---------------+
+| 3		| UNCONNECTED	| UNCONNECTED	|
++---------------+---------------+---------------+
+| 4		| SFI1 (5G)	| SGMII1 (1G)	|
++---------------+---------------+---------------+
+| 5		| PCIE2 (x1)    | PCIE2 (x1)    |
++---------------+---------------+---------------+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+
+|AP807 pin	| 1: VD-A	| 2: VD-B	|
++===============+===============+===============+
+|	AP-SDIO | N/C           | N/C           |
++---------------+---------------+---------------+
+|	AP-SPI0 | [0-3]         | [0-3]         |
++---------------+---------------+---------------+
+|	AP-I2C	| [4-5]		| [4-5]		|
++---------------+---------------+---------------+
+|	AP-UART0| [11,19]	| [11,19]	|
++---------------+---------------+---------------+
+
++---------------+---------------+---------------+
+|CP0 pin:	| 4: VD-A	| 5: VD-B	|
++===============+===============+===============+
+| CP-SPI1	| N/C		| N/C		|
++---------------+---------------+---------------+
+| NAND		| [13,15-27]	| [13,15-27]	|
++---------------+---------------+---------------+
+| SMI		| [32,34]	| [32,34]	|
++---------------+---------------+---------------+
+| XSMI		| [35-36]	| [35-36]	|
++---------------+---------------+---------------+
+| CP-I2C0	| N/C		| N/C		|
++---------------+---------------+---------------+
+| CP-I2C1	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+
+| USB0_VDD	| [44]		| [44]		|
++---------------+---------------+---------------+
+| USB1_VDD	| [45]		| [45]		|
++---------------+---------------+---------------+
+| IHB_ENABLE	| [56]		| [56]		|
++---------------+---------------+---------------+
+| IHB_RESET	| [57]		| [57]		|
++---------------+---------------+---------------+
+| IOT_RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| ETH-PHY-RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| PPS-RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| CP-UART1	| [46-47,49,58]	| [46-47,49,58]	|
++---------------+---------------+---------------+
+| CP-UART0	| [59-62]	| [59-62]	|
++---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 4 (VD-A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SFI (5G)             		|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | SFI (5G)			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (VD-B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SFI (5G)                      |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | SGMII1 (1G)                   |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- (*) eth0/serdes2 are expected to run with 5G speed but u-boot can't dynammically change the
+              serdes speed. It is configured with 1G and let Linux handle 5G task.
+	- Equivalent of this configuration can be viewed in arch/arm64/boot/dts/mvebu/armada-cpn110.dtsi
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
diff --git a/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt b/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
new file mode 100644
index 0000000000..ff28bca982
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
@@ -0,0 +1,243 @@
+Armada-70x0 Development Board Setup
+===================================
+
+The Armada 7040 Development Board (PCB: DB-88F7040-Modular) is a configurable board,
+designed to test several combinations of SoC configurations.
+U-Boot supports a defined set of those configurations via different device tree files.
+
+.. _fig_a70x0-db:
+
+.. figure:: /images/a70x0-db.*
+   :align: center
+
+   Armada-7040 Development Board
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db-88f8040_defconfig            - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Board Setup Options
+~~~~~~~~~~~~~~~~~~~
+
++---------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|		| 1: A			| 2: B			| 3: C			| 4: D			| 5: E			| 6: F			|
++===============+=======================+=======================+=======================+=======================+=======================+=======================+
+|Device tree	| armada-7040-db.dts	| armada-7040-db-B.dts	| armada-7040-db-C.dts	| armada-7040-db-D.dts  |armada-7040-db-E.dts	| armada-7040-db-F.dts	|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 | SW1:1	| ON			| OFF			| ON			| ON			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| ON			| ON			| ON			| ON			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| ON			| ON			| ON			| ON			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| ON			| ON			| ON			| ON			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+DPR Setting
+~~~~~~~~~~~
+
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|			| 1: A			| 2: B			| 3: C			| 4: D			| 5: E			| 6: F			|
++=======================+=======================+=======================+=======================+=======================+=======================+=======================+
+| Mpp Jumper Module	| DPR all = 1-2		| DPR all = 1-2		| DPR 133-143:		| DPR 133,135,136,137:	| DPR133-143:		|			|
+| (SLM1548)		|			|			|   2-3 position	|   N/C			|   1-2 position	|			|
+|			|			|			|			| DPR 134:		| DPR144-147:		|			|
+|			|			|			|			|   2-3 postion		|   2-3 position	|			|
+|			|			|			|			| DPR 138-143:		|			|			|
+|			|			|			|			|   2-3 postion		|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Serdess Jumper Module	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	|
+| (SLM1547)		|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|
+|			| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	|
+|			|   2-3 position	|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|   2-3 position	|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 Serdess module	| SW1:			| SW1:			|  SW1:			| sW1:			| SW1:			| SW1:			|
+| (SLM1521)		|   (1,3,6,7)= ON	|   (2,3,4,5,6,7)= ON	|    (1,3,6,7)= ON	|   (1,3,6,7)= ON	|   (3,6,7)= ON		|   (1,3,6,7)= ON	|
+|			|   (2,4,5,8)= OFF	|   (1,8)=OFF		|    (2,4,5,8)=OFF	|   (2,4,5,8)= OFF	|   (1,2,4,5,8)=OFF	|   (2,4,5,8)= OFF	|
+|			| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		|
+|			|   1-2 position	|    2-3 position	|     1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|
+|			|			|			|			| Disconnect CON9 (USB3 |			|			|
+|			|			|			|			| host plug type A)	|			|			|
+|			|			|			|			| Connect CON11 (marvell|			|			|
+|			|			|			|			| pn CON641)		|			|			|
+|			|			|			|			| Connect R126,127,119,	|			|			|
+|			|			|			|			| 122, 121, 117		|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Install TDM Module	|			|			| on DB-7040 CON46	|			|			|			|
+| (SLM1448)		|			|			|			|			|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Install Audio Module	|			|			|			| on DB-7040 CON46	|			|			|
+| (SLM1449)		|			|			|			|			|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| DB7040		|			|			|			| wire:			| DPR53-54: 1-2 position|			|
+|			|			|			|			|  from U36-1 to con47-2| DPR61: 2-3 position	|			|
+|			|			|			|			| DPR23 - NC		| DPR10-11 position 1-2	|			|
+|			|			|			|			|			| DPR12-15 position 1-2 |			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Install Switch Module	|			|			|			|			|			| on DB-7040 CON35/36	|
+| (SLM1449)		|			|			|			|			|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+The tables below summarizes the interface configuration of each setup
+
+SerDes Configuration
+~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP0 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		|
++===============+===============+===============+===============+===============+===============+===============+
+| 0		| SGMII1	| PICE0 (x4)	| PCIE0 (x1)    | PCIE0 (x1)    | PCIE0 (x1)	| SGMII1	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 1		| USB3_HOST0	| PCIE0 (x4)	| SATA0		| USB3_DEVICE0  | SATA0		| USB3_HOST0	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 2		| SFI0 (10G)	| PCIE0 (x4)	| SFI0 (10G)    | SFI0 (10G)	| SGMII0 (1G)	| SFI0 (10G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 3		| SATA1		| PCIE0 (x4)	| SATA1		| SATA1         | SATA1		| SATA1		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 4		| USB3_HOST1	| USB3_HOST1	| USB3_HOST1    | USB3_HOST1    | USB_HOST1	| USB3_HOST1	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 5		| PCIE2 (x1)	| PCIE2 (x1)	| PCIE2 (x1)    | PCIE2 (x1)    | PCIE2 (x1)	| PCIE2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+- USB2_H1 (UTMI & USB3 SerDes)
+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|AP806 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		|
++===============+===============+===============+===============+===============+===============+===============+
+|	AP-SDIO | [0-5]		| [0-5]		| [0-5]         | [0-5]		| N/C		| [0-5]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-SPI0 | N/C		| N/C		| N/C		| N/C		| [0-3]		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-I2C	| N/C		| N/C		| N/C		| N/C		| [4,5]		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-UART0| [11,19]	| [11,19]	| [11,19]       | [11,19]	| [11,19]	| [11,19]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|CP0 pin:	| 1: A		| 3: B		| 3: C		| 4: D		| 5: E		| 6: F		|
++===============+===============+===============+===============+===============+===============+===============+
+| CP-SPI0	| N/C		| N/C		| [6-11]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-SPI1	| [13-16]	| [13-16]	| [13-16]	| N/C		| [13-16]	| [13-16]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| NAND		| N/C		| N/C		| N/C		| [15-27]	| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| RGMII1	| [0-11]	| [0-11]	| N/C		| N/C		| [0-11]	| [0-11]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| RGMII2	| N/C		| [44-55]	| [44-55]	| [44-55]	| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-UART0	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-UART1	| N/C		| N/C		| N/C		| N/C		| [47,49-51]	| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| SD		| [56-61]	| [56-61]	| [56-61]	| [56-61]	| [54,56-61]	| [56-61]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| GPIO		| [62]		| [62]		| [62]		| [62]		| [62]		| [62]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| TDM		| N/C		| N/C		| [0-5]		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| TWSI		| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| SATA0		| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| SATA1		| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| SMI		| [32,34]	| [32,34]	| [32,34]	| [32,34]	| [32,34]	| [32,34]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| XSMI		| [35-36]	| [35-36]	| [35-36]	| [35-36]	| [35-36]	| [35-36]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| USB_DEV	| N/C		| N/C		| N/C		| [7]		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 1 (A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| CP0	| eth0		| 0		| 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0	| eth1		| 2		| SGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| CP0	| eth2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 2 (B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 2             | RGMII1                        |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 3 (C):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 4 (D):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (E)
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SGMII0 (1G)                   |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | RGMII1                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 6 (F):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| CP0	| eth0		| 0		| 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0	| eth1		| 2		| SGMII1 (2.5G through switch	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| CP0	| eth2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- Equivalent of this configuration can be viewed in arch/arm64/boot/dts/mvebu/armada-cpn110.dtsi
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
+	- Setup F network via switch not operational in U-Boot.
diff --git a/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt b/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
new file mode 100644
index 0000000000..38a5f50902
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
@@ -0,0 +1,307 @@
+Armada-80x0 Development Board Setup
+===================================
+
+The Armada 8040 Development Board (PCB: DB-88F8040-Modular) is a configurable board,
+designed to test several combinations of SoC configurations.
+U-Boot supports a defined set of those configurations via different device tree files.
+
+.. _fig_a80x0-db:
+
+.. figure:: /images/a80x0-db.*
+   :align: center
+
+   Armada-8040 Development Board
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db-88f8040_defconfig		 - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Warning:
+The PCIe x4 + SFI 10G configuration (H) requires usage of IO card SLM-1521-v2.
+
+Board Setup Options
+-------------------
+
++---------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|		| 1: A			| 2: B			| 3: C			| 4: D			| 5: E			| 6: F			| 7: G			| 8: H (SLM-1521-v2)	|
++===============+=======================+=======================+=======================+=======================+=======================+=======================+=======================+=======================+
+|Device tree	|armada-8040-db.dtb	|armada-8040-db-B.dtb	|armada-8040-db-C.dtb	|armada-8040-db-D.dtb	|armada-8040-db-E.dtb	|armada-8040-db-F.dtb	|armada-8040-db-G.dtb	|armada-8040-db-H.dtb	|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 | SW1:1	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP1 | SW1:1	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| ON			| ON			| ON			| ON			| ON			| ON			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+DPR Setting
+~~~~~~~~~~~
+
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+|						| 1: A		| 2: B		| 3: C			| 4: D			| 5: E				| 6: F		| 7: G		| 8: H		|
++===============================================+===============+===============+=======================+=======================+===============================+===============+===============+===============+
+| Jumper-module (CON44): SLM1564		| DPR all = 1-2	| DPR all = 1-2	| DPR 96-101 = 2-3,	| DPR 96-101 = 2-3,	| DPR 109-112 = 2-3,		| DPR all = 1-2	|DPR all = 1-2	|DPR all = 1-2	|
+|						|		|		| DPR 103-108 = 2-3,	| DPR 103-108 = 2-3,	| others = 1-2			|		|		|		|
+|						|		|		| DPR 102 = 1-2		| DPR 102 = 1-2		|				|		|		|		|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| Serdes CP0 site module (CON42): SLM1521	| DPR 2-5 = 1-2	| DPR 2-5 = 2-3	| DPR 2-5 = 1-2		|DPR 2-5 = 1-2		| DPR 2-5 = 1-2			| DPR 2-5 = 1-2	| DPR 2-5 = 2-3	| DPR 2-5 = 1-2	|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| Serdes CP1 site module (CON41): SLM1521	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2		|DPR 2-5 = 1-2		| DPR 2-5 = 1-2			| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| DB8040					|		|		| DPR 84 = 2-3		| DPR 76 = 1-2,		| DPR 81 = 2-3,			|		|		|		|
+|						|		|		| TDM module (CON51):	| DPR 87-88 = 2-3	| DPR 23-26,119,121 =1-2	|		|		|		|
+|						|		|		| SLM1448		| Audio module (CON51):	|				|		|		|		|
+|						|		|		|			| SLM1449		|				|		|		|		|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+
+The tables below summarizes the interface configuration of each setup
+
+
+SerDes Configurations
+~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| CP0 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F			| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+=======================+===============+===============+
+| 0		| PCIe0 (x1)	| PCIe0 (x4)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 1		| SATA0		| PCIe0 (x4)	| SATA0		| SATA0		| SATA0		| SATA0			| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 2		| SFI0 (10G)	| PCIe0 (x4)	| SFI0 (10G)	| SFI0 (10G)	| SFI0 (10G)	| AP (802.3 auto-neg)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 3		| SATA1		| PCIe0 (x4)	| SATA1		| SATA1		| SATA1		| SATA1			| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 4		| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1		| USB3_HOST1	| SFI1 (10G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 5		| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)		| PCIe2 (x1)	|PCIe2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+- USB2_H1 (UTMI & USB3 SerDes)
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP1 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+| 0		| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 1		| SATA0		| USB3_HOST0	| SATA0		| SATA0		| SATA0		| SATA0		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 2		| SFI0 (10G)	| SFI0 (10G)	| SFI0 (10G)	| SGMII0	| SGMII0 (2.5G)	| SFI0 (10G)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 3		| SATA1		| SATA1		| SATA1		| SATA1		| SATA1		| SATA1		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 4		| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| USB3_HOST1	| SFI1 (10G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 5		| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| AP806 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|    AP-SDIO	| [0-10]	| [0-10]	| [0-10]	| [0-10]	| N/C		| [0-10]	| [0-10]	| [0-10]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    I2C0	| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    AP-SPI0	| N/C		| N/C		| N/C		| N/C		| [0,3]		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    AP-UART0	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP0 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|   CP0-SMI	| [32,34]	| [32,34]	| [32,34]	| [32,34]	| N/C		| [32,34]	| [32,34]	| [32,34]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-XSMI	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-TWSI	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SATA1	| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SATA0	| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-RGMII2	| [44-55]	| [44-55]	| [44-55]	| [44-55]	| N/C		| [44-55]	| [44-55]	| [44-55]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SD	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-PTP_CLK	| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-TWSI1	| N/C		| N/C		| N/C		| N/C		| [35-36]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-UART1	| N/C		| N/C		| N/C		| N/C		| [47,49]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-UART2	| N/C		| N/C		| N/C		| N/C		| [50-51]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+GPIOS:
+	- 33: GPIO: GE_INT#/push button/Wake
+	- 35: MSS_GPIO[3]: MSS_PWDN (only in configuration 1,3,4,5)
+	- 36: MSS_GPIO[5]: MSS_VTT_EN (only in configuration 1,3,4,5)
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP1 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|   CP1-RGMII1	| [0-11]	| [0-11]	| N/C		| N/C		| [0-11]	| [0-11]	| [0-11]	| [0-11]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SMI	| [27,31]	| [27,31]	| N/C		| N/C		| [27,31]	| [27,31]	| [27,31]	| [27,31]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SPI1	| [13-16]	| [13-16]	| [13-16]	| N/C		| [13-16]	| [13-16]	| [13-16]	| [13-16]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-UART0	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SATA1	| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SATA0	| N/C		| N/C		| [27]		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-AU	| N/C		| N/C		| N/C		| [0-5]		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-NAND	| N/C		| N/C		| N/C		| [13,15-27]	| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-TDM	| N/C		| N/C		| [0-11]	| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 1 (A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 2 (B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 3 (C):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 4 (D):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| SGMII0			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (E):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 0		| 0		| 2.5G SGMII0			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 6 (F):
+
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface				|
++===============+=======+===============+===============+===============================================+
+| eth0		| 0	| 0		| 0		| AP (Lane 2 left for 802.3 auto-negotiation)	|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2					|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFI)			|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1					|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+
+Setup 7 (G):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 8 (H):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 4 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 4 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
diff --git a/doc/mvebu/build.txt b/doc/mvebu/build.txt
new file mode 100644
index 0000000000..30b03888e4
--- /dev/null
+++ b/doc/mvebu/build.txt
@@ -0,0 +1,210 @@
+U-Boot Build Instructions
+=========================
+
+This document describes how to compile U-Boot and how to change U-Boot
+configuration. The are 2 methods to compile u-boot:
+
+1. Using prepared scripts
+
+2. Manual compilation
+
+Both methods will be described in this documents.
+
+System preparations (for both methods)
+--------------------------------------
+1. Install required packages::
+
+		> sudo apt-get install libssl-dev
+		> sudo apt-get install device-tree-compiler
+		> sudo apt-get install swig libpython-dev
+
+2. Set the cross compiler::
+
+		> export CROSS_COMPILE=/path/to/toolchain/aarch64-linux-gnu
+
+Build with scripts
+------------------
+The script is located in the u-boot tree **./scripts/ci/**
+
+Script usage::
+
+		> ./scripts/ci/compile.sh --help
+
+		Usage: compile [--no_configure] [--echo_only] BUILD_NAME
+		 or:   compile --list
+		 or:   compile --help
+
+		Compiles u-boot similar to the given CI build
+
+		 -N, --no_configure   Skip configuration steps (mrproper, make defconfig)
+		 -e, --echo_only      Print out the compilation sequence but do not execute it
+		 -l, --list           List all supported BUILD_NAME values and exit
+		 -h, --help           Display this help and exit
+
+		Prerequisites:       CROSS_COMPILE must point to the cross compiler
+
+Examples::
+
+		MacchiatoBin build: ./scripts/ci/compile.sh uboot_2018_a80x0_mcbin
+
+Manual build procedure
+----------------------
+1. Clean-up old residuals::
+
+		> make mrproper
+
+2. Configure the U-Boot::
+
+		> make <defconfig_file>
+
+   - For the ARMADA 70x0/80x0/3900 DB board and ARMADA 7020 AMC use
+     "make mvebu_db_armada8k_defconfig"
+   - For the ARMADA 80x0 MacchiatoBin use "make mvebu_mcbin-88f8040_defconfig"
+   - For the ARMADA 3700 DB board use "make mvebu_db-88f3720_defconfig"
+   - For the ARMADA 3700 EsspressoBin use "make mvebu_espressobin-88f3720_defconfig"
+   - For the OcteonTX2 CN913x DB board use "make mvebu_db_cn91xx_defconfig"
+
+3. Configure the device-tree and build the U-Boot image:
+
+	All device-tree files are located in ./arch/arm/dts/ folder.
+	Information about the different configuration available for the
+	development board is located in:
+
+	- For ARMADA 37x0: ./doc/mvebu/a3700/armada-3700-db-setup.txt
+	- For ARMADA 70x0: ./doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
+	- For ARMADA 80x0: ./doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
+	- For ARMADA 3900: ./doc/mvebu/a7k-a8k/armada3900-db-setup.txt
+
+	In order to compile u-boot with a specific device-tree,
+	use the following::
+
+		> make DEVICE_TREE=<name>
+
+	- For the ARMADA 3900 DB use "make DEVICE_TREE=armada-3900-vd[-X]"
+	- For the ARMADA 70x0 DB use "make DEVICE_TREE=armada-7040-db[-X]"
+	- For the ARMADA 7020 AMC use "make DEVICE_TREE=armada-7020-amc"
+	- For the ARMADA 80x0 DB use "make DEVICE_TREE=armada-8040-db[-X]"
+	- For the ARMADA 37x0 DB use "make DEVICE_TREE=armada-3720-ddrX-db[-X]"
+	  (X represents possible board configuration)
+	- For the EspressoBin board without soldered eMMC device use
+	  "make DEVICE_TREE=armada-3720-espressobin"
+	- For the EspressoBin board with populated eMMC device use
+	  "make DEVICE_TREE=armada-3720-espressobin-emmc"
+	- For the ARMADA 80x0 MacchiatoBin use
+	  "make DEVICE_TREE=armada-8040-mcbin"
+	- For the ARMADA 80x0 MacchiatoBin Single Shot use
+	  "make DEVICE_TREE=armada-8040-mcbin-single-shot"
+	- For the OcteonTX2 CN913x DB use "make DEVICE_TREE=cn913[X]-A"
+
+	The U-Boot compilation generates u-boot.bin - the U-Boot image
+
+	.. Note::
+		The u-boot.bin should not be used as a stand-alone image.
+		The ARM Trusted Firmware (ATF) build process uses this image to
+		generate the flash image.
+
+
+Configuration Update
+---------------------
+To update the U-Boot configuration, refer to doc/README.kconfig
+
+
+Boot Device Selection
+---------------------
+The following options are available:
+	- Boot from SPI boot
+	- Boot from eMMC boot
+
+eMMC Boot Device
+-----------------
+The ARMADA 3700, ARMADA 7K/8K/3900 and OcteonTX2 CN913x support eMMC as the boot
+device on the target.
+The default boot device on this platform is SPI NOR flash.
+In order to change the boot device to eMMC, set the following parameter
+the default configuration::
+
+	- CONFIG_MVEBU_MMC_BOOT=y
+	- CONFIG_ENV_IS_IN_MMC=y
+	- Remove any other CONFIG_ENV_IS_IN_* occurrences in defconfig file
+
+If "menuconfig" is used, navigate to the following location::
+
+	-> Command line interface
+	  -> Misc commands
+	    -> MVEBU commands
+	      -> Flash for image
+
+and select "eMMC flash boot" for the boot device, then select the device for the
+environment location):
+
+	-> Command line interface
+	  -> Environment
+	    -> Environment in an MMC device
+
+The eMMC has 2 boot partitions (BOOT0 and BOOT1) and a user data partition
+(DATA).
+The boot partitions are numbered as partition 1 and 2 in MMC driver.
+Number 0 is used for user data partition and should not be utilized for storing
+boot images and U-Boot environment in RAW mode since it will break file system
+structures usually located here.
+
+The default boot partition is BOOT0. It is selected by the following parameter:
+CONFIG_SYS_MMC_ENV_PART=1
+Valid values for this parameter are 1 for BOOT0 and 2 for BOOT1.
+Never use partition number 0 here!
+
+If select SD card as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_PART		0
+
+If select eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_PART		1
+or::
+
+	#define CONFIG_SYS_MMC_ENV_PART         2
+
+The parameter CONFIG_SYS_MMC_ENV_DEV depends on total number of enabled eMMC
+interfaces on board, the AP interface is enumerated first, then CP interface.
+
+For example on board with eMMC interface on both AP and CP::
+
+If select AP's SD card/eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_DEV         0
+
+If select CP's SD card/eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_DEV         1
+
+Both parameters can be changed in the "include/configs/mvebu_armadacommon.h".
+
+Note that this configuration is only available when "Flash for image"
+selects "eMMC flash boot" device as described above.
+The selected partition will be used by U-Boot "bubt" and "savenv" commands
+for flashing the boot image and saving U-Boot configuration.
+
+
+Boot Device Selection for ARMADA 7K/8K/3900 and OcteonTX2 CN913x Build
+----------------------------------------------------------------------
+The following options are available for A8K, A7K, A3900 and OcteonTX2 CN913x boot:
+
+	- Boot from SPI NAND
+
+SPI NAND Boot Device
+--------------------
+The ARMADA-7K/8K/3900 and OcteonTX2 CN913x support SPI NAND flash as the boot
+device on the target.
+In order to burn the image and save environment variables to SPI NAND flash,
+please enable SPI NAND driver at first by set the following parameter to <Y>::
+
+	CONFIG_MVEBU_NAND_BOOT=y
+
+If "menuconfig" is used, navigate to the following location::
+
+	-> Command line interface
+	  -> Misc commands
+	    -> MVEBU commands
+	      -> Flash for image
+
+and select "NAND flash boot".
diff --git a/doc/mvebu/linux_boot.txt b/doc/mvebu/linux_boot.txt
new file mode 100644
index 0000000000..5169d67801
--- /dev/null
+++ b/doc/mvebu/linux_boot.txt
@@ -0,0 +1,42 @@
+Booting Linux Kernel
+====================
+
+U-Boot supports loading the Linux kernel with the following images:
+- Linux image
+- Device Tree Blob (DTB) image
+- RAM File System (RAMFS) image - optional
+
+To load images from a TFTP server, set the TFTP server with the relevant image
+file.
+
+Run the following commands from the U-Boot prompt::
+
+	# setenv serverip <IP address of the TFTP server>
+	# setenv ipaddr <IP address of the board>
+	# setenv gatewayip <IP address of the Gateway>
+	# setenv image_name <Linux image name>
+	# setenv fdt_name <DTB image name>
+
+To mount the file-system via NFS:
+
+	- Set the NFS server with the appropriate file system.
+	- Run the following commands from the U-Boot prompt::
+
+		# setenv rootpath <path to filesystem in the NFS server>
+		# setenv netdev <NFS interface name, eth0 for example>
+		# setenv ramfs_name (optional)
+
+	Note:
+	  For the boards with Marvell SOHO switch, e.g., Espressobin,
+	  'netdev' should be set according to the port name defined by
+	  switch driver instead, i.e., lan0, lan1 or wan0.
+
+To load RAMFS:
+Run the following commands from the U-Boot prompt::
+
+	# setenv ramfs_name <RAMFS image name>
+	# setenv root <the ram device. for example, /dev/ram0 rw>
+
+To boot Linux Kerenl, run from U-Boot prompt::
+
+	# boot
diff --git a/doc/mvebu/porting_guide.txt b/doc/mvebu/porting_guide.txt
new file mode 100644
index 0000000000..90536ff825
--- /dev/null
+++ b/doc/mvebu/porting_guide.txt
@@ -0,0 +1,128 @@
+U-Boot Porting Guide
+====================
+
+This document provide instructions for porting the Marvell U-Boot package to a customer board.
+
+Relevant Devices
+----------------
+- ARMADA 80x0
+- ARMADA 70x0
+- ARMADA 37x0
+- ARMADA 3900
+- Octeon-TX2 CN913x
+
+Introduction
+------------
+	U-Boot configuration is based on three elements:
+
+	- defconfig file:
+	  This file includes compile-time options for U-Boot, and is used to
+	  enable / disable U-Boot device drivers and features.
+	- include/configs/mv-common.h, include/configs/mvebu_<soc-name>.h (e.g. armada8k.h)
+	  These files include low-level control over U-Boot definitions,
+	  and is likely not to be changed when porting to a new board.
+	- device-tree files
+	  These files are located under arch/arm/dts, and include the runtime
+	  configuration of U-Boot, and enables passing configuration parameters for
+	  each of the drivers/units in U-Boot.
+	  The majority of the porting should be done in the device-tree.
+	  For more information about device-tree syntax, refer to the various examples
+	  under arch/arm/dts/ or visit http://devicetree.org/Device_Tree_Usage
+
+	For the sake of simplicity, all examples below will use the armada-80x0-db board, and the new
+	board will be called "my_board".
+
+
+Customer Board Porting Procedure
+--------------------------------
+
+defconfig & DT file
+~~~~~~~~~~~~~~~~~~~
+
+   1. defconfig
+
+	- Find the defconfig file that matches the SoC flavor being used (e.g. armada-3700, armada-70x0...)
+	- Create a new defconfig to hold U-Boot compile time configuration::
+
+		> cp configs/mvebu_db_armada8k_defconfig configs/my_board_defconfig
+
+   2. device-tree
+
+	- Create a new DT file to hold U-Boot runtime configuration for your board.
+	- Some example DT files already exist in U-Boot, it's possible to use them as-is or
+	  rename to match your system's name::
+
+		> cp arch/arm/dts/armada-8040-db.dts arch/arm/dts/armada-70x0-my_board.dts
+
+	- Add new DT file to arch/arm/dts/Makefile under CONFIG_ARCH_MVEBU::
+
+		dtb-$(CONFIG_ARCH_MVEBU) +=                     \
+			armada-70x0-my_board.dtb                \
+			armada-3720-db.dtb                      \
+
+Basic defconfig setup
+~~~~~~~~~~~~~~~~~~~~~
+
+   1. Update my_board defconfig::
+
+		> make my_board_defconfig
+		> make menuconfig
+
+	- Update device tree file name:
+		-> Device Tree Control -> Default Device Tree for DT control -> "armada-80x0-my_board"
+
+	- Save and exit::
+
+		> make savedefconfig
+		> cp defconfig configs/my_board_defconfig
+
+   2. Compilation sanity
+
+      Compile U-Boot to make sure that everything was set properly.
+      (Refer to doc/mvebu/build.txt for detailed build instructions)::
+
+		> export CROSS_COMPILE=/path/to/toolchain/aarch64-linux-gnu
+		> make
+
+You are ready to start porting U-Boot to match "my_board" configuration.
+
+
+Device-tree porting
+~~~~~~~~~~~~~~~~~~~
+
+   This is the actual porting of U-Boot to make it work properly on "my_board":
+
+	- Edit the "my_board" dts file under arch/arm/dts/<name of dts given in section 2 above>
+	- For each of the (configurable) U-Boot drivers/units, a device tree binding
+	  description file exists, which explains the different configuration options
+	  for the relevant driver.
+
+   Below is a list of drivers/units, and their relevant DT binding description file:
+   (all file paths are relative to "doc/device-tree-bindings/")
+
+   1. Common for all SoCs:
+
+	- COMPHY - phy/mvebu_comphy.txt
+	- SATA - scsi/mvebu-ahci.txt & scsi/marvell,mvebu-scsi.txt
+	- USB3 - xHCI - usb/marvell.xhci-usb.txt
+	- MMC/SDIO - mmc/xenon-mmc.txt
+
+   2. ARMADA 7K/8K/3900 and OcteonTX2 CN913x SoC family:
+
+	- MPPs - pinctrl/marvell,mvebu-pinctrl.txt
+	- GPIO - gpio/mvebu-gpio.txt
+	- MDIO (SMI) - net/mvebu-mdio.txt
+	- NAND - nand/marvell-pxa3xx-nand.txt
+	- SPI - spi/mvebu-spi.txt
+	- Serial - serial/snps-dw-apb-uart.txt
+	- PCIe - pci/armada8k-pcie.txt
+	- I2C - i2c/mvebu-i2c.txt
+	- PPv2 - net/marvell-pp2x.txt
+	- Efuse - fuse/fuse-a7k.txt
+
+   3. ARMADA 3700 SoC family:
+
+	- Serial - serial/mvebu-serial.txt
+	- MPPs & GPIO - pinctrl/marvell,armada-37xx-pinctrl.txt
+	- SPI - spi/mvebu-a3700-spi.txt
+	- PCIe - pci/armada37xx-pcie.txt
diff --git a/doc/mvebu/trusted_boot.txt b/doc/mvebu/trusted_boot.txt
new file mode 100644
index 0000000000..4c5ab66bae
--- /dev/null
+++ b/doc/mvebu/trusted_boot.txt
@@ -0,0 +1,540 @@
+.. _uboot_trusted:
+
+Trusted Boot (Secure Mode)
+==========================
+
+This document describes how to build/burn and update Secure Trusted image with
+Key generating and updating, assuming that the SoC being used is already
+supported in U-Boot & ATF.
+
+The trusted boot document describes the following components:
+
+- eFuse module - Allows burning boot device, authentication key digest,
+  encryption key, etc.
+- Boot image format - Provides the trusted boot information to BootROM.
+- Work flow - Guide how to build and burn Secure Trusted images to target
+  board.
+- Authentication Keys Generation and selection - Provides method to generate
+  and select authentication keys.
+
+A38x platforms
+~~~~~~~~~~~~~~
+Please refer to Application Note
+- AN-383: ARMADA 38x/39x Families Secure Boot Mode Support
+
+eFuses
+-------
+The eFuse command module and driver provides RW access to SoC eFuses through
+the "efuse" command for A3700 platform or "fuse" command for A7K/8K platform.
+In order to enable this SW component, the following configuration entry should
+be set by using "make menuconfig"::
+
+A8K platforms
+~~~~~~~~~~~~~
+Command Location:
+	-> command line interface
+		-> Device access commands
+			-> fuse
+Driver Location:
+	-> Device Drivers
+		-> EFUSE Support
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+Command Location:
+	-> Command line interface
+		-> MVEBU commands
+			-> efuse
+Driver Location:
+	-> ARM architecture
+		-> MVEBU Common SoC Utilities
+			-> eFuse support
+
+The above configuration enables the eFuse driver and eFuse command module.
+Refer to SoC and BootROM manuals for details about supported eFuses
+and their role in the trusted boot flow.
+Since the eFuse command module and driver are only used for simplified access
+to eFuse HW values, the presence of these components in the final trusted boot
+image is not required.
+
+A8K platforms
+~~~~~~~~~~~~~
+The AES-256 key is visible only during the efuse burn session. It will be hidden
+after reset and accessible only on early boot stages by the internal BootROM
+procedures.
+Trying to read efuse values of AES-256 key will return zeros.
+Note that if the JTAG is permanently enabled in A8K efuse, the AES-256 key
+becomes hidden for everyone, including the BootROM. Therefore when JTAG is
+enabled permanently by eFuse, the boot image should not be encrypted, since
+BootROM decryption will always fail unless a zero-key was used for image
+encryption.
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+The AES-256 KEY can be hidden by setting the "DEV_DEPLOY" bits, these bits are
+set by the customer when deploying their products which will set the chip to
+trusted mode.
+
+Boot Image Format
+-----------------
+The boot image should be properly formatted for the trusted boot mode, so
+the BootROM extracts the required information from the image headers and uses it
+for authentication against eFuse values and digital signatures and for image
+decryption.
+Various platforms use different BootROMs and boot image formats.
+For specific details refer to the SoC functional specification, BootROM manual
+and to the section related to a selected platform below.
+Refer to ATF build documentation for enabling secure image output.
+
+A8K platforms
+~~~~~~~~~~~~~
+Refer to A8K functional specification for details about trusted boot image
+components.
+The secure image configuration is defined by a file sec_img_xx.cfg located in
+ATF folder "tools/doimage/secure". The xx in the configuration file name is
+either 7K or 8K for targeting Armada-80x0 or Aramda-70x0 platform setup
+accordingly.
+The configuration file has a standard INI file format and defines the following
+options:
+
+- kak_key_file - The string containing path to the Keys Authentication Key file
+		in PEM format. This parameter is mandatory.
+
+- csk_key_file	- Array of string containing paths to Code Signing Key files in
+		PEM format. This array has to include at least a single key used
+		for signing the boot image and prolog. The key index is defined
+		by the file location in this array.
+		Empty key paths should be coded as "*" strings to make the
+		entire array size of 16 strings. This parameter is mandatory.
+
+- csk_key_index - The integer value in range of 0 to 15 defining the CSK file
+		from the above array to be used for creating image and prolog
+		signatures.
+		This parameter is optional and if omitted defaults to 0.
+
+- aes_key_file	- The string containing the path to the AES-256 symmetric key
+		file in ASCII text format.
+		The boot image will be encrypted if this parameter is included
+		in the configuration or left unencrypted if the parameter is
+		omitted.
+		This parameter is optional.
+
+- efuse_disable - Boolean parameter defining whether to disable access to efuses
+		in secure boot mode or not.
+		Can be either "true" or "false". The efuse access policy is
+		enforced by the BootROM.
+		This parameter is optional and if omitted defaults to "true".
+
+- jtag		- Parameters defining the JTAG behavior in trusted boot mode.
+		There are two parameters enclosed in curly brackets - "enable"
+		and "delay".
+		The "jtag.enable" boolean parameter allows to enable the JTAG
+		support in trusted boot mode (valid values "true" and "false").
+		The second parameter - "jtag.delay" (integer) defines delay
+		in milliseconds the BootROM waits before enabling the JTAG
+		connection in the HW. These parameters are optional and if
+		omitted default to "false" and 0 respectfully.
+
+- box_id	- 4 byte hexadecimal number to be used as box ID.
+		This value will be part of the secure extension in the trusted
+		boot image and should match the value burned in the appropriate
+		efuse field.
+		This parameter is optional and if omitted defaults to 0.
+
+- flash_id	- 4 byte hexadecimal number to be used as the flash ID.
+		This value will be part of the secure extension in trusted boot
+		image and should match the value burned in the appropriate efuse
+		field.
+		This parameter is optional and if omitted defaults to 0.
+
+- control	- Array of hexadecimal addresses to be set on each CP connected
+		to an AP in trusted mode.
+		It is required to add two addresses for each connected CP.
+		The first address points to the CP SecureBootControl register
+		and the second address points to the CP EfuseBurnControl
+		register.
+		Refer to your SoC documentation for details. For instance,
+		Armada-7040 SoC has a single CP connected to AP, so this array
+		has to list 2 register addresses. The Armada-8040 has two CPS
+		connected to AP, so this array has to include 4 register
+		addresses.
+		This parameter is optional.
+
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+Please refer to MARVELL WIRELESS Trusted Platform Tools Packages functional
+specification for details about trusted boot image components.
+The secure image configuration is defined by a single file atf_timN.txt located
+in the build folder. This file will be generated after compilation.
+There are some files in the A3700_utils/tim folder which are used for
+trusted image boot.
+
+- aes-256.txt - This file includes AES-256 encryption key values. This key
+		is used to do Encryption/Decryption on wtmi and obmi images
+		which should be programmed into efuse. it can be updated by the
+		image provider.
+
+- kak.txt - The file including (DSA Algorithm ID/Hash Algorithm ID/Key Size
+		in bits/RSA Public Exponent/RSA System Modulus/RSA Private Key)
+		is used to signature the TIM file, and will generate the OEM key
+		in "otphash.txt" The file is generated by Key Generation command
+		by KeyGeneration.txt file stored in tools/wtp/key folder.
+		This file is mandatory and can be updated according to
+		requirements for updating the Secure Trusted image.
+
+- CSK[0-F].txt	- These files contain different CSK Key information (Hash
+		Algorithm ID/Key Size in bits/Public Key Size in bits/Encrypt
+		Algorithm ID/RSA System Modulus). These files are also generated
+		by the Key Generation command with KeyGeneration.txt by setting
+		different parameters(i.e. Seed...).
+
+- timnsign.txt- This file defines which key is used to signature the TIMH file.
+		Indicate the CSK_INDEX of this file in fuse. All of parameters
+		(DSA Algorithm ID/Hash Algorithm ID/Key Size in bits/RSA Public
+		Exponent/RSA System Modulus/RSA Private Key) in the file should
+		be aligned with one of 16 KEY files in the tools/wtp/key folder.
+		This file is mandatory and and can be updated according to
+		requirements for updating Secure Trusted image.
+
+Work flow - Target Preparation
+------------------------------
+After the trusted boot mode is selected by the SoC eFuse, the BootROM enforces
+security checks upon boot image load. Therefore a right work flow is essential
+for target preparation and preventing the system from self-locking.
+
+A8K platforms
+~~~~~~~~~~~~~
+
+1. Build an image for trusted boot mode using the configuration file described
+   above and any additional settings required by ATF.
+   The image encryption option should not be used in this build, since the
+   resulting image should be compatible with non-trusted systems.
+2. Burn the image on the target board and boot it. The secure header will be
+   bypassed in non-trusted boot mode and the system will start as usual.
+3. Enable eFuse burning in the HW by connecting 1.8V source to AP_VHV, CP0_VHV
+   and CP1_VHV pins.
+   For example on A8K-DB Rev1.4 platform it is done by shortening on-board
+   jumpers JP36 and JP42.
+   Please refer to your Marvell Development Board manual or consult Marvell
+   representative
+   for the details about VHV connection setup on other supported HW platforms.
+4. Burn all required efuses to each efuse rows using "fuse prog" commands.
+   The trusted boot enable efuse should be burned last since any further
+   modifications to the SoC efuses will not be possible afterwards.
+   See the efuse programming example(HD and LD efuse rows) for A8K device below.
+   uboot fuse command::
+
+	/* HD efuse rows(64bits width) programming */
+	/* prog KAK_DIGEST key to efuse */
+	fuse prog -y 25 0 <KAK_DIGEST bit 31-0>    <KAK_DIGEST bit 55-32>   0x1
+	fuse prog -y 26 0 <KAK_DIGEST bit 95-56>   <KAK_DIGEST bit 111-96>  0x1
+	fuse prog -y 27 0 <KAK_DIGEST bit 143-112> <KAK_DIGEST bit 167-144> 0x1
+	fuse prog -y 28 0 <KAK_DIGEST bit 199-168> <KAK_DIGEST bit 223-200> 0x1
+	fuse prog -y 29 0 <KAK_DIGEST bit 255-224> 0x0 0x1
+
+	For example:
+	KAK key hash
+	8B3732C8F03D0C407F34200C206CA36B0701E47C9074034EDE97FBFF5BA6D778
+	fuse prog -y 25 0 0xC832378B 0x000C3DF0 0x1
+	fuse prog -y 26 0 0x20347F40 0x006C200C 0x1
+	fuse prog -y 27 0 0x01076BA3 0x00907CE4 0x1
+	fuse prog -y 28 0 0xDE4E0374 0x00FFFB97 0x1
+	fuse prog -y 29 0 0x78D7A65B 0x0 0x1
+
+	/* prog AES key to efuse */
+	fuse prog -y 32 0 <AES_KEY bit 31-0>    <AES_KEY bit 55-32>   0x1
+	fuse prog -y 33 0 <AES_KEY bit 95-56>   <AES_KEY bit 111-96>  0x1
+	fuse prog -y 34 0 <AES_KEY bit 143-112> <AES_KEY bit 167-144> 0x1
+	fuse prog -y 35 0 <AES_KEY bit 199-168> <AES_KEY bit 223-200> 0x1
+	fuse prog -y 36 0 <AES_KEY bit 255-224> 0x0 0x1
+
+	For example:
+	AES key
+	ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890
+	fuse prog -y 32 0 0x12EFCDAB 0x00785634 0x1
+	fuse prog -y 33 0 0xEFCDAB90 0x00563412 0x1
+	fuse prog -y 34 0 0xCDAB9078 0x003412EF 0x1
+	fuse prog -y 35 0 0xAB907856 0x0012EFCD 0x1
+	fuse prog -y 36 0 0x90785634 0x0 0x1
+
+	/* prog efuse row to select CSK valid - the first empty row specifies
+	 * the CSK index
+	 */
+	fuse prog -y 37~50 0 0x00000001 0x00000000 0x1
+
+	For example:
+	/* prog efuse row to select CSK 3 valid,need to set bit[0] in the efuse
+	 * rows 37, 38 and 39 to non zero values and leave the efuse row 40
+	 * intact
+	 */
+	fuse prog -y 37 0 0x00000001 0x00000000 0x1
+	fuse prog -y 38 0 0x00000001 0x00000000 0x1
+	fuse prog -y 39 0 0x00000001 0x00000000 0x1
+
+	/* prog flash ID to efuse row 30 */
+	fuse prog -y 30 0 0xbaddf00d 0x00000000 0x1
+
+	/* prog Box ID to efuse row 31 */
+	fuse prog -y 31 0 0xdeadbeef 0x00000000 0x1
+
+	/* LD efuse rows(256bits width) programming */
+	/* For A8k SoCs, both AP and SB0/1 have LD0 and LD1 efuse rows.
+	 * Only LD1 rows could be programmed.
+	 * Efuse row 65 is AP LD1 while row 67 is SB0 LD1. Row 69 is SB1 LD1.
+	 * /
+	fuse prog -y <RowIndex> 0 <bit 31-0> <bit 63-32> <bit 95-64>
+	<bit 127-96> <bit 159-128> <bit 191-160> <bit 223-192> <bit 255-224>
+
+	Below example shows secure boot fusing to select CP0_SPI as boot device.
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from AP perspective, here the value is 0x0 which means IHB to select
+	 * device. Please see Table(Boot Source Options) for boot device
+	 * selection in functional specifications document), enable CPU
+	 * Wakeup/Enable in AP LD1.
+	 */
+	fuse prog -y 65 0 0x00000001 0x0000C000 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	.. ATTENTION!::
+	Devices based on AP807 have different AP LD1 CPU-wakeup related fields.
+	For instance, the Armada-3900 DB board with boot device on AP SPI should
+	be programmed in the following way (boot device 0x2)::
+
+	fuse prog -y 65 0 0x00000011 0x00003000 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	.. Note::
+	When the secure boot device is located on AP interface, the value of CP
+	efuse specifying the boot device is not taken into account by the BootROM.
+	Therefore if, like in the example above, the secure boot device is AP SPI,
+	the CP (SB) efuse boot device may have any value.
+
+	Next example is for AP807-based SoCs with secure boot device on CP0_SPI::
+
+	fuse prog -y 65 0 0x00000001 0x00003000 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from SB perspective, the value is 0x32 which means boot from CP0_SPI
+	 * Please see the HW sepcificaiton document for a list of supported
+	 * values), disable ICU message LD1 in SB0
+	 */
+	fuse prog -y 67 0 0x000000c9 0x00000001 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from SB perspective, the value is 0x32 which means boot from CP0_SPI
+	 * Please see the HW sepcificaiton document for a list of supported
+	 * values), disable ICU message LD1 in SB1
+	 */
+	fuse prog -y 69 0 0x000000c9 0x00000001 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+   .. Note::
+	HD_efuse (bank ID 0~63's bit56-63 must be 0x0 according to Functional
+	Specification document). Efuse row 64,66,68 are LD0 and read-only.
+
+5. Verify the efuse values for correct efuse rows using "fuse read" commands.
+6. Restart the system and ensure the secure boot authentication stage has been
+   passed.
+7. If the image encryption option is required, build a new image with image
+   encryption enabled and burn it to the system boot device using the regular
+   "bubt" command.
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+1. Create an UNTRUSTED boot image with eFuse command module support (as stated
+   in the "eFuses" chapter above) and burn it on the target flash device using
+   the regular "bubt" command.
+2. Create a TRUSTED boot image with Encryption option (as stated in "Boot image
+   format" chapter above)and save it for later use. Actually, encryption option
+   is enabled by default to "AES-256-CBC"(only AES-256 CBC is supported).
+3. Boot the target board with the UNTRUSTED boot image.
+4. Run the below commands in uboot before burning TRUSTED boot image
+	a. efuse write ENCRYPTION <binary value> (it always is 10 -- enable
+	   encryption for primary type image)
+	b. efuse write AES256_KEY <AES-256 key value>
+	c. efuse write BOOT_DEVICE <device_type>
+	d. efuse write KAK_DIGEST <otphash_value>
+	e. efuse write CSK_INDEX <key_index>
+	f. efuse write OPER_MODE <mode_type> (mode_type should be always 2).
+	g. efuse DEV_DEPLOY <deploy_value> (1 - enable/0 - disable), this
+	   command will set the chip into trusted mode.
+	   It will also hide the AES-256 key.
+5. Burn the TRUSTED boot image using regular "bubt" command.
+6. Reset the board and verify that the trusted boot mode works.
+
+.. Note::
+	a. binary value: supports 00/01/10/11 disable/.../enable encryption for
+	   primary type image/...
+	b. AES-256 value: AES-256 symmetric encryption key in HEX format.
+	   The values are in the aes-256.txt file.
+	c. device_type: SPINOR, SPINAND, EMMCNORM..., select device flash
+	   according to requirement.
+	   After selecting device_type by efuse, the device could not be changed
+	   anymore. The device flash is locked.
+	d. otphash_value: OEM key generated by tbb tool when signature the TIM
+	   header with kak.txt
+	e. key_index: Range 0 to 15 in DEC format to select which CSK KEY is
+	   used.
+	f. mode_type: Operation mode in range of 0 to 3, where mode 2 is Trusted
+	   boot, security check is performed on the boot device content
+	g. deploy_value: Enable(1) this feature will mask AES-256 KEY value. The
+	   command is optional. When secure trusted images need to hide AES-256
+	   KEY value to stop reading.
+
+<otphash_value>
+   When the trusted boot image is created, the the TBB tool saves the OEM key
+   in OtpHash.txt. This digest value is otphash_value which is used for efuse
+   KAK_DIGEST command.
+   The OtpHash.txt file lists the otphash_value in groups of 4-bytes values,
+   organized in the following
+   order::
+
+       LSB
+       ...
+       ...
+       MSB
+
+   These otphash_value should be converted to a single 32-bytes value for
+   eFuse burning::
+
+       MSB ... ... ... LSB.
+
+   For instance, the following otphash_value::
+
+       0x1887C298
+       0x59C9AFD9
+       0x6E814E34
+       0x25CD518B
+       0x3CDB7EED
+       0x33CC58B1
+       0x2C69997A
+       0xC27B7242
+
+   Will be used in the following form in eFuse KAK digest write command::
+
+       efuse write KAK_DIGEST C27B72422C69997A33CC58B13CDB7EED25CD518B6E814E3459C9AFD91887C298
+
+<key_index>
+   key_index is the index of the "timnsign.txt", refer to "timnsign.txt" in the
+   previous chapter for detailed description.
+   For instance, the following sample content is from timnsign.txt::
+
+      DSA Algorithm ID:                7		; Signed with CSK6
+      Hash Algorithm ID:               32
+      Key Size in bits:                2048
+      RSA Public Exponent
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+	  RSA System Modulus:
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+	  RSA Private Key:
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+
+   The key_index will be used in the following form in eFuse CSK_INDEX
+   write command::
+
+      efuse write CSK_INDEX 6
+
+i.e.
+
+Default commands before bubt Secure Trusted boot image::
+
+	efuse write ENCRYPTION 10
+	efuse write AES256_KEY 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF
+	efuse write BOOT_DEVICE SPINOR
+	efuse write KAK_DIGEST C27B72422C69997A33CC58B13CDB7EED25CD518B6E814E3459C9AFD91887C298
+	efuse write CSK_INDEX 6
+	efuse write OPER_MODE 2
+
+
+Authentication/Encryption Keys Generation and Selection
+-------------------------------------------------------
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+
+A3700 platform supports selecting 16 authentication key files(CSK[0-F].txt
+in the A3700_utils/tim/trusted/keys/ folder) for trusted boot.
+All of the authentication keys files must be generated by TBB tool before
+building Secure Trusted image.
+
+KAK.txt (Keysignauture file) is also generated by using the same Key Generation
+command.
+
+From the above chapters decriptions, in order to update the authentication keys
+of the Secure Trusted Image, we could update two files (kak.txt/timnsign.txt)
+stored in the A3700_utils/tim folder.
+Please follow the below steps to update these files.
+
+1. Key Generation command::
+
+       tbb_linux.exe -G <<path\>KeyGeneration.txt>
+
+   Normally KeyGenernation.txt is stored in the A3700_utils/tim/trusted/keys/
+   folder. If the file is a directory other than the directory from which TBB
+   is executed, then a file path must also be provided.
+
+2. KeyGeneration.txt
+
+   Content::
+
+	Seed: Trusted platform
+	Key ID: DSIG
+	Encrypt Algorithm ID: 7
+	Hash Algorithm ID: 32
+	Key Size: 2048
+	Output Binary Filename:
+	Output Text Filename: ./KAK.txt
+
+   - Seed - The ASCII seed value can be any continuous ASCII alphanumeric
+	sequence delimited by white-space. TBB hashes the ASCII seed value to
+	a 32-bit value and uses that value to seed the random number generator.
+
+   - Key ID - The ASCII tag can be any 4-character string. i.e. DSIG -- means
+	that it will be created for digital signature.
+
+   - Encrypt Algorithm ID - i.e.7 = PKCS_2_2(ippcp). Currenlty, only 7 is
+	supported.
+
+   - Hash Algorithm ID - Hash Algorithm uses the Hash Algorithm ID to hash the
+	data associated with the key.
+	i.e. 20 = SHA160, 32 = SHA256, 64 = SHA512. Our A3700 use 32 as default.
+
+   - Key Size - For PKCS, the supported key sixe in bits is 2048.
+
+   - Output Binary Filename - if blank, no binary file is generated.
+	Normally, we keep this empty.
+
+   - Output Text Filename - if a path\filename is provided, TBB outputs an
+	ASCII txt file containing the generated key components.
+
+3. Update kak.txt files according the KAK.txt file. Copy the KAK.txt to
+   the A3700_utils/tim/trusted folder and update some parameters
+   Rename KAK.txt to kak.txt in the A3700_utils/tim folder.
+   Change the kak.txt file headers in the content:
+
+       Key ID: DSIG
+       Encrypt Algorithm ID: 7
+       ... ... ... ...
+
+   to below format::
+
+       DSA Algorithm ID:                7		; Signed with KAK
+       ... ... ... ...
+
+   The kak.txt is used to be generated to OtpHash.txt mentioned in the above
+   chapter.
+
+4. Update timnsign.txt file content to select CSK_Index
+
+   Update all parameters(DSA Algorithm ID/Hash Algorithm ID/Key Size in bits
+   /RSA Public Exponent/RSA System Modulus/RSA Private Key) value in
+   timnsign.txt according to CSK[0-F].txt files located in tools/wtp/key folder.
+   For instance, if you decide to use CSKA file (eFsue write CSK_INDEX 10),
+   you should update timnsign.txt's parameters aligned with CSKA.txt file.
diff --git a/doc/mvebu/uart_boot.txt b/doc/mvebu/uart_boot.txt
new file mode 100644
index 0000000000..90dd6f3d56
--- /dev/null
+++ b/doc/mvebu/uart_boot.txt
@@ -0,0 +1,116 @@
+UART boot
+=========
+
+UART boot for Armada-70x0/80x0/3900 and OcteonTX2 CN913x
+----------------------------------------------------------
+
+UART recovery is a method of loading boot flash image using Xmodem protocol
+when the target board is used for the first time or when the board fails to
+start due to invalid flash image located on its boot device.
+
+1. The entire process is greatly simplified with a dedicated script usage.
+   The script is located under /tools folder and named mrvl_uart.sh.
+   This script supports 2 parameters - the serial interface and the
+   path to flash image::
+
+	mrvl_uart.sh <port> <file>
+
+2. Power on the board, connect it to the Linux workstation using serail cable,
+   run the script and follow the on-screen instructions.
+   Below is the example for A-8040 board connected to /dev/ttyUSB0 serial line::
+
+	./tools/mrvl_uart.sh /dev/ttyUSB0 /srv/tftp/flash-image-a8040-db.bin
+
+   The script generates UART escape sequence pattern and requests
+   the target board reset::
+
+	Using device connected on serial port "/dev/ttyUSB0"
+	Loading flash image file "/srv/tftp/flash-image-a8040-db.bin"
+	Recovery will run at 115200 baud
+	========================================
+	Press the "Reset" button on the target board and the "Enter" key on the host keyboard simultaneously
+
+3. Once "Enter" key is pressed, the script sends escape pattern to the target
+   board (interrupting normal boot flow) followed by X-modem transfer of the flash image.
+   When the download process ends, the "minicom" application is started on the
+   same serial port, presenting u-boot startup messages.
+
+4. Note that after downloading flash image using UART recovery it is still required
+   to burn the image on the target board boot device, since serial image boot uses
+   binary loaded to the target DRAM.
+
+UART boot for Armada-3700 platform
+----------------------------------
+
+Note that WtpDownload application (v3.3.11.15) is Linux host tool used
+to do the UART boot. The source code and binaries is provided as part
+of A3700 utility package, which is out of the bootloader source tree.
+The package is located in same folder of the bootloader source. Please
+refer to the readme.txt in wtptp/src/Wtpdownloader_Linux folder for the
+prerequisitions of the tool.
+
+The following shows the detail steps of UART boot. The target board is
+connected to /dev/ttyUSB0 in this example, replace the port number
+according to your set-up.
+
+1. The normal ATF build procedure for A3700 target creates a folder
+   with all the images required for UART boot under ATF build output
+   folder (A.K.A., build/a3700/release or build/a3700/debug). Make
+   sure u-boot was built before ATF, see detail in build.txt.
+
+2. Make sure the target board is in UART mode and ">" prompt is
+   presented on the connected terminal. Pressing "Enter" in this mode
+   will show "E" and then ">" again.
+   There is a way to stop the target board booting from other sources,
+   SPI flash for example, and switch to UART boot mode, by using the
+   WtpDownload application::
+
+	(power down the board or hold the RESET button)
+	sudo stty -F /dev/ttyUSB0 clocal
+	(power up the board or release the RESET button)
+	./WtpDownload_linux -P UART -C 0 -R 115200 -Y
+
+3. Stop the terminal emulator program on the UART port attached to the
+   target board (minicom) for releasing the serial port and allowing
+   an application to use it for image download.
+
+4. Disable the TTY modem control signals::
+
+	sudo stty -F /dev/ttyUSB0 clocal
+
+5. Start the image download application in the ATF build folder using
+   the following parameters.
+
+   WTP downloader usage example - non-secure boot::
+
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E
+
+   WTP downloader usage example - secure boot::
+
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF_TRUSTED.bin \
+		-B ./uart-images/TIMN_ATF_TRUSTED.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E
+
+   Note that "-E" parameter can be dropped from the above commands.
+   If you do this, check that the BootROM UART download mode is
+   selected in paragraph 2, type in terminal "wtp" without quotes and
+   press Enter. Then follow the procedure described in paragraph 3.
+   This command will switch the BootROM to WTP download mode. The same is
+   archieved by "-E" parameter in latest downloader SW.
+
+6. After the process is finished, start the terminal emulator
+   program (minicom) on that the UART port attached to the target
+   board and ensure the U-Boot prompt is reached.
+
+Note that steps 2-5 can be simplified with a single command as below::
+
+	sudo stty -F /dev/ttyUSB0 clocal
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E -O
diff --git a/doc/mvebu/uboot_cmd.txt b/doc/mvebu/uboot_cmd.txt
new file mode 100644
index 0000000000..7c182d2605
--- /dev/null
+++ b/doc/mvebu/uboot_cmd.txt
@@ -0,0 +1,366 @@
+.. _uboot_cmd:
+
+U-Boot Commands
+===============
+
+For standard U-Boot commands (mmc, usb, sata, fdt), please refer to denx
+mainline documentation.
+
+
+Base command
+------------
+Base command provides the ability to change the base address of a memory command
+(ir, md, mm, etc..).
+
+   Examples:
+
+	(1) Show the current base address::
+
+		> base
+
+		Base Address: 0x00000000
+
+	(2) change the base address::
+
+		> base 0xf2000000
+
+		Base Address: 0xf2000000
+
+
+BUBT (Burn ATF) command
+-----------------------
+Bubt command is used to burn a new ATF image to flash device.
+
+The bubt command gets the following parameters: ATF file name, destination
+device and source device::
+
+	bubt [file-name] [destination [source]]
+
+	- file-name:	Image file name to burn. default = flash-image.bin
+	- destination:	Flash to burn to [spi, nand, mmc]. default = active flash
+	- source:	Source to load image from [tftp, usb]. default = tftp
+
+Examples:
+
+	``bubt``			- Burn flash-image.bin from tftp to active flash
+	``bubt latest-spi.bin nand``	- Burn latest-spi.bin from tftp to NAND flash
+
+.. Note::
+	- For the TFTP interface set serverip and ipaddr.
+	- To burn image to SD/eMMC device, the target is defined
+	  by parameters CONFIG_SYS_MMC_ENV_DEV and CONFIG_SYS_MMC_ENV_PART.
+
+Bubt command details (burn image step by-step)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+This section describes bubt command flow:
+
+1. Fetch the requested ATF image from an available interface (USB/SD/SATA/XDB, etc.)
+   into the DRAM, and place it at <load_address>
+   Example: when using the FAT file system on USB flash device::
+
+	# usb reset
+	# fatls usb 0 (see files in device)
+	# fatload usb 0 <load_address> <file_name>
+
+2. Erase the target device::
+
+	- NAND:		# nand erase 0 100000
+	- SPI:		# sf probe 0
+			# sf erase 0 100000
+	- SD/eMMC:	# mmc dev <dev_id> <boot_partition>
+
+   .. Note::
+	- The eMMC has 2 boot partitions (BOOT0 and BOOT1) and a user data
+	  partition (DATA). The boot partitions are numbered as partition 1 and
+	  2 in MMC driver. Number 0 is used for user data partition and should
+	  not be utilized for storing boot images and U-Boot environment in RAW
+	  mode since it will break file system structures usually located here.
+
+	  The default boot partition is BOOT0. It is selected by the following
+	  parameter::
+
+		CONFIG_SYS_MMC_ENV_PART=1
+
+	  Valid values for this parameter are 1 for BOOT0 and 2 for BOOT1.
+	  Please never use partition number 0 here!
+
+	- The partition number is ignored if the target device is SD card.
+
+	- The boot image offset starts at block 0 for eMMC and block 1 for SD
+	  devices. The block 0 on SD devices is left for MBR storage.
+
+3. Write the ATF image::
+
+	- NAND:		# nand write <load_address> 0 <ATF Size>
+	- SPI:		# sf write <load_address> 0 <ATF Size>
+	- SD/eMMC:	# mmc write <load_address> [0|1] <ATF Size>/<block_size>
+
+
+hw_info command
+---------------
+hw_info commands are used for the following:
+
+  - Store HW manufacturing information to EEPROM during the board production in
+    order to keep these parameters, regardless of the boot-loader upgrading.
+  - Load HW manufacturing information from the EEPROM to the relevant U-Boot
+    env variable in order to take effect.
+
+.. Note::
+	hw_info commands are only relevant for Marvell boards that use the
+	EEPROM device to save the HW manufacturing information.
+
+
+hw_info usage
+~~~~~~~~~~~~~
+- ``hw_info dump [name]``  - Dump all or specific HW parameters from the EEPROM.
+
+- ``hw_info load [name]``  - Load all or specific HW parameters from the EEPROM
+			     to env variables. The hw_info load will be
+			     performed automatically with the ``env default -a``
+			     operation, however it requires that the user
+			     executes ``env save`` manually, later on.
+
+- ``hw_info store [name]`` - Store all or specific HW parameters from env
+			     variables to the EEPROM. Before the operation, the
+			     expected env varibles should already be saved to
+			     env by using the command setenv or editenv.
+
+Supported HW information parameters:
+
+	- board_id      board ID
+	- pcb_slm       PCB system level manufacturing part ID (SLM)
+	- pcb_rev       PCB revision number
+	- eco_rev       ECO revision number
+	- pcb_sn        PCB SN
+	- ethaddr       first MAC address
+	- eth1addr      second MAC address
+	- eth2addr      third MAC address
+	- eth3addr      fourth MAC address
+
+Examples
+~~~~~~~~
+1. Initialize or change HW manufacturing information for the Armada-3700::
+
+	# setenv board_id 0020
+	# setenv pcb_slm 1443
+	# setenv pcb_rev 10
+	# setenv eco_rev 12
+	# setenv pcb_sn 0028
+	# setenv ethaddr 00:50:43:00:00:01
+	# setenv eth1addr 00:50:43:00:00:02
+	# setenv eth2addr 00:50:43:00:00:03
+	# setenv eth3addr 00:50:43:00:00:04
+	# saveenv
+	# hw_info store
+
+2. Restore HW manufacturing information env variables after the resetenv command::
+
+	# hw_info load
+	# saveenv (optional since hw_info load will ask user whether to saveenv)
+
+3. Dump HW parameters from EEPROM
+
+	# hw_info dump
+
+
+ir command
+----------
+Reading and changing internal register values.
+
+Displays the contents of the internal register in 2 forms, hex and binary.
+It is possible to change the value by writing a hex value beginning with 0x
+or by writing 0 or 1 in the required place.
+Pressing enter without any value keeps the value unchanged.
+
+NOTE: before using the ir command, the base address (using base command,
+described above) must be set:
+
+	- Armada3700	-	0xd0000000
+	- AP806		-	0xf0000000
+	- CP110-0	-	0xf2000000
+	- CP110-1	-	0xf4000000
+
+Example::
+
+	# base 0xf4000000
+	Base Address: 0xf4000000
+	# ir 440000
+	Internal register 0x440000 value : 0x33333333
+
+	31      24        16         8         0
+	 |       |         |         |         |
+	OLD: 0011-0011-0011-0011-0011-0011-0011-0011
+	NEW:             00           1			/* Set specific bits */
+
+	New value = 0x33033b33
+
+	# ir 440000
+	Internal register 0x440000 value : 0x33033b33
+
+	31      24        16         8         0
+	 |       |         |         |         |
+	OLD: 0011-0011-0000-0011-0011-1011-0011-0011
+	NEW:	/* Press enter to keep the value unchanged */
+
+
+
+mg_boot command
+---------------
+mg_boot command allows to load MG CM3 firmware and emulate MG's CM3 UART
+
+Introduced commands allows to load MG CM3 firmware into MG's CM3 SRAM and
+release it from reset. The MG's CM3 doesn't have hardware UART but after
+enabling CMD_MVEBU_MG_BOOT option, UART emulation can be used and console
+input/output can be redirected to MG's CM3
+
+The MG's CM3 UART emulation is done in the shared memory where both MG's CM3
+and ARMv8 has access to. The CM3 instead of putting some characters into UART
+registers, puts char into memory which can be read by ARMv8 U-Boot.
+
+Receiving character from CM3 perspective: The CM3 polls some other part of
+shared memory, if it finds some new chars it process it (instead of reading UART
+register). Thanks to that, ARMv8 U-Boot can send some characters to this
+shared memory and the CM3 will be able to receive and process them.
+
+A complementary patch can be found in FreeRTOS github repo:
+"a8k_mg: add uart emulation support"
+
+parameters:
+
+	- remote_file_name - TFTP image path to be loaded to MG CM3 SRAM
+	- cp_nr - CPx number [0 | 1]
+	- io_redirect - redirect console IO to CM3 [0=no (deflt) | 1=yes]
+
+Load the FreeRTOS firmware and switch to emulated MG's CM3 console::
+
+	# mg_boot path/to/tftpfile/RTOSDemo-cm3-mg.bin 0 1
+	# Using egiga1 device
+	# TFTP from server 10.2.0.102; our IP address is 10.2.2.182
+	# Filename 'path/to/tftpfile/RTOSDemo-cm3-mg.bin'.
+	# Load address: 0xf2100000
+	# Loading: #############
+	# 	 1.3 MiB/s
+	# done
+	# Bytes transferred = 61801 (f169 hex)
+	# Opening MG CM3 console..
+	# 	Use "poweroff" for powerdown CM3 and falling back to u-boot prompt
+	# 	Use "exit" falling back to u-boot prompt (CM3 still running)
+	#
+	#
+	# 	<some FreeRTOS log>
+
+.. Note::
+
+   Be aware that A8K MG's CM3 doesn't have hardware UART, therefore are emulated
+   console was prepared. After loading the CM3 firmware and using console
+   redirect (io_redirect set to 1), the emulated console of CM3 takes control
+   over A8K U-Boot's console.
+
+The logs from CM3 are not printed in real time, they are buffered in shared
+memory. To dump buffered log just:
+
+	- Press the 'Enter' key (this is needed to see logs that are buffered by
+	  FreeRTOS and they are not a direct result of entered command)
+	- Enter a command followed by 'Enter' key (this will dump log which is
+	  direct results of entered command)
+
+Falling back to u-boot console:
+
+  - To exit from it (and leave the CM3 running) do::
+
+	# MG-CM3>exit
+
+  - To exit and shutdown CM3 do::
+
+	# MG-CM3>poweroff
+
+
+mg_console command
+------------------
+
+mg_console command allows to switch console IO to CPn MG CM3. It is useful
+in cases where:
+
+- we run mg_boot without console IO redirection
+- we fall back to u-boot console but after some time we want to switch
+  back console redirection to CPn MG CM3
+
+parameters:
+- cp_nr - CPx number [0 | 1]
+
+Returning to MG CM3's console:
+
+If there is need to check status in CM3, we can return by running the command::
+
+	# Marvell>> mg_console 0
+
+Afterwards, we can dump what was buffered by FreeRTOS as described earlier by:
+
+- Pressing the 'Enter' key (this is needed to see logs that are buffered by FreeRTOS)
+- Enter new command followed by 'Enter' key (this will dump log which is direct
+  results of entered command)
+
+
+rx_training command
+-------------------
+
+RX training allows to improve link quality (for SFI/XFI mode) by running training
+sequence, this allows to reach better link quality then using static configuration.
+
+When running rx_training sequence, the user must state CP index (0/1/2) and comphy ID (0/5).
+
+If after rx training procedure the kernel will be booted (without
+resetting/rebooting the board), Linux will skip comphy power off and power on
+sequence, so the user can test the link quality in Linux.
+
+After board reset/reboot the comphy parameters for SFI/XFI are the default one
+(the training results are not valid anymore after reset).
+
+.. seealso::
+        Please refer to :ref:`porting` section: Comphy Porting.
+
+SAR (Sample at Reset) commands
+-------------------------------
+SAR commands are used to toggle the available Sample at Reset modes.
+
+.. Note::
+	- SAR commands are only relevant for Marvell boards that use EEPROM
+	  device.
+	- At first use, a reset should be done to SAR fields values with
+	  ``sar default`` command.
+	- In order to use SAR fields values a jumper should be in:
+
+		- jumper 52 in a8040-db
+		- jumper 38 in a7040-db
+
+	- After a SAR write command, a reset is required for the changes to
+	  take effect.
+
+Examples
+~~~~~~~~
+- ``sar list`` - Get the list of possible fields.
+- ``sar list <field>`` - Get the list of possible values for a specific field.
+- ``sar read`` - Get the current values of all available SAR fields.
+- ``sar read <field>`` - Get the current value of a specific SAR field.
+- ``sar write <field> <value>`` - Set the required value for a specific field.
+   A reset is required after a SAR write command for the changes to take effect.
+- ``sar default`` - Reset all writable SAR fields back to their default values.
+- ``sar default <field>`` - Reset SAR field back to his default value.
+
+The list of the Sample At Reset possible fields and values is defined in the
+device tree. For more information, please refer to
+doc/device-tree-bindings/misc/mvebu-sar.txt.
+
+
+tsen command
+-------------
+tsen command is used to display the SoC thermal sensor readout.
+When tsen command is executed, AP's and CP's temperature is sampled:
+
+Example::
+
+	Running 'tsen' on Armada-7040:
+
+	Marvell>> tsen
+	Thermal.f06f8084 = 49
+	Thermal.f2400070 = 53
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 350acf81f3..700a636fad 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -40,6 +40,8 @@ source "drivers/firmware/Kconfig"
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/fuse/Kconfig"
+
 source "drivers/gpio/Kconfig"
 
 source "drivers/hwspinlock/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index a4bb5e4975..99d0f5ada1 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -31,10 +31,17 @@ ifndef CONFIG_TPL_BUILD
 ifdef CONFIG_SPL_BUILD
 
 obj-$(CONFIG_SPL_BOOTCOUNT_LIMIT) += bootcount/
+
+ifneq ($(EXT_DDR_PATH),)
+DDR_PATH := $(EXT_DDR_PATH)
+else
+DDR_PATH := ddr/marvell/a38x/
+endif
+
 obj-$(CONFIG_SPL_CPU_SUPPORT) += cpu/
 obj-$(CONFIG_SPL_CRYPTO_SUPPORT) += crypto/
 obj-$(CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT) += ddr/fsl/
-obj-$(CONFIG_ARMADA_38X) += ddr/marvell/a38x/
+obj-$(CONFIG_ARMADA_38X) += $(DDR_PATH)
 obj-$(CONFIG_ARMADA_XP) += ddr/marvell/axp/
 obj-$(CONFIG_$(SPL_)ALTERA_SDRAM) += ddr/altera/
 obj-$(CONFIG_ARCH_IMX8M) += ddr/imx/imx8m/
@@ -105,6 +112,7 @@ obj-y += memory/
 obj-y += pwm/
 obj-y += reset/
 obj-y += input/
+obj-y += fuse/
 # SOC specific infrastructure drivers.
 obj-y += smem/
 obj-y += soc/
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 9a08575053..bc31a715c9 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -1,5 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
  * Copyright (C) Freescale Semiconductor, Inc. 2006.
  * Author: Jason Jin<Jason.jin@freescale.com>
  *         Zhang Wei<wei.zhang@freescale.com>
@@ -26,6 +28,10 @@
 #include <dm/device-internal.h>
 #include <dm/lists.h>
 
+#if defined(CONFIG_ARCH_OCTEONTX)
+#include <asm/arch/board.h>
+#endif
+
 static int ata_io_flush(struct ahci_uc_priv *uc_priv, u8 port);
 
 #ifndef CONFIG_DM_SCSI
@@ -259,7 +265,7 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 		/* Bring up SATA link. */
 		ret = ahci_link_up(uc_priv, i);
 		if (ret) {
-			printf("SATA link %d timeout.\n", i);
+			debug("SATA link %d timeout.\n", i);
 			continue;
 		} else {
 			debug("SATA link ok.\n");
@@ -292,7 +298,7 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 			continue;
 		}
 
-		printf("Target spinup took %d ms.\n", j);
+		debug("Target spinup took %d ms.\n", j);
 		if (j == WAIT_MS_SPINUP)
 			debug("timeout.\n");
 		else
@@ -386,38 +392,38 @@ static void ahci_print_info(struct ahci_uc_priv *uc_priv)
 	else
 		scc_s = "unknown";
 #endif
-	printf("AHCI %02x%02x.%02x%02x "
-	       "%u slots %u ports %s Gbps 0x%x impl %s mode\n",
-	       (vers >> 24) & 0xff,
-	       (vers >> 16) & 0xff,
-	       (vers >> 8) & 0xff,
-	       vers & 0xff,
-	       ((cap >> 8) & 0x1f) + 1, (cap & 0x1f) + 1, speed_s, impl, scc_s);
-
-	printf("flags: "
-	       "%s%s%s%s%s%s%s"
-	       "%s%s%s%s%s%s%s"
-	       "%s%s%s%s%s%s\n",
-	       cap & (1 << 31) ? "64bit " : "",
-	       cap & (1 << 30) ? "ncq " : "",
-	       cap & (1 << 28) ? "ilck " : "",
-	       cap & (1 << 27) ? "stag " : "",
-	       cap & (1 << 26) ? "pm " : "",
-	       cap & (1 << 25) ? "led " : "",
-	       cap & (1 << 24) ? "clo " : "",
-	       cap & (1 << 19) ? "nz " : "",
-	       cap & (1 << 18) ? "only " : "",
-	       cap & (1 << 17) ? "pmp " : "",
-	       cap & (1 << 16) ? "fbss " : "",
-	       cap & (1 << 15) ? "pio " : "",
-	       cap & (1 << 14) ? "slum " : "",
-	       cap & (1 << 13) ? "part " : "",
-	       cap & (1 << 7) ? "ccc " : "",
-	       cap & (1 << 6) ? "ems " : "",
-	       cap & (1 << 5) ? "sxs " : "",
-	       cap2 & (1 << 2) ? "apst " : "",
-	       cap2 & (1 << 1) ? "nvmp " : "",
-	       cap2 & (1 << 0) ? "boh " : "");
+	debug("AHCI %02x%02x.%02x%02x "
+	      "%u slots %u ports %s Gbps 0x%x impl %s mode\n",
+	      (vers >> 24) & 0xff,
+	      (vers >> 16) & 0xff,
+	      (vers >> 8) & 0xff,
+	      vers & 0xff,
+	      ((cap >> 8) & 0x1f) + 1, (cap & 0x1f) + 1, speed_s, impl, scc_s);
+
+	debug("flags: "
+	      "%s%s%s%s%s%s%s"
+	      "%s%s%s%s%s%s%s"
+	      "%s%s%s%s%s%s\n",
+	      cap & (1 << 31) ? "64bit " : "",
+	      cap & (1 << 30) ? "ncq " : "",
+	      cap & (1 << 28) ? "ilck " : "",
+	      cap & (1 << 27) ? "stag " : "",
+	      cap & (1 << 26) ? "pm " : "",
+	      cap & (1 << 25) ? "led " : "",
+	      cap & (1 << 24) ? "clo " : "",
+	      cap & (1 << 19) ? "nz " : "",
+	      cap & (1 << 18) ? "only " : "",
+	      cap & (1 << 17) ? "pmp " : "",
+	      cap & (1 << 16) ? "fbss " : "",
+	      cap & (1 << 15) ? "pio " : "",
+	      cap & (1 << 14) ? "slum " : "",
+	      cap & (1 << 13) ? "part " : "",
+	      cap & (1 << 7) ? "ccc " : "",
+	      cap & (1 << 6) ? "ems " : "",
+	      cap & (1 << 5) ? "sxs " : "",
+	      cap2 & (1 << 2) ? "apst " : "",
+	      cap2 & (1 << 1) ? "nvmp " : "",
+	      cap2 & (1 << 0) ? "boh " : "");
 }
 
 #if defined(CONFIG_DM_SCSI) || !defined(CONFIG_SCSI_AHCI_PLAT)
@@ -506,6 +512,11 @@ static int ahci_fill_sg(struct ahci_uc_priv *uc_priv, u8 port,
 		ahci_sg->addr =
 		    cpu_to_le32((unsigned long) buf + i * MAX_DATA_BYTE_COUNT);
 		ahci_sg->addr_hi = 0;
+#ifdef CONFIG_PHYS_64BIT
+		ahci_sg->addr_hi =
+		    cpu_to_le32((u32)(((u64)(buf + i * MAX_DATA_BYTE_COUNT)
+					>> 16) >> 16));
+#endif
 		ahci_sg->flags_size = cpu_to_le32(0x3fffff &
 					  (buf_len < MAX_DATA_BYTE_COUNT
 					   ? (buf_len - 1)
@@ -587,7 +598,7 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	 * and its scatter-gather table
 	 */
 	pp->cmd_tbl = virt_to_phys((void *)mem);
-	debug("cmd_tbl_dma = %lx\n", pp->cmd_tbl);
+	debug("cmd_tbl_dma = %llx\n", pp->cmd_tbl);
 
 	mem += AHCI_CMD_TBL_HDR;
 	pp->cmd_tbl_sg =
@@ -595,8 +606,20 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 
 	writel_with_flush((unsigned long)pp->cmd_slot,
 			  port_mmio + PORT_LST_ADDR);
+#ifdef CONFIG_PHYS_64BIT
+	if (uc_priv->cap & HOST_64BIT)
+		writel_with_flush(
+			cpu_to_le32((u32)(((u64)(pp->cmd_slot) >> 16) >> 16)),
+			port_mmio + PORT_LST_ADDR_HI);
+#endif
 
 	writel_with_flush(pp->rx_fis, port_mmio + PORT_FIS_ADDR);
+#ifdef CONFIG_PHYS_64BIT
+	if (uc_priv->cap & HOST_64BIT)
+		writel_with_flush(
+			cpu_to_le32((u32)(((pp->rx_fis) >> 16) >> 16)),
+			port_mmio + PORT_FIS_ADDR_HI);
+#endif
 
 #ifdef CONFIG_SUNXI_AHCI
 	sunxi_dma_init(port_mmio);
@@ -608,6 +631,18 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 
 	debug("Exit start port %d\n", port);
 
+#if CONFIG_ARCH_OCTEONTX
+	/*
+	 * Skip interface busy check based on error and status
+	 * information from task file data register as these boards
+	 * have port multiplier and device is always present
+	 * U-boot lacks port multiplier support hence this ugly hack.
+	 */
+
+	if (octeontx_board_has_pmp())
+		return 0;
+#endif
+
 	/*
 	 * Make sure interface is not busy based on error and status
 	 * information from task file data register before proceeding
@@ -639,6 +674,17 @@ static int ahci_device_data_io(struct ahci_uc_priv *uc_priv, u8 port, u8 *fis,
 		return -1;
 	}
 
+	/*
+	 * If the device was plugged after boot, the port is not initialized
+	 * Try to restart the port for supporting device hot plug-in
+	 */
+	if (pp->cmd_tbl == 0) {
+		if (ahci_port_start(uc_priv, port)) {
+			printf("Cannot restart port %d\n", port);
+			return -1;
+		}
+	}
+
 	memcpy((unsigned char *)pp->cmd_tbl, fis, fis_len);
 
 	sg_count = ahci_fill_sg(uc_priv, port, buf, buf_len);
@@ -927,6 +973,8 @@ static int ahci_scsi_exec(struct udevice *dev, struct scsi_cmd *pccb)
 #endif
 	int ret;
 
+	debug("ahci_scsi_exec: CMD %d\n", pccb->cmd[0]);
+
 	switch (pccb->cmd[0]) {
 	case SCSI_READ16:
 	case SCSI_READ10:
@@ -970,7 +1018,7 @@ static int ahci_start_ports(struct ahci_uc_priv *uc_priv)
 	for (i = 0; i < uc_priv->n_ports; i++) {
 		if (((linkmap >> i) & 0x01)) {
 			if (ahci_port_start(uc_priv, (u8) i)) {
-				printf("Can not start port %d\n", i);
+				debug("AHCI Can not start port %d\n", i);
 				continue;
 			}
 		}
@@ -1174,6 +1222,9 @@ int ahci_probe_scsi(struct udevice *ahci_dev, ulong base)
 	 */
 	uc_plat->max_id = max_t(unsigned long, uc_priv->n_ports,
 				uc_plat->max_id);
+	/* If port count is less than max_id, update max_id */
+	if (uc_priv->n_ports < uc_plat->max_id)
+		uc_plat->max_id = uc_priv->n_ports;
 
 	return 0;
 }
@@ -1182,10 +1233,17 @@ int ahci_probe_scsi(struct udevice *ahci_dev, ulong base)
 int ahci_probe_scsi_pci(struct udevice *ahci_dev)
 {
 	ulong base;
+	u16 vendor, device;
 
 	base = (ulong)dm_pci_map_bar(ahci_dev, PCI_BASE_ADDRESS_5,
 				     PCI_REGION_MEM);
 
+	dm_pci_read_config16(ahci_dev, PCI_VENDOR_ID, &vendor);
+	dm_pci_read_config16(ahci_dev, PCI_DEVICE_ID, &device);
+
+	if (vendor == 0x177d && device == 0xa01c)
+		base = (ulong)dm_pci_map_bar(ahci_dev, PCI_BASE_ADDRESS_0,
+					     PCI_REGION_MEM);
 	return ahci_probe_scsi(ahci_dev, base);
 }
 #endif
diff --git a/drivers/fuse/Kconfig b/drivers/fuse/Kconfig
new file mode 100644
index 0000000000..005673e3e9
--- /dev/null
+++ b/drivers/fuse/Kconfig
@@ -0,0 +1,24 @@
+#
+# EFUSE infrastructure and drivers
+#
+
+menu "EFUSE Support"
+
+config MVEBU_EFUSE
+	bool "Enable eFuse support"
+	default n
+	depends on HAVE_MVEBU_EFUSE
+	help
+	  This enable mvebu efuse driver.
+	  It supports for reading and writing eFuses.
+	  This efuse driver supports marvell
+	  a38x and a7k/8k SoC chips.
+
+config MVEBU_EFUSE_READ_ONLY
+	bool "eFuse read only access"
+	default n
+	depends on MVEBU_EFUSE
+	help
+	  This enables a "read only" mode. Write attempt
+          will result in an error message.
+endmenu
diff --git a/drivers/fuse/Makefile b/drivers/fuse/Makefile
new file mode 100644
index 0000000000..02971f3fba
--- /dev/null
+++ b/drivers/fuse/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu.o
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu-hd.o
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu-ld.o
+obj-$(CONFIG_ARMADA_38X) += fuse-mvebu-init.o
diff --git a/drivers/fuse/fuse-mvebu-hd.c b/drivers/fuse/fuse-mvebu-hd.c
new file mode 100644
index 0000000000..6f692c6906
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-hd.c
@@ -0,0 +1,163 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+#define ROW_WORDS_LEN	3
+#define ECC_BITS_MASK	0xfe000000
+
+static int valid_prog_words;
+static u32 prog_val[ROW_WORDS_LEN];
+
+int mvebu_efuse_hd_read(struct udevice *dev, int row_id, u32 *val)
+{
+	void __iomem *otp_mem;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	row_widths = priv->pdata->row_bit_width;
+
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		*(val + i) = readl(otp_mem + 4 * i);
+
+	return 0;
+}
+
+#define EFUSE_MAX_RETRIES	3
+
+static int do_mvebu_efuse_hd_prog(struct udevice *dev, int row_id, u32 *new_val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	u32 fuse_read_value[ROW_WORDS_LEN];
+	int retry_cnt = 0, err_flag = 0;
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	/* only write a fuse line with lock bit */
+	if (!(*(new_val + 2) & 0x1))
+		return -EINVAL;
+	/* according to specs ECC protection bits must be 0 on write */
+	if (*(new_val + 1) & ECC_BITS_MASK)
+		return -EINVAL;
+
+	do {
+		err_flag = 0;
+
+		/* enable fuse prog */
+		setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+		/* read fuse row value before burn fuse */
+		for (i = 0; i < GET_LEN(row_widths); i++)
+			fuse_read_value[i] = readl(otp_mem + 4 * i);
+
+		/* fuse row value burn */
+		for (i = 0; i < GET_LEN(row_widths); i++) {
+			fuse_read_value[i] |= *(new_val + i);
+			writel(fuse_read_value[i], otp_mem + 4 * i);
+		}
+
+		/* wait 1 ms for burn efuse */
+		mdelay(1);
+
+		/* Disable efuse write */
+		clrbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+		/* ERRATA: 5073
+		 * When burning a row in the HD eFuse, the SM first read the
+		 * row to be burned to check it wasnt already burned, to prevent
+		 * re-buring. However, this errata causes the first HD burn
+		 * to read row zero instead of the targeted row, causing the
+		 * write to fail even if its empty. (The row zero is always
+		 * programmed in the production chips)
+		 *
+		 * The workaround is to detect failure by read and compare
+		 * and retry the fuse burn again (for max_retries = 3)
+		 */
+
+		/* Read & compare new read values with expected values */
+		for (i = 0; i < GET_LEN(row_widths); i++)
+			fuse_read_value[i] = readl(otp_mem + 4 * i);
+
+		for (i = 0; i < GET_LEN(row_widths); i++) {
+			dev_dbg(&dev->dev, "Expected value: 0x%x\n",
+				*(new_val + i));
+			/* Bank 1 has ECC bits which should
+			 * be masked while comparing
+			 */
+			if (i == 1)
+				fuse_read_value[i] &= ~ECC_BITS_MASK;
+			dev_dbg(&dev->dev, "Read value: 0x%x\n",
+				fuse_read_value[i]);
+			/* If comparison fails,
+			 * set error flag to initiate retry
+			 */
+			if (fuse_read_value[i] != *(new_val + i)) {
+				dev_dbg(&dev->dev, "Fuse prog failed\n");
+				err_flag = 1;
+				retry_cnt++;
+				dev_dbg(&dev->dev, "Retrying fuse prog..\n");
+			}
+		}
+	} while ((err_flag != 0) && (retry_cnt < EFUSE_MAX_RETRIES));
+
+	/* If we exceed retries limit, report error */
+	if (err_flag != 0) {
+		dev_err(&dev->dev, "fuse prog failed after %d retries\n",
+			retry_cnt);
+		return -EIO;
+	}
+	return 0;
+}
+
+int mvebu_efuse_hd_prog(struct udevice *dev, int word, int row_id, u32 new_val)
+{
+	int res = 0;
+
+#ifdef EFUSE_READ_ONLY
+	dev_err(&dev->dev, "ERROR: fuse programming disabled!\n");
+	return -EPERM;
+#endif
+
+	if (word < ROW_WORDS_LEN - 1) {
+		prog_val[word] = new_val;
+		valid_prog_words |= (1 << word);
+	}
+
+	if (word == ROW_WORDS_LEN - 1) {
+		if ((valid_prog_words & 3) == 0 && new_val) {
+			prog_val[0] = 0;
+			prog_val[1] = 0;
+			/* lock bit is set to 1*/
+			prog_val[2] = 1;
+			res = do_mvebu_efuse_hd_prog(dev, row_id, prog_val);
+			valid_prog_words = 0;
+		} else if ((valid_prog_words & 3) == 3 && new_val) {
+			prog_val[ROW_WORDS_LEN - 1] = new_val;
+			res = do_mvebu_efuse_hd_prog(dev, row_id, prog_val);
+			valid_prog_words = 0;
+		} else {
+			res = -EINVAL;
+			valid_prog_words = 0;
+		}
+	}
+
+	return res;
+}
diff --git a/drivers/fuse/fuse-mvebu-init.c b/drivers/fuse/fuse-mvebu-init.c
new file mode 100644
index 0000000000..b487ac6c12
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-init.c
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Copyright (C) 2015-2016 Reinhard Pfau <reinhard.pfau@gdsys.cc>
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <linux/mbus.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define MBUS_EFUSE_SIZE BIT(20)
+#define EFUSE_ADDR_MASK	0xff000000
+
+int mvebu_efuse_init_hw(struct udevice *dev)
+{
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	int ret = 0;
+	phys_addr_t efuse_base;
+
+	efuse_base = (phys_addr_t)priv->target_otp_mem & EFUSE_ADDR_MASK;
+
+	ret = mvebu_mbus_add_window_by_id(CPU_TARGET_SATA23_DFX,
+					  0xA, efuse_base, MBUS_EFUSE_SIZE);
+
+	return ret;
+}
diff --git a/drivers/fuse/fuse-mvebu-ld.c b/drivers/fuse/fuse-mvebu-ld.c
new file mode 100644
index 0000000000..7f42678c92
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-ld.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+#define ROW_WORDS_LEN	8
+
+static int valid_prog_words;
+static u32 prog_val[ROW_WORDS_LEN];
+
+int mvebu_efuse_ld_read(struct udevice *dev, int row_id, u32 *val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	/* when read_only flag is set, which means read LD0 */
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user"))
+		clrbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+	else
+		setbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		*(val + i) = readl(otp_mem + 4 * i);
+
+	return 0;
+}
+
+int do_mvebu_efuse_ld_prog(struct udevice *dev, int row_id, u32 *new_val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	u32 fuse_read_value[ROW_WORDS_LEN];
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user")) {
+		printf("This efuse row is LD0 and read-only\n");
+		return -EINVAL;
+	}
+	/* select LD1 for fuse burn */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+
+	/* enable fuse prog */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+	/* enable security bit to lock LD efuse row for further programming */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_LD_SEC_EN_MASK);
+	/* read fuse row value before burn fuse */
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		fuse_read_value[i] = readl(otp_mem + 4 * i);
+	/* fuse row value burn */
+	for (i = 0; i < GET_LEN(row_widths); i++) {
+		fuse_read_value[i] |= *(new_val + i);
+		writel(fuse_read_value[i], otp_mem + 4 * i);
+	}
+
+	/* write all 0 for LD eFuse to burn efuse */
+	writel(0x0, otp_mem + 0x20);
+
+	/* wait 1 ms for burn efuse */
+	mdelay(1);
+
+	/* Disable efuse write */
+	clrbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+	return 0;
+}
+
+int mvebu_efuse_ld_prog(struct udevice *dev, int word, int row_id, u32 new_val)
+{
+	int res = 0;
+
+#ifdef EFUSE_READ_ONLY
+	dev_err(&dev->dev, "ERROR: fuse programming disabled!\n");
+	return -EPERM;
+#endif
+
+	if (word < ROW_WORDS_LEN - 1) {
+		prog_val[word] = new_val;
+		valid_prog_words |= (1 << word);
+	} else if ((valid_prog_words & 0x7F) != 0x7F) {
+		res = -EINVAL;
+	} else {
+		prog_val[ROW_WORDS_LEN - 1] = new_val;
+		res = do_mvebu_efuse_ld_prog(dev, row_id, prog_val);
+		valid_prog_words = 0;
+	}
+
+	return res;
+}
diff --git a/drivers/fuse/fuse-mvebu.c b/drivers/fuse/fuse-mvebu.c
new file mode 100644
index 0000000000..5e2161f6db
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Copyright (C) 2015-2016 Reinhard Pfau <reinhard.pfau@gdsys.cc>
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <dm.h>
+#include <fdt_support.h>
+#include <mvebu/fuse-mvebu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+
+static int row_index;
+
+static struct fuse_ops fuse_ops = {
+	.fuse_init = NULL,
+	.fuse_hd_read = mvebu_efuse_hd_read,
+	.fuse_hd_prog = mvebu_efuse_hd_prog,
+	.fuse_ld_read = mvebu_efuse_ld_read,
+	.fuse_ld_prog = mvebu_efuse_ld_prog,
+};
+
+int reg_fuse_ops(struct fuse_ops *ops)
+{
+	if (!ops) {
+		printf("ERROR: No fuse operation registration\n");
+		return -EINVAL;
+	}
+	if (ops->fuse_init)
+		fuse_ops.fuse_init = ops->fuse_init;
+	if (ops->fuse_hd_read)
+		fuse_ops.fuse_hd_read = ops->fuse_hd_read;
+	if (ops->fuse_hd_prog)
+		fuse_ops.fuse_hd_prog = ops->fuse_hd_prog;
+	if (ops->fuse_ld_read)
+		fuse_ops.fuse_ld_read = ops->fuse_ld_read;
+	if (ops->fuse_ld_prog)
+		fuse_ops.fuse_ld_prog = ops->fuse_ld_prog;
+
+	return 0;
+}
+
+static int get_fuse_device(u32 bank, struct udevice **devp)
+{
+	struct mvebu_fuse_block_data *priv;
+	struct udevice *dev;
+
+	for (uclass_first_device(UCLASS_MISC, &dev); dev;
+	     uclass_next_device(&dev)) {
+		if ((device_is_compatible(dev, "marvell,mvebu-fuse-hd")) ||
+		    (device_is_compatible(dev,
+		     "marvell,mvebu-fuse-ld-user")) ||
+		    (device_is_compatible(dev,
+		     "marvell,mvebu-fuse-ld-prop"))) {
+			priv = dev_get_priv(dev);
+			if (bank >= priv->row_base &&
+			    bank < priv->row_base + priv->row_num) {
+				*devp = dev;
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{
+	int res = 0;
+	u32 *fuse_data;
+	struct udevice *dev = NULL;
+	struct mvebu_fuse_block_data *priv;
+	const struct fuse_ops *ops;
+	int row_widths;
+
+	if (bank < 0 || bank >= row_index)
+		return -EINVAL;
+
+	res = get_fuse_device(bank, &dev);
+	if (res)
+		return res;
+
+	priv = dev_get_priv(dev);
+	ops = device_get_ops(dev);
+	row_widths = priv->pdata->row_bit_width;
+
+	if (word >= GET_LEN(row_widths))
+		return -EINVAL;
+
+	fuse_data = kmalloc_array(GET_LEN(row_widths), sizeof(u32),
+				  GFP_KERNEL);
+
+	if (priv->hd_ld_flag)
+		res = ops->fuse_hd_read(dev, bank, fuse_data);
+	else
+		res = ops->fuse_ld_read(dev, bank, fuse_data);
+
+	if (res)
+		goto read_end;
+
+	*val = fuse_data[word];
+
+read_end:
+	kfree(fuse_data);
+	return res;
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	/* not supported */
+	return -EPERM;
+}
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	int res = 0;
+	struct udevice *dev = NULL;
+	struct mvebu_fuse_block_data *priv;
+	const struct fuse_ops *ops;
+	int row_widths;
+
+	if (bank < 0 || bank >= row_index)
+		return -EINVAL;
+
+	res = get_fuse_device(bank, &dev);
+	if (res)
+		return res;
+
+	priv = dev_get_priv(dev);
+	ops = device_get_ops(dev);
+	row_widths = priv->pdata->row_bit_width;
+
+	if (word >= GET_LEN(row_widths))
+		return -EINVAL;
+
+	if (priv->hd_ld_flag)
+		res = ops->fuse_hd_prog(dev, word, bank, val);
+	else
+		res = ops->fuse_ld_prog(dev, word, bank, val);
+
+	return res;
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	/* not supported */
+	return -EPERM;
+}
+
+static int fuse_probe(struct udevice *dev)
+{
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	const struct fuse_ops *ops;
+	int res = 0;
+
+	priv->control_reg = dev_read_addr_ptr(dev);
+	if (IS_ERR(priv->control_reg))
+		return -EINVAL;
+
+	priv->pdata =
+		(struct mvebu_fuse_platform_data *)dev_get_driver_data(dev);
+	priv->target_otp_mem =
+		(void *)(((phys_addr_t)dev_read_addr(dev) & ~0x00ffffff) +
+		(((phys_addr_t)fdtdec_get_int(blob, node,
+			"otp-mem", 0)) & 0x00ffffff));
+
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-hd"))
+		priv->hd_ld_flag = true;
+	else
+		priv->hd_ld_flag = false;
+
+	priv->row_num = fdtdec_get_int(blob, node, "rows-count", 1);
+	priv->row_base = row_index;
+	row_index = priv->row_num + row_index;
+
+	debug("%s efuse OTP mem %p, row base = %d\n",
+	      priv->hd_ld_flag != 0 ? "HD " :
+	      (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user") != 0 ?
+			"LD0" : "LD1"),
+	      priv->target_otp_mem, priv->row_base);
+
+	ops = device_get_ops(dev);
+	if (ops->fuse_init)
+		res = ops->fuse_init(dev);
+
+	return res;
+}
+
+static struct mvebu_fuse_platform_data fuse_hd_pdata = {
+	.row_bit_width = 65,
+	.row_step = 16,
+};
+
+static struct mvebu_fuse_platform_data fuse_ld_pdata = {
+	.row_bit_width = 256,
+};
+
+static const struct udevice_id mvebu_fuse_ids[] = {
+	{ .compatible = "marvell,mvebu-fuse-hd",
+		.data = (ulong)&fuse_hd_pdata },
+	{ .compatible = "marvell,mvebu-fuse-ld-user",
+		.data = (ulong)&fuse_ld_pdata },
+	{ .compatible = "marvell,mvebu-fuse-ld-prop",
+		.data = (ulong)&fuse_ld_pdata },
+
+	{}
+};
+
+int fuse_bind(struct udevice *dev)
+{
+	struct udevice *bank;
+	struct uclass *uc;
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	int ret = 0;
+
+	fdtdec_get_alias_seq(blob, "fuse", node, &dev->req_seq);
+
+	/* Get MISC uclass */
+	ret = uclass_get(UCLASS_MISC, &uc);
+	if (ret)
+		return ret;
+
+	/*
+	 * Reorder the efuse bank device in devices
+	 * list by its request sequence number.
+	 */
+	uclass_foreach_dev(bank, uc) {
+		node = dev_of_offset(bank);
+		fdtdec_get_alias_seq(blob, "fuse", node, &bank->req_seq);
+
+		if ((device_is_compatible(bank, "marvell,mvebu-fuse-hd")) ||
+		    (device_is_compatible(bank,
+		     "marvell,mvebu-fuse-ld-user")) ||
+		    (device_is_compatible(bank,
+		     "marvell,mvebu-fuse-ld-prop"))) {
+			if (bank->req_seq > dev->req_seq) {
+				list_move(&dev->uclass_node,
+					  bank->uclass_node.prev);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(mvebu_efuse) = {
+	.name	= "mvebu_efuse",
+	.id	= UCLASS_MISC,
+	.of_match = mvebu_fuse_ids,
+	.probe	= fuse_probe,
+	.priv_auto_alloc_size = sizeof(struct mvebu_fuse_block_data),
+	.ops	= &fuse_ops,
+	.bind	= fuse_bind,
+};
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index f2dabb554f..69250d7877 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -276,6 +276,13 @@ config PIC32_GPIO
 	help
 	  Say yes here to support Microchip PIC32 GPIOs.
 
+config OCTEONTX_GPIO
+	bool "OcteonTX GPIO driver"
+	depends on DM_GPIO && (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	default y
+	help
+	  Say yes here to support OcteonTX GPIOs.
+
 config STM32_GPIO
 	bool "ST STM32 GPIO driver"
 	depends on DM_GPIO && (STM32 || ARCH_STM32MP)
@@ -383,4 +390,15 @@ config MT7621_GPIO
 	help
 	  Say yes here to support MediaTek MT7621 compatible GPIOs.
 
+config I2C_GPIO
+	bool  "Generic I2C->GPIO no-irq expander"
+	depends on DM_GPIO
+	help
+	  Select this option to enable GPIO for simple I2C devices,
+	  parameterized by device-tree, and having no interrupts.
+	  Developed to model a custom board's CPLD, but may be useful
+	  for various hardware where i2c-poking flips external pins.
+
+	  If unsure, say N.
+
 endmenu
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 4a8aa0ff6f..82ca633204 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -55,9 +55,11 @@ obj-$(CONFIG_HIKEY_GPIO)	+= hi6220_gpio.o
 obj-$(CONFIG_HSDK_CREG_GPIO)	+= hsdk-creg-gpio.o
 obj-$(CONFIG_IMX_RGPIO2P)	+= imx_rgpio2p.o
 obj-$(CONFIG_PIC32_GPIO)	+= pic32_gpio.o
+obj-$(CONFIG_OCTEONTX_GPIO)	+= octeontx_gpio.o
 obj-$(CONFIG_MVEBU_GPIO)	+= mvebu_gpio.o
 obj-$(CONFIG_MSM_GPIO)		+= msm_gpio.o
 obj-$(CONFIG_$(SPL_)PCF8575_GPIO)	+= pcf8575_gpio.o
 obj-$(CONFIG_PM8916_GPIO)	+= pm8916_gpio.o
 obj-$(CONFIG_MT7621_GPIO)	+= mt7621_gpio.o
 obj-$(CONFIG_MSCC_SGPIO)	+= mscc_sgpio.o
+obj-$(CONFIG_I2C_GPIO)		+= i2c_gpio.o
diff --git a/drivers/gpio/i2c_gpio.c b/drivers/gpio/i2c_gpio.c
new file mode 100644
index 0000000000..df3dc78144
--- /dev/null
+++ b/drivers/gpio/i2c_gpio.c
@@ -0,0 +1,236 @@
+/*
+ * Take linux kernel driver drivers/i2c/busses/i2c-gpio.c for reference.
+ *
+ * Copyright (C) 2019 Marvell, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/* This driver handles generic i2c GPIO devices where a GPIO pin is indexed
+ * by the register address and bit number.  This driver is based off of the
+ * linux kernel gpio-i2c.c driver.
+ *
+ * Note that this driver should not be confused with i2c-gpio as this is
+ * an i2c to gpio driver whereas the other driver is a gpio to i2c driver.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <asm-generic/gpio.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <dt-bindings/gpio/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct i2c_gpio_chip {
+	int addr;	/** I2C address */
+	int gpio_count;	/** No. of GPIOs supported by the chip */
+	u8 *func;	/** Array to specify if pin is input or output */
+};
+
+static int i2c_gpio_write8(struct udevice *dev, uint offset, u8 byte)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+	int ret;
+
+	ret = dm_i2c_write(dev, offset, &byte, 1);
+	if (ret)
+		pr_err("%s(%s): i2c write failed to addr 0x%x\n",
+		       __func__, dev->name, chip->chip_addr);
+
+	return ret;
+}
+
+static int i2c_gpio_read8(struct udevice *dev, uint offset)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+	u8 data;
+	int ret;
+
+	ret = dm_i2c_read(dev, offset, &data, 1);
+	if (ret)
+		pr_err("%s(%s): i2c read failed from addr 0x%x\n", __func__,
+		       dev->name, chip->chip_addr);
+
+	return ret < 0 ? ret : data;
+}
+
+static int i2c_gpio_get_value(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int value;
+	int byte = (offset >> 3);
+	int bit = (offset & 7);
+
+	if (offset >= chip->gpio_count) {
+		pr_err("%s(%s): Error: offset %u out of range 0..%u\n",
+		       __func__, dev->name, offset, chip->gpio_count);
+		return -EINVAL;
+	}
+	value = i2c_gpio_read8(dev, byte);
+	value = (value < 0) ? value : ((value >> bit) & 1);
+	return value;
+}
+
+static int i2c_gpio_set_value(struct udevice *dev, unsigned int offset,
+			      int value)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	unsigned int byte = offset >> 3;
+	unsigned int bit = offset & 7;
+	unsigned int mask = (1 << bit);
+	int status;
+	int was;
+
+	if (offset >= chip->gpio_count) {
+		pr_err("%s(%s): Error: offset %u out of range 0..%u\n",
+		       __func__, dev->name, offset, chip->gpio_count);
+		return -EINVAL;
+	}
+
+	was = i2c_gpio_get_value(dev, byte);
+	if (was < 0)
+		return was;
+
+	if (value)
+		was |= mask;
+	else
+		was &= ~mask;
+	status = i2c_gpio_write8(dev, byte, was);
+	return status;
+}
+
+static int i2c_gpio_direction_input(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = ~(1 << bit);
+
+	chip->func[byte] &= mask;
+
+	/* For open drain: set as input by letting output go high */
+
+	return i2c_gpio_set_value(dev, offset, 1);
+}
+
+static int i2c_gpio_direction_output(struct udevice *dev, unsigned int offset,
+				     int value)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = (1 << bit);
+
+	chip->func[byte] |= mask;
+
+	return i2c_gpio_set_value(dev, offset, value);
+}
+
+static int i2c_gpio_get_function(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = (1 << bit);
+
+	return (chip->func[byte] & mask) ? GPIOF_OUTPUT : GPIOF_INPUT;
+}
+
+static int i2c_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
+			  struct ofnode_phandle_args *args)
+{
+	if (args->args_count < 1)
+		return -EINVAL;
+
+	desc->offset = args->args[0];
+	desc->flags = 0;
+	if (args->args_count > 1) {
+		if (args->args[1] & GPIO_ACTIVE_LOW)
+			desc->flags |= GPIOD_ACTIVE_LOW;
+	}
+	return 0;
+}
+
+static int i2c_gpio_probe(struct udevice *dev)
+{
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	char name[32], label[16], *str;
+	const char *tmp;
+	int size;
+	const char *status;
+
+	debug("%s(%s)\n", __func__, dev->name);
+
+	status = ofnode_read_string(dev->node, "status");
+	if (status && !strncmp(status, "ok", 2)) {
+		debug("%s(%s): GPIO device disabled in device tree\n",
+		      __func__, dev->name);
+		return -ENODEV;
+	}
+
+	chip->addr = ofnode_read_u32_default(dev->node, "reg", 0);
+	if (!chip->addr) {
+		pr_err("%s(%s): Missing reg property\n",
+		       __func__, dev->name);
+		return -ENODEV;
+	}
+	chip->gpio_count = ofnode_read_u32_default(dev->node, "ngpios", 0);
+	if (!chip->gpio_count) {
+		pr_err("%s(%s): Missing ngpios property\n",
+		       __func__, dev->name);
+		return -ENODEV;
+	}
+
+	tmp = dev_read_prop(dev, "label", &size);
+	if (tmp) {
+		strlcpy(label, tmp, sizeof(label));
+		snprintf(name, sizeof(name), "%s@%x_", label, chip->addr);
+	} else {
+		snprintf(name, sizeof(name), "gpio@%x_", chip->addr);
+	}
+
+	str = strdup(name);
+	if (!str)
+		return -ENOMEM;
+
+	uc_priv->bank_name = str;
+	uc_priv->gpio_count = chip->gpio_count;
+	chip->func = calloc((chip->gpio_count + 7) / 8, 1);
+	if (!chip->func)
+		return -ENOMEM;
+
+	debug("%s(%s): probed at address %d with %u gpios and name %s\n",
+	      __func__, dev->name, chip->addr, chip->gpio_count, name);
+
+	return 0;
+}
+
+static const struct dm_gpio_ops i2c_gpio_ops = {
+	.direction_input	= i2c_gpio_direction_input,
+	.direction_output	= i2c_gpio_direction_output,
+	.get_value		= i2c_gpio_get_value,
+	.set_value		= i2c_gpio_set_value,
+	.get_function		= i2c_gpio_get_function,
+	.xlate			= i2c_gpio_xlate,
+};
+
+static const struct udevice_id i2c_gpio_ids[] = {
+	{ .compatible = "gpio-i2c" },
+	{ }
+};
+
+U_BOOT_DRIVER(i2c_gpio) = {
+	.name		= "gpio-i2c",
+	.id		= UCLASS_GPIO,
+	.ops		= &i2c_gpio_ops,
+	.probe		= i2c_gpio_probe,
+	.platdata_auto_alloc_size = sizeof(struct i2c_gpio_chip),
+	.of_match	= i2c_gpio_ids,
+};
diff --git a/drivers/gpio/mvebu_gpio.c b/drivers/gpio/mvebu_gpio.c
index e8b1c5965c..ffc3b77251 100644
--- a/drivers/gpio/mvebu_gpio.c
+++ b/drivers/gpio/mvebu_gpio.c
@@ -88,12 +88,27 @@ static int mvebu_gpio_probe(struct udevice *dev)
 {
 	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
 	struct mvebu_gpio_priv *priv = dev_get_priv(dev);
+	char name[32], label[8], *str;
+	const u8 *tmp;
+	int size;
 
 	priv->regs = (struct mvebu_gpio_regs *)devfdt_get_addr(dev);
 	uc_priv->gpio_count = MVEBU_GPIOS_PER_BANK;
 	priv->name[0] = 'A' + dev->req_seq;
-	uc_priv->bank_name = priv->name;
-
+	tmp = dev_read_prop(dev, "label", &size);
+
+	if (tmp) {
+		memcpy(label, tmp, sizeof(label) - 1);
+		label[sizeof(label) - 1] = '\0';
+		snprintf(name, sizeof(name), "%s@", label);
+		str = strdup(name);
+		if (!str)
+			return -ENOMEM;
+		uc_priv->bank_name = str;
+
+	} else {
+		uc_priv->bank_name = priv->name;
+	}
 	return 0;
 }
 
diff --git a/drivers/gpio/octeontx_gpio.c b/drivers/gpio/octeontx_gpio.c
new file mode 100644
index 0000000000..d012044c47
--- /dev/null
+++ b/drivers/gpio/octeontx_gpio.c
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ *
+ * (C) Copyright 2011
+ * eInfochips Ltd. <www.einfochips.com>
+ * Written-by: Ajay Bhargav <ajay.bhargav@einfochips.com>
+ *
+ * (C) Copyright 2010
+ * Marvell Semiconductor <www.marvell.com>
+ *
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/bitops.h>
+#include <dt-bindings/gpio/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/** Returns the bit value to write or read based on the offset */
+#define GPIO_BIT(x)		(1ULL << ((x) & 0x3f))
+
+#define GPIO_RX_DAT		(0x0)
+#define GPIO_TX_SET		(0x8)
+#define GPIO_TX_CLR		(0x10)
+#define GPIO_CONST		(0x90)
+#define GPIO_RX1_DAT		(0x1400)
+#define GPIO_TX1_SET		(0x1408)
+#define GPIO_TX1_CLR		(0x1410)
+
+/** Returns the offset to the output register based on the offset and value */
+#define GPIO_TX_REG(offset, value)					\
+	((offset) >= 64 ? ((value) ? GPIO_TX1_SET : GPIO_TX1_CLR) :	\
+			  ((value) ? GPIO_TX_SET : GPIO_TX_CLR))
+
+/** Returns the offset to the input data register based on the offset */
+#define GPIO_RX_DAT_REG(offset) (((offset) >= 64) ? GPIO_RX1_DAT : GPIO_RX_DAT)
+
+/** Returns the bit configuration register based on the offset */
+#define GPIO_BIT_CFG(x)		(0x400 + 8 * (x))
+#define GPIO_BIT_CFG_FN(x)	(((x) >> 16) & 0x3ff)
+#define GPIO_BIT_CFG_TX_OE(x)	((x) & 0x1)
+#define GPIO_BIT_CFG_RX_DAT(x)	((x) & 0x1)
+
+/** PCI ID on NCB bus */
+#define PCI_DEVICE_ID_OCTEONTX_GPIO	0xa00a
+
+union gpio_const {
+	u64 u;
+	struct {
+		u64 gpios:8;	/** Number of GPIOs implemented */
+		u64 pp:8;	/** Number of PP vectors */
+		u64:48;	/* Reserved */
+	} s;
+};
+
+struct octeontx_gpio {
+	void __iomem *baseaddr;
+};
+
+static int octeontx_gpio_dir_input(struct udevice *dev, unsigned int offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
+	debug("%s(%s, %u)\n", __func__, dev->name, offset);
+	clrbits_le64(gpio->baseaddr + GPIO_BIT_CFG(offset),
+		     (0x3ffUL << 16) | 4UL | 2UL | 1UL);
+	return 0;
+}
+
+static int octeontx_gpio_dir_output(struct udevice *dev, unsigned int offset,
+				    int value)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
+	debug("%s(%s, %u, %d)\n", __func__, dev->name, offset, value);
+	writeq(GPIO_BIT(offset), gpio->baseaddr + GPIO_TX_REG(offset, value));
+
+	clrsetbits_le64(gpio->baseaddr + GPIO_BIT_CFG(offset),
+			((0x3ffUL << 16) | 4UL), 1UL);
+	return 0;
+}
+
+static int octeontx_gpio_get_value(struct udevice *dev,
+				   unsigned int offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+	u64 reg = readq(gpio->baseaddr + GPIO_RX_DAT_REG(offset));
+
+	debug("%s(%s, %u): value: %d\n", __func__, dev->name, offset,
+	      !!(reg & GPIO_BIT(offset)));
+
+	return !!(reg & GPIO_BIT(offset));
+}
+
+static int octeontx_gpio_set_value(struct udevice *dev,
+				   unsigned int offset, int value)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
+	debug("%s(%s, %u, %d)\n", __func__, dev->name, offset, value);
+	writeq(GPIO_BIT(offset), gpio->baseaddr + GPIO_TX_REG(offset, value));
+
+	return 0;
+}
+
+static int octeontx_gpio_get_function(struct udevice *dev,
+				      unsigned int offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+	u64 pinsel = readl(gpio->baseaddr + GPIO_BIT_CFG(offset));
+
+	debug("%s(%s, %u): pinsel: 0x%llx\n", __func__, dev->name, offset,
+	      pinsel);
+	if (GPIO_BIT_CFG_FN(pinsel))
+		return GPIOF_FUNC;
+	else if (GPIO_BIT_CFG_TX_OE(pinsel))
+		return GPIOF_OUTPUT;
+	else
+		return GPIOF_INPUT;
+}
+
+static int octeontx_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
+			       struct ofnode_phandle_args *args)
+{
+	if (args->args_count < 1)
+		return -EINVAL;
+
+	desc->offset = args->args[0];
+	desc->flags = 0;
+	if (args->args_count > 1) {
+		if (args->args[1] & GPIO_ACTIVE_LOW)
+			desc->flags |= GPIOD_ACTIVE_LOW;
+		/* In the future add tri-state flag support */
+	}
+	return 0;
+}
+
+static const struct dm_gpio_ops octeontx_gpio_ops = {
+	.direction_input	= octeontx_gpio_dir_input,
+	.direction_output	= octeontx_gpio_dir_output,
+	.get_value		= octeontx_gpio_get_value,
+	.set_value		= octeontx_gpio_set_value,
+	.get_function		= octeontx_gpio_get_function,
+	.xlate			= octeontx_gpio_xlate,
+};
+
+static int octeontx_gpio_probe(struct udevice *dev)
+{
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct octeontx_gpio *priv = dev_get_priv(dev);
+	union gpio_const gpio_const;
+	char *end;
+	const char *status;
+
+	status = ofnode_read_string(dev->node, "status");
+
+	if (status && !strncmp(status, "ok", 2)) {
+		debug("%s(%s): GPIO device disabled in device tree\n",
+		      __func__, dev->name);
+		return -1;
+	}
+
+	dev->req_seq = PCI_FUNC(bdf);
+	priv->baseaddr = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					PCI_REGION_MEM);
+
+	if (!priv->baseaddr) {
+		debug("%s(%s): Could not get base address\n",
+		      __func__, dev->name);
+		return -1;
+	}
+
+	gpio_const.u = readq(priv->baseaddr + GPIO_CONST);
+
+	debug("%s(%s): base address: %p, of_offset: %ld, pin count: %d\n",
+	      __func__, dev->name, priv->baseaddr, dev->node.of_offset,
+	      gpio_const.s.gpios);
+
+	uc_priv->gpio_count = gpio_const.s.gpios;
+	uc_priv->bank_name  = strdup(dev->name);
+	end = strchr(uc_priv->bank_name, '@');
+	end[0] = 'A' + dev->seq;
+	end[1] = '\0';
+
+	return 0;
+}
+
+static const struct udevice_id octeontx_gpio_ids[] = {
+	{ .compatible = "cavium,thunder-8890-gpio" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_gpio) = {
+	.name	= "octeontx_gpio",
+	.id	= UCLASS_GPIO,
+	.of_match = of_match_ptr(octeontx_gpio_ids),
+	.probe = octeontx_gpio_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_gpio),
+	.ops	= &octeontx_gpio_ops,
+	.flags	= DM_FLAG_PRE_RELOC,
+};
+
+static struct pci_device_id octeontx_gpio_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_GPIO) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(octeontx_gpio, octeontx_gpio_supported);
diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index 03d2fed341..eb47454e76 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -366,6 +366,13 @@ config SYS_I2C_SANDBOX
 	  bus. Devices can be attached to the bus using the device tree
 	  which specifies the driver to use.  See sandbox.dts as an example.
 
+config SYS_I2C_OCTEONTX
+	bool "OcteonTX I2C driver"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2) && DM_I2C
+	default y
+	help
+	 Enable I2C support for OcteonTX/TX2 line of processors.
+
 config SYS_I2C_S3C24X0
 	bool "Samsung I2C driver"
 	depends on ARCH_EXYNOS4 && DM_I2C
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index c2f75d8755..e2ae95e770 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_SYS_I2C_SH) += sh_i2c.o
 obj-$(CONFIG_SYS_I2C_SOFT) += soft_i2c.o
 obj-$(CONFIG_SYS_I2C_STM32F7) += stm32f7_i2c.o
 obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
+obj-$(CONFIG_SYS_I2C_OCTEONTX) += octeontx_i2c.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER) += i2c-uniphier.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER_F) += i2c-uniphier-f.o
 obj-$(CONFIG_SYS_I2C_VERSATILE) += i2c-versatile.o
diff --git a/drivers/i2c/i2c-uclass.c b/drivers/i2c/i2c-uclass.c
index e47abf1833..af2efb25d9 100644
--- a/drivers/i2c/i2c-uclass.c
+++ b/drivers/i2c/i2c-uclass.c
@@ -265,6 +265,9 @@ static int i2c_probe_chip(struct udevice *bus, uint chip_addr,
 	/* Probe with a zero-length message */
 	msg->addr = chip_addr;
 	msg->flags = chip_flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
+#ifdef CONFIG_ARCH_OCTEONTX
+	msg->flags |= I2C_M_RD;
+#endif
 	msg->len = 0;
 	msg->buf = NULL;
 
diff --git a/drivers/i2c/muxes/Kconfig b/drivers/i2c/muxes/Kconfig
index 68f15261be..39683fc43b 100644
--- a/drivers/i2c/muxes/Kconfig
+++ b/drivers/i2c/muxes/Kconfig
@@ -33,8 +33,8 @@ config I2C_MUX_PCA954x
 	  devices. It is x width I2C multiplexer which enables to partitioning
 	  I2C bus and connect multiple devices with the same address to the same
 	  I2C controller where driver handles proper routing to target i2c
-	  device. Supported chips are PCA9543, PCA9544, PCA9547, PCA9548 and
-	  PCA9646.
+	  device. Supported chips are PCA9543, PCA9544, PCA9546, PCA9547,
+	  PCA9548 and PCA9646.
 
 config I2C_MUX_GPIO
         tristate "GPIO-based I2C multiplexer"
diff --git a/drivers/i2c/muxes/pca954x.c b/drivers/i2c/muxes/pca954x.c
index a630ce991d..dfe936870a 100644
--- a/drivers/i2c/muxes/pca954x.c
+++ b/drivers/i2c/muxes/pca954x.c
@@ -17,6 +17,7 @@ DECLARE_GLOBAL_DATA_PTR;
 enum pca_type {
 	PCA9543,
 	PCA9544,
+	PCA9546,
 	PCA9547,
 	PCA9548,
 	PCA9646
@@ -47,6 +48,10 @@ static const struct chip_desc chips[] = {
 		.muxtype = pca954x_ismux,
 		.width = 4,
 	},
+	[PCA9546] = {
+		.muxtype = pca954x_isswi,
+		.width = 4,
+	},
 	[PCA9547] = {
 		.enable = 0x8,
 		.muxtype = pca954x_ismux,
@@ -94,6 +99,7 @@ static const struct i2c_mux_ops pca954x_ops = {
 static const struct udevice_id pca954x_ids[] = {
 	{ .compatible = "nxp,pca9543", .data = PCA9543 },
 	{ .compatible = "nxp,pca9544", .data = PCA9544 },
+	{ .compatible = "nxp,pca9546", .data = PCA9546 },
 	{ .compatible = "nxp,pca9547", .data = PCA9547 },
 	{ .compatible = "nxp,pca9548", .data = PCA9548 },
 	{ .compatible = "nxp,pca9646", .data = PCA9646 },
diff --git a/drivers/i2c/mv_i2c.c b/drivers/i2c/mv_i2c.c
index 8a56ef9a24..227c3f4457 100644
--- a/drivers/i2c/mv_i2c.c
+++ b/drivers/i2c/mv_i2c.c
@@ -238,6 +238,7 @@ static int __i2c_read(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		      uchar *buffer, int len)
 {
 	struct mv_i2c_msg msg;
+	int i = 0;
 
 	debug("i2c_read(chip=0x%02x, addr=0x%02x, alen=0x%02x, "
 	      "len=0x%02x)\n", chip, *addr, alen, len);
@@ -269,7 +270,7 @@ static int __i2c_read(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		msg.condition = I2C_COND_NORMAL;
 		msg.acknack   = I2C_ACKNAK_WAITACK;
 		msg.direction = I2C_WRITE;
-		msg.data      = addr[alen];
+		msg.data      = addr[i++];
 		if (i2c_transfer(base, &msg))
 			return -1;
 	}
@@ -314,6 +315,7 @@ static int __i2c_write(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		       uchar *buffer, int len)
 {
 	struct mv_i2c_msg msg;
+	int i = 0;
 
 	debug("i2c_write(chip=0x%02x, addr=0x%02x, alen=0x%02x, "
 	      "len=0x%02x)\n", chip, *addr, alen, len);
@@ -340,7 +342,7 @@ static int __i2c_write(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		msg.condition = I2C_COND_NORMAL;
 		msg.acknack   = I2C_ACKNAK_WAITACK;
 		msg.direction = I2C_WRITE;
-		msg.data      = addr[alen];
+		msg.data      = addr[i++];
 		if (i2c_transfer(base, &msg))
 			return -1;
 	}
@@ -565,10 +567,18 @@ static int mv_i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
 	struct mv_i2c_priv *priv = dev_get_priv(bus);
 	u32 val;
 
-	if (speed > 100000)
-		val = ICR_FM;
-	else
+	switch (speed) {
+	case 100000:
 		val = ICR_SM;
+		break;
+	case 400000:
+		val = ICR_FM;
+		break;
+	default:
+		printf("Only 100k and 400k modes supported\n");
+		return -EOPNOTSUPP;
+	}
+
 	clrsetbits_le32(&priv->base->icr, ICR_MODE_MASK, val);
 
 	return 0;
@@ -583,9 +593,18 @@ static int mv_i2c_probe(struct udevice *bus)
 	return 0;
 }
 
+static int mv_i2c_reset(struct udevice *bus)
+{
+	struct mv_i2c_priv *priv = dev_get_priv(bus);
+
+	i2c_reset(priv->base);
+	return 0;
+}
+
 static const struct dm_i2c_ops mv_i2c_ops = {
 	.xfer		= mv_i2c_xfer,
 	.set_bus_speed	= mv_i2c_set_bus_speed,
+	.deblock	= mv_i2c_reset,
 };
 
 static const struct udevice_id mv_i2c_ids[] = {
diff --git a/drivers/i2c/mvtwsi.c b/drivers/i2c/mvtwsi.c
index 0a2dafcec6..69244b890c 100644
--- a/drivers/i2c/mvtwsi.c
+++ b/drivers/i2c/mvtwsi.c
@@ -615,13 +615,14 @@ static int __twsi_i2c_read(struct mvtwsi_registers *twsi, uchar chip,
 	int status = 0;
 	int stop_status;
 	int expected_start = MVTWSI_STATUS_START;
+	int i = 0;
 
 	if (alen > 0) {
 		/* Begin i2c write to send the address bytes */
 		status = i2c_begin(twsi, expected_start, (chip << 1), tick);
 		/* Send address bytes */
 		while ((status == 0) && alen--)
-			status = twsi_send(twsi, addr[alen],
+			status = twsi_send(twsi, addr[i++],
 					   MVTWSI_STATUS_DATA_W_ACK, tick);
 		/* Send repeated STARTs after the initial START */
 		expected_start = MVTWSI_STATUS_REPEATED_START;
@@ -662,13 +663,14 @@ static int __twsi_i2c_write(struct mvtwsi_registers *twsi, uchar chip,
 			    uint tick)
 {
 	int status, stop_status;
+	int i = 0;
 
 	/* Begin i2c write to send first the address bytes, then the
 	 * data bytes */
 	status = i2c_begin(twsi, MVTWSI_STATUS_START, (chip << 1), tick);
 	/* Send address bytes */
 	while ((status == 0) && (alen-- > 0))
-		status = twsi_send(twsi, addr[alen], MVTWSI_STATUS_DATA_W_ACK,
+		status = twsi_send(twsi, addr[i++], MVTWSI_STATUS_DATA_W_ACK,
 				   tick);
 	/* Send data bytes */
 	while ((status == 0) && (length-- > 0))
diff --git a/drivers/i2c/octeontx_i2c.c b/drivers/i2c/octeontx_i2c.c
new file mode 100644
index 0000000000..7d462ce28c
--- /dev/null
+++ b/drivers/i2c/octeontx_i2c.c
@@ -0,0 +1,968 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+# define TWSI_THP		24
+#else
+# define TWSI_THP		3
+#endif
+
+/**
+ * Slave address to use for Thunder when accessed by another master
+ */
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR
+# define CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR	0x77
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_0
+# ifdef CONFIG_SYS_I2C_SPEED
+#  define CONFIG_SYS_I2C_OCTEONTX_SPEED_0	CONFIG_SYS_I2C_SPEED
+# else
+#  define CONFIG_SYS_I2C_SPEED			100000
+#  define CONFIG_SYS_I2C_OCTEONTX_SPEED_0	CONFIG_SYS_I2C_SPEED
+# endif
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_1
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_1	CONFIG_SYS_I2C_OCTEONTX_SPEED_0
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_2
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_2	CONFIG_SYS_I2C_OCTEONTX_SPEED_1
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_3
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_3	CONFIG_SYS_I2C_OCTEONTX_SPEED_2
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_4
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_4	CONFIG_SYS_I2C_OCTEONTX_SPEED_3
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_5
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_5	CONFIG_SYS_I2C_OCTEONTX_SPEED_4
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_6
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_6	CONFIG_SYS_I2C_OCTEONTX_SPEED_5
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_7
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_7	CONFIG_SYS_I2C_OCTEONTX_SPEED_6
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_8
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_8	CONFIG_SYS_I2C_OCTEONTX_SPEED_7
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_9
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_9	CONFIG_SYS_I2C_OCTEONTX_SPEED_8
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_10
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_10	CONFIG_SYS_I2C_OCTEONTX_SPEED_9
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_11
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_11	CONFIG_SYS_I2C_OCTEONTX_SPEED_10
+#endif
+
+#define TWSI_SW_TWSI		0x1000
+#define TWSI_TWSI_SW		0x1008
+#define TWSI_INT		0x1010
+#define TWSI_SW_TWSI_EXT	0x1018
+
+union twsx_sw_twsi {
+	u64 u;
+	struct {
+		u64 data:32;
+		u64 eop_ia:3;
+		u64 ia:5;
+		u64 addr:10;
+		u64 scr:2;
+		u64 size:3;
+		u64 sovr:1;
+		u64 r:1;
+		u64 op:4;
+		u64 eia:1;
+		u64 slonly:1;
+		u64 v:1;
+	} s;
+};
+
+union twsx_sw_twsi_ext {
+	u64 u;
+	struct {
+		u64 data:32;
+		u64 ia:8;
+		u64 rsvd:24;
+	} s;
+};
+
+union twsx_int {
+	u64 u;
+	struct {
+		u64 st_int:1;	/** TWSX_SW_TWSI register update int */
+		u64 ts_int:1;	/** TWSX_TWSI_SW register update int */
+		u64 core_int:1;	/** TWSI core interrupt, ignored for HLC */
+		u64 rsvd1:5;		/** Reserved */
+		u64 sda_ovr:1;	/** SDA testing override */
+		u64 scl_ovr:1;	/** SCL testing override */
+		u64 sda:1;		/** SDA signal */
+		u64 scl:1;		/** SCL signal */
+		u64 rsvd2:52;		/** Reserved */
+	} s;
+};
+
+enum {
+	TWSI_OP_WRITE	= 0,
+	TWSI_OP_READ	= 1,
+};
+
+enum {
+	TWSI_EOP_SLAVE_ADDR = 0,
+	TWSI_EOP_CLK_CTL = 3,
+	TWSI_SW_EOP_IA   = 6,
+};
+
+enum {
+	TWSI_SLAVEADD     = 0,
+	TWSI_DATA         = 1,
+	TWSI_CTL          = 2,
+	TWSI_CLKCTL       = 3,
+	TWSI_STAT         = 3,
+	TWSI_SLAVEADD_EXT = 4,
+	TWSI_RST          = 7,
+};
+
+enum {
+	TWSI_CTL_AAK	= BIT(2),
+	TWSI_CTL_IFLG	= BIT(3),
+	TWSI_CTL_STP	= BIT(4),
+	TWSI_CTL_STA	= BIT(5),
+	TWSI_CTL_ENAB	= BIT(6),
+	TWSI_CTL_CE	= BIT(7),
+};
+
+enum {
+	/** Bus error */
+	TWSI_STAT_BUS_ERROR		= 0x00,
+	/** Start condition transmitted */
+	TWSI_STAT_START			= 0x08,
+	/** Repeat start condition transmitted */
+	TWSI_STAT_RSTART		= 0x10,
+	/** Address + write bit transmitted, ACK received */
+	TWSI_STAT_TXADDR_ACK		= 0x18,
+	/** Address + write bit transmitted, /ACK received */
+	TWSI_STAT_TXADDR_NAK		= 0x20,
+	/** Data byte transmitted in master mode, ACK received */
+	TWSI_STAT_TXDATA_ACK		= 0x28,
+	/** Data byte transmitted in master mode, ACK received */
+	TWSI_STAT_TXDATA_NAK		= 0x30,
+	/** Arbitration lost in address or data byte */
+	TWSI_STAT_TX_ARB_LOST		= 0x38,
+	/** Address + read bit transmitted, ACK received */
+	TWSI_STAT_RXADDR_ACK		= 0x40,
+	/** Address + read bit transmitted, /ACK received */
+	TWSI_STAT_RXADDR_NAK		= 0x48,
+	/** Data byte received in master mode, ACK transmitted */
+	TWSI_STAT_RXDATA_ACK_SENT	= 0x50,
+	/** Data byte received, NACK transmitted */
+	TWSI_STAT_RXDATA_NAK_SENT	= 0x58,
+	/** Slave address received, sent ACK */
+	TWSI_STAT_SLAVE_RXADDR_ACK	= 0x60,
+	/**
+	 * Arbitration lost in address as master, slave address + write bit
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_TX_ACK_ARB_LOST	= 0x68,
+	/** General call address received, ACK transmitted */
+	TWSI_STAT_RX_GEN_ADDR_ACK	= 0x70,
+	/**
+	 * Arbitration lost in address as master, general call address
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_RX_GEN_ADDR_ARB_LOST	= 0x78,
+	/** Data byte received after slave address received, ACK transmitted */
+	TWSI_STAT_SLAVE_RXDATA_ACK	= 0x80,
+	/** Data byte received after slave address received, /ACK transmitted */
+	TWSI_STAT_SLAVE_RXDATA_NAK	= 0x88,
+	/**
+	 * Data byte received after general call address received, ACK
+	 * transmitted
+	 */
+	TWSI_STAT_GEN_RXADDR_ACK	= 0x90,
+	/**
+	 * Data byte received after general call address received, /ACK
+	 * transmitted
+	 */
+	TWSI_STAT_GEN_RXADDR_NAK	= 0x98,
+	/** STOP or repeated START condition received in slave mode */
+	TWSI_STAT_STOP_MULTI_START	= 0xA0,
+	/** Slave address + read bit received, ACK transmitted */
+	TWSI_STAT_SLAVE_RXADDR2_ACK	= 0xA8,
+	/**
+	 * Arbitration lost in address as master, slave address + read bit
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_RXDATA_ACK_ARB_LOST	= 0xB0,
+	/** Data byte transmitted in slave mode, ACK received */
+	TWSI_STAT_SLAVE_TXDATA_ACK	= 0xB8,
+	/** Data byte transmitted in slave mode, /ACK received */
+	TWSI_STAT_SLAVE_TXDATA_NAK	= 0xC0,
+	/** Last byte transmitted in slave mode, ACK received */
+	TWSI_STAT_SLAVE_TXDATA_END_ACK	= 0xC8,
+	/** Second address byte + write bit transmitted, ACK received */
+	TWSI_STAT_TXADDR2DATA_ACK	= 0xD0,
+	/** Second address byte + write bit transmitted, /ACK received */
+	TWSI_STAT_TXADDR2DATA_NAK	= 0xD8,
+	/** No relevant status information */
+	TWSI_STAT_IDLE		= 0xF8
+};
+
+struct octeontx_twsi {
+	int			id;
+	int			speed;
+	void			*baseaddr;
+};
+
+/** Array of bus speeds */
+static unsigned int speeds[] = {
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_0,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_1,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_2,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_3,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_4,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_5,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_6,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_7,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_8,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_9,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_10,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_11,
+};
+
+/** Last i2c id assigned */
+static int last_id;
+
+static void twsi_unblock(void *baseaddr);
+static int twsi_stop(void *baseaddr);
+
+/**
+ * Converts the i2c status to a meaningful string
+ *
+ * @param	status	status to convert
+ *
+ * @return	string representation of the status
+ */
+static const char *twsi_i2c_status_str(uint8_t status)
+{
+	switch (status) {
+	case TWSI_STAT_BUS_ERROR:
+		return "Bus error";
+	case TWSI_STAT_START:
+		return "START condition transmitted";
+	case TWSI_STAT_RSTART:
+		return "Repeated START condition transmitted";
+	case TWSI_STAT_TXADDR_ACK:
+		return "Address + write bit transmitted, ACK received";
+	case TWSI_STAT_TXADDR_NAK:
+		return "Address + write bit transmitted, NAK received";
+	case TWSI_STAT_TXDATA_ACK:
+		return "Data byte transmitted in master mode, ACK received";
+	case TWSI_STAT_TXDATA_NAK:
+		return "Data byte transmitted in master mode, NAK received";
+	case TWSI_STAT_TX_ARB_LOST:
+		return "Arbitration lost in address or data byte";
+	case TWSI_STAT_RXADDR_ACK:
+		return "Address + read bit transmitted, ACK received";
+	case TWSI_STAT_RXADDR_NAK:
+		return "Address + read bit transmitted, NAK received";
+	case TWSI_STAT_RXDATA_ACK_SENT:
+		return "Data byte received in master mode, ACK transmitted";
+	case TWSI_STAT_RXDATA_NAK_SENT:
+		return "Data byte received in master mode, NAK transmitted";
+	case TWSI_STAT_SLAVE_RXADDR_ACK:
+		return "Slave address + write bit received, ACK transmitted";
+	case TWSI_STAT_TX_ACK_ARB_LOST:
+		return "Arbitration lost in address as master, slave address + write bit received, ACK transmitted";
+	case TWSI_STAT_RX_GEN_ADDR_ACK:
+		return "General call address received, ACK transmitted";
+	case TWSI_STAT_RX_GEN_ADDR_ARB_LOST:
+		return "Arbitration lost in address as master, general call address received, ACK transmitted";
+	case TWSI_STAT_SLAVE_RXDATA_ACK:
+		return "Data byte received after slave address received, ACK transmitted";
+	case TWSI_STAT_SLAVE_RXDATA_NAK:
+		return "Data byte received after slave address received, NAK transmitted";
+	case TWSI_STAT_GEN_RXADDR_ACK:
+		return "Data byte received after general call address received, ACK transmitted";
+	case TWSI_STAT_GEN_RXADDR_NAK:
+		return "Data byte received after general call address received, NAK transmitted";
+	case TWSI_STAT_STOP_MULTI_START:
+		return "STOP or repeated START condition received in slave mode";
+	case TWSI_STAT_SLAVE_RXADDR2_ACK:
+		return "Slave address + read bit received, ACK transmitted";
+	case TWSI_STAT_RXDATA_ACK_ARB_LOST:
+		return "Arbitration lost in address as master, slave address + read bit received, ACK transmitted";
+	case TWSI_STAT_SLAVE_TXDATA_ACK:
+		return "Data byte transmitted in slave mode, ACK received";
+	case TWSI_STAT_SLAVE_TXDATA_NAK:
+		return "Data byte transmitted in slave mode, NAK received";
+	case TWSI_STAT_SLAVE_TXDATA_END_ACK:
+		return "Last byte transmitted in slave mode, ACK received";
+	case TWSI_STAT_TXADDR2DATA_ACK:
+		return "Second address byte + write bit transmitted, ACK received";
+	case TWSI_STAT_TXADDR2DATA_NAK:
+		return "Second address byte + write bit transmitted, NAK received";
+	case TWSI_STAT_IDLE:
+		return "Idle";
+	default:
+		return "Unknown status code";
+	}
+}
+
+/**
+ * Returns true if we lost arbitration
+ *
+ * @param	code		status code
+ * @param	final_read	true if this is the final read operation
+ *
+ * @return	true if arbitration has been lost, false if it hasn't been lost.
+ */
+static int twsi_i2c_lost_arb(u8 code, int final_read)
+{
+	switch (code) {
+	/* Arbitration lost */
+	case TWSI_STAT_TX_ARB_LOST:
+	case TWSI_STAT_TX_ACK_ARB_LOST:
+	case TWSI_STAT_RX_GEN_ADDR_ARB_LOST:
+	case TWSI_STAT_RXDATA_ACK_ARB_LOST:
+		return -EAGAIN;
+
+	/* Being addressed as slave, should back off and listen */
+	case TWSI_STAT_SLAVE_RXADDR_ACK:
+	case TWSI_STAT_RX_GEN_ADDR_ACK:
+	case TWSI_STAT_GEN_RXADDR_ACK:
+	case TWSI_STAT_GEN_RXADDR_NAK:
+		return -EIO;
+
+	/* Core busy as slave */
+	case TWSI_STAT_SLAVE_RXDATA_ACK:
+	case TWSI_STAT_SLAVE_RXDATA_NAK:
+	case TWSI_STAT_STOP_MULTI_START:
+	case TWSI_STAT_SLAVE_RXADDR2_ACK:
+	case TWSI_STAT_SLAVE_TXDATA_ACK:
+	case TWSI_STAT_SLAVE_TXDATA_NAK:
+	case TWSI_STAT_SLAVE_TXDATA_END_ACK:
+		return  -EIO;
+
+	/* Ack allowed on pre-terminal bytes only */
+	case TWSI_STAT_RXDATA_ACK_SENT:
+		if (!final_read)
+			return 0;
+		return -EAGAIN;
+
+	/* NAK allowed on terminal byte only */
+	case TWSI_STAT_RXDATA_NAK_SENT:
+		if (!final_read)
+			return 0;
+		return -EAGAIN;
+
+	case TWSI_STAT_TXDATA_NAK:
+	case TWSI_STAT_TXADDR_NAK:
+	case TWSI_STAT_RXADDR_NAK:
+	case TWSI_STAT_TXADDR2DATA_NAK:
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+#define RST_BOOT_PNR_MUL(val)  (((val) >> 33) & 0x1F)
+
+/**
+ * Writes to the MIO_TWS(0..5)_SW_TWSI register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ * @param	sw_twsi		value to write
+ *
+ * @return	0 for success, otherwise error
+ */
+static u64 twsi_write_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
+{
+	unsigned long start = get_timer(0);
+
+	sw_twsi.s.r = 0;
+	sw_twsi.s.v = 1;
+
+	debug("%s(%p, 0x%llx)\n", __func__, baseaddr, sw_twsi.u);
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+	do {
+		sw_twsi.u = readq(baseaddr + TWSI_SW_TWSI);
+	} while (sw_twsi.s.v != 0 && get_timer(start) < 50);
+
+	if (sw_twsi.s.v)
+		debug("%s: timed out\n", __func__);
+	return sw_twsi.u;
+}
+
+/**
+ * Reads the MIO_TWS(0..5)_SW_TWSI register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ * @param	sw_twsi		value for eia and op, etc. to read
+ *
+ * @return	value of the register
+ */
+static u64 twsi_read_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
+{
+	unsigned long start = get_timer(0);
+
+	sw_twsi.s.r = 1;
+	sw_twsi.s.v = 1;
+
+	debug("%s(%p, 0x%llx)\n", __func__, baseaddr, sw_twsi.u);
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+
+	do {
+		sw_twsi.u = readq(baseaddr + TWSI_SW_TWSI);
+	} while (sw_twsi.s.v != 0 && get_timer(start) < 50);
+
+	if (sw_twsi.s.v)
+		debug("%s: Error writing 0x%llx\n", __func__, sw_twsi.u);
+
+	debug("%s: Returning 0x%llx\n", __func__, sw_twsi.u);
+	return sw_twsi.u;
+}
+
+/**
+ * Write control register
+ *
+ * @param	baseaddr	Base address for i2c registers
+ * @param	data		data to write
+ */
+static void twsi_write_ctl(void *baseaddr, u8 data)
+{
+	union twsx_sw_twsi twsi_sw;
+
+	debug("%s(%p, 0x%x)\n", __func__, baseaddr, data);
+	twsi_sw.u = 0;
+
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_CTL;
+	twsi_sw.s.data	 = data;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+}
+
+/**
+ * Reads the TWSI Control Register
+ *
+ * @param[in]	baseaddr	Base address for i2c
+ *
+ * @return	8-bit TWSI control register
+ */
+static u32 twsi_read_ctl(void *baseaddr)
+{
+	union twsx_sw_twsi sw_twsi;
+
+	sw_twsi.u	 = 0;
+	sw_twsi.s.op	 = TWSI_SW_EOP_IA;
+	sw_twsi.s.eop_ia = TWSI_CTL;
+
+	sw_twsi.u = twsi_read_sw(baseaddr, sw_twsi);
+	debug("%s(%p): 0x%x\n", __func__, baseaddr, sw_twsi.s.data);
+	return sw_twsi.s.data;
+}
+
+/**
+ * Read i2c status register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ *
+ * @return	value of status register
+ */
+static u8 twsi_read_status(void *baseaddr)
+{
+	union twsx_sw_twsi twsi_sw;
+
+	twsi_sw.u	= 0;
+	twsi_sw.s.op	= TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_STAT;
+
+	return twsi_read_sw(baseaddr, twsi_sw);
+}
+
+/**
+ * Waits for an i2c operation to complete
+ *
+ * @param	baseaddr	Base address of registers
+ *
+ * @return	0 for success, 1 if timeout
+ */
+static int twsi_wait(void *baseaddr)
+{
+	unsigned long start = get_timer(0);
+	u8 twsi_ctl;
+
+	debug("%s(%p)\n", __func__, baseaddr);
+	do {
+		twsi_ctl = twsi_read_ctl(baseaddr);
+		twsi_ctl &= TWSI_CTL_IFLG;
+	} while (!twsi_ctl && get_timer(start) < 50);
+
+	debug("  return: %u\n", !twsi_ctl);
+	return !twsi_ctl;
+}
+
+/**
+ * Unsticks the i2c bus
+ *
+ * @param	baseaddr	base address of registers
+ */
+static int twsi_start_unstick(void *baseaddr)
+{
+	twsi_stop(baseaddr);
+
+	twsi_unblock(baseaddr);
+
+	return 0;
+}
+
+/**
+ * Sends an i2c start condition
+ *
+ * @param	baseaddr	base address of registers
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_start(void *baseaddr)
+{
+	int result;
+	u8 stat;
+
+	debug("%s(%p)\n", __func__, baseaddr);
+	twsi_write_ctl(baseaddr, TWSI_CTL_STA | TWSI_CTL_ENAB);
+	result = twsi_wait(baseaddr);
+	if (result) {
+		stat = twsi_read_status(baseaddr);
+		debug("%s: result: 0x%x, status: 0x%x\n", __func__,
+		      result, stat);
+		switch (stat) {
+		case TWSI_STAT_START:
+		case TWSI_STAT_RSTART:
+			return 0;
+		case TWSI_STAT_RXADDR_ACK:
+		default:
+			return twsi_start_unstick(baseaddr);
+		}
+	}
+	debug("%s: success\n", __func__);
+	return 0;
+}
+
+/**
+ * Sends an i2c stop condition
+ *
+ * @param	baseaddr	register base address
+ *
+ * @return	0 for success, -1 if error
+ */
+static int twsi_stop(void *baseaddr)
+{
+	u8 stat;
+
+	twsi_write_ctl(baseaddr, TWSI_CTL_STP | TWSI_CTL_ENAB);
+
+	stat = twsi_read_status(baseaddr);
+	if (stat != TWSI_STAT_IDLE) {
+		debug("%s: Bad status on bus@%p\n", __func__, baseaddr);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * Writes data to the i2c bus
+ *
+ * @param	baseraddr	register base address
+ * @param	slave_addr	address of slave to write to
+ * @param	buffer		Pointer to buffer to write
+ * @param	length		Number of bytes in buffer to write
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_write_data(void *baseaddr, u8  slave_addr,
+			   u8 *buffer, unsigned int length)
+{
+	union twsx_sw_twsi twsi_sw;
+	unsigned int curr = 0;
+	int result;
+
+	debug("%s(%p, 0x%x, %p, 0x%x)\n", __func__, baseaddr, slave_addr,
+	      buffer, length);
+	result = twsi_start(baseaddr);
+	if (result) {
+		debug("%s: Could not start BUS transaction\n", __func__);
+		return -1;
+	}
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: wait failed\n", __func__);
+		return result;
+	}
+
+	twsi_sw.u	 = 0;
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_DATA;
+	twsi_sw.s.data	 = (u32)(slave_addr << 1) | TWSI_OP_WRITE;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+	debug("%s: Waiting\n", __func__);
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: Timed out writing slave address 0x%x to target\n",
+		      __func__, slave_addr);
+		return result;
+	}
+	result = twsi_read_status(baseaddr);
+	debug("%s: status: (%d) %s\n", __func__, result,
+	      twsi_i2c_status_str(result));
+	if (result != TWSI_STAT_TXADDR_ACK) {
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+		twsi_stop(baseaddr);
+		return twsi_i2c_lost_arb(result, 0);
+	}
+
+	while (curr < length) {
+		twsi_sw.u	 = 0;
+		twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+		twsi_sw.s.eop_ia = TWSI_DATA;
+		twsi_sw.s.data	 = buffer[curr++];
+
+		twsi_write_sw(baseaddr, twsi_sw);
+		twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+		debug("%s: Writing 0x%x\n", __func__, twsi_sw.s.data);
+
+		result = twsi_wait(baseaddr);
+		if (result) {
+			debug("%s: Timed out writing data to 0x%x\n",
+			      __func__, slave_addr);
+			return result;
+		}
+		result = twsi_read_status(baseaddr);
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+	}
+
+	debug("%s: Stopping\n", __func__);
+	return twsi_stop(baseaddr);
+}
+
+/**
+ * Manually clear the I2C bus and send a stop
+ */
+static void twsi_unblock(void *baseaddr)
+{
+	int i;
+	union twsx_int	int_reg;
+
+	int_reg.u = 0;
+	for (i = 0; i < 9; i++) {
+		int_reg.s.scl_ovr = 0;
+		writeq(int_reg.u, baseaddr + TWSI_INT);
+		udelay(5);
+		int_reg.s.scl_ovr = 1;
+		writeq(int_reg.u, baseaddr + TWSI_INT);
+		udelay(5);
+	}
+	int_reg.s.sda_ovr = 1;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+	int_reg.s.scl_ovr = 0;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+	int_reg.u = 0;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+}
+
+/**
+ * Performs a read transaction on the i2c bus
+ *
+ * @param	baseaddr	Base address of twsi registers
+ * @param	slave_addr	i2c bus address to read from
+ * @param	buffer		buffer to read into
+ * @param	length		number of bytes to read
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_read_data(void *baseaddr, u8 slave_addr,
+			  u8 *buffer, unsigned int length)
+{
+	union twsx_sw_twsi twsi_sw;
+	unsigned int curr = 0;
+	int result;
+
+	debug("%s(%p, 0x%x, %p, %u)\n", __func__, baseaddr, slave_addr,
+	      buffer, length);
+	result = twsi_start(baseaddr);
+	if (result) {
+		debug("%s: start failed\n", __func__);
+		return result;
+	}
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: wait failed\n", __func__);
+		return result;
+	}
+
+	twsi_sw.u	 = 0;
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_DATA;
+
+	twsi_sw.s.data  = (u32)(slave_addr << 1) | TWSI_OP_READ;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: waiting for sending addr failed\n", __func__);
+		return result;
+	}
+
+	result = twsi_read_status(baseaddr);
+	debug("%s: status: (%d) %s\n", __func__, result,
+	      twsi_i2c_status_str(result));
+	if (result != TWSI_STAT_RXADDR_ACK) {
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+		twsi_stop(baseaddr);
+		return twsi_i2c_lost_arb(result, 0);
+	}
+
+	while (curr < length) {
+		twsi_write_ctl(baseaddr, TWSI_CTL_ENAB |
+				((curr < length - 1) ? TWSI_CTL_AAK : 0));
+
+		result = twsi_wait(baseaddr);
+		if (result) {
+			debug("%s: waiting for data failed\n", __func__);
+			return result;
+		}
+
+		twsi_sw.u = twsi_read_sw(baseaddr, twsi_sw);
+		buffer[curr++] = twsi_sw.s.data;
+	}
+
+	twsi_stop(baseaddr);
+
+	return 0;
+}
+
+static void twsi_calc_div(unsigned int speed, int *m_div, int *n_div)
+{
+	int io_clock_hz;
+	int tclk, fsamp;
+	int ndiv, mdiv;
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+	io_clock_hz = octeontx_get_io_clock();
+	tclk = io_clock_hz / (2 * (TWSI_THP + 1));
+#elif defined(CONFIG_ARCH_OCTEONTX2)
+	/* Refclk src in mode register defaults to 100MHz clock */
+	io_clock_hz = 100000000; /* 100 Mhz */
+	tclk = io_clock_hz / (TWSI_THP + 2);
+#endif
+	debug("%s( io_clock %u tclk %u)\n", __func__, io_clock_hz, tclk);
+
+	/* Set the TWSI clock to a conservative TWSI_BUS_FREQ.
+	 * Compute the clocks M divider based on the SCLK.
+	 *
+	 * TWSI freq = (core freq) / (10 x (M+1) x 2 * (thp+1) x 2^N)
+	 * M = ((core freq) / (10 x (TWSI freq) x 2 * (thp+1) x 2^N)) - 1
+	 *
+	 * For OcteonTX2 -
+	 * TWSI freq = (core freq) / (10 x (M+1) x (thp+2) x 2^N)
+	 * M = ((core freq) / (10 x (TWSI freq) x (thp+2) x 2^N)) - 1
+	 */
+	for (ndiv = 0; ndiv < 8; ndiv++) {
+		fsamp = tclk / (1 << ndiv);
+		mdiv = fsamp / speed / 10;
+		mdiv -= 1;
+		if (mdiv < 16)
+			break;
+	}
+	*m_div = mdiv;
+	*n_div = ndiv;
+}
+
+static int twsi_init(void *baseaddr, unsigned int speed, int slaveaddr)
+{
+	int n_div, m_div;
+	union twsx_sw_twsi sw_twsi;
+
+	debug("%s(%p, %u, 0x%x)\n", __func__, baseaddr, speed, slaveaddr);
+
+	twsi_calc_div(speed, &m_div, &n_div);
+	if (m_div >= 16)
+		return -1;
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;	/* Clear valid bit */
+	sw_twsi.s.op = 0x6;	/* See EOP field */
+	sw_twsi.s.r = 0;	/* Select CLKCTL when R = 0 */
+	sw_twsi.s.eop_ia = 3;	/* R=0 selects CLKCTL, R=1 selects STAT */
+	sw_twsi.s.data = ((m_div & 0xf) << 3) | ((n_div & 0x7) << 0);
+
+	twsi_write_sw(baseaddr, sw_twsi);
+	/* Only init non-slave ports */
+	debug("%s: Writing 0x%llx to sw_twsi, m_div: 0x%x, n_div: 0x%x\n",
+	      __func__, sw_twsi.u, m_div, n_div);
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.op = TWSI_SW_EOP_IA;
+	sw_twsi.s.r = 0;
+	sw_twsi.s.eop_ia = 0;
+	sw_twsi.s.data = slaveaddr << 1;
+
+	twsi_write_sw(baseaddr, sw_twsi);
+
+	/* Set slave address */
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.op = TWSI_SW_EOP_IA;
+	sw_twsi.s.r = 0;
+	sw_twsi.s.eop_ia = TWSI_EOP_SLAVE_ADDR;
+	sw_twsi.s.data = slaveaddr;
+	twsi_write_sw(baseaddr, sw_twsi);
+
+	return 0;
+}
+
+/**
+ * Transfers data over the i2c bus
+ *
+ * @param	bus	i2c bus to transfer data over
+ * @param	msg	Array of i2c messages
+ * @param	nmsgs	Number of messages to send/receive
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
+			     int nmsgs)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(bus);
+	int result;
+
+	debug("%s: %d messages\n", __func__, nmsgs);
+	for (; nmsgs > 0; nmsgs--, msg++) {
+		debug("%s: chip=0x%x, len=0x%x\n", __func__, msg->addr,
+		      msg->len);
+		if (msg->flags & I2C_M_RD) {
+			debug("%s: Reading data\n", __func__);
+			result = twsi_read_data(twsi->baseaddr, msg->addr,
+						msg->buf, msg->len);
+		} else {
+			debug("%s: Writing data\n", __func__);
+			result = twsi_write_data(twsi->baseaddr, msg->addr,
+						 msg->buf, msg->len);
+		}
+		if (result) {
+			debug("%s: error sending\n", __func__);
+			return -EREMOTEIO;
+		}
+	}
+
+	return 0;
+}
+
+static int octeontx_i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(bus);
+	int m_div, n_div;
+	union twsx_sw_twsi sw_twsi;
+	void *baseaddr = twsi->baseaddr;
+
+	debug("%s(%p, %u)\n", __func__, bus, speed);
+
+	twsi_calc_div(speed, &m_div, &n_div);
+	if (m_div >= 16)
+		return -1;
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;		/* Clear valid bit */
+	sw_twsi.s.op = TWSI_SW_EOP_IA;	/* See EOP field */
+	sw_twsi.s.r = 0;		/* Select CLKCTL when R = 0 */
+	sw_twsi.s.eop_ia = TWSI_CLKCTL;	/* R=0 selects CLKCTL, R=1 selects STAT */
+	sw_twsi.s.data = ((m_div & 0xf) << 3) | ((n_div & 0x7) << 0);
+
+	/* Only init non-slave ports */
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+
+	debug("%s: Wrote 0x%llx to sw_twsi\n", __func__, sw_twsi.u);
+	return 0;
+}
+
+static int octeontx_pci_i2c_probe(struct udevice *dev)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(dev);
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+
+	debug("TWSI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+
+	twsi->baseaddr = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					PCI_REGION_MEM);
+	twsi->id = last_id++;
+
+	debug("TWSI bus %d at %p\n", dev->seq, twsi->baseaddr);
+
+	return twsi_init(twsi->baseaddr,
+			 twsi->id < ARRAY_SIZE(speeds) ?
+			 speeds[twsi->id] : CONFIG_SYS_I2C_SPEED,
+			 CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR);
+}
+
+static const struct dm_i2c_ops octeontx_i2c_ops = {
+	.xfer		= octeontx_i2c_xfer,
+	.set_bus_speed	= octeontx_i2c_set_bus_speed,
+};
+
+static const struct udevice_id octeontx_i2c_ids[] = {
+	{ .compatible = "cavium,thunder-8890-twsi" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_pci_twsi) = {
+	.name	= "i2c_octeontx",
+	.id	= UCLASS_I2C,
+	.of_match = octeontx_i2c_ids,
+	.probe	= octeontx_pci_i2c_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_twsi),
+	.ops	= &octeontx_i2c_ops,
+};
+
+static struct pci_device_id octeontx_twsi_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, 0xa012) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_twsi, octeontx_twsi_supported);
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 509c588582..16638fbf23 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_NS87308) += ns87308.o
 obj-$(CONFIG_NUVOTON_NCT6102D) += nuvoton_nct6102d.o
 obj-$(CONFIG_PCA9551_LED) += pca9551_led.o
 obj-$(CONFIG_$(SPL_)PWRSEQ) += pwrseq-uclass.o
+obj-$(CONFIG_MVEBU_SAR) += mvebu_sar/
 obj-$(CONFIG_QFW) += qfw.o
 obj-$(CONFIG_ROCKCHIP_EFUSE) += rockchip-efuse.o
 obj-$(CONFIG_SANDBOX) += swap_case.o
diff --git a/drivers/misc/mvebu_sar/Makefile b/drivers/misc/mvebu_sar/Makefile
new file mode 100644
index 0000000000..a581c2f9d6
--- /dev/null
+++ b/drivers/misc/mvebu_sar/Makefile
@@ -0,0 +1,12 @@
+
+obj-$(CONFIG_MVEBU_SAR) += sar-uclass.o
+ifdef CONFIG_TARGET_MVEBU_ARMADA_8K
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += ap806_sar.o
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += ap807_sar.o
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += cp110_sar.o
+endif
+
+ifdef CONFIG_TARGET_OCTEONTX2_CN913x
+	obj-$(CONFIG_TARGET_OCTEONTX2_CN913x) += ap807_sar.o
+	obj-$(CONFIG_TARGET_OCTEONTX2_CN913x) += cp110_sar.o
+endif
diff --git a/drivers/misc/mvebu_sar/ap806_sar.c b/drivers/misc/mvebu_sar/ap806_sar.c
new file mode 100644
index 0000000000..3cda3d3b63
--- /dev/null
+++ b/drivers/misc/mvebu_sar/ap806_sar.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <mach/clock.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#include <sar-uclass.h>
+
+#define CPU_CLOCK_ID	0
+#define DDR_CLOCK_ID	1
+#define RING_CLOCK_ID	2
+
+/* SAR AP806 registers */
+#define SAR_CLOCK_FREQ_MODE_OFFSET	0
+#define SAR_CLOCK_FREQ_MODE_MASK	(0x1f << SAR_CLOCK_FREQ_MODE_OFFSET)
+#define SAR_TEST_MODE_ENABLE_OFFSET	5
+#define SAR_TEST_MODE_ENABLE_MASK	(0x1 << SAR_TEST_MODE_ENABLE_OFFSET)
+#define SAR_SKIP_LINK_I2C_INIT_OFFSET	6
+#define SAR_SKIP_LINK_I2C_INIT_MASK	(0x1 << SAR_SKIP_LINK_I2C_INIT_OFFSET)
+#define SAR_POR_BYPASS_OFFSET		7
+#define SAR_POR_BYPASS_MASK		(0x1 << SAR_POR_BYPASS_OFFSET)
+#define SAR_BOOT_SOURCE_OFFSET		8
+#define SAR_BOOT_SOURCE_MASK		(0x7 << SAR_BOOT_SOURCE_OFFSET)
+#define SAR_PIDI_C2C_IHB_SELECT_OFFSET	11
+#define SAR_PIDI_C2C_IHB_SELECT_MASK	(0x1 << SAR_PIDI_C2C_IHB_SELECT_OFFSET)
+#define SAR_I2C_INIT_ENABLE_OFFSET	12
+#define SAR_I2C_INIT_ENABLE_MASK	(0x1 << SAR_I2C_INIT_ENABLE_OFFSET)
+#define SAR_SSCG_DISABLE_OFFSET		13
+#define SAR_SSCG_DISABLE_MASK		(0x1 << SAR_SSCG_DISABLE_OFFSET)
+#define SAR_PIDI_HW_TRAINING_DIS_OFFSET	14
+#define SAR_PIDI_HW_TRAINING_DIS_MASK	(0x1 << SAR_PIDI_HW_TRAINING_DIS_OFFSET)
+#define SAR_CPU_FMAX_REFCLK_OFFSET	15
+#define SAR_CPU_FMAX_REFCLK_MASK	(0x1 << SAR_CPU_FMAX_REFCLK_OFFSET)
+#define SAR_IHB_DIFF_REFCLK_DIS_OFFSET	16
+#define SAR_IHB_DIFF_REFCLK_DIS_MASK	(0x1 << SAR_IHB_DIFF_REFCLK_DIS_OFFSET)
+#define SAR_REF_CLK_MSTR_OFFSET		17
+#define SAR_REF_CLK_MSTR_MASK		(0x1 << SAR_REF_CLK_MSTR_OFFSET)
+#define SAR_CPU_WAKE_UP_OFFSET		18
+#define SAR_CPU_WAKE_UP_MASK		(0x1 << SAR_CPU_WAKE_UP_OFFSET)
+#define SAR_XTAL_BYPASS_OFFSET		19
+#define SAR_XTAL_BYPASS_MASK		(0x1 << SAR_XTAL_BYPASS_OFFSET)
+#define SAR_PIDI_LOW_SPEED_OFFSET	20
+#define SAR_PIDI_LOW_SPEED_MASK		(0x1 << SAR_PIDI_LOW_SPEED_OFFSET)
+
+#define AP806_SAR_1_REG			4
+#define SAR1_PLL2_OFFSET		(9)
+#define SAR1_PLL2_MASK			(0x1f << SAR1_PLL2_OFFSET)
+#define SAR1_PLL1_OFFSET		(14)
+#define SAR1_PLL1_MASK			(0x1f << SAR1_PLL1_OFFSET)
+#define SAR1_PLL0_OFFSET		(19)
+#define SAR1_PLL0_MASK			(0x1f << SAR1_PLL0_OFFSET)
+#define SAR1_PIDI_CONNECT_OFFSET	(24)
+#define SAR1_PIDI_CONNECT_MASK		(0x1 << SAR1_PIDI_CONNECT_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info ap806_sar_0[] = {
+	{"Clock Freq mode		  ",
+		SAR_CLOCK_FREQ_MODE_OFFSET, SAR_CLOCK_FREQ_MODE_MASK },
+	{"Test mode enable		  ",
+		SAR_TEST_MODE_ENABLE_OFFSET, SAR_TEST_MODE_ENABLE_MASK },
+	{"Skip link i2c init		  ",
+		SAR_SKIP_LINK_I2C_INIT_OFFSET, SAR_SKIP_LINK_I2C_INIT_MASK },
+	{"Por ByPass			  ",
+		SAR_POR_BYPASS_OFFSET, SAR_POR_BYPASS_MASK },
+	{"Boot Source			  ",
+		SAR_BOOT_SOURCE_OFFSET, SAR_BOOT_SOURCE_MASK },
+	{"PIDI C2C IHB select		  ",
+		SAR_PIDI_C2C_IHB_SELECT_OFFSET, SAR_PIDI_C2C_IHB_SELECT_MASK },
+	{"I2C init enable		  ",
+		SAR_I2C_INIT_ENABLE_OFFSET, SAR_I2C_INIT_ENABLE_MASK },
+	{"SSCG disable			  ",
+		SAR_SSCG_DISABLE_OFFSET, SAR_SSCG_DISABLE_MASK },
+	{"PIDI hw training disable	  ",
+		SAR_PIDI_HW_TRAINING_DIS_OFFSET,
+		SAR_PIDI_HW_TRAINING_DIS_MASK },
+	{"CPU Fmax refclk select	  ",
+		SAR_CPU_FMAX_REFCLK_OFFSET, SAR_CPU_FMAX_REFCLK_MASK },
+	{"IHB differential refclk disable ",
+		SAR_IHB_DIFF_REFCLK_DIS_OFFSET, SAR_IHB_DIFF_REFCLK_DIS_MASK },
+	{"Ref clk mstr			  ",
+		SAR_REF_CLK_MSTR_OFFSET, SAR_REF_CLK_MSTR_MASK },
+	{"CPU wake up			  ",
+		SAR_CPU_WAKE_UP_OFFSET, SAR_CPU_WAKE_UP_MASK },
+	{"Xtal ByPass			  ",
+		SAR_XTAL_BYPASS_OFFSET, SAR_XTAL_BYPASS_MASK },
+	{"PIDI low speed		  ",
+		SAR_PIDI_LOW_SPEED_OFFSET, SAR_PIDI_LOW_SPEED_MASK },
+	{"",			-1,			-1},
+};
+
+struct sar_info ap806_sar_1[] = {
+	{"PIDI connect       ", SAR1_PIDI_CONNECT_OFFSET,
+				SAR1_PIDI_CONNECT_MASK },
+	{"PLL0 Config        ", SAR1_PLL0_OFFSET, SAR1_PLL0_MASK },
+	{"PLL1 Config        ", SAR1_PLL1_OFFSET, SAR1_PLL1_MASK },
+	{"PLL2 Config        ", SAR1_PLL2_OFFSET, SAR1_PLL2_MASK },
+	{"",			-1,			-1},
+};
+
+enum clocking_options {
+	CPU_2000_DDR_1200_RCLK_1200 = 0x0,
+	CPU_2000_DDR_1050_RCLK_1050 = 0x1,
+	CPU_1600_DDR_800_RCLK_800 = 0x4,
+	CPU_1800_DDR_1200_RCLK_1200 = 0x6,
+	CPU_1800_DDR_1050_RCLK_1050 = 0x7,
+	CPU_1600_DDR_1050_RCLK_1050 = 0x0d,
+	CPU_1000_DDR_650_RCLK_650 = 0x13,
+	CPU_1300_DDR_800_RCLK_800 = 0x14,
+	CPU_1300_DDR_650_RCLK_650 = 0x17,
+	CPU_1200_DDR_800_RCLK_800 = 0x19,
+	CPU_1400_DDR_800_RCLK_800 = 0x1a,
+	CPU_600_DDR_800_RCLK_800 = 0x1b,
+	CPU_800_DDR_800_RCLK_800 = 0x1c,
+	CPU_1000_DDR_800_RCLK_800 = 0x1d,
+};
+
+static const u32 pll_freq_tbl[16][4] = {
+	/* CPU */   /* DDR */   /* Ring */
+	{2.0 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2000_DDR_1200_RCLK_1200},
+	{2.0 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_2000_DDR_1050_RCLK_1050},
+	{1.8 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_1800_DDR_1200_RCLK_1200},
+	{1.8 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_1800_DDR_1050_RCLK_1050},
+	{1.6 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_1600_DDR_1050_RCLK_1050},
+	{1.3 * GHz, 800  * MHz, 800  * MHz, CPU_1300_DDR_800_RCLK_800},
+	{1.3 * GHz, 650  * MHz, 650  * MHz, CPU_1300_DDR_650_RCLK_650},
+	{1.6 * GHz, 800  * MHz, 800  * MHz, CPU_1600_DDR_800_RCLK_800},
+	{1.0 * GHz, 650  * MHz, 650  * MHz, CPU_1000_DDR_650_RCLK_650},
+	{1.2 * GHz, 800  * MHz, 800  * MHz, CPU_1200_DDR_800_RCLK_800},
+	{1.4 * GHz, 800  * MHz, 800  * MHz, CPU_1400_DDR_800_RCLK_800},
+	{600 * MHz, 800  * MHz, 800  * MHz, CPU_600_DDR_800_RCLK_800},
+	{800 * MHz, 800  * MHz, 800  * MHz, CPU_800_DDR_800_RCLK_800},
+	{1.0 * GHz, 800  * MHz, 800  * MHz, CPU_1000_DDR_800_RCLK_800}
+};
+
+static u32 sar_get_clock_freq_mode(struct udevice *dev)
+{
+	u32 i, clock_freq;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mvebu_dfx_sread(&clock_freq, (uintptr_t)priv->sar_base);
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy read */
+		clock_freq = (readl(priv->sar_base));
+
+	clock_freq = (clock_freq & SAR_CLOCK_FREQ_MODE_MASK) >>
+		      SAR_CLOCK_FREQ_MODE_OFFSET;
+
+	for (i = 0; i < 16; i++) {
+		if (pll_freq_tbl[i][3] == clock_freq)
+			return i;
+	}
+	pr_err("sar regs: Unsupported clock freq mode %d", clock_freq);
+	return -1;
+}
+
+int ap806_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 clock_type, clock_freq_mode;
+
+	switch (sar_opt) {
+	case(SAR_CPU_FREQ):
+		clock_type = CPU_CLOCK_ID;
+		break;
+	case(SAR_DDR_FREQ):
+		clock_type = DDR_CLOCK_ID;
+		break;
+	case(SAR_AP_FABRIC_FREQ):
+		clock_type = RING_CLOCK_ID;
+		break;
+	default:
+		pr_err("AP806-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	clock_freq_mode = sar_get_clock_freq_mode(dev);
+	val->raw_sar_val = clock_freq_mode;
+	val->freq = pll_freq_tbl[clock_freq_mode][clock_type];
+	return 0;
+}
+
+static int ap806_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mvebu_dfx_sread(&reg, (uintptr_t)priv->sar_base);
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy */
+		reg = readl(priv->sar_base);
+
+	printf("AP806 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap806_sar_0;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+
+	ret = mvebu_dfx_sread(&reg,
+			      (uintptr_t)(priv->sar_base + AP806_SAR_1_REG));
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy */
+		reg = readl(priv->sar_base + AP806_SAR_1_REG);
+
+	printf("\nAP806 SAR register 1 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap806_sar_1;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+int ap806_sar_init(struct udevice *dev)
+{
+	int ret, i;
+
+	u32 sar_list[] = {
+		SAR_CPU_FREQ,
+		SAR_DDR_FREQ,
+		SAR_AP_FABRIC_FREQ
+	};
+
+	for (i = 0; i < ARRAY_SIZE(sar_list); i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for AP806.\n",
+			       sar_list[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const struct sar_ops ap806_sar_ops = {
+	.sar_init_func = ap806_sar_init,
+	.sar_value_get_func = ap806_sar_value_get,
+	.sar_dump_func = ap806_sar_dump,
+};
+
+U_BOOT_DRIVER(ap806_sar) = {
+	.name = "ap806_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &ap806_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/ap807_sar.c b/drivers/misc/mvebu_sar/ap807_sar.c
new file mode 100644
index 0000000000..5ea26e60e2
--- /dev/null
+++ b/drivers/misc/mvebu_sar/ap807_sar.c
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <mach/clock.h>
+
+#include <sar-uclass.h>
+
+#define CPU_CLOCK_ID	0
+#define DDR_CLOCK_ID	1
+#define RING_CLOCK_ID	2
+
+/* SAR AP807 registers */
+#define SAR_CLOCK_FREQ_MODE_OFFSET	0
+#define SAR_CLOCK_FREQ_MODE_MASK	(0x1f << SAR_CLOCK_FREQ_MODE_OFFSET)
+#define SAR_TEST_MODE_ENABLE_OFFSET	5
+#define SAR_TEST_MODE_ENABLE_MASK	(0x1 << SAR_TEST_MODE_ENABLE_OFFSET)
+#define SAR_SKIP_LINK_I2C_INIT_OFFSET	6
+#define SAR_SKIP_LINK_I2C_INIT_MASK	(0x1 << SAR_SKIP_LINK_I2C_INIT_OFFSET)
+#define SAR_POR_BYPASS_OFFSET		7
+#define SAR_POR_BYPASS_MASK		(0x1 << SAR_POR_BYPASS_OFFSET)
+#define SAR_BOOT_SOURCE_OFFSET		8
+#define SAR_BOOT_SOURCE_MASK		(0x7 << SAR_BOOT_SOURCE_OFFSET)
+#define SAR_PIDI_C2C_IHB_SELECT_OFFSET	11
+#define SAR_PIDI_C2C_IHB_SELECT_MASK	(0x1 << SAR_PIDI_C2C_IHB_SELECT_OFFSET)
+#define SAR_I2C_INIT_ENABLE_OFFSET	12
+#define SAR_I2C_INIT_ENABLE_MASK	(0x1 << SAR_I2C_INIT_ENABLE_OFFSET)
+#define SAR_PIDI_HW_TRAINING_DIS_OFFSET	13
+#define SAR_PIDI_HW_TRAINING_DIS_MASK	(0x1 << SAR_PIDI_HW_TRAINING_DIS_OFFSET)
+#define SAR_CPU_FMAX_REFCLK_OFFSET	14
+#define SAR_CPU_FMAX_REFCLK_MASK	(0x1 << SAR_CPU_FMAX_REFCLK_OFFSET)
+#define SAR_IHB_DIFF_REFCLK_DIS_OFFSET	15
+#define SAR_IHB_DIFF_REFCLK_DIS_MASK	(0x1 << SAR_IHB_DIFF_REFCLK_DIS_OFFSET)
+#define SAR_REF_CLK_MSTR_OFFSET		16
+#define SAR_REF_CLK_MSTR_MASK		(0x1 << SAR_REF_CLK_MSTR_OFFSET)
+#define SAR_CPU_WAKE_UP_OFFSET		17
+#define SAR_CPU_WAKE_UP_MASK		(0x1 << SAR_CPU_WAKE_UP_OFFSET)
+#define SAR_XTAL_BYPASS_OFFSET		18
+#define SAR_XTAL_BYPASS_MASK		(0x1 << SAR_XTAL_BYPASS_OFFSET)
+#define SAR_PIDI_LOW_SPEED_OFFSET	19
+#define SAR_PIDI_LOW_SPEED_MASK		(0x1 << SAR_PIDI_LOW_SPEED_OFFSET)
+
+#define AP807_SAR_1_REG			4
+#define SAR1_PLL2_OFFSET		(9)
+#define SAR1_PLL2_MASK			(0x1f << SAR1_PLL2_OFFSET)
+#define SAR1_PLL1_OFFSET		(14)
+#define SAR1_PLL1_MASK			(0x1f << SAR1_PLL1_OFFSET)
+#define SAR1_PLL0_OFFSET		(19)
+#define SAR1_PLL0_MASK			(0x1f << SAR1_PLL0_OFFSET)
+#define SAR1_PIDI_CONNECT_OFFSET	(24)
+#define SAR1_PIDI_CONNECT_MASK		(0x1 << SAR1_PIDI_CONNECT_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info ap807_sar_0[] = {
+	{"Clock Freq mode		  ",
+		SAR_CLOCK_FREQ_MODE_OFFSET, SAR_CLOCK_FREQ_MODE_MASK },
+	{"Test mode enable		  ",
+		SAR_TEST_MODE_ENABLE_OFFSET, SAR_TEST_MODE_ENABLE_MASK },
+	{"Skip link i2c init		  ",
+		SAR_SKIP_LINK_I2C_INIT_OFFSET, SAR_SKIP_LINK_I2C_INIT_MASK },
+	{"Por ByPass			  ",
+		SAR_POR_BYPASS_OFFSET, SAR_POR_BYPASS_MASK },
+	{"Boot Source			  ",
+		SAR_BOOT_SOURCE_OFFSET, SAR_BOOT_SOURCE_MASK },
+	{"PIDI C2C IHB select		  ",
+		SAR_PIDI_C2C_IHB_SELECT_OFFSET, SAR_PIDI_C2C_IHB_SELECT_MASK },
+	{"I2C init enable		  ",
+		SAR_I2C_INIT_ENABLE_OFFSET, SAR_I2C_INIT_ENABLE_MASK },
+	{"PIDI hw training disable	  ",
+		SAR_PIDI_HW_TRAINING_DIS_OFFSET,
+		SAR_PIDI_HW_TRAINING_DIS_MASK },
+	{"CPU Fmax refclk select	  ",
+		SAR_CPU_FMAX_REFCLK_OFFSET, SAR_CPU_FMAX_REFCLK_MASK },
+	{"IHB differential refclk disable ",
+		SAR_IHB_DIFF_REFCLK_DIS_OFFSET, SAR_IHB_DIFF_REFCLK_DIS_MASK },
+	{"Ref clk mstr			  ",
+		SAR_REF_CLK_MSTR_OFFSET, SAR_REF_CLK_MSTR_MASK },
+	{"CPU wake up			  ",
+		SAR_CPU_WAKE_UP_OFFSET, SAR_CPU_WAKE_UP_MASK },
+	{"Xtal ByPass			  ",
+		SAR_XTAL_BYPASS_OFFSET, SAR_XTAL_BYPASS_MASK },
+	{"PIDI low speed		  ",
+		SAR_PIDI_LOW_SPEED_OFFSET, SAR_PIDI_LOW_SPEED_MASK },
+	{"",			-1,			-1},
+};
+
+struct sar_info ap807_sar_1[] = {
+	{"PIDI connect       ", SAR1_PIDI_CONNECT_OFFSET,
+				SAR1_PIDI_CONNECT_MASK },
+	{"PLL0 Config        ", SAR1_PLL0_OFFSET, SAR1_PLL0_MASK },
+	{"PLL1 Config        ", SAR1_PLL1_OFFSET, SAR1_PLL1_MASK },
+	{"PLL2 Config        ", SAR1_PLL2_OFFSET, SAR1_PLL2_MASK },
+	{"",			-1,			-1},
+};
+
+enum clocking_options {
+	CPU_2000_DDR_1200_RCLK_1200 = 0x0,
+	CPU_2000_DDR_1050_RCLK_1050 = 0x1,
+	CPU_2200_DDR_1200_RCLK_1200 = 0x6,
+	CPU_1800_DDR_1050_RCLK_1200 = 0x7,
+	CPU_1600_DDR_1200_RCLK_1200 = 0x0d,
+	CPU_1600_DDR_900_RCLK_900 = 0x0e,
+	CPU_1300_DDR_800_RCLK_800 = 0x14,
+};
+
+static const u32 pll_freq_tbl[16][4] = {
+	/* CPU */   /* DDR */   /* Ring */
+	{2.0 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2000_DDR_1200_RCLK_1200},
+	{2.0 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_2000_DDR_1050_RCLK_1050},
+	{2.2 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2200_DDR_1200_RCLK_1200},
+	{1.8 * GHz, 1.05 * GHz, 1.2 * GHz, CPU_1800_DDR_1050_RCLK_1200},
+	{1.6 * GHz, 1.2 * GHz, 1.2 * GHz, CPU_1600_DDR_1200_RCLK_1200},
+	{1.6 * GHz, 0.9  * GHz, 0.9  * GHz, CPU_1600_DDR_900_RCLK_900},
+	{1.3 * GHz, 0.8  * GHz, 0.8  * GHz, CPU_1300_DDR_800_RCLK_800},
+};
+
+static u32 sar_get_clock_freq_mode(struct udevice *dev)
+{
+	u32 i, clock_freq;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mvebu_dfx_sread(&clock_freq, (uintptr_t)priv->sar_base);
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy read */
+		clock_freq = (readl(priv->sar_base));
+
+	clock_freq = (clock_freq & SAR_CLOCK_FREQ_MODE_MASK) >>
+		      SAR_CLOCK_FREQ_MODE_OFFSET;
+
+	for (i = 0; i < 7; i++) {
+		if (pll_freq_tbl[i][3] == clock_freq)
+			return i;
+	}
+	pr_err("sar regs: unsupported clock freq mode %d", clock_freq);
+	return -1;
+}
+
+int ap807_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 clock_type, clock_freq_mode;
+
+	switch (sar_opt) {
+	case(SAR_CPU_FREQ):
+		clock_type = CPU_CLOCK_ID;
+		break;
+	case(SAR_DDR_FREQ):
+		clock_type = DDR_CLOCK_ID;
+		break;
+	case(SAR_AP_FABRIC_FREQ):
+		clock_type = RING_CLOCK_ID;
+		break;
+	default:
+		pr_err("AP807-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	clock_freq_mode = sar_get_clock_freq_mode(dev);
+	val->raw_sar_val = clock_freq_mode;
+	val->freq = pll_freq_tbl[clock_freq_mode][clock_type];
+	return 0;
+}
+
+static int ap807_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mvebu_dfx_sread(&reg, (uintptr_t)priv->sar_base);
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy */
+		reg = readl(priv->sar_base);
+
+	printf("AP807 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap807_sar_0;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+
+	ret = mvebu_dfx_sread(&reg,
+			      (uintptr_t)(priv->sar_base + AP807_SAR_1_REG));
+	if (ret != SMCCC_RET_SUCCESS) /* try legacy */
+		reg = readl(priv->sar_base + AP807_SAR_1_REG);
+
+	printf("\nAP807 SAR register 1 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap807_sar_1;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+int ap807_sar_init(struct udevice *dev)
+{
+	int ret, i;
+
+	u32 sar_list[] = {
+		SAR_CPU_FREQ,
+		SAR_DDR_FREQ,
+		SAR_AP_FABRIC_FREQ
+	};
+
+	for (i = 0; i < ARRAY_SIZE(sar_list); i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for AP807.\n",
+			       sar_list[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const struct sar_ops ap807_sar_ops = {
+	.sar_init_func = ap807_sar_init,
+	.sar_value_get_func = ap807_sar_value_get,
+	.sar_dump_func = ap807_sar_dump,
+};
+
+U_BOOT_DRIVER(ap807_sar) = {
+	.name = "ap807_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &ap807_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/cp110_sar.c b/drivers/misc/mvebu_sar/cp110_sar.c
new file mode 100644
index 0000000000..d319c7d070
--- /dev/null
+++ b/drivers/misc/mvebu_sar/cp110_sar.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#include <sar-uclass.h>
+
+/* SAR CP1 registers */
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET	(0)
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK	\
+	(0x1 << SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET	(1)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK	\
+	(0x1 << SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET)
+
+/* SAR CP0 registers */
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET	(2)
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK	\
+	(0x1 << SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET	(3)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK	\
+	(0x1 << SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET)
+
+#define SAR1_RST_BOOT_MODE_AP_CP0_OFFSET	(4)
+#define SAR1_RST_BOOT_MODE_AP_CP0_MASK		\
+	(0x3f << SAR1_RST_BOOT_MODE_AP_CP0_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info cp110_sar_1[] = {
+	{"PCIE0 clock config   ", SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET,
+				  SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK},
+	{"PCIE1 clock config   ", SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET,
+				  SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK},
+	{"",			-1,			-1},
+};
+
+struct sar_info cp110_sar_0[] = {
+	{"PCIE0 clock config   ", SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET,
+				  SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK},
+	{"PCIE1 clock config   ", SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET,
+				  SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK},
+	{"Reset Boot Mode     ", SAR1_RST_BOOT_MODE_AP_CP0_OFFSET,
+				 SAR1_RST_BOOT_MODE_AP_CP0_MASK },
+	{"",			-1,			-1},
+};
+
+struct bootsrc_idx_info {
+	int start;
+	int end;
+	enum mvebu_bootsrc_type src;
+	int index;
+};
+
+static struct bootsrc_idx_info bootsrc_list[] = {
+	{0x0,	0x5,	BOOTSRC_NOR,		0},
+	{0xA,	0x25,	BOOTSRC_NAND,		0},
+	{0x28,	0x28,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x29,	0x29,	BOOTSRC_SD_EMMC,	0},
+	{0x2A,	0x2A,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x2B,	0x2B,	BOOTSRC_SD_EMMC,	0},
+	{0x30,	0x30,	BOOTSRC_AP_SPI,		0},
+	{0x31,	0x31,	BOOTSRC_AP_SPI,		0}, /* BootRom disabled */
+	{0x32,	0x33,	BOOTSRC_SPI,		1},
+	{0x34,	0x35,	BOOTSRC_SPI,		0},
+	{0x36,	0x37,	BOOTSRC_SPI,		1}, /* BootRom disabled */
+	{-1,	-1,	-1}
+};
+
+int cp110_sar_bootsrc_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			  struct sar_val *val)
+{
+	u32 reg, mode;
+	int i;
+
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	mode = (reg & SAR1_RST_BOOT_MODE_AP_CP0_MASK) >>
+		SAR1_RST_BOOT_MODE_AP_CP0_OFFSET;
+
+	val->raw_sar_val = mode;
+
+	i = 0;
+	while (bootsrc_list[i].start != -1) {
+		if ((mode >= bootsrc_list[i].start) &&
+		    (mode <= bootsrc_list[i].end)) {
+			val->bootsrc.type = bootsrc_list[i].src;
+			val->bootsrc.index = bootsrc_list[i].index;
+			break;
+		}
+		i++;
+	}
+
+	if (bootsrc_list[i].start == -1) {
+		pr_err("Bad CP110 sample at reset mode (%d).\n", mode);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int cp110_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 reg, mode;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+
+	switch (sar_opt) {
+	case SAR_BOOT_SRC:
+		return cp110_sar_bootsrc_get(dev, sar_opt, val);
+	case SAR_CP0_PCIE0_CLK:
+		mode = (reg & SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK) >>
+			SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP0_PCIE1_CLK:
+		mode = (reg & SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK) >>
+			SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP1_PCIE0_CLK:
+		mode = (reg & SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK) >>
+			SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP1_PCIE1_CLK:
+		mode = (reg & SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK) >>
+			SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	default:
+		pr_err("AP806-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cp110_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	printf("\nCP110 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+
+	if (!strcmp(priv->sar_name, "cp0-sar"))
+		sar = cp110_sar_0;
+	else
+		sar = cp110_sar_1;
+
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+static int cp110_sar_register(struct udevice *dev, u32 sar_list[], int size)
+{
+	int ret, i;
+
+	for (i = 0; i < size; i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for %s.\n",
+			       sar_list[i], dev->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int cp110_sar_init(struct udevice *dev)
+{
+	int ret = 0;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	u32 cp0_sar_list[] = {
+		SAR_CP0_PCIE0_CLK,
+		SAR_CP0_PCIE1_CLK,
+		SAR_BOOT_SRC
+	};
+
+	u32 cp1_sar_list[] = {
+		SAR_CP1_PCIE0_CLK,
+		SAR_CP1_PCIE1_CLK,
+	};
+
+	if (!strcmp(priv->sar_name, "cp0-sar"))
+		ret = cp110_sar_register(dev, cp0_sar_list,
+					 ARRAY_SIZE(cp0_sar_list));
+	else if (!strcmp(priv->sar_name, "cp1-sar"))
+		ret = cp110_sar_register(dev, cp1_sar_list,
+					 ARRAY_SIZE(cp1_sar_list));
+
+	if (ret)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct sar_ops cp110_sar_ops = {
+	.sar_init_func = cp110_sar_init,
+	.sar_value_get_func = cp110_sar_value_get,
+	.sar_dump_func = cp110_sar_dump,
+};
+
+U_BOOT_DRIVER(cp110_sar) = {
+	.name = "cp110_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &cp110_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/sar-uclass.c b/drivers/misc/mvebu_sar/sar-uclass.c
new file mode 100644
index 0000000000..74cfe9faca
--- /dev/null
+++ b/drivers/misc/mvebu_sar/sar-uclass.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <sar-uclass.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SAR_MAX_CHIP	4
+
+UCLASS_DRIVER(sar) = {
+	.name = "sar",
+	.id = UCLASS_SAR,
+};
+
+struct udevice *__attribute__((section(".data")))soc_sar_info[SAR_MAX_IDX];
+
+int mvebu_sar_id_register(struct udevice *dev, u32 sar_id)
+{
+	if (soc_sar_info[sar_id]) {
+		pr_err("sar %d was already registered.\n", sar_id);
+		return -EBUSY;
+	}
+	soc_sar_info[sar_id] = dev;
+
+	return 0;
+}
+
+/* find all drivers for sar device and initialize each driver */
+int mvebu_sar_init(void)
+{
+	int ret, i;
+	int node, chip_count, sar_list[SAR_MAX_CHIP];
+	const void *blob = gd->fdt_blob;
+	struct udevice *sar_chip[SAR_MAX_CHIP];
+	struct dm_sar_pdata *priv;
+	const struct sar_ops *ops;
+	struct udevice *parent;
+	struct driver_info sar_drivers[SAR_MAX_CHIP];
+	void *sar_base = NULL;
+	const char *sar_driver, *sar_name;
+
+	chip_count = fdtdec_find_aliases_for_id(blob, "sar-reg",
+						COMPAT_MVEBU_SAR_REG_COMMON,
+						sar_list, SAR_MAX_CHIP);
+
+	if (chip_count <= 0) {
+		pr_err("Cannot find sample-at-reset dt entry (%d).\n",
+		       chip_count);
+		return -ENODEV;
+	}
+	uclass_get_device_by_name(UCLASS_ROOT, "root_driver", &parent);
+	memset(soc_sar_info, 0, sizeof(soc_sar_info));
+
+	for (i = 0; i < chip_count ; i++) {
+		node = sar_list[i];
+		if (node <= 0)
+			continue;
+
+		/* Skip if Node is disabled */
+		if (!fdtdec_get_is_enabled(blob, node))
+			continue;
+		/* Binding stage */
+		sar_driver = fdt_getprop(blob, node, "sar-driver", NULL);
+		sar_drivers[i].name = sar_driver;
+		ret = device_bind_by_name(parent, false,
+					  &sar_drivers[i], &sar_chip[i]);
+
+		if (!sar_chip[i]) {
+			pr_err("SAR driver binding failed\n");
+			return 0;
+		}
+
+		/* fetch driver info from device-tree */
+		sar_base = (void *)fdtdec_get_addr_size_auto_noparent(blob,
+				node, "reg", 0, NULL, true);
+		if (!sar_base) {
+			pr_err("SAR address isn't found in the device-tree\n");
+			return 0;
+		}
+		sar_name = fdt_getprop(blob, node, "sar-name", NULL);
+		/* Initialize driver priv struct */
+		device_probe(sar_chip[i]);
+		priv = dev_get_priv(sar_chip[i]);
+		priv->sar_base = sar_base;
+		priv->sar_name = sar_name;
+		ops = device_get_ops(sar_chip[i]);
+		if (!ops->sar_init_func)
+			return -EINVAL;
+
+		ret = ops->sar_init_func(sar_chip[i]);
+		if (ret) {
+			pr_err("sar_init failed (%d).\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val)
+{
+	const struct sar_ops *ops;
+
+	if (soc_sar_info[opt]) {
+		ops = device_get_ops(soc_sar_info[opt]);
+		return ops->sar_value_get_func(soc_sar_info[opt], opt, val);
+	}
+
+	pr_err("SAR - No chip registered on sar %d.\n", opt);
+	return -ENODEV;
+}
+
+char *mvebu_sar_bootsrc_to_name(enum mvebu_bootsrc_type src)
+{
+	switch (src) {
+	case(BOOTSRC_NAND):
+		return "nand";
+	case(BOOTSRC_SPI):
+	case(BOOTSRC_AP_SPI):
+		return "spi";
+	case(BOOTSRC_SD_EMMC):
+	case(BOOTSRC_AP_SD_EMMC):
+		return "mmc";
+	case(BOOTSRC_NOR):
+		return "nor";
+	default:
+		return "unknown";
+	}
+}
+
+void mvebu_sar_dump(struct udevice *dev)
+{
+	const struct sar_ops *ops;
+
+	ops = device_get_ops(dev);
+
+	ops->sar_dump_func(dev);
+}
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 7361bcaf8e..19da6f88e2 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -289,6 +289,17 @@ config MMC_PCI
 
 	  If unsure, say N.
 
+config MMC_OCTEONTX
+	bool "Marvell OcteonTX Multimedia Card Interface support"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	depends on DM_MMC
+	help
+	  This selects the OcteonTX Multimedia card Interface.
+	  If you have an OcteonTX/TX2 board with a Multimedia Card slot,
+	  say Y here.
+
+	  If unsure, say N.
+
 config MMC_OMAP_HS
 	bool "TI OMAP High Speed Multimedia Card Interface support"
 	select DM_REGULATOR_PBIAS if DM_MMC && DM_REGULATOR
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 5594195528..91398a9be0 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_MVEBU_MMC) += mvebu_mmc.o
 obj-$(CONFIG_MMC_OMAP_HS)		+= omap_hsmmc.o
 obj-$(CONFIG_MMC_MXC)			+= mxcmmc.o
 obj-$(CONFIG_MMC_MXS)			+= mxsmmc.o
+obj-$(CONFIG_MMC_OCTEONTX)		+= octeontx_hsmmc.o
 obj-$(CONFIG_MMC_PCI)			+= pci_mmc.o
 obj-$(CONFIG_PXA_MMC_GENERIC) += pxa_mmc_gen.o
 obj-$(CONFIG_SUPPORT_EMMC_RPMB) += rpmb.o
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index c8f71cd0c1..f98676820d 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -2630,7 +2630,7 @@ __weak void board_mmc_power_init(void)
 }
 #endif
 
-static int mmc_power_init(struct mmc *mmc)
+int mmc_power_init(struct mmc *mmc)
 {
 #if CONFIG_IS_ENABLED(DM_MMC)
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
@@ -2957,8 +2957,14 @@ static int mmc_probe(bd_t *bis)
 	}
 	uclass_foreach_dev(dev, uc) {
 		ret = device_probe(dev);
-		if (ret)
-			pr_err("%s - probe failed: %d\n", dev->name, ret);
+		if (ret) {
+			if (ret == -ENODEV || ret == -ENXIO)
+				pr_debug("%s: probe of %s rejects match %d\n",
+					 __func__, dev->name, ret);
+			else
+				pr_err("%s - probe failed: %d\n",
+				       dev->name, ret);
+		}
 	}
 
 	return 0;
diff --git a/drivers/mmc/octeontx_hsmmc.c b/drivers/mmc/octeontx_hsmmc.c
new file mode 100644
index 0000000000..95544b1960
--- /dev/null
+++ b/drivers/mmc/octeontx_hsmmc.c
@@ -0,0 +1,3867 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <mmc.h>
+#include <part.h>
+#include <asm/io.h>
+#include <dm.h>
+#include <dm/lists.h>
+#include <errno.h>
+#include <pci.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <asm/arch/csrs/csrs-mio_emm.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/board.h>
+#include <linux/list.h>
+#include <div64.h>
+#include <watchdog.h>
+#include <power/regulator.h>
+#include <console.h>	/* for ctrlc */
+#include "octeontx_hsmmc.h"
+
+#define PCI_DEVICE_ID_OCTEONTX_EMMC	0xA010
+
+#define MMC_TIMEOUT_SHORT	20	/* in ms */
+#define MMC_TIMEOUT_LONG	1000
+#define MMC_TIMEOUT_ERASE	10000
+
+#define MMC_DEFAULT_DATA_IN_TAP			10
+#define MMC_DEFAULT_CMD_IN_TAP			10
+#define MMC_DEFAULT_CMD_OUT_TAP			39
+#define MMC_DEFAULT_DATA_OUT_TAP		39
+#define MMC_DEFAULT_HS200_CMD_IN_TAP		24
+#define MMC_DEFAULT_HS200_DATA_IN_TAP		24
+#define MMC_DEFAULT_HS200_CMD_OUT_TAP	(otx_is_soc(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS200_DATA_OUT_TAP	(otx_is_soc(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS400_CMD_OUT_TAP	(otx_is_soc(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS400_DATA_OUT_TAP	(otx_is_soc(CN95XX) ? 5 : 3)
+#define MMC_DEFAULT_HS200_CMD_OUT_DLY		800	/* Delay in ps */
+#define MMC_DEFAULT_HS200_DATA_OUT_DLY		800	/* Delay in ps */
+#define MMC_DEFAULT_HS400_CMD_OUT_DLY		800	/* Delay in ps */
+#define MMC_DEFAULT_HS400_DATA_OUT_DLY		400	/* Delay in ps */
+#define MMC_DEFAULT_SD_UHS_SDR104_CMD_OUT_TAP	MMC_DEFAULT_HS200_CMD_OUT_TAP
+#define MMC_DEFAULT_SD_UHS_SDR104_DATA_OUT_TAP	MMC_DEFAULT_HS200_DATA_OUT_TAP
+#define MMC_LEGACY_DEFAULT_CMD_OUT_TAP		39
+#define MMC_LEGACY_DEFAULT_DATA_OUT_TAP		39
+#define MMC_SD_LEGACY_DEFAULT_CMD_OUT_TAP	63
+#define MMC_SD_LEGACY_DEFAULT_DATA_OUT_TAP	63
+#define MMC_HS_CMD_OUT_TAP			32
+#define MMC_HS_DATA_OUT_TAP			32
+#define MMC_SD_HS_CMD_OUT_TAP			26
+#define MMC_SD_HS_DATA_OUT_TAP			26
+#define MMC_SD_UHS_SDR25_CMD_OUT_TAP		26
+#define MMC_SD_UHS_SDR25_DATA_OUT_TAP		26
+#define MMC_SD_UHS_SDR50_CMD_OUT_TAP		26
+#define MMC_SD_UHS_SDR50_DATA_OUT_TAP		26
+#define MMC_DEFAULT_TAP_DELAY			4
+#define TOTAL_NO_OF_TAPS			512
+static void octeontx_mmc_switch_to(struct mmc *mmc);
+static int octeontx_mmc_configure_delay(struct mmc *mmc);
+#ifdef MMC_SUPPORTS_TUNING
+static void octeontx_mmc_set_timing(struct mmc *mmc);
+#endif
+static void set_wdog(struct mmc *mmc, u64 us);
+static void do_switch(struct mmc *mmc, union mio_emm_switch emm_switch);
+static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+				 struct mmc_data *data);
+#ifndef CONFIG_ARCH_OCTEONTX
+static int octeontx2_mmc_calc_delay(struct mmc *mmc, int delay);
+static int octeontx_mmc_calibrate_delay(struct mmc *mmc);
+#endif
+static int octeontx_mmc_set_input_bus_timing(struct mmc *mmc);
+static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc);
+
+static bool host_probed;
+
+/**
+ * Get the slot data structure from a MMC data structure
+ */
+static inline struct octeontx_mmc_slot *mmc_to_slot(struct mmc *mmc)
+{
+	return container_of(mmc, struct octeontx_mmc_slot, mmc);
+}
+
+static inline struct octeontx_mmc_host *mmc_to_host(struct mmc *mmc)
+{
+	return mmc_to_slot(mmc)->host;
+}
+
+static inline struct octeontx_mmc_slot *dev_to_mmc_slot(struct udevice *dev)
+{
+	return dev_get_priv(dev);
+}
+
+static inline struct mmc *dev_to_mmc(struct udevice *dev)
+{
+	return &((struct octeontx_mmc_slot *)dev_get_priv(dev))->mmc;
+}
+
+#ifdef DEBUG
+const char *mmc_reg_str(u64 reg)
+{
+	if (reg == MIO_EMM_DMA_CFG())
+		return "MIO_EMM_DMA_CFG";
+	if (reg == MIO_EMM_DMA_ADR())
+		return "MIO_EMM_DMA_ADR";
+	if (reg == MIO_EMM_DMA_INT())
+		return "MIO_EMM_DMA_INT";
+	if (reg == MIO_EMM_CFG())
+		return "MIO_EMM_CFG";
+	if (reg == MIO_EMM_MODEX(0))
+		return "MIO_EMM_MODE0";
+	if (reg == MIO_EMM_MODEX(1))
+		return "MIO_EMM_MODE1";
+	if (reg == MIO_EMM_MODEX(2))
+		return "MIO_EMM_MODE2";
+	if (reg == MIO_EMM_MODEX(3))
+		return "MIO_EMM_MODE3";
+	if (reg == MIO_EMM_IO_CTL())
+		return "MIO_EMM_IO_CTL";
+	if (reg == MIO_EMM_SWITCH())
+		return "MIO_EMM_SWITCH";
+	if (reg == MIO_EMM_DMA())
+		return "MIO_EMM_DMA";
+	if (reg == MIO_EMM_CMD())
+		return "MIO_EMM_CMD";
+	if (reg == MIO_EMM_RSP_STS())
+		return "MIO_EMM_RSP_STS";
+	if (reg == MIO_EMM_RSP_LO())
+		return "MIO_EMM_RSP_LO";
+	if (reg == MIO_EMM_RSP_HI())
+		return "MIO_EMM_RSP_HI";
+	if (reg == MIO_EMM_INT())
+		return "MIO_EMM_INT";
+	if (reg == MIO_EMM_WDOG())
+		return "MIO_EMM_WDOG";
+	if (reg == MIO_EMM_DMA_ARG())
+		return "MIO_EMM_DMA_ARG";
+#if defined(CONFIG_ARCH_OCTEONTX)
+	if (reg == MIO_EMM_SAMPLE())
+		return "MIO_EMM_SAMPLE";
+#endif
+	if (reg == MIO_EMM_STS_MASK())
+		return "MIO_EMM_STS_MASK";
+	if (reg == MIO_EMM_RCA())
+		return "MIO_EMM_RCA";
+	if (reg == MIO_EMM_BUF_IDX())
+		return "MIO_EMM_BUF_IDX";
+	if (reg == MIO_EMM_BUF_DAT())
+		return "MIO_EMM_BUF_DAT";
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	if (reg == MIO_EMM_CALB())
+		return "MIO_EMM_CALB";
+	if (reg == MIO_EMM_TAP())
+		return "MIO_EMM_TAP";
+	if (reg == MIO_EMM_TIMING())
+		return "MIO_EMM_TIMING";
+	if (reg == MIO_EMM_DEBUG())
+		return "MIO_EMM_DEBUG";
+#endif
+	return "UNKNOWN";
+}
+#endif
+
+static void octeontx_print_rsp_sts(struct mmc *mmc)
+{
+#ifdef DEBUG
+	union mio_emm_rsp_sts emm_rsp_sts;
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	static const char * const ctype_xor_str[] = {
+		"No data",
+		"Read data into Dbuf",
+		"Write data from Dbuf",
+		"Reserved"
+	};
+
+	static const char * const rtype_xor_str[] = {
+		"No response",
+		"R1, 48 bits",
+		"R2, 136 bits",
+		"R3, 48 bits",
+		"R4, 48 bits",
+		"R5, 48 bits",
+		"Reserved 6",
+		"Reserved 7"
+	};
+
+	emm_rsp_sts.u = readq(host->base_addr + MIO_EMM_RSP_STS());
+	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
+	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_rsp_sts.s.cmd_val ? "yes" : "no");
+	printf("    58:    switch_val:          %s\n",
+	       emm_rsp_sts.s.switch_val ? "yes" : "no");
+	printf("    57:    dma_val:             %s\n",
+	       emm_rsp_sts.s.dma_val ? "yes" : "no");
+	printf("    56:    dma_pend:            %s\n",
+	       emm_rsp_sts.s.dma_pend ? "yes" : "no");
+	printf("    28:    dbuf_err:            %s\n",
+	       emm_rsp_sts.s.dbuf_err ? "yes" : "no");
+	printf("    23:    dbuf:                %u\n", emm_rsp_sts.s.dbuf);
+	printf("    22:    blk_timeout:         %s\n",
+	       emm_rsp_sts.s.blk_timeout ? "yes" : "no");
+	printf("    21:    blk_crc_err:         %s\n",
+	       emm_rsp_sts.s.blk_crc_err ? "yes" : "no");
+	printf("    20:    rsp_busybit:         %s\n",
+	       emm_rsp_sts.s.rsp_busybit ? "yes" : "no");
+	printf("    19:    stp_timeout:         %s\n",
+	       emm_rsp_sts.s.stp_timeout ? "yes" : "no");
+	printf("    18:    stp_crc_err:         %s\n",
+	       emm_rsp_sts.s.stp_crc_err ? "yes" : "no");
+	printf("    17:    stp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.stp_bad_sts ? "yes" : "no");
+	printf("    16:    stp_val:             %s\n",
+	       emm_rsp_sts.s.stp_val ? "yes" : "no");
+	printf("    15:    rsp_timeout:         %s\n",
+	       emm_rsp_sts.s.rsp_timeout ? "yes" : "no");
+	printf("    14:    rsp_crc_err:         %s\n",
+	       emm_rsp_sts.s.rsp_crc_err ? "yes" : "no");
+	printf("    13:    rsp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.rsp_bad_sts ? "yes" : "no");
+	printf("    12:    rsp_val:             %s\n",
+	       emm_rsp_sts.s.rsp_val ? "yes" : "no");
+	printf("    9-11:  rsp_type:            %s\n",
+	       rtype_xor_str[emm_rsp_sts.s.rsp_type]);
+	printf("    7-8:   cmd_type:            %s\n",
+	       ctype_xor_str[emm_rsp_sts.s.cmd_type]);
+	printf("    1-6:   cmd_idx:             %u\n",
+	       emm_rsp_sts.s.cmd_idx);
+	printf("    0:     cmd_done:            %s\n",
+	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
+#endif
+}
+
+static inline u64 read_csr(struct mmc *mmc, u64 reg)
+{
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	u64 value = readq(host->base_addr + reg);
+#ifdef DEBUG_CSR
+	printf("        %s: %s(0x%p) => 0x%llx\n", __func__,
+	       mmc_reg_str(reg), host->base_addr + reg,
+	       value);
+#endif
+	return value;
+}
+
+/**
+ * Writes to a CSR register
+ *
+ * @param[in]	mmc	pointer to mmc data structure
+ * @param	reg	register offset
+ * @param	value	value to write to register
+ */
+static inline void write_csr(struct mmc *mmc, u64 reg, u64 value)
+{
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	void *addr = host->base_addr + reg;
+
+#ifdef DEBUG_CSR
+	printf("        %s: %s(0x%p) <= 0x%llx\n", __func__, mmc_reg_str(reg),
+	       addr, value);
+#endif
+	writeq(value, addr);
+}
+
+#ifdef DEBUG
+static void mmc_print_status(u32 status)
+{
+#ifdef DEBUG_STATUS
+	static const char * const state[] = {
+		"Idle",		/* 0 */
+		"Ready",	/* 1 */
+		"Ident",	/* 2 */
+		"Standby",	/* 3 */
+		"Tran",		/* 4 */
+		"Data",		/* 5 */
+		"Receive",	/* 6 */
+		"Program",	/* 7 */
+		"Dis",		/* 8 */
+		"Btst",		/* 9 */
+		"Sleep",	/* 10 */
+		"reserved",	/* 11 */
+		"reserved",	/* 12 */
+		"reserved",	/* 13 */
+		"reserved",	/* 14 */
+		"reserved"	/* 15 */ };
+	if (status & R1_APP_CMD)
+		puts("MMC ACMD\n");
+	if (status & R1_SWITCH_ERROR)
+		puts("MMC switch error\n");
+	if (status & R1_READY_FOR_DATA)
+		puts("MMC ready for data\n");
+	printf("MMC %s state\n", state[R1_CURRENT_STATE(status)]);
+	if (status & R1_ERASE_RESET)
+		puts("MMC erase reset\n");
+	if (status & R1_WP_ERASE_SKIP)
+		puts("MMC partial erase due to write protected blocks\n");
+	if (status & R1_CID_CSD_OVERWRITE)
+		puts("MMC CID/CSD overwrite error\n");
+	if (status & R1_ERROR)
+		puts("MMC undefined device error\n");
+	if (status & R1_CC_ERROR)
+		puts("MMC device error\n");
+	if (status & R1_CARD_ECC_FAILED)
+		puts("MMC internal ECC failed to correct data\n");
+	if (status & R1_ILLEGAL_COMMAND)
+		puts("MMC illegal command\n");
+	if (status & R1_COM_CRC_ERROR)
+		puts("MMC CRC of previous command failed\n");
+	if (status & R1_LOCK_UNLOCK_FAILED)
+		puts("MMC sequence or password error in lock/unlock device command\n");
+	if (status & R1_CARD_IS_LOCKED)
+		puts("MMC device locked by host\n");
+	if (status & R1_WP_VIOLATION)
+		puts("MMC attempt to program write protected block\n");
+	if (status & R1_ERASE_PARAM)
+		puts("MMC invalid selection of erase groups for erase\n");
+	if (status & R1_ERASE_SEQ_ERROR)
+		puts("MMC error in sequence of erase commands\n");
+	if (status & R1_BLOCK_LEN_ERROR)
+		puts("MMC block length error\n");
+	if (status & R1_ADDRESS_ERROR)
+		puts("MMC address misalign error\n");
+	if (status & R1_OUT_OF_RANGE)
+		puts("MMC address out of range\n");
+#endif
+}
+#endif
+
+/**
+ * Print out all of the register values where mmc is optional
+ *
+ * @param mmc	MMC device (can be NULL)
+ * @param host	Pointer to host data structure (can be NULL if mmc is !NULL)
+ */
+static void octeontx_mmc_print_registers2(struct mmc *mmc,
+					  struct octeontx_mmc_host *host)
+{
+	struct octeontx_mmc_slot *slot = mmc ? mmc->priv : NULL;
+	union mio_emm_dma_cfg emm_dma_cfg;
+	union mio_emm_dma_adr emm_dma_adr;
+	union mio_emm_dma_int emm_dma_int;
+	union mio_emm_cfg emm_cfg;
+	union mio_emm_modex emm_mode;
+	union mio_emm_switch emm_switch;
+	union mio_emm_dma emm_dma;
+	union mio_emm_cmd emm_cmd;
+	union mio_emm_rsp_sts emm_rsp_sts;
+	union mio_emm_rsp_lo emm_rsp_lo;
+	union mio_emm_rsp_hi emm_rsp_hi;
+	union mio_emm_int emm_int;
+	union mio_emm_wdog emm_wdog;
+#if defined(CONFIG_ARCH_OCTEONTX)
+	union mio_emm_sample emm_sample;
+#else
+	union mio_emm_calb emm_calb;
+	union mio_emm_tap emm_tap;
+	union mio_emm_timing emm_timing;
+	union mio_emm_io_ctl io_ctl;
+	union mio_emm_debug emm_debug;
+#endif
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_rca emm_rca;
+	int bus;
+
+	static const char * const bus_width_str[] = {
+		"1-bit data bus (power on)",
+		"4-bit data bus",
+		"8-bit data bus",
+		"reserved (3)",
+		"reserved (4)",
+		"4-bit data bus (dual data rate)",
+		"8-bit data bus (dual data rate)",
+		"reserved (7)",
+		"reserved (8)",
+		"invalid (9)",
+		"invalid (10)",
+		"invalid (11)",
+		"invalid (12)",
+		"invalid (13)",
+		"invalid (14)",
+		"invalid (15)",
+	};
+	static const char * const ctype_xor_str[] = {
+		"No data",
+		"Read data into Dbuf",
+		"Write data from Dbuf",
+		"Reserved"
+	};
+
+	static const char * const rtype_xor_str[] = {
+		"No response",
+		"R1, 48 bits",
+		"R2, 136 bits",
+		"R3, 48 bits",
+		"R4, 48 bits",
+		"R5, 48 bits",
+		"Reserved 6",
+		"Reserved 7"
+	};
+
+	if (!host && mmc)
+		host = mmc_to_host(mmc);
+
+	if (mmc)
+		printf("%s: bus id: %u\n", __func__, slot->bus_id);
+	emm_dma_cfg.u = readq(host->base_addr + MIO_EMM_DMA_CFG());
+	printf("MIO_EMM_DMA_CFG:                0x%016llx\n",
+	       emm_dma_cfg.u);
+	printf("    63:    en:                  %s\n",
+	       emm_dma_cfg.s.en ? "enabled" : "disabled");
+	printf("    62:    rw:                  %s\n",
+	       emm_dma_cfg.s.rw ? "write" : "read");
+	printf("    61:    clr:                 %s\n",
+	       emm_dma_cfg.s.clr ? "clear" : "not clear");
+	printf("    59:    swap32:              %s\n",
+	       emm_dma_cfg.s.swap32 ? "yes" : "no");
+	printf("    58:    swap16:              %s\n",
+	       emm_dma_cfg.s.swap16 ? "yes" : "no");
+	printf("    57:    swap8:               %s\n",
+	       emm_dma_cfg.s.swap8 ? "yes" : "no");
+	printf("    56:    endian:              %s\n",
+	       emm_dma_cfg.s.endian ? "little" : "big");
+	printf("    36-55: size:                %u\n",
+	       emm_dma_cfg.s.size);
+
+	emm_dma_adr.u = readq(host->base_addr + MIO_EMM_DMA_ADR());
+	printf("MIO_EMM_DMA_ADR:              0x%016llx\n", emm_dma_adr.u);
+	printf("    0-49:  adr:                 0x%llx\n",
+	       (u64)emm_dma_adr.s.adr);
+
+	emm_dma_int.u = readq(host->base_addr + MIO_EMM_DMA_INT());
+	printf("\nMIO_EMM_DMA_INT:              0x%016llx\n",
+	       emm_dma_int.u);
+	printf("    1:     FIFO:                %s\n",
+	       emm_dma_int.s.fifo ? "yes" : "no");
+	printf("    0:     Done:                %s\n",
+	       emm_dma_int.s.done ? "yes" : "no");
+		emm_cfg.u = readq(host->base_addr + MIO_EMM_CFG());
+
+	printf("\nMIO_EMM_CFG:                  0x%016llx\n",
+	       emm_cfg.u);
+	printf("    3:     bus_ena3:            %s\n",
+	       emm_cfg.s.bus_ena & 0x08 ? "yes" : "no");
+	printf("    2:     bus_ena2:            %s\n",
+	       emm_cfg.s.bus_ena & 0x04 ? "yes" : "no");
+	printf("    1:     bus_ena1:            %s\n",
+	       emm_cfg.s.bus_ena & 0x02 ? "yes" : "no");
+	printf("    0:     bus_ena0:            %s\n",
+	       emm_cfg.s.bus_ena & 0x01 ? "yes" : "no");
+	for (bus = 0; bus < 4; bus++) {
+		emm_mode.u = readq(host->base_addr + MIO_EMM_MODEX(bus));
+		printf("\nMIO_EMM_MODE%u:               0x%016llx\n",
+		       bus, emm_mode.u);
+#ifndef CONFIG_ARCH_OCTEONTX
+		printf("    50:    hs400_timing:        %s\n",
+		       emm_mode.s.hs400_timing ? "yes" : "no");
+		printf("    49:    hs200_timing:        %s\n",
+		       emm_mode.s.hs200_timing ? "yes" : "no");
+#endif
+		printf("    48:    hs_timing:           %s\n",
+		       emm_mode.s.hs_timing ? "yes" : "no");
+		printf("    40-42: bus_width:           %s\n",
+		       bus_width_str[emm_mode.s.bus_width]);
+		printf("    32-35: power_class          %u\n",
+		       emm_mode.s.power_class);
+		printf("    16-31: clk_hi:              %u\n",
+		       emm_mode.s.clk_hi);
+		printf("    0-15:  clk_lo:              %u\n",
+		       emm_mode.s.clk_lo);
+	}
+
+	emm_switch.u = readq(host->base_addr + MIO_EMM_SWITCH());
+	printf("\nMIO_EMM_SWITCH:               0x%016llx\n", emm_switch.u);
+	printf("    60-61: bus_id:              %u\n", emm_switch.s.bus_id);
+	printf("    59:    switch_exe:          %s\n",
+	       emm_switch.s.switch_exe ? "yes" : "no");
+	printf("    58:    switch_err0:         %s\n",
+	       emm_switch.s.switch_err0 ? "yes" : "no");
+	printf("    57:    switch_err1:         %s\n",
+	       emm_switch.s.switch_err1 ? "yes" : "no");
+	printf("    56:    switch_err2:         %s\n",
+	       emm_switch.s.switch_err2 ? "yes" : "no");
+	printf("    48:    hs_timing:           %s\n",
+	       emm_switch.s.hs_timing ? "yes" : "no");
+	printf("    42-40: bus_width:           %s\n",
+	       bus_width_str[emm_switch.s.bus_width]);
+	printf("    32-35: power_class:         %u\n",
+	       emm_switch.s.power_class);
+	printf("    16-31: clk_hi:              %u\n",
+	       emm_switch.s.clk_hi);
+	printf("    0-15:  clk_lo:              %u\n", emm_switch.s.clk_lo);
+
+	emm_dma.u = readq(host->base_addr + MIO_EMM_DMA());
+	printf("\nMIO_EMM_DMA:                  0x%016llx\n", emm_dma.u);
+	printf("    60-61: bus_id:              %u\n", emm_dma.s.bus_id);
+	printf("    59:    dma_val:             %s\n",
+	       emm_dma.s.dma_val ? "yes" : "no");
+	printf("    58:    sector:              %s mode\n",
+	       emm_dma.s.sector ? "sector" : "byte");
+	printf("    57:    dat_null:            %s\n",
+	       emm_dma.s.dat_null ? "yes" : "no");
+	printf("    51-56: thres:               %u\n", emm_dma.s.thres);
+	printf("    50:    rel_wr:              %s\n",
+	       emm_dma.s.rel_wr ? "yes" : "no");
+	printf("    49:    rw:                  %s\n",
+	       emm_dma.s.rw ? "write" : "read");
+	printf("    48:    multi:               %s\n",
+	       emm_dma.s.multi ? "yes" : "no");
+	printf("    32-47: block_cnt:           %u\n",
+	       emm_dma.s.block_cnt);
+	printf("    0-31:  card_addr:           0x%x\n",
+	       emm_dma.s.card_addr);
+
+	emm_cmd.u = readq(host->base_addr + MIO_EMM_CMD());
+	printf("\nMIO_EMM_CMD:                  0x%016llx\n", emm_cmd.u);
+	printf("\n  62:    skip_busy:           %s\n",
+	       emm_cmd.s.skip_busy ? "yes" : "no");
+	printf("    60-61: bus_id:              %u\n", emm_cmd.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_cmd.s.cmd_val ? "yes" : "no");
+	printf("    55:    dbuf:                %u\n", emm_cmd.s.dbuf);
+	printf("    49-54: offset:              %u\n", emm_cmd.s.offset);
+	printf("    41-42: ctype_xor:           %s\n",
+	       ctype_xor_str[emm_cmd.s.ctype_xor]);
+	printf("    38-40: rtype_xor:           %s\n",
+	       rtype_xor_str[emm_cmd.s.rtype_xor]);
+	printf("    32-37: cmd_idx:             %u\n", emm_cmd.s.cmd_idx);
+	printf("    0-31:  arg:                 0x%x\n", emm_cmd.s.arg);
+
+	emm_rsp_sts.u = readq(host->base_addr + MIO_EMM_RSP_STS());
+	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
+	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_rsp_sts.s.cmd_val ? "yes" : "no");
+	printf("    58:    switch_val:          %s\n",
+	       emm_rsp_sts.s.switch_val ? "yes" : "no");
+	printf("    57:    dma_val:             %s\n",
+	       emm_rsp_sts.s.dma_val ? "yes" : "no");
+	printf("    56:    dma_pend:            %s\n",
+	       emm_rsp_sts.s.dma_pend ? "yes" : "no");
+	printf("    28:    dbuf_err:            %s\n",
+	       emm_rsp_sts.s.dbuf_err ? "yes" : "no");
+	printf("    23:    dbuf:                %u\n", emm_rsp_sts.s.dbuf);
+	printf("    22:    blk_timeout:         %s\n",
+	       emm_rsp_sts.s.blk_timeout ? "yes" : "no");
+	printf("    21:    blk_crc_err:         %s\n",
+	       emm_rsp_sts.s.blk_crc_err ? "yes" : "no");
+	printf("    20:    rsp_busybit:         %s\n",
+	       emm_rsp_sts.s.rsp_busybit ? "yes" : "no");
+	printf("    19:    stp_timeout:         %s\n",
+	       emm_rsp_sts.s.stp_timeout ? "yes" : "no");
+	printf("    18:    stp_crc_err:         %s\n",
+	       emm_rsp_sts.s.stp_crc_err ? "yes" : "no");
+	printf("    17:    stp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.stp_bad_sts ? "yes" : "no");
+	printf("    16:    stp_val:             %s\n",
+	       emm_rsp_sts.s.stp_val ? "yes" : "no");
+	printf("    15:    rsp_timeout:         %s\n",
+	       emm_rsp_sts.s.rsp_timeout ? "yes" : "no");
+	printf("    14:    rsp_crc_err:         %s\n",
+	       emm_rsp_sts.s.rsp_crc_err ? "yes" : "no");
+	printf("    13:    rsp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.rsp_bad_sts ? "yes" : "no");
+	printf("    12:    rsp_val:             %s\n",
+	       emm_rsp_sts.s.rsp_val ? "yes" : "no");
+	printf("    9-11:  rsp_type:            %s\n",
+	       rtype_xor_str[emm_rsp_sts.s.rsp_type]);
+	printf("    7-8:   cmd_type:            %s\n",
+	       ctype_xor_str[emm_rsp_sts.s.cmd_type]);
+	printf("    1-6:   cmd_idx:             %u\n",
+	       emm_rsp_sts.s.cmd_idx);
+	printf("    0:     cmd_done:            %s\n",
+	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
+
+	emm_rsp_lo.u = readq(host->base_addr + MIO_EMM_RSP_LO());
+	printf("\nMIO_EMM_RSP_STS_LO:           0x%016llx\n", emm_rsp_lo.u);
+
+	emm_rsp_hi.u = readq(host->base_addr + MIO_EMM_RSP_HI());
+	printf("\nMIO_EMM_RSP_STS_HI:           0x%016llx\n", emm_rsp_hi.u);
+
+	emm_int.u = readq(host->base_addr + MIO_EMM_INT());
+	printf("\nMIO_EMM_INT:                  0x%016llx\n", emm_int.u);
+	printf("    6:    switch_err:           %s\n",
+	       emm_int.s.switch_err ? "yes" : "no");
+	printf("    5:    switch_done:          %s\n",
+	       emm_int.s.switch_done ? "yes" : "no");
+	printf("    4:    dma_err:              %s\n",
+	       emm_int.s.dma_err ? "yes" : "no");
+	printf("    3:    cmd_err:              %s\n",
+	       emm_int.s.cmd_err ? "yes" : "no");
+	printf("    2:    dma_done:             %s\n",
+	       emm_int.s.dma_done ? "yes" : "no");
+	printf("    1:    cmd_done:             %s\n",
+	       emm_int.s.cmd_done ? "yes" : "no");
+	printf("    0:    buf_done:             %s\n",
+	       emm_int.s.buf_done ? "yes" : "no");
+
+	emm_wdog.u = readq(host->base_addr + MIO_EMM_WDOG());
+	printf("\nMIO_EMM_WDOG:                 0x%016llx (%u)\n",
+	       emm_wdog.u, emm_wdog.s.clk_cnt);
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+	emm_sample.u = readq(host->base_addr + MIO_EMM_SAMPLE());
+	printf("\nMIO_EMM_SAMPLE:               0x%016llx\n", emm_sample.u);
+	printf("    16-25: cmd_cnt:             %u\n", emm_sample.s.cmd_cnt);
+	printf("    0-9:   dat_cnt:             %u\n", emm_sample.s.dat_cnt);
+#endif
+
+	emm_sts_mask.u = readq(host->base_addr + MIO_EMM_STS_MASK());
+	printf("\nMIO_EMM_STS_MASK:             0x%016llx\n", emm_sts_mask.u);
+
+	emm_rca.u = readq(host->base_addr + MIO_EMM_RCA());
+	printf("\nMIO_EMM_RCA:                  0x%016llx\n", emm_rca.u);
+	printf("    0-15:  card_rca:            0x%04x\n",
+	       emm_rca.s.card_rca);
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	emm_calb.u = readq(host->base_addr + MIO_EMM_CALB());
+	printf("\nMIO_EMM_CALB:                 0x%016llx\n", emm_calb.u);
+	printf("       0:  start:               %u\n", emm_calb.s.start);
+	emm_tap.u = readq(host->base_addr + MIO_EMM_TAP());
+	printf("\nMIO_EMM_TAP:                  0x%016llx\n", emm_tap.u);
+	printf("     7-0:  delay:               %u\n", emm_tap.s.delay);
+	emm_timing.u = readq(host->base_addr + MIO_EMM_TIMING());
+	printf("\nMIO_EMM_TIMING:               0x%016llx\n", emm_timing.u);
+	printf("   53-48:  cmd_in_tap:          %u\n",
+	       emm_timing.s.cmd_in_tap);
+	printf("   37-32:  cmd_out_tap:         %u\n",
+	       emm_timing.s.cmd_out_tap);
+	printf("   21-16:  data_in_tap:         %u\n",
+	       emm_timing.s.data_in_tap);
+	printf("     5-0:  data_out_tap:        %u\n",
+	       emm_timing.s.data_out_tap);
+	io_ctl.u = readq(host->base_addr + MIO_EMM_IO_CTL());
+	printf("\nMIO_IO_CTL:                   0x%016llx\n", io_ctl.u);
+	printf("     3-2:  drive:               %u (%u mA)\n",
+	       io_ctl.s.drive, 2 << io_ctl.s.drive);
+	printf("       0:  slew:                %u %s\n", io_ctl.s.slew,
+	       io_ctl.s.slew ? "high" : "low");
+	emm_debug.u = readq(host->base_addr + MIO_EMM_DEBUG());
+	printf("\nMIO_EMM_DEBUG:                0x%016llx\n", emm_debug.u);
+	printf("      21: rdsync_rst            0x%x\n",
+	       emm_debug.s.rdsync_rst);
+	printf("      20: emmc_clk_disable      0x%x\n",
+	       emm_debug.s.emmc_clk_disable);
+	printf("   19-16: dma_sm:               0x%x\n", emm_debug.s.dma_sm);
+	printf("   15-12: data_sm:              0x%x\n", emm_debug.s.data_sm);
+	printf("    11-8: cmd_sm:               0x%x\n", emm_debug.s.cmd_sm);
+	printf("       0: clk_on:               0x%x\n", emm_debug.s.clk_on);
+#endif
+	puts("\n");
+}
+
+/**
+ * Print out all of the register values
+ *
+ * @param mmc	MMC device
+ */
+static void octeontx_mmc_print_registers(struct mmc *mmc)
+{
+#ifdef DEBUG_REGISTERS
+	const int print = 1;
+#else
+	const int print = 0;
+#endif
+	if (print)
+		octeontx_mmc_print_registers2(mmc, mmc_to_host(mmc));
+}
+
+static const struct octeontx_sd_mods octeontx_cr_types[] = {
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD0 */
+{ {0, 3}, {0, 3}, {0, 0} },	/* CMD1 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD2 */
+{ {0, 1}, {0, 3}, {0, 0} },	/* CMD3 SD_CMD_SEND_RELATIVE_ADDR 0, 2 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD4 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD5 */
+{ {0, 1}, {1, 1}, {0, 1} },	/*
+				 * CMD6 SD_CMD_SWITCH_FUNC 1,0
+				 * (ACMD) SD_APP_SET_BUS_WIDTH
+				 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD7 */
+{ {1, 1}, {0, 3}, {0, 0} },	/* CMD8 SD_CMD_SEND_IF_COND 1,2 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD9 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD10 */
+{ {1, 1}, {0, 1}, {1, 1} },	/* CMD11 SD_CMD_SWITCH_UHS18V 1,0 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD12 */
+{ {0, 1}, {0, 1}, {1, 3} },	/* CMD13 (ACMD)) SD_CMD_APP_SD_STATUS 1,2 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD14 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD15 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD16 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD17 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD18 */
+{ {3, 1}, {3, 1}, {0, 0} },	/* CMD19 */
+{ {2, 1}, {0, 0}, {0, 0} },	/* CMD20 */	/* SD 2,0 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD21 */
+{ {0, 0}, {0, 0}, {1, 1} },	/* CMD22 (ACMD) SD_APP_SEND_NUM_WR_BLKS 1,0 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD23 */	/* SD ACMD 1,0 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD24 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD25 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD26 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD27 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD28 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD29 */
+{ {1, 1}, {1, 1}, {1, 1} },	/* CMD30 */
+{ {1, 1}, {1, 1}, {1, 1} },	/* CMD31 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD32 SD_CMD_ERASE_WR_BLK_START 0,1 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD33 SD_CMD_ERASE_WR_BLK_END 0,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD34 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD35 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD36 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD37 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD38 */
+{ {0, 4}, {0, 4}, {0, 4} },	/* CMD39 */
+{ {0, 5}, {0, 5}, {0, 5} },	/* CMD40 */
+{ {0, 0}, {0, 0}, {0, 3} },	/* CMD41 (ACMD) SD_CMD_APP_SEND_OP_COND 0,3 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD42 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD43 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD44 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD45 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD46 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD47 */
+{ {0, 0}, {1, 0}, {0, 0} },	/* CMD48 SD_CMD_READ_EXTR_SINGLE */
+{ {0, 0}, {2, 0}, {0, 0} },	/* CMD49 SD_CMD_WRITE_EXTR_SINGLE */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD50 */
+{ {0, 0}, {0, 0}, {1, 1} },	/* CMD51 (ACMD) SD_CMD_APP_SEND_SCR 1,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD52 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD53 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD54 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD55 */
+{ {0xff, 0xff}, {0xff, 0xff}, {0xff, 0xff} },	/* CMD56 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD57 */
+{ {0, 0}, {0, 3}, {0, 3} },	/* CMD58 SD_CMD_SPI_READ_OCR 0,3 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD59 SD_CMD_SPI_CRC_ON_OFF 0,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD60 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD61 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD62 */
+{ {0, 0}, {0, 0}, {0, 0} }	/* CMD63 */
+};
+
+/**
+ * Returns XOR values needed for SD commands and other quirks
+ *
+ * @param	mmc	mmc device
+ * @param	cmd	command information
+ *
+ * @return octeontx_mmc_cr_mods data structure with various quirks and flags
+ */
+static struct octeontx_mmc_cr_mods
+octeontx_mmc_get_cr_mods(struct mmc *mmc, const struct mmc_cmd *cmd,
+			 const struct mmc_data *data)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_cr_mods cr = {0, 0};
+	const struct octeontx_sd_mods *sdm =
+					&octeontx_cr_types[cmd->cmdidx & 0x3f];
+	u8 c = sdm->mmc.c, r = sdm->mmc.r;
+	u8 desired_ctype = 0;
+
+	if (IS_MMC(mmc)) {
+#ifdef MMC_SUPPORTS_TUNING
+		if (cmd->cmdidx == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+			if (cmd->resp_type == MMC_RSP_R1)
+				cr.rtype_xor = 1;
+			if (data && data->flags & MMC_DATA_READ)
+				cr.ctype_xor = 1;
+		}
+#endif
+		return cr;
+	}
+
+	if (cmd->cmdidx == 56)
+		c = (cmd->cmdarg & 1) ? 1 : 2;
+
+	if (data) {
+		if (data->flags & MMC_DATA_READ)
+			desired_ctype = 1;
+		else if (data->flags & MMC_DATA_WRITE)
+			desired_ctype = 2;
+	}
+
+	cr.ctype_xor = c ^ desired_ctype;
+	if (slot->is_acmd)
+		cr.rtype_xor = r ^ sdm->sdacmd.r;
+	else
+		cr.rtype_xor = r ^ sdm->sd.r;
+
+	debug("%s(%s): mmc c: %d, mmc r: %d, desired c: %d, xor c: %d, xor r: %d\n",
+	      __func__, mmc->dev->name, c, r, desired_ctype,
+	      cr.ctype_xor, cr.rtype_xor);
+	return cr;
+}
+
+/**
+ * Keep track of switch commands internally
+ */
+static void octeontx_mmc_track_switch(struct mmc *mmc, u32 cmd_arg)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	u8 how = (cmd_arg >> 24) & 3;
+	u8 where = (u8)(cmd_arg >> 16);
+	u8 val = (u8)(cmd_arg >> 8);
+
+	slot->want_switch = slot->cached_switch;
+
+	if (slot->is_acmd)
+		return;
+
+	if (how != 3)
+		return;
+
+	switch (where) {
+	case EXT_CSD_BUS_WIDTH:
+		slot->want_switch.s.bus_width = val;
+		break;
+	case EXT_CSD_POWER_CLASS:
+		slot->want_switch.s.power_class = val;
+		break;
+	case EXT_CSD_HS_TIMING:
+		slot->want_switch.s.hs_timing = 0;
+		slot->want_switch.s.hs200_timing = 0;
+		slot->want_switch.s.hs400_timing = 0;
+		switch (val & 0xf) {
+		case 0:
+			break;
+		case 1:
+			slot->want_switch.s.hs_timing = 1;
+			break;
+		case 2:
+			if (!slot->is_asim && !slot->is_emul)
+				slot->want_switch.s.hs200_timing = 1;
+			break;
+		case 3:
+			if (!slot->is_asim && !slot->is_emul)
+				slot->want_switch.s.hs400_timing = 1;
+			break;
+		default:
+			pr_err("%s(%s): Unsupported timing mode 0x%x\n",
+			       __func__, mmc->dev->name, val & 0xf);
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int octeontx_mmc_print_rsp_errors(struct mmc *mmc,
+					 union mio_emm_rsp_sts rsp_sts)
+{
+	bool err = false;
+	const char *name = mmc->dev->name;
+
+	if (rsp_sts.s.acc_timeout) {
+		pr_warn("%s(%s): acc_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.dbuf_err) {
+		pr_warn("%s(%s): dbuf_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.blk_timeout) {
+		pr_warn("%s(%s): blk_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.blk_crc_err) {
+		pr_warn("%s(%s): blk_crc_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_timeout) {
+		pr_warn("%s(%s): stp_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_crc_err) {
+		pr_warn("%s(%s): stp_crc_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_bad_sts) {
+		pr_warn("%s(%s): stp_bad_sts\n", __func__, name);
+		err = true;
+	}
+	if (err)
+		pr_warn("  rsp_sts: 0x%llx\n", rsp_sts.u);
+
+	return err ? -1 : 0;
+}
+
+/**
+ * Starts a DMA operation for block read/write
+ *
+ * @param	mmc	mmc device
+ * @param	write	true if write operation
+ * @param	clear	true to clear DMA operation
+ * @param	adr	source or destination DMA address
+ * @param	size	size in blocks
+ * @param	timeout	timeout in ms
+ */
+static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
+				   bool clear, u32 block, dma_addr_t adr,
+				   u32 size, int timeout)
+{
+	const struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_dma_cfg emm_dma_cfg;
+	union mio_emm_dma_adr emm_dma_adr;
+	union mio_emm_dma emm_dma;
+
+	/* Clear any interrupts */
+	write_csr(mmc, MIO_EMM_DMA_INT(),
+		  read_csr(mmc, MIO_EMM_DMA_INT()));
+
+	emm_dma_cfg.u = 0;
+	emm_dma_cfg.s.en = 1;
+	emm_dma_cfg.s.rw = !!write;
+	emm_dma_cfg.s.clr = !!clear;
+	emm_dma_cfg.s.size = ((u64)(size * mmc->read_bl_len) / 8) - 1;
+#if __BYTE_ORDER != __BIG_ENDIAN
+	emm_dma_cfg.s.endian = 1;
+#endif
+	emm_dma_adr.u = 0;
+	emm_dma_adr.s.adr = adr;
+	write_csr(mmc, MIO_EMM_DMA_ADR(), emm_dma_adr.u);
+	write_csr(mmc, MIO_EMM_DMA_CFG(), emm_dma_cfg.u);
+
+	emm_dma.u = 0;
+	emm_dma.s.bus_id = slot->bus_id;
+	emm_dma.s.dma_val = 1;
+	emm_dma.s.rw = !!write;
+	emm_dma.s.sector = mmc->high_capacity ? 1 : 0;
+
+	if (size > 1 && ((IS_SD(mmc) && (mmc->scr[0] & 2)) || !IS_SD(mmc)))
+		emm_dma.s.multi = 1;
+	else
+		emm_dma.s.multi = 0;
+
+	emm_dma.s.block_cnt = size;
+	if (!mmc->high_capacity)
+		block *= mmc->read_bl_len;
+	emm_dma.s.card_addr = block;
+	debug("%s(%s): card address: 0x%x, size: %d, multi: %d\n",
+	      __func__, mmc->dev->name, block, size, emm_dma.s.multi);
+
+	if (timeout > 0)
+		timeout = (timeout * 1000) - 1000;
+	set_wdog(mmc, timeout);
+
+	debug("  Writing 0x%llx to mio_emm_dma\n", emm_dma.u);
+	write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
+}
+
+/**
+ * Waits for a DMA operation to complete
+ *
+ * @param	mmc	mmc device
+ * @param	timeout	timeout in ms
+ *
+ * @return	0 for success (could be DMA errors), -ETIMEDOUT on timeout
+ */
+
+/**
+ * Cleanup DMA engine after a failure
+ *
+ * @param	mmc	mmc device
+ * @param	rsp_sts	rsp status
+ */
+static void octeontx_mmc_cleanup_dma(struct mmc *mmc,
+				     union mio_emm_rsp_sts rsp_sts)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_dma emm_dma;
+	ulong start;
+	int retries = 3;
+
+	do {
+		debug("%s(%s): rsp_sts: 0x%llx, rsp_lo: 0x%llx, dma_int: 0x%llx\n",
+		      __func__, mmc->dev->name, rsp_sts.u,
+		      read_csr(mmc, MIO_EMM_RSP_LO()),
+		      read_csr(mmc, MIO_EMM_DMA_INT()));
+		emm_dma.u = read_csr(mmc, MIO_EMM_DMA());
+		emm_dma.s.dma_val = 1;
+		emm_dma.s.dat_null = 1;
+		emm_dma.s.bus_id = slot->bus_id;
+		write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
+		start = get_timer(0);
+		do {
+			rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+			WATCHDOG_RESET();
+		} while (get_timer(start) < 100 &&
+			 (rsp_sts.s.dma_val || rsp_sts.s.dma_pend));
+	} while (retries-- >= 0 && rsp_sts.s.dma_pend);
+	if (rsp_sts.s.dma_val)
+		pr_err("%s(%s): Error: could not clean up DMA.  RSP_STS: 0x%llx, RSP_LO: 0x%llx\n",
+		       __func__, mmc->dev->name, rsp_sts.u,
+		       read_csr(mmc, MIO_EMM_RSP_LO()));
+	debug("  rsp_sts after clearing up DMA: 0x%llx\n",
+	      read_csr(mmc, MIO_EMM_RSP_STS()));
+}
+
+/**
+ * Waits for a DMA operation to complete
+ *
+ * @param	mmc	mmc device
+ * @param	timeout	timeout in ms
+ * @param	verbose	true to print out error information
+ *
+ * @return	0 for success (could be DMA errors), -ETIMEDOUT on timeout
+ *		or -EIO if IO error.
+ */
+static int octeontx_mmc_wait_dma(struct mmc *mmc, bool write, ulong timeout,
+				 bool verbose)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	ulong start_time = get_timer(0);
+	union mio_emm_dma_int emm_dma_int;
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_dma emm_dma;
+	bool timed_out = false;
+	bool err = false;
+
+	debug("%s(%s, %lu, %d), delay: %uus\n", __func__, mmc->dev->name,
+	      timeout, verbose, host->dma_wait_delay);
+
+	udelay(host->dma_wait_delay);
+	do {
+		emm_dma_int.u = read_csr(mmc, MIO_EMM_DMA_INT());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+		if (write) {
+			if ((rsp_sts.s.dma_pend && !rsp_sts.s.dma_val) ||
+			    rsp_sts.s.blk_timeout ||
+			    rsp_sts.s.stp_timeout ||
+			    rsp_sts.s.rsp_timeout) {
+				err = true;
+#ifdef DEBUG
+				debug("%s: f1\n", __func__);
+				octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+#endif
+				break;
+			}
+		} else {
+			if (rsp_sts.s.blk_crc_err ||
+			    (rsp_sts.s.dma_pend && !rsp_sts.s.dma_val)) {
+				err = true;
+#if defined(DEBUG)
+				octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+#endif
+				break;
+			}
+		}
+		if (rsp_sts.s.dma_pend) {
+			/*
+			 * If this is set then an error has occurred.
+			 * Try and restart the DMA operation.
+			 */
+			emm_dma.u = read_csr(mmc, MIO_EMM_DMA());
+			if (verbose) {
+				pr_err("%s(%s): DMA pending error: rsp_sts: 0x%llx, dma_int: 0x%llx, emm_dma: 0x%llx\n",
+				       __func__, mmc->dev->name, rsp_sts.u,
+				       emm_dma_int.u, emm_dma.u);
+				octeontx_print_rsp_sts(mmc);
+				debug("  MIO_EMM_DEBUG: 0x%llx\n",
+				      read_csr(mmc, MIO_EMM_DEBUG()));
+				pr_err("%s: Trying DMA resume...\n", __func__);
+			}
+			emm_dma.s.dma_val = 1;
+			emm_dma.s.dat_null = 1;
+			write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
+			udelay(10);
+		} else if (!rsp_sts.s.dma_val && emm_dma_int.s.done) {
+			break;
+		}
+		WATCHDOG_RESET();
+		timed_out = (get_timer(start_time) > timeout);
+	} while (!timed_out);
+
+	if (timed_out || err) {
+		if (verbose) {
+			pr_err("%s(%s): MMC DMA %s after %lu ms, rsp_sts: 0x%llx, dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+			       __func__, mmc->dev->name,
+			       timed_out ? "timed out" : "error",
+			       get_timer(start_time), rsp_sts.u,
+			       emm_dma_int.u,
+			       read_csr(mmc, MIO_EMM_RSP_LO()),
+			       read_csr(mmc, MIO_EMM_DMA()));
+			octeontx_print_rsp_sts(mmc);
+		}
+		if (rsp_sts.s.dma_pend)
+			octeontx_mmc_cleanup_dma(mmc, rsp_sts);
+	} else {
+		write_csr(mmc, MIO_EMM_DMA_INT(),
+			  read_csr(mmc, MIO_EMM_DMA_INT()));
+	}
+
+	return timed_out ? -ETIMEDOUT : (err ? -EIO : 0);
+}
+
+/**
+ * Read blocks from the MMC/SD device
+ *
+ * @param	mmc	mmc device
+ * @param	cmd	command
+ * @param	data	data for read
+ * @param	verbose	true to print out error information
+ *
+ * @return	number of blocks read or 0 if error
+ */
+static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
+				    struct mmc_data *data, bool verbose)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	union mio_emm_rsp_sts rsp_sts;
+	dma_addr_t dma_addr = (dma_addr_t)dm_pci_virt_to_mem(host->dev,
+							     data->dest);
+	ulong count;
+	ulong blkcnt = data->blocks;
+	ulong start = cmd->cmdarg;
+	int timeout = 1000 + blkcnt * 20;
+	bool timed_out = false;
+	bool multi_xfer = cmd->cmdidx == MMC_CMD_READ_MULTIPLE_BLOCK;
+
+	debug("%s(%s): dest: %p, dma address: 0x%llx, blkcnt: %lu, start: %lu\n",
+	      __func__, mmc->dev->name, data->dest, dma_addr, blkcnt, start);
+	debug("%s: rsp_sts: 0x%llx\n", __func__,
+	      read_csr(mmc, MIO_EMM_RSP_STS()));
+	/* use max timeout for multi-block transfers */
+	/* timeout = 0; */
+
+	/*
+	 * If we have a valid SD card in the slot, we set the response bit
+	 * mask to check for CRC errors and timeouts only.
+	 * Otherwise, use the default power on reset value.
+	 */
+	write_csr(mmc, MIO_EMM_STS_MASK(),
+		  IS_SD(mmc) ? 0x00b00000ull : 0xe4390080ull);
+	invalidate_dcache_range((u64)data->dest,
+				(u64)data->dest + blkcnt * data->blocksize);
+
+	if (multi_xfer) {
+		octeontx_mmc_start_dma(mmc, false, false, start, dma_addr,
+				       blkcnt, timeout);
+		timed_out = !!octeontx_mmc_wait_dma(mmc, false, timeout,
+						    verbose);
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
+			if (!verbose)
+				return 0;
+
+			pr_err("%s(%s): Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
+			       __func__, mmc->dev->name, rsp_sts.u,
+			       read_csr(mmc, MIO_EMM_INT()),
+			       read_csr(mmc, MIO_EMM_DMA_INT()),
+			       read_csr(mmc, MIO_EMM_RSP_LO()));
+			pr_err("%s: block count: %lu, start: 0x%lx\n",
+			       __func__, blkcnt, start);
+			octeontx_mmc_print_registers(mmc);
+			return 0;
+		}
+	} else {
+		count = blkcnt;
+		timeout = 1000;
+		do {
+			octeontx_mmc_start_dma(mmc, false, false, start,
+					       dma_addr, 1, timeout);
+			dma_addr += mmc->read_bl_len;
+			start++;
+
+			timed_out = !!octeontx_mmc_wait_dma(mmc, false,
+							    timeout, verbose);
+			rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+			if (timed_out || rsp_sts.s.dma_val ||
+			    rsp_sts.s.dma_pend) {
+				if (verbose) {
+					pr_err("%s: Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
+					       __func__, rsp_sts.u,
+					       read_csr(mmc, MIO_EMM_INT()),
+					       read_csr(mmc, MIO_EMM_DMA_INT()),
+					       read_csr(mmc, MIO_EMM_RSP_LO()));
+					pr_err("%s: block count: 1, start: 0x%lx\n",
+					       __func__, start);
+					octeontx_mmc_print_registers(mmc);
+				}
+				return blkcnt - count;
+			}
+			WATCHDOG_RESET();
+		} while (--count);
+	}
+#ifdef DEBUG
+	debug("%s(%s): Read %lu (0x%lx) blocks starting at block %u (0x%x) to address %p (dma address 0x%llx)\n",
+	      __func__, mmc->dev->name, blkcnt, blkcnt,
+	      cmd->cmdarg, cmd->cmdarg, data->dest,
+	      dm_pci_virt_to_mem(host->dev, data->dest));
+	print_buffer(0, data->dest, 1, 0x200, 0);
+#endif
+	return blkcnt;
+}
+
+static int octeontx_mmc_poll_ready(struct mmc *mmc, ulong timeout)
+{
+	ulong start;
+	struct mmc_cmd cmd;
+	int err;
+	bool not_ready = false;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.resp_type = MMC_RSP_R1;
+	start = get_timer(0);
+	do {
+		err = octeontx_mmc_send_cmd(mmc, &cmd, NULL);
+		if (err) {
+			pr_err("%s(%s): MMC command error: %d; Retry...\n",
+			       __func__, mmc->dev->name, err);
+			not_ready = true;
+		} else if (cmd.response[0] & R1_READY_FOR_DATA) {
+			return 0;
+		}
+		WATCHDOG_RESET();
+	} while (get_timer(start) < timeout);
+
+	if (not_ready)
+		pr_err("%s(%s): MMC command error; Retry timeout\n",
+		       __func__, mmc->dev->name);
+	return -ETIMEDOUT;
+}
+
+static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
+				       struct mmc_data *data)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	ulong start = cmd->cmdarg;
+	ulong blkcnt = data->blocks;
+	dma_addr_t dma_addr;
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_sts_mask emm_sts_mask;
+	ulong timeout;
+	int count;
+	bool timed_out = false;
+	bool multi_xfer = (blkcnt > 1) &&
+			((IS_SD(mmc) && mmc->scr[0] & 2) || !IS_SD(mmc));
+
+	octeontx_mmc_switch_to(mmc);
+	emm_sts_mask.u = 0;
+	emm_sts_mask.s.sts_msk = R1_BLOCK_WRITE_MASK;
+	write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
+
+	if (octeontx_mmc_poll_ready(mmc, 10000)) {
+		pr_err("%s(%s): Ready timed out\n", __func__, mmc->dev->name);
+		return 0;
+	}
+	flush_dcache_range((u64)data->src,
+			   (u64)data->src + blkcnt * mmc->write_bl_len);
+	dma_addr = (u64)dm_pci_virt_to_mem(host->dev, (void *)data->src);
+	if (multi_xfer) {
+		timeout = 5000 + 100 * blkcnt;
+		octeontx_mmc_start_dma(mmc, true, false, start, dma_addr,
+				       blkcnt, timeout);
+		timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout, true);
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
+			pr_err("%s(%s): Error: multi-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+			       __func__, mmc->dev->name, timeout,
+			       rsp_sts.u,
+			       read_csr(mmc, MIO_EMM_INT()),
+			       read_csr(mmc, MIO_EMM_DMA_INT()),
+			       read_csr(mmc, MIO_EMM_RSP_LO()),
+			       read_csr(mmc, MIO_EMM_DMA()));
+			return 0;
+		}
+	} else {
+		timeout = 5000;
+		count = blkcnt;
+		do {
+			octeontx_mmc_start_dma(mmc, true, false, start,
+					       dma_addr, 1, timeout);
+			dma_addr += mmc->read_bl_len;
+			start++;
+
+			timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout,
+							    true);
+			rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+			if (timed_out || rsp_sts.s.dma_val ||
+			    rsp_sts.s.dma_pend) {
+				pr_err("%s(%s): Error: single-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+				       __func__, mmc->dev->name, timeout,
+				       rsp_sts.u,
+				       read_csr(mmc, MIO_EMM_RSP_STS()),
+				       read_csr(mmc, MIO_EMM_DMA_INT()),
+				       read_csr(mmc, MIO_EMM_RSP_LO()),
+				       read_csr(mmc, MIO_EMM_DMA()));
+				return blkcnt - count;
+			}
+			WATCHDOG_RESET();
+		} while (--count);
+	}
+
+	return blkcnt;
+}
+
+/**
+ * Send a command to the eMMC/SD device
+ *
+ * @param mmc	mmc device
+ * @param cmd	cmd to send and response
+ * @param data	additional data
+ * @param flags
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+				 struct mmc_data *data)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	const char *name = slot->dev->name;
+	struct octeontx_mmc_cr_mods mods = {0, 0};
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_cmd emm_cmd;
+	union mio_emm_rsp_lo rsp_lo;
+	union mio_emm_buf_idx emm_buf_idx;
+	union mio_emm_buf_dat emm_buf_dat;
+	ulong start;
+	int i;
+	ulong blkcnt;
+
+	/**
+	 * This constant has a 1 bit for each command which should have a short
+	 * timeout and a 0 for each bit with a long timeout.  Currently the
+	 * following commands have a long timeout:
+	 *   CMD6, CMD17, CMD18, CMD24, CMD25, CMD32, CMD33, CMD35, CMD36 and
+	 *   CMD38.
+	 */
+	static const u64 timeout_short = 0xFFFFFFA4FCF9FFDFull;
+	uint timeout;
+
+	if (cmd->cmdidx == MMC_CMD_SEND_EXT_CSD) {
+		union mio_emm_rca emm_rca;
+
+		emm_rca.u = 0;
+		emm_rca.s.card_rca = mmc->rca;
+		write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
+	}
+
+	if (timeout_short & (1ull << cmd->cmdidx))
+		timeout = MMC_TIMEOUT_SHORT;
+	else if (cmd->cmdidx == MMC_CMD_SWITCH && IS_SD(mmc))
+		timeout = 2560;
+	else if (cmd->cmdidx == MMC_CMD_ERASE)
+		timeout = MMC_TIMEOUT_ERASE;
+	else
+		timeout = MMC_TIMEOUT_LONG;
+
+	debug("%s(%s): cmd idx: %u, arg: 0x%x, resp type: 0x%x, timeout: %u\n",
+	      __func__, name, cmd->cmdidx, cmd->cmdarg, cmd->resp_type,
+	      timeout);
+	if (data)
+		debug("  data: addr: %p, flags: 0x%x, blocks: %u, blocksize: %u\n",
+		      data->dest, data->flags, data->blocks, data->blocksize);
+
+	octeontx_mmc_switch_to(mmc);
+
+	/* Clear any interrupts */
+	write_csr(mmc, MIO_EMM_INT(), read_csr(mmc, MIO_EMM_INT()));
+
+	/*
+	 * We need to override the default command types and response types
+	 * when dealing with SD cards.
+	 */
+	mods = octeontx_mmc_get_cr_mods(mmc, cmd, data);
+
+	/* Handle block read/write/stop operations */
+	switch (cmd->cmdidx) {
+	case MMC_CMD_GO_IDLE_STATE:
+		slot->tuned = false;
+		slot->hs200_tuned = false;
+		slot->hs400_tuned = false;
+		break;
+	case MMC_CMD_STOP_TRANSMISSION:
+		return 0;
+	case MMC_CMD_READ_MULTIPLE_BLOCK:
+	case MMC_CMD_READ_SINGLE_BLOCK:
+		pr_debug("%s(%s): Reading blocks\n", __func__, name);
+		blkcnt = octeontx_mmc_read_blocks(mmc, cmd, data, true);
+		return (blkcnt > 0) ? 0 : -1;
+	case MMC_CMD_WRITE_MULTIPLE_BLOCK:
+	case MMC_CMD_WRITE_SINGLE_BLOCK:
+		blkcnt = octeontx_mmc_write_blocks(mmc, cmd, data);
+		return (blkcnt > 0) ? 0 : -1;
+	case MMC_CMD_SELECT_CARD:
+		/* Set the RCA register (is it set automatically?) */
+		if (IS_SD(mmc)) {
+			union mio_emm_rca emm_rca;
+
+			emm_rca.u = 0;
+			emm_rca.s.card_rca = (cmd->cmdarg >> 16);
+			write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
+			debug("%s: Set SD relative address (RCA) to 0x%x\n",
+			      __func__, emm_rca.s.card_rca);
+		}
+		break;
+
+	case MMC_CMD_SWITCH:
+		if (!data && !slot->is_acmd)
+			octeontx_mmc_track_switch(mmc, cmd->cmdarg);
+		break;
+	}
+
+	emm_cmd.u = 0;
+	emm_cmd.s.cmd_val = 1;
+	emm_cmd.s.bus_id = slot->bus_id;
+	emm_cmd.s.cmd_idx = cmd->cmdidx;
+	emm_cmd.s.arg = cmd->cmdarg;
+	emm_cmd.s.ctype_xor = mods.ctype_xor;
+	emm_cmd.s.rtype_xor = mods.rtype_xor;
+	if (data && data->blocks == 1 && data->blocksize != 512) {
+		emm_cmd.s.offset =
+			64 - ((data->blocks * data->blocksize) / 8);
+		debug("%s: offset set to %u\n", __func__, emm_cmd.s.offset);
+	}
+
+	if (data && data->flags & MMC_DATA_WRITE) {
+		u8 *src = (u8 *)data->src;
+
+		if (!src) {
+			pr_err("%s(%s): Error: data source for cmd 0x%x is NULL!\n",
+			       __func__, name, cmd->cmdidx);
+			return -1;
+		}
+		if (data->blocksize > 512) {
+			pr_err("%s(%s): Error: data for cmd 0x%x exceeds 512 bytes\n",
+			       __func__, name, cmd->cmdidx);
+			return -1;
+		}
+#ifdef DEBUG
+		debug("%s: Sending %d bytes data\n", __func__, data->blocksize);
+		print_buffer(0, src, 1, data->blocksize, 0);
+#endif
+		emm_buf_idx.u = 0;
+		emm_buf_idx.s.inc = 1;
+		write_csr(mmc, MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
+			memcpy(&emm_buf_dat.u, src, sizeof(emm_buf_dat.u));
+			write_csr(mmc, MIO_EMM_BUF_DAT(),
+				  cpu_to_be64(emm_buf_dat.u));
+			src += sizeof(emm_buf_dat.u);
+		}
+		write_csr(mmc, MIO_EMM_BUF_IDX(), 0);
+	}
+	debug("%s(%s): Sending command %u (emm_cmd: 0x%llx)\n", __func__,
+	      name, cmd->cmdidx, emm_cmd.u);
+	set_wdog(mmc, timeout * 1000);
+	write_csr(mmc, MIO_EMM_CMD(), emm_cmd.u);
+
+	/* Wait for command to finish or time out */
+	start = get_timer(0);
+	do {
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+		WATCHDOG_RESET();
+	} while (!rsp_sts.s.cmd_done && !rsp_sts.s.rsp_timeout &&
+		 (get_timer(start) < timeout + 10));
+	octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+	if (rsp_sts.s.rsp_timeout || !rsp_sts.s.cmd_done) {
+		debug("%s(%s): Error: command %u(0x%x) timed out.  rsp_sts: 0x%llx\n",
+		      __func__, name, cmd->cmdidx, cmd->cmdarg, rsp_sts.u);
+		octeontx_mmc_print_registers(mmc);
+		return -ETIMEDOUT;
+	}
+	if (rsp_sts.s.rsp_crc_err) {
+		debug("%s(%s): RSP CRC error, rsp_sts: 0x%llx, cmdidx: %u, arg: 0x%08x\n",
+		      __func__, name, rsp_sts.u, cmd->cmdidx, cmd->cmdarg);
+		octeontx_mmc_print_registers(mmc);
+		return -1;
+	}
+	if (slot->bus_id != rsp_sts.s.bus_id) {
+		pr_warn("%s(%s): bus id mismatch, got %d, expected %d for command 0x%x(0x%x)\n",
+			__func__, name,
+			rsp_sts.s.bus_id, slot->bus_id,
+			cmd->cmdidx, cmd->cmdarg);
+		goto error;
+	}
+	if (rsp_sts.s.rsp_bad_sts) {
+		rsp_lo.u = read_csr(mmc, MIO_EMM_RSP_LO());
+		debug("%s: Bad response for bus id %d, cmd id %d:\n"
+		      "    rsp_timeout: %d\n"
+		      "    rsp_bad_sts: %d\n"
+		      "    rsp_crc_err: %d\n",
+		      __func__, slot->bus_id, cmd->cmdidx,
+		      rsp_sts.s.rsp_timeout,
+		      rsp_sts.s.rsp_bad_sts,
+		      rsp_sts.s.rsp_crc_err);
+		if (rsp_sts.s.rsp_type == 1 && rsp_sts.s.rsp_bad_sts) {
+			debug("    Response status: 0x%llx\n",
+			      (rsp_lo.u >> 8) & 0xffffffff);
+#ifdef DEBUG
+			mmc_print_status((rsp_lo.u >> 8) & 0xffffffff);
+#endif
+		}
+		goto error;
+	}
+	if (rsp_sts.s.cmd_idx != cmd->cmdidx) {
+		debug("%s(%s): Command response index %d does not match command index %d\n",
+		      __func__, name, rsp_sts.s.cmd_idx, cmd->cmdidx);
+		octeontx_print_rsp_sts(mmc);
+		debug("%s: rsp_lo: 0x%llx\n", __func__,
+		      read_csr(mmc, MIO_EMM_RSP_LO()));
+
+		goto error;
+	}
+
+	slot->is_acmd = (cmd->cmdidx == MMC_CMD_APP_CMD);
+
+	if (!cmd->resp_type & MMC_RSP_PRESENT)
+		debug("  Response type: 0x%x, no response expected\n",
+		      cmd->resp_type);
+	/* Get the response if present */
+	if (rsp_sts.s.rsp_val && (cmd->resp_type & MMC_RSP_PRESENT)) {
+		union mio_emm_rsp_hi rsp_hi;
+
+		rsp_lo.u = read_csr(mmc, MIO_EMM_RSP_LO());
+
+		switch (rsp_sts.s.rsp_type) {
+		case 1:
+		case 3:
+		case 4:
+		case 5:
+			cmd->response[0] = (rsp_lo.u >> 8) & 0xffffffffull;
+			debug("  response: 0x%08x\n",
+			      cmd->response[0]);
+			cmd->response[1] = 0;
+			cmd->response[2] = 0;
+			cmd->response[3] = 0;
+			break;
+		case 2:
+			cmd->response[3] = rsp_lo.u & 0xffffffff;
+			cmd->response[2] = (rsp_lo.u >> 32) & 0xffffffff;
+			rsp_hi.u = read_csr(mmc, MIO_EMM_RSP_HI());
+			cmd->response[1] = rsp_hi.u & 0xffffffff;
+			cmd->response[0] = (rsp_hi.u >> 32) & 0xffffffff;
+			debug("  response: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			      cmd->response[0], cmd->response[1],
+			      cmd->response[2], cmd->response[3]);
+			break;
+		default:
+			pr_err("%s(%s): Unknown response type 0x%x for command %d, arg: 0x%x, rsp_sts: 0x%llx\n",
+			       __func__, name, rsp_sts.s.rsp_type, cmd->cmdidx,
+			       cmd->cmdarg, rsp_sts.u);
+			return -1;
+		}
+	} else {
+		debug("  Response not expected\n");
+	}
+
+	if (data && data->flags & MMC_DATA_READ) {
+		u8 *dest = (u8 *)data->dest;
+
+		if (!dest) {
+			pr_err("%s(%s): Error, destination buffer NULL!\n",
+			       __func__, mmc->dev->name);
+			goto error;
+		}
+		if (data->blocksize > 512) {
+			printf("%s(%s): Error: data size %u exceeds 512\n",
+			       __func__, mmc->dev->name,
+			       data->blocksize);
+			goto error;
+		}
+		emm_buf_idx.u = 0;
+		emm_buf_idx.s.inc = 1;
+		write_csr(mmc, MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
+			emm_buf_dat.u = read_csr(mmc, MIO_EMM_BUF_DAT());
+			emm_buf_dat.u = be64_to_cpu(emm_buf_dat.u);
+			memcpy(dest, &emm_buf_dat.u, sizeof(emm_buf_dat.u));
+			dest += sizeof(emm_buf_dat.u);
+		}
+		write_csr(mmc, MIO_EMM_BUF_IDX(), 0);
+#ifdef DEBUG
+		debug("%s: Received %d bytes data\n", __func__,
+		      data->blocksize);
+		print_buffer(0, data->dest, 1, data->blocksize, 0);
+#endif
+	}
+
+	return 0;
+error:
+#ifdef DEBUG
+	octeontx_mmc_print_registers(mmc);
+#endif
+	return -1;
+}
+
+static int octeontx_mmc_dev_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
+				     struct mmc_data *data)
+{
+	return octeontx_mmc_send_cmd(dev_to_mmc(dev), cmd, data);
+}
+
+#ifdef MMC_SUPPORTS_TUNING
+static int octeontx_mmc_test_cmd(struct mmc *mmc, u32 opcode, int *statp)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	debug("%s(%s, %u, %p)\n", __func__, mmc->dev->name, opcode, statp);
+	cmd.cmdidx = opcode;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = octeontx_mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		debug("%s(%s, %u) returned %d\n", __func__,
+		      mmc->dev->name, opcode, err);
+	if (statp)
+		*statp = cmd.response[0];
+	return err;
+}
+
+static int octeontx_mmc_test_get_ext_csd(struct mmc *mmc, u32 opcode,
+					 int *statp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+	u8 ext_csd[MMC_MAX_BLOCK_LEN];
+
+	debug("%s(%s, %u, %p)\n",  __func__, mmc->dev->name, opcode, statp);
+	memset(&cmd, 0, sizeof(cmd));
+
+	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)ext_csd;
+	data.blocks = 1;
+	data.blocksize = MMC_MAX_BLOCK_LEN;
+	data.flags = MMC_DATA_READ;
+
+	err = octeontx_mmc_send_cmd(mmc, &cmd, &data);
+	if (statp)
+		*statp = cmd.response[0];
+
+	return err;
+}
+
+/**
+ * Wrapper to set the MIO_EMM_TIMING register
+ *
+ * @param	mmc		pointer to mmc data structure
+ * @param	emm_timing	New emm_timing register value
+ *
+ * On some devices it is possible that changing the data out value can
+ * cause a glitch on an internal fifo.  This works around this problem
+ * by performing a soft-reset immediately before setting the timing register.
+ *
+ * Note: this function should not be called from any function that
+ * performs DMA or block operations since not all registers are
+ * preserved.
+ */
+static void octeontx_mmc_set_emm_timing(struct mmc *mmc,
+					union mio_emm_timing emm_timing)
+{
+	union mio_emm_cfg emm_cfg;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	union mio_emm_debug emm_debug;
+
+	debug("%s(%s, 0x%llx) din: %u\n", __func__, mmc->dev->name,
+	      emm_timing.u, emm_timing.s.data_in_tap);
+
+	udelay(1);
+	if (slot->host->tap_requires_noclk) {
+		/* Turn off the clock */
+		emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+		emm_debug.s.emmc_clk_disable = 1;
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+		udelay(1);
+		emm_debug.s.rdsync_rst = 1;
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+	}
+	emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
+	emm_cfg.s.bus_ena = 1 << 3;
+	write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+
+	udelay(1);
+	write_csr(mmc, MIO_EMM_TIMING(), emm_timing.u);
+	udelay(1);
+
+	if (slot->host->tap_requires_noclk) {
+		/* Turn on the clock */
+		emm_debug.s.rdsync_rst = 0;
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+		udelay(1);
+		emm_debug.s.emmc_clk_disable = 0;
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+		udelay(1);
+	}
+	emm_cfg.s.bus_ena = 1 << mmc_to_slot(mmc)->bus_id;
+	write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+}
+
+static const u8 octeontx_hs400_tuning_block[512] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+	0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00,
+	0x00, 0xff, 0x00, 0xff, 0x55, 0xaa, 0x55, 0xaa,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
+	0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
+	0x01, 0xfe, 0x01, 0xfe, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+
+};
+
+/**
+ * Perform tuning in HS400 mode
+ *
+ * @param[in]	mmc	mmc data structure
+ *
+ * @ret		0 for success, otherwise error
+ */
+static int octeontx_tune_hs400(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	union mio_emm_timing emm_timing;
+	u8 buffer[mmc->read_bl_len];
+	int tap_adj;
+	int err = -1;
+	int tap;
+	int run = 0;
+	int start_run = -1;
+	int best_run = 0;
+	int best_start = -1;
+	bool prev_ok = false;
+	char env_name[64];
+	char how[MAX_NO_OF_TAPS + 1] = "";
+
+	if (slot->hs400_tuning_block == -1)
+		return 0;
+
+	/* The eMMC standard disables all tuning support when operating in
+	 * DDR modes like HS400.  The problem with this is that there are
+	 * many cases where the HS200 tuning does not work for HS400 mode.
+	 * In order to perform this tuning, while in HS200 a block is written
+	 * to a block specified in the device tree (marvell,hs400-tuning-block)
+	 * which is used for tuning in this function by repeatedly reading
+	 * this block and comparing the data and return code.  This function
+	 * chooses the data input tap in the middle of the longest run of
+	 * successful read operations.
+	 */
+
+	emm_timing = slot->hs200_taps;
+	debug("%s(%s): Start ci: %d, co: %d, di: %d, do: %d\n",
+	      __func__, mmc->dev->name, emm_timing.s.cmd_in_tap,
+	      emm_timing.s.cmd_out_tap, emm_timing.s.data_in_tap,
+	      emm_timing.s.data_out_tap);
+	memset(buffer, 0xdb, sizeof(buffer));
+
+	snprintf(env_name, sizeof(env_name), "emmc%d_data_in_tap_hs400",
+		 slot->bus_id);
+	tap = env_get_ulong(env_name, 10, -1L);
+	if (tap >= 0 && tap < MAX_NO_OF_TAPS) {
+		printf("Overriding data input tap for HS400 mode to %d\n", tap);
+		emm_timing.s.data_in_tap = tap;
+		octeontx_mmc_set_emm_timing(mmc, emm_timing);
+		return 0;
+	}
+
+	for (tap = 0; tap <= MAX_NO_OF_TAPS; tap++, prev_ok = !err) {
+		if (tap < MAX_NO_OF_TAPS) {
+			debug("%s: Testing data in tap %d\n", __func__, tap);
+			emm_timing.s.data_in_tap = tap;
+			octeontx_mmc_set_emm_timing(mmc, emm_timing);
+
+			cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+			cmd.cmdarg = slot->hs400_tuning_block;
+			cmd.resp_type = MMC_RSP_R1;
+			data.dest = (void *)buffer;
+			data.blocks = 1;
+			data.blocksize = mmc->read_bl_len;
+			data.flags = MMC_DATA_READ;
+			err = !octeontx_mmc_read_blocks(mmc, &cmd, &data,
+							false);
+			if (err || memcmp(buffer, octeontx_hs400_tuning_block,
+					  sizeof(buffer))) {
+#ifdef DEBUG
+				if (!err) {
+					debug("%s: data mismatch.  Read:\n",
+					      __func__);
+					print_buffer(0, buffer, 1,
+						     sizeof(buffer), 0);
+					debug("\nExpected:\n");
+					print_buffer(0,
+					    octeontx_hs400_tuning_block, 1,
+					    sizeof(octeontx_hs400_tuning_block),
+					    0);
+				} else {
+					debug("%s: Error %d reading block\n",
+					      __func__, err);
+				}
+#endif
+				err = -EINVAL;
+			} else {
+				debug("%s: tap %d good\n", __func__, tap);
+			}
+			how[tap] = "-+"[!err];
+		} else {
+			err = -EINVAL;
+		}
+
+		if (!err) {
+			if (!prev_ok)
+				start_run = tap;
+		} else if (prev_ok) {
+			run = tap - 1 - start_run;
+			if (start_run >= 0 && run > best_run) {
+				best_start = start_run;
+				best_run = run;
+			}
+		}
+	}
+	how[tap - 1] = '\0';
+	if (best_start < 0) {
+		printf("%s(%s): %lldMHz tuning failed for HS400\n",
+		       __func__, mmc->dev->name, slot->clock / 1000000);
+		return -EINVAL;
+	}
+	tap = best_start + best_run / 2;
+
+	snprintf(env_name, sizeof(env_name), "emmc%d_data_in_tap_adj_hs400",
+		 slot->bus_id);
+	tap_adj = env_get_ulong(env_name, 10, slot->hs400_tap_adj);
+	/*
+	 * Keep it in range and if out of range force it back in with a small
+	 * buffer.
+	 */
+	if (best_run > 3) {
+		tap = tap + tap_adj;
+		if (tap >= best_start + best_run)
+			tap = best_start + best_run - 2;
+		if (tap <= best_start)
+			tap = best_start + 2;
+	}
+	how[tap] = '@';
+	debug("Tuning: %s\n", how);
+	debug("%s(%s): HS400 tap: best run start: %d, length: %d, tap: %d\n",
+	      __func__, mmc->dev->name, best_start, best_run, tap);
+	slot->hs400_taps = slot->hs200_taps;
+	slot->hs400_taps.s.data_in_tap = tap;
+	slot->hs400_tuned = true;
+	if (env_get_yesno("emmc_export_hs400_taps") > 0) {
+		debug("%s(%s): Exporting HS400 taps\n",
+		      __func__, mmc->dev->name);
+		env_set_ulong("emmc_timing_tap", slot->host->timing_taps);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_in_tap_debug",
+			 slot->bus_id);
+		env_set(env_name, how);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_in_tap_val",
+			 slot->bus_id);
+		env_set_ulong(env_name, tap);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_in_tap_start",
+			 slot->bus_id);
+		env_set_ulong(env_name, best_start);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_in_tap_end",
+			 slot->bus_id);
+		env_set_ulong(env_name, best_start + best_run);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_cmd_in_tap",
+			 slot->bus_id);
+		env_set_ulong(env_name, slot->hs400_taps.s.cmd_in_tap);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_cmd_out_tap",
+			 slot->bus_id);
+		env_set_ulong(env_name, slot->hs400_taps.s.cmd_out_tap);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_cmd_out_delay",
+			 slot->bus_id);
+		env_set_ulong(env_name, slot->cmd_out_hs400_delay);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_out_tap",
+			 slot->bus_id);
+		env_set_ulong(env_name, slot->hs400_taps.s.data_out_tap);
+		snprintf(env_name, sizeof(env_name),
+			 "emmc%d_hs400_data_out_delay",
+			 slot->bus_id);
+		env_set_ulong(env_name, slot->data_out_hs400_delay);
+	} else {
+		debug("%s(%s): HS400 environment export disabled\n",
+		      __func__, mmc->dev->name);
+	}
+	octeontx_mmc_set_timing(mmc);
+
+	return 0;
+}
+
+struct adj {
+	const char *name;
+	u8 mask_shift;
+	int (*test)(struct mmc *mmc, u32 opcode, int *error);
+	u32 opcode;
+	bool ddr_only;
+	bool hs200_only;
+	bool not_hs200_only;
+	u8 num_runs;
+};
+
+struct adj adj[] = {
+	{ "CMD_IN", 48, octeontx_mmc_test_cmd, MMC_CMD_SEND_STATUS,
+	  false, false, false, 2, },
+/*	{ "CMD_OUT", 32, octeontx_mmc_test_cmd, MMC_CMD_SEND_STATUS, },*/
+	{ "DATA_IN(HS200)", 16, mmc_send_tuning,
+		MMC_CMD_SEND_TUNING_BLOCK_HS200, false, true, false, 2, },
+	{ "DATA_IN", 16, octeontx_mmc_test_get_ext_csd, 0, false, false,
+	  true, 2, },
+/*	{ "DATA_OUT", 0, octeontx_mmc_test_cmd, 0, true, false},*/
+	{ NULL, },
+};
+
+/**
+ * Perform tuning tests to find optimal timing
+ *
+ * @param	mmc	mmc device
+ * @param	adj	parameter to tune
+ * @param	opcode	command opcode to use
+ *
+ * @return	0 for success, -1 if tuning failed
+ */
+static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
+				      u32 opcode)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_timing timing;
+	union mio_emm_debug emm_debug;
+	int tap;
+	int err = -1;
+	int run = 0;
+	int count;
+	int start_run = -1;
+	int best_run = 0;
+	int best_start = -1;
+	bool prev_ok = false;
+	u64 tap_status = 0;
+	const int tap_adj = slot->hs200_tap_adj;
+	char how[MAX_NO_OF_TAPS + 1] = "";
+	bool is_hs200 = mmc->selected_mode == MMC_HS_200;
+
+	debug("%s(%s, %s, %d), hs200: %d\n", __func__, mmc->dev->name,
+	      adj->name, opcode, is_hs200);
+	octeontx_mmc_set_emm_timing(mmc,
+				    is_hs200 ? slot->hs200_taps : slot->taps);
+
+#ifdef DEBUG
+	if (opcode == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+		printf("%s(%s): Before tuning %s, opcode: %d\n",
+		       __func__, mmc->dev->name, adj->name, opcode);
+		octeontx_mmc_print_registers2(mmc, NULL);
+	}
+#endif
+
+	/*
+	 * The algorithm to find the optimal timing is to start
+	 * at the end and work backwards and select the second
+	 * value that passes.  Each test is repeated twice.
+	 */
+	for (tap = 0; tap <= MAX_NO_OF_TAPS; tap++, prev_ok = !err) {
+		if (tap < MAX_NO_OF_TAPS) {
+			if (slot->host->tap_requires_noclk) {
+				/* Turn off the clock */
+				emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+				emm_debug.s.emmc_clk_disable = 1;
+				write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+				udelay(1);
+				emm_debug.s.rdsync_rst = 1;
+				write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+				udelay(1);
+			}
+
+			timing.u = read_csr(mmc, MIO_EMM_TIMING());
+			timing.u &= ~(0x3full << adj->mask_shift);
+			timing.u |= (u64)tap << adj->mask_shift;
+			write_csr(mmc, MIO_EMM_TIMING(), timing.u);
+			debug("%s(%s): Testing ci: %d, co: %d, di: %d, do: %d\n",
+			      __func__, mmc->dev->name, timing.s.cmd_in_tap,
+			      timing.s.cmd_out_tap, timing.s.data_in_tap,
+			      timing.s.data_out_tap);
+
+			if (slot->host->tap_requires_noclk) {
+				/* Turn off the clock */
+				emm_debug.s.rdsync_rst = 0;
+				write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+				udelay(1);
+				emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+				emm_debug.s.emmc_clk_disable = 0;
+				write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+				udelay(1);
+			}
+			for (count = 0; count < 2; count++) {
+				err = adj->test(mmc, opcode, NULL);
+				if (err) {
+					debug("%s(%s, %s): tap %d failed, count: %d, rsp_sts: 0x%llx, rsp_lo: 0x%llx\n",
+					      __func__, mmc->dev->name,
+					      adj->name, tap, count,
+					      read_csr(mmc,
+						       MIO_EMM_RSP_STS()),
+					      read_csr(mmc,
+						       MIO_EMM_RSP_LO()));
+					debug("%s(%s, %s): tap: %d, do: %d, di: %d, co: %d, ci: %d\n",
+					      __func__, mmc->dev->name,
+					      adj->name, tap,
+					      timing.s.data_out_tap,
+					      timing.s.data_in_tap,
+					      timing.s.cmd_out_tap,
+					      timing.s.cmd_in_tap);
+					break;
+				}
+				debug("%s(%s, %s): tap %d passed, count: %d, rsp_sts: 0x%llx, rsp_lo: 0x%llx\n",
+				      __func__, mmc->dev->name, adj->name, tap,
+				      count,
+				      read_csr(mmc, MIO_EMM_RSP_STS()),
+				      read_csr(mmc, MIO_EMM_RSP_LO()));
+			}
+			tap_status |= (u64)(!err) << tap;
+			how[tap] = "-+"[!err];
+		} else {
+			/*
+			 * Putting the end+1 case in the loop simplifies
+			 * logic, allowing 'prev_ok' to process a sweet
+			 * spot in tuning which extends to the wall.
+			 */
+			err = -EINVAL;
+		}
+		if (!err) {
+			/*
+			 * If no CRC/etc errors in the response, but previous
+			 * failed, note the start of a new run.
+			 */
+			debug("  prev_ok: %d\n", prev_ok);
+			if (!prev_ok)
+				start_run = tap;
+		} else if (prev_ok) {
+			run = tap - 1 - start_run;
+			/* did we just exit a wider sweet spot? */
+			if (start_run >= 0 && run > best_run) {
+				best_start = start_run;
+				best_run = run;
+			}
+		}
+	}
+	how[tap - 1] = '\0';
+	if (best_start < 0) {
+		printf("%s(%s, %s): %lldMHz tuning %s failed\n", __func__,
+		       mmc->dev->name, adj->name, slot->clock / 1000000,
+		       adj->name);
+		return -EINVAL;
+	}
+
+	tap = best_start + best_run / 2;
+	debug("  tap %d is center, start: %d, run: %d\n", tap,
+	      best_start, best_run);
+	if (is_hs200) {
+		slot->hs200_taps.u &= ~(0x3full << adj->mask_shift);
+		slot->hs200_taps.u |= (u64)tap << adj->mask_shift;
+	} else {
+		slot->taps.u &= ~(0x3full << adj->mask_shift);
+		slot->taps.u |= (u64)tap << adj->mask_shift;
+	}
+	if (best_start < 0) {
+		printf("%s(%s, %s): %lldMHz tuning %s failed\n", __func__,
+		       mmc->dev->name, adj->name, slot->clock / 1000000,
+		       adj->name);
+		return -EINVAL;
+	}
+
+	tap = best_start + best_run / 2;
+	if (is_hs200 && (tap + tap_adj >= 0) && (tap + tap_adj < 64) &&
+	    tap_status & (1ULL << (tap + tap_adj))) {
+		debug("Adjusting tap from %d by %d to %d\n",
+		      tap, tap_adj, tap + tap_adj);
+		tap += tap_adj;
+	}
+	how[tap] = '@';
+	debug("%s/%s %d/%d/%d %s\n", mmc->dev->name,
+	      adj->name, best_start, tap, best_start + best_run, how);
+
+	if (is_hs200) {
+		slot->hs200_taps.u &= ~(0x3full << adj->mask_shift);
+		slot->hs200_taps.u |= (u64)tap << adj->mask_shift;
+	} else {
+		slot->taps.u &= ~(0x3full << adj->mask_shift);
+		slot->taps.u |= (u64)tap << adj->mask_shift;
+	}
+
+#ifdef DEBUG
+	if (opcode == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+		debug("%s(%s, %s): After successful tuning\n",
+		      __func__, mmc->dev->name, adj->name);
+		debug("%s(%s, %s): tap: %d, new do: %d, di: %d, co: %d, ci: %d\n",
+		      __func__, mmc->dev->name, adj->name, tap,
+		      slot->taps.s.data_out_tap,
+		      slot->taps.s.data_in_tap,
+		      slot->taps.s.cmd_out_tap,
+		      slot->taps.s.cmd_in_tap);
+		debug("%s(%s, %s): tap: %d, new do HS200: %d, di: %d, co: %d, ci: %d\n",
+		      __func__, mmc->dev->name, adj->name, tap,
+		      slot->hs200_taps.s.data_out_tap,
+		      slot->hs200_taps.s.data_in_tap,
+		      slot->hs200_taps.s.cmd_out_tap,
+		      slot->hs200_taps.s.cmd_in_tap);
+	}
+#endif
+	octeontx_mmc_set_timing(mmc);
+
+	if (is_hs200 && env_get_yesno("emmc_export_hs200_taps")) {
+		char env_name[64];
+
+		env_set_ulong("emmc_timing_tap", slot->host->timing_taps);
+		switch (opcode) {
+		case MMC_CMD_SEND_TUNING_BLOCK:
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_data_in_tap_debug",
+				 slot->bus_id);
+			env_set(env_name, how);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_data_in_tap_val", slot->bus_id);
+			env_set_ulong(env_name, tap);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_data_in_tap_start",
+				 slot->bus_id);
+			env_set_ulong(env_name, best_start);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_data_in_tap_end",
+				 slot->bus_id);
+			env_set_ulong(env_name, best_start + best_run);
+			break;
+		case MMC_CMD_SEND_STATUS:
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_cmd_in_tap_debug",
+				 slot->bus_id);
+			env_set(env_name, how);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_cmd_in_tap_val", slot->bus_id);
+			env_set_ulong(env_name, tap);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_cmd_in_tap_start",
+				 slot->bus_id);
+			env_set_ulong(env_name, best_start);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_cmd_in_tap_end",
+				 slot->bus_id);
+			env_set_ulong(env_name, best_start + best_run);
+			break;
+		default:
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_data_out_tap", slot->bus_id);
+			env_set_ulong(env_name, slot->data_out_hs200_delay);
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_hs200_cmd_out_tap", slot->bus_id);
+			env_set_ulong(env_name, slot->cmd_out_hs200_delay);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int octeontx_mmc_execute_tuning(struct udevice *dev, u32 opcode)
+{
+	struct mmc *mmc = dev_to_mmc(dev);
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_timing emm_timing;
+	int err;
+	struct adj *a;
+	bool is_hs200;
+	char env_name[64];
+
+	pr_info("%s re-tuning, opcode 0x%x\n", dev->name, opcode);
+
+	if (slot->is_asim || slot->is_emul)
+		return 0;
+
+	is_hs200 = (mmc->selected_mode == MMC_HS_200);
+	if (is_hs200) {
+		slot->hs200_tuned = false;
+		slot->hs400_tuned = false;
+	} else {
+		slot->tuned = false;
+	}
+	octeontx_mmc_set_output_bus_timing(mmc);
+	octeontx_mmc_set_input_bus_timing(mmc);
+	emm_timing.u = read_csr(mmc, MIO_EMM_TIMING());
+	if (mmc->selected_mode == MMC_HS_200) {
+		slot->hs200_taps.s.cmd_out_tap = emm_timing.s.cmd_out_tap;
+		slot->hs200_taps.s.data_out_tap = emm_timing.s.data_out_tap;
+	} else {
+		slot->taps.s.cmd_out_tap = emm_timing.s.cmd_out_tap;
+		slot->taps.s.data_out_tap = emm_timing.s.data_out_tap;
+	}
+	octeontx_mmc_set_input_bus_timing(mmc);
+	octeontx_mmc_set_output_bus_timing(mmc);
+
+	for (a = adj; a->name; a++) {
+		ulong in_tap;
+
+		if (!strcmp(a->name, "CMD_IN")) {
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_cmd_in_tap", slot->bus_id);
+			in_tap = env_get_ulong(env_name, 10, (ulong)-1);
+			if (in_tap != (ulong)-1) {
+				if (mmc->selected_mode == MMC_HS_200 ||
+				    a->hs200_only) {
+					slot->hs200_taps.s.cmd_in_tap = in_tap;
+					slot->hs400_taps.s.cmd_in_tap = in_tap;
+				} else {
+					slot->taps.s.cmd_in_tap = in_tap;
+				}
+				continue;
+			}
+		} else if (a->hs200_only &&
+			   !strcmp(a->name, "DATA_IN(HS200)")) {
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_data_in_tap_hs200", slot->bus_id);
+			in_tap = env_get_ulong(env_name, 10, (ulong)-1);
+			if (in_tap != (ulong)-1) {
+				debug("%s(%s): Overriding HS200 data in tap to %d\n",
+				      __func__, dev->name, (int)in_tap);
+				slot->hs200_taps.s.data_in_tap = in_tap;
+				continue;
+			}
+		} else if (!a->hs200_only && !strcmp(a->name, "DATA_IN")) {
+			snprintf(env_name, sizeof(env_name),
+				 "emmc%d_data_in_tap", slot->bus_id);
+			in_tap = env_get_ulong(env_name, 10, (ulong)-1);
+			if (in_tap != (ulong)-1) {
+				debug("%s(%s): Overriding non-HS200 data in tap to %d\n",
+				      __func__, dev->name, (int)in_tap);
+				slot->taps.s.data_in_tap = in_tap;
+				continue;
+			}
+		}
+
+		debug("%s(%s): Testing: %s, mode: %s, opcode: %u\n", __func__,
+		      dev->name, a->name, mmc_mode_name(mmc->selected_mode),
+		      opcode);
+
+		/* Skip DDR only test when not in DDR mode */
+		if (a->ddr_only && !mmc->ddr_mode) {
+			debug("%s(%s): Skipping %s due to non-DDR mode\n",
+			      __func__, dev->name, a->name);
+			continue;
+		}
+		/* Skip hs200 tests in non-hs200 mode and
+		 * non-hs200 tests in hs200 mode
+		 */
+		if (is_hs200) {
+			if (a->not_hs200_only) {
+				debug("%s(%s): Skipping %s\n", __func__,
+				      dev->name, a->name);
+				continue;
+			}
+		} else {
+			if (a->hs200_only) {
+				debug("%s(%s): Skipping %s\n", __func__,
+				      dev->name, a->name);
+				continue;
+			}
+		}
+
+		err = octeontx_mmc_adjust_tuning(mmc, a, a->opcode ?
+						 a->opcode : opcode);
+		if (err) {
+			pr_err("%s(%s, %u): tuning %s failed\n", __func__,
+			       dev->name, opcode, a->name);
+			return err;
+		}
+	}
+
+	octeontx_mmc_set_timing(mmc);
+	if (is_hs200)
+		slot->hs200_tuned = true;
+	else
+		slot->tuned = true;
+
+	if (slot->hs400_tuning_block != -1) {
+		struct mmc_cmd cmd;
+		struct mmc_data data;
+		u8 buffer[mmc->read_bl_len];
+
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+		cmd.cmdarg = slot->hs400_tuning_block;
+		cmd.resp_type = MMC_RSP_R1;
+		data.dest = (void *)buffer;
+		data.blocks = 1;
+		data.blocksize = mmc->read_bl_len;
+		data.flags = MMC_DATA_READ;
+		err = octeontx_mmc_read_blocks(mmc, &cmd, &data, true) != 1;
+
+		if (err) {
+			printf("%s: Cannot read HS400 tuning block %u\n",
+			       dev->name, slot->hs400_tuning_block);
+			return err;
+		}
+		if (memcmp(buffer, octeontx_hs400_tuning_block,
+			   sizeof(buffer))) {
+			debug("%s(%s): Writing new HS400 tuning block to block %d\n",
+			      __func__, dev->name, slot->hs400_tuning_block);
+			cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
+			data.src = (void *)octeontx_hs400_tuning_block;
+			data.flags = MMC_DATA_WRITE;
+			err = !octeontx_mmc_write_blocks(mmc, &cmd, &data);
+			if (err) {
+				printf("%s: Cannot write HS400 tuning block %u\n",
+				       dev->name, slot->hs400_tuning_block);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /* MMC_SUPPORTS_TUNING) */
+
+/**
+ * Calculate the clock period with rounding up
+ *
+ * @param	mmc	mmc device
+ * @return	clock period in system clocks for clk_lo + clk_hi
+ */
+static u32 octeontx_mmc_calc_clk_period(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+
+	return DIV_ROUND_UP(host->sys_freq, mmc->clock);
+}
+
+static int octeontx_mmc_set_ios(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	struct mmc *mmc = &slot->mmc;
+	struct octeontx_mmc_host *host = slot->host;
+	union mio_emm_switch emm_switch;
+	union mio_emm_modex mode;
+	uint clock;
+	int bus_width = 0;
+	int clk_period = 0;
+	int power_class = 10;
+	int err = 0;
+	bool is_hs200 = false;
+	bool is_hs400 = false;
+
+	debug("%s(%s): Entry\n", __func__, dev->name);
+	debug("  clock: %u, bus width: %u, mode: %u\n", mmc->clock,
+	      mmc->bus_width, mmc->selected_mode);
+	debug("  host caps: 0x%x, card caps: 0x%x\n", mmc->host_caps,
+	      mmc->card_caps);
+	octeontx_mmc_switch_to(mmc);
+
+	clock = mmc->clock;
+	if (!clock)
+		clock = mmc->cfg->f_min;
+
+	switch (mmc->bus_width) {
+	case 8:
+		bus_width = 2;
+		break;
+	case 4:
+		bus_width = 1;
+		break;
+	case 1:
+		bus_width = 0;
+		break;
+	default:
+		pr_warn("%s(%s): Invalid bus width %d, defaulting to 1\n",
+			__func__, dev->name, mmc->bus_width);
+		bus_width = 0;
+	}
+
+	/* DDR is available for 4/8 bit bus width */
+	if (mmc->ddr_mode && bus_width)
+		bus_width |= 4;
+
+	debug("%s: sys_freq: %llu\n", __func__, host->sys_freq);
+	clk_period = octeontx_mmc_calc_clk_period(mmc);
+
+	emm_switch.u = 0;
+	emm_switch.s.bus_width = bus_width;
+	emm_switch.s.power_class = power_class;
+	emm_switch.s.clk_hi = clk_period / 2;
+	emm_switch.s.clk_lo = clk_period / 2;
+
+	debug("%s: last mode: %d, mode: %d, last clock: %u, clock: %u, ddr: %d\n",
+	      __func__, slot->last_mode, mmc->selected_mode,
+	      slot->last_clock, mmc->clock, mmc->ddr_mode);
+	switch (mmc->selected_mode) {
+	case MMC_LEGACY:
+	case SD_LEGACY:
+		break;
+	case MMC_HS:
+	case SD_HS:
+	case MMC_HS_52:
+		emm_switch.s.hs_timing = 1;
+		break;
+	case MMC_HS_200:
+		is_hs200 = true;
+		/* fall through */
+	case UHS_SDR12:
+	case UHS_SDR25:
+	case UHS_SDR50:
+	case UHS_SDR104:
+		emm_switch.s.hs200_timing = 1;
+		break;
+	case MMC_HS_400:
+		is_hs400 = true;
+		/* fall through */
+	case UHS_DDR50:
+	case MMC_DDR_52:
+		emm_switch.s.hs400_timing = 1;
+		break;
+	default:
+		pr_err("%s(%s): Unsupported mode 0x%x\n", __func__, dev->name,
+		       mmc->selected_mode);
+		return -1;
+	}
+	emm_switch.s.bus_id = slot->bus_id;
+
+	if (!is_hs200 && !is_hs400 &&
+	    (mmc->selected_mode != slot->last_mode ||
+	     mmc->clock != slot->last_clock) &&
+	    !mmc->ddr_mode) {
+		slot->tuned = false;
+		slot->last_mode = mmc->selected_mode;
+		slot->last_clock = mmc->clock;
+	}
+
+#if CONFIG_IS_ENABLED(MMC_VERBOSE) || defined(debug)
+	debug("%s(%s): Setting bus mode to %s\n", __func__, dev->name,
+	      mmc_mode_name(mmc->selected_mode));
+#else
+	debug("%s(%s): Setting bus mode to 0x%x\n", __func__, dev->name,
+	      mmc->selected_mode);
+#endif
+	debug(" Trying switch 0x%llx w%d hs:%d hs200:%d hs400:%d\n",
+	      emm_switch.u, emm_switch.s.bus_width, emm_switch.s.hs_timing,
+	      emm_switch.s.hs200_timing, emm_switch.s.hs400_timing);
+
+	set_wdog(mmc, 1000);
+	do_switch(mmc, emm_switch);
+	mdelay(100);
+	mode.u = read_csr(mmc, MIO_EMM_MODEX(slot->bus_id));
+	debug("%s(%s): mode: 0x%llx w:%d, hs:%d, hs200:%d, hs400:%d\n",
+	      __func__, dev->name, mode.u, mode.s.bus_width,
+	      mode.s.hs_timing, mode.s.hs200_timing, mode.s.hs400_timing);
+
+	err = octeontx_mmc_configure_delay(mmc);
+
+#ifdef MMC_SUPPORTS_TUNING
+	if (!err && mmc->selected_mode == MMC_HS_400 && !slot->hs400_tuned) {
+		debug("%s: Tuning HS400 mode\n", __func__);
+		err = octeontx_tune_hs400(mmc);
+	}
+#endif
+
+	return err;
+}
+
+/**
+ * Gets the status of the card detect pin
+ */
+static int octeontx_mmc_get_cd(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	int val = 1;
+
+	if (dm_gpio_is_valid(&slot->cd_gpio)) {
+		val = dm_gpio_get_value(&slot->cd_gpio);
+		val ^= slot->cd_inverted;
+	}
+	debug("%s(%s): cd: %d\n", __func__, dev->name, val);
+	return val;
+}
+
+/**
+ * Gets the status of the write protect pin
+ */
+static int octeontx_mmc_get_wp(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	int val = 0;
+
+	if (dm_gpio_is_valid(&slot->wp_gpio)) {
+		val = dm_gpio_get_value(&slot->wp_gpio);
+		val ^= slot->wp_inverted;
+	}
+	debug("%s(%s): wp: %d\n", __func__, dev->name, val);
+	return val;
+}
+
+#ifdef MMC_SUPPORTS_TUNING
+static void octeontx_mmc_set_timing(struct mmc *mmc)
+{
+	union mio_emm_timing timing;
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+
+	switch (mmc->selected_mode) {
+	case MMC_HS_200:
+		timing = slot->hs200_taps;
+		break;
+	case MMC_HS_400:
+		timing = slot->hs400_tuned ?
+				slot->hs400_taps : slot->hs200_taps;
+		break;
+	default:
+		timing = slot->taps;
+		break;
+	}
+
+	debug("%s(%s):\n  cmd_in_tap: %u\n  cmd_out_tap: %u\n  data_in_tap: %u\n  data_out_tap: %u\n",
+	      __func__, mmc->dev->name, timing.s.cmd_in_tap,
+	      timing.s.cmd_out_tap, timing.s.data_in_tap,
+	      timing.s.data_out_tap);
+
+	octeontx_mmc_set_emm_timing(mmc, timing);
+}
+#endif
+
+static int octeontx_mmc_configure_delay(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+	bool __maybe_unused is_hs200;
+	bool __maybe_unused is_hs400;
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+#if defined(CONFIG_ARCH_OCTEONTX)
+	{
+		union mio_emm_sample emm_sample;
+
+		emm_sample.u = 0;
+		emm_sample.s.cmd_cnt = slot->cmd_cnt;
+		emm_sample.s.dat_cnt = slot->dat_cnt;
+		write_csr(mmc, MIO_EMM_SAMPLE(), emm_sample.u);
+	}
+#else
+	is_hs200 = (mmc->selected_mode == MMC_HS_200);
+	is_hs400 = (mmc->selected_mode == MMC_HS_400);
+
+	if ((is_hs200 && slot->hs200_tuned) ||
+	    (is_hs400 && slot->hs400_tuned) ||
+	    (!is_hs200 && !is_hs400 && slot->tuned)) {
+		octeontx_mmc_set_output_bus_timing(mmc);
+	} else {
+		int half = MAX_NO_OF_TAPS / 2;
+		int dout, cout;
+
+		switch (mmc->selected_mode) {
+		case MMC_LEGACY:
+			cout = MMC_LEGACY_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_LEGACY_DEFAULT_DATA_OUT_TAP;
+			break;
+		case SD_LEGACY:
+			cout = MMC_SD_LEGACY_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_SD_LEGACY_DEFAULT_DATA_OUT_TAP;
+			break;
+		case MMC_HS:
+			cout = MMC_HS_CMD_OUT_TAP;
+			dout = MMC_HS_DATA_OUT_TAP;
+			break;
+		case SD_HS:
+		case UHS_SDR12:
+		case UHS_SDR25:
+		case UHS_SDR50:
+			cout = MMC_SD_HS_CMD_OUT_TAP;
+			dout = MMC_SD_HS_DATA_OUT_TAP;
+			break;
+		case UHS_SDR104:
+		case UHS_DDR50:
+		case MMC_HS_52:
+		case MMC_DDR_52:
+			cout = MMC_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_DEFAULT_DATA_OUT_TAP;
+			break;
+		case MMC_HS_200:
+			cout = -1;
+			dout = -1;
+			if (host->timing_calibrated) {
+				cout = octeontx2_mmc_calc_delay(mmc,
+						slot->cmd_out_hs200_delay);
+				dout = octeontx2_mmc_calc_delay(mmc,
+						slot->data_out_hs200_delay);
+				debug("%s(%s): Calibrated HS200/HS400 cmd out delay: %dps tap: %d, data out delay: %d, tap: %d\n",
+				      __func__, mmc->dev->name,
+				      slot->cmd_out_hs200_delay, cout,
+				      slot->data_out_hs200_delay, dout);
+			} else {
+				cout = MMC_DEFAULT_HS200_CMD_OUT_TAP;
+				dout = MMC_DEFAULT_HS200_DATA_OUT_TAP;
+			}
+			is_hs200 = true;
+			break;
+		case MMC_HS_400:
+			cout = -1;
+			dout = -1;
+			if (host->timing_calibrated) {
+				if (slot->cmd_out_hs400_delay)
+					cout = octeontx2_mmc_calc_delay(mmc,
+						slot->cmd_out_hs400_delay);
+				if (slot->data_out_hs400_delay)
+					dout = octeontx2_mmc_calc_delay(mmc,
+						slot->data_out_hs400_delay);
+				debug("%s(%s): Calibrated HS200/HS400 cmd out delay: %dps tap: %d, data out delay: %d, tap: %d\n",
+				      __func__, mmc->dev->name,
+				      slot->cmd_out_hs400_delay, cout,
+				      slot->data_out_hs400_delay, dout);
+			} else {
+				cout = MMC_DEFAULT_HS400_CMD_OUT_TAP;
+				dout = MMC_DEFAULT_HS400_DATA_OUT_TAP;
+			}
+			is_hs400 = true;
+			break;
+		default:
+			pr_err("%s(%s): Invalid mode %d\n", __func__,
+			       mmc->dev->name, mmc->selected_mode);
+			return -1;
+		}
+		debug("%s(%s): Not tuned, hs200: %d, hs200 tuned: %d, hs400: %d, hs400 tuned: %d, tuned: %d\n",
+		      __func__, mmc->dev->name, is_hs200, slot->hs200_tuned,
+		      is_hs400, slot->hs400_tuned, slot->tuned);
+		/* Set some defaults */
+		if (is_hs200) {
+			slot->hs200_taps.u = 0;
+			slot->hs200_taps.s.cmd_out_tap = cout;
+			slot->hs200_taps.s.data_out_tap = dout;
+			slot->hs200_taps.s.cmd_in_tap = half;
+			slot->hs200_taps.s.data_in_tap = half;
+		} else if (is_hs400) {
+			slot->hs400_taps.u = 0;
+			slot->hs400_taps.s.cmd_out_tap = cout;
+			slot->hs400_taps.s.data_out_tap = dout;
+			slot->hs400_taps.s.cmd_in_tap = half;
+			slot->hs400_taps.s.data_in_tap = half;
+		} else {
+			slot->taps.u = 0;
+			slot->taps.s.cmd_out_tap = cout;
+			slot->taps.s.data_out_tap = dout;
+			slot->taps.s.cmd_in_tap = half;
+			slot->taps.s.data_in_tap = half;
+		}
+	}
+
+	if (is_hs200)
+		debug("%s(%s): hs200 taps: ci: %u, co: %u, di: %u, do: %u\n",
+		      __func__, mmc->dev->name,
+		      slot->hs200_taps.s.cmd_in_tap,
+		      slot->hs200_taps.s.cmd_out_tap,
+		      slot->hs200_taps.s.data_in_tap,
+		      slot->hs200_taps.s.data_out_tap);
+	else if (is_hs400)
+		debug("%s(%s): hs400 taps: ci: %u, co: %u, di: %u, do: %u\n",
+		      __func__, mmc->dev->name,
+		      slot->hs400_taps.s.cmd_in_tap,
+		      slot->hs400_taps.s.cmd_out_tap,
+		      slot->hs400_taps.s.data_in_tap,
+		      slot->hs400_taps.s.data_out_tap);
+	else
+		debug("%s(%s): taps: ci: %u, co: %u, di: %u, do: %u\n",
+		      __func__, mmc->dev->name, slot->taps.s.cmd_in_tap,
+		      slot->taps.s.cmd_out_tap, slot->taps.s.data_in_tap,
+		      slot->taps.s.data_out_tap);
+	octeontx_mmc_set_timing(mmc);
+	debug("%s: Done\n", __func__);
+#endif
+	return 0;
+}
+
+/**
+ * Sets the MMC watchdog timer in microseconds
+ *
+ * @param	mmc	mmc device
+ * @param	us	timeout in microseconds, 0 for maximum timeout
+ */
+static void set_wdog(struct mmc *mmc, u64 us)
+{
+	union mio_emm_wdog wdog;
+	u64 val;
+
+	val = (us * mmc->clock) / 1000000;
+	if (val >= (1 << 26) || !us) {
+		if (us)
+			pr_debug("%s: warning: timeout %llu exceeds max value %llu, truncating\n",
+				 __func__, us,
+				 (u64)(((1ULL << 26) - 1) * 1000000ULL) /
+					mmc->clock);
+		val = (1 << 26) - 1;
+	}
+	wdog.u = 0;
+	wdog.s.clk_cnt = val;
+	write_csr(mmc, MIO_EMM_WDOG(), wdog.u);
+}
+
+/**
+ * Set the IO drive strength and slew
+ *
+ * @param	mmc	mmc device
+ */
+static void octeontx_mmc_io_drive_setup(struct mmc *mmc)
+{
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_io_ctl io_ctl;
+
+	if (slot->drive < 0 || slot->slew < 0)
+		return;
+	io_ctl.u = 0;
+	io_ctl.s.drive = slot->drive;
+	io_ctl.s.slew = slot->slew;
+	write_csr(mmc, MIO_EMM_IO_CTL(), io_ctl.u);
+#endif
+}
+
+/**
+ * Print switch errors
+ *
+ * @param	mmc	mmc device
+ */
+static void check_switch_errors(struct mmc *mmc)
+{
+	union mio_emm_switch emm_switch;
+
+	emm_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
+	if (emm_switch.s.switch_err0)
+		pr_err("%s: Switch power class error\n", mmc->cfg->name);
+	if (emm_switch.s.switch_err1)
+		pr_err("%s: Switch HS timing error\n", mmc->cfg->name);
+	if (emm_switch.s.switch_err2)
+		pr_err("%s: Switch bus width error\n", mmc->cfg->name);
+}
+
+static void do_switch(struct mmc *mmc, union mio_emm_switch emm_switch)
+{
+	union mio_emm_rsp_sts rsp_sts;
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	int bus_id = emm_switch.s.bus_id;
+	ulong start;
+
+	if (emm_switch.s.bus_id != 0) {
+		emm_switch.s.bus_id = 0;
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
+		udelay(100);
+		emm_switch.s.bus_id = bus_id;
+	}
+	debug("%s(%s, 0x%llx)\n", __func__, mmc->dev->name, emm_switch.u);
+	write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
+
+	start = get_timer(0);
+	do {
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
+		if (!rsp_sts.s.switch_val)
+			break;
+		udelay(100);
+	} while (get_timer(start) < 10);
+	if (rsp_sts.s.switch_val) {
+		pr_warn("%s(%s): Warning: writing 0x%llx to emm_switch timed out, status: 0x%llx\n",
+			__func__, mmc->dev->name, emm_switch.u, rsp_sts.u);
+	}
+	slot->cached_switch = emm_switch;
+	check_switch_errors(mmc);
+	slot->cached_switch.u = emm_switch.u;
+	debug("%s: emm_switch: 0x%llx, rsp_lo: 0x%llx\n",
+	      __func__, read_csr(mmc, MIO_EMM_SWITCH()),
+				 read_csr(mmc, MIO_EMM_RSP_LO()));
+}
+
+#ifndef CONFIG_ARCH_OCTEONTX
+/**
+ * Given a delay in ps, return the tap delay count
+ *
+ * @param	mmc	mmc data structure
+ * @param	delay	delay in picoseconds
+ *
+ * @return	Number of tap cycles or error if -1
+ */
+static int octeontx2_mmc_calc_delay(struct mmc *mmc, int delay)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+
+	if (host->is_asim || host->is_emul)
+		return 63;
+
+	if (!host->timing_taps) {
+		pr_err("%s(%s): Error: host timing not calibrated\n",
+		       __func__, mmc->dev->name);
+		return -1;
+	}
+	debug("%s(%s, %d) timing taps: %llu\n", __func__, mmc->dev->name,
+	      delay, host->timing_taps);
+	return min_t(int, DIV_ROUND_UP(delay, host->timing_taps), 63);
+}
+
+/**
+ * Calibrates the delay based on the internal clock
+ *
+ * @param	mmc	Pointer to mmc data structure
+ *
+ * @return	0 for success or -ETIMEDOUT on error
+ *
+ * NOTE: On error a default value will be calculated.
+ */
+static int octeontx_mmc_calibrate_delay(struct mmc *mmc)
+{
+	union mio_emm_calb emm_calb;
+	union mio_emm_tap emm_tap;
+	union mio_emm_cfg emm_cfg;
+	union mio_emm_io_ctl emm_io_ctl;
+	union mio_emm_switch emm_switch;
+	union mio_emm_wdog emm_wdog;
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_debug emm_debug;
+	union mio_emm_timing emm_timing;
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	ulong start;
+	u8 bus_id, bus_ena;
+
+	debug("%s: Calibrating delay\n", __func__);
+	if (host->is_asim || host->is_emul) {
+		debug("  No calibration for ASIM\n");
+		return 0;
+	}
+	emm_tap.u = 0;
+	if (host->calibrate_glitch) {
+		emm_tap.s.delay = MMC_DEFAULT_TAP_DELAY;
+	} else {
+		/* Save registers */
+		emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
+		emm_io_ctl.u = read_csr(mmc, MIO_EMM_IO_CTL());
+		emm_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
+		emm_wdog.u = read_csr(mmc, MIO_EMM_WDOG());
+		emm_sts_mask.u = read_csr(mmc, MIO_EMM_STS_MASK());
+		emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+		emm_timing.u = read_csr(mmc, MIO_EMM_TIMING());
+		bus_ena = emm_cfg.s.bus_ena;
+		bus_id = emm_switch.s.bus_id;
+		emm_cfg.s.bus_ena = 0;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		udelay(1);
+		emm_cfg.s.bus_ena = 1ULL << 3;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		mdelay(1);
+		emm_calb.u = 0;
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
+		emm_calb.s.start = 1;
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
+		start = get_timer(0);
+		/* This should only take 3 microseconds */
+		do {
+			udelay(5);
+			emm_tap.u = read_csr(mmc, MIO_EMM_TAP());
+		} while (!emm_tap.s.delay && get_timer(start) < 10);
+
+		emm_calb.s.start = 0;
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
+
+		emm_cfg.s.bus_ena = 0;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		udelay(1);
+		/* Restore registers */
+		emm_cfg.s.bus_ena = bus_ena;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		if (host->tap_requires_noclk) {
+			/* Turn off the clock */
+			emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+			emm_debug.s.emmc_clk_disable = 1;
+			write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+			udelay(1);
+			emm_debug.s.rdsync_rst = 1;
+			write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+			udelay(1);
+		}
+
+		write_csr(mmc, MIO_EMM_TIMING(), emm_timing.u);
+		if (host->tap_requires_noclk) {
+			/* Turn the clock back on */
+			udelay(1);
+			emm_debug.s.rdsync_rst = 0;
+			write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+			udelay(1);
+			emm_debug.s.emmc_clk_disable = 0;
+			write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+		}
+		udelay(1);
+		write_csr(mmc, MIO_EMM_IO_CTL(), emm_io_ctl.u);
+		bus_id = emm_switch.s.bus_id;
+		emm_switch.s.bus_id = 0;
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
+		emm_switch.s.bus_id = bus_id;
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
+		write_csr(mmc, MIO_EMM_WDOG(), emm_wdog.u);
+		write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
+		write_csr(mmc, MIO_EMM_RCA(), mmc->rca);
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+
+		if (!emm_tap.s.delay) {
+			pr_err("%s: Error: delay calibration failed, timed out.\n",
+			       __func__);
+			/* Set to default value if timed out */
+			emm_tap.s.delay = MMC_DEFAULT_TAP_DELAY;
+			return -ETIMEDOUT;
+		}
+	}
+	/* Round up */
+	host->timing_taps = (10 * 1000 * emm_tap.s.delay) / TOTAL_NO_OF_TAPS;
+	debug("%s(%s): timing taps: %llu, delay: %u\n",
+	      __func__, mmc->dev->name, host->timing_taps, emm_tap.s.delay);
+	host->timing_calibrated = true;
+	return 0;
+}
+#endif
+
+static int octeontx_mmc_set_input_bus_timing(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+
+#ifdef CONFIG_ARCH_OCTEONTX
+	union mio_emm_sample sample;
+
+	sample.u = 0;
+	sample.s.cmd_cnt = slot->cmd_clk_skew;
+	sample.s.dat_cnt = slot->dat_clk_skew;
+	write_csr(mmc, MIO_EMM_SAMPLE(), sample.u);
+
+#else
+	union mio_emm_timing timing;
+
+	timing.u = read_csr(mmc, MIO_EMM_TIMING());
+	if (mmc->selected_mode == MMC_HS_200) {
+		if (slot->hs200_tuned) {
+			timing.s.cmd_in_tap = slot->hs200_taps.s.cmd_in_tap;
+			timing.s.data_in_tap = slot->hs200_taps.s.data_in_tap;
+		} else {
+			pr_warn("%s(%s): Warning: hs200 timing not tuned\n",
+				__func__, mmc->dev->name);
+			timing.s.cmd_in_tap = MMC_DEFAULT_HS200_CMD_IN_TAP;
+			timing.s.data_in_tap = MMC_DEFAULT_HS200_DATA_IN_TAP;
+		}
+	} else if (mmc->selected_mode == MMC_HS_400) {
+		if (slot->hs400_tuned) {
+			timing.s.cmd_in_tap = slot->hs400_taps.s.cmd_in_tap;
+			timing.s.data_in_tap = slot->hs400_taps.s.data_in_tap;
+		} else if (slot->hs200_tuned) {
+			timing.s.cmd_in_tap = slot->hs200_taps.s.cmd_in_tap;
+			timing.s.data_in_tap = slot->hs200_taps.s.data_in_tap;
+		} else {
+			pr_warn("%s(%s): Warning: hs400 timing not tuned\n",
+				__func__, mmc->dev->name);
+			timing.s.cmd_in_tap = MMC_DEFAULT_HS200_CMD_IN_TAP;
+			timing.s.data_in_tap = MMC_DEFAULT_HS200_DATA_IN_TAP;
+		}
+	} else if (slot->tuned) {
+		timing.s.cmd_in_tap = slot->taps.s.cmd_in_tap;
+		timing.s.data_in_tap = slot->taps.s.data_in_tap;
+	} else {
+		timing.s.cmd_in_tap = MMC_DEFAULT_CMD_IN_TAP;
+		timing.s.data_in_tap = MMC_DEFAULT_DATA_IN_TAP;
+	}
+	octeontx_mmc_set_emm_timing(mmc, timing);
+#endif
+	return 0;
+}
+
+/**
+ * Sets the default bus timing for the current mode.
+ *
+ * @param	mmc	mmc data structure
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc)
+{
+#ifdef CONFIG_ARCH_OCTEONTX
+	return 0;
+#else
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union mio_emm_timing timing;
+	int cout_bdelay, dout_bdelay;
+	unsigned int cout_delay, dout_delay;
+	char env_name[32];
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+	if (slot->is_asim || slot->is_emul)
+		return 0;
+
+	octeontx_mmc_calibrate_delay(mmc);
+
+	if (mmc->clock < 26000000) {
+		cout_delay = 5000;
+		dout_delay = 5000;
+	} else if (mmc->clock <= 52000000) {
+		cout_delay = 2500;
+		dout_delay = 2500;
+	} else if (!mmc_is_mode_ddr(mmc->selected_mode)) {
+		cout_delay = slot->cmd_out_hs200_delay;
+		dout_delay = slot->data_out_hs200_delay;
+	} else {
+		cout_delay = slot->cmd_out_hs400_delay;
+		dout_delay = slot->data_out_hs400_delay;
+	}
+
+	snprintf(env_name, sizeof(env_name), "mmc%d_hs200_dout_delay_ps",
+		 slot->bus_id);
+	dout_delay = env_get_ulong(env_name, 10, dout_delay);
+	debug("%s: dout_delay: %u\n", __func__, dout_delay);
+
+	cout_bdelay = octeontx2_mmc_calc_delay(mmc, cout_delay);
+	dout_bdelay = octeontx2_mmc_calc_delay(mmc, dout_delay);
+
+	debug("%s: cmd output delay: %u, data output delay: %u, cmd bdelay: %d, data bdelay: %d, clock: %d\n",
+	      __func__, cout_delay, dout_delay, cout_bdelay, dout_bdelay,
+	      mmc->clock);
+	if (cout_bdelay < 0 || dout_bdelay < 0) {
+		pr_err("%s: Error: could not calculate command and/or data clock skew\n",
+		       __func__);
+		return -1;
+	}
+	timing.u = read_csr(mmc, MIO_EMM_TIMING());
+	timing.s.cmd_out_tap = cout_bdelay;
+	timing.s.data_out_tap = dout_bdelay;
+	if (mmc->selected_mode == MMC_HS_200) {
+		slot->hs200_taps.s.cmd_out_tap = cout_bdelay;
+		slot->hs200_taps.s.data_out_tap = dout_bdelay;
+	} else if (mmc->selected_mode == MMC_HS_400) {
+		slot->hs400_taps.s.cmd_out_tap = cout_bdelay;
+		slot->hs400_taps.s.data_out_tap = dout_bdelay;
+	} else {
+		slot->taps.s.cmd_out_tap = cout_bdelay;
+		slot->taps.s.data_out_tap = dout_bdelay;
+	}
+	octeontx_mmc_set_emm_timing(mmc, timing);
+	debug("%s(%s): bdelay: %d/%d, clock: %d, ddr: %s, timing taps: %llu, do: %d, di: %d, co: %d, ci: %d\n",
+	      __func__, mmc->dev->name, cout_bdelay, dout_bdelay, mmc->clock,
+	      mmc->ddr_mode ? "yes" : "no",
+	      mmc_to_host(mmc)->timing_taps,
+	      timing.s.data_out_tap,
+	      timing.s.data_in_tap,
+	      timing.s.cmd_out_tap,
+	      timing.s.cmd_in_tap);
+	return 0;
+#endif
+}
+
+static void octeontx_mmc_set_clock(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	uint clock;
+
+	clock = min(mmc->cfg->f_max, (uint)slot->clock);
+	clock = max(mmc->cfg->f_min, clock);
+	debug("%s(%s): f_min: %u, f_max: %u, clock: %u\n", __func__,
+	      mmc->dev->name, mmc->cfg->f_min, mmc->cfg->f_max, clock);
+	slot->clock = clock;
+	mmc->clock = clock;
+}
+
+/**
+ * This switches I/O power as needed when switching between slots.
+ *
+ * @param	mmc	mmc data structure
+ */
+static void octeontx_mmc_switch_io(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+	struct mmc *last_mmc = host->last_mmc;
+	static struct udevice *last_reg;
+	union mio_emm_cfg emm_cfg;
+	int bus;
+	static bool initialized;
+
+	/* First time? */
+	if (!initialized || mmc != host->last_mmc) {
+		struct mmc *ommc;
+
+		/* Switch to bus 3 which is unused */
+		emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
+		emm_cfg.s.bus_ena = 1 << 3;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+
+		/* Turn off all other I/O interfaces with first initialization
+		 * if at least one supply was found.
+		 */
+		for (bus = 0; bus <= OCTEONTX_MAX_MMC_SLOT; bus++) {
+			ommc = &host->slots[bus].mmc;
+
+			/* Handle self case later */
+			if (ommc == mmc || !ommc->vqmmc_supply)
+				continue;
+
+			/* Skip if we're not switching regulators */
+			if (last_reg == mmc->vqmmc_supply)
+				continue;
+
+			/* Turn off other regulators */
+			if (ommc->vqmmc_supply != mmc->vqmmc_supply)
+				regulator_set_enable(ommc->vqmmc_supply, false);
+		}
+		/* Turn ourself on */
+		if (mmc->vqmmc_supply && last_reg != mmc->vqmmc_supply)
+			regulator_set_enable(mmc->vqmmc_supply, true);
+		mdelay(1);	/* Settle time */
+		/* Switch to new bus */
+		emm_cfg.s.bus_ena = 1 << slot->bus_id;
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		last_reg = mmc->vqmmc_supply;
+		initialized = true;
+		return;
+	}
+
+	/* No change in device */
+	if (last_mmc == mmc)
+		return;
+
+	if (!last_mmc) {
+		pr_warn("%s(%s): No previous slot detected in IO slot switch!\n",
+			__func__, mmc->dev->name);
+		return;
+	}
+
+	debug("%s(%s): last: %s, supply: %p\n", __func__, mmc->dev->name,
+	      last_mmc->dev->name, mmc->vqmmc_supply);
+
+	/* The supply is the same so we do nothing */
+	if (last_mmc->vqmmc_supply == mmc->vqmmc_supply)
+		return;
+
+	/* Turn off the old slot I/O supply */
+	if (last_mmc->vqmmc_supply) {
+		debug("%s(%s): Turning off IO to %s, supply: %s\n",
+		      __func__, mmc->dev->name, last_mmc->dev->name,
+		      last_mmc->vqmmc_supply->name);
+		regulator_set_enable(last_mmc->vqmmc_supply, false);
+	}
+	/* Turn on the new slot I/O supply */
+	if (mmc->vqmmc_supply)  {
+		debug("%s(%s): Turning on IO to slot %d, supply: %s\n",
+		      __func__, mmc->dev->name, slot->bus_id,
+		      mmc->vqmmc_supply->name);
+		regulator_set_enable(mmc->vqmmc_supply, true);
+	}
+	/* Allow power to settle */
+	mdelay(1);
+}
+
+/**
+ * Called to switch between mmc devices
+ *
+ * @param	mmc	new mmc device
+ */
+static void octeontx_mmc_switch_to(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_slot *old_slot;
+	struct octeontx_mmc_host *host = slot->host;
+	union mio_emm_switch emm_switch;
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_rca emm_rca;
+
+	if (slot->bus_id == host->last_slotid)
+		return;
+
+	debug("%s(%s) switching from slot %d to slot %d\n", __func__,
+	      mmc->dev->name, host->last_slotid, slot->bus_id);
+	octeontx_mmc_switch_io(mmc);
+
+	if (host->last_slotid >= 0 && slot->valid) {
+		old_slot = &host->slots[host->last_slotid];
+		old_slot->cached_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
+		old_slot->cached_rca.u = read_csr(mmc, MIO_EMM_RCA());
+	}
+	if (mmc->rca)
+		write_csr(mmc, MIO_EMM_RCA(), mmc->rca);
+	emm_switch = slot->cached_switch;
+	do_switch(mmc, emm_switch);
+	emm_rca.u = 0;
+	emm_rca.s.card_rca = mmc->rca;
+	write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
+	mdelay(100);
+
+	set_wdog(mmc, 100000);
+	if (octeontx_mmc_set_output_bus_timing(mmc) ||
+	    octeontx_mmc_set_input_bus_timing(mmc))
+		pr_err("%s(%s): Error setting bus timing\n", __func__,
+		       mmc->dev->name);
+	octeontx_mmc_io_drive_setup(mmc);
+
+	emm_sts_mask.u = 0;
+	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
+	write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
+	host->last_slotid = slot->bus_id;
+	host->last_mmc = mmc;
+	mdelay(10);
+}
+
+#ifndef CONFIG_ARCH_OCTEONTX
+/**
+ * Perform initial timing configuration
+ *
+ * @param mmc	mmc device
+ *
+ * @return 0 for success
+ *
+ * NOTE: This will need to be updated when new silicon comes out
+ */
+static int octeontx_mmc_init_timing(struct mmc *mmc)
+{
+	union mio_emm_timing timing;
+
+	if (mmc_to_slot(mmc)->is_asim || mmc_to_slot(mmc)->is_emul)
+		return 0;
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+	timing.u = 0;
+	timing.s.cmd_out_tap = MMC_DEFAULT_CMD_OUT_TAP;
+	timing.s.data_out_tap = MMC_DEFAULT_DATA_OUT_TAP;
+	timing.s.cmd_in_tap = MMC_DEFAULT_CMD_IN_TAP;
+	timing.s.data_in_tap = MMC_DEFAULT_DATA_IN_TAP;
+	octeontx_mmc_set_emm_timing(mmc, timing);
+	return 0;
+}
+#endif
+
+/**
+ * Perform low-level initialization
+ *
+ * @param	mmc	mmc device
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_init_lowlevel(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+	union mio_emm_switch emm_switch;
+	u32 clk_period;
+
+	debug("%s(%s): lowlevel init for slot %d\n", __func__,
+	      mmc->dev->name, slot->bus_id);
+	host->emm_cfg.s.bus_ena &= ~(1 << slot->bus_id);
+	write_csr(mmc, MIO_EMM_CFG(), host->emm_cfg.u);
+	udelay(100);
+	host->emm_cfg.s.bus_ena |= 1 << slot->bus_id;
+	write_csr(mmc, MIO_EMM_CFG(), host->emm_cfg.u);
+	udelay(10);
+	slot->clock = mmc->cfg->f_min;
+	octeontx_mmc_set_clock(&slot->mmc);
+#ifdef CONFIG_ARCH_OCTEONTX2
+	if (host->cond_clock_glitch) {
+		union mio_emm_debug emm_debug;
+
+		emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+		emm_debug.s.clk_on = 1;
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
+	}
+	octeontx_mmc_calibrate_delay(&slot->mmc);
+#endif
+
+	clk_period = octeontx_mmc_calc_clk_period(mmc);
+	emm_switch.u = 0;
+	emm_switch.s.power_class = 10;
+	emm_switch.s.clk_lo = clk_period / 2;
+	emm_switch.s.clk_hi = clk_period / 2;
+
+	emm_switch.s.bus_id = slot->bus_id;
+	debug("%s: Performing switch\n", __func__);
+	do_switch(mmc, emm_switch);
+	slot->cached_switch.u = emm_switch.u;
+
+#ifndef CONFIG_ARCH_OCTEONTX
+	octeontx_mmc_init_timing(mmc);
+#endif
+
+	set_wdog(mmc, 1000000); /* Set to 1 second */
+	write_csr(mmc, MIO_EMM_STS_MASK(), 0xe4390080ull);
+	write_csr(mmc, MIO_EMM_RCA(), 1);
+	mdelay(10);
+	debug("%s: done\n", __func__);
+	return 0;
+}
+
+/**
+ * Translates a voltage number to bits in MMC register
+ *
+ * @param	voltage	voltage in microvolts
+ *
+ * @return	MMC register value for voltage
+ */
+static u32 xlate_voltage(u32 voltage)
+{
+	u32 volt = 0;
+
+	/* Convert to millivolts */
+	voltage /= 1000;
+	if (voltage >= 1650 && voltage <= 1950)
+		volt |= MMC_VDD_165_195;
+	if (voltage >= 2000 && voltage <= 2100)
+		volt |= MMC_VDD_20_21;
+	if (voltage >= 2100 && voltage <= 2200)
+		volt |= MMC_VDD_21_22;
+	if (voltage >= 2200 && voltage <= 2300)
+		volt |= MMC_VDD_22_23;
+	if (voltage >= 2300 && voltage <= 2400)
+		volt |= MMC_VDD_23_24;
+	if (voltage >= 2400 && voltage <= 2500)
+		volt |= MMC_VDD_24_25;
+	if (voltage >= 2500 && voltage <= 2600)
+		volt |= MMC_VDD_25_26;
+	if (voltage >= 2600 && voltage <= 2700)
+		volt |= MMC_VDD_26_27;
+	if (voltage >= 2700 && voltage <= 2800)
+		volt |= MMC_VDD_27_28;
+	if (voltage >= 2800 && voltage <= 2900)
+		volt |= MMC_VDD_28_29;
+	if (voltage >= 2900 && voltage <= 3000)
+		volt |= MMC_VDD_29_30;
+	if (voltage >= 3000 && voltage <= 3100)
+		volt |= MMC_VDD_30_31;
+	if (voltage >= 3100 && voltage <= 3200)
+		volt |= MMC_VDD_31_32;
+	if (voltage >= 3200 && voltage <= 3300)
+		volt |= MMC_VDD_32_33;
+	if (voltage >= 3300 && voltage <= 3400)
+		volt |= MMC_VDD_33_34;
+	if (voltage >= 3400 && voltage <= 3500)
+		volt |= MMC_VDD_34_35;
+	if (voltage >= 3500 && voltage <= 3600)
+		volt |= MMC_VDD_35_36;
+
+	return volt;
+}
+
+/**
+ * Check if a slot is valid in the device tree
+ *
+ * @param	dev	slot device to check
+ *
+ * @return	true if status reports "ok" or "okay" or if no status,
+ *		false otherwise.
+ */
+static bool octeontx_mmc_get_valid(struct udevice *dev)
+{
+	const char *stat = ofnode_read_string(dev->node, "status");
+
+	if (!stat || !strncmp(stat, "ok", 2))
+		return true;
+	else
+		return false;
+}
+
+/**
+ * Reads slot configuration from the device tree
+ *
+ * @param	dev	slot device
+ *
+ * @return	0 on success, otherwise error
+ */
+static int octeontx_mmc_get_config(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	uint voltages[2];
+	uint low, high;
+	char env_name[32];
+	int err;
+	ofnode node = dev->node;
+	int bus_width = 1;
+	ulong new_max_freq;
+
+	debug("%s(%s)", __func__, dev->name);
+	slot->cfg.name = dev->name;
+
+	slot->cfg.f_max = ofnode_read_s32_default(dev->node, "max-frequency",
+						  26000000);
+	snprintf(env_name, sizeof(env_name), "mmc_max_frequency%d",
+		 slot->bus_id);
+
+	new_max_freq = env_get_ulong(env_name, 10, slot->cfg.f_max);
+	dev_dbg(dev, "Reading %s, got %lu\n", env_name, new_max_freq);
+
+	if (new_max_freq != slot->cfg.f_max) {
+		printf("Overriding device tree MMC maximum frequency %u to %lu\n",
+		       slot->cfg.f_max, new_max_freq);
+		slot->cfg.f_max = new_max_freq;
+	}
+	slot->cfg.f_min = 400000;
+	slot->cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	slot->hs400_tuning_block =
+		ofnode_read_s32_default(dev->node,
+					"marvell,hs400-tuning-block", -1);
+	debug("%s(%s): mmc HS400 tuning block: %d\n", __func__, dev->name,
+	      slot->hs400_tuning_block);
+
+	slot->hs200_tap_adj =
+		ofnode_read_s32_default(dev->node,
+					"marvell,hs200-tap-adjust", 0);
+	debug("%s(%s): hs200-tap-adjust: %d\n", __func__, dev->name,
+	      slot->hs200_tap_adj);
+	slot->hs400_tap_adj =
+		ofnode_read_s32_default(dev->node,
+					"marvell,hs400-tap-adjust", 0);
+	debug("%s(%s): hs400-tap-adjust: %d\n", __func__, dev->name,
+	      slot->hs400_tap_adj);
+#endif
+	err = ofnode_read_u32_array(dev->node, "voltage-ranges", voltages, 2);
+	if (err) {
+		slot->cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	} else {
+		low = xlate_voltage(voltages[0]);
+		high = xlate_voltage(voltages[1]);
+		debug("  low voltage: 0x%x (%u), high: 0x%x (%u)\n",
+		      low, voltages[0], high, voltages[1]);
+		if (low > high || !low || !high) {
+			pr_err("Invalid MMC voltage range [%u-%u] specified for %s\n",
+			       low, high, dev->name);
+			return -1;
+		}
+		slot->cfg.voltages = 0;
+		do {
+			slot->cfg.voltages |= low;
+			low <<= 1;
+		} while (low <= high);
+	}
+	debug("%s: config voltages: 0x%x\n", __func__, slot->cfg.voltages);
+	slot->slew = ofnode_read_s32_default(node, "cavium,clk-slew", -1);
+	slot->drive = ofnode_read_s32_default(node, "cavium,drv-strength", -1);
+	gpio_request_by_name(dev, "cd-gpios", 0, &slot->cd_gpio, GPIOD_IS_IN);
+	slot->cd_inverted = ofnode_read_bool(node, "cd-inverted");
+	gpio_request_by_name(dev, "wp-gpios", 0, &slot->wp_gpio, GPIOD_IS_IN);
+	slot->wp_inverted = ofnode_read_bool(node, "wp-inverted");
+	if (slot->cfg.voltages & MMC_VDD_165_195) {
+		slot->is_1_8v = true;
+		slot->is_3_3v = false;
+	} else if (slot->cfg.voltages & (MMC_VDD_30_31 | MMC_VDD_31_32 |
+					 MMC_VDD_33_34 | MMC_VDD_34_35 |
+					 MMC_VDD_35_36)) {
+		slot->is_1_8v = false;
+		slot->is_3_3v = true;
+	}
+	bus_width = ofnode_read_u32_default(node, "bus-width", 1);
+	/* Note fall-through */
+	switch (bus_width) {
+	case 8:
+		slot->cfg.host_caps |= MMC_MODE_8BIT;
+	case 4:
+		slot->cfg.host_caps |= MMC_MODE_4BIT;
+	case 1:
+		slot->cfg.host_caps |= MMC_MODE_1BIT;
+		break;
+	}
+	if (ofnode_read_bool(node, "no-1-8-v")) {
+		slot->is_3_3v = true;
+		slot->is_1_8v = false;
+		if (!(slot->cfg.voltages & (MMC_VDD_32_33 | MMC_VDD_33_34)))
+			pr_warn("%s(%s): voltages indicate 3.3v but 3.3v not supported\n",
+				__func__, dev->name);
+	}
+	if (ofnode_read_bool(node, "mmc-ddr-3-3v")) {
+		slot->is_3_3v = true;
+		slot->is_1_8v = false;
+		if (!(slot->cfg.voltages & (MMC_VDD_32_33 | MMC_VDD_33_34)))
+			pr_warn("%s(%s): voltages indicate 3.3v but 3.3v not supported\n",
+				__func__, dev->name);
+	}
+	if (ofnode_read_bool(node, "cap-sd-highspeed") ||
+	    ofnode_read_bool(node, "cap-mmc-highspeed") ||
+	    ofnode_read_bool(node, "sd-uhs-sdr25"))
+		slot->cfg.host_caps |= MMC_MODE_HS;
+	if (slot->cfg.f_max >= 50000000 &&
+	    slot->cfg.host_caps & MMC_MODE_HS)
+		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	if (ofnode_read_bool(node, "sd-uhs-sdr50"))
+		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	if (ofnode_read_bool(node, "sd-uhs-ddr50"))
+		slot->cfg.host_caps |= MMC_MODE_HS | MMC_MODE_HS_52MHz |
+				       MMC_MODE_DDR_52MHz;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	if (!slot->is_asim && !slot->is_emul) {
+		if (ofnode_read_bool(node, "mmc-hs200-1_8v"))
+			slot->cfg.host_caps |= MMC_MODE_HS200 |
+					       MMC_MODE_HS_52MHz;
+		if (ofnode_read_bool(node, "mmc-hs400-1_8v"))
+			slot->cfg.host_caps |= MMC_MODE_HS400 |
+					       MMC_MODE_HS_52MHz |
+					       MMC_MODE_HS200 |
+					       MMC_MODE_DDR_52MHz;
+		slot->cmd_out_hs200_delay =
+			ofnode_read_u32_default(node,
+						"marvell,cmd-out-hs200-dly",
+						MMC_DEFAULT_HS200_CMD_OUT_DLY);
+		debug("%s(%s): HS200 cmd out delay: %d\n",
+		      __func__, dev->name, slot->cmd_out_hs200_delay);
+		slot->data_out_hs200_delay =
+			ofnode_read_u32_default(node,
+						"marvell,data-out-hs200-dly",
+						MMC_DEFAULT_HS200_DATA_OUT_DLY);
+		debug("%s(%s): HS200 data out delay: %d\n",
+		      __func__, dev->name, slot->data_out_hs200_delay);
+		slot->cmd_out_hs400_delay =
+			ofnode_read_u32_default(node,
+						"marvell,cmd-out-hs400-dly",
+						MMC_DEFAULT_HS400_CMD_OUT_DLY);
+		debug("%s(%s): HS400 cmd out delay: %d\n",
+		      __func__, dev->name, slot->cmd_out_hs400_delay);
+		slot->data_out_hs400_delay =
+			ofnode_read_u32_default(node,
+						"marvell,data-out-hs400-dly",
+						MMC_DEFAULT_HS400_DATA_OUT_DLY);
+		debug("%s(%s): HS400 data out delay: %d\n",
+		      __func__, dev->name, slot->data_out_hs400_delay);
+	}
+#endif
+	slot->disable_ddr = ofnode_read_bool(node, "marvell,disable-ddr");
+	slot->non_removable = ofnode_read_bool(node, "non-removable");
+	slot->cmd_clk_skew = ofnode_read_u32_default(node,
+						     "cavium,cmd-clk-skew", 0);
+	slot->dat_clk_skew = ofnode_read_u32_default(node,
+						     "cavium,dat-clk-skew", 0);
+	debug("%s(%s): host caps: 0x%x\n", __func__,
+	      dev->name, slot->cfg.host_caps);
+	return 0;
+}
+
+/**
+ * Probes a MMC slot
+ *
+ * @param	dev	mmc device
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_slot_probe(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot;
+	struct mmc *mmc;
+	int err;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	if (!host_probed) {
+		pr_err("%s(%s): Error: host not probed yet\n",
+		       __func__, dev->name);
+	}
+	slot = dev_to_mmc_slot(dev);
+	mmc = &slot->mmc;
+	mmc->dev = dev;
+
+	slot->valid = false;
+	if (!octeontx_mmc_get_valid(dev)) {
+		debug("%s(%s): slot is invalid\n", __func__, dev->name);
+		return -ENODEV;
+	}
+
+	debug("%s(%s): Getting config\n", __func__, dev->name);
+	err = octeontx_mmc_get_config(dev);
+	if (err) {
+		pr_err("probe(%s): Error getting config\n", dev->name);
+		return err;
+	}
+	debug("%s(%s): mmc bind, mmc: %p\n", __func__, dev->name, &slot->mmc);
+	err = mmc_bind(dev, &slot->mmc, &slot->cfg);
+	if (err) {
+		pr_err("%s(%s): Error binding mmc\n", __func__, dev->name);
+		return -1;
+	}
+	/* For some reason, mmc_bind always assigns priv to the device */
+	slot->mmc.priv = slot;
+
+	debug("%s(%s): lowlevel init\n", __func__, dev->name);
+	err = octeontx_mmc_init_lowlevel(mmc);
+	if (err) {
+		pr_err("probe(%s): Low-level init failed\n", dev->name);
+		return err;
+	}
+	slot->valid = true;
+
+	if (!err) {
+		/* Initialize each device regulator */
+		err = mmc_power_init(&slot->mmc);
+		debug("%s: Initialized %s\n", __func__, dev->name);
+		/* Turn off all I/O supplies */
+		if (!err && slot->mmc.vqmmc_supply)
+			regulator_set_enable(slot->mmc.vqmmc_supply, false);
+	}
+
+	debug("%s(%s):\n"
+	      "  base address : %p\n"
+	      "  bus id       : %d\n", __func__, dev->name,
+		slot->base_addr, slot->bus_id);
+	return err;
+}
+
+/**
+ * MMC slot driver operations
+ */
+static const struct dm_mmc_ops octeontx_hsmmc_ops = {
+	.send_cmd = octeontx_mmc_dev_send_cmd,
+	.set_ios = octeontx_mmc_set_ios,
+	.get_cd = octeontx_mmc_get_cd,
+	.get_wp = octeontx_mmc_get_wp,
+#ifdef MMC_SUPPORTS_TUNING
+	.execute_tuning = octeontx_mmc_execute_tuning,
+#endif
+};
+
+static const struct udevice_id octeontx_hsmmc_ids[] = {
+	{ .compatible = "mmc-slot" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_hsmmc_slot) = {
+	.name	= "octeontx_hsmmc_slot",
+	.id	= UCLASS_MMC,
+	.of_match = of_match_ptr(octeontx_hsmmc_ids),
+	.probe = octeontx_mmc_slot_probe,
+	.ops = &octeontx_hsmmc_ops,
+};
+
+/*****************************************************************
+ * PCI host driver
+ *
+ * The PCI host driver contains the resources used by all of the
+ * slot drivers.
+ *
+ * The slot drivers are pseudo drivers.
+ */
+
+/**
+ * Probe the MMC host controller
+ *
+ * @param	dev	mmc host controller device
+ *
+ * @return	0 for success, -1 on error
+ */
+static int octeontx_mmc_host_probe(struct udevice *dev)
+{
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	union mio_emm_int emm_int;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	u8 rev;
+#endif
+
+	debug("%s(%s): Entry host: %p\n", __func__, dev->name, host);
+
+	if (!octeontx_mmc_get_valid(dev)) {
+		debug("%s(%s): mmc host not valid\n", __func__, dev->name);
+		return -ENODEV;
+	}
+	memset(host, 0, sizeof(*host));
+	host->base_addr = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					 PCI_REGION_MEM);
+	if (!host->base_addr) {
+		pr_err("%s: Error: MMC base address not found\n", __func__);
+		return -1;
+	}
+	host->dev = dev;
+	debug("%s(%s): Base address: %p\n", __func__, dev->name,
+	      host->base_addr);
+	if (!dev_has_of_node(dev)) {
+		pr_err("%s: No device tree information found\n", __func__);
+		return -1;
+	}
+	host->node = dev->node;
+	dev->req_seq = PCI_FUNC(bdf);
+	host->last_slotid = -1;
+	if (otx_is_platform(PLATFORM_ASIM))
+		host->is_asim = true;
+	if (otx_is_platform(PLATFORM_EMULATOR))
+		host->is_emul = true;
+	host->dma_wait_delay =
+		ofnode_read_u32_default(dev->node, "marvell,dma-wait-delay", 1);
+	/* Force reset of eMMC */
+	writeq(0, host->base_addr + MIO_EMM_CFG());
+	debug("%s: Clearing MIO_EMM_CFG\n", __func__);
+	udelay(100);
+	emm_int.u = readq(host->base_addr + MIO_EMM_INT());
+	debug("%s: Writing 0x%llx to MIO_EMM_INT\n", __func__, emm_int.u);
+	writeq(emm_int.u, host->base_addr + MIO_EMM_INT());
+
+	debug("%s(%s): Getting I/O clock\n", __func__, dev->name);
+	host->sys_freq = octeontx_get_io_clock();
+	debug("%s(%s): I/O clock %llu\n", __func__, dev->name, host->sys_freq);
+
+#ifdef CONFIG_ARCH_OCTEONTX2
+	/* Flags for issues to work around */
+	dm_pci_read_config8(dev, PCI_REVISION_ID, &rev);
+	if (otx_is_soc(CN96XX)) {
+		debug("%s: CN96XX revision %d\n", __func__, rev);
+		switch (rev) {
+		case 0:
+			host->calibrate_glitch = true;
+			host->cond_clock_glitch = true;
+			break;
+		case 1:
+			break;
+		case 2:
+			break;
+		case 0x10:	/* C0 */
+			host->hs400_skew_needed = true;
+			debug("HS400 skew support enabled\n");
+			/* fall-through */
+		default:
+			debug("CN96XX rev C0+ detected\n");
+			host->tap_requires_noclk = true;
+			break;
+		}
+	} else if (otx_is_soc(CN95XX)) {
+		if (!rev)
+			host->cond_clock_glitch = true;
+	} else if (otx_is_soc(CN98XX) || otx_is_soc(F95MM)) {
+		host->tap_requires_noclk = true;
+	}
+#endif
+	host_probed = true;
+
+	return 0;
+}
+
+/**
+ * This performs some initial setup before a probe occurs.
+ *
+ * @param dev:	MMC slot device
+ *
+ * @return 0 for success, -1 on failure
+ *
+ * Do some pre-initialization before probing a slot.
+ */
+static int octeontx_mmc_host_child_pre_probe(struct udevice *dev)
+{
+	struct octeontx_mmc_host *host = dev_get_priv(dev_get_parent(dev));
+	struct octeontx_mmc_slot *slot;
+	struct mmc_uclass_priv *upriv;
+	ofnode node = dev->node;
+	u32 bus_id;
+	char name[16];
+	int err;
+
+	debug("%s(%s) Pre-Probe\n", __func__, dev->name);
+	if (ofnode_read_u32(node, "reg", &bus_id)) {
+		pr_err("%s(%s): Error: \"reg\" not found in device tree\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	if (bus_id > OCTEONTX_MAX_MMC_SLOT) {
+		pr_err("%s(%s): Error: \"reg\" out of range of 0..%d\n",
+		       __func__, dev->name, OCTEONTX_MAX_MMC_SLOT);
+		return -1;
+	}
+
+	slot = &host->slots[bus_id];
+	dev->priv = slot;
+	slot->host = host;
+	slot->bus_id = bus_id;
+	slot->dev = dev;
+	slot->base_addr = host->base_addr;
+	slot->is_asim = host->is_asim;
+	slot->is_emul = host->is_emul;
+
+	snprintf(name, sizeof(name), "octeontx-mmc%d", bus_id);
+	err = device_set_name(dev, name);
+
+	if (!dev->uclass_priv) {
+		debug("%s(%s): Allocating uclass priv\n", __func__,
+		      dev->name);
+		upriv = calloc(1, sizeof(struct mmc_uclass_priv));
+		if (!upriv)
+			return -ENOMEM;
+		dev->uclass_priv = upriv;
+		dev->uclass->priv = upriv;
+	} else {
+		upriv = dev->uclass_priv;
+	}
+	upriv->mmc = &slot->mmc;
+	debug("%s: uclass priv: %p, mmc: %p\n", dev->name, upriv, upriv->mmc);
+
+	debug("%s: ret: %d\n", __func__, err);
+	return err;
+}
+
+static const struct udevice_id octeontx_hsmmc_host_ids[] = {
+	{ .compatible = "cavium,thunder-8890-mmc" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_hsmmc_host) = {
+	.name	= "octeontx_hsmmc_host",
+	.id	= UCLASS_MISC,
+	.of_match = of_match_ptr(octeontx_hsmmc_host_ids),
+	.probe	= octeontx_mmc_host_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_mmc_host),
+	.child_pre_probe = octeontx_mmc_host_child_pre_probe,
+	.flags	= DM_FLAG_PRE_RELOC,
+};
+
+static struct pci_device_id octeontx_mmc_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_EMMC) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(octeontx_hsmmc_host, octeontx_mmc_supported);
diff --git a/drivers/mmc/octeontx_hsmmc.h b/drivers/mmc/octeontx_hsmmc.h
new file mode 100644
index 0000000000..70844b1cba
--- /dev/null
+++ b/drivers/mmc/octeontx_hsmmc.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __OCTEONTX_HSMMC_H__
+#define __OCTEONTX_HSMMC_H__
+#include <asm/gpio.h>
+
+/** Name of our driver */
+#define OCTEONTX_MMC_DRIVER_NAME	"octeontx-hsmmc"
+
+/** Maximum supported MMC slots */
+#define OCTEONTX_MAX_MMC_SLOT		3
+
+#define POWER_ON_TIME			40 /** See SD 4.1 spec figure 6-5 */
+
+/**
+ * Timeout used when waiting for commands to complete.  We need to keep this
+ * above the hardware watchdog timeout which is usually limited to 1000ms
+ */
+#define WATCHDOG_COUNT			(1100)	/* in msecs */
+
+/**
+ * Long timeout for commands which might take a while to complete.
+ */
+#define MMC_TIMEOUT_LONG		1000
+
+/**
+ * Short timeout used for most commands in msecs
+ */
+#define MMC_TIMEOUT_SHORT		20
+
+#define NSEC_PER_SEC			1000000000L
+
+#define MAX_NO_OF_TAPS			64
+
+#define EXT_CSD_POWER_CLASS		187	/* R/W */
+
+/* default HS400 tuning block number */
+#define DEFAULT_HS400_TUNING_BLOCK	1
+
+struct octeontx_mmc_host;
+
+/** MMC/SD slot data structure */
+struct octeontx_mmc_slot {
+	struct mmc		mmc;
+	struct mmc_config	cfg;
+	struct octeontx_mmc_host *host;
+	struct udevice		*dev;
+	void			*base_addr;	/** Same as host base_addr */
+	u64			clock;
+	int			bus_id;		/** slot number */
+	uint			bus_width;
+	uint			max_width;
+	int			hs200_tap_adj;
+	int			hs400_tap_adj;
+	int			hs400_tuning_block;
+	struct gpio_desc	cd_gpio;
+	struct gpio_desc	wp_gpio;
+	struct gpio_desc	power_gpio;
+	enum bus_mode		mode;
+	union mio_emm_switch	cached_switch;
+	union mio_emm_switch	want_switch;
+	union mio_emm_rca	cached_rca;
+	union mio_emm_timing	taps;	/* otx2: MIO_EMM_TIMING */
+	union mio_emm_timing	hs200_taps;
+	union mio_emm_timing	hs400_taps;
+	/* These are used to see if our tuning is still valid or not */
+	enum bus_mode		last_mode;
+	u32			last_clock;
+	u32			block_len;
+	u32			block_count;
+	int			cmd_clk_skew;
+	int			dat_clk_skew;
+	uint			cmd_cnt;	/* otx: sample cmd in delay */
+	uint			dat_cnt;	/* otx: sample data in delay */
+	uint			drive;		/* Current drive */
+	uint			slew;		/* clock skew */
+	uint			cmd_out_hs200_delay;
+	uint			data_out_hs200_delay;
+	uint			cmd_out_hs400_delay;
+	uint			data_out_hs400_delay;
+	uint			clk_period;
+	bool			valid:1;
+	bool			is_acmd:1;
+	bool			tuned:1;
+	bool			hs200_tuned:1;
+	bool			hs400_tuned:1;
+	bool			is_1_8v:1;
+	bool			is_3_3v:1;
+	bool			is_ddr:1;
+	bool			is_asim:1;
+	bool			is_emul:1;
+	bool			cd_inverted:1;
+	bool			wp_inverted:1;
+	bool			disable_ddr:1;
+	bool			non_removable:1;
+};
+
+struct octeontx_mmc_cr_mods {
+	u8 ctype_xor;
+	u8 rtype_xor;
+};
+
+struct octeontx_mmc_cr {
+	u8 c;
+	u8 r;
+};
+
+struct octeontx_sd_mods {
+	struct octeontx_mmc_cr mmc;
+	struct octeontx_mmc_cr sd;
+	struct octeontx_mmc_cr sdacmd;
+};
+
+/** Host controller data structure */
+struct octeontx_mmc_host {
+	struct		udevice *dev;
+	void		*base_addr;
+	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT + 1];
+	pci_dev_t	pdev;
+	u64		sys_freq;
+	union mio_emm_cfg emm_cfg;
+	u64		timing_taps;
+	struct mmc	*last_mmc;	/** Last mmc used */
+	ofnode		node;
+	int		cur_slotid;
+	int		last_slotid;
+	int		max_width;
+	uint		per_tap_delay;
+	uint		num_slots;
+	uint		dma_wait_delay;	/* Delay before polling DMA in usecs */
+	bool		initialized:1;
+	bool		timing_calibrated:1;
+	bool		is_asim:1;
+	bool		is_emul:1;
+	bool		calibrate_glitch:1;
+	bool		cond_clock_glitch:1;
+	bool		tap_requires_noclk:1;
+	bool		hs400_skew_needed:1;
+};
+
+/*
+ * NOTE: This was copied from the Linux kernel.
+ *
+ * MMC status in R1, for native mode (SPI bits are different)
+ * Type
+ *	e:error bit
+ *	s:status bit
+ *	r:detected and set for the actual command response
+ *	x:detected and set during command execution. the host must poll
+ *	    the card by sending status command in order to read these bits.
+ * Clear condition
+ *	a:according to the card state
+ *	b:always related to the previous command. Reception of
+ *	    a valid command will clear it (with a delay of one command)
+ *	c:clear by read
+ */
+#define R1_OUT_OF_RANGE		BIT(31)		/* er, c */
+#define R1_ADDRESS_ERROR	BIT(30)		/* erx, c */
+#define R1_BLOCK_LEN_ERROR	BIT(29)		/* er, c */
+#define R1_ERASE_SEQ_ERROR	BIT(28)		/* er, c */
+#define R1_ERASE_PARAM          BIT(27)		/* ex, c */
+#define R1_WP_VIOLATION		BIT(26)		/* erx, c */
+#define R1_CARD_IS_LOCKED	BIT(25)		/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	BIT(24)		/* erx, c */
+#define R1_COM_CRC_ERROR	BIT(23)		/* er, b */
+/*#define R1_ILLEGAL_COMMAND	BIT(22)*/		/* er, b */
+#define R1_CARD_ECC_FAILED	BIT(21)		/* ex, c */
+#define R1_CC_ERROR		BIT(20)		/* erx, c */
+#define R1_ERROR		BIT(19)		/* erx, c */
+#define R1_UNDERRUN		BIT(18)		/* ex, c */
+#define R1_OVERRUN		BIT(17)		/* ex, c */
+#define R1_CID_CSD_OVERWRITE	BIT(16)		/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
+#define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
+#define R1_ERASE_RESET		BIT(13)		/* sr, c */
+#define R1_STATUS(x)		((x) & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)	(((x) & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
+#define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
+
+#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR
+#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_WP_VIOLATION |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR |		\
+				R1_UNDERRUN |		\
+				R1_OVERRUN
+
+#endif /* __OCTEONTX_HSMMC_H__ */
diff --git a/drivers/mmc/xenon_sdhci.c b/drivers/mmc/xenon_sdhci.c
index 829b75683b..431d367904 100644
--- a/drivers/mmc/xenon_sdhci.c
+++ b/drivers/mmc/xenon_sdhci.c
@@ -20,6 +20,7 @@
 #include <linux/libfdt.h>
 #include <malloc.h>
 #include <sdhci.h>
+#include <power/regulator.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -40,6 +41,15 @@ DECLARE_GLOBAL_DATA_PTR;
 #define SDHC_SYS_EXT_OP_CTRL			0x010C
 #define MASK_CMD_CONFLICT_ERROR			BIT(8)
 
+#define SDHC_SLOT_EMMC_CTRL			0x0130
+#define ENABLE_DATA_STROBE_SHIFT		24
+#define ENABLE_DATA_STROBE			BIT(ENABLE_DATA_STROBE_SHIFT)
+#define SET_EMMC_RSTN_SHIFT			16
+#define EMMC_VCCQ_MASK				0x3
+#define EMMC_VCCQ_1_8V				0x1
+#define EMMC_VCCQ_1_2V				0x2
+#define	EMMC_VCCQ_3_3V				0x3
+
 #define SDHC_SLOT_RETUNING_REQ_CTRL		0x0144
 /* retuning compatible */
 #define RETUNING_COMPATIBLE			0x1
@@ -53,6 +63,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define OUTPUT_QSN_PHASE_SELECT			BIT(17)
 #define SAMPL_INV_QSP_PHASE_SELECT		BIT(18)
 #define SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
+#define EMMC_PHY_SDIO_MODE			BIT(28)
 #define EMMC_PHY_SLOW_MODE			BIT(29)
 #define PHY_INITIALIZAION			BIT(31)
 #define WAIT_CYCLE_BEFORE_USING_MASK		0xf
@@ -79,6 +90,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define FC_QSN_RECEN				BIT(27)
 #define OEN_QSN					BIT(28)
 #define AUTO_RECEN_CTRL				BIT(30)
+#define FC_ALL_CMOS_RECEIVER			(REC_EN_MASK << REC_EN_SHIFT)
 
 #define EMMC_PHY_PAD_CONTROL1			(EMMC_PHY_REG_BASE + 0xc)
 #define EMMC5_1_FC_QSP_PD			BIT(9)
@@ -88,10 +100,71 @@ DECLARE_GLOBAL_DATA_PTR;
 #define EMMC5_1_FC_DQ_PD			0xff
 #define EMMC5_1_FC_DQ_PU			(0xff << 16)
 
+#define EMMC_PHY_PAD_CONTROL2			(EMMC_PHY_REG_BASE + 0x10)
+#define ZNR_MASK				0x1F
+#define ZNR_SHIFT				8
+#define ZPR_MASK				0x1F
+
 #define SDHCI_RETUNE_EVT_INTSIG			0x00001000
 
+#define SDHCI_HOST_CONTROL2		0x3E
+#define  SDHCI_CTRL_UHS_MASK		0x0007
+#define   SDHCI_CTRL_UHS_SDR12		0x0000
+#define   SDHCI_CTRL_UHS_SDR25		0x0001
+#define   SDHCI_CTRL_UHS_SDR50		0x0002
+#define   SDHCI_CTRL_UHS_SDR104		0x0003
+#define   SDHCI_CTRL_UHS_DDR50		0x0004
+#define   SDHCI_CTRL_HS400		0x0005 /* Non-standard */
+#define   SDHCI_CTRL_HS200_ONLY		0x0005 /* Non-standard */
+#define   SDHCI_CTRL_HS400_ONLY		0x0006 /* Non-standard */
+#define  SDHCI_CTRL_VDD_180		0x0008
+#define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
+#define   SDHCI_CTRL_DRV_TYPE_B		0x0000
+#define   SDHCI_CTRL_DRV_TYPE_A		0x0010
+#define   SDHCI_CTRL_DRV_TYPE_C		0x0020
+#define   SDHCI_CTRL_DRV_TYPE_D		0x0030
+#define  SDHCI_CTRL_EXEC_TUNING		0x0040
+#define  SDHCI_CTRL_TUNED_CLK		0x0080
+#define  SDHCI_CTRL_PRESET_VAL_ENABLE	0x8000
+
+/*
+ * Config to eMMC PHY to prepare for tuning.
+ * Enable HW DLL and set the TUNING_STEP
+ */
+#define XENON_SLOT_DLL_CUR_DLY_VAL		0x0150
+
+#define XENON_SLOT_OP_STATUS_CTRL		0x0128
+#define XENON_TUN_CONSECUTIVE_TIMES_SHIFT	16
+#define XENON_TUN_CONSECUTIVE_TIMES_MASK	0x7
+#define XENON_TUN_CONSECUTIVE_TIMES		0x4
+#define XENON_TUNING_STEP_SHIFT			12
+#define XENON_TUNING_STEP_MASK			0xF
+#define XENON_TUNING_STEP_DIVIDER		BIT(6)
+
+#define XENON_EMMC_PHY_DLL_CONTROL		(EMMC_PHY_REG_BASE + 0x14)
+#define XENON_EMMC_5_0_PHY_DLL_CONTROL		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x10)
+#define XENON_DLL_ENABLE			BIT(31)
+#define XENON_DLL_UPDATE_STROBE_5_0		BIT(30)
+#define XENON_DLL_REFCLK_SEL			BIT(30)
+#define XENON_DLL_UPDATE			BIT(23)
+#define XENON_DLL_PHSEL1_SHIFT			24
+#define XENON_DLL_PHSEL0_SHIFT			16
+#define XENON_DLL_PHASE_MASK			0x3F
+#define XENON_DLL_PHASE_90_DEGREE		0x1F
+#define XENON_DLL_FAST_LOCK			BIT(5)
+#define XENON_DLL_GAIN2X			BIT(3)
+#define XENON_DLL_BYPASS_EN			BIT(0)
+
+#define XENON_SLOT_EXT_PRESENT_STATE		0x014C
+#define XENON_DLL_LOCK_STATE			0x1
+
 /* Hyperion only have one slot 0 */
 #define XENON_MMC_SLOT_ID_HYPERION		0
+#define SLOT_MASK(slot)				BIT(slot)
+
+#define XENON_EMMC_PHY_LOGIC_TIMING_ADJUST	(EMMC_PHY_REG_BASE + 0x18)
+#define XENON_LOGIC_TIMING_VALUE		0x00AA8977
 
 #define MMC_TIMING_LEGACY	0
 #define MMC_TIMING_MMC_HS	1
@@ -105,7 +178,17 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MMC_TIMING_MMC_HS200	9
 #define MMC_TIMING_MMC_HS400	10
 
+#define XENON_LOWEST_SDCLK_FREQ		100000
+#define XENON_DEFAULT_SDCLK_FREQ	400000
+
 #define XENON_MMC_MAX_CLK	400000000
+#define XENON_MMC_3V3_UV	3300000
+#define XENON_MMC_1V8_UV	1800000
+
+#define UHS_SDR12_MAX_DTR	25000000
+#define MMC_HIGH_26_MAX_DTR	26000000
+#define MMC_HIGH_DDR_MAX_DTR	52000000
+#define MMC_HS200_MAX_DTR	200000000
 
 enum soc_pad_ctrl_type {
 	SOC_PAD_SD,
@@ -126,6 +209,8 @@ struct xenon_sdhci_priv {
 
 	void *pad_ctrl_reg;
 	int pad_type;
+
+	struct udevice *vqmmc;
 };
 
 static int xenon_mmc_phy_init(struct sdhci_host *host)
@@ -141,26 +226,14 @@ static int xenon_mmc_phy_init(struct sdhci_host *host)
 	if ((priv->timing == MMC_TIMING_UHS_SDR50) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR25) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR12) ||
-	    (priv->timing == MMC_TIMING_SD_HS) ||
+	    (priv->timing == MMC_TIMING_SD_HS)     ||
+	    (priv->timing == MMC_TIMING_MMC_HS)    ||
 	    (priv->timing == MMC_TIMING_LEGACY))
 		var |= EMMC_PHY_SLOW_MODE;
-	sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
+	else if (priv->timing == MMC_TIMING_MMC_HS400)
+		var &= ~EMMC_PHY_SLOW_MODE;
 
-	/* Poll for host MMC PHY clock init to be stable */
-	/* Wait up to 10ms */
-	time = 100;
-	while (time--) {
-		var = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-		if (var & SDHCI_CLOCK_INT_STABLE)
-			break;
-
-		udelay(100);
-	}
-
-	if (time <= 0) {
-		pr_err("Failed to enable MMC internal clock in time\n");
-		return -ETIMEDOUT;
-	}
+	sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
 
 	/* Init PHY */
 	var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
@@ -169,7 +242,7 @@ static int xenon_mmc_phy_init(struct sdhci_host *host)
 
 	if (clock == 0) {
 		/* Use the possibly slowest bus frequency value */
-		clock = 100000;
+		clock = XENON_LOWEST_SDCLK_FREQ;
 	}
 
 	/* Poll for host eMMC PHY init to complete */
@@ -206,6 +279,211 @@ static void armada_3700_soc_pad_voltage_set(struct sdhci_host *host)
 		writel(ARMADA_3700_SOC_PAD_3_3V, priv->pad_ctrl_reg);
 }
 
+static int xenon_mmc_start_signal_voltage_switch(struct sdhci_host *host,
+						 int *pwr_1v8)
+{
+	struct xenon_sdhci_priv *priv = host->mmc->priv;
+	u8 voltage = host->mmc->signal_voltage;
+	int enable_1v8 = 0;
+	u32 ctrl;
+	int ret = 0;
+
+	/* If there is no vqmmc regulator, return */
+	if (!priv->vqmmc)
+		return 0;
+
+	if (priv->pad_type == SOC_PAD_FIXED_1_8V) {
+		/* Switch to 1.8v */
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_1V8_UV);
+		enable_1v8 = 1;
+	} else if (voltage == MMC_SIGNAL_VOLTAGE_330) {
+		/* Switch to 3.3v */
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_3V3_UV);
+	} else if (voltage == MMC_SIGNAL_VOLTAGE_180) {
+		/* Switch to 1.8v */
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_1V8_UV);
+		enable_1v8 = 1;
+	} else {
+		return -ENOTSUPP;
+	}
+
+	if (ret) {
+		printf("Signal voltage switch fail\n");
+		return ret;
+	}
+
+	/* Set VCCQ, eMMC mode: 1.8V; SD/SDIO mode: 3.3V */
+	ctrl = sdhci_readl(host, SDHC_SLOT_EMMC_CTRL);
+	if (IS_SD(host->mmc))
+		ctrl |= EMMC_VCCQ_3_3V;
+	else
+		ctrl |= EMMC_VCCQ_1_8V;
+	sdhci_writel(host, ctrl, SDHC_SLOT_EMMC_CTRL);
+
+	*pwr_1v8 = enable_1v8;
+
+	return 0;
+}
+
+/*
+ * Xenon defines different values for HS200 and HS400
+ * in Host_Control_2
+ */
+static void xenon_set_uhs_signaling(struct sdhci_host *host,
+				    unsigned int timing)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if (timing == MMC_TIMING_MMC_HS200)
+		ctrl_2 |= SDHCI_CTRL_HS200_ONLY;
+	else if (timing == MMC_TIMING_UHS_SDR104)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (timing == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+		 (timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400)
+		ctrl_2 |= SDHCI_CTRL_HS400_ONLY;
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static void xenon_emmc_phy_disable_data_strobe(struct sdhci_host *host)
+{
+	u32 reg;
+
+	/* Disable SDHC Data Strobe */
+	reg = sdhci_readl(host, SDHC_SLOT_EMMC_CTRL);
+	reg &= ~ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHC_SLOT_EMMC_CTRL);
+
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
+	reg &= ~(EMMC5_1_FC_QSP_PD | EMMC5_1_FC_QSP_PU);
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+}
+
+/*
+ * Enable eMMC PHY HW DLL
+ * DLL should be enabled and stable before HS200/SDR104 tuning,
+ * and before HS400 data strobe setting.
+ */
+static int xenon_emmc_phy_enable_dll(struct sdhci_host *host)
+{
+	u32 reg;
+	u32 timeout;
+
+	if (host->mmc->tran_speed <= MMC_HIGH_DDR_MAX_DTR)
+		return -EINVAL;
+
+	reg = sdhci_readl(host, XENON_EMMC_PHY_DLL_CONTROL);
+	if (reg & XENON_DLL_ENABLE)
+		return 0;
+
+	/* Enable DLL */
+	reg = sdhci_readl(host, XENON_EMMC_PHY_DLL_CONTROL);
+	reg |= (XENON_DLL_ENABLE | XENON_DLL_FAST_LOCK);
+
+	/*
+	 * Set Phase as 90 degree, which is most common value.
+	 * Might set another value if necessary.
+	 * The granularity is 1 degree.
+	 */
+	reg &= ~((XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL0_SHIFT) |
+		 (XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL1_SHIFT));
+	reg |= ((XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL0_SHIFT) |
+		(XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL1_SHIFT));
+
+	reg &= ~(XENON_DLL_BYPASS_EN | XENON_DLL_REFCLK_SEL);
+	reg |= XENON_DLL_UPDATE;
+	sdhci_writel(host, reg, XENON_EMMC_PHY_DLL_CONTROL);
+
+	/* Wait max 32 ms */
+	timeout = 32;
+	while (!(sdhci_readl(host, XENON_SLOT_EXT_PRESENT_STATE) &
+		XENON_DLL_LOCK_STATE)) {
+		if (timeout > 32) {
+			printf("Wait for DLL Lock time-out\n");
+			return -ETIMEDOUT;
+		}
+		udelay(1000);
+		timeout++;
+	}
+	return 0;
+}
+
+/* Set HS400 Data Strobe */
+static void xenon_emmc_phy_strobe_delay_adj(struct sdhci_host *host)
+{
+	struct xenon_sdhci_priv *priv = host->mmc->priv;
+	u32 reg;
+
+	if (WARN_ON(priv->timing != MMC_TIMING_MMC_HS400))
+		return;
+
+	if (host->mmc->tran_speed <= MMC_HIGH_DDR_MAX_DTR)
+		return;
+
+	debug("starting HS400 strobe delay adjustment\n");
+
+	xenon_emmc_phy_enable_dll(host);
+
+	/* Enable SDHC Data Strobe */
+	reg = sdhci_readl(host, SDHC_SLOT_EMMC_CTRL);
+	reg |= ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHC_SLOT_EMMC_CTRL);
+
+	/* Set Data Strobe Pull down */
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
+	reg |= EMMC5_1_FC_QSP_PD;
+	reg &= ~EMMC5_1_FC_QSP_PU;
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+}
+
+static int xenon_emmc_phy_config_tuning(struct sdhci_host *host)
+{
+	u32 reg, tuning_step;
+	int ret;
+
+	if (host->mmc->tran_speed <= MMC_HIGH_DDR_MAX_DTR)
+		return -EINVAL;
+
+	ret = xenon_emmc_phy_enable_dll(host);
+	if (ret)
+		return ret;
+
+	/* Achieve TUNING_STEP with HW DLL help */
+	reg = sdhci_readl(host, XENON_SLOT_DLL_CUR_DLY_VAL);
+	tuning_step = reg / XENON_TUNING_STEP_DIVIDER;
+	if (unlikely(tuning_step > XENON_TUNING_STEP_MASK)) {
+		dev_warn(mmc_dev(host->mmc),
+			 "HS200 TUNING_STEP %d is larger than MAX value\n",
+			 tuning_step);
+		tuning_step = XENON_TUNING_STEP_MASK;
+	}
+
+	/* Set TUNING_STEP for later tuning */
+	reg = sdhci_readl(host, XENON_SLOT_OP_STATUS_CTRL);
+	reg &= ~(XENON_TUN_CONSECUTIVE_TIMES_MASK <<
+		 XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg |= (XENON_TUN_CONSECUTIVE_TIMES <<
+		XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg &= ~(XENON_TUNING_STEP_MASK << XENON_TUNING_STEP_SHIFT);
+	reg |= (tuning_step << XENON_TUNING_STEP_SHIFT);
+	sdhci_writel(host, reg, XENON_SLOT_OP_STATUS_CTRL);
+
+	return 0;
+}
+
 static void xenon_mmc_phy_set(struct sdhci_host *host)
 {
 	struct xenon_sdhci_priv *priv = host->mmc->priv;
@@ -213,8 +491,8 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 
 	/* Setup pad, set bit[30], bit[28] and bits[26:24] */
 	var = sdhci_readl(host, EMMC_PHY_PAD_CONTROL);
-	var |= AUTO_RECEN_CTRL | OEN_QSN | FC_QSP_RECEN |
-		FC_CMD_RECEN | FC_DQ_RECEN;
+	var |= OEN_QSN | FC_QSP_RECEN | FC_CMD_RECEN | FC_DQ_RECEN |
+		FC_ALL_CMOS_RECEIVER;
 	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL);
 
 	/* Set CMD and DQ Pull Up */
@@ -224,44 +502,116 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL1);
 
 	/*
-	 * If timing belongs to high speed, set bit[17] of
+	 * If Timing belongs to high speed, clear bit[17] of
 	 * EMMC_PHY_TIMING_ADJUST register
 	 */
+	var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
 	if ((priv->timing == MMC_TIMING_MMC_HS400) ||
 	    (priv->timing == MMC_TIMING_MMC_HS200) ||
+	    (priv->timing == MMC_TIMING_MMC_DDR52) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR50) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR104) ||
 	    (priv->timing == MMC_TIMING_UHS_DDR50) ||
-	    (priv->timing == MMC_TIMING_UHS_SDR25) ||
-	    (priv->timing == MMC_TIMING_MMC_DDR52)) {
-		var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
-		var |= OUTPUT_QSN_PHASE_SELECT;
+	    (priv->timing == MMC_TIMING_UHS_SDR25)) {
+		var &= ~OUTPUT_QSN_PHASE_SELECT;
 		sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
 	}
 
+	if (priv->timing == MMC_TIMING_LEGACY)
+		goto phy_init;
+
+	/*
+	 * If SDIO card, set SDIO Mode
+	 * Otherwise, clear SDIO Mode
+	 */
+	var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	if (IS_SD(host->mmc))
+		var |= EMMC_PHY_SDIO_MODE;
+	else
+		var &= ~EMMC_PHY_SDIO_MODE;
+	sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
+
+	/*
+	 * Set preferred ZNR and ZPR value
+	 * The ZNR and ZPR value vary between different boards.
+	 * Define them both in sdhci-xenon-emmc-phy.h.
+	 */
+	var = sdhci_readl(host, EMMC_PHY_PAD_CONTROL2);
+	var &= ~((ZNR_MASK << ZNR_SHIFT) | ZPR_MASK);
+	var |= ((0xf << ZNR_SHIFT) | 0xf);
+	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL2);
+
 	/*
 	 * When setting EMMC_PHY_FUNC_CONTROL register,
 	 * SD clock should be disabled
 	 */
-	var = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	var = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
 	var &= ~SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, var, SDHCI_CLOCK_CONTROL);
 
 	var = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
-	if (host->mmc->ddr_mode) {
-		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) | CMD_DDR_MODE;
-	} else {
+	switch (priv->timing) {
+	case MMC_TIMING_MMC_HS400:
+		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
+		       CMD_DDR_MODE;
+		var &= ~DQ_ASYNC_MODE;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
+		       CMD_DDR_MODE | DQ_ASYNC_MODE;
+		break;
+	default:
 		var &= ~((DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
 			 CMD_DDR_MODE);
+		var |= DQ_ASYNC_MODE;
 	}
 	sdhci_writel(host, var, EMMC_PHY_FUNC_CONTROL);
 
 	/* Enable bus clock */
-	var = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	var = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
 	var |= SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, var, SDHCI_CLOCK_CONTROL);
 
+	udelay(1000);
+
+	/* Quirk, value suggested by hardware team */
+	if (priv->timing == MMC_TIMING_MMC_HS400)
+		/* Hardware team recommend a value for HS400 */
+		sdhci_writel(host, XENON_LOGIC_TIMING_VALUE,
+			     XENON_EMMC_PHY_LOGIC_TIMING_ADJUST);
+	else
+		xenon_emmc_phy_disable_data_strobe(host);
+
+phy_init:
+
+	xenon_set_uhs_signaling(host, priv->timing);
 	xenon_mmc_phy_init(host);
+
+	if (priv->timing == MMC_TIMING_MMC_HS200) {
+		if (xenon_emmc_phy_config_tuning(host) != 0)
+			printf("Error, failed to tune MMC PHY\n");
+	}
+	if (priv->timing == MMC_TIMING_MMC_HS400)
+		xenon_emmc_phy_strobe_delay_adj(host);
+}
+
+/* Set SDCLK-off-while-idle */
+static void xenon_set_sdclk_off_idle(struct sdhci_host *host,
+				     u8 slot, bool enable)
+{
+	u32 reg;
+	u32 mask;
+
+	reg = sdhci_readl(host, SDHC_SYS_OP_CTRL);
+	/* Get the bit shift basing on the SDHC index */
+	mask = (0x1 << (SDCLK_IDLEOFF_ENABLE_SHIFT + slot));
+	if (enable)
+		reg |= mask;
+	else
+		reg &= ~mask;
+
+	sdhci_writel(host, reg, SDHC_SYS_OP_CTRL);
 }
 
 /* Enable/Disable the Auto Clock Gating function of this slot */
@@ -278,8 +628,6 @@ static void xenon_mmc_set_acg(struct sdhci_host *host, bool enable)
 	sdhci_writel(host, var, SDHC_SYS_OP_CTRL);
 }
 
-#define SLOT_MASK(slot)		BIT(slot)
-
 /* Enable specific slot */
 static void xenon_mmc_enable_slot(struct sdhci_host *host, u8 slot)
 {
@@ -313,6 +661,9 @@ static void xenon_mmc_disable_tuning(struct sdhci_host *host, u8 slot)
 	var = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
 	var &= ~SDHCI_RETUNE_EVT_INTSIG;
 	sdhci_writel(host, var, SDHCI_SIGNAL_ENABLE);
+	var = sdhci_readl(host, SDHCI_INT_ENABLE);
+	var &= ~SDHCI_RETUNE_EVT_INTSIG;
+	sdhci_writel(host, var, SDHCI_INT_ENABLE);
 }
 
 /* Mask command conflict error */
@@ -331,10 +682,14 @@ static int xenon_sdhci_set_ios_post(struct sdhci_host *host)
 	struct xenon_sdhci_priv *priv = host->mmc->priv;
 	uint speed = host->mmc->tran_speed;
 	int pwr_18v = 0;
+	u32 reg;
 
-	if ((sdhci_readb(host, SDHCI_POWER_CONTROL) & ~SDHCI_POWER_ON) ==
-	    SDHCI_POWER_180)
-		pwr_18v = 1;
+	/*
+	 * Signal Voltage Switching is only applicable for Host Controllers
+	 * v3.00 and above.
+	 */
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+		xenon_mmc_start_signal_voltage_switch(host, &pwr_18v);
 
 	/* Set timing variable according to the configured speed */
 	if (IS_SD(host->mmc)) {
@@ -342,29 +697,50 @@ static int xenon_sdhci_set_ios_post(struct sdhci_host *host)
 		if (pwr_18v) {
 			if (host->mmc->ddr_mode)
 				priv->timing = MMC_TIMING_UHS_DDR50;
-			else if (speed <= 25000000)
+			else if (speed <= UHS_SDR12_MAX_DTR)
 				priv->timing = MMC_TIMING_UHS_SDR25;
 			else
 				priv->timing = MMC_TIMING_UHS_SDR50;
 		} else {
-			if (speed <= 25000000)
+			if (speed <= UHS_SDR12_MAX_DTR)
 				priv->timing = MMC_TIMING_LEGACY;
 			else
 				priv->timing = MMC_TIMING_SD_HS;
 		}
 	} else {
 		/* eMMC */
-		if (host->mmc->ddr_mode)
+		if (speed == MMC_HS200_MAX_DTR) {
+			if (host->mmc->ddr_mode)
+				priv->timing = MMC_TIMING_MMC_HS400;
+			else
+				priv->timing = MMC_TIMING_MMC_HS200;
+		} else if (host->mmc->ddr_mode) {
 			priv->timing = MMC_TIMING_MMC_DDR52;
-		else if (speed <= 26000000)
+		} else if (speed <= MMC_HIGH_26_MAX_DTR) {
 			priv->timing = MMC_TIMING_LEGACY;
-		else
+		} else {
 			priv->timing = MMC_TIMING_MMC_HS;
+		}
+	}
+
+	/*
+	 * HS400/HS200/eMMC HS doesn't have Preset Value register.
+	 */
+	if ((priv->timing == MMC_TIMING_MMC_HS400) ||
+	    (priv->timing == MMC_TIMING_MMC_HS200) ||
+	    (priv->timing == MMC_TIMING_MMC_HS)) {
+		reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		reg &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;
+		sdhci_writew(host, reg, SDHCI_HOST_CONTROL2);
 	}
 
 	/* Re-init the PHY */
 	xenon_mmc_phy_set(host);
 
+	if (host->clock > XENON_DEFAULT_SDCLK_FREQ)
+		xenon_set_sdclk_off_idle(host, XENON_MMC_SLOT_ID_HYPERION,
+					 true);
+
 	return 0;
 }
 
@@ -380,6 +756,7 @@ static int xenon_sdhci_probe(struct udevice *dev)
 	struct xenon_sdhci_priv *priv = dev_get_priv(dev);
 	struct sdhci_host *host = dev_get_priv(dev);
 	int ret;
+	int len;
 
 	host->mmc = &plat->mmc;
 	host->mmc->priv = host;
@@ -392,18 +769,17 @@ static int xenon_sdhci_probe(struct udevice *dev)
 	/* Set default timing */
 	priv->timing = MMC_TIMING_LEGACY;
 
-	/* Disable auto clock gating during init */
-	xenon_mmc_set_acg(host, false);
-
-	/* Enable slot */
-	xenon_mmc_enable_slot(host, XENON_MMC_SLOT_ID_HYPERION);
-
-	/*
-	 * Set default power on SoC PHY PAD register (currently only
-	 * available on the Armada 3700)
-	 */
-	if (priv->pad_ctrl_reg)
-		armada_3700_soc_pad_voltage_set(host);
+	/* Get the vqmmc regulator if there is */
+	device_get_supply_regulator(dev, "vqmmc-supply", &priv->vqmmc);
+	/* Set the initial voltage value to 3.3V if there is regulator */
+	if (priv->vqmmc) {
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_3V3_UV);
+		if (ret) {
+			printf("Failed to set VQMMC regulator to 3.3V\n");
+			return ret;
+		}
+	}
 
 	host->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_DDR_52MHz;
 	switch (fdtdec_get_int(gd->fdt_blob, dev_of_offset(dev), "bus-width",
@@ -421,28 +797,56 @@ static int xenon_sdhci_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	host->ops = &xenon_sdhci_ops;
+	/* Support for High Speed modes */
+	if (fdt_getprop(gd->fdt_blob,
+			dev_of_offset(dev), "mmc-hs400-1_8v", &len) != NULL) {
+		host->host_caps |= (MMC_MODE_HS400 | MMC_MODE_HS200);
+	}
+	if (fdt_getprop(gd->fdt_blob,
+			dev_of_offset(dev), "mmc-hs200-1_8v", &len) != NULL) {
+		host->host_caps |= MMC_MODE_HS200;
+	}
+
+	if (host->host_caps & MMC_MODE_HS200)
+		sdhci_writeb(host,  SDHCI_POWER_180 | SDHCI_POWER_ON,
+			     SDHCI_POWER_CONTROL);
 
+	host->ops = &xenon_sdhci_ops;
 	host->max_clk = XENON_MMC_MAX_CLK;
-	ret = sdhci_setup_cfg(&plat->cfg, host, 0, 0);
-	if (ret)
-		return ret;
 
-	ret = sdhci_probe(dev);
-	if (ret)
-		return ret;
+	/* Disable auto clock gating during init */
+	xenon_mmc_set_acg(host, false);
+
+	/* Enable slot */
+	xenon_mmc_enable_slot(host, XENON_MMC_SLOT_ID_HYPERION);
+
+	/*
+	 * Set default power on SoC PHY PAD register (currently only
+	 * available on the Armada 3700)
+	 */
+	if (priv->pad_ctrl_reg)
+		armada_3700_soc_pad_voltage_set(host);
 
 	/* Enable parallel transfer */
 	xenon_mmc_enable_parallel_tran(host, XENON_MMC_SLOT_ID_HYPERION);
 
-	/* Disable tuning functionality of this slot */
-	xenon_mmc_disable_tuning(host, XENON_MMC_SLOT_ID_HYPERION);
-
 	/* Enable auto clock gating after init */
 	xenon_mmc_set_acg(host, true);
 
+	/* Disable SDCLK-Off-While-Idle before card init */
+	xenon_set_sdclk_off_idle(host, XENON_MMC_SLOT_ID_HYPERION, false);
+
+	/* Disable tuning functionality of this slot */
+	xenon_mmc_disable_tuning(host, XENON_MMC_SLOT_ID_HYPERION);
+
 	xenon_mask_cmd_conflict_err(host);
 
+	ret = sdhci_setup_cfg(&plat->cfg, host, XENON_MMC_MAX_CLK, 0);
+	if (ret)
+		return ret;
+
+	ret = sdhci_probe(dev);
+
 	return ret;
 }
 
@@ -455,8 +859,10 @@ static int xenon_sdhci_ofdata_to_platdata(struct udevice *dev)
 	host->name = dev->name;
 	host->ioaddr = (void *)devfdt_get_addr(dev);
 
-	if (device_is_compatible(dev, "marvell,armada-3700-sdhci"))
-		priv->pad_ctrl_reg = (void *)devfdt_get_addr_index(dev, 1);
+	if (!device_is_compatible(dev, "marvell,armada-3700-sdhci"))
+		return 0;
+
+	priv->pad_ctrl_reg = (void *)devfdt_get_addr_index(dev, 1);
 
 	name = fdt_getprop(gd->fdt_blob, dev_of_offset(dev), "marvell,pad-type",
 			   NULL);
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index a129f44869..10ac180199 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -286,6 +286,22 @@ config NAND_ZYNQ_USE_BOOTLOADER1_TIMINGS
 	  This flag prevent U-boot reconfigure NAND flash controller and reuse
 	  the NAND timing from 1st stage bootloader.
 
+config NAND_OCTEONTX
+	bool "Support for OcteonTX NAND controller"
+	select SYS_NAND_SELF_INIT
+	imply CMD_NAND
+	help
+	 This enables Nand flash controller hardware found on the OcteonTX
+	 processors.
+
+config NAND_OCTEONTX_HW_ECC
+	bool "Support Hardware ECC for OcteonTX NAND controller"
+	depends on NAND_OCTEONTX
+	default y
+	help
+	 This enables Hardware BCH engine found on the OcteonTX processors to
+	 support ECC for NAND flash controller.
+
 config NAND_STM32_FMC2
 	bool "Support for NAND controller on STM32MP SoCs"
 	depends on ARCH_STM32MP
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
index 9337f6482e..24c51b6924 100644
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -58,6 +58,8 @@ obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
 obj-$(CONFIG_NAND_MXC) += mxc_nand.o
 obj-$(CONFIG_NAND_MXS) += mxs_nand.o
 obj-$(CONFIG_NAND_MXS_DT) += mxs_nand_dt.o
+obj-$(CONFIG_NAND_OCTEONTX) += octeontx_nand.o
+obj-$(CONFIG_NAND_OCTEONTX_HW_ECC) += octeontx_bch.o
 obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o
 obj-$(CONFIG_NAND_SPEAR) += spr_nand.o
 obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o
diff --git a/drivers/mtd/nand/raw/octeontx_bch.c b/drivers/mtd/nand/raw/octeontx_bch.c
new file mode 100644
index 0000000000..db6c948320
--- /dev/null
+++ b/drivers/mtd/nand/raw/octeontx_bch.c
@@ -0,0 +1,424 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <pci.h>
+#include <nand.h>
+#include <dm.h>
+#include <dm/of_access.h>
+#include <linux/bitfield.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/libfdt.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand_bch.h>
+#include <linux/mtd/nand_ecc.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/dma-mapping.h>
+#include <asm/arch/clock.h>
+#include "octeontx_bch.h"
+
+#ifdef DEBUG
+# undef CONFIG_LOGLEVEL
+# define CONFIG_LOGLEVEL 8
+#endif
+
+LIST_HEAD(octeontx_bch_devices);
+static unsigned int num_vfs = BCH_NR_VF;
+static void *bch_pf;
+static void *bch_vf;
+static void *token;
+static bool bch_pf_initialized;
+static bool bch_vf_initialized;
+
+static int pci_enable_sriov(struct udevice *dev, int nr_virtfn)
+{
+	int ret;
+
+	ret = pci_sriov_init(dev, nr_virtfn);
+	if (ret)
+		printf("%s(%s): pci_sriov_init returned %d\n", __func__,
+		       dev->name, ret);
+	return ret;
+}
+
+void *octeontx_bch_getv(void)
+{
+	if (!bch_vf)
+		return NULL;
+	if (bch_vf_initialized && bch_pf_initialized)
+		return bch_vf;
+	else
+		return NULL;
+}
+
+void octeontx_bch_putv(void *token)
+{
+	bch_vf_initialized = !!token;
+	bch_vf = token;
+}
+
+void *octeontx_bch_getp(void)
+{
+	return token;
+}
+
+void octeontx_bch_putp(void *token)
+{
+	bch_pf = token;
+	bch_pf_initialized = !!token;
+}
+
+static int do_bch_init(struct bch_device *bch)
+{
+	return 0;
+}
+
+static void bch_reset(struct bch_device *bch)
+{
+	writeq(1, bch->reg_base + BCH_CTL);
+	mdelay(2);
+}
+
+static void bch_disable(struct bch_device *bch)
+{
+	writeq(~0ull, bch->reg_base + BCH_ERR_INT_ENA_W1C);
+	writeq(~0ull, bch->reg_base + BCH_ERR_INT);
+	bch_reset(bch);
+}
+
+static u32 bch_check_bist_status(struct bch_device *bch)
+{
+	return readq(bch->reg_base + BCH_BIST_RESULT);
+}
+
+static int bch_device_init(struct bch_device *bch)
+{
+	u64 bist;
+	int rc;
+
+	debug("%s: Resetting...\n", __func__);
+	/* Reset the PF when probed first */
+	bch_reset(bch);
+
+	debug("%s: Checking BIST...\n", __func__);
+	/* Check BIST status */
+	bist = (u64)bch_check_bist_status(bch);
+	if (bist) {
+		dev_err(dev, "BCH BIST failed with code 0x%llx\n", bist);
+		return -ENODEV;
+	}
+
+	/* Get max VQs/VFs supported by the device */
+
+	bch->max_vfs = pci_sriov_get_totalvfs(bch->dev);
+	debug("%s: %d vfs\n", __func__, bch->max_vfs);
+	if (num_vfs > bch->max_vfs) {
+		dev_warn(dev, "Num of VFs to enable %d is greater than max available.  Enabling %d VFs.\n",
+			 num_vfs, bch->max_vfs);
+		num_vfs = bch->max_vfs;
+	}
+	bch->vfs_enabled = bch->max_vfs;
+	/* Get number of VQs/VFs to be enabled */
+	/* TODO: Get CLK frequency */
+	/* Reset device parameters */
+
+	debug("%s: Doing initialization\n", __func__);
+	rc = do_bch_init(bch);
+
+	return rc;
+}
+
+static int bch_sriov_configure(struct udevice *dev, int numvfs)
+{
+	struct bch_device *bch = dev_get_priv(dev);
+	int ret = -EBUSY;
+
+	debug("%s(%s, %d), bch: %p, vfs_in_use: %d, enabled: %d\n", __func__,
+	      dev->name, numvfs, bch, bch->vfs_in_use, bch->vfs_enabled);
+	if (bch->vfs_in_use)
+		goto exit;
+
+	ret = 0;
+
+	if (numvfs > 0) {
+		debug("%s: Enabling sriov\n", __func__);
+		ret = pci_enable_sriov(dev, numvfs);
+		if (ret == 0) {
+			bch->flags |= BCH_FLAG_SRIOV_ENABLED;
+			ret = numvfs;
+			bch->vfs_enabled = numvfs;
+		}
+	}
+
+	dev_notice(bch->dev, "VFs enabled: %d\n", ret);
+exit:
+	debug("%s: Returning %d\n", __func__, ret);
+	return ret;
+}
+
+static int octeontx_pci_bchpf_probe(struct udevice *dev)
+{
+	struct bch_device *bch;
+	int ret;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	bch = dev_get_priv(dev);
+	if (!bch)
+		return -ENOMEM;
+
+	bch->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
+	bch->dev = dev;
+
+	debug("%s: base address: %p\n", __func__, bch->reg_base);
+	ret = bch_device_init(bch);
+	if (ret) {
+		printf("%s(%s): init returned %d\n", __func__, dev->name, ret);
+		return ret;
+	}
+	INIT_LIST_HEAD(&bch->list);
+	list_add(&bch->list, &octeontx_bch_devices);
+	token = (void *)dev;
+
+	debug("%s: Configuring SRIOV\n", __func__);
+	bch_sriov_configure(dev, num_vfs);
+	debug("%s: Done.\n", __func__);
+	octeontx_bch_putp(bch);
+
+	return 0;
+}
+
+static const struct pci_device_id octeontx_bchpf_pci_id_table[] = {
+	{ PCI_VDEVICE(CAVIUM, BCH_PCI_PF_DEVICE_ID) },
+	{},
+};
+
+static const struct pci_device_id octeontx_bchvf_pci_id_table[] = {
+	{ PCI_VDEVICE(CAVIUM, BCH_PCI_VF_DEVICE_ID)},
+	{},
+};
+
+/**
+ * Given a data block calculate the ecc data and fill in the response
+ *
+ * @param[in] block	8-byte aligned pointer to data block to calculate ECC
+ * @param block_size	Size of block in bytes, must be a multiple of two.
+ * @param bch_level	Number of errors that must be corrected.  The number of
+ *			parity bytes is equal to ((15 * bch_level) + 7) / 8.
+ *			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] ecc	8-byte aligned pointer to where ecc data should go
+ * @param[in] resp	pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int octeontx_bch_encode(struct bch_vf *vf, dma_addr_t block, u16 block_size,
+			u8 bch_level, dma_addr_t ecc, dma_addr_t resp)
+{
+	union bch_cmd cmd;
+	int rc;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.s.cword.ecc_gen = eg_gen;
+	cmd.s.cword.ecc_level = bch_level;
+	cmd.s.cword.size = block_size;
+
+	cmd.s.oword.ptr = ecc;
+	cmd.s.iword.ptr = block;
+	cmd.s.rword.ptr = resp;
+	rc = octeontx_cmd_queue_write(QID_BCH, 1,
+				      sizeof(cmd) / sizeof(uint64_t), cmd.u);
+	if (rc)
+		return -1;
+
+	octeontx_bch_write_doorbell(1, vf);
+
+	return 0;
+}
+
+/**
+ * Given a data block and ecc data correct the data block
+ *
+ * @param[in] block_ecc_in	8-byte aligned pointer to data block with ECC
+ *				data concatenated to the end to correct
+ * @param block_size		Size of block in bytes, must be a multiple of
+ *				two.
+ * @param bch_level		Number of errors that must be corrected.  The
+ *				number of parity bytes is equal to
+ *				((15 * bch_level) + 7) / 8.
+ *				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] block_out	8-byte aligned pointer to corrected data buffer.
+ *				This should not be the same as block_ecc_in.
+ * @param[in] resp		pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+
+int octeontx_bch_decode(struct bch_vf *vf, dma_addr_t block_ecc_in,
+			u16 block_size, u8 bch_level,
+			dma_addr_t block_out, dma_addr_t resp)
+{
+	union bch_cmd cmd;
+	int rc;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.s.cword.ecc_gen = eg_correct;
+	cmd.s.cword.ecc_level = bch_level;
+	cmd.s.cword.size = block_size;
+
+	cmd.s.oword.ptr = block_out;
+	cmd.s.iword.ptr = block_ecc_in;
+	cmd.s.rword.ptr = resp;
+	rc = octeontx_cmd_queue_write(QID_BCH, 1,
+				      sizeof(cmd) / sizeof(uint64_t), cmd.u);
+	if (rc)
+		return -1;
+
+	octeontx_bch_write_doorbell(1, vf);
+	return 0;
+}
+EXPORT_SYMBOL(octeontx_bch_decode);
+
+int octeontx_bch_wait(struct bch_vf *vf, union bch_resp *resp,
+		      dma_addr_t handle)
+{
+	ulong start = get_timer(0);
+
+	__iormb(); /* HW is updating *resp */
+	while (!resp->s.done && get_timer(start) < 10)
+		__iormb(); /* HW is updating *resp */
+
+	if (resp->s.done)
+		return 0;
+
+	return -ETIMEDOUT;
+}
+
+struct bch_q octeontx_bch_q[QID_MAX];
+
+static int octeontx_cmd_queue_initialize(struct udevice *dev, int queue_id,
+					 int max_depth, int fpa_pool,
+					 int pool_size)
+{
+	/* some params are for later merge with CPT or cn83xx */
+	struct bch_q *q = &octeontx_bch_q[queue_id];
+	unsigned long paddr;
+	union bch_cmd *qb;
+	int chunk = max_depth + 1;
+	int i, size;
+
+	if ((unsigned int)queue_id >= QID_MAX)
+		return -EINVAL;
+	if (max_depth & chunk) /* must be 2^N - 1 */
+		return -EINVAL;
+
+	size = NQS * chunk * sizeof(u64);
+	qb = dma_alloc_coherent(size, &paddr);
+	if (!qb)
+		return -ENOMEM;
+	q->base_paddr = paddr;
+	q->dev = dev;
+	q->index = 0;
+	q->max_depth = max_depth;
+	q->pool_size_m1 = pool_size;
+	q->base_vaddr = (u64 *)qb;
+
+	for (i = 0; i < NQS; i++) {
+		u64 *ixp;
+		int inext = (i + 1) * chunk - 1;
+		int j = (i + 1) % NQS;
+		int jnext = j * chunk;
+		dma_addr_t jbase = q->base_paddr + jnext * sizeof(u64);
+
+		ixp = &qb->u[inext];
+		*ixp = jbase;
+	}
+
+	return 0;
+}
+
+static int octeontx_pci_bchvf_probe(struct udevice *dev)
+{
+	struct bch_vf *vf;
+	union bch_vqx_ctl ctl;
+	union bch_vqx_cmd_buf cbuf;
+	int err;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	vf = dev_get_priv(dev);
+	if (!vf)
+		return -ENOMEM;
+
+	vf->dev = dev;
+
+	/* Map PF's configuration registers */
+	vf->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
+	debug("%s: reg base: %p\n", __func__, vf->reg_base);
+
+	err = octeontx_cmd_queue_initialize(dev, QID_BCH, QDEPTH - 1, 0,
+					    sizeof(union bch_cmd) * QDEPTH);
+	if (err) {
+		dev_err(dev, "octeontx_cmd_queue_initialize() failed\n");
+		goto release;
+	}
+
+	ctl.u = readq(vf->reg_base + BCH_VQX_CTL(0));
+
+	cbuf.u = 0;
+	cbuf.s.ldwb = 1;
+	cbuf.s.dfb = 1;
+	cbuf.s.size = QDEPTH;
+	writeq(cbuf.u, vf->reg_base + BCH_VQX_CMD_BUF(0));
+
+	writeq(ctl.u, vf->reg_base + BCH_VQX_CTL(0));
+
+	writeq(octeontx_bch_q[QID_BCH].base_paddr,
+	       vf->reg_base + BCH_VQX_CMD_PTR(0));
+
+	octeontx_bch_putv(vf);
+
+	debug("%s: bch vf initialization complete\n", __func__);
+
+	if (octeontx_bch_getv())
+		return octeontx_pci_nand_deferred_probe();
+
+	return -1;
+
+release:
+	return err;
+}
+
+static int octeontx_pci_bchpf_remove(struct udevice *dev)
+{
+	struct bch_device *bch = dev_get_priv(dev);
+
+	bch_disable(bch);
+	return 0;
+}
+
+U_BOOT_DRIVER(octeontx_pci_bchpf) = {
+	.name	= BCHPF_DRIVER_NAME,
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_pci_bchpf_probe,
+	.remove = octeontx_pci_bchpf_remove,
+	.priv_auto_alloc_size = sizeof(struct bch_device),
+	.flags = DM_FLAG_OS_PREPARE,
+};
+
+U_BOOT_DRIVER(octeontx_pci_bchvf) = {
+	.name	= BCHVF_DRIVER_NAME,
+	.id	= UCLASS_MISC,
+	.probe = octeontx_pci_bchvf_probe,
+	.priv_auto_alloc_size = sizeof(struct bch_vf),
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_bchpf, octeontx_bchpf_pci_id_table);
+U_BOOT_PCI_DEVICE(octeontx_pci_bchvf, octeontx_bchvf_pci_id_table);
diff --git a/drivers/mtd/nand/raw/octeontx_bch.h b/drivers/mtd/nand/raw/octeontx_bch.h
new file mode 100644
index 0000000000..4629b4b535
--- /dev/null
+++ b/drivers/mtd/nand/raw/octeontx_bch.h
@@ -0,0 +1,142 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_BCH_H__
+#define __OCTEONTX_BCH_H__
+
+#include "octeontx_bch_regs.h"
+
+/* Device ID */
+#define BCH_PCI_PF_DEVICE_ID		0xa043
+#define BCH_PCI_VF_DEVICE_ID		0xa044
+
+#define BCH_81XX_PCI_PF_SUBSYS_ID	0xa243
+#define BCH_81XX_PCI_VF_SUBSYS_ID	0xa244
+#define BCH_83XX_PCI_PF_SUBSYS_ID	0xa343
+#define BCH_83XX_PCI_VF_SUBSYS_ID	0xa344
+
+/* flags to indicate the features supported */
+#define BCH_FLAG_SRIOV_ENABLED		BIT(1)
+
+/*
+ * BCH Registers map for 81xx
+ */
+
+/* PF registers */
+#define BCH_CTL				0x0ull
+#define BCH_ERR_CFG			0x10ull
+#define BCH_BIST_RESULT			0x80ull
+#define BCH_ERR_INT			0x88ull
+#define BCH_ERR_INT_W1S			0x90ull
+#define BCH_ERR_INT_ENA_W1C		0xA0ull
+#define BCH_ERR_INT_ENA_W1S		0xA8ull
+
+/* VF registers */
+#define BCH_VQX_CTL(z)			0x0ull
+#define BCH_VQX_CMD_BUF(z)		0x8ull
+#define BCH_VQX_CMD_PTR(z)		0x20ull
+#define BCH_VQX_DOORBELL(z)		0x800ull
+
+#define BCHPF_DRIVER_NAME	"octeontx-bchpf"
+#define BCHVF_DRIVER_NAME	"octeontx-bchvf"
+
+struct bch_device {
+	struct list_head list;
+	u8 max_vfs;
+	u8 vfs_enabled;
+	u8 vfs_in_use;
+	u32 flags;
+	void __iomem *reg_base;
+	struct udevice *dev;
+};
+
+struct bch_vf {
+	u16 flags;
+	u8 vfid;
+	u8 node;
+	u8 priority;
+	struct udevice *dev;
+	void __iomem *reg_base;
+};
+
+struct buf_ptr {
+	u8 *vptr;
+	dma_addr_t dma_addr;
+	u16 size;
+};
+
+void *octeontx_bch_getv(void);
+void octeontx_bch_putv(void *token);
+void *octeontx_bch_getp(void);
+void octeontx_bch_putp(void *token);
+int octeontx_bch_wait(struct bch_vf *vf, union bch_resp *resp,
+		      dma_addr_t handle);
+/**
+ * Given a data block calculate the ecc data and fill in the response
+ *
+ * @param[in] block	8-byte aligned pointer to data block to calculate ECC
+ * @param block_size	Size of block in bytes, must be a multiple of two.
+ * @param bch_level	Number of errors that must be corrected.  The number of
+ *			parity bytes is equal to ((15 * bch_level) + 7) / 8.
+ *			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] ecc	8-byte aligned pointer to where ecc data should go
+ * @param[in] resp	pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int octeontx_bch_encode(struct bch_vf *vf, dma_addr_t block, u16 block_size,
+			u8 bch_level, dma_addr_t ecc, dma_addr_t resp);
+
+/**
+ * Given a data block and ecc data correct the data block
+ *
+ * @param[in] block_ecc_in	8-byte aligned pointer to data block with ECC
+ *				data concatenated to the end to correct
+ * @param block_size		Size of block in bytes, must be a multiple of
+ *				two.
+ * @param bch_level		Number of errors that must be corrected.  The
+ *				number of parity bytes is equal to
+ *				((15 * bch_level) + 7) / 8.
+ *				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] block_out	8-byte aligned pointer to corrected data buffer.
+ *				This should not be the same as block_ecc_in.
+ * @param[in] resp		pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+
+int octeontx_bch_decode(struct bch_vf *vf, dma_addr_t block_ecc_in,
+			u16 block_size, u8 bch_level,
+			dma_addr_t block_out, dma_addr_t resp);
+
+/**
+ * Ring the BCH doorbell telling it that new commands are
+ * available.
+ *
+ * @param num_commands	Number of new commands
+ * @param vf		virtual function handle
+ */
+static inline void octeontx_bch_write_doorbell(u64 num_commands,
+					       struct bch_vf *vf)
+{
+	u64 num_words = num_commands * sizeof(union bch_cmd) / sizeof(uint64_t);
+
+	writeq(num_words, vf->reg_base + BCH_VQX_DOORBELL(0));
+}
+
+/**
+ * Since it's possible (and even likely) that the NAND device will be probed
+ * before the BCH device has been probed, we may need to defer the probing.
+ *
+ * In this case, the initial probe returns success but the actual probing
+ * is deferred until the BCH VF has been probed.
+ *
+ * @return	0 for success, otherwise error
+ */
+int octeontx_pci_nand_deferred_probe(void);
+
+#endif /* __OCTEONTX_BCH_H__ */
diff --git a/drivers/mtd/nand/raw/octeontx_bch_regs.h b/drivers/mtd/nand/raw/octeontx_bch_regs.h
new file mode 100644
index 0000000000..d8f8432690
--- /dev/null
+++ b/drivers/mtd/nand/raw/octeontx_bch_regs.h
@@ -0,0 +1,169 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_BCH_REGS_H__
+#define __OCTEONTX_BCH_REGS_H__
+
+#define BCH_NR_VF	1
+
+union bch_cmd {
+	u64 u[4];
+	struct fields {
+	    struct {
+		u64 size:12;
+		u64 reserved_12_31:20;
+		u64 ecc_level:4;
+		u64 reserved_36_61:26;
+		u64 ecc_gen:2;
+	    } cword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_55:7;
+		u64 nc:1;
+		u64 fw:1;
+		u64 reserved_58_63:6;
+	    } oword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_55:7;
+		u64 nc:1;
+		u64 reserved_57_63:7;
+	    } iword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_63:15;
+	    } rword;
+	} s;
+};
+
+enum ecc_gen {
+	eg_correct,
+	eg_copy,
+	eg_gen,
+	eg_copy3,
+};
+
+/** Response from BCH instruction */
+union bch_resp {
+	u16  u16;
+	struct {
+		u16	num_errors:7;	/** Number of errors in block */
+		u16	zero:6;		/** Always zero, ignore */
+		u16	erased:1;	/** Block is erased */
+		u16	uncorrectable:1;/** too many bits flipped */
+		u16	done:1;		/** Block is done */
+	} s;
+};
+
+union bch_vqx_ctl {
+	u64 u;
+	struct {
+		u64 reserved_0:1;
+		u64 cmd_be:1;
+		u64 max_read:4;
+		u64 reserved_6_15:10;
+		u64 erase_disable:1;
+		u64 one_cmd:1;
+		u64 early_term:4;
+		u64 reserved_22_63:42;
+	} s;
+};
+
+union bch_vqx_cmd_buf {
+	u64 u;
+	struct {
+		u64 reserved_0_32:33;
+		u64 size:13;
+		u64 dfb:1;
+		u64 ldwb:1;
+		u64 reserved_48_63:16;
+	} s;
+};
+
+/* keep queue state indexed, even though just one supported here,
+ * for later generalization to similarly-shaped queues on other Cavium devices
+ */
+enum {
+	QID_BCH,
+	QID_MAX
+};
+
+struct bch_q {
+	struct udevice *dev;
+	int index;
+	u16 max_depth;
+	u16 pool_size_m1;
+	u64 *base_vaddr;
+	dma_addr_t base_paddr;
+};
+
+extern struct bch_q octeontx_bch_q[QID_MAX];
+
+/* with one dma-mapped area, virt<->phys conversions by +/- (vaddr-paddr) */
+static inline dma_addr_t qphys(int qid, void *v)
+{
+	struct bch_q *q = &octeontx_bch_q[qid];
+	int off = (u8 *)v - (u8 *)q->base_vaddr;
+
+	return q->base_paddr + off;
+}
+
+#define octeontx_ptr_to_phys(v) qphys(QID_BCH, (v))
+
+static inline void *qvirt(int qid, dma_addr_t p)
+{
+	struct bch_q *q = &octeontx_bch_q[qid];
+	int off = p - q->base_paddr;
+
+	return q->base_vaddr + off;
+}
+
+#define octeontx_phys_to_ptr(p) qvirt(QID_BCH, (p))
+
+/* plenty for interleaved r/w on two planes with 16k page, ecc_size 1k */
+/* QDEPTH >= 16, as successive chunks must align on 128-byte boundaries */
+#define QDEPTH	256	/* u64s in a command queue chunk, incl next-pointer */
+#define NQS	1	/* linked chunks in the chain */
+
+/**
+ * Write an arbitrary number of command words to a command queue.
+ * This is a generic function; the fixed number of command word
+ * functions yield higher performance.
+ *
+ * Could merge with crypto version for FPA use on cn83xx
+ */
+static inline int octeontx_cmd_queue_write(int queue_id, bool use_locking,
+					   int cmd_count, const u64 *cmds)
+{
+	int ret = 0;
+	u64 *cmd_ptr;
+	struct bch_q *qptr = &octeontx_bch_q[queue_id];
+
+	if (unlikely(cmd_count < 1 || cmd_count > 32))
+		return -EINVAL;
+	if (unlikely(!cmds))
+		return -EINVAL;
+
+	cmd_ptr = qptr->base_vaddr;
+
+	while (cmd_count > 0) {
+		int slot = qptr->index % (QDEPTH * NQS);
+
+		if (slot % QDEPTH != QDEPTH - 1) {
+			cmd_ptr[slot] = *cmds++;
+			cmd_count--;
+		}
+
+		qptr->index++;
+	}
+
+	__iowmb();	/* flush commands before ringing bell */
+
+	return ret;
+}
+
+#endif /* __OCTEONTX_BCH_REGS_H__ */
diff --git a/drivers/mtd/nand/raw/octeontx_nand.c b/drivers/mtd/nand/raw/octeontx_nand.c
new file mode 100644
index 0000000000..5819322b6d
--- /dev/null
+++ b/drivers/mtd/nand/raw/octeontx_nand.c
@@ -0,0 +1,2256 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <pci.h>
+#include <nand.h>
+#include <dm.h>
+#include <dm/of_access.h>
+#include <dm/device-internal.h>
+#include <linux/bitfield.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/libfdt.h>
+#include <linux/mtd/nand_bch.h>
+#include <linux/mtd/nand_ecc.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/dma-mapping.h>
+#include <asm/arch/clock.h>
+#include "octeontx_bch.h"
+
+#ifdef DEBUG
+# undef CONFIG_LOGLEVEL
+# define CONFIG_LOGLEVEL 8
+#endif
+
+/*
+ * The NDF_CMD queue takes commands between 16 - 128 bit.
+ * All commands must be 16 bit aligned and are little endian.
+ * WAIT_STATUS commands must be 64 bit aligned.
+ * Commands are selected by the 4 bit opcode.
+ *
+ * Available Commands:
+ *
+ * 16 Bit:
+ *   NOP
+ *   WAIT
+ *   BUS_ACQ, BUS_REL
+ *   CHIP_EN, CHIP_DIS
+ *
+ * 32 Bit:
+ *   CLE_CMD
+ *   RD_CMD, RD_EDO_CMD
+ *   WR_CMD
+ *
+ * 64 Bit:
+ *   SET_TM_PAR
+ *
+ * 96 Bit:
+ *   ALE_CMD
+ *
+ * 128 Bit:
+ *   WAIT_STATUS, WAIT_STATUS_ALE
+ */
+
+/* NDF Register offsets */
+#define NDF_CMD			0x0
+#define NDF_MISC		0x8
+#define NDF_ECC_CNT		0x10
+#define NDF_DRBELL		0x30
+#define NDF_ST_REG		0x38	/* status */
+#define NDF_INT			0x40
+#define NDF_INT_W1S		0x48
+#define NDF_DMA_CFG		0x50
+#define NDF_DMA_ADR		0x58
+#define NDF_INT_ENA_W1C		0x60
+#define NDF_INT_ENA_W1S		0x68
+
+/* NDF command opcodes */
+#define NDF_OP_NOP		0x0
+#define NDF_OP_SET_TM_PAR	0x1
+#define NDF_OP_WAIT		0x2
+#define NDF_OP_CHIP_EN_DIS	0x3
+#define NDF_OP_CLE_CMD		0x4
+#define NDF_OP_ALE_CMD		0x5
+#define NDF_OP_WR_CMD		0x8
+#define NDF_OP_RD_CMD		0x9
+#define NDF_OP_RD_EDO_CMD	0xa
+#define NDF_OP_WAIT_STATUS	0xb	/* same opcode for WAIT_STATUS_ALE */
+#define NDF_OP_BUS_ACQ_REL	0xf
+
+#define NDF_BUS_ACQUIRE		1
+#define NDF_BUS_RELEASE		0
+
+#define DBGX_EDSCR(X)		(0x87A008000088 + (X) * 0x80000)
+
+struct ndf_nop_cmd {
+	u16 opcode:	4;
+	u16 nop:	12;
+};
+
+struct ndf_wait_cmd {
+	u16 opcode:4;
+	u16 r_b:1;		/* wait for one cycle or PBUS_WAIT deassert */
+	u16:3;
+	u16 wlen:3;		/* timing parameter select */
+	u16:5;
+};
+
+struct ndf_bus_cmd {
+	u16 opcode:4;
+	u16 direction:4;	/* 1 = acquire, 0 = release */
+	u16:8;
+};
+
+struct ndf_chip_cmd {
+	u16 opcode:4;
+	u16 chip:3;		/* select chip, 0 = disable */
+	u16 enable:1;		/* 1 = enable, 0 = disable */
+	u16 bus_width:2;	/* 10 = 16 bit, 01 = 8 bit */
+	u16:6;
+};
+
+struct ndf_cle_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 cmd_data:8;		/* command sent to the PBUS AD pins */
+	u32 clen1:3;		/* time between PBUS CLE and WE asserts */
+	u32 clen2:3;		/* time WE remains asserted */
+	u32 clen3:3;		/* time between WE deassert and CLE */
+	u32:7;
+};
+
+/* RD_EDO_CMD uses the same layout as RD_CMD */
+struct ndf_rd_cmd {
+	u32 opcode:4;
+	u32 data:16;		/* data bytes */
+	u32 rlen1:3;
+	u32 rlen2:3;
+	u32 rlen3:3;
+	u32 rlen4:3;
+};
+
+struct ndf_wr_cmd {
+	u32 opcode:4;
+	u32 data:16;		/* data bytes */
+	u32:4;
+	u32 wlen1:3;
+	u32 wlen2:3;
+	u32:3;
+};
+
+struct ndf_set_tm_par_cmd {
+	u64 opcode:4;
+	u64 tim_mult:4;	/* multiplier for the seven parameters */
+	u64 tm_par1:8;	/* --> Following are the 7 timing parameters that */
+	u64 tm_par2:8;	/*     specify the number of coprocessor cycles.  */
+	u64 tm_par3:8;	/*     A value of zero means one cycle.		  */
+	u64 tm_par4:8;	/*     All values are scaled by tim_mult	  */
+	u64 tm_par5:8;	/*     using tim_par * (2 ^ tim_mult).		  */
+	u64 tm_par6:8;
+	u64 tm_par7:8;
+};
+
+struct ndf_ale_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 adr_byte_num:4;	/* number of address bytes to be sent */
+	u32:4;
+	u32 alen1:3;
+	u32 alen2:3;
+	u32 alen3:3;
+	u32 alen4:3;
+	u32:4;
+	u8 adr_byt1;
+	u8 adr_byt2;
+	u8 adr_byt3;
+	u8 adr_byt4;
+	u8 adr_byt5;
+	u8 adr_byt6;
+	u8 adr_byt7;
+	u8 adr_byt8;
+};
+
+struct ndf_wait_status_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 data:8;		/** data */
+	u32 clen1:3;
+	u32 clen2:3;
+	u32 clen3:3;
+	u32:8;
+	/** set to 5 to select WAIT_STATUS_ALE command */
+	u32 ale_ind:8;
+	/** ALE only: number of address bytes to be sent */
+	u32 adr_byte_num:4;
+	u32:4;
+	u32 alen1:3;	/* ALE only */
+	u32 alen2:3;	/* ALE only */
+	u32 alen3:3;	/* ALE only */
+	u32 alen4:3;	/* ALE only */
+	u32:4;
+	u8 adr_byt[4];		/* ALE only */
+	u32 nine:4;	/* set to 9 */
+	u32 and_mask:8;
+	u32 comp_byte:8;
+	u32 rlen1:3;
+	u32 rlen2:3;
+	u32 rlen3:3;
+	u32 rlen4:3;
+};
+
+union ndf_cmd {
+	u64 val[2];
+	union {
+		struct ndf_nop_cmd		nop;
+		struct ndf_wait_cmd		wait;
+		struct ndf_bus_cmd		bus_acq_rel;
+		struct ndf_chip_cmd		chip_en_dis;
+		struct ndf_cle_cmd		cle_cmd;
+		struct ndf_rd_cmd		rd_cmd;
+		struct ndf_wr_cmd		wr_cmd;
+		struct ndf_set_tm_par_cmd	set_tm_par;
+		struct ndf_ale_cmd		ale_cmd;
+		struct ndf_wait_status_cmd	wait_status;
+	} u;
+};
+
+/** Disable multi-bit error hangs */
+#define NDF_MISC_MB_DIS		BIT_ULL(27)
+/** High watermark for NBR FIFO or load/store operations */
+#define NDF_MISC_NBR_HWM	GENMASK_ULL(26, 24)
+/** Wait input filter count */
+#define NDF_MISC_WAIT_CNT	GENMASK_ULL(23, 18)
+/** Unfilled NFD_CMD queue bytes */
+#define NDF_MISC_FR_BYTE	GENMASK_ULL(17, 7)
+/** Set by HW when it reads the last 8 bytes of NDF_CMD */
+#define NDF_MISC_RD_DONE	BIT_ULL(6)
+/** Set by HW when it reads. SW read of NDF_CMD clears it */
+#define NDF_MISC_RD_VAL		BIT_ULL(5)
+/** Let HW read NDF_CMD queue. Cleared on SW NDF_CMD write */
+#define NDF_MISC_RD_CMD		BIT_ULL(4)
+/** Boot disable */
+#define NDF_MISC_BT_DIS		BIT_ULL(2)
+/** Stop command execution after completing command queue */
+#define NDF_MISC_EX_DIS		BIT_ULL(1)
+/** Reset fifo */
+#define NDF_MISC_RST_FF		BIT_ULL(0)
+
+/** DMA engine enable */
+#define NDF_DMA_CFG_EN		BIT_ULL(63)
+/** Read or write */
+#define NDF_DMA_CFG_RW		BIT_ULL(62)
+/** Terminates DMA and clears enable bit */
+#define NDF_DMA_CFG_CLR		BIT_ULL(61)
+/** 32-bit swap enable */
+#define NDF_DMA_CFG_SWAP32	BIT_ULL(59)
+/** 16-bit swap enable */
+#define NDF_DMA_CFG_SWAP16	BIT_ULL(58)
+/** 8-bit swap enable */
+#define NDF_DMA_CFG_SWAP8	BIT_ULL(57)
+/** Endian mode */
+#define NDF_DMA_CFG_CMD_BE	BIT_ULL(56)
+/** Number of 64 bit transfers */
+#define NDF_DMA_CFG_SIZE	GENMASK_ULL(55, 36)
+
+/** Command execution status idle */
+#define NDF_ST_REG_EXE_IDLE	BIT_ULL(15)
+/** Command execution SM states */
+#define NDF_ST_REG_EXE_SM	GENMASK_ULL(14, 11)
+/** DMA and load SM states */
+#define NDF_ST_REG_BT_SM	GENMASK_ULL(10, 7)
+/** Queue read-back SM bad state */
+#define NDF_ST_REG_RD_FF_BAD	BIT_ULL(6)
+/** Queue read-back SM states */
+#define NDF_ST_REG_RD_FF	GENMASK_ULL(5, 4)
+/** Main SM is in a bad state */
+#define NDF_ST_REG_MAIN_BAD	BIT_ULL(3)
+/** Main SM states */
+#define NDF_ST_REG_MAIN_SM	GENMASK_ULL(2, 0)
+
+#define MAX_NAND_NAME_LEN	64
+#if (defined(NAND_MAX_PAGESIZE) && (NAND_MAX_PAGESIZE > 4096)) ||	\
+	!defined(NAND_MAX_PAGESIZE)
+# undef NAND_MAX_PAGESIZE
+# define NAND_MAX_PAGESIZE	4096
+#endif
+#if (defined(NAND_MAX_OOBSIZE) && (NAND_MAX_OOBSIZE > 256)) ||		\
+	!defined(NAND_MAX_OOBSIZE)
+# undef NAND_MAX_OOBSIZE
+# define NAND_MAX_OOBSIZE	256
+#endif
+
+#define OCTEONTX_NAND_DRIVER_NAME	"octeontx_nand"
+
+#define NDF_TIMEOUT		1000	/** Timeout in ms */
+#define USEC_PER_SEC		1000000	/** Linux compatibility */
+#ifndef NAND_MAX_CHIPS
+# define NAND_MAX_CHIPS		8	/** Linux compatibility */
+#endif
+
+struct octeontx_nand_chip {
+	struct list_head node;
+	struct nand_chip nand;
+	struct ndf_set_tm_par_cmd timings;
+	int cs;
+	int selected_page;
+	int iface_mode;
+	int row_bytes;
+	int col_bytes;
+	bool oob_only;
+	bool iface_set;
+};
+
+struct octeontx_nand_buf {
+	u8 *dmabuf;
+	dma_addr_t dmaaddr;
+	int dmabuflen;
+	int data_len;
+	int data_index;
+};
+
+/** NAND flash controller (NDF) related information */
+struct octeontx_nfc {
+	struct nand_hw_control controller;
+	struct udevice *dev;
+	void __iomem *base;
+	struct list_head chips;
+	int selected_chip;      /* Currently selected NAND chip number */
+
+	/*
+	 * Status is separate from octeontx_nand_buf because
+	 * it can be used in parallel and during init.
+	 */
+	u8 *stat;
+	dma_addr_t stat_addr;
+	bool use_status;
+
+	struct octeontx_nand_buf buf;
+	union bch_resp *bch_resp;
+	dma_addr_t bch_rhandle;
+
+	/* BCH of all-0xff, so erased pages read as error-free */
+	unsigned char *eccmask;
+};
+
+/* settable timings - 0..7 select timing of alen1..4/clen1..3/etc */
+enum tm_idx {
+	t0, /* fixed at 4<<mult cycles */
+	t1, t2, t3, t4, t5, t6, t7, /* settable per ONFI-timing mode */
+};
+
+#ifdef CONFIG_NAND_OCTEONTX_HW_ECC
+struct octeontx_probe_device {
+	struct list_head list;
+	struct udevice *dev;
+};
+
+static struct bch_vf *bch_vf;
+/** Deferred devices due to BCH not being ready */
+LIST_HEAD(octeontx_pci_nand_deferred_devices);
+#endif
+
+/** default parameters used for probing chips */
+#define MAX_ONFI_MODE	5
+
+static int default_onfi_timing;
+static int slew_ns = 2; /* default timing padding */
+static int def_ecc_size = 512; /* 1024 best for sw_bch, <= 4095 for hw_bch */
+static int default_width = 1; /* 8 bit */
+static int default_page_size = 2048;
+static struct ndf_set_tm_par_cmd default_timing_parms;
+
+/** Port from Linux */
+#define readq_poll_timeout(addr, val, cond, delay_us, timeout_us)	\
+({									\
+	ulong __start = get_timer(0);					\
+	void *__addr = (addr);						\
+	const ulong __timeout_ms = timeout_us / 1000;			\
+	do {								\
+		(val) = readq(__addr);					\
+		if (cond)						\
+			break;						\
+		if (timeout_us && get_timer(__start) > __timeout_ms) {	\
+			(val) = readq(__addr);				\
+			break;						\
+		}							\
+		if (delay_us)						\
+			udelay(delay_us);				\
+	} while (1);							\
+	(cond) ? 0 : -ETIMEDOUT;					\
+})
+
+/** Ported from Linux 4.9.0 include/linux/of.h for compatibility */
+static inline int of_get_child_count(const ofnode node)
+{
+	return fdtdec_get_child_count(gd->fdt_blob, ofnode_to_offset(node));
+}
+
+/**
+ * Linux compatibility from Linux 4.9.0 drivers/mtd/nand/nand_base.c
+ */
+static int nand_ooblayout_ecc_lp(struct mtd_info *mtd, int section,
+				 struct mtd_oob_region *oobregion)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_ecc_ctrl *ecc = &chip->ecc;
+
+	if (section || !ecc->total)
+		return -ERANGE;
+
+	oobregion->length = ecc->total;
+	oobregion->offset = mtd->oobsize - oobregion->length;
+
+	return 0;
+}
+
+/**
+ * Linux compatibility from Linux 4.9.0 drivers/mtd/nand/nand_base.c
+ */
+static int nand_ooblayout_free_lp(struct mtd_info *mtd, int section,
+				  struct mtd_oob_region *oobregion)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_ecc_ctrl *ecc = &chip->ecc;
+
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = mtd->oobsize - ecc->total - 2;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops nand_ooblayout_lp_ops = {
+	.ecc = nand_ooblayout_ecc_lp,
+	.free = nand_ooblayout_free_lp,
+};
+
+static inline struct octeontx_nand_chip *to_otx_nand(struct nand_chip *nand)
+{
+	return container_of(nand, struct octeontx_nand_chip, nand);
+}
+
+static inline struct octeontx_nfc *to_otx_nfc(struct nand_hw_control *ctrl)
+{
+	return container_of(ctrl, struct octeontx_nfc, controller);
+}
+
+#if defined(CONFIG_NAND_OCTEONTX_HW_ECC)
+static int octeontx_nand_calc_ecc_layout(struct nand_chip *nand)
+{
+	struct nand_ecclayout *layout = nand->ecc.layout;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	struct mtd_info *mtd = &nand->mtd;
+	int oobsize = mtd->oobsize;
+	int i;
+	bool layout_alloc = false;
+
+	if (!layout) {
+		layout = devm_kzalloc(tn->dev, sizeof(*layout), GFP_KERNEL);
+		if (!layout)
+			return -ENOMEM;
+		nand->ecc.layout = layout;
+		layout_alloc = true;
+	}
+	layout->eccbytes = nand->ecc.steps * nand->ecc.bytes;
+	/* Reserve 2 bytes for bad block marker */
+	if (layout->eccbytes + 2 > oobsize) {
+		pr_err("No suitable oob scheme available for oobsize %d eccbytes %u\n",
+		       oobsize, layout->eccbytes);
+		goto fail;
+	}
+	/* put ecc bytes at oob tail */
+	for (i = 0; i < layout->eccbytes; i++)
+		layout->eccpos[i] = oobsize - layout->eccbytes + i;
+	layout->oobfree[0].offset = 2;
+	layout->oobfree[0].length = oobsize - 2 - layout->eccbytes;
+	nand->ecc.layout = layout;
+	return 0;
+
+fail:
+	if (layout_alloc)
+		kfree(layout);
+	return -1;
+}
+#endif
+
+/*
+ * Read a single byte from the temporary buffer. Used after READID
+ * to get the NAND information and for STATUS.
+ */
+static u8 octeontx_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	if (tn->use_status) {
+		tn->use_status = false;
+		return *tn->stat;
+	}
+
+	if (tn->buf.data_index < tn->buf.data_len)
+		return tn->buf.dmabuf[tn->buf.data_index++];
+
+	dev_err(tn->dev, "No data to read, idx: 0x%x, len: 0x%x\n",
+		tn->buf.data_index, tn->buf.data_len);
+
+	return 0xff;
+}
+
+/*
+ * Read a number of pending bytes from the temporary buffer. Used
+ * to get page and OOB data.
+ */
+static void octeontx_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	if (len > tn->buf.data_len - tn->buf.data_index) {
+		dev_err(tn->dev, "Not enough data for read of %d bytes\n", len);
+		return;
+	}
+
+	memcpy(buf, tn->buf.dmabuf + tn->buf.data_index, len);
+	tn->buf.data_index += len;
+}
+
+static void octeontx_nand_write_buf(struct mtd_info *mtd,
+				    const u8 *buf, int len)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	memcpy(tn->buf.dmabuf + tn->buf.data_len, buf, len);
+	tn->buf.data_len += len;
+}
+
+/* Overwrite default function to avoid sync abort on chip = -1. */
+static void octeontx_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+}
+
+static inline int timing_to_cycle(u32 psec, unsigned long clock)
+{
+	unsigned int ns;
+	int ticks;
+
+	ns = DIV_ROUND_UP(psec, 1000);
+	ns += slew_ns;
+
+	/* no rounding needed since clock is multiple of 1MHz */
+	clock /= 1000000;
+	ns *= clock;
+
+	ticks = DIV_ROUND_UP(ns, 1000);
+
+	/* actual delay is (tm_parX+1)<<tim_mult */
+	if (ticks)
+		ticks--;
+
+	return ticks;
+}
+
+static void set_timings(struct octeontx_nand_chip *chip,
+			struct ndf_set_tm_par_cmd *tp,
+			const struct nand_sdr_timings *timings,
+			unsigned long sclk)
+{
+	/* scaled coprocessor-cycle values */
+	u32 sWH, sCLS, sCLH, sRP, sWB, sWC;
+
+	tp->tim_mult = 0;
+	sWH = timing_to_cycle(timings->tWH_min, sclk);
+	sCLS = timing_to_cycle(timings->tCLS_min, sclk);
+	sCLH = timing_to_cycle(timings->tCLH_min, sclk);
+	sRP = timing_to_cycle(timings->tRP_min, sclk);
+	sWB = timing_to_cycle(timings->tWB_max, sclk);
+	sWC = timing_to_cycle(timings->tWC_min, sclk);
+
+	tp->tm_par1 = sWH;
+	tp->tm_par2 = sCLH;
+	tp->tm_par3 = sRP + 1;
+	tp->tm_par4 = sCLS - sWH;
+	tp->tm_par5 = sWC - sWH + 1;
+	tp->tm_par6 = sWB;
+	tp->tm_par7 = 0;
+	tp->tim_mult++; /* overcompensate for bad math */
+
+	/* TODO: comment parameter re-use */
+
+	pr_debug("%s: tim_par: mult: %d  p1: %d  p2: %d  p3: %d\n",
+		 __func__, tp->tim_mult, tp->tm_par1, tp->tm_par2, tp->tm_par3);
+	pr_debug("                 p4: %d  p5: %d  p6: %d  p7: %d\n",
+		 tp->tm_par4, tp->tm_par5, tp->tm_par6, tp->tm_par7);
+}
+
+static int set_default_timings(struct octeontx_nfc *tn,
+			       const struct nand_sdr_timings *timings)
+{
+	unsigned long sclk = octeontx_get_io_clock();
+
+	set_timings(NULL, &default_timing_parms, timings, sclk);
+	return 0;
+}
+
+static int octeontx_nfc_chip_set_timings(struct octeontx_nand_chip *chip,
+					 const struct nand_sdr_timings *timings)
+{
+	/*struct octeontx_nfc *tn = to_otx_nfc(chip->nand.controller);*/
+	unsigned long sclk = octeontx_get_io_clock();
+
+	set_timings(chip, &chip->timings, timings, sclk);
+	return 0;
+}
+
+/* How many bytes are free in the NFD_CMD queue? */
+static int ndf_cmd_queue_free(struct octeontx_nfc *tn)
+{
+	u64 ndf_misc;
+
+	ndf_misc = readq(tn->base + NDF_MISC);
+	return FIELD_GET(NDF_MISC_FR_BYTE, ndf_misc);
+}
+
+/* Submit a command to the NAND command queue. */
+static int ndf_submit(struct octeontx_nfc *tn, union ndf_cmd *cmd)
+{
+	int opcode = cmd->val[0] & 0xf;
+
+	switch (opcode) {
+	/* All these commands fit in one 64bit word */
+	case NDF_OP_NOP:
+	case NDF_OP_SET_TM_PAR:
+	case NDF_OP_WAIT:
+	case NDF_OP_CHIP_EN_DIS:
+	case NDF_OP_CLE_CMD:
+	case NDF_OP_WR_CMD:
+	case NDF_OP_RD_CMD:
+	case NDF_OP_RD_EDO_CMD:
+	case NDF_OP_BUS_ACQ_REL:
+		if (ndf_cmd_queue_free(tn) < 8)
+			goto full;
+		writeq(cmd->val[0], tn->base + NDF_CMD);
+		break;
+	case NDF_OP_ALE_CMD:
+		/* ALE commands take either one or two 64bit words */
+		if (cmd->u.ale_cmd.adr_byte_num < 5) {
+			if (ndf_cmd_queue_free(tn) < 8)
+				goto full;
+			writeq(cmd->val[0], tn->base + NDF_CMD);
+		} else {
+			if (ndf_cmd_queue_free(tn) < 16)
+				goto full;
+			writeq(cmd->val[0], tn->base + NDF_CMD);
+			writeq(cmd->val[1], tn->base + NDF_CMD);
+		}
+		break;
+	case NDF_OP_WAIT_STATUS: /* Wait status commands take two 64bit words */
+		if (ndf_cmd_queue_free(tn) < 16)
+			goto full;
+		writeq(cmd->val[0], tn->base + NDF_CMD);
+		writeq(cmd->val[1], tn->base + NDF_CMD);
+		break;
+	default:
+		dev_err(tn->dev, "%s: unknown command: %u\n", __func__, opcode);
+		return -EINVAL;
+	}
+	return 0;
+
+full:
+	dev_err(tn->dev, "%s: no space left in command queue\n", __func__);
+	return -ENOMEM;
+}
+
+/**
+ * Wait for the ready/busy signal. First wait for busy to be valid,
+ * then wait for busy to de-assert.
+ */
+static int ndf_build_wait_busy(struct octeontx_nfc *tn)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wait.opcode = NDF_OP_WAIT;
+	cmd.u.wait.r_b = 1;
+	cmd.u.wait.wlen = t6;
+
+	if (ndf_submit(tn, &cmd))
+		return -ENOMEM;
+	return 0;
+}
+
+static bool ndf_dma_done(struct octeontx_nfc *tn)
+{
+	u64 dma_cfg;
+
+	/* Enable bit should be clear after a transfer */
+	dma_cfg = readq(tn->base + NDF_DMA_CFG);
+	if (!(dma_cfg & NDF_DMA_CFG_EN))
+		return true;
+
+	return false;
+}
+
+static int ndf_wait(struct octeontx_nfc *tn)
+{
+	ulong start = get_timer(0);
+	bool done;
+
+	while (!(done = ndf_dma_done(tn)) && get_timer(start) < NDF_TIMEOUT)
+		;
+
+	if (!done) {
+		dev_err(tn->dev, "%s: timeout error\n", __func__);
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+static int ndf_wait_idle(struct octeontx_nfc *tn)
+{
+	u64 val;
+	u64 dval = 0;
+	int rc;
+	int pause = 100;
+	u64 tot_us = USEC_PER_SEC / 10;
+
+	rc = readq_poll_timeout(tn->base + NDF_ST_REG,
+				val, val & NDF_ST_REG_EXE_IDLE, pause, tot_us);
+	if (!rc)
+		rc = readq_poll_timeout(tn->base + NDF_DMA_CFG,
+					dval, !(dval & NDF_DMA_CFG_EN),
+					pause, tot_us);
+
+	return rc;
+}
+
+/** Issue set timing parameters */
+static int ndf_queue_cmd_timing(struct octeontx_nfc *tn,
+				struct ndf_set_tm_par_cmd *timings)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.set_tm_par.opcode = NDF_OP_SET_TM_PAR;
+	cmd.u.set_tm_par.tim_mult = timings->tim_mult;
+	cmd.u.set_tm_par.tm_par1 = timings->tm_par1;
+	cmd.u.set_tm_par.tm_par2 = timings->tm_par2;
+	cmd.u.set_tm_par.tm_par3 = timings->tm_par3;
+	cmd.u.set_tm_par.tm_par4 = timings->tm_par4;
+	cmd.u.set_tm_par.tm_par5 = timings->tm_par5;
+	cmd.u.set_tm_par.tm_par6 = timings->tm_par6;
+	cmd.u.set_tm_par.tm_par7 = timings->tm_par7;
+	return ndf_submit(tn, &cmd);
+}
+
+/** Issue bus acquire or release */
+static int ndf_queue_cmd_bus(struct octeontx_nfc *tn, int direction)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.bus_acq_rel.opcode = NDF_OP_BUS_ACQ_REL;
+	cmd.u.bus_acq_rel.direction = direction;
+	return ndf_submit(tn, &cmd);
+}
+
+/* Issue chip select or deselect */
+static int ndf_queue_cmd_chip(struct octeontx_nfc *tn, int enable, int chip,
+			      int width)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.chip_en_dis.opcode = NDF_OP_CHIP_EN_DIS;
+	cmd.u.chip_en_dis.chip = chip;
+	cmd.u.chip_en_dis.enable = enable;
+	cmd.u.chip_en_dis.bus_width = width;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_wait(struct octeontx_nfc *tn, int t_delay)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wait.opcode = NDF_OP_WAIT;
+	cmd.u.wait.wlen = t_delay;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_cle(struct octeontx_nfc *tn, int command)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.cle_cmd.opcode = NDF_OP_CLE_CMD;
+	cmd.u.cle_cmd.cmd_data = command;
+	cmd.u.cle_cmd.clen1 = t4;
+	cmd.u.cle_cmd.clen2 = t1;
+	cmd.u.cle_cmd.clen3 = t2;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_ale(struct octeontx_nfc *tn, int addr_bytes,
+			     struct nand_chip *nand, u64 page,
+			     u32 col, int page_size)
+{
+	struct octeontx_nand_chip *octeontx_nand = (nand) ?
+						to_otx_nand(nand) : NULL;
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.ale_cmd.opcode = NDF_OP_ALE_CMD;
+	cmd.u.ale_cmd.adr_byte_num = addr_bytes;
+
+	/* set column bit for OOB area, assume OOB follows page */
+	if (octeontx_nand && octeontx_nand->oob_only)
+		col += page_size;
+
+	/* page is u64 for this generality, even if cmdfunc() passes int */
+	switch (addr_bytes) {
+	/* 4-8 bytes: page, then 2-byte col */
+	case 8:
+		cmd.u.ale_cmd.adr_byt8 = (page >> 40) & 0xff;
+		/* fall thru */
+	case 7:
+		cmd.u.ale_cmd.adr_byt7 = (page >> 32) & 0xff;
+		/* fall thru */
+	case 6:
+		cmd.u.ale_cmd.adr_byt6 = (page >> 24) & 0xff;
+		/* fall thru */
+	case 5:
+		cmd.u.ale_cmd.adr_byt5 = (page >> 16) & 0xff;
+		/* fall thru */
+	case 4:
+		cmd.u.ale_cmd.adr_byt4 = (page >> 8) & 0xff;
+		cmd.u.ale_cmd.adr_byt3 = page & 0xff;
+		cmd.u.ale_cmd.adr_byt2 = (col >> 8) & 0xff;
+		cmd.u.ale_cmd.adr_byt1 =  col & 0xff;
+		break;
+	/* 1-3 bytes: just the page address */
+	case 3:
+		cmd.u.ale_cmd.adr_byt3 = (page >> 16) & 0xff;
+		/* fall thru */
+	case 2:
+		cmd.u.ale_cmd.adr_byt2 = (page >> 8) & 0xff;
+		/* fall thru */
+	case 1:
+		cmd.u.ale_cmd.adr_byt1 = page & 0xff;
+		break;
+	default:
+		break;
+	}
+
+	cmd.u.ale_cmd.alen1 = t3;
+	cmd.u.ale_cmd.alen2 = t1;
+	cmd.u.ale_cmd.alen3 = t5;
+	cmd.u.ale_cmd.alen4 = t2;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_write(struct octeontx_nfc *tn, int len)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wr_cmd.opcode = NDF_OP_WR_CMD;
+	cmd.u.wr_cmd.data = len;
+	cmd.u.wr_cmd.wlen1 = t3;
+	cmd.u.wr_cmd.wlen2 = t1;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_build_pre_cmd(struct octeontx_nfc *tn, int cmd1,
+			     int addr_bytes, u64 page, u32 col, int cmd2)
+{
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *octeontx_nand;
+	struct ndf_set_tm_par_cmd *timings;
+	int width, page_size, rc;
+
+	/* Also called before chip probing is finished */
+	if (!nand) {
+		timings = &default_timing_parms;
+		page_size = default_page_size;
+		width = default_width;
+	} else {
+		octeontx_nand = to_otx_nand(nand);
+		timings = &octeontx_nand->timings;
+		page_size = nand->mtd.writesize;
+		if (nand->options & NAND_BUSWIDTH_16)
+			width = 2;
+		else
+			width = 1;
+	}
+	rc = ndf_queue_cmd_timing(tn, timings);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_bus(tn, NDF_BUS_ACQUIRE);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_chip(tn, 1, tn->selected_chip, width);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, t1);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_cle(tn, cmd1);
+	if (rc)
+		return rc;
+
+	if (addr_bytes) {
+		rc = ndf_build_wait_busy(tn);
+		if (rc)
+			return rc;
+
+		rc = ndf_queue_cmd_ale(tn, addr_bytes, nand,
+				       page, col, page_size);
+		if (rc)
+			return rc;
+	}
+
+	/* CLE 2 */
+	if (cmd2) {
+		rc = ndf_build_wait_busy(tn);
+		if (rc)
+			return rc;
+
+		rc = ndf_queue_cmd_cle(tn, cmd2);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static int ndf_build_post_cmd(struct octeontx_nfc *tn, int hold_time)
+{
+	int rc;
+
+	/* Deselect chip */
+	rc = ndf_queue_cmd_chip(tn, 0, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Release bus */
+	rc = ndf_queue_cmd_bus(tn, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, hold_time);
+	if (rc)
+		return rc;
+
+	/*
+	 * Last action is ringing the doorbell with number of bus
+	 * acquire-releases cycles (currently 1).
+	 */
+	writeq(1, tn->base + NDF_DRBELL);
+	return 0;
+}
+
+/* Setup the NAND DMA engine for a transfer. */
+static void ndf_setup_dma(struct octeontx_nfc *tn, int is_write,
+			  dma_addr_t bus_addr, int len)
+{
+	u64 dma_cfg;
+
+	dma_cfg = FIELD_PREP(NDF_DMA_CFG_RW, is_write) |
+		  FIELD_PREP(NDF_DMA_CFG_SIZE, (len >> 3) - 1);
+	dma_cfg |= NDF_DMA_CFG_EN;
+	writeq(bus_addr, tn->base + NDF_DMA_ADR);
+	writeq(dma_cfg, tn->base + NDF_DMA_CFG);
+}
+
+static int octeontx_nand_reset(struct octeontx_nfc *tn)
+{
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_RESET, 0, 0, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int ndf_read(struct octeontx_nfc *tn, int cmd1, int addr_bytes,
+		    u64 page, u32 col, int cmd2, int len)
+{
+	dma_addr_t bus_addr = tn->use_status ? tn->stat_addr : tn->buf.dmaaddr;
+	struct nand_chip *nand = tn->controller.active;
+	int timing_mode, bytes, rc;
+	union ndf_cmd cmd;
+	u64 start, end;
+
+	pr_debug("%s(%p, 0x%x, 0x%x, 0x%llx, 0x%x, 0x%x, 0x%x)\n", __func__,
+		 tn, cmd1, addr_bytes, page, col, cmd2, len);
+	if (!nand)
+		timing_mode = default_onfi_timing;
+	else
+		timing_mode = nand->onfi_timing_mode_default;
+
+	/* Build the command and address cycles */
+	rc = ndf_build_pre_cmd(tn, cmd1, addr_bytes, page, col, cmd2);
+	if (rc) {
+		dev_err(tn->dev, "Build pre command failed\n");
+		return rc;
+	}
+
+	/* This waits for some time, then waits for busy to be de-asserted. */
+	rc = ndf_build_wait_busy(tn);
+	if (rc) {
+		dev_err(tn->dev, "Wait timeout\n");
+		return rc;
+	}
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (timing_mode < 4)
+		cmd.u.rd_cmd.opcode = NDF_OP_RD_CMD;
+	else
+		cmd.u.rd_cmd.opcode = NDF_OP_RD_EDO_CMD;
+
+	cmd.u.rd_cmd.data = len;
+	cmd.u.rd_cmd.rlen1 = t7;
+	cmd.u.rd_cmd.rlen2 = t3;
+	cmd.u.rd_cmd.rlen3 = t1;
+	cmd.u.rd_cmd.rlen4 = t7;
+	rc = ndf_submit(tn, &cmd);
+	if (rc) {
+		dev_err(tn->dev, "Error submitting command\n");
+		return rc;
+	}
+
+	start = (u64)bus_addr;
+	ndf_setup_dma(tn, 0, bus_addr, len);
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc) {
+		dev_err(tn->dev, "Build post command failed\n");
+		return rc;
+	}
+
+	/* Wait for the DMA to complete */
+	rc = ndf_wait(tn);
+	if (rc) {
+		dev_err(tn->dev, "DMA timed out\n");
+		return rc;
+	}
+
+	end = readq(tn->base + NDF_DMA_ADR);
+	bytes = end - start;
+
+	/* Make sure NDF is really done */
+	rc = ndf_wait_idle(tn);
+	if (rc) {
+		dev_err(tn->dev, "poll idle failed\n");
+		return rc;
+	}
+
+	pr_debug("%s: Read %d bytes\n", __func__, bytes);
+	return bytes;
+}
+
+static int octeontx_nand_get_features(struct mtd_info *mtd,
+				      struct nand_chip *chip, int feature_addr,
+				      u8 *subfeature_para)
+{
+	struct nand_chip *nand = chip;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int len = 8;
+	int rc;
+
+	pr_debug("%s: feature addr: 0x%x\n", __func__, feature_addr);
+	memset(tn->buf.dmabuf, 0xff, len);
+	tn->buf.data_index = 0;
+	tn->buf.data_len = 0;
+	rc = ndf_read(tn, NAND_CMD_GET_FEATURES, 1, feature_addr, 0, 0, len);
+	if (rc)
+		return rc;
+
+	memcpy(subfeature_para, tn->buf.dmabuf, ONFI_SUBFEATURE_PARAM_LEN);
+
+	return 0;
+}
+
+static int octeontx_nand_set_features(struct mtd_info *mtd,
+				      struct nand_chip *chip, int feature_addr,
+				      u8 *subfeature_para)
+{
+	struct nand_chip *nand = chip;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	const int len = ONFI_SUBFEATURE_PARAM_LEN;
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_SET_FEATURES,
+			       1, feature_addr, 0, 0);
+	if (rc)
+		return rc;
+
+	memcpy(tn->buf.dmabuf, subfeature_para, len);
+	memset(tn->buf.dmabuf + len, 0, 8 - len);
+
+	ndf_setup_dma(tn, 1, tn->buf.dmaaddr, 8);
+
+	rc = ndf_queue_cmd_write(tn, 8);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+/*
+ * Read a page from NAND. If the buffer has room, the out of band
+ * data will be included.
+ */
+static int ndf_page_read(struct octeontx_nfc *tn, u64 page, int col, int len)
+{
+	debug("%s(%p, 0x%llx, 0x%x, 0x%x) active: %p\n", __func__,
+	      tn, page, col, len, tn->controller.active);
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes + chip->col_bytes;
+
+	memset(tn->buf.dmabuf, 0xff, len);
+	return ndf_read(tn, NAND_CMD_READ0, addr_bytes,
+		    page, col, NAND_CMD_READSTART, len);
+}
+
+/* Erase a NAND block */
+static int ndf_block_erase(struct octeontx_nfc *tn, u64 page_addr)
+{
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes;
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_ERASE1, addr_bytes,
+			       page_addr, 0, NAND_CMD_ERASE2);
+	if (rc)
+		return rc;
+
+	/* Wait for R_B to signal erase is complete  */
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Wait until the command queue is idle */
+	return ndf_wait_idle(tn);
+}
+
+/*
+ * Write a page (or less) to NAND.
+ */
+static int ndf_page_write(struct octeontx_nfc *tn, int page)
+{
+	int len, rc;
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes + chip->col_bytes;
+
+	len = tn->buf.data_len - tn->buf.data_index;
+	chip->oob_only = (tn->buf.data_index >= nand->mtd.writesize);
+	WARN_ON_ONCE(len & 0x7);
+
+	ndf_setup_dma(tn, 1, tn->buf.dmaaddr + tn->buf.data_index, len);
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_SEQIN, addr_bytes, page, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_write(tn, len);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_cle(tn, NAND_CMD_PAGEPROG);
+	if (rc)
+		return rc;
+
+	/* Wait for R_B to signal program is complete  */
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Wait for the DMA to complete */
+	rc = ndf_wait(tn);
+	if (rc)
+		return rc;
+
+	/* Data transfer is done but NDF is not, it is waiting for R/B# */
+	return ndf_wait_idle(tn);
+}
+
+static void octeontx_nand_cmdfunc(struct mtd_info *mtd, unsigned int command,
+				  int column, int page_addr)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nand_chip *octeontx_nand = to_otx_nand(nand);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int rc;
+
+	tn->selected_chip = octeontx_nand->cs;
+	if (tn->selected_chip < 0 || tn->selected_chip >= NAND_MAX_CHIPS) {
+		dev_err(tn->dev, "invalid chip select\n");
+		return;
+	}
+
+	tn->use_status = false;
+
+	pr_debug("%s(%p, 0x%x, 0x%x, 0x%x) cs: %d\n", __func__, mtd, command,
+		 column, page_addr, tn->selected_chip);
+	switch (command) {
+	case NAND_CMD_READID:
+		tn->buf.data_index = 0;
+		octeontx_nand->oob_only = false;
+		rc = ndf_read(tn, command, 1, column, 0, 0, 8);
+		if (rc < 0)
+			dev_err(tn->dev, "READID failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_READOOB:
+		octeontx_nand->oob_only = true;
+		tn->buf.data_index = 0;
+		tn->buf.data_len = 0;
+		rc = ndf_page_read(tn, page_addr, column, mtd->oobsize);
+		if (rc < mtd->oobsize)
+			dev_err(tn->dev, "READOOB failed with %d\n",
+				tn->buf.data_len);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_READ0:
+		octeontx_nand->oob_only = false;
+		tn->buf.data_index = 0;
+		tn->buf.data_len = 0;
+		rc = ndf_page_read(tn, page_addr, column,
+				   mtd->writesize + mtd->oobsize);
+
+		if (rc < mtd->writesize + mtd->oobsize)
+			dev_err(tn->dev, "READ0 failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_STATUS:
+		/* used in oob/not states */
+		tn->use_status = true;
+		rc = ndf_read(tn, command, 0, 0, 0, 0, 8);
+		if (rc < 0)
+			dev_err(tn->dev, "STATUS failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_RESET:
+		/* used in oob/not states */
+		rc = octeontx_nand_reset(tn);
+		if (rc < 0)
+			dev_err(tn->dev, "RESET failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_PARAM:
+		octeontx_nand->oob_only = false;
+		tn->buf.data_index = 0;
+		rc = ndf_read(tn, command, 1, 0, 0, 0,
+			      min(tn->buf.dmabuflen, 3 * 512));
+		if (rc < 0)
+			dev_err(tn->dev, "PARAM failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_RNDOUT:
+		tn->buf.data_index = column;
+		break;
+
+	case NAND_CMD_ERASE1:
+		if (ndf_block_erase(tn, page_addr))
+			dev_err(tn->dev, "ERASE1 failed\n");
+		break;
+
+	case NAND_CMD_ERASE2:
+		/* We do all erase processing in the first command, so ignore
+		 * this one.
+		 */
+		break;
+
+	case NAND_CMD_SEQIN:
+		octeontx_nand->oob_only = (column >= mtd->writesize);
+		tn->buf.data_index = column;
+		tn->buf.data_len = column;
+
+		octeontx_nand->selected_page = page_addr;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		rc = ndf_page_write(tn, octeontx_nand->selected_page);
+		if (rc)
+			dev_err(tn->dev, "PAGEPROG failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_SET_FEATURES:
+		octeontx_nand->oob_only = false;
+		/* assume tn->buf.data_len == 4 of data has been set there */
+		rc = octeontx_nand_set_features(mtd, nand,
+						page_addr, tn->buf.dmabuf);
+		if (rc)
+			dev_err(tn->dev, "SET_FEATURES failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_GET_FEATURES:
+		octeontx_nand->oob_only = false;
+		rc = octeontx_nand_get_features(mtd, nand,
+						page_addr, tn->buf.dmabuf);
+		if (!rc) {
+			tn->buf.data_index = 0;
+			tn->buf.data_len = 4;
+		} else {
+			dev_err(tn->dev, "GET_FEATURES failed with %d\n", rc);
+		}
+		break;
+
+	default:
+		WARN_ON_ONCE(1);
+		dev_err(tn->dev, "unhandled nand cmd: %x\n", command);
+	}
+}
+
+static int octeontx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct octeontx_nfc *tn = to_otx_nfc(chip->controller);
+	int ret;
+
+	ret = ndf_wait_idle(tn);
+	return (ret < 0) ? -EIO : 0;
+}
+
+/* check compatibility with ONFI timing mode#N, and optionally apply */
+/* TODO: Implement chipnr support? */
+static int octeontx_nand_setup_dat_intf(struct mtd_info *mtd, int chipnr,
+					const struct nand_data_interface *conf)
+{
+	static const bool check_only;
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int rc;
+	static u64 tWC_N[MAX_ONFI_MODE + 2]; /* cache a mode signature */
+	int mode; /* deduced mode number, for reporting and restricting */
+
+	/*
+	 * Cache timing modes for reporting, and reducing needless change.
+	 *
+	 * Challenge: caller does not pass ONFI mode#, but reporting the mode
+	 * and restricting to a maximum, or a list, are useful for diagnosing
+	 * new hardware.  So use tWC_min, distinct and monotonic across modes,
+	 * to discover the requested/accepted mode number
+	 */
+	for (mode = MAX_ONFI_MODE; mode >= 0 && !tWC_N[0]; mode--) {
+		const struct nand_sdr_timings *t;
+
+		t = onfi_async_timing_mode_to_sdr_timings(mode);
+		if (!t)
+			continue;
+		tWC_N[mode] = t->tWC_min;
+	}
+
+	if (!conf) {
+		rc = -EINVAL;
+	} else if (check_only) {
+		rc = 0;
+	} else if (nand->data_interface &&
+			chip->iface_set && chip->iface_mode == mode) {
+		/*
+		 * Cases:
+		 * - called from nand_reset, which clears DDR timing
+		 *   mode back to SDR.  BUT if we're already in SDR,
+		 *   timing mode persists over resets.
+		 *   While mtd/nand layer only supports SDR,
+		 *   this is always safe. And this driver only supports SDR.
+		 *
+		 * - called from post-power-event nand_reset (maybe
+		 *   NFC+flash power down, or system hibernate.
+		 *   Address this when CONFIG_PM support added
+		 */
+		rc = 0;
+	} else {
+		rc = octeontx_nfc_chip_set_timings(chip, &conf->timings.sdr);
+		if (!rc) {
+			chip->iface_mode = mode;
+			chip->iface_set = true;
+		}
+	}
+	return rc;
+}
+
+#if defined(CONFIG_NAND_OCTEONTX_HW_ECC)
+
+static void octeontx_bch_reset(void)
+{
+}
+
+/*
+ * Given a page, calculate the ECC code
+ *
+ * chip:	Pointer to NAND chip data structure
+ * buf:		Buffer to calculate ECC on
+ * code:	Buffer to hold ECC data
+ *
+ * Return 0 on success or -1 on failure
+ */
+static int octeontx_nand_bch_calculate_ecc_internal(struct mtd_info *mtd,
+						    dma_addr_t ihandle,
+						    u8 *code)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int rc;
+	int i;
+	static u8 *ecc_buffer;
+	static int ecc_size;
+	static unsigned long ecc_handle;
+	union bch_resp *r = tn->bch_resp;
+
+	if (!ecc_buffer || ecc_size < nand->ecc.size) {
+		ecc_size = nand->ecc.size;
+		ecc_buffer = dma_alloc_coherent(ecc_size,
+						(unsigned long *)&ecc_handle);
+	}
+
+	memset(ecc_buffer, 0, nand->ecc.bytes);
+
+	r->u16 = 0;
+	__iowmb(); /* flush done=0 before making request */
+
+	rc = octeontx_bch_encode(bch_vf, ihandle, nand->ecc.size,
+				 nand->ecc.strength,
+				 (dma_addr_t)ecc_handle, tn->bch_rhandle);
+
+	if (!rc) {
+		octeontx_bch_wait(bch_vf, r, tn->bch_rhandle);
+	} else {
+		dev_err(tn->dev, "octeontx_bch_encode failed\n");
+		return -1;
+	}
+
+	if (!r->s.done || r->s.uncorrectable) {
+		dev_err(tn->dev,
+			"%s timeout, done:%d uncorr:%d corr:%d erased:%d\n",
+			__func__, r->s.done, r->s.uncorrectable,
+			r->s.num_errors, r->s.erased);
+		octeontx_bch_reset();
+		return -1;
+	}
+
+	memcpy(code, ecc_buffer, nand->ecc.bytes);
+
+	for (i = 0; i < nand->ecc.bytes; i++)
+		code[i] ^= tn->eccmask[i];
+
+	return tn->bch_resp->s.num_errors;
+}
+
+/*
+ * Given a page, calculate the ECC code
+ *
+ * mtd:        MTD block structure
+ * dat:        raw data (unused)
+ * ecc_code:   buffer for ECC
+ */
+static int octeontx_nand_bch_calculate(struct mtd_info *mtd,
+				       const u8 *dat, u8 *ecc_code)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	dma_addr_t handle = dma_map_single((u8 *)dat,
+					   nand->ecc.size, DMA_TO_DEVICE);
+	int ret;
+
+	ret = octeontx_nand_bch_calculate_ecc_internal(mtd, handle,
+						       (void *)ecc_code);
+
+	return ret;
+}
+
+/*
+ * Detect and correct multi-bit ECC for a page
+ *
+ * mtd:        MTD block structure
+ * dat:        raw data read from the chip
+ * read_ecc:   ECC from the chip (unused)
+ * isnull:     unused
+ *
+ * Returns number of bits corrected or -1 if unrecoverable
+ */
+static int octeontx_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *isnull)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int i = nand->ecc.size + nand->ecc.bytes;
+	static u8 *data_buffer;
+	static dma_addr_t ihandle;
+	static int buffer_size;
+	dma_addr_t ohandle;
+	union bch_resp *r = tn->bch_resp;
+	int rc;
+
+	if (i > buffer_size) {
+		if (buffer_size)
+			free(data_buffer);
+		data_buffer = dma_alloc_coherent(i,
+						 (unsigned long *)&ihandle);
+		if (!data_buffer) {
+			dev_err(tn->dev,
+				"%s: Could not allocate %d bytes for buffer\n",
+				__func__, i);
+			goto error;
+		}
+		buffer_size = i;
+	}
+
+	memcpy(data_buffer, dat, nand->ecc.size);
+	memcpy(data_buffer + nand->ecc.size, read_ecc, nand->ecc.bytes);
+
+	for (i = 0; i < nand->ecc.bytes; i++)
+		data_buffer[nand->ecc.size + i] ^= tn->eccmask[i];
+
+	r->u16 = 0;
+	__iowmb(); /* flush done=0 before making request */
+
+	ohandle = dma_map_single(dat, nand->ecc.size, DMA_FROM_DEVICE);
+	rc = octeontx_bch_decode(bch_vf, ihandle, nand->ecc.size,
+				 nand->ecc.strength, ohandle, tn->bch_rhandle);
+
+	if (!rc)
+		octeontx_bch_wait(bch_vf, r, tn->bch_rhandle);
+
+	if (rc) {
+		dev_err(tn->dev, "octeontx_bch_decode failed\n");
+		goto error;
+	}
+
+	if (!r->s.done) {
+		dev_err(tn->dev, "Error: BCH engine timeout\n");
+		octeontx_bch_reset();
+		goto error;
+	}
+
+	if (r->s.erased) {
+		debug("Info: BCH block is erased\n");
+		return 0;
+	}
+
+	if (r->s.uncorrectable) {
+		debug("Cannot correct NAND block, response: 0x%x\n",
+		      r->u16);
+		goto error;
+	}
+
+	return r->s.num_errors;
+
+error:
+	debug("Error performing bch correction\n");
+	return -1;
+}
+
+void octeontx_nand_bch_hwctl(struct mtd_info *mtd, int mode)
+{
+	/* Do nothing. */
+}
+
+static int octeontx_nand_hw_bch_read_page(struct mtd_info *mtd,
+					  struct nand_chip *chip, u8 *buf,
+					  int oob_required, int page)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int i, eccsize = chip->ecc.size, ret;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	u8 *p;
+	u8 *ecc_code = chip->buffers->ecccode;
+	unsigned int max_bitflips = 0;
+
+	/* chip->read_buf() insists on sequential order, we do OOB first */
+	memcpy(chip->oob_poi, tn->buf.dmabuf + mtd->writesize, mtd->oobsize);
+
+	/* Use private buffer as input for ECC correction */
+	p = tn->buf.dmabuf;
+
+	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
+					 chip->ecc.total);
+	if (ret)
+		return ret;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
+
+		debug("Correcting block offset %lx, ecc offset %x\n",
+		      p - buf, i);
+		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
+
+		if (stat < 0) {
+			mtd->ecc_stats.failed++;
+			debug("Cannot correct NAND page %d\n", page);
+		} else {
+			mtd->ecc_stats.corrected += stat;
+			max_bitflips = max_t(unsigned int, max_bitflips, stat);
+		}
+	}
+
+	/* Copy corrected data to caller's buffer now */
+	memcpy(buf, tn->buf.dmabuf, mtd->writesize);
+
+	return max_bitflips;
+}
+
+static int octeontx_nand_hw_bch_write_page(struct mtd_info *mtd,
+					   struct nand_chip *chip,
+					   const u8 *buf, int oob_required,
+					   int page)
+{
+	struct octeontx_nfc *tn = to_otx_nfc(chip->controller);
+	int i, eccsize = chip->ecc.size, ret;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const u8 *p;
+	u8 *ecc_calc = chip->buffers->ecccalc;
+
+	debug("%s(buf?%p, oob%d p%x)\n",
+	      __func__, buf, oob_required, page);
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_calc[i] = 0xFF;
+
+	/* Copy the page data from caller's buffers to private buffer */
+	chip->write_buf(mtd, buf, mtd->writesize);
+	/* Use private date as source for ECC calculation */
+	p = tn->buf.dmabuf;
+
+	/* Hardware ECC calculation */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int ret;
+
+		ret = chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		if (ret < 0)
+			debug("calculate(mtd, p?%p, &ecc_calc[%d]?%p) returned %d\n",
+			      p, i, &ecc_calc[i], ret);
+
+		debug("block offset %lx, ecc offset %x\n", p - buf, i);
+	}
+
+	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
+					 chip->ecc.total);
+	if (ret)
+		return ret;
+
+	/* Store resulting OOB into private buffer, will be sent to HW */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/**
+ * nand_write_page_raw - [INTERN] raw page write function
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @buf: data buffer
+ * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
+ *
+ * Not for syndrome calculating ECC controllers, which use a special oob layout.
+ */
+static int octeontx_nand_write_page_raw(struct mtd_info *mtd,
+					struct nand_chip *chip,
+					const u8 *buf, int oob_required,
+					int page)
+{
+	chip->write_buf(mtd, buf, mtd->writesize);
+	if (oob_required)
+		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/**
+ * octeontx_nand_write_oob_std - [REPLACEABLE] the most common OOB data write
+ *                             function
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @page: page number to write
+ */
+static int octeontx_nand_write_oob_std(struct mtd_info *mtd,
+				       struct nand_chip *chip,
+				       int page)
+{
+	int status = 0;
+	const u8 *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, buf, length);
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/**
+ * octeontx_nand_read_page_raw - [INTERN] read raw page data without ecc
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @buf: buffer to store read data
+ * @oob_required: caller requires OOB data read to chip->oob_poi
+ * @page: page number to read
+ *
+ * Not for syndrome calculating ECC controllers, which use a special oob layout.
+ */
+static int octeontx_nand_read_page_raw(struct mtd_info *mtd,
+				       struct nand_chip *chip,
+				       u8 *buf, int oob_required, int page)
+{
+	chip->read_buf(mtd, buf, mtd->writesize);
+	if (oob_required)
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
+
+static int octeontx_nand_read_oob_std(struct mtd_info *mtd,
+				      struct nand_chip *chip,
+				      int page)
+
+{
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
+
+static int octeontx_nand_calc_bch_ecc_strength(struct nand_chip *nand)
+{
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct nand_ecc_ctrl *ecc = &nand->ecc;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int nsteps = mtd->writesize / ecc->size;
+	int oobchunk = mtd->oobsize / nsteps;
+
+	/* ecc->strength determines ecc_level and OOB's ecc_bytes. */
+	const u8 strengths[]  = {4, 8, 16, 24, 32, 40, 48, 56, 60, 64};
+	/* first set the desired ecc_level to match strengths[] */
+	int index = ARRAY_SIZE(strengths) - 1;
+	int need;
+
+	while (index > 0 && !(ecc->options & NAND_ECC_MAXIMIZE) &&
+	       strengths[index - 1] >= ecc->strength)
+		index--;
+
+	do {
+		need = DIV_ROUND_UP(15 * strengths[index], 8);
+		if (need <= oobchunk - 2)
+			break;
+	} while (index > 0);
+
+	debug("%s: steps ds: %d, strength ds: %d\n", __func__,
+	      nand->ecc_step_ds, nand->ecc_strength_ds);
+	ecc->strength = strengths[index];
+	ecc->bytes = need;
+	debug("%s: strength: %d, bytes: %d\n", __func__, ecc->strength,
+	      ecc->bytes);
+
+	if (!tn->eccmask)
+		tn->eccmask = devm_kzalloc(tn->dev, ecc->bytes, GFP_KERNEL);
+	if (!tn->eccmask)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* sample the BCH signature of an erased (all 0xff) page,
+ * to XOR into all page traffic, so erased pages have no ECC errors
+ */
+static int octeontx_bch_save_empty_eccmask(struct nand_chip *nand)
+{
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	unsigned int eccsize = nand->ecc.size;
+	unsigned int eccbytes = nand->ecc.bytes;
+	u8 erased_ecc[eccbytes];
+	unsigned long erased_handle;
+	unsigned char *erased_page = dma_alloc_coherent(eccsize,
+							&erased_handle);
+	int i;
+	int rc = 0;
+
+	if (!erased_page)
+		return -ENOMEM;
+
+	memset(erased_page, 0xff, eccsize);
+	memset(erased_ecc, 0, eccbytes);
+
+	rc = octeontx_nand_bch_calculate_ecc_internal(mtd,
+						      (dma_addr_t)erased_handle,
+						      erased_ecc);
+
+	free(erased_page);
+
+	for (i = 0; i < eccbytes; i++)
+		tn->eccmask[i] = erased_ecc[i] ^ 0xff;
+
+	return rc;
+}
+#endif /*CONFIG_NAND_OCTEONTX_HW_ECC*/
+
+static void octeontx_nfc_chip_sizing(struct nand_chip *nand)
+{
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct nand_ecc_ctrl *ecc = &nand->ecc;
+
+	chip->row_bytes = nand->onfi_params.addr_cycles & 0xf;
+	chip->col_bytes = nand->onfi_params.addr_cycles >> 4;
+	debug("%s(%p) row bytes: %d, col bytes: %d, ecc mode: %d\n",
+	      __func__, nand, chip->row_bytes, chip->col_bytes, ecc->mode);
+
+	/*
+	 * HW_BCH using OcteonTX BCH engine, or SOFT_BCH laid out in
+	 * HW_BCH-compatible fashion, depending on devtree advice
+	 * and kernel config.
+	 * BCH/NFC hardware capable of subpage ops, not implemented.
+	 */
+	mtd_set_ooblayout(mtd, &nand_ooblayout_lp_ops);
+	nand->options |= NAND_NO_SUBPAGE_WRITE;
+	debug("%s: start steps: %d, size: %d, bytes: %d\n",
+	      __func__, ecc->steps, ecc->size, ecc->bytes);
+	debug("%s: step ds: %d, strength ds: %d\n", __func__,
+	      nand->ecc_step_ds, nand->ecc_strength_ds);
+
+	if (ecc->mode != NAND_ECC_NONE) {
+		int nsteps = ecc->steps ? ecc->steps : 1;
+
+		if (ecc->size && ecc->size != mtd->writesize)
+			nsteps = mtd->writesize / ecc->size;
+		else if (mtd->writesize > def_ecc_size &&
+			 !(mtd->writesize & (def_ecc_size - 1)))
+			nsteps = mtd->writesize / def_ecc_size;
+		ecc->steps = nsteps;
+		ecc->size = mtd->writesize / nsteps;
+		ecc->bytes = mtd->oobsize / nsteps;
+
+		if (nand->ecc_strength_ds)
+			ecc->strength = nand->ecc_strength_ds;
+		if (nand->ecc_step_ds)
+			ecc->size = nand->ecc_step_ds;
+		/*
+		 * no subpage ops, but set subpage-shift to match ecc->steps
+		 * so mtd_nandbiterrs tests appropriate boundaries
+		 */
+		if (!mtd->subpage_sft && !(ecc->steps & (ecc->steps - 1)))
+			mtd->subpage_sft = fls(ecc->steps) - 1;
+
+#if defined(CONFIG_NAND_OCTEONTX_HW_ECC)
+		debug("%s: ecc mode: %d\n", __func__, ecc->mode);
+		if (ecc->mode != NAND_ECC_SOFT &&
+		    !octeontx_nand_calc_bch_ecc_strength(nand)) {
+			struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+			debug("Using hardware BCH engine support\n");
+			ecc->mode = NAND_ECC_HW_SYNDROME;
+			ecc->read_page = octeontx_nand_hw_bch_read_page;
+			ecc->write_page = octeontx_nand_hw_bch_write_page;
+			ecc->read_page_raw = octeontx_nand_read_page_raw;
+			ecc->write_page_raw = octeontx_nand_write_page_raw;
+			ecc->read_oob = octeontx_nand_read_oob_std;
+			ecc->write_oob = octeontx_nand_write_oob_std;
+
+			ecc->calculate = octeontx_nand_bch_calculate;
+			ecc->correct = octeontx_nand_bch_correct;
+			ecc->hwctl = octeontx_nand_bch_hwctl;
+
+			debug("NAND chip %d using hw_bch\n",
+			      tn->selected_chip);
+			debug(" %d bytes ECC per %d byte block\n",
+			      ecc->bytes, ecc->size);
+			debug(" for %d bits of correction per block.",
+			      ecc->strength);
+			octeontx_nand_calc_ecc_layout(nand);
+			octeontx_bch_save_empty_eccmask(nand);
+		}
+#endif /*CONFIG_NAND_OCTEONTX_HW_ECC*/
+	}
+}
+
+static int octeontx_nfc_chip_init(struct octeontx_nfc *tn, struct udevice *dev,
+				  ofnode node)
+{
+	struct octeontx_nand_chip *chip;
+	struct nand_chip *nand;
+	struct mtd_info *mtd;
+	int ret;
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	debug("%s: Getting chip select\n", __func__);
+	ret = ofnode_read_s32(node, "reg", &chip->cs);
+	if (ret) {
+		dev_err(dev, "could not retrieve reg property: %d\n", ret);
+		return ret;
+	}
+
+	if (chip->cs >= NAND_MAX_CHIPS) {
+		dev_err(dev, "invalid reg value: %u (max CS = 7)\n", chip->cs);
+		return -EINVAL;
+	}
+	debug("%s: chip select: %d\n", __func__, chip->cs);
+	nand = &chip->nand;
+	nand->controller = &tn->controller;
+	if (!tn->controller.active)
+		tn->controller.active = nand;
+
+	debug("%s: Setting flash node\n", __func__);
+	nand_set_flash_node(nand, node);
+
+	nand->options = 0;
+	nand->select_chip = octeontx_nand_select_chip;
+	nand->cmdfunc = octeontx_nand_cmdfunc;
+	nand->waitfunc = octeontx_nand_waitfunc;
+	nand->read_byte = octeontx_nand_read_byte;
+	nand->read_buf = octeontx_nand_read_buf;
+	nand->write_buf = octeontx_nand_write_buf;
+	nand->onfi_set_features = octeontx_nand_set_features;
+	nand->onfi_get_features = octeontx_nand_get_features;
+	nand->setup_data_interface = octeontx_nand_setup_dat_intf;
+
+	mtd = nand_to_mtd(nand);
+	mtd->dev = dev;
+
+	/* TODO: support more then 1 chip */
+	debug("%s: Scanning identification\n", __func__);
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret)
+		return ret;
+
+	debug("%s: Sizing chip\n", __func__);
+	octeontx_nfc_chip_sizing(nand);
+
+	debug("%s: Scanning tail\n", __func__);
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		dev_err(dev, "nand_scan_tail failed: %d\n", ret);
+		return ret;
+	}
+
+	debug("%s: Registering mtd\n", __func__);
+	ret = nand_register(0, mtd);
+
+	debug("%s: Adding tail\n", __func__);
+	list_add_tail(&chip->node, &tn->chips);
+	return 0;
+}
+
+static int octeontx_nfc_chips_init(struct octeontx_nfc *tn)
+{
+	struct udevice *dev = tn->dev;
+	ofnode node = dev->node;
+	ofnode nand_node;
+	int nr_chips = of_get_child_count(node);
+	int ret;
+
+	debug("%s: node: %s\n", __func__, ofnode_get_name(node));
+	debug("%s: %d chips\n", __func__, nr_chips);
+	if (nr_chips > NAND_MAX_CHIPS) {
+		dev_err(dev, "too many NAND chips: %d\n", nr_chips);
+		return -EINVAL;
+	}
+
+	if (!nr_chips) {
+		debug("no DT NAND chips found\n");
+		return -ENODEV;
+	}
+
+	pr_info("%s: scanning %d chips DTs\n", __func__, nr_chips);
+
+	ofnode_for_each_subnode(nand_node, node) {
+		debug("%s: Calling octeontx_nfc_chip_init(%p, %s, %ld)\n",
+		      __func__, tn, dev->name, nand_node.of_offset);
+		ret = octeontx_nfc_chip_init(tn, dev, nand_node);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/* Reset NFC and initialize registers. */
+static int octeontx_nfc_init(struct octeontx_nfc *tn)
+{
+	const struct nand_sdr_timings *timings;
+	u64 ndf_misc;
+	int rc;
+
+	/* Initialize values and reset the fifo */
+	ndf_misc = readq(tn->base + NDF_MISC);
+
+	ndf_misc &= ~NDF_MISC_EX_DIS;
+	ndf_misc |= (NDF_MISC_BT_DIS | NDF_MISC_RST_FF);
+	writeq(ndf_misc, tn->base + NDF_MISC);
+	debug("%s: NDF_MISC: 0x%llx\n", __func__, readq(tn->base + NDF_MISC));
+
+	/* Bring the fifo out of reset */
+	ndf_misc &= ~(NDF_MISC_RST_FF);
+
+	/* Maximum of co-processor cycles for glitch filtering */
+	ndf_misc |= FIELD_PREP(NDF_MISC_WAIT_CNT, 0x3f);
+
+	writeq(ndf_misc, tn->base + NDF_MISC);
+
+	/* Set timing parameters to onfi mode 0 for probing */
+	timings = onfi_async_timing_mode_to_sdr_timings(0);
+	if (IS_ERR(timings))
+		return PTR_ERR(timings);
+	rc = set_default_timings(tn, timings);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int octeontx_pci_nand_probe(struct udevice *dev)
+{
+	struct octeontx_nfc *tn = dev_get_priv(dev);
+	int ret;
+	static bool probe_done;
+
+	debug("%s(%s) tn: %p\n", __func__, dev->name, tn);
+	if (probe_done)
+		return 0;
+
+#ifdef CONFIG_NAND_OCTEONTX_HW_ECC
+	bch_vf = octeontx_bch_getv();
+	if (!bch_vf) {
+		struct octeontx_probe_device *probe_dev;
+
+		debug("%s: bch not yet initialized\n", __func__);
+		probe_dev = calloc(sizeof(*probe_dev), 1);
+		if (!probe_dev) {
+			printf("%s: Out of memory\n", __func__);
+			return -ENOMEM;
+		}
+		probe_dev->dev = dev;
+		INIT_LIST_HEAD(&probe_dev->list);
+		list_add_tail(&probe_dev->list,
+			      &octeontx_pci_nand_deferred_devices);
+		debug("%s: Defering probe until after BCH initialization\n",
+		      __func__);
+		return 0;
+	}
+#endif
+
+	tn->dev = dev;
+	INIT_LIST_HEAD(&tn->chips);
+
+	tn->base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
+	if (!tn->base) {
+		ret = -EINVAL;
+		goto release;
+	}
+	debug("%s: bar at %p\n", __func__, tn->base);
+	tn->buf.dmabuflen = NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE;
+	tn->buf.dmabuf = dma_alloc_coherent(tn->buf.dmabuflen,
+					    (unsigned long *)&tn->buf.dmaaddr);
+	if (!tn->buf.dmabuf) {
+		ret = -ENOMEM;
+		debug("%s: Could not allocate DMA buffer\n", __func__);
+		goto unclk;
+	}
+
+	/* one hw-bch response, for one outstanding transaction */
+	tn->bch_resp = dma_alloc_coherent(sizeof(*tn->bch_resp),
+					  (unsigned long *)&tn->bch_rhandle);
+
+	tn->stat = dma_alloc_coherent(8, (unsigned long *)&tn->stat_addr);
+	if (!tn->stat || !tn->bch_resp) {
+		debug("%s: Could not allocate bch status or response\n",
+		      __func__);
+		ret = -ENOMEM;
+		goto unclk;
+	}
+
+	debug("%s: Calling octeontx_nfc_init()\n", __func__);
+	octeontx_nfc_init(tn);
+	debug("%s: Initializing chips\n", __func__);
+	ret = octeontx_nfc_chips_init(tn);
+	debug("%s: init chips ret: %d\n", __func__, ret);
+	if (ret) {
+		if (ret != -ENODEV)
+			dev_err(dev, "failed to init nand chips\n");
+		goto unclk;
+	}
+	dev_info(dev, "probed\n");
+	return 0;
+
+unclk:
+release:
+	return ret;
+}
+
+int octeontx_pci_nand_disable(struct udevice *dev)
+{
+	struct octeontx_nfc *tn = dev_get_priv(dev);
+	u64 dma_cfg;
+	u64 ndf_misc;
+
+	debug("%s: Disabling NAND device %s\n", __func__, dev->name);
+	dma_cfg = readq(tn->base + NDF_DMA_CFG);
+	dma_cfg &= ~NDF_DMA_CFG_EN;
+	dma_cfg |= NDF_DMA_CFG_CLR;
+	writeq(dma_cfg, tn->base + NDF_DMA_CFG);
+
+	/* Disable execution and put FIFO in reset mode */
+	ndf_misc = readq(tn->base + NDF_MISC);
+	ndf_misc |= NDF_MISC_EX_DIS | NDF_MISC_RST_FF;
+	writeq(ndf_misc, tn->base + NDF_MISC);
+	ndf_misc &= ~NDF_MISC_RST_FF;
+	writeq(ndf_misc, tn->base + NDF_MISC);
+#ifdef DEBUG
+	printf("%s: NDF_MISC: 0x%llx\n", __func__, readq(tn->base + NDF_MISC));
+#endif
+	/* Clear any interrupts and enable bits */
+	writeq(~0ull, tn->base + NDF_INT_ENA_W1C);
+	writeq(~0ull, tn->base + NDF_INT);
+	debug("%s: NDF_ST_REG: 0x%llx\n", __func__,
+	      readq(tn->base + NDF_ST_REG));
+	return 0;
+}
+
+#ifdef CONFIG_NAND_OCTEONTX_HW_ECC
+/**
+ * Since it's possible (and even likely) that the NAND device will be probed
+ * before the BCH device has been probed, we may need to defer the probing.
+ *
+ * In this case, the initial probe returns success but the actual probing
+ * is deferred until the BCH VF has been probed.
+ *
+ * @return	0 for success, otherwise error
+ */
+int octeontx_pci_nand_deferred_probe(void)
+{
+	int rc = 0;
+	struct octeontx_probe_device *pdev;
+
+	debug("%s: Performing deferred probing\n", __func__);
+	list_for_each_entry(pdev, &octeontx_pci_nand_deferred_devices, list) {
+		debug("%s: Probing %s\n", __func__, pdev->dev->name);
+		pdev->dev->flags &= ~DM_FLAG_ACTIVATED;
+		rc = device_probe(pdev->dev);
+		if (rc && rc != -ENODEV) {
+			printf("%s: Error %d with deferred probe of %s\n",
+			       __func__, rc, pdev->dev->name);
+			break;
+		}
+	}
+	return rc;
+}
+#endif
+
+static const struct pci_device_id octeontx_nfc_pci_id_table[] = {
+	{ PCI_VDEVICE(CAVIUM, 0xA04F) },
+	{}
+};
+
+static int octeontx_nand_ofdata_to_platdata(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct udevice_id octeontx_nand_ids[] = {
+	{ .compatible = "cavium,cn8130-nand" },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_pci_nand) = {
+	.name	= OCTEONTX_NAND_DRIVER_NAME,
+	.id	= UCLASS_MTD,
+	.of_match = of_match_ptr(octeontx_nand_ids),
+	.ofdata_to_platdata = octeontx_nand_ofdata_to_platdata,
+	.probe = octeontx_pci_nand_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_nfc),
+	.remove = octeontx_pci_nand_disable,
+	.flags = DM_FLAG_OS_PREPARE | DM_FLAG_ACTIVE_DMA,
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_nand, octeontx_nfc_pci_id_table);
+
+void board_nand_init(void)
+{
+	struct udevice *dev;
+	int ret;
+
+#ifdef CONFIG_NAND_OCTEONTX_HW_ECC
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(octeontx_pci_bchpf),
+					  &dev);
+	if (ret && ret != -ENODEV) {
+		pr_err("Failed to initialize OcteonTX BCH PF controller. (error %d)\n",
+		       ret);
+	}
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(octeontx_pci_bchvf),
+					  &dev);
+	if (ret && ret != -ENODEV) {
+		pr_err("Failed to initialize OcteonTX BCH VF controller. (error %d)\n",
+		       ret);
+	}
+#endif
+
+	ret = uclass_get_device_by_driver(UCLASS_MTD,
+					  DM_GET_DRIVER(octeontx_pci_nand),
+					  &dev);
+	if (ret && ret != -ENODEV)
+		pr_err("Failed to initialize OcteonTX NAND controller. (error %d)\n",
+		       ret);
+}
diff --git a/drivers/mtd/nand/raw/pxa3xx_nand.c b/drivers/mtd/nand/raw/pxa3xx_nand.c
index 4d2712df4c..8538c38cd5 100644
--- a/drivers/mtd/nand/raw/pxa3xx_nand.c
+++ b/drivers/mtd/nand/raw/pxa3xx_nand.c
@@ -21,6 +21,8 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define MVEBU_RAW_READ_DISABLE	1
+
 #define TIMEOUT_DRAIN_FIFO	5	/* in ms */
 #define	CHIP_DELAY_TIMEOUT	200
 #define NAND_STOP_DELAY		40
@@ -148,108 +150,6 @@ enum {
 	STATE_READY,
 };
 
-enum pxa3xx_nand_variant {
-	PXA3XX_NAND_VARIANT_PXA,
-	PXA3XX_NAND_VARIANT_ARMADA370,
-};
-
-struct pxa3xx_nand_host {
-	struct nand_chip	chip;
-	void			*info_data;
-
-	/* page size of attached chip */
-	int			use_ecc;
-	int			cs;
-
-	/* calculated from pxa3xx_nand_flash data */
-	unsigned int		col_addr_cycles;
-	unsigned int		row_addr_cycles;
-};
-
-struct pxa3xx_nand_info {
-	struct nand_hw_control	controller;
-	struct pxa3xx_nand_platform_data *pdata;
-
-	struct clk		*clk;
-	void __iomem		*mmio_base;
-	unsigned long		mmio_phys;
-	int			cmd_complete, dev_ready;
-
-	unsigned int		buf_start;
-	unsigned int		buf_count;
-	unsigned int		buf_size;
-	unsigned int		data_buff_pos;
-	unsigned int		oob_buff_pos;
-
-	unsigned char		*data_buff;
-	unsigned char		*oob_buff;
-
-	struct pxa3xx_nand_host *host[NUM_CHIP_SELECT];
-	unsigned int		state;
-
-	/*
-	 * This driver supports NFCv1 (as found in PXA SoC)
-	 * and NFCv2 (as found in Armada 370/XP SoC).
-	 */
-	enum pxa3xx_nand_variant variant;
-
-	int			cs;
-	int			use_ecc;	/* use HW ECC ? */
-	int			force_raw;	/* prevent use_ecc to be set */
-	int			ecc_bch;	/* using BCH ECC? */
-	int			use_spare;	/* use spare ? */
-	int			need_wait;
-
-	/* Amount of real data per full chunk */
-	unsigned int		chunk_size;
-
-	/* Amount of spare data per full chunk */
-	unsigned int		spare_size;
-
-	/* Number of full chunks (i.e chunk_size + spare_size) */
-	unsigned int            nfullchunks;
-
-	/*
-	 * Total number of chunks. If equal to nfullchunks, then there
-	 * are only full chunks. Otherwise, there is one last chunk of
-	 * size (last_chunk_size + last_spare_size)
-	 */
-	unsigned int            ntotalchunks;
-
-	/* Amount of real data in the last chunk */
-	unsigned int		last_chunk_size;
-
-	/* Amount of spare data in the last chunk */
-	unsigned int		last_spare_size;
-
-	unsigned int		ecc_size;
-	unsigned int		ecc_err_cnt;
-	unsigned int		max_bitflips;
-	int			retcode;
-
-	/*
-	 * Variables only valid during command
-	 * execution. step_chunk_size and step_spare_size is the
-	 * amount of real data and spare data in the current
-	 * chunk. cur_chunk is the current chunk being
-	 * read/programmed.
-	 */
-	unsigned int		step_chunk_size;
-	unsigned int		step_spare_size;
-	unsigned int            cur_chunk;
-
-	/* cached register value */
-	uint32_t		reg_ndcr;
-	uint32_t		ndtr0cs0;
-	uint32_t		ndtr1cs0;
-
-	/* generated NDCBx register values */
-	uint32_t		ndcb0;
-	uint32_t		ndcb1;
-	uint32_t		ndcb2;
-	uint32_t		ndcb3;
-};
-
 static struct pxa3xx_nand_timing timing[] = {
 	/*
 	 * tCH	Enable signal hold time
@@ -417,13 +317,20 @@ static enum pxa3xx_nand_variant pxa3xx_nand_get_variant(void)
 	return PXA3XX_NAND_VARIANT_ARMADA370;
 }
 
-static void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
-				   const struct pxa3xx_nand_timing *t)
+static int pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
+				  const struct pxa3xx_nand_timing *t)
 {
 	struct pxa3xx_nand_info *info = host->info_data;
-	unsigned long nand_clk = mvebu_get_nand_clock();
+	unsigned long nand_clk;
 	uint32_t ndtr0, ndtr1;
 
+	nand_clk = mvebu_get_nand_clock(info->nand_flash_clk_ctrl_reg);
+	if (!nand_clk) {
+		dev_err(&host->info->pdev->dev,
+			"Missinig flash clock register\n");
+		return -EINVAL;
+	}
+
 	ndtr0 = NDTR0_tCH(ns2cycle(t->tCH, nand_clk)) |
 		NDTR0_tCS(ns2cycle(t->tCS, nand_clk)) |
 		NDTR0_tWH(ns2cycle(t->tWH, nand_clk)) |
@@ -439,14 +346,16 @@ static void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
 	info->ndtr1cs0 = ndtr1;
 	nand_writel(info, NDTR0CS0, ndtr0);
 	nand_writel(info, NDTR1CS0, ndtr1);
+
+	return 0;
 }
 
-static void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
-				       const struct nand_sdr_timings *t)
+static int pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
+				      const struct nand_sdr_timings *t)
 {
 	struct pxa3xx_nand_info *info = host->info_data;
 	struct nand_chip *chip = &host->chip;
-	unsigned long nand_clk = mvebu_get_nand_clock();
+	unsigned long nand_clk;
 	uint32_t ndtr0, ndtr1;
 
 	u32 tCH_min = DIV_ROUND_UP(t->tCH_min, 1000);
@@ -459,6 +368,13 @@ static void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
 	u32 tWHR_min = DIV_ROUND_UP(t->tWHR_min, 1000);
 	u32 tAR_min = DIV_ROUND_UP(t->tAR_min, 1000);
 
+	nand_clk = mvebu_get_nand_clock(info->nand_flash_clk_ctrl_reg);
+	if (!nand_clk) {
+		dev_err(&host->info->pdev->dev,
+			"Missinig flash clock register\n");
+		return -EINVAL;
+	}
+
 	/* fallback to a default value if tR = 0 */
 	if (!tR)
 		tR = 20000;
@@ -478,6 +394,8 @@ static void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
 	info->ndtr1cs0 = ndtr1;
 	nand_writel(info, NDTR0CS0, ndtr0);
 	nand_writel(info, NDTR1CS0, ndtr1);
+
+	return 0;
 }
 
 static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
@@ -487,7 +405,7 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 	struct pxa3xx_nand_info *info = host->info_data;
 	const struct pxa3xx_nand_flash *f = NULL;
 	struct mtd_info *mtd = nand_to_mtd(&host->chip);
-	int mode, id, ntypes, i;
+	int mode, id, ntypes, i, ret;
 
 	mode = onfi_get_async_timing_mode(chip);
 	if (mode == ONFI_TIMING_MODE_UNKNOWN) {
@@ -510,7 +428,9 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 			return -EINVAL;
 		}
 
-		pxa3xx_nand_set_timing(host, f->timing);
+		ret = pxa3xx_nand_set_timing(host, f->timing);
+		if (ret)
+			return ret;
 
 		if (f->flash_width == 16) {
 			info->reg_ndcr |= NDCR_DWIDTH_M;
@@ -527,7 +447,9 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 		if (IS_ERR(timings))
 			return PTR_ERR(timings);
 
-		pxa3xx_nand_set_sdr_timing(host, timings);
+		ret = pxa3xx_nand_set_sdr_timing(host, timings);
+		if (ret)
+			return ret;
 	}
 
 	return 0;
@@ -1278,6 +1200,7 @@ static int pxa3xx_nand_read_page_hwecc(struct mtd_info *mtd,
 	return info->max_bitflips;
 }
 
+#ifndef MVEBU_RAW_READ_DISABLE
 static int pxa3xx_nand_read_page_raw(struct mtd_info *mtd,
 				     struct nand_chip *chip, uint8_t *buf,
 				     int oob_required, int page)
@@ -1340,6 +1263,7 @@ static int pxa3xx_nand_read_oob_raw(struct mtd_info *mtd,
 	return chip->ecc.read_page_raw(mtd, chip, chip->buffers->databuf, true,
 				       page);
 }
+#endif /* MVEBU_RAW_READ_DISABLE */
 
 static uint8_t pxa3xx_nand_read_byte(struct mtd_info *mtd)
 {
@@ -1772,8 +1696,15 @@ static int alloc_nand_resource(struct pxa3xx_nand_info *info)
 
 		nand_set_controller_data(chip, host);
 		chip->ecc.read_page	= pxa3xx_nand_read_page_hwecc;
+#ifndef MVEBU_RAW_READ_DISABLE
+		/*
+		 * TODO: RAW read support seems to be broken in NFCv2,
+		 * reported working on NFCv1 (A38x).
+		 * The code needs further debug.
+		 */
 		chip->ecc.read_page_raw	= pxa3xx_nand_read_page_raw;
 		chip->ecc.read_oob_raw	= pxa3xx_nand_read_oob_raw;
+#endif
 		chip->ecc.write_page	= pxa3xx_nand_write_page_hwecc;
 		chip->controller        = &info->controller;
 		chip->waitfunc		= pxa3xx_nand_waitfunc;
@@ -1809,6 +1740,8 @@ static int pxa3xx_nand_probe_dt(struct pxa3xx_nand_info *info)
 	struct pxa3xx_nand_platform_data *pdata;
 	const void *blob = gd->fdt_blob;
 	int node = -1;
+	int index;
+	fdt_addr_t addr;
 
 	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
@@ -1830,6 +1763,26 @@ static int pxa3xx_nand_probe_dt(struct pxa3xx_nand_info *info)
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 					blob, node, "reg", 0, NULL, true);
 
+		index = fdt_stringlist_search(blob, node, "reg-names",
+					      "flash_clock");
+		if (index > 0) {
+			addr = fdtdec_get_addr_size_auto_noparent(
+					blob, node, "reg", index, NULL, true);
+			if (addr != FDT_ADDR_T_NONE)
+				info->nand_flash_clk_ctrl_reg =
+					(void __iomem *)addr;
+		}
+
+		index = fdt_stringlist_search(blob, node, "reg-names",
+					      "dev_mux");
+		if (index > 0) {
+			addr = fdtdec_get_addr_size_auto_noparent(
+					blob, node, "reg", index, NULL, true);
+			if (addr != FDT_ADDR_T_NONE)
+				info->soc_dev_multiplex_reg =
+					(void __iomem *)addr;
+		}
+
 		pdata->num_cs = fdtdec_get_int(blob, node, "num-cs", 1);
 		if (pdata->num_cs != 1) {
 			pr_err("pxa3xx driver supports single CS only\n");
@@ -1876,6 +1829,14 @@ static int pxa3xx_nand_probe(struct pxa3xx_nand_info *info)
 
 	pdata = info->pdata;
 
+	/* If the NAND flash is enabled in DT, but the boot image is not
+	 * running from NAND, it may be needed to enable NAND on SOC
+	 * DEVBUS MUX level.
+	 * When the boot device is NAND, such configuration is done
+	 * in the BootROM.
+	 */
+	mvebu_nand_select(info->soc_dev_multiplex_reg);
+
 	ret = alloc_nand_resource(info);
 	if (ret) {
 		dev_err(&pdev->dev, "alloc nand resource failed\n");
diff --git a/drivers/mtd/nand/raw/pxa3xx_nand.h b/drivers/mtd/nand/raw/pxa3xx_nand.h
index 8f24ae6d18..a465b0f60a 100644
--- a/drivers/mtd/nand/raw/pxa3xx_nand.h
+++ b/drivers/mtd/nand/raw/pxa3xx_nand.h
@@ -61,4 +61,111 @@ struct pxa3xx_nand_platform_data {
 	const struct pxa3xx_nand_flash		*flash;
 	size_t					num_flash;
 };
+
+enum pxa3xx_nand_variant {
+	PXA3XX_NAND_VARIANT_PXA,
+	PXA3XX_NAND_VARIANT_ARMADA370,
+};
+
+struct pxa3xx_nand_host {
+	struct nand_chip	chip;
+	void			*info_data;
+
+	/* page size of attached chip */
+	int			use_ecc;
+	int			cs;
+
+	/* calculated from pxa3xx_nand_flash data */
+	unsigned int		col_addr_cycles;
+	unsigned int		row_addr_cycles;
+};
+
+struct pxa3xx_nand_info {
+	struct nand_hw_control	controller;
+	struct pxa3xx_nand_platform_data *pdata;
+
+	struct clk		*clk;
+	void __iomem		*mmio_base;
+	unsigned long		mmio_phys;
+	int			cmd_complete, dev_ready;
+
+	unsigned int		buf_start;
+	unsigned int		buf_count;
+	unsigned int		buf_size;
+	unsigned int		data_buff_pos;
+	unsigned int		oob_buff_pos;
+
+	unsigned char		*data_buff;
+	unsigned char		*oob_buff;
+
+	struct pxa3xx_nand_host *host[NUM_CHIP_SELECT];
+	unsigned int		state;
+
+	/*
+	 * This driver supports NFCv1 (as found in PXA SoC)
+	 * and NFCv2 (as found in Armada 370/XP SoC).
+	 */
+	enum pxa3xx_nand_variant variant;
+
+	int			cs;
+	int			use_ecc;	/* use HW ECC ? */
+	int			force_raw;	/* prevent use_ecc to be set */
+	int			ecc_bch;	/* using BCH ECC? */
+	int			use_spare;	/* use spare ? */
+	int			need_wait;
+
+	/* Amount of real data per full chunk */
+	unsigned int		chunk_size;
+
+	/* Amount of spare data per full chunk */
+	unsigned int		spare_size;
+
+	/* Number of full chunks (i.e chunk_size + spare_size) */
+	unsigned int            nfullchunks;
+
+	/*
+	 * Total number of chunks. If equal to nfullchunks, then there
+	 * are only full chunks. Otherwise, there is one last chunk of
+	 * size (last_chunk_size + last_spare_size)
+	 */
+	unsigned int            ntotalchunks;
+
+	/* Amount of real data in the last chunk */
+	unsigned int		last_chunk_size;
+
+	/* Amount of spare data in the last chunk */
+	unsigned int		last_spare_size;
+
+	unsigned int		ecc_size;
+	unsigned int		ecc_err_cnt;
+	unsigned int		max_bitflips;
+	int			retcode;
+
+	/*
+	 * Variables only valid during command
+	 * execution. step_chunk_size and step_spare_size is the
+	 * amount of real data and spare data in the current
+	 * chunk. cur_chunk is the current chunk being
+	 * read/programmed.
+	 */
+	unsigned int		step_chunk_size;
+	unsigned int		step_spare_size;
+	unsigned int            cur_chunk;
+
+	/* cached register value */
+	uint32_t		reg_ndcr;
+	uint32_t		ndtr0cs0;
+	uint32_t		ndtr1cs0;
+
+	/* generated NDCBx register values */
+	uint32_t		ndcb0;
+	uint32_t		ndcb1;
+	uint32_t		ndcb2;
+	uint32_t		ndcb3;
+
+	/* SOC related registers for nand */
+	void __iomem		*nand_flash_clk_ctrl_reg;
+	void __iomem		*soc_dev_multiplex_reg;
+};
+
 #endif /* __ASM_ARCH_PXA3XX_NAND_H */
diff --git a/drivers/mtd/spi/spi-nor-core.c b/drivers/mtd/spi/spi-nor-core.c
old mode 100644
new mode 100755
index 990e39d7c2..649859113a
--- a/drivers/mtd/spi/spi-nor-core.c
+++ b/drivers/mtd/spi/spi-nor-core.c
@@ -612,18 +612,26 @@ static void stm_get_locked_range(struct spi_nor *nor, u8 sr, loff_t *ofs,
 	int shift = ffs(mask) - 1;
 	int pow;
 
+	if (!strcmp(mtd->name, "mt25ql02g"))
+		mask |= SR_BP3;
+
 	if (!(sr & mask)) {
 		/* No protection */
 		*ofs = 0;
 		*len = 0;
 	} else {
 		pow = ((sr & mask) ^ mask) >> shift;
-		*len = mtd->size >> pow;
+		*len = mtd->size >> (pow - 2);
 		if (nor->flags & SNOR_F_HAS_SR_TB && sr & SR_TB)
 			*ofs = 0;
 		else
 			*ofs = mtd->size - *len;
+		if (!strcmp(mtd->name, "mt25ql02g"))
+			*ofs = 0;
+		debug("%s sr %x shift %x mask %x xor %x pow %x\n", __func__,
+		      sr, shift, mask, (sr & mask) ^ mask, pow);
 	}
+	debug("%s ofs %llx len %llx\n", __func__, *ofs, *len);
 }
 
 /*
@@ -640,7 +648,9 @@ static int stm_check_lock_status_sr(struct spi_nor *nor, loff_t ofs, u64 len,
 		return 1;
 
 	stm_get_locked_range(nor, sr, &lock_offs, &lock_len);
-
+	debug("%s ofs %llx len %llx\n", __func__, ofs, len);
+	debug("%s lock_offs %llx lock_len %llx\n", __func__, lock_offs,
+	      lock_len);
 	if (locked)
 		/* Requested range is a sub-range of locked range */
 		return (ofs + len <= lock_offs + lock_len) && (ofs >= lock_offs);
@@ -707,6 +717,16 @@ static int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 	if (status_old < 0)
 		return status_old;
 
+	/* For this flash device, BP3 of status is in position 6 instead of 5
+	 * so move it to fall inline with mask
+	 */
+	if (!strcmp(mtd->name, "mt25ql02g")) {
+		u8 reg = status_old;
+
+		mask |= SR_BP3;
+		status_old = ((reg & BIT(6)) >> 1) | (reg & ~BIT(5));
+		debug("%s SRO %x\n", __func__, status_old);
+	}
 	/* If nothing in our range is unlocked, we don't need to do anything */
 	if (stm_is_locked_sr(nor, ofs, len, status_old))
 		return 0;
@@ -715,6 +735,9 @@ static int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 	if (!stm_is_locked_sr(nor, 0, ofs, status_old))
 		can_be_bottom = false;
 
+	debug("%s ofs %llx len %llx\n", __func__, ofs, len);
+	debug("%s 1ofs %llx 1len %llx\n", __func__, ofs + len,
+	      mtd->size - ofs - len);
 	/* If anything above us is unlocked, we can't use 'top' protection */
 	if (!stm_is_locked_sr(nor, ofs + len, mtd->size - (ofs + len),
 			      status_old))
@@ -725,6 +748,8 @@ static int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 
 	/* Prefer top, if both are valid */
 	use_top = can_be_top;
+	if (!strcmp(mtd->name, "mt25ql02g"))
+		use_top = false;
 
 	/* lock_len: length of region that should end up locked */
 	if (use_top)
@@ -742,29 +767,56 @@ static int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 	 *   pow = ceil(log2(size / len)) = log2(size) - floor(log2(len))
 	 */
 	pow = ilog2(mtd->size) - ilog2(lock_len);
-	val = mask - (pow << shift);
+	val = mask - ((pow + 1) << shift);
 	if (val & ~mask)
 		return -EINVAL;
+	debug("%s val %x mask %x pow %x shift %x\n", __func__, val, mask, pow,
+	      shift);
+
 	/* Don't "lock" with no region! */
 	if (!(val & mask))
 		return -EINVAL;
 
-	status_new = (status_old & ~mask & ~SR_TB) | val;
+	/* For this flash device, BP3 of mask is in position 5 instead of 6
+	 * so move it to fall inline with register bits
+	 */
+	if (!strcmp(mtd->name, "mt25ql02g")) {
+		u8 reg;
 
-	/* Disallow further writes if WP pin is asserted */
-	status_new |= SR_SRWD;
+		status_new = (status_old & ~mask) | val;
 
-	if (!use_top)
-		status_new |= SR_TB;
+		/* Only modify protection if it will not unlock other areas */
+		if ((status_new & mask) < (status_old & mask))
+			return -EINVAL;
 
-	/* Don't bother if they're the same */
-	if (status_new == status_old)
-		return 0;
+		reg = status_new;
+		status_new = ((reg & BIT(5)) << 1) | (reg & ~BIT(6));
 
-	/* Only modify protection if it will not unlock other areas */
-	if ((status_new & mask) < (status_old & mask))
-		return -EINVAL;
+		/* Disallow further writes if WP pin is asserted */
+		status_new |= SR_SRWD;
+
+		if (!use_top)
+			status_new |= SR_TB;
+
+		mask = BIT(6) | SR_BP2 | SR_BP1 | SR_BP0;
+	} else {
+		status_new = (status_old & ~mask & ~SR_TB) | val;
+
+		/* Disallow further writes if WP pin is asserted */
+		status_new |= SR_SRWD;
 
+		if (!use_top)
+			status_new |= SR_TB;
+
+		/* Don't bother if they're the same */
+		if (status_new == status_old)
+			return 0;
+
+		/* Only modify protection if it will not unlock other areas */
+		if ((status_new & mask) < (status_old & mask))
+			return -EINVAL;
+	}
+	debug("%s SRN %x mask %x\n", __func__, status_new, mask);
 	return write_sr_and_check(nor, status_new, mask);
 }
 
@@ -787,6 +839,17 @@ static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 	if (status_old < 0)
 		return status_old;
 
+	/* For this flash device, BP3 of status is in position 6 instead of 5
+	 * so move it to fall inline with mask
+	 */
+	if (!strcmp(mtd->name, "mt25ql02g")) {
+		u8 reg = status_old;
+
+		mask |= SR_BP3;
+		status_old = ((reg & BIT(6)) >> 1) | (reg & ~BIT(5));
+		debug("%s SRO %x\n", __func__, status_old);
+	}
+
 	/* If nothing in our range is locked, we don't need to do anything */
 	if (stm_is_unlocked_sr(nor, ofs, len, status_old))
 		return 0;
@@ -805,6 +868,8 @@ static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 
 	/* Prefer top, if both are valid */
 	use_top = can_be_top;
+	if (!strcmp(mtd->name, "mt25ql02g"))
+		use_top = false;
 
 	/* lock_len: length of region that should remain locked */
 	if (use_top)
@@ -822,32 +887,63 @@ static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 	 *   pow = floor(log2(size / len)) = log2(size) - ceil(log2(len))
 	 */
 	pow = ilog2(mtd->size) - order_base_2(lock_len);
+	debug("%s il1 %x il2 %x\n", __func__, ilog2(mtd->size),
+	      order_base_2(lock_len));
 	if (lock_len == 0) {
 		val = 0; /* fully unlocked */
 	} else {
 		val = mask - (pow << shift);
+		debug("%s val %x mask %x po %x\n", __func__, val, mask,
+		      pow << shift);
 		/* Some power-of-two sizes are not supported */
 		if (val & ~mask)
 			return -EINVAL;
 	}
+	debug("%s val %x mask %x\n", __func__, val, mask);
+	/* For this flash device, BP3 of mask is in position 5 instead of 6
+	 * so move it to fall inline with register bits
+	 */
+	if (!strcmp(mtd->name, "mt25ql02g")) {
+		u8 reg;
 
-	status_new = (status_old & ~mask & ~SR_TB) | val;
+		status_new = (status_old & ~mask) | val;
 
-	/* Don't protect status register if we're fully unlocked */
-	if (lock_len == 0)
-		status_new &= ~SR_SRWD;
+		/* Only modify protection if it will not unlock other areas */
+		if ((status_new & mask) > (status_old & mask))
+			return -EINVAL;
 
-	if (!use_top)
-		status_new |= SR_TB;
+		reg = status_new;
+		status_new = ((reg & BIT(5)) << 1) | (reg & ~BIT(6));
+		status_new &= ~SR_TB;
 
-	/* Don't bother if they're the same */
-	if (status_new == status_old)
-		return 0;
+		/* Don't protect status register if we're fully unlocked */
+		if (lock_len == 0)
+			status_new &= ~SR_SRWD;
 
-	/* Only modify protection if it will not lock other areas */
-	if ((status_new & mask) > (status_old & mask))
-		return -EINVAL;
+		if (!use_top)
+			status_new |= SR_TB;
+
+		mask = BIT(6) | SR_BP2 | SR_BP1 | SR_BP0;
+	} else {
+		status_new = (status_old & ~mask & ~SR_TB) | val;
 
+		/* Don't protect status register if we're fully unlocked */
+		if (lock_len == 0)
+			status_new &= ~SR_SRWD;
+
+		if (!use_top)
+			status_new |= SR_TB;
+
+		/* Don't bother if they're the same */
+		if (status_new == status_old)
+			return 0;
+
+		/* Only modify protection if it will not lock other areas */
+		if ((status_new & mask) > (status_old & mask))
+			return -EINVAL;
+	}
+
+	debug("%s SRN %x mask %x\n", __func__, status_new, mask);
 	return write_sr_and_check(nor, status_new, mask);
 }
 
@@ -861,11 +957,18 @@ static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)
 static int stm_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)
 {
 	int status;
+	struct mtd_info *mtd = &nor->mtd;
 
 	status = read_sr(nor);
 	if (status < 0)
 		return status;
 
+	/* For this flash device, BP3 is in position 6 instead of 5
+	 * so move it to fall inline with mask
+	 */
+	if (!strcmp(mtd->name, "mt25ql02g"))
+		status = ((status & BIT(6)) >> 1) | (status & ~BIT(5));
+
 	return stm_is_locked_sr(nor, ofs, len, status);
 }
 #endif /* CONFIG_SPI_FLASH_STMICRO */
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index 6996c0a286..8506a9fdf7 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -136,19 +136,22 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("mx25l8005",   0xc22014, 0, 64 * 1024,  16, 0) },
 	{ INFO("mx25l1606e",  0xc22015, 0, 64 * 1024,  32, SECT_4K) },
 	{ INFO("mx25l3205d",  0xc22016, 0, 64 * 1024,  64, SECT_4K) },
-	{ INFO("mx25l6405d",  0xc22017, 0, 64 * 1024, 128, SECT_4K) },
+	{ INFO("mx25l6433f",  0xc22017, 0, 64 * 1024, 128,
+			 SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25u2033e",  0xc22532, 0, 64 * 1024,   4, SECT_4K) },
 	{ INFO("mx25u1635e",  0xc22535, 0, 64 * 1024,  32, SECT_4K) },
+	{ INFO("mx25u3235f",  0xc22536, 0, 64 * 1024,  64, SECT_4K) },
 	{ INFO("mx25u6435f",  0xc22537, 0, 64 * 1024, 128, SECT_4K) },
-	{ INFO("mx25l12805d", 0xc22018, 0, 64 * 1024, 256, 0) },
+	{ INFO("mx25l12845g", 0xc22018, 0, 64 * 1024, 256,
+			 SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("mx25l12855e", 0xc22618, 0, 64 * 1024, 256, 0) },
-	{ INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx25u25635f", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx25l25655e", 0xc22619, 0, 64 * 1024, 512, 0) },
 	{ INFO("mx66l51235l", 0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx66u51235f", 0xc2253a, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx66u2g45g",  0xc2253c, 0, 64 * 1024, 4096, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("mx66l1g45g",  0xc2201b, 0, 64 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("mx66l1g45g",  0xc2201b, 0, 64 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("mx25l1633e", 0xc22415, 0, 64 * 1024,   32, SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | SECT_4K) },
 #endif
 
@@ -168,8 +171,9 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("n25q512a",    0x20bb20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("n25q512ax3",  0x20ba20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 	{ INFO("n25q00",      0x20ba21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
-	{ INFO("n25q00a",     0x20bb21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
+	{ INFO("n25q00a",     0x20bb21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE | SPI_NOR_4B_OPCODES) },
 	{ INFO("mt25qu02g",   0x20bb22, 0, 64 * 1024, 4096, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
+	{ INFO("mt25ql02g",   0x20ba22, 0, 64 * 1024, 4096, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE | SPI_NOR_4B_OPCODES | SPI_NOR_HAS_TB) },
 	{ INFO("mt35xu512aba", 0x2c5b1a, 0,  128 * 1024,  512, USE_FSR | SPI_NOR_4B_OPCODES) },
 	{ INFO("mt35xu02g",  0x2c5b1c, 0, 128 * 1024,  2048, USE_FSR | SPI_NOR_4B_OPCODES) },
 #endif
@@ -180,7 +184,9 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("s25sl032p",  0x010215, 0x4d00,  64 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("s25sl064p",  0x010216, 0x4d00,  64 * 1024, 128, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("s25fl256s0", 0x010219, 0x4d00, 256 * 1024, 128, USE_CLSR) },
-	{ INFO("s25fl256s1", 0x010219, 0x4d01,  64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
+	{ INFO("s25fl256s1", 0x010219, 0x4d01,  64 * 1024, 512,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR |
+			SPI_NOR_4B_OPCODES) },
 	{ INFO6("s25fl512s",  0x010220, 0x4d0081, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
 	{ INFO("s25fl512s_256k",  0x010220, 0x4d00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
 	{ INFO("s25fl512s_64k",  0x010220, 0x4d01, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
@@ -297,7 +303,8 @@ const struct flash_info spi_nor_ids[] = {
 	{ INFO("w25q16cl", 0xef4015, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("w25q64cv", 0xef4017, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ INFO("w25q128", 0xef4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K |
+		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
 #endif
 #ifdef CONFIG_SPI_FLASH_XMC
 	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2ce3092db0..5ffac849d8 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -297,6 +297,8 @@ config MVNETA
 config MVPP2
 	bool "Marvell Armada 375/7K/8K network interface support"
 	depends on ARMADA_375 || ARMADA_8K
+	select DM_MDIO
+	select MVMDIO
 	select PHYLIB
 	help
 	  This driver supports the network interface units in the
@@ -326,6 +328,36 @@ config MT7628_ETH
 	  The MediaTek MT7628 ethernet interface is used on MT7628 and
 	  MT7688 based boards.
 
+config NET_OCTEONTX
+	bool "OcteonTX Ethernet support"
+	depends on ARCH_OCTEONTX
+	help
+	  You must select Y to enable network device support for
+	  OcteonTX SoCs. If unsure, say n
+
+config NET_OCTEONTX2
+	bool "OcteonTX2 Ethernet support"
+	depends on ARCH_OCTEONTX2
+	select OCTEONTX2_CGX_INTF
+	help
+	  You must select Y to enable network device support for
+	  OcteonTX2 SoCs. If unsure, say n
+
+config OCTEONTX_SMI
+	bool "OcteonTX SMI Device support"
+	depends on ARCH_OCTEONTX || ARCH_OCTEONTX2
+	help
+	  You must select Y to enable SMI controller support for
+	  OcteonTX or OcteonTX2 SoCs. If unsure, say n
+
+config OCTEONTX2_CGX_INTF
+	bool "OcteonTX2 CGX ATF interface support"
+	depends on ARCH_OCTEONTX2
+	default y if ARCH_OCTEONTX2
+	help
+	  You must select Y to enable CGX ATF interface support for
+	  OcteonTX2 SoCs. If unsure, say n
+
 config PCH_GBE
 	bool "Intel Platform Controller Hub EG20T GMAC driver"
 	depends on DM_ETH && DM_PCI
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 30991834ec..5555594ce4 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -62,6 +62,10 @@ obj-$(CONFIG_RENESAS_RAVB) += ravb.o
 obj-$(CONFIG_SMC91111) += smc91111.o
 obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_TSEC_ENET) += tsec.o fsl_mdio.o
+obj-$(CONFIG_NET_OCTEONTX) += octeontx/
+obj-$(CONFIG_NET_OCTEONTX2) += octeontx2/
+obj-$(CONFIG_OCTEONTX_SMI) += octeontx/smi.o
+obj-$(CONFIG_OCTEONTX2_CGX_INTF) += octeontx2/cgx_intf.o
 obj-$(CONFIG_FMAN_ENET) += fsl_mdio.o
 obj-$(CONFIG_ULI526X) += uli526x.o
 obj-$(CONFIG_VSC7385_ENET) += vsc7385.o
diff --git a/drivers/net/e1000.c b/drivers/net/e1000.c
index a34f697461..2a5d09d143 100644
--- a/drivers/net/e1000.c
+++ b/drivers/net/e1000.c
@@ -4571,11 +4571,21 @@ e1000_get_phy_cfg_done(struct e1000_hw *hw)
 			mdelay(1);
 			timeout--;
 		}
+
 		if (!timeout) {
 			DEBUGOUT("MNG configuration cycle has not "
 					"completed.\n");
-			return -E1000_ERR_RESET;
+			/*
+			 * Temporarely WA for PHY HW reset timeout on
+			 * MACCHIATOBin board.
+			 * The reason for the timeout is unknown, adding
+			 * delays before and after PCIe reset line release
+			 * did not help to solve the issue.
+			 *
+			 * return -E1000_ERR_RESET;
+			 */
 		}
+
 		break;
 	}
 
@@ -5139,7 +5149,7 @@ fill_rx(struct e1000_hw *hw)
 	rd = rx_base + rx_tail;
 	rx_tail = (rx_tail + 1) % 8;
 	memset(rd, 0, 16);
-	rd->buffer_addr = cpu_to_le64((unsigned long)packet);
+	rd->buffer_addr = cpu_to_le64((uintptr_t)packet);
 
 	/*
 	 * Make sure there are no stale data in WB over this area, which
@@ -5228,7 +5238,6 @@ e1000_configure_tx(struct e1000_hw *hw)
 		E1000_WRITE_REG(hw, TARC1, tarc);
 	}
 
-
 	e1000_config_collision_dist(hw);
 	/* Setup Transmit Descriptor Settings for eop descriptor */
 	hw->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;
@@ -5239,7 +5248,6 @@ e1000_configure_tx(struct e1000_hw *hw)
 	else
 		hw->txd_cmd |= E1000_TXD_CMD_RS;
 
-
 	if (hw->mac_type == e1000_igb) {
 		E1000_WRITE_REG(hw, TCTL_EXT, 0x42 << 10);
 
@@ -5249,11 +5257,7 @@ e1000_configure_tx(struct e1000_hw *hw)
 		mdelay(20);
 	}
 
-
-
 	E1000_WRITE_REG(hw, TCTL, tctl);
-
-
 }
 
 /**
@@ -5358,7 +5362,7 @@ _e1000_poll(struct e1000_hw *hw)
 
 	if (!(rd->status & E1000_RXD_STAT_DD))
 		return 0;
-	/* DEBUGOUT("recv: packet len=%d\n", rd->length); */
+	DEBUGOUT("recv: packet len=%d\n", rd->length);
 	/* Packet received, make sure the data are re-loaded from RAM. */
 	len = le16_to_cpu(rd->length);
 	invalidate_dcache_range((unsigned long)packet,
@@ -5551,8 +5555,7 @@ static int e1000_init_one(struct e1000_hw *hw, int cardnum, pci_dev_t devno,
 	hw->eeprom_semaphore_present = true;
 #endif
 #ifdef CONFIG_DM_ETH
-	hw->hw_addr = dm_pci_map_bar(devno,	PCI_BASE_ADDRESS_0,
-						PCI_REGION_MEM);
+	hw->hw_addr = dm_pci_map_bar(devno, PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
 #else
 	hw->hw_addr = pci_map_bar(devno,	PCI_BASE_ADDRESS_0,
 						PCI_REGION_MEM);
diff --git a/drivers/net/mvneta.c b/drivers/net/mvneta.c
index 333be8ff28..c1961bc562 100644
--- a/drivers/net/mvneta.c
+++ b/drivers/net/mvneta.c
@@ -519,8 +519,17 @@ static void mvneta_rxq_desc_num_update(struct mvneta_port *pp,
 static struct mvneta_rx_desc *
 mvneta_rxq_next_desc_get(struct mvneta_rx_queue *rxq)
 {
+	struct mvneta_rx_desc *curr;
 	int rx_desc = rxq->next_desc_to_proc;
 
+	/* validate RX descriptor */
+	curr = rxq->descs + rx_desc;
+	if (curr->data_size == 0) {
+		/* do it to read real descriptor next time */
+		DSB;
+		return NULL;
+	}
+
 	rxq->next_desc_to_proc = MVNETA_QUEUE_NEXT_DESC(rxq, rx_desc);
 	return rxq->descs + rx_desc;
 }
@@ -1647,11 +1656,15 @@ static int mvneta_recv(struct udevice *dev, int flags, uchar **packetp)
 		 */
 		rx_desc = mvneta_rxq_next_desc_get(rxq);
 
+		if (!rx_desc)
+			return 0;
+
 		rx_status = rx_desc->status;
 		if (!mvneta_rxq_desc_is_first_last(rx_status) ||
 		    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {
 			mvneta_rx_error(pp, rx_desc);
-			/* leave the descriptor untouched */
+			/* invalidate the descriptor */
+			rx_desc->data_size = 0;
 			return -EIO;
 		}
 
@@ -1671,6 +1684,8 @@ static int mvneta_recv(struct udevice *dev, int flags, uchar **packetp)
 		 * since only one was processed
 		 */
 		mvneta_rxq_desc_num_update(pp, rxq, 1, 1);
+		/* invalidate the descriptor */
+		rx_desc->data_size = 0;
 	}
 
 	return rx_bytes;
diff --git a/drivers/net/mvpp2.c b/drivers/net/mvpp2.c
index bd89725e77..7c00c88787 100644
--- a/drivers/net/mvpp2.c
+++ b/drivers/net/mvpp2.c
@@ -13,25 +13,26 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <asm-generic/gpio.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <asm/io.h>
 #include <common.h>
+#include <config.h>
 #include <dm.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#include <fdt_support.h>
+#include <linux/compat.h>
+#include <linux/errno.h>
+#include <linux/mbus.h>
+#include <linux/mdio.h>
+#include <malloc.h>
+#include <miiphy.h>
 #include <net.h>
 #include <netdev.h>
-#include <config.h>
-#include <malloc.h>
-#include <asm/io.h>
-#include <linux/errno.h>
 #include <phy.h>
-#include <miiphy.h>
 #include <watchdog.h>
-#include <asm/arch/cpu.h>
-#include <asm/arch/soc.h>
-#include <linux/compat.h>
-#include <linux/mbus.h>
-#include <asm-generic/gpio.h>
-#include <fdt_support.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -62,7 +63,24 @@ do {									\
 #define MTU			1500
 #define RX_BUFFER_SIZE		(ALIGN(MTU + WRAP, ARCH_DMA_MINALIGN))
 
-#define MVPP2_SMI_TIMEOUT			10000
+/* Common PHY */
+#define COMPHY_TRX_TRAIN_CTRL_REG_0_OFFS	0xA2C
+#define COMPHY_TRX_TRAIN_COMPHY_OFFS		0x1000
+#define COMPHY_TRX_TRAIN_RX_TRAIN_ENABLE	0x1
+#define COMPHY_TRX_RELATIVE_ADDR(comphy_num)				      \
+				  (priv->sdip_base +			      \
+				   COMPHY_TRX_TRAIN_CTRL_REG_0_OFFS +	      \
+				   (comphy_num) * COMPHY_TRX_TRAIN_COMPHY_OFFS)
+
+#define COMPHY_SEL_REG_OFFS			0x140
+#define COMPHY2_SEL_BIT_OFFS			8
+#define COMPHY4_SEL_BIT_OFFS			16
+#define COMPHY2_SEL_MASK			0xF00
+#define COMPHY4_SEL_MASK			0xF000
+#define COMPHY2_MODE_CHECK(val)						      \
+			(((val) & COMPHY2_SEL_MASK) >> COMPHY2_SEL_BIT_OFFS)
+#define COMPHY4_MODE_CHECK(val)						      \
+			(((val) & COMPHY4_SEL_MASK) >> COMPHY4_SEL_BIT_OFFS)
 
 /* RX Fifo Registers */
 #define MVPP2_RX_DATA_FIFO_SIZE_REG(port)	(0x00 + 4 * (port))
@@ -413,8 +431,6 @@ do {									\
 #define      MVPP22_XLG_CTRL3_MACMODESELECT_10GMAC	(1 << 13)
 /* Port Mac Control4 */
 #define MVPP22_XLG_CTRL4_REG			0x184
-#define      MVPP22_XLG_FORWARD_802_3X_FC_EN	BIT(5)
-#define      MVPP22_XLG_FORWARD_PFC_EN		BIT(6)
 #define      MVPP22_XLG_MODE_DMA_1G		BIT(12)
 #define      MVPP22_XLG_EN_IDLE_CHECK_FOR_LINK	BIT(14)
 
@@ -481,32 +497,14 @@ do {									\
 #define MVPP22_SMI_MISC_CFG_REG			(MVPP22_SMI + 0x04)
 #define      MVPP22_SMI_POLLING_EN		BIT(10)
 
-#define MVPP22_SMI_PHY_ADDR_REG(port)		(MVPP22_SMI + 0x04 + \
-						 (0x4 * (port)))
-
 #define MVPP2_CAUSE_TXQ_SENT_DESC_ALL_MASK	0xff
 
 /* Descriptor ring Macros */
 #define MVPP2_QUEUE_NEXT_DESC(q, index) \
 	(((index) < (q)->last_desc) ? ((index) + 1) : 0)
 
-/* SMI: 0xc0054 -> offset 0x54 to lms_base */
-#define MVPP21_SMI				0x0054
 /* PP2.2: SMI: 0x12a200 -> offset 0x1200 to iface_base */
 #define MVPP22_SMI				0x1200
-#define     MVPP2_PHY_REG_MASK			0x1f
-/* SMI register fields */
-#define     MVPP2_SMI_DATA_OFFS			0	/* Data */
-#define     MVPP2_SMI_DATA_MASK			(0xffff << MVPP2_SMI_DATA_OFFS)
-#define     MVPP2_SMI_DEV_ADDR_OFFS		16	/* PHY device address */
-#define     MVPP2_SMI_REG_ADDR_OFFS		21	/* PHY device reg addr*/
-#define     MVPP2_SMI_OPCODE_OFFS		26	/* Write/Read opcode */
-#define     MVPP2_SMI_OPCODE_READ		(1 << MVPP2_SMI_OPCODE_OFFS)
-#define     MVPP2_SMI_READ_VALID		(1 << 27)	/* Read Valid */
-#define     MVPP2_SMI_BUSY			(1 << 28)	/* Busy */
-
-#define     MVPP2_PHY_ADDR_MASK			0x1f
-#define     MVPP2_PHY_REG_MASK			0x1f
 
 /* Additional PPv2.2 offsets */
 #define MVPP22_MPCS				0x007000
@@ -526,8 +524,9 @@ do {									\
 /* Net Complex */
 enum mv_netc_topology {
 	MV_NETC_GE_MAC2_SGMII		=	BIT(0),
-	MV_NETC_GE_MAC3_SGMII		=	BIT(1),
-	MV_NETC_GE_MAC3_RGMII		=	BIT(2),
+	MV_NETC_GE_MAC2_RGMII		=	BIT(1),
+	MV_NETC_GE_MAC3_SGMII		=	BIT(2),
+	MV_NETC_GE_MAC3_RGMII		=	BIT(3),
 };
 
 enum mv_netc_phase {
@@ -902,6 +901,8 @@ struct mvpp2 {
 	void __iomem *xpcs_base;
 	void __iomem *rfu1_base;
 
+	void __iomem *sdip_base;
+
 	u32 netc_config;
 
 	/* List of pointers to port structures */
@@ -952,7 +953,6 @@ struct mvpp2_port {
 
 	/* Per-port registers' base address */
 	void __iomem *base;
-	void __iomem *mdio_base;
 
 	struct mvpp2_rx_queue **rxqs;
 	struct mvpp2_tx_queue **txqs;
@@ -973,9 +973,8 @@ struct mvpp2_port {
 
 	struct phy_device *phy_dev;
 	phy_interface_t phy_interface;
-	int phy_node;
 	int phyaddr;
-	struct mii_dev *bus;
+	struct udevice *mdio_dev;
 #ifdef CONFIG_DM_GPIO
 	struct gpio_desc phy_reset_gpio;
 	struct gpio_desc phy_tx_disable_gpio;
@@ -985,8 +984,6 @@ struct mvpp2_port {
 	unsigned int duplex;
 	unsigned int speed;
 
-	unsigned int phy_speed;		/* SGMII 1Gbps vs 2.5Gbps */
-
 	struct mvpp2_bm_pool *pool_long;
 	struct mvpp2_bm_pool *pool_short;
 
@@ -1586,7 +1583,6 @@ static void mvpp2_prs_sram_ai_update(struct mvpp2_prs_entry *pe,
 	int ai_off = MVPP2_PRS_SRAM_AI_OFFS;
 
 	for (i = 0; i < MVPP2_PRS_SRAM_AI_CTRL_BITS; i++) {
-
 		if (!(mask & BIT(i)))
 			continue;
 
@@ -2636,7 +2632,8 @@ static int mvpp2_bm_pool_destroy(struct udevice *dev,
 
 	mvpp2_bm_bufs_free(dev, priv, bm_pool);
 	if (bm_pool->buf_num) {
-		dev_err(dev, "cannot free all buffers in pool %d\n", bm_pool->id);
+		dev_err(dev, "cannot free all buffers in pool %d\n",
+			bm_pool->id);
 		return 0;
 	}
 
@@ -2790,7 +2787,6 @@ static int mvpp2_bm_bufs_add(struct mvpp2_port *port,
 		mvpp2_bm_pool_put(port, bm_pool->id,
 				  (dma_addr_t)buffer_loc.rx_buffer[i],
 				  (unsigned long)buffer_loc.rx_buffer[i]);
-
 	}
 
 	/* Update BM driver with number of buffers added to pool */
@@ -2882,8 +2878,13 @@ static void mvpp2_port_mii_set(struct mvpp2_port *port)
 
 	switch (port->phy_interface) {
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_SGMII_2500:
 		val |= MVPP2_GMAC_INBAND_AN_MASK;
 		break;
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
+		val &= ~MVPP2_GMAC_INBAND_AN_MASK;
+		break;
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 		val |= MVPP2_GMAC_PORT_RGMII_MASK;
@@ -2944,7 +2945,10 @@ static void mvpp2_port_loopback_set(struct mvpp2_port *port)
 	else
 		val &= ~MVPP2_GMAC_GMII_LB_EN_MASK;
 
-	if (port->phy_interface == PHY_INTERFACE_MODE_SGMII)
+	if (port->phy_interface == PHY_INTERFACE_MODE_SGMII ||
+	    port->phy_interface == PHY_INTERFACE_MODE_SGMII_2500 ||
+	    port->phy_interface == PHY_INTERFACE_MODE_1000BASEX ||
+	    port->phy_interface == PHY_INTERFACE_MODE_2500BASEX)
 		val |= MVPP2_GMAC_PCS_LB_EN_MASK;
 	else
 		val &= ~MVPP2_GMAC_PCS_LB_EN_MASK;
@@ -3055,10 +3059,10 @@ static void gop_gmac_sgmii2_5_cfg(struct mvpp2_port *port)
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
 	/*
-	 * Configure GIG MAC to 1000Base-X mode connected to a fiber
+	 * Configure GIG MAC to SGMII mode connected to a fiber
 	 * transceiver
 	 */
-	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	val &= ~MVPP2_GMAC_PORT_TYPE_MASK;
 	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
 
 	/* configure AN 0x9268 */
@@ -3110,6 +3114,91 @@ static void gop_gmac_sgmii_cfg(struct mvpp2_port *port)
 	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 }
 
+static void gop_gmac_2500basex_cfg(struct mvpp2_port *port)
+{
+	u32 val, thresh;
+
+	/*
+	 * Configure minimal level of the Tx FIFO before the lower part
+	 * starts to read a packet
+	 */
+	thresh = MVPP2_SGMII2_5_TX_FIFO_MIN_TH;
+	val = readl(port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+	val &= ~MVPP2_GMAC_TX_FIFO_MIN_TH_ALL_MASK;
+	val |= MVPP2_GMAC_TX_FIFO_MIN_TH_MASK(thresh);
+	writel(val, port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+
+	/* Disable bypass of sync module */
+	val = readl(port->base + MVPP2_GMAC_CTRL_4_REG);
+	val |= MVPP2_GMAC_CTRL4_SYNC_BYPASS_MASK;
+	/* configure DP clock select according to mode */
+	val |= MVPP2_GMAC_CTRL4_DP_CLK_SEL_MASK;
+	/* configure QSGMII bypass according to mode */
+	val |= MVPP2_GMAC_CTRL4_QSGMII_BYPASS_ACTIVE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_4_REG);
+
+	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
+	/*
+	 * Configure GIG MAC to 2500Base-X mode connected to a fiber
+	 * transceiver
+	 */
+	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
+
+	/* In 2500BaseX mode, we can't negotiate speed
+	 * and we do not want InBand autoneg
+	 * bypass enabled (link interrupt storm risk
+	 * otherwise).
+	 */
+	val = MVPP2_GMAC_AN_BYPASS_EN |
+		MVPP2_GMAC_EN_PCS_AN |
+		MVPP2_GMAC_CONFIG_GMII_SPEED  |
+		MVPP2_GMAC_CONFIG_FULL_DUPLEX |
+		MVPP2_GMAC_CHOOSE_SAMPLE_TX_CONFIG;
+	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
+}
+
+static void gop_gmac_1000basex_cfg(struct mvpp2_port *port)
+{
+	u32 val, thresh;
+
+	/*
+	 * Configure minimal level of the Tx FIFO before the lower part
+	 * starts to read a packet
+	 */
+	thresh = MVPP2_SGMII_TX_FIFO_MIN_TH;
+	val = readl(port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+	val &= ~MVPP2_GMAC_TX_FIFO_MIN_TH_ALL_MASK;
+	val |= MVPP2_GMAC_TX_FIFO_MIN_TH_MASK(thresh);
+	writel(val, port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+
+	/* Disable bypass of sync module */
+	val = readl(port->base + MVPP2_GMAC_CTRL_4_REG);
+	val |= MVPP2_GMAC_CTRL4_SYNC_BYPASS_MASK;
+	/* configure DP clock select according to mode */
+	val &= ~MVPP2_GMAC_CTRL4_DP_CLK_SEL_MASK;
+	/* configure QSGMII bypass according to mode */
+	val |= MVPP2_GMAC_CTRL4_QSGMII_BYPASS_ACTIVE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_4_REG);
+
+	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
+	/* configure GIG MAC to 1000BASEX mode */
+	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
+
+	/* In 1000BaseX mode, we can't negotiate speed (it's
+	 * only 1000), and we do not want InBand autoneg
+	 * bypass enabled (link interrupt storm risk
+	 * otherwise).
+	 */
+	val = MVPP2_GMAC_AN_BYPASS_EN |
+		MVPP2_GMAC_EN_PCS_AN |
+		MVPP2_GMAC_CONFIG_GMII_SPEED  |
+		MVPP2_GMAC_CONFIG_FULL_DUPLEX |
+		MVPP2_GMAC_CHOOSE_SAMPLE_TX_CONFIG;
+	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
+}
+
 static void gop_gmac_rgmii_cfg(struct mvpp2_port *port)
 {
 	u32 val, thresh;
@@ -3155,10 +3244,17 @@ static int gop_gmac_mode_cfg(struct mvpp2_port *port)
 	/* Set TX FIFO thresholds */
 	switch (port->phy_interface) {
 	case PHY_INTERFACE_MODE_SGMII:
-		if (port->phy_speed == 2500)
-			gop_gmac_sgmii2_5_cfg(port);
-		else
-			gop_gmac_sgmii_cfg(port);
+		gop_gmac_sgmii_cfg(port);
+		break;
+	case PHY_INTERFACE_MODE_SGMII_2500:
+		gop_gmac_sgmii2_5_cfg(port);
+		break;
+	case PHY_INTERFACE_MODE_1000BASEX:
+		gop_gmac_1000basex_cfg(port);
+		break;
+
+	case PHY_INTERFACE_MODE_2500BASEX:
+		gop_gmac_2500basex_cfg(port);
 		break;
 
 	case PHY_INTERFACE_MODE_RGMII:
@@ -3213,56 +3309,31 @@ static int gop_gpcs_reset(struct mvpp2_port *port, int reset)
 	return 0;
 }
 
-/* Set the internal mux's to the required PCS in the PI */
-static int gop_xpcs_mode(struct mvpp2_port *port, int num_of_lanes)
-{
-	u32 val;
-	int lane;
-
-	switch (num_of_lanes) {
-	case 1:
-		lane = 0;
-		break;
-	case 2:
-		lane = 1;
-		break;
-	case 4:
-		lane = 2;
-		break;
-	default:
-		return -1;
-	}
-
-	/* configure XG MAC mode */
-	val = readl(port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-	val &= ~MVPP22_XPCS_PCSMODE_MASK;
-	val &= ~MVPP22_XPCS_LANEACTIVE_MASK;
-	val |= (2 * lane) << MVPP22_XPCS_LANEACTIVE_OFFS;
-	writel(val, port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-
-	return 0;
-}
-
 static int gop_mpcs_mode(struct mvpp2_port *port)
 {
 	u32 val;
 
 	/* configure PCS40G COMMON CONTROL */
-	val = readl(port->priv->mpcs_base + PCS40G_COMMON_CONTROL);
+	val = readl(port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+		    PCS40G_COMMON_CONTROL);
 	val &= ~FORWARD_ERROR_CORRECTION_MASK;
-	writel(val, port->priv->mpcs_base + PCS40G_COMMON_CONTROL);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS40G_COMMON_CONTROL);
 
 	/* configure PCS CLOCK RESET */
-	val = readl(port->priv->mpcs_base + PCS_CLOCK_RESET);
+	val = readl(port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+		    PCS_CLOCK_RESET);
 	val &= ~CLK_DIVISION_RATIO_MASK;
 	val |= 1 << CLK_DIVISION_RATIO_OFFS;
-	writel(val, port->priv->mpcs_base + PCS_CLOCK_RESET);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS_CLOCK_RESET);
 
 	val &= ~CLK_DIV_PHASE_SET_MASK;
 	val |= MAC_CLK_RESET_MASK;
 	val |= RX_SD_CLK_RESET_MASK;
 	val |= TX_SD_CLK_RESET_MASK;
-	writel(val, port->priv->mpcs_base + PCS_CLOCK_RESET);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS_CLOCK_RESET);
 
 	return 0;
 }
@@ -3285,8 +3356,6 @@ static int gop_xlg_mac_mode_cfg(struct mvpp2_port *port, int num_of_act_lanes)
 	/* read - modify - write */
 	val = readl(port->base + MVPP22_XLG_CTRL4_REG);
 	val &= ~MVPP22_XLG_MODE_DMA_1G;
-	val |= MVPP22_XLG_FORWARD_PFC_EN;
-	val |= MVPP22_XLG_FORWARD_802_3X_FC_EN;
 	val &= ~MVPP22_XLG_EN_IDLE_CHECK_FOR_LINK;
 	writel(val, port->base + MVPP22_XLG_CTRL4_REG);
 
@@ -3305,22 +3374,6 @@ static int gop_xlg_mac_mode_cfg(struct mvpp2_port *port, int num_of_act_lanes)
 	return 0;
 }
 
-/* Set PCS to reset or exit from reset */
-static int gop_xpcs_reset(struct mvpp2_port *port, int reset)
-{
-	u32 val;
-
-	/* read - modify - write */
-	val = readl(port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-	if (reset)
-		val &= ~MVPP22_XPCS_PCSRESET;
-	else
-		val |= MVPP22_XPCS_PCSRESET;
-	writel(val, port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-
-	return 0;
-}
-
 /* Set the MAC to reset or exit from reset */
 static int gop_xlg_mac_reset(struct mvpp2_port *port, int reset)
 {
@@ -3375,6 +3428,9 @@ static int gop_port_init(struct mvpp2_port *port)
 		break;
 
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_SGMII_2500:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		/* configure PCS */
 		gop_gpcs_mode_cfg(port, 1);
 
@@ -3393,18 +3449,17 @@ static int gop_port_init(struct mvpp2_port *port)
 		num_of_act_lanes = 2;
 		mac_num = 0;
 		/* configure PCS */
-		gop_xpcs_mode(port, num_of_act_lanes);
 		gop_mpcs_mode(port);
 		/* configure MAC */
 		gop_xlg_mac_mode_cfg(port, num_of_act_lanes);
 
-		/* pcs unreset */
-		gop_xpcs_reset(port, 0);
-
 		/* mac unreset */
 		gop_xlg_mac_reset(port, 0);
 		break;
 
+	case PHY_INTERFACE_MODE_AP:
+		break;
+
 	default:
 		netdev_err(NULL, "%s: Requested port mode (%d) not supported\n",
 			   __func__, port->phy_interface);
@@ -3436,6 +3491,9 @@ static void gop_port_enable(struct mvpp2_port *port, int enable)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_SGMII_2500:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		if (enable)
 			mvpp2_port_enable(port);
 		else
@@ -3445,6 +3503,8 @@ static void gop_port_enable(struct mvpp2_port *port, int enable)
 	case PHY_INTERFACE_MODE_SFI:
 		gop_xlg_mac_port_enable(port, enable);
 
+		break;
+	case PHY_INTERFACE_MODE_AP:
 		break;
 	default:
 		netdev_err(NULL, "%s: Wrong port mode (%d)\n", __func__,
@@ -3469,12 +3529,21 @@ static u32 mvpp2_netc_cfg_create(int gop_id, phy_interface_t phy_type)
 	u32 val = 0;
 
 	if (gop_id == 2) {
-		if (phy_type == PHY_INTERFACE_MODE_SGMII)
+		if (phy_type == PHY_INTERFACE_MODE_SGMII ||
+		    phy_type == PHY_INTERFACE_MODE_SGMII_2500 ||
+		    phy_type == PHY_INTERFACE_MODE_1000BASEX ||
+		    phy_type == PHY_INTERFACE_MODE_2500BASEX)
 			val |= MV_NETC_GE_MAC2_SGMII;
+		else if (phy_type == PHY_INTERFACE_MODE_RGMII ||
+			 phy_type == PHY_INTERFACE_MODE_RGMII_ID)
+			val |= MV_NETC_GE_MAC2_RGMII;
 	}
 
 	if (gop_id == 3) {
-		if (phy_type == PHY_INTERFACE_MODE_SGMII)
+		if (phy_type == PHY_INTERFACE_MODE_SGMII ||
+		    phy_type == PHY_INTERFACE_MODE_SGMII_2500 ||
+		    phy_type == PHY_INTERFACE_MODE_1000BASEX ||
+		    phy_type == PHY_INTERFACE_MODE_2500BASEX)
 			val |= MV_NETC_GE_MAC3_SGMII;
 		else if (phy_type == PHY_INTERFACE_MODE_RGMII ||
 			 phy_type == PHY_INTERFACE_MODE_RGMII_ID)
@@ -3662,7 +3731,7 @@ static int gop_netc_init(struct mvpp2 *priv, enum mv_netc_phase phase)
 
 	if (c & MV_NETC_GE_MAC2_SGMII)
 		gop_netc_mac_to_sgmii(priv, 2, phase);
-	else
+	else if (c & MV_NETC_GE_MAC2_RGMII)
 		gop_netc_mac_to_xgmii(priv, 2, phase);
 
 	if (c & MV_NETC_GE_MAC3_SGMII) {
@@ -4389,7 +4458,8 @@ static void mvpp2_link_event(struct mvpp2_port *port)
 			if (phydev->duplex)
 				val |= MVPP2_GMAC_CONFIG_FULL_DUPLEX;
 
-			if (phydev->speed == SPEED_1000)
+			if (phydev->speed == SPEED_1000 ||
+			    phydev->speed == 2500)
 				val |= MVPP2_GMAC_CONFIG_GMII_SPEED;
 			else if (phydev->speed == SPEED_100)
 				val |= MVPP2_GMAC_CONFIG_MII_SPEED;
@@ -4467,6 +4537,9 @@ static void mvpp2_start_dev(struct mvpp2_port *port)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_SGMII_2500:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		mvpp2_gmac_max_rx_size_set(port);
 	default:
 		break;
@@ -4494,17 +4567,38 @@ static void mvpp2_stop_dev(struct mvpp2_port *port)
 		gop_port_enable(port, 0);
 }
 
-static int mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
+static void mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
 {
 	struct phy_device *phy_dev;
 
 	if (!port->init || port->link == 0) {
-		phy_dev = phy_connect(port->bus, port->phyaddr, dev,
-				      port->phy_interface);
+		phy_dev = dm_mdio_phy_connect(port->mdio_dev, port->phyaddr,
+					      dev, port->phy_interface);
+
+		/* If the phy doesn't match with any existing u-boot drivers the
+		 * phy framework will connect it to generic one which
+		 * uid == 0xffffffff. In this case act as if the phy wouldn't be
+		 * declared in dts. Otherwise in case of 3310 (for which the
+		 * driver doesn't exist) the link will not be correctly
+		 * detected. Removing phy entry from dts in case of 3310 is not
+		 * an option because it is required for the phy_fw_down
+		 * procedure.
+		 */
+		if (phy_dev->drv->uid == 0xffffffff) {/* Generic phy */
+			netdev_warn(port->dev,
+				    "Marking phy as invalid, link will not be checked\n");
+			/* set phy_addr to invalid value */
+			port->phyaddr = PHY_MAX_ADDR;
+			mvpp2_egress_enable(port);
+			mvpp2_ingress_enable(port);
+
+			return;
+		}
+
 		port->phy_dev = phy_dev;
 		if (!phy_dev) {
 			netdev_err(port->dev, "cannot connect to phy\n");
-			return -ENODEV;
+			return;
 		}
 		phy_dev->supported &= PHY_GBIT_FEATURES;
 		phy_dev->advertising = phy_dev->supported;
@@ -4516,18 +4610,14 @@ static int mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
 
 		phy_config(phy_dev);
 		phy_startup(phy_dev);
-		if (!phy_dev->link) {
+		if (!phy_dev->link)
 			printf("%s: No link\n", phy_dev->dev->name);
-			return -1;
-		}
-
-		port->init = 1;
+		else
+			port->init = 1;
 	} else {
 		mvpp2_egress_enable(port);
 		mvpp2_ingress_enable(port);
 	}
-
-	return 0;
 }
 
 static int mvpp2_open(struct udevice *dev, struct mvpp2_port *port)
@@ -4566,11 +4656,8 @@ static int mvpp2_open(struct udevice *dev, struct mvpp2_port *port)
 		return err;
 	}
 
-	if (port->phy_node) {
-		err = mvpp2_phy_connect(dev, port);
-		if (err < 0)
-			return err;
-
+	if (port->phyaddr < PHY_MAX_ADDR) {
+		mvpp2_phy_connect(dev, port);
 		mvpp2_link_event(port);
 	} else {
 		mvpp2_egress_enable(port);
@@ -4604,7 +4691,8 @@ static int mvpp2_port_init(struct udevice *dev, struct mvpp2_port *port)
 {
 	struct mvpp2 *priv = port->priv;
 	struct mvpp2_txq_pcpu *txq_pcpu;
-	int queue, cpu, err;
+	int queue, cpu, err, comphy_num;
+	u32 val;
 
 	if (port->first_rxq + rxq_number >
 	    MVPP2_MAX_PORTS * priv->max_port_rxqs)
@@ -4697,6 +4785,32 @@ static int mvpp2_port_init(struct udevice *dev, struct mvpp2_port *port)
 	if (err)
 		return err;
 
+	/* Force rx training on 10G port */
+	if (port->phy_interface == PHY_INTERFACE_MODE_SFI) {
+		if (port->gop_id == 2) { /* 10G port2 associated with comphy4 */
+			comphy_num = 4;
+		/* check whether COMPHY 2 or 4 is set to SFI mode */
+		} else {
+			val = readl(priv->rfu1_base + COMPHY_SEL_REG_OFFS);
+			if (COMPHY2_MODE_CHECK(val) == 1) {
+				comphy_num = 2;
+			} else if (COMPHY4_MODE_CHECK(val) == 2) {
+				comphy_num = 4;
+			} else { /* should not reach here */
+				netdev_err(port->dev,
+					   "Failed to find COMPHY lane\n");
+				return 0;
+			}
+		}
+
+		val = readl(COMPHY_TRX_RELATIVE_ADDR(comphy_num));
+		val |= COMPHY_TRX_TRAIN_RX_TRAIN_ENABLE;
+		writel(val, COMPHY_TRX_RELATIVE_ADDR(comphy_num));
+		mdelay(200);
+		val &= ~COMPHY_TRX_TRAIN_RX_TRAIN_ENABLE;
+		writel(val, COMPHY_TRX_RELATIVE_ADDR(comphy_num));
+	}
+
 	return 0;
 }
 
@@ -4708,35 +4822,35 @@ static int phy_info_parse(struct udevice *dev, struct mvpp2_port *port)
 	u32 id;
 	u32 phyaddr = 0;
 	int phy_mode = -1;
-
-	/* Default mdio_base from the same eth base */
-	if (port->priv->hw_version == MVPP21)
-		port->mdio_base = port->priv->lms_base + MVPP21_SMI;
-	else
-		port->mdio_base = port->priv->iface_base + MVPP22_SMI;
+	int fixed_link = 0;
+	int ret;
 
 	phy_node = fdtdec_lookup_phandle(gd->fdt_blob, port_node, "phy");
+	fixed_link = fdt_subnode_offset(gd->fdt_blob, port_node, "fixed-link");
 
 	if (phy_node > 0) {
-		ofnode phy_ofnode;
-		fdt_addr_t phy_base;
+		int parent;
 
-		phyaddr = fdtdec_get_int(gd->fdt_blob, phy_node, "reg", 0);
-		if (phyaddr < 0) {
-			dev_err(&pdev->dev, "could not find phy address\n");
-			return -1;
-		}
-
-		phy_ofnode = ofnode_get_parent(offset_to_ofnode(phy_node));
-		phy_base = ofnode_get_addr(phy_ofnode);
-		port->mdio_base = (void *)phy_base;
-
-		if (port->mdio_base < 0) {
-			dev_err(&pdev->dev, "could not find mdio base address\n");
-			return -1;
+		if (fixed_link != -FDT_ERR_NOTFOUND) {
+			/* phy_addr is set to invalid value for fixed links */
+			phyaddr = PHY_MAX_ADDR;
+		} else {
+			phyaddr = fdtdec_get_int(gd->fdt_blob, phy_node,
+						 "reg", 0);
+			if (phyaddr < 0) {
+				dev_err(&pdev->dev,
+					"could not find phy address\n");
+				return -1;
+			}
 		}
+		parent = fdt_parent_offset(gd->fdt_blob, phy_node);
+		ret = uclass_get_device_by_of_offset(UCLASS_MDIO, parent,
+						     &port->mdio_dev);
+		if (ret)
+			return ret;
 	} else {
-		phy_node = 0;
+		/* phy_addr is set to invalid value */
+		phyaddr = PHY_MAX_ADDR;
 	}
 
 	phy_mode_str = fdt_getprop(gd->fdt_blob, port_node, "phy-mode", NULL);
@@ -4760,21 +4874,11 @@ static int phy_info_parse(struct udevice *dev, struct mvpp2_port *port)
 			     &port->phy_tx_disable_gpio, GPIOD_IS_OUT);
 #endif
 
-	/*
-	 * ToDo:
-	 * Not sure if this DT property "phy-speed" will get accepted, so
-	 * this might change later
-	 */
-	/* Get phy-speed for SGMII 2.5Gbps vs 1Gbps setup */
-	port->phy_speed = fdtdec_get_int(gd->fdt_blob, port_node,
-					 "phy-speed", 1000);
-
 	port->id = id;
 	if (port->priv->hw_version == MVPP21)
 		port->first_rxq = port->id * rxq_number;
 	else
 		port->first_rxq = port->id * port->priv->max_port_rxqs;
-	port->phy_node = phy_node;
 	port->phy_interface = phy_mode;
 	port->phyaddr = phyaddr;
 
@@ -4873,10 +4977,12 @@ static void mvpp2_rx_fifo_init(struct mvpp2 *priv)
 			} else if (port == 1) {
 				mvpp2_write(priv,
 					    MVPP2_RX_DATA_FIFO_SIZE_REG(port),
-					    MVPP22_RX_FIFO_2_5GB_PORT_DATA_SIZE);
+					    MVPP22_RX_FIFO_2_5GB_PORT_DATA_SIZE
+					    );
 				mvpp2_write(priv,
 					    MVPP2_RX_ATTR_FIFO_SIZE_REG(port),
-					    MVPP22_RX_FIFO_2_5GB_PORT_ATTR_SIZE);
+					    MVPP22_RX_FIFO_2_5GB_PORT_ATTR_SIZE
+					    );
 			} else {
 				mvpp2_write(priv,
 					    MVPP2_RX_DATA_FIFO_SIZE_REG(port),
@@ -4984,9 +5090,9 @@ static int mvpp2_init(struct udevice *dev, struct mvpp2 *priv)
 		return -EINVAL;
 	}
 
-	if (priv->hw_version == MVPP22)
+	if (priv->hw_version == MVPP22) {
 		mvpp2_axi_init(priv);
-	else {
+	} else {
 		/* MBUS windows configuration */
 		dram_target_info = mvebu_mbus_dram_info();
 		if (dram_target_info)
@@ -5051,118 +5157,6 @@ static int mvpp2_init(struct udevice *dev, struct mvpp2 *priv)
 	return 0;
 }
 
-/* SMI / MDIO functions */
-
-static int smi_wait_ready(struct mvpp2_port *priv)
-{
-	u32 timeout = MVPP2_SMI_TIMEOUT;
-	u32 smi_reg;
-
-	/* wait till the SMI is not busy */
-	do {
-		/* read smi register */
-		smi_reg = readl(priv->mdio_base);
-		if (timeout-- == 0) {
-			printf("Error: SMI busy timeout\n");
-			return -EFAULT;
-		}
-	} while (smi_reg & MVPP2_SMI_BUSY);
-
-	return 0;
-}
-
-/*
- * mpp2_mdio_read - miiphy_read callback function.
- *
- * Returns 16bit phy register value, or 0xffff on error
- */
-static int mpp2_mdio_read(struct mii_dev *bus, int addr, int devad, int reg)
-{
-	struct mvpp2_port *priv = bus->priv;
-	u32 smi_reg;
-	u32 timeout;
-
-	/* check parameters */
-	if (addr > MVPP2_PHY_ADDR_MASK) {
-		printf("Error: Invalid PHY address %d\n", addr);
-		return -EFAULT;
-	}
-
-	if (reg > MVPP2_PHY_REG_MASK) {
-		printf("Err: Invalid register offset %d\n", reg);
-		return -EFAULT;
-	}
-
-	/* wait till the SMI is not busy */
-	if (smi_wait_ready(priv) < 0)
-		return -EFAULT;
-
-	/* fill the phy address and regiser offset and read opcode */
-	smi_reg = (addr << MVPP2_SMI_DEV_ADDR_OFFS)
-		| (reg << MVPP2_SMI_REG_ADDR_OFFS)
-		| MVPP2_SMI_OPCODE_READ;
-
-	/* write the smi register */
-	writel(smi_reg, priv->mdio_base);
-
-	/* wait till read value is ready */
-	timeout = MVPP2_SMI_TIMEOUT;
-
-	do {
-		/* read smi register */
-		smi_reg = readl(priv->mdio_base);
-		if (timeout-- == 0) {
-			printf("Err: SMI read ready timeout\n");
-			return -EFAULT;
-		}
-	} while (!(smi_reg & MVPP2_SMI_READ_VALID));
-
-	/* Wait for the data to update in the SMI register */
-	for (timeout = 0; timeout < MVPP2_SMI_TIMEOUT; timeout++)
-		;
-
-	return readl(priv->mdio_base) & MVPP2_SMI_DATA_MASK;
-}
-
-/*
- * mpp2_mdio_write - miiphy_write callback function.
- *
- * Returns 0 if write succeed, -EINVAL on bad parameters
- * -ETIME on timeout
- */
-static int mpp2_mdio_write(struct mii_dev *bus, int addr, int devad, int reg,
-			   u16 value)
-{
-	struct mvpp2_port *priv = bus->priv;
-	u32 smi_reg;
-
-	/* check parameters */
-	if (addr > MVPP2_PHY_ADDR_MASK) {
-		printf("Error: Invalid PHY address %d\n", addr);
-		return -EFAULT;
-	}
-
-	if (reg > MVPP2_PHY_REG_MASK) {
-		printf("Err: Invalid register offset %d\n", reg);
-		return -EFAULT;
-	}
-
-	/* wait till the SMI is not busy */
-	if (smi_wait_ready(priv) < 0)
-		return -EFAULT;
-
-	/* fill the phy addr and reg offset and write opcode and data */
-	smi_reg = value << MVPP2_SMI_DATA_OFFS;
-	smi_reg |= (addr << MVPP2_SMI_DEV_ADDR_OFFS)
-		| (reg << MVPP2_SMI_REG_ADDR_OFFS);
-	smi_reg &= ~MVPP2_SMI_OPCODE_READ;
-
-	/* write the smi register */
-	writel(smi_reg, priv->mdio_base);
-
-	return 0;
-}
-
 static int mvpp2_recv(struct udevice *dev, int flags, uchar **packetp)
 {
 	struct mvpp2_port *port = dev_get_priv(dev);
@@ -5175,6 +5169,10 @@ static int mvpp2_recv(struct udevice *dev, int flags, uchar **packetp)
 	struct mvpp2_rx_queue *rxq;
 	u8 *data;
 
+	if (port->phyaddr < PHY_MAX_ADDR)
+		if (!port->phy_dev->link)
+			return 0;
+
 	/* Process RX packets */
 	rxq = port->rxqs[0];
 
@@ -5240,6 +5238,10 @@ static int mvpp2_send(struct udevice *dev, void *packet, int length)
 	int tx_done;
 	int timeout;
 
+	if (port->phyaddr < PHY_MAX_ADDR)
+		if (!port->phy_dev->link)
+			return 0;
+
 	txq = port->txqs[0];
 	aggr_txq = &port->priv->aggr_txqs[smp_processor_id()];
 
@@ -5302,6 +5304,9 @@ static int mvpp2_start(struct udevice *dev)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_SGMII_2500:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		mvpp2_port_power_up(port);
 	default:
 		break;
@@ -5328,14 +5333,6 @@ static int mvpp2_write_hwaddr(struct udevice *dev)
 	return mvpp2_prs_update_mac_da(port, port->dev_addr);
 }
 
-static int mvpp22_smi_phy_addr_cfg(struct mvpp2_port *port)
-{
-	writel(port->phyaddr, port->priv->iface_base +
-	       MVPP22_SMI_PHY_ADDR_REG(port->gop_id));
-
-	return 0;
-}
-
 static int mvpp2_base_probe(struct udevice *dev)
 {
 	struct mvpp2 *priv = dev_get_priv(dev);
@@ -5406,6 +5403,8 @@ static int mvpp2_base_probe(struct udevice *dev)
 		priv->mpcs_base = priv->iface_base + MVPP22_MPCS;
 		priv->xpcs_base = priv->iface_base + MVPP22_XPCS;
 		priv->rfu1_base = priv->iface_base + MVPP22_RFU1;
+
+		priv->sdip_base = (void *)devfdt_get_addr_index(dev, 2);
 	}
 
 	if (priv->hw_version == MVPP21)
@@ -5420,31 +5419,13 @@ static int mvpp2_probe(struct udevice *dev)
 {
 	struct mvpp2_port *port = dev_get_priv(dev);
 	struct mvpp2 *priv = dev_get_priv(dev->parent);
-	struct mii_dev *bus;
 	int err;
 
 	/* Only call the probe function for the parent once */
 	if (!priv->probe_done)
 		err = mvpp2_base_probe(dev->parent);
 
-	port->priv = dev_get_priv(dev->parent);
-
-	/* Create and register the MDIO bus driver */
-	bus = mdio_alloc();
-	if (!bus) {
-		printf("Failed to allocate MDIO bus\n");
-		return -ENOMEM;
-	}
-
-	bus->read = mpp2_mdio_read;
-	bus->write = mpp2_mdio_write;
-	snprintf(bus->name, sizeof(bus->name), dev->name);
-	bus->priv = (void *)port;
-	port->bus = bus;
-
-	err = mdio_register(bus);
-	if (err)
-		return err;
+	port->priv = priv;
 
 	err = phy_info_parse(dev, port);
 	if (err)
@@ -5472,10 +5453,6 @@ static int mvpp2_probe(struct udevice *dev)
 		port->base = priv->iface_base + MVPP22_PORT_BASE +
 			port->gop_id * MVPP22_PORT_OFFSET;
 
-		/* Set phy address of the port */
-		if(port->phy_node)
-			mvpp22_smi_phy_addr_cfg(port);
-
 		/* GoP Init */
 		gop_port_init(port);
 	}
diff --git a/drivers/net/octeontx/Makefile b/drivers/net/octeontx/Makefile
new file mode 100644
index 0000000000..170f1f41cd
--- /dev/null
+++ b/drivers/net/octeontx/Makefile
@@ -0,0 +1,9 @@
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * https://spdx.org/licenses
+# */
+
+obj-$(CONFIG_NET_OCTEONTX) += bgx.o nic_main.o nicvf_queues.o nicvf_main.o \
+				xcv.o
diff --git a/drivers/net/octeontx/bgx.c b/drivers/net/octeontx/bgx.c
new file mode 100644
index 0000000000..f2a50ee81a
--- /dev/null
+++ b/drivers/net/octeontx/bgx.c
@@ -0,0 +1,1574 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <net.h>
+#include <dm.h>
+#include <pci.h>
+#include <misc.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+
+#ifdef CONFIG_OF_LIBFDT
+ #include <linux/libfdt.h>
+ #include <fdt_support.h>
+#endif
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "bgx.h"
+
+static const phy_interface_t if_mode[] = {
+	[QLM_MODE_SGMII]  = PHY_INTERFACE_MODE_SGMII,
+	[QLM_MODE_RGMII]  = PHY_INTERFACE_MODE_RGMII,
+	[QLM_MODE_QSGMII] = PHY_INTERFACE_MODE_QSGMII,
+	[QLM_MODE_XAUI]   = PHY_INTERFACE_MODE_XAUI,
+	[QLM_MODE_RXAUI]  = PHY_INTERFACE_MODE_RXAUI,
+};
+
+struct lmac {
+	struct bgx		*bgx;
+	int			dmac;
+	u8			mac[6];
+	bool			link_up;
+	bool			init_pend;
+	int			lmacid; /* ID within BGX */
+	int			phy_addr; /* ID on board */
+	struct udevice		*dev;
+	struct mii_dev		*mii_bus;
+	struct phy_device	*phydev;
+	unsigned int		last_duplex;
+	unsigned int		last_link;
+	unsigned int		last_speed;
+	int			lane_to_sds;
+	int			use_training;
+	int			lmac_type;
+	u8			qlm_mode;
+	int			qlm;
+	bool			is_1gx;
+};
+
+struct bgx {
+	u8			bgx_id;
+	int			node;
+	struct	lmac		lmac[MAX_LMAC_PER_BGX];
+	int			lmac_count;
+	u8			max_lmac;
+	void __iomem		*reg_base;
+	struct pci_dev		*pdev;
+	bool			is_rgx;
+};
+
+struct bgx_board_info bgx_board_info[MAX_BGX_PER_NODE];
+
+struct bgx *bgx_vnic[MAX_BGX_PER_NODE];
+extern int rxaui_phy_xs_init(struct mii_dev *bus, int phy_addr);
+
+/* APIs to read/write BGXX CSRs */
+static u64 bgx_reg_read(struct bgx *bgx, uint8_t lmac, u64 offset)
+{
+	u64 addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	return readq((void *)addr);
+}
+
+static void bgx_reg_write(struct bgx *bgx, uint8_t lmac,
+			  u64 offset, u64 val)
+{
+	u64 addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	writeq(val, (void *)addr);
+}
+
+static void bgx_reg_modify(struct bgx *bgx, uint8_t lmac,
+			   u64 offset, u64 val)
+{
+	u64 addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	writeq(val | bgx_reg_read(bgx, lmac, offset), (void *)addr);
+}
+
+static int bgx_poll_reg(struct bgx *bgx, uint8_t lmac,
+			u64 reg, u64 mask, bool zero)
+{
+	int timeout = 200;
+	u64 reg_val;
+
+	while (timeout) {
+		reg_val = bgx_reg_read(bgx, lmac, reg);
+		if (zero && !(reg_val & mask))
+			return 0;
+		if (!zero && (reg_val & mask))
+			return 0;
+		mdelay(1);
+		timeout--;
+	}
+	return 1;
+}
+
+static int gser_poll_reg(u64 reg, int bit, u64 mask, u64 expected_val,
+			 int timeout)
+{
+	u64 reg_val;
+
+	debug("%s reg = %#llx, mask = %#llx,", __func__, reg, mask);
+	debug(" expected_val = %#llx, bit = %d\n", expected_val, bit);
+	while (timeout) {
+		reg_val = readq(CSR_PA(0, reg)) >> bit;
+		if ((reg_val & mask) == (expected_val))
+			return 0;
+		mdelay(1);
+		timeout--;
+	}
+	return 1;
+}
+
+static bool is_bgx_port_valid(int bgx, int lmac)
+{
+	debug("%s bgx %d lmac %d valid %d\n", __func__, bgx, lmac,
+	      bgx_board_info[bgx].lmac_reg[lmac]);
+
+	if (bgx_board_info[bgx].lmac_reg[lmac])
+		return 1;
+	else
+		return 0;
+}
+
+struct lmac *bgx_get_lmac(int node, int bgx_idx, int lmacid)
+{
+	struct bgx *bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (bgx)
+		return &bgx->lmac[lmacid];
+
+	return NULL;
+}
+
+const u8 *bgx_get_lmac_mac(int node, int bgx_idx, int lmacid)
+{
+	struct bgx *bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (bgx)
+		return bgx->lmac[lmacid].mac;
+
+	return NULL;
+}
+
+void bgx_set_lmac_mac(int node, int bgx_idx, int lmacid, const u8 *mac)
+{
+	struct bgx *bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (!bgx)
+		return;
+
+	memcpy(bgx->lmac[lmacid].mac, mac, 6);
+#ifdef ALLOW_USER_MAC_ADDR
+	fdt_board_update_macaddr(bgx_idx, lmacid, (char *)mac);
+#endif
+}
+
+/* Return number of BGX present in HW */
+void bgx_get_count(int node, int *bgx_count)
+{
+	int i;
+	struct bgx *bgx;
+
+	*bgx_count = 0;
+	for (i = 0; i < MAX_BGX_PER_NODE; i++) {
+		bgx = bgx_vnic[node * MAX_BGX_PER_NODE + i];
+		debug("bgx_vnic[%u]: %p\n", node * MAX_BGX_PER_NODE + i,
+		      bgx);
+		if (bgx)
+			*bgx_count |= (1 << i);
+	}
+}
+
+/* Return number of LMAC configured for this BGX */
+int bgx_get_lmac_count(int node, int bgx_idx)
+{
+	struct bgx *bgx;
+
+	bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+	if (bgx)
+		return bgx->lmac_count;
+
+	return 0;
+}
+
+void bgx_lmac_rx_tx_enable(int node, int bgx_idx, int lmacid, bool enable)
+{
+	struct bgx *bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+	u64 cfg;
+
+	if (!bgx)
+		return;
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	if (enable)
+		cfg |= CMR_PKT_RX_EN | CMR_PKT_TX_EN;
+	else
+		cfg &= ~(CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+}
+
+static void bgx_flush_dmac_addrs(struct bgx *bgx, u64 lmac)
+{
+	u64 dmac = 0x00;
+	u64 offset, addr;
+
+	while (bgx->lmac[lmac].dmac > 0) {
+		offset = ((bgx->lmac[lmac].dmac - 1) * sizeof(dmac)) +
+			(lmac * MAX_DMAC_PER_LMAC * sizeof(dmac));
+		addr = (uintptr_t)bgx->reg_base +
+				BGX_CMR_RX_DMACX_CAM + offset;
+		writeq(dmac, (void *)addr);
+		bgx->lmac[lmac].dmac--;
+	}
+}
+
+/* Configure BGX LMAC in internal loopback mode */
+void bgx_lmac_internal_loopback(int node, int bgx_idx,
+				int lmac_idx, bool enable)
+{
+	struct bgx *bgx;
+	struct lmac *lmac;
+	u64    cfg;
+
+	bgx = bgx_vnic[(node * MAX_BGX_PER_NODE) + bgx_idx];
+	if (!bgx)
+		return;
+
+	lmac = &bgx->lmac[lmac_idx];
+	if (lmac->qlm_mode == QLM_MODE_SGMII) {
+		cfg = bgx_reg_read(bgx, lmac_idx, BGX_GMP_PCS_MRX_CTL);
+		if (enable)
+			cfg |= PCS_MRX_CTL_LOOPBACK1;
+		else
+			cfg &= ~PCS_MRX_CTL_LOOPBACK1;
+		bgx_reg_write(bgx, lmac_idx, BGX_GMP_PCS_MRX_CTL, cfg);
+	} else {
+		cfg = bgx_reg_read(bgx, lmac_idx, BGX_SPUX_CONTROL1);
+		if (enable)
+			cfg |= SPU_CTL_LOOPBACK;
+		else
+			cfg &= ~SPU_CTL_LOOPBACK;
+		bgx_reg_write(bgx, lmac_idx, BGX_SPUX_CONTROL1, cfg);
+	}
+}
+
+/* Return the DLM used for the BGX */
+static int get_qlm_for_bgx(int node, int bgx_id, int index)
+{
+	int qlm = 0;
+	u64 cfg;
+
+	if (otx_is_soc(CN81XX)) {
+		qlm = (bgx_id) ? 2 : 0;
+		qlm += (index >= 2) ? 1 : 0;
+	} else if (otx_is_soc(CN83XX)) {
+		switch (bgx_id) {
+		case 0:
+			qlm = 2;
+			break;
+		case 1:
+			qlm = 3;
+			break;
+		case 2:
+			if (index >= 2)
+				qlm = 6;
+			else
+				qlm = 5;
+			break;
+		case 3:
+			qlm = 4;
+			break;
+		}
+	}
+
+	cfg = readq(CSR_PA(node, GSERX_CFG(qlm))) & GSERX_CFG_BGX;
+	debug("%s:qlm%d: cfg = %lld\n", __func__, qlm, cfg);
+
+	/* Check if DLM is configured as BGX# */
+	if (cfg) {
+		if (readq(CSR_PA(node, GSERX_PHY_CTL(qlm))))
+			return -1;
+		return qlm;
+	}
+	return -1;
+}
+
+static int bgx_lmac_sgmii_init(struct bgx *bgx, int lmacid)
+{
+	u64 cfg;
+	struct lmac *lmac;
+
+	lmac = &bgx->lmac[lmacid];
+
+	debug("%s:bgx_id = %d, lmacid = %d\n", __func__, bgx->bgx_id, lmacid);
+
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_TXX_THRESH, 0x30);
+	/* max packet size */
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_RXX_JABBER, MAX_FRAME_SIZE);
+
+	/* Disable frame alignment if using preamble */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND);
+	if (cfg & 1)
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SGMII_CTL, 0);
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG, CMR_EN);
+
+	/* PCS reset */
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, PCS_MRX_CTL_RESET);
+	if (bgx_poll_reg(bgx, lmacid, BGX_GMP_PCS_MRX_CTL,
+			 PCS_MRX_CTL_RESET, true)) {
+		printf("BGX PCS reset not completed\n");
+		return -1;
+	}
+
+	/* power down, reset autoneg, autoneg enable */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MRX_CTL);
+	cfg &= ~PCS_MRX_CTL_PWR_DN;
+
+	if (bgx_board_info[bgx->bgx_id].phy_info[lmacid].autoneg_dis)
+		cfg |= (PCS_MRX_CTL_RST_AN);
+	else
+		cfg |= (PCS_MRX_CTL_RST_AN | PCS_MRX_CTL_AN_EN);
+	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
+
+	/* Disable disparity for QSGMII mode, to prevent propogation across
+	 * ports.
+	 */
+
+	if (lmac->qlm_mode == QLM_MODE_QSGMII) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL);
+		cfg &= ~PCS_MISCX_CTL_DISP_EN;
+		bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, cfg);
+		return 0; /* Skip checking AN_CPT */
+	}
+
+	if (lmac->is_1gx) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL);
+		cfg |= PCS_MISC_CTL_MODE;
+		bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, cfg);
+	}
+
+	if (lmac->qlm_mode == QLM_MODE_SGMII) {
+		if (bgx_poll_reg(bgx, lmacid, BGX_GMP_PCS_MRX_STATUS,
+				 PCS_MRX_STATUS_AN_CPT, false)) {
+			printf("BGX AN_CPT not completed\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int bgx_lmac_sgmii_set_link_speed(struct lmac *lmac)
+{
+	u64 prtx_cfg;
+	u64 pcs_miscx_ctl;
+	u64 cfg;
+	struct bgx *bgx = lmac->bgx;
+	unsigned int lmacid = lmac->lmacid;
+
+	debug("%s: lmacid %d\n", __func__, lmac->lmacid);
+
+	/* Disable LMAC before setting up speed */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg &= ~CMR_EN;
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	/* Read GMX CFG */
+	prtx_cfg = bgx_reg_read(bgx, lmacid,
+				BGX_GMP_GMI_PRTX_CFG);
+	/* Read PCS MISCS CTL */
+	pcs_miscx_ctl = bgx_reg_read(bgx, lmacid,
+				     BGX_GMP_PCS_MISCX_CTL);
+
+	/* Use GMXENO to force the link down*/
+	if (lmac->link_up) {
+		pcs_miscx_ctl &= ~PCS_MISC_CTL_GMX_ENO;
+		/* change the duplex setting if the link is up */
+		prtx_cfg |= GMI_PORT_CFG_DUPLEX;
+	} else {
+		pcs_miscx_ctl |= PCS_MISC_CTL_GMX_ENO;
+	}
+
+	/* speed based setting for GMX */
+	switch (lmac->last_speed) {
+	case 10:
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED;
+		prtx_cfg |= GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg &= ~GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 50; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x40);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		break;
+	case 100:
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED;
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg &= ~GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 0x5; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x40);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		break;
+	case 1000:
+		prtx_cfg |= GMI_PORT_CFG_SPEED;
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg |= GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 0x1; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x200);
+		if (lmac->last_duplex)
+			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		else /* half duplex */
+			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST,
+				      0x2000);
+		break;
+	default:
+		break;
+	}
+
+	/* write back the new PCS misc and GMX settings */
+	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, pcs_miscx_ctl);
+	bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG, prtx_cfg);
+
+	/* read back GMX CFG again to check config completion */
+	bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG);
+
+	/* enable BGX back */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg |= CMR_EN;
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	return 0;
+}
+
+static int bgx_lmac_xaui_init(struct bgx *bgx, int lmacid, int lmac_type)
+{
+	u64 cfg;
+	struct lmac *lmac;
+
+	lmac = &bgx->lmac[lmacid];
+
+	/* Reset SPU */
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET);
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET, true)) {
+		printf("BGX SPU reset not completed\n");
+		return -1;
+	}
+
+	/* Disable LMAC */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg &= ~CMR_EN;
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_LOW_POWER);
+	/* Set interleaved running disparity for RXAUI */
+	if (lmac->qlm_mode != QLM_MODE_RXAUI)
+		bgx_reg_modify(bgx, lmacid,
+			       BGX_SPUX_MISC_CONTROL, SPU_MISC_CTL_RX_DIS);
+	else
+		bgx_reg_modify(bgx, lmacid, BGX_SPUX_MISC_CONTROL,
+			       SPU_MISC_CTL_RX_DIS | SPU_MISC_CTL_INTLV_RDISP);
+
+	/* clear all interrupts */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_RX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_RX_INT, cfg);
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_INT, cfg);
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+
+	if (lmac->use_training) {
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LP_CUP, 0x00);
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LD_CUP, 0x00);
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LD_REP, 0x00);
+		/* training enable */
+		bgx_reg_modify(bgx, lmacid,
+			       BGX_SPUX_BR_PMD_CRTL, SPU_PMD_CRTL_TRAIN_EN);
+	}
+
+	/* Append FCS to each packet */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_APPEND, SMU_TX_APPEND_FCS_D);
+
+	/* Disable forward error correction */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_FEC_CONTROL);
+	cfg &= ~SPU_FEC_CTL_FEC_EN;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_FEC_CONTROL, cfg);
+
+	/* Disable autoneg */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_CONTROL);
+	cfg = cfg & ~(SPU_AN_CTL_XNP_EN);
+	if (lmac->use_training)
+		cfg = cfg | (SPU_AN_CTL_AN_EN);
+	else
+		cfg = cfg & ~(SPU_AN_CTL_AN_EN);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_AN_CONTROL, cfg);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_ADV);
+	/* Clear all KR bits, configure according to the mode */
+	cfg &= ~((0xfULL << 22) | (1ULL << 12));
+	if (lmac->qlm_mode == QLM_MODE_10G_KR)
+		cfg |= (1 << 23);
+	else if (lmac->qlm_mode == QLM_MODE_40G_KR4)
+		cfg |= (1 << 24);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_AN_ADV, cfg);
+
+	cfg = bgx_reg_read(bgx, 0, BGX_SPU_DBG_CONTROL);
+	if (lmac->use_training)
+		cfg |= SPU_DBG_CTL_AN_ARB_LINK_CHK_EN;
+	else
+		cfg &= ~SPU_DBG_CTL_AN_ARB_LINK_CHK_EN;
+	bgx_reg_write(bgx, 0, BGX_SPU_DBG_CONTROL, cfg);
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG, CMR_EN);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_CONTROL1);
+	cfg &= ~SPU_CTL_LOW_POWER;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_CONTROL1, cfg);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_CTL);
+	cfg &= ~SMU_TX_CTL_UNI_EN;
+	cfg |= SMU_TX_CTL_DIC_EN;
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_CTL, cfg);
+
+	/* take lmac_count into account */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_THRESH, (0x100 - 1));
+	/* max packet size */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_RX_JABBER, MAX_FRAME_SIZE);
+
+	debug("xaui_init: lmacid = %d, qlm = %d, qlm_mode = %d\n",
+	      lmacid, lmac->qlm, lmac->qlm_mode);
+	/* RXAUI with Marvell PHY requires some tweaking */
+	if (lmac->qlm_mode == QLM_MODE_RXAUI) {
+		char mii_name[20];
+		struct phy_info *phy;
+
+		phy = &bgx_board_info[bgx->bgx_id].phy_info[lmacid];
+		snprintf(mii_name, sizeof(mii_name), "smi%d", phy->mdio_bus);
+
+		debug("mii_name: %s\n", mii_name);
+		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
+		lmac->phy_addr = phy->phy_addr;
+		rxaui_phy_xs_init(lmac->mii_bus, lmac->phy_addr);
+	}
+
+	return 0;
+}
+
+/* Get max number of lanes present in a given QLM/DLM */
+static int get_qlm_lanes(int qlm)
+{
+	if (otx_is_soc(CN81XX))
+		return 2;
+	else if (otx_is_soc(CN83XX))
+		return (qlm >= 5) ? 2 : 4;
+	else
+		return -1;
+}
+
+int __rx_equalization(int qlm, int lane)
+{
+	int max_lanes = get_qlm_lanes(qlm);
+	int l;
+	int fail = 0;
+
+	/* Before completing Rx equalization wait for
+	 * GSERx_RX_EIE_DETSTS[CDRLOCK] to be set
+	 * This ensures the rx data is valid
+	 */
+	if (lane == -1) {
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, 0xf,
+				  (1 << max_lanes) - 1, 100)) {
+			debug("ERROR: CDR Lock not detected");
+			debug(" on DLM%d for 2 lanes\n", qlm);
+			return -1;
+		}
+	} else {
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK,
+				  (0xf & (1 << lane)), (1 << lane), 100)) {
+			debug("ERROR: DLM%d: CDR Lock not detected", qlm);
+			debug(" on %d lane\n", lane);
+			return -1;
+		}
+	}
+
+	for (l = 0; l < max_lanes; l++) {
+		u64 rctl, reer;
+
+		if (lane != -1 && lane != l)
+			continue;
+
+		/* Enable software control */
+		rctl = readq(CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+		rctl |= GSER_BR_RXX_CTL_RXT_SWM;
+		writeq(rctl, CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+
+		/* Clear the completion flag and initiate a new request */
+		reer = readq(CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+		reer &= ~GSER_BR_RXX_EER_RXT_ESV;
+		reer |= GSER_BR_RXX_EER_RXT_EER;
+		writeq(reer, CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+	}
+
+	/* Wait for RX equalization to complete */
+	for (l = 0; l < max_lanes; l++) {
+		u64 rctl, reer;
+
+		if (lane != -1 && lane != l)
+			continue;
+
+		gser_poll_reg(GSER_BR_RXX_EER(qlm, l), EER_RXT_ESV, 1, 1, 200);
+		reer = readq(CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+
+		/* Switch back to hardware control */
+		rctl = readq(CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+		rctl &= ~GSER_BR_RXX_CTL_RXT_SWM;
+		writeq(rctl, CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+
+		if (reer & GSER_BR_RXX_EER_RXT_ESV) {
+			debug("Rx equalization completed on DLM%d", qlm);
+			debug(" QLM%d rxt_esm = 0x%llx\n", l, (reer & 0x3fff));
+		} else {
+			debug("Rx equalization timedout on DLM%d", qlm);
+			debug(" lane %d\n", l);
+			fail = 1;
+		}
+	}
+
+	return (fail) ? -1 : 0;
+}
+
+static int bgx_xaui_check_link(struct lmac *lmac)
+{
+	struct bgx *bgx = lmac->bgx;
+	int lmacid = lmac->lmacid;
+	int lmac_type = lmac->lmac_type;
+	u64 cfg;
+
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_MISC_CONTROL, SPU_MISC_CTL_RX_DIS);
+
+	/* check if auto negotiation is complete */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_CONTROL);
+	if (cfg & SPU_AN_CTL_AN_EN) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_STATUS);
+		if (!(cfg & SPU_AN_STS_AN_COMPLETE)) {
+			/* Restart autonegotiation */
+			debug("restarting auto-neg\n");
+			bgx_reg_modify(bgx, lmacid, BGX_SPUX_AN_CONTROL,
+				       SPU_AN_CTL_AN_RESTART);
+			return -1;
+		}
+	}
+
+	debug("%s link use_training %d\n", __func__, lmac->use_training);
+	if (lmac->use_training) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+		if (!(cfg & (1ull << 13))) {
+			debug("waiting for link training\n");
+			/* Clear the training interrupts (W1C) */
+			cfg = (1ull << 13) | (1ull << 14);
+			bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+
+			udelay(2000);
+			/* Restart training */
+			cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_BR_PMD_CRTL);
+			cfg |= (1ull << 0);
+			bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_CRTL, cfg);
+			return -1;
+		}
+	}
+
+	/* Perform RX Equalization. Applies to non-KR interfaces for speeds
+	 * >= 6.25Gbps.
+	 */
+	if (!lmac->use_training) {
+		int qlm;
+		bool use_dlm = 0;
+
+		if (otx_is_soc(CN81XX) || (otx_is_soc(CN83XX) &&
+					   bgx->bgx_id == 2))
+			use_dlm = 1;
+		switch (lmac->lmac_type) {
+		default:
+		case BGX_MODE_SGMII:
+		case BGX_MODE_RGMII:
+		case BGX_MODE_XAUI:
+			/* Nothing to do */
+			break;
+		case BGX_MODE_XLAUI:
+			if (use_dlm) {
+				if (__rx_equalization(lmac->qlm, -1) ||
+				    __rx_equalization(lmac->qlm + 1, -1)) {
+					printf("BGX%d:%d", bgx->bgx_id, lmacid);
+					printf(" Waiting for RX Equalization");
+					printf(" on DLM%d/DLM%d\n",
+					       lmac->qlm, lmac->qlm + 1);
+					return -1;
+				}
+			} else {
+				if (__rx_equalization(lmac->qlm, -1)) {
+					printf("BGX%d:%d", bgx->bgx_id, lmacid);
+					printf(" Waiting for RX Equalization");
+					printf(" on QLM%d\n", lmac->qlm);
+					return -1;
+				}
+			}
+			break;
+		case BGX_MODE_RXAUI:
+			/* RXAUI0 uses LMAC0:QLM0/QLM2 and RXAUI1 uses
+			 * LMAC1:QLM1/QLM3 RXAUI requires 2 lanes
+			 * for each interface
+			 */
+			qlm = lmac->qlm;
+			if (__rx_equalization(qlm, 0)) {
+				printf("BGX%d:%d", bgx->bgx_id, lmacid);
+				printf(" Waiting for RX Equalization");
+				printf(" on QLM%d, Lane0\n", qlm);
+				return -1;
+			}
+			if (__rx_equalization(qlm, 1)) {
+				printf("BGX%d:%d", bgx->bgx_id, lmacid);
+				printf(" Waiting for RX Equalization");
+				printf(" on QLM%d, Lane1\n", qlm);
+				return -1;
+			}
+			break;
+		case BGX_MODE_XFI:
+			{
+				int lid;
+				bool altpkg = otx_is_altpkg();
+
+				if (bgx->bgx_id == 0 && altpkg && lmacid)
+					lid = 0;
+				else if ((lmacid >= 2) && use_dlm)
+					lid = lmacid - 2;
+				else
+					lid = lmacid;
+
+				if (__rx_equalization(lmac->qlm, lid)) {
+					printf("BGX%d:%d", bgx->bgx_id, lid);
+					printf(" Waiting for RX Equalization");
+					printf(" on QLM%d\n", lmac->qlm);
+				}
+			}
+			break;
+		}
+	}
+
+	/* wait for PCS to come out of reset */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET, true)) {
+		printf("BGX SPU reset not completed\n");
+		return -1;
+	}
+
+	if (lmac_type == 3 || lmac_type == 4) {
+		if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_BR_STATUS1,
+				 SPU_BR_STATUS_BLK_LOCK, false)) {
+			printf("SPU_BR_STATUS_BLK_LOCK not completed\n");
+			return -1;
+		}
+	} else {
+		if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_BX_STATUS,
+				 SPU_BX_STATUS_RX_ALIGN, false)) {
+			printf("SPU_BX_STATUS_RX_ALIGN not completed\n");
+			return -1;
+		}
+	}
+
+	/* Clear rcvflt bit (latching high) and read it back */
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS2, SPU_STATUS2_RCVFLT);
+	if (bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS2) & SPU_STATUS2_RCVFLT) {
+		printf("Receive fault, retry training\n");
+		if (lmac->use_training) {
+			cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+			if (!(cfg & (1ull << 13))) {
+				cfg = (1ull << 13) | (1ull << 14);
+				bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+				cfg = bgx_reg_read(bgx, lmacid,
+						   BGX_SPUX_BR_PMD_CRTL);
+				cfg |= (1ull << 0);
+				bgx_reg_write(bgx, lmacid,
+					      BGX_SPUX_BR_PMD_CRTL, cfg);
+				return -1;
+			}
+		}
+		return -1;
+	}
+
+	/* Wait for MAC RX to be ready */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_RX_CTL,
+			 SMU_RX_CTL_STATUS, true)) {
+		printf("SMU RX link not okay\n");
+		return -1;
+	}
+
+	/* Wait for BGX RX to be idle */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_CTL, SMU_CTL_RX_IDLE, false)) {
+		printf("SMU RX not idle\n");
+		return -1;
+	}
+
+	/* Wait for BGX TX to be idle */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_CTL, SMU_CTL_TX_IDLE, false)) {
+		printf("SMU TX not idle\n");
+		return -1;
+	}
+
+	if (bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS2) & SPU_STATUS2_RCVFLT) {
+		printf("Receive fault\n");
+		return -1;
+	}
+
+	/* Receive link is latching low. Force it high and verify it */
+	if (!(bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS1) &
+	    SPU_STATUS1_RCV_LNK))
+		bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS1,
+			       SPU_STATUS1_RCV_LNK);
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_STATUS1,
+			 SPU_STATUS1_RCV_LNK, false)) {
+		printf("SPU receive link down\n");
+		return -1;
+	}
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_MISC_CONTROL);
+	cfg &= ~SPU_MISC_CTL_RX_DIS;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_MISC_CONTROL, cfg);
+	return 0;
+}
+
+static int bgx_lmac_enable(struct bgx *bgx, int8_t lmacid)
+{
+	struct lmac *lmac;
+	u64 cfg;
+
+	lmac = &bgx->lmac[lmacid];
+
+	debug("%s: lmac: %p, lmacid = %d\n", __func__, lmac, lmacid);
+
+	if (lmac->qlm_mode == QLM_MODE_SGMII ||
+	    lmac->qlm_mode == QLM_MODE_RGMII ||
+	    lmac->qlm_mode == QLM_MODE_QSGMII) {
+		if (bgx_lmac_sgmii_init(bgx, lmacid)) {
+			debug("bgx_lmac_sgmii_init failed\n");
+			return -1;
+		}
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND);
+		cfg |= ((1ull << 2) | (1ull << 1)); /* FCS and PAD */
+		bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND, cfg);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_MIN_PKT, 60 - 1);
+	} else {
+		if (bgx_lmac_xaui_init(bgx, lmacid, lmac->lmac_type))
+			return -1;
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_APPEND);
+		cfg |= ((1ull << 2) | (1ull << 1)); /* FCS and PAD */
+		bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_APPEND, cfg);
+		bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_MIN_PKT, 60 + 4);
+	}
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG,
+		       CMR_EN | CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+
+	return 0;
+}
+
+int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
+{
+	int ret;
+	struct lmac *lmac = bgx_get_lmac(node, bgx_idx, lmacid);
+	char mii_name[10];
+	struct phy_info *phy;
+
+	if (!lmac) {
+		printf("LMAC %d/%d/%d is disabled or doesn't exist\n",
+		       node, bgx_idx, lmacid);
+		return 0;
+	}
+
+	debug("%s: %d, lmac: %d/%d/%d %p\n",
+	      __FILE__, __LINE__,
+	      node, bgx_idx, lmacid, lmac);
+	if (lmac->init_pend) {
+		ret = bgx_lmac_enable(lmac->bgx, lmacid);
+		if (ret < 0) {
+			printf("BGX%d LMAC%d lmac_enable failed\n", bgx_idx,
+			       lmacid);
+			return ret;
+		}
+		lmac->init_pend = 0;
+		mdelay(100);
+	}
+	if (lmac->qlm_mode == QLM_MODE_SGMII ||
+	    lmac->qlm_mode == QLM_MODE_RGMII ||
+	    lmac->qlm_mode == QLM_MODE_QSGMII) {
+		if (bgx_board_info[bgx_idx].phy_info[lmacid].phy_addr == -1) {
+			lmac->link_up = 1;
+			lmac->last_speed = 1000;
+			lmac->last_duplex = 1;
+			printf("BGX%d:LMAC %u link up\n", bgx_idx, lmacid);
+			return lmac->link_up;
+		}
+		snprintf(mii_name, sizeof(mii_name), "smi%d",
+			 bgx_board_info[bgx_idx].phy_info[lmacid].mdio_bus);
+
+		debug("mii_name: %s\n", mii_name);
+
+		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
+		phy = &bgx_board_info[bgx_idx].phy_info[lmacid];
+		lmac->phy_addr = phy->phy_addr;
+
+		debug("lmac->mii_bus: %p\n", lmac->mii_bus);
+		if (!lmac->mii_bus) {
+			printf("MDIO device %s not found\n", mii_name);
+			ret = -ENODEV;
+			return ret;
+		}
+
+		lmac->phydev = phy_connect(lmac->mii_bus, lmac->phy_addr,
+					   lmac->dev,
+					   if_mode[lmac->qlm_mode]);
+
+		if (!lmac->phydev) {
+			printf("%s: No PHY device\n", __func__);
+			return -1;
+		}
+
+		ret = phy_config(lmac->phydev);
+		if (ret) {
+			printf("%s: Could not initialize PHY %s\n",
+			       __func__, lmac->phydev->dev->name);
+			return ret;
+		}
+
+		ret = phy_startup(lmac->phydev);
+		debug("%s: %d\n", __FILE__, __LINE__);
+		if (ret) {
+			printf("%s: Could not initialize PHY %s\n",
+			       __func__, lmac->phydev->dev->name);
+		}
+
+#ifdef OCTEONTX_XCV
+		if (lmac->qlm_mode == QLM_MODE_RGMII)
+			xcv_setup_link(lmac->phydev->link, lmac->phydev->speed);
+#endif
+
+		lmac->link_up = lmac->phydev->link;
+		lmac->last_speed = lmac->phydev->speed;
+		lmac->last_duplex = lmac->phydev->duplex;
+
+		debug("%s qlm_mode %d phy link status 0x%x,last speed 0x%x,",
+		      __func__, lmac->qlm_mode, lmac->link_up,
+		      lmac->last_speed);
+		debug(" duplex 0x%x\n", lmac->last_duplex);
+
+		if (lmac->qlm_mode != QLM_MODE_RGMII)
+			bgx_lmac_sgmii_set_link_speed(lmac);
+
+	} else {
+		u64 status1;
+		u64 tx_ctl;
+		u64 rx_ctl;
+
+		status1 = bgx_reg_read(lmac->bgx, lmac->lmacid,
+				       BGX_SPUX_STATUS1);
+		tx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_TX_CTL);
+		rx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_RX_CTL);
+
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS2: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SPUX_STATUS2));
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS1: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SPUX_STATUS1));
+		debug("BGX%d LMAC%d BGX_SMUX_RX_CTL: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SMUX_RX_CTL));
+		debug("BGX%d LMAC%d BGX_SMUX_TX_CTL: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SMUX_TX_CTL));
+
+		if ((status1 & SPU_STATUS1_RCV_LNK) &&
+		    ((tx_ctl & SMU_TX_CTL_LNK_STATUS) == 0) &&
+		    ((rx_ctl & SMU_RX_CTL_STATUS) == 0)) {
+			lmac->link_up = 1;
+			if (lmac->lmac_type == 4)
+				lmac->last_speed = 40000;
+			else
+				lmac->last_speed = 10000;
+			lmac->last_duplex = 1;
+		} else {
+			lmac->link_up = 0;
+			lmac->last_speed = 0;
+			lmac->last_duplex = 0;
+			return bgx_xaui_check_link(lmac);
+		}
+
+		lmac->last_link = lmac->link_up;
+	}
+
+	printf("BGX%d:LMAC %u link %s\n", bgx_idx, lmacid,
+	       (lmac->link_up) ? "up" : "down");
+
+	return lmac->link_up;
+}
+
+void bgx_lmac_disable(struct bgx *bgx, uint8_t lmacid)
+{
+	struct lmac *lmac;
+	u64 cmrx_cfg;
+
+	lmac = &bgx->lmac[lmacid];
+
+	cmrx_cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cmrx_cfg &= ~(1 << 15);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cmrx_cfg);
+	bgx_flush_dmac_addrs(bgx, lmacid);
+
+	if (lmac->phydev)
+		phy_shutdown(lmac->phydev);
+
+	lmac->phydev = NULL;
+}
+
+/* Program BGXX_CMRX_CONFIG.{lmac_type,lane_to_sds} for each interface.
+ * And the number of LMACs used by this interface. Each lmac can be in
+ * programmed in a different mode, so parse each lmac one at a time.
+ */
+static void bgx_init_hw(struct bgx *bgx)
+{
+	struct lmac *lmac;
+	int i, lmacid, count = 0, inc = 0;
+	char buf[40];
+	static int qsgmii_configured;
+
+	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
+		struct lmac *tlmac;
+
+		lmac = &bgx->lmac[lmacid];
+		debug("%s: lmacid = %d, qlm = %d, mode = %d\n",
+		      __func__, lmacid, lmac->qlm, lmac->qlm_mode);
+		/* If QLM is not programmed, skip */
+		if (lmac->qlm == -1)
+			continue;
+
+		switch (lmac->qlm_mode) {
+		case QLM_MODE_SGMII:
+		{
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 0;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: %s\n",
+				 bgx->bgx_id, lmac->qlm, lmacid,
+				 lmac->is_1gx ? "1000Base-X" : "SGMII");
+			break;
+		}
+		case QLM_MODE_XAUI:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 1;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_RXAUI:
+			if (lmacid == 0) {
+				lmac->lmac_type = 2;
+				lmac->lane_to_sds = 0x4;
+			} else if (lmacid == 1) {
+				struct lmac *tlmac;
+
+				tlmac = &bgx->lmac[2];
+				if (tlmac->qlm_mode == QLM_MODE_RXAUI) {
+					lmac->lmac_type = 2;
+					lmac->lane_to_sds = 0xe;
+					lmac->qlm = tlmac->qlm;
+				}
+			} else {
+				continue;
+			}
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: RXAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_XFI:
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 3;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XFI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_XLAUI:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 4;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XLAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_10G_KR:
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 3;
+			lmac->use_training = 1;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: 10G-KR\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_40G_KR4:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 4;
+			lmac->lane_to_sds = 0xE4;
+			lmac->use_training = 1;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: 40G-KR4\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_RGMII:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 5;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d LMAC%d mode: RGMII\n",
+				 bgx->bgx_id, lmacid);
+			break;
+		case QLM_MODE_QSGMII:
+			if (qsgmii_configured)
+				continue;
+			if (lmacid == 0 || lmacid == 2) {
+				count = 4;
+				printf("BGX%d QLM%d LMAC%d mode: QSGMII\n",
+				       bgx->bgx_id, lmac->qlm, lmacid);
+				for (i = 0; i < count; i++) {
+					struct lmac *l;
+					int type;
+
+					l = &bgx->lmac[i];
+					l->lmac_type = 6;
+					type = l->lmac_type;
+					l->qlm_mode = QLM_MODE_QSGMII;
+					l->lane_to_sds = lmacid + i;
+					if (is_bgx_port_valid(bgx->bgx_id, i))
+						bgx_reg_write(bgx, i,
+							      BGX_CMRX_CFG,
+							      (type << 8) |
+							      l->lane_to_sds);
+				}
+				qsgmii_configured = 1;
+			}
+			continue;
+		default:
+			continue;
+		}
+
+		/* Reset lmac to the unused slot */
+		if (is_bgx_port_valid(bgx->bgx_id, count) &&
+		    lmac->qlm_mode != QLM_MODE_QSGMII) {
+			int lmac_en = 0;
+			int tmp, idx;
+
+			tlmac = &bgx->lmac[count];
+			tlmac->lmac_type = lmac->lmac_type;
+			idx = bgx->bgx_id;
+			tmp = count + inc;
+			/* Adjust lane_to_sds based on BGX-ENABLE */
+			for (; tmp < MAX_LMAC_PER_BGX; inc++) {
+				lmac_en = bgx_board_info[idx].lmac_enable[tmp];
+				if (lmac_en)
+					break;
+				tmp = count + inc;
+			}
+
+			if (inc != 0 && inc < MAX_LMAC_PER_BGX &&
+			    lmac_en && inc != count)
+				tlmac->lane_to_sds =
+					lmac->lane_to_sds + abs(inc - count);
+			else
+				tlmac->lane_to_sds = lmac->lane_to_sds;
+			tlmac->qlm = lmac->qlm;
+			tlmac->qlm_mode = lmac->qlm_mode;
+
+			printf("%s", buf);
+			/* Initialize lmac_type and lane_to_sds */
+			bgx_reg_write(bgx, count, BGX_CMRX_CFG,
+				      (tlmac->lmac_type << 8) |
+				      tlmac->lane_to_sds);
+
+			if (tlmac->lmac_type == BGX_MODE_SGMII) {
+				if (tlmac->is_1gx) {
+					/* This is actually 1000BASE-X, so
+					 * mark the LMAC as such.
+					 */
+					bgx_reg_modify(bgx, count,
+						       BGX_GMP_PCS_MISCX_CTL,
+						       PCS_MISC_CTL_MODE);
+				}
+
+				if (!bgx_board_info[bgx->bgx_id].
+						phy_info[lmacid].autoneg_dis) {
+					/* The Linux DTS does not disable
+					 * autoneg for this LMAC (in SGMII or
+					 * 1000BASE-X mode), so that means
+					 * enable autoneg.
+					 */
+					bgx_reg_modify(bgx, count,
+						       BGX_GMP_PCS_MRX_CTL,
+						       PCS_MRX_CTL_AN_EN);
+				}
+			}
+
+			count += 1;
+		}
+	}
+
+	/* Done probing all 4 lmacs, now clear qsgmii_configured */
+	qsgmii_configured = 0;
+
+	printf("BGX%d LMACs: %d\n", bgx->bgx_id, count);
+	bgx->lmac_count = count;
+	bgx_reg_write(bgx, 0, BGX_CMR_RX_LMACS, count);
+	bgx_reg_write(bgx, 0, BGX_CMR_TX_LMACS, count);
+
+	bgx_reg_modify(bgx, 0, BGX_CMR_GLOBAL_CFG, CMR_GLOBAL_CFG_FCS_STRIP);
+	if (bgx_reg_read(bgx, 0, BGX_CMR_BIST_STATUS))
+		printf("BGX%d BIST failed\n", bgx->bgx_id);
+
+	/* Set the backpressure AND mask */
+	for (i = 0; i < bgx->lmac_count; i++)
+		bgx_reg_modify(bgx, 0, BGX_CMR_CHAN_MSK_AND,
+			       ((1ULL << MAX_BGX_CHANS_PER_LMAC) - 1) <<
+				(i * MAX_BGX_CHANS_PER_LMAC));
+
+	/* Disable all MAC filtering */
+	for (i = 0; i < RX_DMAC_COUNT; i++)
+		bgx_reg_write(bgx, 0, BGX_CMR_RX_DMACX_CAM + (i * 8), 0x00);
+
+	/* Disable MAC steering (NCSI traffic) */
+	for (i = 0; i < RX_TRAFFIC_STEER_RULE_COUNT; i++)
+		bgx_reg_write(bgx, 0, BGX_CMR_RX_STREERING + (i * 8), 0x00);
+}
+
+static void bgx_get_qlm_mode(struct bgx *bgx)
+{
+	struct lmac *lmac;
+	int lmacid;
+
+	/* Read LMACx type to figure out QLM mode
+	 * This is configured by low level firmware
+	 */
+	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
+		int lmac_type;
+		int train_en;
+		int index = 0;
+
+		if (otx_is_soc(CN81XX) || (otx_is_soc(CN83XX) &&
+					   bgx->bgx_id == 2))
+			index = (lmacid < 2) ? 0 : 2;
+
+		lmac = &bgx->lmac[lmacid];
+
+		/* check if QLM is programmed, if not, skip */
+		if (lmac->qlm == -1)
+			continue;
+
+		lmac_type = bgx_reg_read(bgx, index, BGX_CMRX_CFG);
+		lmac->lmac_type = (lmac_type >> 8) & 0x07;
+		debug("%s:%d:%d: lmac_type = %d, altpkg = %d\n", __func__,
+		      bgx->bgx_id, lmacid, lmac->lmac_type, otx_is_altpkg());
+
+		train_en = (readq(CSR_PA(0, GSERX_SCRATCH(lmac->qlm))) & 0xf);
+		lmac->is_1gx = bgx_reg_read(bgx, index, BGX_GMP_PCS_MISCX_CTL)
+				& (PCS_MISC_CTL_MODE) ? true : false;
+
+		switch (lmac->lmac_type) {
+		case BGX_MODE_SGMII:
+			if (bgx->is_rgx) {
+				if (lmacid == 0) {
+					lmac->qlm_mode = QLM_MODE_RGMII;
+					debug("BGX%d LMAC%d mode: RGMII\n",
+					      bgx->bgx_id, lmacid);
+				}
+				continue;
+			} else {
+				if (bgx->bgx_id == 0 && otx_is_altpkg()) {
+					if (lmacid % 2)
+						continue;
+				}
+				lmac->qlm_mode = QLM_MODE_SGMII;
+				debug("BGX%d QLM%d LMAC%d mode: %s\n",
+				      bgx->bgx_id, lmac->qlm, lmacid,
+				      lmac->is_1gx ? "1000Base-X" : "SGMII");
+			}
+			break;
+		case BGX_MODE_XAUI:
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
+				continue;
+			lmac->qlm_mode = QLM_MODE_XAUI;
+			if (lmacid != 0)
+				continue;
+			debug("BGX%d QLM%d LMAC%d mode: XAUI\n",
+			      bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case BGX_MODE_RXAUI:
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
+				continue;
+			lmac->qlm_mode = QLM_MODE_RXAUI;
+			if (index == lmacid) {
+				debug("BGX%d QLM%d LMAC%d mode: RXAUI\n",
+				      bgx->bgx_id, lmac->qlm, (index ? 1 : 0));
+			}
+			break;
+		case BGX_MODE_XFI:
+			if (bgx->bgx_id == 0 && otx_is_altpkg()) {
+				if (lmacid % 2)
+					continue;
+			}
+			if ((lmacid < 2 && (train_en & (1 << lmacid))) ||
+			    (train_en & (1 << (lmacid - 2)))) {
+				lmac->qlm_mode = QLM_MODE_10G_KR;
+				debug("BGX%d QLM%d LMAC%d mode: 10G_KR\n",
+				      bgx->bgx_id, lmac->qlm, lmacid);
+			} else {
+				lmac->qlm_mode = QLM_MODE_XFI;
+				debug("BGX%d QLM%d LMAC%d mode: XFI\n",
+				      bgx->bgx_id, lmac->qlm, lmacid);
+			}
+			break;
+		case BGX_MODE_XLAUI:
+			if (bgx->bgx_id == 0 && otx_is_altpkg())
+				continue;
+			if (train_en) {
+				lmac->qlm_mode = QLM_MODE_40G_KR4;
+				if (lmacid != 0)
+					break;
+				debug("BGX%d QLM%d LMAC%d mode: 40G_KR4\n",
+				      bgx->bgx_id, lmac->qlm, lmacid);
+			} else {
+				lmac->qlm_mode = QLM_MODE_XLAUI;
+				if (lmacid != 0)
+					break;
+				debug("BGX%d QLM%d LMAC%d mode: XLAUI\n",
+				      bgx->bgx_id, lmac->qlm, lmacid);
+			}
+		break;
+		case BGX_MODE_QSGMII:
+			/* If QLM is configured as QSGMII, use lmac0 */
+			if (otx_is_soc(CN83XX) && lmacid == 2 &&
+			    bgx->bgx_id != 2) {
+				//lmac->qlm_mode = QLM_MODE_DISABLED;
+				continue;
+			}
+
+			if (lmacid == 0 || lmacid == 2) {
+				lmac->qlm_mode = QLM_MODE_QSGMII;
+				debug("BGX%d QLM%d LMAC%d mode: QSGMII\n",
+				      bgx->bgx_id, lmac->qlm, lmacid);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+void bgx_set_board_info(int bgx_id, int *mdio_bus,
+			int *phy_addr, bool *autoneg_dis, bool *lmac_reg,
+			bool *lmac_enable)
+{
+	unsigned int i;
+
+	for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
+		bgx_board_info[bgx_id].phy_info[i].phy_addr = phy_addr[i];
+		bgx_board_info[bgx_id].phy_info[i].mdio_bus = mdio_bus[i];
+		bgx_board_info[bgx_id].phy_info[i].autoneg_dis = autoneg_dis[i];
+		bgx_board_info[bgx_id].lmac_reg[i] = lmac_reg[i];
+		bgx_board_info[bgx_id].lmac_enable[i] = lmac_enable[i];
+		debug("%s bgx_id %d lmac %d\n", __func__, bgx_id, i);
+		debug("phy addr %x mdio bus %d autoneg_dis %d lmac_reg %d\n",
+		      bgx_board_info[bgx_id].phy_info[i].phy_addr,
+		      bgx_board_info[bgx_id].phy_info[i].mdio_bus,
+		      bgx_board_info[bgx_id].phy_info[i].autoneg_dis,
+		      bgx_board_info[bgx_id].lmac_reg[i]);
+		debug("lmac_enable = %x\n",
+		      bgx_board_info[bgx_id].lmac_enable[i]);
+	}
+}
+
+int octeontx_bgx_remove(struct udevice *dev)
+{
+	int lmacid;
+	u64 cfg;
+	int count = MAX_LMAC_PER_BGX;
+	struct bgx *bgx = dev_get_priv(dev);
+
+	if (!bgx->reg_base)
+		return 0;
+
+	if (bgx->is_rgx)
+		count = 1;
+
+	for (lmacid = 0; lmacid < count; lmacid++) {
+		struct lmac *lmac;
+
+		lmac = &bgx->lmac[lmacid];
+		cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+		cfg &= ~(CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+		bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+		/* Disable PCS for 1G interface */
+		if (lmac->lmac_type == BGX_MODE_SGMII ||
+		    lmac->lmac_type == BGX_MODE_QSGMII) {
+			cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MRX_CTL);
+			cfg |= PCS_MRX_CTL_PWR_DN;
+			bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
+		}
+
+		debug("%s disabling bgx%d lmacid%d\n", __func__, bgx->bgx_id,
+		      lmacid);
+		bgx_lmac_disable(bgx, lmacid);
+	}
+	return 0;
+}
+
+int octeontx_bgx_probe(struct udevice *dev)
+{
+	struct bgx *bgx = dev_get_priv(dev);
+	u8 lmac = 0;
+	int qlm[4] = {-1, -1, -1, -1};
+	int bgx_idx, node;
+	int inc = 1;
+
+	bgx->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+				       PCI_REGION_MEM);
+	if (!bgx->reg_base) {
+		debug("No PCI region found\n");
+		return 0;
+	}
+
+#ifdef OCTEONTX_XCV
+	/* Use FAKE BGX2 for RGX interface */
+	if ((((uintptr_t)bgx->reg_base >> 24) & 0xf) == 0x8) {
+		bgx->bgx_id = 2;
+		bgx->is_rgx = true;
+		for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac++) {
+			if (lmac == 0) {
+				bgx->lmac[lmac].lmacid = 0;
+				bgx->lmac[lmac].qlm = 0;
+			} else {
+				bgx->lmac[lmac].qlm = -1;
+			}
+		}
+		xcv_init_hw();
+		goto skip_qlm_config;
+	}
+#endif
+
+	node = node_id(bgx->reg_base);
+	bgx_idx = ((uintptr_t)bgx->reg_base >> 24) & 3;
+	bgx->bgx_id = (node * MAX_BGX_PER_NODE) + bgx_idx;
+	if (otx_is_soc(CN81XX))
+		inc = 2;
+	else if (otx_is_soc(CN83XX) && (bgx_idx == 2))
+		inc = 2;
+
+	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac += inc) {
+		/* BGX3 (DLM4), has only 2 lanes */
+		if (otx_is_soc(CN83XX) && bgx_idx == 3 && lmac >= 2)
+			continue;
+		qlm[lmac + 0] = get_qlm_for_bgx(node, bgx_idx, lmac);
+		/* Each DLM has 2 lanes, configure both lanes with
+		 * same qlm configuration
+		 */
+		if (inc == 2)
+			qlm[lmac + 1] = qlm[lmac];
+		debug("qlm[%d] = %d\n", lmac, qlm[lmac]);
+	}
+
+	/* A BGX can take 1 or 2 DLMs, if both the DLMs are not configured
+	 * as BGX, then return, nothing to initialize
+	 */
+	if (otx_is_soc(CN81XX))
+		if ((qlm[0] == -1) && (qlm[2] == -1))
+			return -ENODEV;
+
+	/* MAP configuration registers */
+	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac++) {
+		bgx->lmac[lmac].qlm = qlm[lmac];
+		bgx->lmac[lmac].lmacid = lmac;
+	}
+
+#ifdef OCTEONTX_XCV
+skip_qlm_config:
+#endif
+	bgx_vnic[bgx->bgx_id] = bgx;
+	bgx_get_qlm_mode(bgx);
+	debug("bgx_vnic[%u]: %p\n", bgx->bgx_id, bgx);
+
+	bgx_init_hw(bgx);
+
+	/* Init LMACs */
+	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+		struct lmac *tlmac = &bgx->lmac[lmac];
+
+		tlmac->dev = dev;
+		tlmac->init_pend = 1;
+		tlmac->bgx = bgx;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(octeontx_bgx) = {
+	.name	= "octeontx_bgx",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_bgx_probe,
+	.remove	= octeontx_bgx_remove,
+	.priv_auto_alloc_size = sizeof(struct bgx),
+	.flags  = DM_FLAG_OS_PREPARE,
+};
+
+static struct pci_device_id octeontx_bgx_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_BGX) },
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_RGX) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_bgx, octeontx_bgx_supported);
diff --git a/drivers/net/octeontx/bgx.h b/drivers/net/octeontx/bgx.h
new file mode 100644
index 0000000000..1ad582a91a
--- /dev/null
+++ b/drivers/net/octeontx/bgx.h
@@ -0,0 +1,259 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef BGX_H
+#define BGX_H
+
+#include <asm/arch/board.h>
+
+/* PCI device IDs */
+#define	PCI_DEVICE_ID_OCTEONTX_BGX	0xA026
+#define	PCI_DEVICE_ID_OCTEONTX_RGX	0xA054
+
+#define    MAX_LMAC_PER_BGX			4
+#define    MAX_BGX_CHANS_PER_LMAC		16
+#define    MAX_DMAC_PER_LMAC			8
+#define    MAX_FRAME_SIZE			9216
+
+#define    MAX_DMAC_PER_LMAC_TNS_BYPASS_MODE	2
+
+#define    MAX_LMAC	(MAX_BGX_PER_NODE * MAX_LMAC_PER_BGX)
+
+#define    NODE_ID_MASK				0x300000000000
+#define    NODE_ID(x)				(((x) & NODE_ID_MASK) >> 44)
+
+/* Registers */
+#define GSERX_CFG(x)		(0x87E090000080ull + (x) * 0x1000000ull)
+#define GSERX_SCRATCH(x)	(0x87E090000020ull + (x) * 0x1000000ull)
+#define GSERX_PHY_CTL(x)	(0x87E090000000ull + (x) * 0x1000000ull)
+#define GSERX_CFG_BGX		BIT(2)
+#define GSER_RX_EIE_DETSTS(x)	(0x87E090000150ull + (x) * 0x1000000ull)
+#define GSER_CDRLOCK		(8)
+#define GSER_BR_RXX_CTL(x, y)	(0x87E090000400ull + (x) * 0x1000000ull + \
+				(y) * 0x80)
+#define GSER_BR_RXX_CTL_RXT_SWM	BIT(2)
+#define GSER_BR_RXX_EER(x, y)	(0x87E090000418ull + (x) * 0x1000000ull + \
+				(y) * 0x80)
+#define GSER_BR_RXX_EER_RXT_ESV BIT(14)
+#define GSER_BR_RXX_EER_RXT_EER BIT(15)
+#define EER_RXT_ESV		(14)
+
+#define BGX_CMRX_CFG			0x00
+#define CMR_PKT_TX_EN				BIT_ULL(13)
+#define CMR_PKT_RX_EN				BIT_ULL(14)
+#define CMR_EN					BIT_ULL(15)
+#define BGX_CMR_GLOBAL_CFG		0x08
+#define CMR_GLOBAL_CFG_FCS_STRIP		BIT_ULL(6)
+#define BGX_CMRX_RX_ID_MAP		0x60
+#define BGX_CMRX_RX_STAT0		0x70
+#define BGX_CMRX_RX_STAT1		0x78
+#define BGX_CMRX_RX_STAT2		0x80
+#define BGX_CMRX_RX_STAT3		0x88
+#define BGX_CMRX_RX_STAT4		0x90
+#define BGX_CMRX_RX_STAT5		0x98
+#define BGX_CMRX_RX_STAT6		0xA0
+#define BGX_CMRX_RX_STAT7		0xA8
+#define BGX_CMRX_RX_STAT8		0xB0
+#define BGX_CMRX_RX_STAT9		0xB8
+#define BGX_CMRX_RX_STAT10		0xC0
+#define BGX_CMRX_RX_BP_DROP		0xC8
+#define BGX_CMRX_RX_DMAC_CTL		0x0E8
+#define BGX_CMR_RX_DMACX_CAM		0x200
+#define RX_DMACX_CAM_EN				BIT_ULL(48)
+#define RX_DMACX_CAM_LMACID(x)			((x) << 49)
+#define RX_DMAC_COUNT			32
+#define BGX_CMR_RX_STREERING		0x300
+#define RX_TRAFFIC_STEER_RULE_COUNT	8
+#define BGX_CMR_CHAN_MSK_AND		0x450
+#define BGX_CMR_BIST_STATUS		0x460
+#define BGX_CMR_RX_LMACS		0x468
+#define BGX_CMRX_TX_STAT0		0x600
+#define BGX_CMRX_TX_STAT1		0x608
+#define BGX_CMRX_TX_STAT2		0x610
+#define BGX_CMRX_TX_STAT3		0x618
+#define BGX_CMRX_TX_STAT4		0x620
+#define BGX_CMRX_TX_STAT5		0x628
+#define BGX_CMRX_TX_STAT6		0x630
+#define BGX_CMRX_TX_STAT7		0x638
+#define BGX_CMRX_TX_STAT8		0x640
+#define BGX_CMRX_TX_STAT9		0x648
+#define BGX_CMRX_TX_STAT10		0x650
+#define BGX_CMRX_TX_STAT11		0x658
+#define BGX_CMRX_TX_STAT12		0x660
+#define BGX_CMRX_TX_STAT13		0x668
+#define BGX_CMRX_TX_STAT14		0x670
+#define BGX_CMRX_TX_STAT15		0x678
+#define BGX_CMRX_TX_STAT16		0x680
+#define BGX_CMRX_TX_STAT17		0x688
+#define BGX_CMR_TX_LMACS		0x1000
+
+#define BGX_SPUX_CONTROL1		0x10000
+#define SPU_CTL_LOW_POWER			BIT_ULL(11)
+#define SPU_CTL_LOOPBACK                        BIT_ULL(14)
+#define SPU_CTL_RESET				BIT_ULL(15)
+#define BGX_SPUX_STATUS1		0x10008
+#define SPU_STATUS1_RCV_LNK			BIT_ULL(2)
+#define BGX_SPUX_STATUS2		0x10020
+#define SPU_STATUS2_RCVFLT			BIT_ULL(10)
+#define BGX_SPUX_BX_STATUS		0x10028
+#define SPU_BX_STATUS_RX_ALIGN                  BIT_ULL(12)
+#define BGX_SPUX_BR_STATUS1		0x10030
+#define SPU_BR_STATUS_BLK_LOCK			BIT_ULL(0)
+#define SPU_BR_STATUS_RCV_LNK			BIT_ULL(12)
+#define BGX_SPUX_BR_PMD_CRTL		0x10068
+#define SPU_PMD_CRTL_TRAIN_EN			BIT_ULL(1)
+#define BGX_SPUX_BR_PMD_LP_CUP		0x10078
+#define BGX_SPUX_BR_PMD_LD_CUP		0x10088
+#define BGX_SPUX_BR_PMD_LD_REP		0x10090
+#define BGX_SPUX_FEC_CONTROL		0x100A0
+#define SPU_FEC_CTL_FEC_EN			BIT_ULL(0)
+#define SPU_FEC_CTL_ERR_EN			BIT_ULL(1)
+#define BGX_SPUX_AN_CONTROL		0x100C8
+#define SPU_AN_CTL_AN_EN			BIT_ULL(12)
+#define SPU_AN_CTL_XNP_EN			BIT_ULL(13)
+#define SPU_AN_CTL_AN_RESTART			BIT_ULL(15)
+#define BGX_SPUX_AN_STATUS		0x100D0
+#define SPU_AN_STS_AN_COMPLETE			BIT_ULL(5)
+#define BGX_SPUX_AN_ADV			0x100D8
+#define BGX_SPUX_MISC_CONTROL		0x10218
+#define SPU_MISC_CTL_INTLV_RDISP		BIT_ULL(10)
+#define SPU_MISC_CTL_RX_DIS			BIT_ULL(12)
+#define BGX_SPUX_INT			0x10220	/* +(0..3) << 20 */
+#define BGX_SPUX_INT_W1S		0x10228
+#define BGX_SPUX_INT_ENA_W1C		0x10230
+#define BGX_SPUX_INT_ENA_W1S		0x10238
+#define BGX_SPU_DBG_CONTROL		0x10300
+#define SPU_DBG_CTL_AN_ARB_LINK_CHK_EN		BIT_ULL(18)
+#define SPU_DBG_CTL_AN_NONCE_MCT_DIS		BIT_ULL(29)
+
+#define BGX_SMUX_RX_INT			0x20000
+#define BGX_SMUX_RX_JABBER		0x20030
+#define BGX_SMUX_RX_CTL			0x20048
+#define SMU_RX_CTL_STATUS			(3ull << 0)
+#define BGX_SMUX_TX_APPEND		0x20100
+#define SMU_TX_APPEND_FCS_D			BIT_ULL(2)
+#define BGX_SMUX_TX_MIN_PKT		0x20118
+#define BGX_SMUX_TX_INT			0x20140
+#define BGX_SMUX_TX_CTL			0x20178
+#define SMU_TX_CTL_DIC_EN			BIT_ULL(0)
+#define SMU_TX_CTL_UNI_EN			BIT_ULL(1)
+#define SMU_TX_CTL_LNK_STATUS			(3ull << 4)
+#define BGX_SMUX_TX_THRESH		0x20180
+#define BGX_SMUX_CTL			0x20200
+#define SMU_CTL_RX_IDLE				BIT_ULL(0)
+#define SMU_CTL_TX_IDLE				BIT_ULL(1)
+
+#define BGX_GMP_PCS_MRX_CTL		0x30000
+#define	PCS_MRX_CTL_RST_AN			BIT_ULL(9)
+#define	PCS_MRX_CTL_PWR_DN			BIT_ULL(11)
+#define	PCS_MRX_CTL_AN_EN			BIT_ULL(12)
+#define PCS_MRX_CTL_LOOPBACK1                   BIT_ULL(14)
+#define	PCS_MRX_CTL_RESET			BIT_ULL(15)
+#define BGX_GMP_PCS_MRX_STATUS		0x30008
+#define	PCS_MRX_STATUS_AN_CPT			BIT_ULL(5)
+#define BGX_GMP_PCS_ANX_AN_RESULTS	0x30020
+#define BGX_GMP_PCS_SGM_AN_ADV		0x30068
+#define BGX_GMP_PCS_MISCX_CTL		0x30078
+#define PCS_MISCX_CTL_DISP_EN			BIT_ULL(13)
+#define PCS_MISC_CTL_GMX_ENO			BIT_ULL(11)
+#define PCS_MISC_CTL_SAMP_PT_MASK		0x7Full
+#define PCS_MISC_CTL_MODE			BIT_ULL(8)
+#define BGX_GMP_GMI_PRTX_CFG		0x38020
+#define GMI_PORT_CFG_SPEED			BIT_ULL(1)
+#define GMI_PORT_CFG_DUPLEX			BIT_ULL(2)
+#define GMI_PORT_CFG_SLOT_TIME			BIT_ULL(3)
+#define GMI_PORT_CFG_SPEED_MSB			BIT_ULL(8)
+#define BGX_GMP_GMI_RXX_JABBER		0x38038
+#define BGX_GMP_GMI_TXX_THRESH		0x38210
+#define BGX_GMP_GMI_TXX_APPEND		0x38218
+#define BGX_GMP_GMI_TXX_SLOT		0x38220
+#define BGX_GMP_GMI_TXX_BURST		0x38228
+#define BGX_GMP_GMI_TXX_MIN_PKT		0x38240
+#define BGX_GMP_GMI_TXX_SGMII_CTL	0x38300
+
+#define BGX_MSIX_VEC_0_29_ADDR		0x400000 /* +(0..29) << 4 */
+#define BGX_MSIX_VEC_0_29_CTL		0x400008
+#define BGX_MSIX_PBA_0			0x4F0000
+
+/* MSI-X interrupts */
+#define BGX_MSIX_VECTORS	30
+#define BGX_LMAC_VEC_OFFSET	7
+#define BGX_MSIX_VEC_SHIFT	4
+
+#define CMRX_INT		0
+#define SPUX_INT		1
+#define SMUX_RX_INT		2
+#define SMUX_TX_INT		3
+#define GMPX_PCS_INT		4
+#define GMPX_GMI_RX_INT		5
+#define GMPX_GMI_TX_INT		6
+#define CMR_MEM_INT		28
+#define SPU_MEM_INT		29
+
+#define LMAC_INTR_LINK_UP	BIT(0)
+#define LMAC_INTR_LINK_DOWN	BIT(1)
+
+/*  RX_DMAC_CTL configuration*/
+enum MCAST_MODE {
+		MCAST_MODE_REJECT,
+		MCAST_MODE_ACCEPT,
+		MCAST_MODE_CAM_FILTER,
+		RSVD
+};
+
+#define BCAST_ACCEPT	1
+#define CAM_ACCEPT	1
+
+int octeontx_bgx_initialize(unsigned int bgx_idx, unsigned int node);
+void bgx_add_dmac_addr(u64 dmac, int node, int bgx_idx, int lmac);
+void bgx_get_count(int node, int *bgx_count);
+int bgx_get_lmac_count(int node, int bgx);
+void bgx_print_stats(int bgx_idx, int lmac);
+void xcv_init_hw(void);
+void xcv_setup_link(bool link_up, int link_speed);
+
+#undef LINK_INTR_ENABLE
+
+enum qlm_mode {
+	QLM_MODE_SGMII,         /* SGMII, each lane independent */
+	QLM_MODE_XAUI,      /* 1 XAUI or DXAUI, 4 lanes */
+	QLM_MODE_RXAUI,     /* 2 RXAUI, 2 lanes each */
+	QLM_MODE_XFI,       /* 4 XFI, 1 lane each */
+	QLM_MODE_XLAUI,     /* 1 XLAUI, 4 lanes each */
+	QLM_MODE_10G_KR,    /* 4 10GBASE-KR, 1 lane each */
+	QLM_MODE_40G_KR4,   /* 1 40GBASE-KR4, 4 lanes each */
+	QLM_MODE_QSGMII,    /* 4 QSGMII, each lane independent */
+	QLM_MODE_RGMII,     /* 1 RGX */
+};
+
+struct phy_info {
+	int mdio_bus;
+	int phy_addr;
+	bool autoneg_dis;
+};
+
+struct bgx_board_info {
+	struct phy_info phy_info[MAX_LMAC_PER_BGX];
+	bool lmac_reg[MAX_LMAC_PER_BGX];
+	bool lmac_enable[MAX_LMAC_PER_BGX];
+};
+
+enum LMAC_TYPE {
+	BGX_MODE_SGMII = 0, /* 1 lane, 1.250 Gbaud */
+	BGX_MODE_XAUI = 1,  /* 4 lanes, 3.125 Gbaud */
+	BGX_MODE_DXAUI = 1, /* 4 lanes, 6.250 Gbaud */
+	BGX_MODE_RXAUI = 2, /* 2 lanes, 6.250 Gbaud */
+	BGX_MODE_XFI = 3,   /* 1 lane, 10.3125 Gbaud */
+	BGX_MODE_XLAUI = 4, /* 4 lanes, 10.3125 Gbaud */
+	BGX_MODE_10G_KR = 3,/* 1 lane, 10.3125 Gbaud */
+	BGX_MODE_40G_KR = 4,/* 4 lanes, 10.3125 Gbaud */
+	BGX_MODE_RGMII = 5,
+	BGX_MODE_QSGMII = 6,
+	BGX_MODE_INVALID = 7,
+};
+
+#endif /* BGX_H */
diff --git a/drivers/net/octeontx/nic.h b/drivers/net/octeontx/nic.h
new file mode 100644
index 0000000000..760675d577
--- /dev/null
+++ b/drivers/net/octeontx/nic.h
@@ -0,0 +1,518 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef NIC_H
+#define	NIC_H
+
+#include <linux/netdevice.h>
+#include "bgx.h"
+
+/**
+ * Macro to get the physical address of a CSR on a node
+ */
+#define CSR_PA(node, csr) ((csr) | ((u64)(node) << 44))
+
+/* PCI device IDs */
+#define	PCI_DEVICE_ID_OCTEONTX_NIC_PF	0xA01E
+#define	PCI_DEVICE_ID_OCTEONTX_NIC_VF_1	0x0011
+#define PCI_DEVICE_ID_OCTEONTX_NIC_VF_2	0xA034
+
+/* Subsystem device IDs */
+#define PCI_SUBSYS_DEVID_88XX_NIC_PF		0xA11E
+#define PCI_SUBSYS_DEVID_81XX_NIC_PF		0xA21E
+#define PCI_SUBSYS_DEVID_83XX_NIC_PF		0xA31E
+
+#define PCI_SUBSYS_DEVID_88XX_PASS1_NIC_VF	0xA11E
+#define PCI_SUBSYS_DEVID_88XX_NIC_VF		0xA134
+#define PCI_SUBSYS_DEVID_81XX_NIC_VF		0xA234
+#define PCI_SUBSYS_DEVID_83XX_NIC_VF		0xA334
+
+#define	NIC_INTF_COUNT			2  /* Interfaces btw VNIC and TNS/BGX */
+#define	NIC_CHANS_PER_INF		128
+#define	NIC_MAX_CHANS			(NIC_INTF_COUNT * NIC_CHANS_PER_INF)
+
+/* PCI BAR nos */
+#define	PCI_CFG_REG_BAR_NUM		0
+#define	PCI_MSIX_REG_BAR_NUM		4
+
+/* NIC SRIOV VF count */
+#define	MAX_NUM_VFS_SUPPORTED		128
+#define	DEFAULT_NUM_VF_ENABLED		8
+
+#define	NIC_TNS_BYPASS_MODE		0
+#define	NIC_TNS_MODE			1
+
+/* NIC priv flags */
+#define	NIC_SRIOV_ENABLED		BIT(0)
+#define	NIC_TNS_ENABLED			BIT(1)
+
+/* VNIC HW optimiation features */
+#define	VNIC_RX_CSUM_OFFLOAD_SUPPORT
+#undef	VNIC_TX_CSUM_OFFLOAD_SUPPORT
+#undef	VNIC_SG_SUPPORT
+#undef	VNIC_TSO_SUPPORT
+#undef	VNIC_LRO_SUPPORT
+#undef  VNIC_RSS_SUPPORT
+
+/* TSO not supported in Thunder pass1 */
+#ifdef	VNIC_TSO_SUPPORT
+#define	VNIC_SW_TSO_SUPPORT
+#undef	VNIC_HW_TSO_SUPPORT
+#endif
+
+/* ETHTOOL enable or disable, undef this to disable */
+#define	NICVF_ETHTOOL_ENABLE
+
+/* Min/Max packet size */
+#define	NIC_HW_MIN_FRS			64
+#define	NIC_HW_MAX_FRS			9200 /* 9216 max packet including FCS */
+
+/* Max pkinds */
+#define	NIC_MAX_PKIND			16
+
+/* Max when CPI_ALG is IP diffserv */
+#define	NIC_MAX_CPI_PER_LMAC		64
+
+/* NIC VF Interrupts */
+#define	NICVF_INTR_CQ			0
+#define	NICVF_INTR_SQ			1
+#define	NICVF_INTR_RBDR			2
+#define	NICVF_INTR_PKT_DROP		3
+#define	NICVF_INTR_TCP_TIMER	4
+#define	NICVF_INTR_MBOX			5
+#define	NICVF_INTR_QS_ERR		6
+
+#define	NICVF_INTR_CQ_SHIFT			0
+#define	NICVF_INTR_SQ_SHIFT			8
+#define	NICVF_INTR_RBDR_SHIFT		16
+#define	NICVF_INTR_PKT_DROP_SHIFT	20
+#define	NICVF_INTR_TCP_TIMER_SHIFT	21
+#define	NICVF_INTR_MBOX_SHIFT		22
+#define	NICVF_INTR_QS_ERR_SHIFT		23
+
+#define	NICVF_INTR_CQ_MASK		(0xFF << NICVF_INTR_CQ_SHIFT)
+#define	NICVF_INTR_SQ_MASK		(0xFF << NICVF_INTR_SQ_SHIFT)
+#define	NICVF_INTR_RBDR_MASK		(0x03 << NICVF_INTR_RBDR_SHIFT)
+#define	NICVF_INTR_PKT_DROP_MASK	BIT(NICVF_INTR_PKT_DROP_SHIFT)
+#define	NICVF_INTR_TCP_TIMER_MASK	BIT(NICVF_INTR_TCP_TIMER_SHIFT)
+#define	NICVF_INTR_MBOX_MASK		BIT(NICVF_INTR_MBOX_SHIFT)
+#define	NICVF_INTR_QS_ERR_MASK		BIT(NICVF_INTR_QS_ERR_SHIFT)
+
+/* MSI-X interrupts */
+#define	NIC_PF_MSIX_VECTORS		10
+#define	NIC_VF_MSIX_VECTORS		20
+
+#define NIC_PF_INTR_ID_ECC0_SBE		0
+#define NIC_PF_INTR_ID_ECC0_DBE		1
+#define NIC_PF_INTR_ID_ECC1_SBE		2
+#define NIC_PF_INTR_ID_ECC1_DBE		3
+#define NIC_PF_INTR_ID_ECC2_SBE		4
+#define NIC_PF_INTR_ID_ECC2_DBE		5
+#define NIC_PF_INTR_ID_ECC3_SBE		6
+#define NIC_PF_INTR_ID_ECC3_DBE		7
+#define NIC_PF_INTR_ID_MBOX0		8
+#define NIC_PF_INTR_ID_MBOX1		9
+
+/* Global timer for CQ timer thresh interrupts
+ * Calculated for SCLK of 700Mhz
+ * value written should be a 1/16thof what is expected
+ *
+ * 1 tick per ms
+ */
+#define NICPF_CLK_PER_INT_TICK		43750
+
+struct nicvf_cq_poll {
+	u8	cq_idx;		/* Completion queue index */
+};
+
+#define NIC_MAX_RSS_HASH_BITS		8
+#define NIC_MAX_RSS_IDR_TBL_SIZE	BIT(NIC_MAX_RSS_HASH_BITS)
+#define RSS_HASH_KEY_SIZE		5 /* 320 bit key */
+
+#ifdef VNIC_RSS_SUPPORT
+struct nicvf_rss_info {
+	bool enable;
+#define	RSS_L2_EXTENDED_HASH_ENA	BIT(0)
+#define	RSS_IP_HASH_ENA			BIT(1)
+#define	RSS_TCP_HASH_ENA		BIT(2)
+#define	RSS_TCP_SYN_DIS			BIT(3)
+#define	RSS_UDP_HASH_ENA		BIT(4)
+#define RSS_L4_EXTENDED_HASH_ENA	BIT(5)
+#define	RSS_ROCE_ENA			BIT(6)
+#define	RSS_L3_BI_DIRECTION_ENA		BIT(7)
+#define	RSS_L4_BI_DIRECTION_ENA		BIT(8)
+	u64 cfg;
+	u8  hash_bits;
+	u16 rss_size;
+	u8  ind_tbl[NIC_MAX_RSS_IDR_TBL_SIZE];
+	u64 key[RSS_HASH_KEY_SIZE];
+};
+#endif
+
+enum rx_stats_reg_offset {
+	RX_OCTS = 0x0,
+	RX_UCAST = 0x1,
+	RX_BCAST = 0x2,
+	RX_MCAST = 0x3,
+	RX_RED = 0x4,
+	RX_RED_OCTS = 0x5,
+	RX_ORUN = 0x6,
+	RX_ORUN_OCTS = 0x7,
+	RX_FCS = 0x8,
+	RX_L2ERR = 0x9,
+	RX_DRP_BCAST = 0xa,
+	RX_DRP_MCAST = 0xb,
+	RX_DRP_L3BCAST = 0xc,
+	RX_DRP_L3MCAST = 0xd,
+	RX_STATS_ENUM_LAST,
+};
+
+enum tx_stats_reg_offset {
+	TX_OCTS = 0x0,
+	TX_UCAST = 0x1,
+	TX_BCAST = 0x2,
+	TX_MCAST = 0x3,
+	TX_DROP = 0x4,
+	TX_STATS_ENUM_LAST,
+};
+
+struct nicvf_hw_stats {
+	u64 rx_bytes_ok;
+	u64 rx_ucast_frames_ok;
+	u64 rx_bcast_frames_ok;
+	u64 rx_mcast_frames_ok;
+	u64 rx_fcs_errors;
+	u64 rx_l2_errors;
+	u64 rx_drop_red;
+	u64 rx_drop_red_bytes;
+	u64 rx_drop_overrun;
+	u64 rx_drop_overrun_bytes;
+	u64 rx_drop_bcast;
+	u64 rx_drop_mcast;
+	u64 rx_drop_l3_bcast;
+	u64 rx_drop_l3_mcast;
+	u64 tx_bytes_ok;
+	u64 tx_ucast_frames_ok;
+	u64 tx_bcast_frames_ok;
+	u64 tx_mcast_frames_ok;
+	u64 tx_drops;
+};
+
+struct nicvf_drv_stats {
+	/* Rx */
+	u64 rx_frames_ok;
+	u64 rx_frames_64;
+	u64 rx_frames_127;
+	u64 rx_frames_255;
+	u64 rx_frames_511;
+	u64 rx_frames_1023;
+	u64 rx_frames_1518;
+	u64 rx_frames_jumbo;
+	u64 rx_drops;
+	/* Tx */
+	u64 tx_frames_ok;
+	u64 tx_drops;
+	u64 tx_busy;
+	u64 tx_tso;
+};
+
+struct hw_info {
+	u8		bgx_cnt;
+	u8		chans_per_lmac;
+	u8		chans_per_bgx; /* Rx/Tx chans */
+	u8		chans_per_rgx;
+	u8		chans_per_lbk;
+	u16		cpi_cnt;
+	u16		rssi_cnt;
+	u16		rss_ind_tbl_size;
+	u16		tl4_cnt;
+	u16		tl3_cnt;
+	u8		tl2_cnt;
+	u8		tl1_cnt;
+	bool		tl1_per_bgx; /* TL1 per BGX or per LMAC */
+	u8		model_id;
+};
+
+struct nicvf {
+	struct udevice		*dev;
+	u8			vf_id;
+	bool			sqs_mode:1;
+	bool			loopback_supported:1;
+	u8			tns_mode;
+	u8			node;
+	u16		mtu;
+	struct queue_set	*qs;
+#define		MAX_SQS_PER_VF_SINGLE_NODE	5
+#define		MAX_SQS_PER_VF			11
+	u8			num_qs;
+	void			*addnl_qs;
+	u16		vf_mtu;
+	void __iomem		*reg_base;
+#define	MAX_QUEUES_PER_QSET			8
+	struct nicvf_cq_poll	*napi[8];
+
+	u8			cpi_alg;
+
+	struct nicvf_hw_stats	stats;
+	struct nicvf_drv_stats	drv_stats;
+
+	struct nicpf		*nicpf;
+
+	/* VF <-> PF mailbox communication */
+	bool			pf_acked;
+	bool			pf_nacked;
+	bool			set_mac_pending;
+
+	bool			link_up;
+	u8			duplex;
+	u32		speed;
+	u8			rev_id;
+	u8			rx_queues;
+	u8			tx_queues;
+
+	bool			open;
+	bool			rb_alloc_fail;
+	void			*rcv_buf;
+	bool			hw_tso;
+};
+
+static inline int node_id(void *addr)
+{
+	return ((uintptr_t)addr >> 44) & 0x3;
+}
+
+struct nicpf {
+	struct udevice		*udev;
+	struct hw_info		*hw;
+	u8			node;
+	unsigned int		flags;
+	u16			total_vf_cnt;	/* Total num of VF supported */
+	u16			num_vf_en;	/* No of VF enabled */
+	void __iomem		*reg_base;	/* Register start address */
+	u16			rss_ind_tbl_size;
+	u8			num_sqs_en;	/* Secondary qsets enabled */
+	u64			nicvf[MAX_NUM_VFS_SUPPORTED];
+	u8			vf_sqs[MAX_NUM_VFS_SUPPORTED][MAX_SQS_PER_VF];
+	u8			pqs_vf[MAX_NUM_VFS_SUPPORTED];
+	bool			sqs_used[MAX_NUM_VFS_SUPPORTED];
+	struct pkind_cfg	pkind;
+	u8			bgx_cnt;
+	u8			rev_id;
+#define	NIC_SET_VF_LMAC_MAP(bgx, lmac)	((((bgx) & 0xF) << 4) | ((lmac) & 0xF))
+#define	NIC_GET_BGX_FROM_VF_LMAC_MAP(map)	(((map) >> 4) & 0xF)
+#define	NIC_GET_LMAC_FROM_VF_LMAC_MAP(map)	((map) & 0xF)
+	u8			vf_lmac_map[MAX_LMAC];
+	u16			cpi_base[MAX_NUM_VFS_SUPPORTED];
+	u64			mac[MAX_NUM_VFS_SUPPORTED];
+	bool			mbx_lock[MAX_NUM_VFS_SUPPORTED];
+	u8			link[MAX_LMAC];
+	u8			duplex[MAX_LMAC];
+	u32			speed[MAX_LMAC];
+	bool			vf_enabled[MAX_NUM_VFS_SUPPORTED];
+	u16			rssi_base[MAX_NUM_VFS_SUPPORTED];
+	u8			lmac_cnt;
+};
+
+/* PF <--> VF Mailbox communication
+ * Eight 64bit registers are shared between PF and VF.
+ * Separate set for each VF.
+ * Writing '1' into last register mbx7 means end of message.
+ */
+
+/* PF <--> VF mailbox communication */
+#define	NIC_PF_VF_MAILBOX_SIZE		2
+#define	NIC_PF_VF_MBX_TIMEOUT		2000 /* ms */
+
+/* Mailbox message types */
+#define	NIC_MBOX_MSG_READY		0x01	/* Is PF ready to rcv msgs */
+#define	NIC_MBOX_MSG_ACK		0x02	/* ACK the message received */
+#define	NIC_MBOX_MSG_NACK		0x03	/* NACK the message received */
+#define	NIC_MBOX_MSG_QS_CFG		0x04	/* Configure Qset */
+#define	NIC_MBOX_MSG_RQ_CFG		0x05	/* Configure receive queue */
+#define	NIC_MBOX_MSG_SQ_CFG		0x06	/* Configure Send queue */
+#define	NIC_MBOX_MSG_RQ_DROP_CFG	0x07	/* Configure receive queue */
+#define	NIC_MBOX_MSG_SET_MAC		0x08	/* Add MAC ID to DMAC filter */
+#define	NIC_MBOX_MSG_SET_MAX_FRS	0x09	/* Set max frame size */
+#define	NIC_MBOX_MSG_CPI_CFG		0x0A	/* Config CPI, RSSI */
+#define	NIC_MBOX_MSG_RSS_SIZE		0x0B	/* Get RSS indir_tbl size */
+#define	NIC_MBOX_MSG_RSS_CFG		0x0C	/* Config RSS table */
+#define	NIC_MBOX_MSG_RSS_CFG_CONT	0x0D	/* RSS config continuation */
+#define	NIC_MBOX_MSG_RQ_BP_CFG		0x0E	/* RQ backpressure config */
+#define	NIC_MBOX_MSG_RQ_SW_SYNC		0x0F	/* Flush inflight pkts to RQ */
+#define	NIC_MBOX_MSG_BGX_STATS		0x10	/* Get stats from BGX */
+#define	NIC_MBOX_MSG_BGX_LINK_CHANGE	0x11	/* BGX:LMAC link status */
+#define	NIC_MBOX_MSG_ALLOC_SQS		0x12	/* Allocate secondary Qset */
+#define	NIC_MBOX_MSG_NICVF_PTR		0x13	/* Send nicvf ptr to PF */
+#define	NIC_MBOX_MSG_PNICVF_PTR		0x14	/* Get primary qset nicvf ptr */
+#define	NIC_MBOX_MSG_SNICVF_PTR		0x15	/* Send sqet nicvf ptr to PVF */
+#define	NIC_MBOX_MSG_LOOPBACK		0x16	/* Set interface in loopback */
+#define	NIC_MBOX_MSG_CFG_DONE		0xF0	/* VF configuration done */
+#define	NIC_MBOX_MSG_SHUTDOWN		0xF1	/* VF is being shutdown */
+
+struct nic_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    node_id;
+	bool  tns_mode:1;
+	bool  sqs_mode:1;
+	bool  loopback_supported:1;
+	u8    mac_addr[6];
+};
+
+/* Qset configuration */
+struct qs_cfg_msg {
+	u8    msg;
+	u8    num;
+	u8    sqs_count;
+	u64   cfg;
+};
+
+/* Receive queue configuration */
+struct rq_cfg_msg {
+	u8    msg;
+	u8    qs_num;
+	u8    rq_num;
+	u64   cfg;
+};
+
+/* Send queue configuration */
+struct sq_cfg_msg {
+	u8    msg;
+	u8    qs_num;
+	u8    sq_num;
+	bool  sqs_mode;
+	u64   cfg;
+};
+
+/* Set VF's MAC address */
+struct set_mac_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    mac_addr[6];
+};
+
+/* Set Maximum frame size */
+struct set_frs_msg {
+	u8    msg;
+	u8    vf_id;
+	u16   max_frs;
+};
+
+/* Set CPI algorithm type */
+struct cpi_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    rq_cnt;
+	u8    cpi_alg;
+};
+
+/* Get RSS table size */
+struct rss_sz_msg {
+	u8    msg;
+	u8    vf_id;
+	u16   ind_tbl_size;
+};
+
+/* Set RSS configuration */
+struct rss_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    hash_bits;
+	u8    tbl_len;
+	u8    tbl_offset;
+#define RSS_IND_TBL_LEN_PER_MBX_MSG	8
+	u8    ind_tbl[RSS_IND_TBL_LEN_PER_MBX_MSG];
+};
+
+struct bgx_stats_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    rx;
+	u8    idx;
+	u64   stats;
+};
+
+/* Physical interface link status */
+struct bgx_link_status {
+	u8    msg;
+	u8    link_up;
+	u8    duplex;
+	u32   speed;
+};
+
+#ifdef VNIC_MULTI_QSET_SUPPORT
+/* Get Extra Qset IDs */
+struct sqs_alloc {
+	u8    msg;
+	u8    vf_id;
+	u8    qs_count;
+};
+
+struct nicvf_ptr {
+	u8    msg;
+	u8    vf_id;
+	bool  sqs_mode;
+	u8    sqs_id;
+	u64   nicvf;
+};
+#endif
+
+/* Set interface in loopback mode */
+struct set_loopback {
+	u8    msg;
+	u8    vf_id;
+	bool  enable;
+};
+
+/* 128 bit shared memory between PF and each VF */
+union nic_mbx {
+	struct { u8 msg; }	msg;
+	struct nic_cfg_msg	nic_cfg;
+	struct qs_cfg_msg	qs;
+	struct rq_cfg_msg	rq;
+	struct sq_cfg_msg	sq;
+	struct set_mac_msg	mac;
+	struct set_frs_msg	frs;
+	struct cpi_cfg_msg	cpi_cfg;
+	struct rss_sz_msg	rss_size;
+	struct rss_cfg_msg	rss_cfg;
+	struct bgx_stats_msg    bgx_stats;
+	struct bgx_link_status  link_status;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	struct sqs_alloc        sqs_alloc;
+	struct nicvf_ptr	nicvf;
+#endif
+	struct set_loopback	lbk;
+};
+
+int nicvf_set_real_num_queues(struct udevice *dev,
+			      int tx_queues, int rx_queues);
+int nicvf_open(struct udevice *dev);
+void nicvf_stop(struct udevice *dev);
+int nicvf_send_msg_to_pf(struct nicvf *vf, union nic_mbx *mbx);
+void nicvf_update_stats(struct nicvf *nic);
+
+void nic_handle_mbx_intr(struct nicpf *nic, int vf);
+
+int bgx_poll_for_link(int node, int bgx_idx, int lmacid);
+const u8 *bgx_get_lmac_mac(int node, int bgx_idx, int lmacid);
+void bgx_set_lmac_mac(int node, int bgx_idx, int lmacid, const u8 *mac);
+void bgx_lmac_rx_tx_enable(int node, int bgx_idx, int lmacid, bool enable);
+void bgx_lmac_internal_loopback(int node, int bgx_idx,
+				int lmac_idx, bool enable);
+
+static inline bool pass1_silicon(unsigned int revision, int model_id)
+{
+	return ((revision < 8) && (model_id == 0x88));
+}
+
+static inline bool pass2_silicon(unsigned int revision, int model_id)
+{
+	return ((revision >= 8) && (model_id == 0x88));
+}
+
+#endif /* NIC_H */
diff --git a/drivers/net/octeontx/nic_main.c b/drivers/net/octeontx/nic_main.c
new file mode 100644
index 0000000000..71b43a0c2b
--- /dev/null
+++ b/drivers/net/octeontx/nic_main.c
@@ -0,0 +1,776 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <net.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <asm/io.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "q_struct.h"
+
+unsigned long rounddown_pow_of_two(unsigned long n)
+{
+	n |= n >> 1;
+	n |= n >> 2;
+	n |= n >> 4;
+	n |= n >> 8;
+	n |= n >> 16;
+	n |= n >> 32;
+
+	return(n + 1);
+}
+
+static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg);
+static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
+			       struct sq_cfg_msg *sq);
+static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf);
+static int nic_rcv_queue_sw_sync(struct nicpf *nic);
+
+/* Register read/write APIs */
+static void nic_reg_write(struct nicpf *nic, u64 offset, u64 val)
+{
+	writeq(val, nic->reg_base + offset);
+}
+
+static u64 nic_reg_read(struct nicpf *nic, u64 offset)
+{
+	return readq(nic->reg_base + offset);
+}
+
+static u64 nic_get_mbx_addr(int vf)
+{
+	return NIC_PF_VF_0_127_MAILBOX_0_1 + (vf << NIC_VF_NUM_SHIFT);
+}
+
+static void nic_send_msg_to_vf(struct nicpf *nic, int vf, union nic_mbx *mbx)
+{
+	void __iomem *mbx_addr = (void *)(nic->reg_base + nic_get_mbx_addr(vf));
+	u64 *msg = (u64 *)mbx;
+
+	/* In first revision HW, mbox interrupt is triggerred
+	 * when PF writes to MBOX(1), in next revisions when
+	 * PF writes to MBOX(0)
+	 */
+	if (pass1_silicon(nic->rev_id, nic->hw->model_id)) {
+		/* see the comment for nic_reg_write()/nic_reg_read()
+		 * functions above
+		 */
+		writeq(msg[0], mbx_addr);
+		writeq(msg[1], mbx_addr + 8);
+	} else {
+		writeq(msg[1], mbx_addr + 8);
+		writeq(msg[0], mbx_addr);
+	}
+}
+
+static void nic_mbx_send_ready(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+	int bgx_idx, lmac, timeout = 5, link = -1;
+	const u8 *mac;
+
+	mbx.nic_cfg.msg = NIC_MBOX_MSG_READY;
+	mbx.nic_cfg.vf_id = vf;
+
+	if (nic->flags & NIC_TNS_ENABLED)
+		mbx.nic_cfg.tns_mode = NIC_TNS_MODE;
+	else
+		mbx.nic_cfg.tns_mode = NIC_TNS_BYPASS_MODE;
+
+	if (vf < nic->num_vf_en) {
+		bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		mac = bgx_get_lmac_mac(nic->node, bgx_idx, lmac);
+		if (mac)
+			memcpy((u8 *)&mbx.nic_cfg.mac_addr, mac, 6);
+
+		while (timeout-- && (link <= 0)) {
+			link = bgx_poll_for_link(nic->node, bgx_idx, lmac);
+			debug("Link status: %d\n", link);
+			if (link <= 0)
+				mdelay(2000);
+		}
+	}
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	mbx.nic_cfg.sqs_mode = (vf >= nic->num_vf_en) ? true : false;
+#endif
+	mbx.nic_cfg.node_id = nic->node;
+
+	mbx.nic_cfg.loopback_supported = vf < nic->num_vf_en;
+
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+/* ACKs VF's mailbox message
+ * @vf: VF to which ACK to be sent
+ */
+static void nic_mbx_send_ack(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_ACK;
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+/* NACKs VF's mailbox message that PF is not able to
+ * complete the action
+ * @vf: VF to which ACK to be sent
+ */
+static void nic_mbx_send_nack(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_NACK;
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+static int nic_config_loopback(struct nicpf *nic, struct set_loopback *lbk)
+{
+	int bgx_idx, lmac_idx;
+
+	if (lbk->vf_id > nic->num_vf_en)
+		return -1;
+
+	bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);
+	lmac_idx = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);
+
+	bgx_lmac_internal_loopback(nic->node, bgx_idx, lmac_idx, lbk->enable);
+
+	return 0;
+}
+
+/* Interrupt handler to handle mailbox messages from VFs */
+void nic_handle_mbx_intr(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+	u64 *mbx_data;
+	u64 mbx_addr;
+	u64 reg_addr;
+	u64 cfg;
+	int bgx, lmac;
+	int i;
+	int ret = 0;
+
+	nic->mbx_lock[vf] = true;
+
+	mbx_addr = nic_get_mbx_addr(vf);
+	mbx_data = (u64 *)&mbx;
+
+	for (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {
+		*mbx_data = nic_reg_read(nic, mbx_addr);
+		mbx_data++;
+		mbx_addr += sizeof(u64);
+	}
+
+	debug("%s: Mailbox msg %d from VF%d\n", __func__, mbx.msg.msg, vf);
+	switch (mbx.msg.msg) {
+	case NIC_MBOX_MSG_READY:
+		nic_mbx_send_ready(nic, vf);
+		if (vf < nic->num_vf_en) {
+			nic->link[vf] = 0;
+			nic->duplex[vf] = 0;
+			nic->speed[vf] = 0;
+		}
+		ret = 1;
+		break;
+	case NIC_MBOX_MSG_QS_CFG:
+		reg_addr = NIC_PF_QSET_0_127_CFG |
+			   (mbx.qs.num << NIC_QS_ID_SHIFT);
+		cfg = mbx.qs.cfg;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		/* Check if its a secondary Qset */
+		if (vf >= nic->num_vf_en) {
+			cfg = cfg & (~0x7FULL);
+			/* Assign this Qset to primary Qset's VF */
+			cfg |= nic->pqs_vf[vf];
+		}
+#endif
+		nic_reg_write(nic, reg_addr, cfg);
+		break;
+	case NIC_MBOX_MSG_RQ_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		/* Enable CQE_RX2_S extension in CQE_RX descriptor.
+		 * This gets appended by default on 81xx/83xx chips,
+		 * for consistency enabling the same on 88xx pass2
+		 * where this is introduced.
+		 */
+		if (pass2_silicon(nic->rev_id, nic->hw->model_id))
+			nic_reg_write(nic, NIC_PF_RX_CFG, 0x01);
+		break;
+	case NIC_MBOX_MSG_RQ_BP_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_BP_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		break;
+	case NIC_MBOX_MSG_RQ_SW_SYNC:
+		ret = nic_rcv_queue_sw_sync(nic);
+		break;
+	case NIC_MBOX_MSG_RQ_DROP_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		break;
+	case NIC_MBOX_MSG_SQ_CFG:
+		reg_addr = NIC_PF_QSET_0_127_SQ_0_7_CFG |
+			   (mbx.sq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.sq.sq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.sq.cfg);
+		nic_tx_channel_cfg(nic, mbx.qs.num,
+				   (struct sq_cfg_msg *)&mbx.sq);
+		break;
+	case NIC_MBOX_MSG_SET_MAC:
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		if (vf >= nic->num_vf_en)
+			break;
+#endif
+		lmac = mbx.mac.vf_id;
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);
+		bgx_set_lmac_mac(nic->node, bgx, lmac, mbx.mac.mac_addr);
+		break;
+	case NIC_MBOX_MSG_SET_MAX_FRS:
+		ret = nic_update_hw_frs(nic, mbx.frs.max_frs,
+					mbx.frs.vf_id);
+		break;
+	case NIC_MBOX_MSG_CPI_CFG:
+		nic_config_cpi(nic, &mbx.cpi_cfg);
+		break;
+#ifdef VNIC_RSS_SUPPORT
+	case NIC_MBOX_MSG_RSS_SIZE:
+		nic_send_rss_size(nic, vf);
+		goto unlock;
+	case NIC_MBOX_MSG_RSS_CFG:
+	case NIC_MBOX_MSG_RSS_CFG_CONT:
+		nic_config_rss(nic, &mbx.rss_cfg);
+		break;
+#endif
+	case NIC_MBOX_MSG_CFG_DONE:
+		/* Last message of VF config msg sequence */
+		nic->vf_enabled[vf] = true;
+		if (vf >= nic->lmac_cnt)
+			goto unlock;
+
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		bgx_lmac_rx_tx_enable(nic->node, bgx, lmac, true);
+		goto unlock;
+	case NIC_MBOX_MSG_SHUTDOWN:
+		/* First msg in VF teardown sequence */
+		nic->vf_enabled[vf] = false;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		if (vf >= nic->num_vf_en)
+			nic->sqs_used[vf - nic->num_vf_en] = false;
+		nic->pqs_vf[vf] = 0;
+#endif
+		if (vf >= nic->lmac_cnt)
+			break;
+
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		bgx_lmac_rx_tx_enable(nic->node, bgx, lmac, false);
+		break;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	case NIC_MBOX_MSG_ALLOC_SQS:
+		nic_alloc_sqs(nic, &mbx.sqs_alloc);
+		goto unlock;
+	case NIC_MBOX_MSG_NICVF_PTR:
+		nic->nicvf[vf] = mbx.nicvf.nicvf;
+		break;
+	case NIC_MBOX_MSG_PNICVF_PTR:
+		nic_send_pnicvf(nic, vf);
+		goto unlock;
+	case NIC_MBOX_MSG_SNICVF_PTR:
+		nic_send_snicvf(nic, &mbx.nicvf);
+		goto unlock;
+#endif
+	case NIC_MBOX_MSG_LOOPBACK:
+		ret = nic_config_loopback(nic, &mbx.lbk);
+		break;
+	default:
+		printf("Invalid msg from VF%d, msg 0x%x\n", vf, mbx.msg.msg);
+		break;
+	}
+
+	if (!ret)
+		nic_mbx_send_ack(nic, vf);
+	else if (mbx.msg.msg != NIC_MBOX_MSG_READY)
+		nic_mbx_send_nack(nic, vf);
+unlock:
+	nic->mbx_lock[vf] = false;
+}
+
+static int nic_rcv_queue_sw_sync(struct nicpf *nic)
+{
+	int timeout = 20;
+
+	nic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x01);
+	while (timeout) {
+		if (nic_reg_read(nic, NIC_PF_SW_SYNC_RX_DONE) & 0x1)
+			break;
+		udelay(2000);
+		timeout--;
+	}
+	nic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x00);
+	if (!timeout) {
+		printf("Recevie queue software sync failed");
+		return 1;
+	}
+	return 0;
+}
+
+static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)
+{
+	u64 *pkind = (u64 *)&nic->pkind;
+
+	if (new_frs > NIC_HW_MAX_FRS || new_frs < NIC_HW_MIN_FRS) {
+		printf("Invalid MTU setting from VF%d rejected,", vf);
+		printf(" should be between %d and %d\n", NIC_HW_MIN_FRS,
+		       NIC_HW_MAX_FRS);
+		return 1;
+	}
+	new_frs += ETH_HLEN;
+	if (new_frs <= nic->pkind.maxlen)
+		return 0;
+
+	nic->pkind.maxlen = new_frs;
+
+	nic_reg_write(nic, NIC_PF_PKIND_0_15_CFG, *pkind);
+	return 0;
+}
+
+/* Set minimum transmit packet size */
+static void nic_set_tx_pkt_pad(struct nicpf *nic, int size)
+{
+	int lmac;
+	u64 lmac_cfg;
+	struct hw_info *hw = nic->hw;
+	int max_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;
+
+	/* Max value that can be set is 60 */
+	if (size > 52)
+		size = 52;
+
+	/* CN81XX has RGX configured as FAKE BGX, adjust mac_lmac accordingly */
+	if (hw->chans_per_rgx)
+		max_lmac = ((nic->hw->bgx_cnt - 1) * MAX_LMAC_PER_BGX) + 1;
+
+	for (lmac = 0; lmac < max_lmac; lmac++) {
+		lmac_cfg = nic_reg_read(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3));
+		lmac_cfg &= ~(0xF << 2);
+		lmac_cfg |= ((size / 4) << 2);
+		nic_reg_write(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3), lmac_cfg);
+	}
+}
+
+/* Function to check number of LMACs present and set VF to LMAC mapping.
+ * Mapping will be used while initializing channels.
+ */
+static void nic_set_lmac_vf_mapping(struct nicpf *nic)
+{
+	int bgx, bgx_count, next_bgx_lmac = 0;
+	int lmac, lmac_cnt = 0;
+	u64 lmac_credit;
+
+	nic->num_vf_en = 0;
+	if (nic->flags & NIC_TNS_ENABLED) {
+		nic->num_vf_en = DEFAULT_NUM_VF_ENABLED;
+		return;
+	}
+
+	bgx_get_count(nic->node, &bgx_count);
+	debug("bgx_count: %d\n", bgx_count);
+
+	for (bgx = 0; bgx < nic->hw->bgx_cnt; bgx++) {
+		if (!(bgx_count & (1 << bgx)))
+			continue;
+		nic->bgx_cnt++;
+		lmac_cnt = bgx_get_lmac_count(nic->node, bgx);
+		debug("lmac_cnt: %d for BGX%d\n", lmac_cnt, bgx);
+		for (lmac = 0; lmac < lmac_cnt; lmac++)
+			nic->vf_lmac_map[next_bgx_lmac++] =
+						NIC_SET_VF_LMAC_MAP(bgx, lmac);
+		nic->num_vf_en += lmac_cnt;
+
+		/* Program LMAC credits */
+		lmac_credit = (1ull << 1); /* chennel credit enable */
+		lmac_credit |= (0x1ff << 2);
+		lmac_credit |= (((((48 * 1024) / lmac_cnt) -
+				NIC_HW_MAX_FRS) / 16) << 12);
+		lmac = bgx * MAX_LMAC_PER_BGX;
+		for (; lmac < lmac_cnt + (bgx * MAX_LMAC_PER_BGX); lmac++)
+			nic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8),
+				      lmac_credit);
+	}
+}
+
+static void nic_get_hw_info(struct nicpf *nic)
+{
+	u16 sdevid;
+	struct hw_info *hw = nic->hw;
+
+	dm_pci_read_config16(nic->udev, PCI_SUBSYSTEM_ID, &sdevid);
+
+	switch (sdevid) {
+	case PCI_SUBSYS_DEVID_88XX_NIC_PF:
+		hw->bgx_cnt = MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 16;
+		hw->chans_per_bgx = 128;
+		hw->cpi_cnt = 2048;
+		hw->rssi_cnt = 4096;
+		hw->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;
+		hw->tl3_cnt = 256;
+		hw->tl2_cnt = 64;
+		hw->tl1_cnt = 2;
+		hw->tl1_per_bgx = true;
+		hw->model_id = 0x88;
+		break;
+	case PCI_SUBSYS_DEVID_81XX_NIC_PF:
+		hw->bgx_cnt = MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 8;
+		hw->chans_per_bgx = 32;
+		hw->chans_per_rgx = 8;
+		hw->chans_per_lbk = 24;
+		hw->cpi_cnt = 512;
+		hw->rssi_cnt = 256;
+		hw->rss_ind_tbl_size = 32; /* Max RSSI / Max interfaces */
+		hw->tl3_cnt = 64;
+		hw->tl2_cnt = 16;
+		hw->tl1_cnt = 10;
+		hw->tl1_per_bgx = false;
+		hw->model_id = 0x81;
+		break;
+	case PCI_SUBSYS_DEVID_83XX_NIC_PF:
+		hw->bgx_cnt = MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 8;
+		hw->chans_per_bgx = 32;
+		hw->chans_per_lbk = 64;
+		hw->cpi_cnt = 2048;
+		hw->rssi_cnt = 1024;
+		hw->rss_ind_tbl_size = 64; /* Max RSSI / Max interfaces */
+		hw->tl3_cnt = 256;
+		hw->tl2_cnt = 64;
+		hw->tl1_cnt = 18;
+		hw->tl1_per_bgx = false;
+		hw->model_id = 0x83;
+		break;
+	}
+
+	hw->tl4_cnt = MAX_QUEUES_PER_QSET * pci_sriov_get_totalvfs(nic->udev);
+}
+
+static void nic_init_hw(struct nicpf *nic)
+{
+	int i;
+	u64 reg;
+	u64 *pkind = (u64 *)&nic->pkind;
+
+	/* Get HW capability info */
+	nic_get_hw_info(nic);
+
+	/* Enable NIC HW block */
+	nic_reg_write(nic, NIC_PF_CFG, 0x3);
+
+	/* Enable backpressure */
+	nic_reg_write(nic, NIC_PF_BP_CFG, (1ULL << 6) | 0x03);
+	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG, (1ULL << 63) | 0x08);
+	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8),
+		      (1ULL << 63) | 0x09);
+
+	for (i = 0; i < NIC_MAX_CHANS; i++)
+		nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (i << 3), 1);
+
+	if (nic->flags & NIC_TNS_ENABLED) {
+		reg = NIC_TNS_MODE << 7;
+		reg |= 0x06;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG, reg);
+		reg &= ~0xFull;
+		reg |= 0x07;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8), reg);
+	} else {
+		/* Disable TNS mode on both interfaces */
+		reg = NIC_TNS_BYPASS_MODE << 7;
+		reg |= 0x08; /* Block identifier */
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG, reg);
+		reg &= ~0xFull;
+		reg |= 0x09;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8), reg);
+	}
+
+	/* PKIND configuration */
+	nic->pkind.minlen = 0;
+	nic->pkind.maxlen = NIC_HW_MAX_FRS + ETH_HLEN;
+	nic->pkind.lenerr_en = 1;
+	nic->pkind.rx_hdr = 0;
+	nic->pkind.hdr_sl = 0;
+
+	for (i = 0; i < NIC_MAX_PKIND; i++)
+		nic_reg_write(nic, NIC_PF_PKIND_0_15_CFG | (i << 3), *pkind);
+
+	nic_set_tx_pkt_pad(nic, NIC_HW_MIN_FRS);
+
+	/* Timer config */
+	nic_reg_write(nic, NIC_PF_INTR_TIMER_CFG, NICPF_CLK_PER_INT_TICK);
+}
+
+/* Channel parse index configuration */
+static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)
+{
+	struct hw_info *hw = nic->hw;
+	u32 vnic, bgx, lmac, chan;
+	u32 padd, cpi_count = 0;
+	u64 cpi_base, cpi, rssi_base, rssi;
+	u8  qset, rq_idx = 0;
+
+	vnic = cfg->vf_id;
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
+
+	chan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);
+	cpi_base = vnic * NIC_MAX_CPI_PER_LMAC;
+	rssi_base = vnic * hw->rss_ind_tbl_size;
+
+	/* Rx channel configuration */
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_RX_BP_CFG | (chan << 3),
+		      (1ull << 63) | (vnic << 0));
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_RX_CFG | (chan << 3),
+		      ((u64)cfg->cpi_alg << 62) | (cpi_base << 48));
+
+	if (cfg->cpi_alg == CPI_ALG_NONE)
+		cpi_count = 1;
+	else if (cfg->cpi_alg == CPI_ALG_VLAN) /* 3 bits of PCP */
+		cpi_count = 8;
+	else if (cfg->cpi_alg == CPI_ALG_VLAN16) /* 3 bits PCP + DEI */
+		cpi_count = 16;
+	else if (cfg->cpi_alg == CPI_ALG_DIFF) /* 6bits DSCP */
+		cpi_count = NIC_MAX_CPI_PER_LMAC;
+
+	/* RSS Qset, Qidx mapping */
+	qset = cfg->vf_id;
+	rssi = rssi_base;
+	for (; rssi < (rssi_base + cfg->rq_cnt); rssi++) {
+		nic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),
+			      (qset << 3) | rq_idx);
+		rq_idx++;
+	}
+
+	rssi = 0;
+	cpi = cpi_base;
+	for (; cpi < (cpi_base + cpi_count); cpi++) {
+		/* Determine port to channel adder */
+		if (cfg->cpi_alg != CPI_ALG_DIFF)
+			padd = cpi % cpi_count;
+		else
+			padd = cpi % 8; /* 3 bits CS out of 6bits DSCP */
+
+		/* Leave RSS_SIZE as '0' to disable RSS */
+		if (pass1_silicon(nic->rev_id, nic->hw->model_id)) {
+			nic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),
+				      (vnic << 24) | (padd << 16) |
+				      (rssi_base + rssi));
+		} else {
+			/* Set MPI_ALG to '0' to disable MCAM parsing */
+			nic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),
+				      (padd << 16));
+			/* MPI index is same as CPI if MPI_ALG is not enabled */
+			nic_reg_write(nic, NIC_PF_MPI_0_2047_CFG | (cpi << 3),
+				      (vnic << 24) | (rssi_base + rssi));
+		}
+
+		if ((rssi + 1) >= cfg->rq_cnt)
+			continue;
+
+		if (cfg->cpi_alg == CPI_ALG_VLAN)
+			rssi++;
+		else if (cfg->cpi_alg == CPI_ALG_VLAN16)
+			rssi = ((cpi - cpi_base) & 0xe) >> 1;
+		else if (cfg->cpi_alg == CPI_ALG_DIFF)
+			rssi = ((cpi - cpi_base) & 0x38) >> 3;
+	}
+	nic->cpi_base[cfg->vf_id] = cpi_base;
+	nic->rssi_base[cfg->vf_id] = rssi_base;
+}
+
+/* Transmit channel configuration (TL4 -> TL3 -> Chan)
+ * VNIC0-SQ0 -> TL4(0)  -> TL4A(0) -> TL3[0] -> BGX0/LMAC0/Chan0
+ * VNIC1-SQ0 -> TL4(8)  -> TL4A(2) -> TL3[2] -> BGX0/LMAC1/Chan0
+ * VNIC2-SQ0 -> TL4(16) -> TL4A(4) -> TL3[4] -> BGX0/LMAC2/Chan0
+ * VNIC3-SQ0 -> TL4(32) -> TL4A(6) -> TL3[6] -> BGX0/LMAC3/Chan0
+ * VNIC4-SQ0 -> TL4(512)  -> TL4A(128) -> TL3[128] -> BGX1/LMAC0/Chan0
+ * VNIC5-SQ0 -> TL4(520)  -> TL4A(130) -> TL3[130] -> BGX1/LMAC1/Chan0
+ * VNIC6-SQ0 -> TL4(528)  -> TL4A(132) -> TL3[132] -> BGX1/LMAC2/Chan0
+ * VNIC7-SQ0 -> TL4(536)  -> TL4A(134) -> TL3[134] -> BGX1/LMAC3/Chan0
+ */
+static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
+			       struct sq_cfg_msg *sq)
+{
+	struct hw_info *hw = nic->hw;
+	u32 bgx, lmac, chan;
+	u32 tl2, tl3, tl4;
+	u32 rr_quantum;
+	u8 sq_idx = sq->sq_num;
+	u8 pqs_vnic = vnic;
+	int svf;
+	u16 sdevid;
+
+	dm_pci_read_config16(nic->udev, PCI_SUBSYSTEM_ID, &sdevid);
+
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);
+
+	/* 24 bytes for FCS, IPG and preamble */
+	rr_quantum = ((NIC_HW_MAX_FRS + 24) / 4);
+
+	/* For 88xx 0-511 TL4 transmits via BGX0 and
+	 * 512-1023 TL4s transmit via BGX1.
+	 */
+	if (hw->tl1_per_bgx) {
+		tl4 = bgx * (hw->tl4_cnt / hw->bgx_cnt);
+		if (!sq->sqs_mode) {
+			tl4 += (lmac * MAX_QUEUES_PER_QSET);
+		} else {
+			for (svf = 0; svf < MAX_SQS_PER_VF_SINGLE_NODE; svf++) {
+				if (nic->vf_sqs[pqs_vnic][svf] == vnic)
+					break;
+			}
+			tl4 += (MAX_LMAC_PER_BGX * MAX_QUEUES_PER_QSET);
+			tl4 += (lmac * MAX_QUEUES_PER_QSET *
+				MAX_SQS_PER_VF_SINGLE_NODE);
+			tl4 += (svf * MAX_QUEUES_PER_QSET);
+		}
+	} else {
+		tl4 = (vnic * MAX_QUEUES_PER_QSET);
+	}
+
+	tl4 += sq_idx;
+
+	tl3 = tl4 / (hw->tl4_cnt / hw->tl3_cnt);
+	nic_reg_write(nic, NIC_PF_QSET_0_127_SQ_0_7_CFG2 |
+		      ((u64)vnic << NIC_QS_ID_SHIFT) |
+		      ((u32)sq_idx << NIC_Q_NUM_SHIFT), tl4);
+	nic_reg_write(nic, NIC_PF_TL4_0_1023_CFG | (tl4 << 3),
+		      ((u64)vnic << 27) | ((u32)sq_idx << 24) | rr_quantum);
+
+	nic_reg_write(nic, NIC_PF_TL3_0_255_CFG | (tl3 << 3), rr_quantum);
+
+	/* On 88xx 0-127 channels are for BGX0 and
+	 * 127-255 channels for BGX1.
+	 *
+	 * On 81xx/83xx TL3_CHAN reg should be configured with channel
+	 * within LMAC i.e 0-7 and not the actual channel number like on 88xx
+	 */
+	chan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);
+	if (hw->tl1_per_bgx)
+		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), chan);
+	else
+		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), 0);
+
+	/* Enable backpressure on the channel */
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (chan << 3), 1);
+
+	tl2 = tl3 >> 2;
+	nic_reg_write(nic, NIC_PF_TL3A_0_63_CFG | (tl2 << 3), tl2);
+	nic_reg_write(nic, NIC_PF_TL2_0_63_CFG | (tl2 << 3), rr_quantum);
+	/* No priorities as of now */
+	nic_reg_write(nic, NIC_PF_TL2_0_63_PRI | (tl2 << 3), 0x00);
+
+	/* Unlike 88xx where TL2s 0-31 transmits to TL1 '0' and rest to TL1 '1'
+	 * on 81xx/83xx TL2 needs to be configured to transmit to one of the
+	 * possible LMACs.
+	 *
+	 * This register doesn't exist on 88xx.
+	 */
+	if (!hw->tl1_per_bgx)
+		nic_reg_write(nic, NIC_PF_TL2_LMAC | (tl2 << 3),
+			      lmac + (bgx * MAX_LMAC_PER_BGX));
+}
+
+int nic_initialize(struct udevice *dev)
+{
+	struct nicpf *nic = dev_get_priv(dev);
+
+	nic->udev = dev;
+	nic->hw = calloc(1, sizeof(struct hw_info));
+	if (!nic->hw)
+		return -ENOMEM;
+
+	/* MAP PF's configuration registers */
+	nic->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+				       PCI_REGION_MEM);
+	if (!nic->reg_base) {
+		printf("Cannot map config register space, aborting\n");
+		goto exit;
+	}
+
+	nic->node = node_id(nic->reg_base);
+	dm_pci_read_config8(dev, PCI_REVISION_ID, &nic->rev_id);
+
+	/* By default set NIC in TNS bypass mode */
+	nic->flags &= ~NIC_TNS_ENABLED;
+
+	/* Initialize hardware */
+	nic_init_hw(nic);
+
+	nic_set_lmac_vf_mapping(nic);
+
+	/* Set RSS TBL size for each VF */
+	nic->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;
+
+	nic->rss_ind_tbl_size = rounddown_pow_of_two(nic->rss_ind_tbl_size);
+
+	return 0;
+exit:
+	free(nic->hw);
+	return -ENODEV;
+}
+
+int octeontx_nic_probe(struct udevice *dev)
+{
+	int ret = 0;
+	struct nicpf *nicpf = dev_get_priv(dev);
+
+	nicpf->udev = dev;
+	ret = nic_initialize(dev);
+	if (ret < 0) {
+		printf("couldn't initialize NIC PF\n");
+		return ret;
+	}
+	ret = pci_sriov_init(dev, nicpf->num_vf_en);
+	if (ret < 0)
+		printf("enabling SRIOV failed for num VFs %d\n",
+		       nicpf->num_vf_en);
+	return ret;
+}
+
+U_BOOT_DRIVER(octeontx_nic) = {
+	.name	= "octeontx_nic",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_nic_probe,
+	.priv_auto_alloc_size = sizeof(struct nicpf),
+};
+
+static struct pci_device_id octeontx_nic_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_PF) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_nic, octeontx_nic_supported);
diff --git a/drivers/net/octeontx/nic_reg.h b/drivers/net/octeontx/nic_reg.h
new file mode 100644
index 0000000000..d8a4a7bd39
--- /dev/null
+++ b/drivers/net/octeontx/nic_reg.h
@@ -0,0 +1,252 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef NIC_REG_H
+#define NIC_REG_H
+
+#define   NIC_PF_REG_COUNT			29573
+#define   NIC_VF_REG_COUNT			249
+
+/* Physical function register offsets */
+#define   NIC_PF_CFG				(0x0000)
+#define   NIC_PF_STATUS				(0x0010)
+
+#define   NIC_PF_INTR_TIMER_CFG			(0x0030)
+#define   NIC_PF_BIST_STATUS			(0x0040)
+#define   NIC_PF_SOFT_RESET			(0x0050)
+
+#define   NIC_PF_TCP_TIMER			(0x0060)
+#define   NIC_PF_BP_CFG				(0x0080)
+#define   NIC_PF_RRM_CFG			(0x0088)
+#define   NIC_PF_CQM_CF				(0x00A0)
+#define   NIC_PF_CNM_CF				(0x00A8)
+#define   NIC_PF_CNM_STATUS			(0x00B0)
+#define   NIC_PF_CQ_AVG_CFG			(0x00C0)
+#define   NIC_PF_RRM_AVG_CFG			(0x00C8)
+
+#define   NIC_PF_INTF_0_1_SEND_CFG		(0x0200)
+#define   NIC_PF_INTF_0_1_BP_CFG		(0x0208)
+#define   NIC_PF_INTF_0_1_BP_DIS_0_1		(0x0210)
+#define   NIC_PF_INTF_0_1_BP_SW_0_1		(0x0220)
+#define   NIC_PF_RBDR_BP_STATE_0_3		(0x0240)
+
+#define   NIC_PF_MAILBOX_INT			(0x0410)
+#define   NIC_PF_MAILBOX_INT_W1S		(0x0430)
+#define   NIC_PF_MAILBOX_ENA_W1C		(0x0450)
+#define   NIC_PF_MAILBOX_ENA_W1S		(0x0470)
+
+#define   NIC_PF_RX_ETYPE_0_7			(0x0500)
+#define   NIC_PF_RX_CFG				(0x05D0)
+#define   NIC_PF_PKIND_0_15_CFG			(0x0600)
+
+#define   NIC_PF_ECC0_FLIP0			(0x1000)
+#define   NIC_PF_ECC1_FLIP0			(0x1008)
+#define   NIC_PF_ECC2_FLIP0			(0x1010)
+#define   NIC_PF_ECC3_FLIP0			(0x1018)
+#define   NIC_PF_ECC0_FLIP1			(0x1080)
+#define   NIC_PF_ECC1_FLIP1			(0x1088)
+#define   NIC_PF_ECC2_FLIP1			(0x1090)
+#define   NIC_PF_ECC3_FLIP1			(0x1098)
+#define   NIC_PF_ECC0_CDIS			(0x1100)
+#define   NIC_PF_ECC1_CDIS			(0x1108)
+#define   NIC_PF_ECC2_CDIS			(0x1110)
+#define   NIC_PF_ECC3_CDIS			(0x1118)
+#define   NIC_PF_BIST0_STATUS			(0x1280)
+#define   NIC_PF_BIST1_STATUS			(0x1288)
+#define   NIC_PF_BIST2_STATUS			(0x1290)
+#define   NIC_PF_BIST3_STATUS			(0x1298)
+
+#define   NIC_PF_ECC0_SBE_INT			(0x2000)
+#define   NIC_PF_ECC0_SBE_INT_W1S		(0x2008)
+#define   NIC_PF_ECC0_SBE_ENA_W1C		(0x2010)
+#define   NIC_PF_ECC0_SBE_ENA_W1S		(0x2018)
+#define   NIC_PF_ECC0_DBE_INT			(0x2100)
+#define   NIC_PF_ECC0_DBE_INT_W1S		(0x2108)
+#define   NIC_PF_ECC0_DBE_ENA_W1C		(0x2110)
+#define   NIC_PF_ECC0_DBE_ENA_W1S		(0x2118)
+
+#define   NIC_PF_ECC1_SBE_INT			(0x2200)
+#define   NIC_PF_ECC1_SBE_INT_W1S		(0x2208)
+#define   NIC_PF_ECC1_SBE_ENA_W1C		(0x2210)
+#define   NIC_PF_ECC1_SBE_ENA_W1S		(0x2218)
+#define   NIC_PF_ECC1_DBE_INT			(0x2300)
+#define   NIC_PF_ECC1_DBE_INT_W1S		(0x2308)
+#define   NIC_PF_ECC1_DBE_ENA_W1C		(0x2310)
+#define   NIC_PF_ECC1_DBE_ENA_W1S		(0x2318)
+
+#define   NIC_PF_ECC2_SBE_INT			(0x2400)
+#define   NIC_PF_ECC2_SBE_INT_W1S		(0x2408)
+#define   NIC_PF_ECC2_SBE_ENA_W1C		(0x2410)
+#define   NIC_PF_ECC2_SBE_ENA_W1S		(0x2418)
+#define   NIC_PF_ECC2_DBE_INT			(0x2500)
+#define   NIC_PF_ECC2_DBE_INT_W1S		(0x2508)
+#define   NIC_PF_ECC2_DBE_ENA_W1C		(0x2510)
+#define   NIC_PF_ECC2_DBE_ENA_W1S		(0x2518)
+
+#define   NIC_PF_ECC3_SBE_INT			(0x2600)
+#define   NIC_PF_ECC3_SBE_INT_W1S		(0x2608)
+#define   NIC_PF_ECC3_SBE_ENA_W1C		(0x2610)
+#define   NIC_PF_ECC3_SBE_ENA_W1S		(0x2618)
+#define   NIC_PF_ECC3_DBE_INT			(0x2700)
+#define   NIC_PF_ECC3_DBE_INT_W1S		(0x2708)
+#define   NIC_PF_ECC3_DBE_ENA_W1C		(0x2710)
+#define   NIC_PF_ECC3_DBE_ENA_W1S		(0x2718)
+
+#define   NIC_PF_CPI_0_2047_CFG			(0x200000)
+#define   NIC_PF_MPI_0_2047_CFG			(0x210000)
+#define   NIC_PF_RSSI_0_4097_RQ			(0x220000)
+#define   NIC_PF_LMAC_0_7_CFG			(0x240000)
+#define   NIC_PF_LMAC_0_7_SW_XOFF		(0x242000)
+#define   NIC_PF_LMAC_0_7_CREDIT		(0x244000)
+#define   NIC_PF_CHAN_0_255_TX_CFG		(0x400000)
+#define   NIC_PF_CHAN_0_255_RX_CFG		(0x420000)
+#define   NIC_PF_CHAN_0_255_SW_XOFF		(0x440000)
+#define   NIC_PF_CHAN_0_255_CREDIT		(0x460000)
+#define   NIC_PF_CHAN_0_255_RX_BP_CFG		(0x480000)
+
+#define   NIC_PF_SW_SYNC_RX			(0x490000)
+
+#define   NIC_PF_SW_SYNC_RX_DONE		(0x490008)
+#define   NIC_PF_TL2_0_63_CFG			(0x500000)
+#define   NIC_PF_TL2_0_63_PRI			(0x520000)
+#define   NIC_PF_TL2_LMAC			(0x540000)
+#define   NIC_PF_TL2_0_63_SH_STATUS		(0x580000)
+#define   NIC_PF_TL3A_0_63_CFG			(0x5F0000)
+#define   NIC_PF_TL3_0_255_CFG			(0x600000)
+#define   NIC_PF_TL3_0_255_CHAN			(0x620000)
+#define   NIC_PF_TL3_0_255_PIR			(0x640000)
+#define   NIC_PF_TL3_0_255_SW_XOFF		(0x660000)
+#define   NIC_PF_TL3_0_255_CNM_RATE		(0x680000)
+#define   NIC_PF_TL3_0_255_SH_STATUS		(0x6A0000)
+#define   NIC_PF_TL4A_0_255_CFG			(0x6F0000)
+#define   NIC_PF_TL4_0_1023_CFG			(0x800000)
+#define   NIC_PF_TL4_0_1023_SW_XOFF		(0x820000)
+#define   NIC_PF_TL4_0_1023_SH_STATUS		(0x840000)
+#define   NIC_PF_TL4A_0_1023_CNM_RATE		(0x880000)
+#define   NIC_PF_TL4A_0_1023_CNM_STATUS		(0x8A0000)
+
+#define   NIC_PF_VF_0_127_MAILBOX_0_1		(0x20002030)
+#define   NIC_PF_VNIC_0_127_TX_STAT_0_4		(0x20004000)
+#define   NIC_PF_VNIC_0_127_RX_STAT_0_13	(0x20004100)
+#define   NIC_PF_QSET_0_127_LOCK_0_15		(0x20006000)
+#define   NIC_PF_QSET_0_127_CFG			(0x20010000)
+#define   NIC_PF_QSET_0_127_RQ_0_7_CFG		(0x20010400)
+#define   NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG	(0x20010420)
+#define   NIC_PF_QSET_0_127_RQ_0_7_BP_CFG	(0x20010500)
+#define   NIC_PF_QSET_0_127_RQ_0_7_STAT_0_1	(0x20010600)
+#define   NIC_PF_QSET_0_127_SQ_0_7_CFG		(0x20010C00)
+#define   NIC_PF_QSET_0_127_SQ_0_7_CFG2		(0x20010C08)
+#define   NIC_PF_QSET_0_127_SQ_0_7_STAT_0_1	(0x20010D00)
+
+#define   NIC_PF_MSIX_VEC_0_18_ADDR		(0x000000)
+#define   NIC_PF_MSIX_VEC_0_CTL			(0x000008)
+#define   NIC_PF_MSIX_PBA_0			(0x0F0000)
+
+/* Virtual function register offsets */
+#define   NIC_VNIC_CFG				(0x000020)
+#define   NIC_VF_PF_MAILBOX_0_1			(0x000130)
+#define   NIC_VF_INT				(0x000200)
+#define   NIC_VF_INT_W1S			(0x000220)
+#define   NIC_VF_ENA_W1C			(0x000240)
+#define   NIC_VF_ENA_W1S			(0x000260)
+
+#define   NIC_VNIC_RSS_CFG			(0x0020E0)
+#define   NIC_VNIC_RSS_KEY_0_4			(0x002200)
+#define   NIC_VNIC_TX_STAT_0_4			(0x004000)
+#define   NIC_VNIC_RX_STAT_0_13			(0x004100)
+#define   NIC_QSET_RQ_GEN_CFG			(0x010010)
+
+#define   NIC_QSET_CQ_0_7_CFG			(0x010400)
+#define   NIC_QSET_CQ_0_7_CFG2			(0x010408)
+#define   NIC_QSET_CQ_0_7_THRESH		(0x010410)
+#define   NIC_QSET_CQ_0_7_BASE			(0x010420)
+#define   NIC_QSET_CQ_0_7_HEAD			(0x010428)
+#define   NIC_QSET_CQ_0_7_TAIL			(0x010430)
+#define   NIC_QSET_CQ_0_7_DOOR			(0x010438)
+#define   NIC_QSET_CQ_0_7_STATUS		(0x010440)
+#define   NIC_QSET_CQ_0_7_STATUS2		(0x010448)
+#define   NIC_QSET_CQ_0_7_DEBUG			(0x010450)
+
+#define   NIC_QSET_RQ_0_7_CFG			(0x010600)
+#define   NIC_QSET_RQ_0_7_STAT_0_1		(0x010700)
+
+#define   NIC_QSET_SQ_0_7_CFG			(0x010800)
+#define   NIC_QSET_SQ_0_7_THRESH		(0x010810)
+#define   NIC_QSET_SQ_0_7_BASE			(0x010820)
+#define   NIC_QSET_SQ_0_7_HEAD			(0x010828)
+#define   NIC_QSET_SQ_0_7_TAIL			(0x010830)
+#define   NIC_QSET_SQ_0_7_DOOR			(0x010838)
+#define   NIC_QSET_SQ_0_7_STATUS		(0x010840)
+#define   NIC_QSET_SQ_0_7_DEBUG			(0x010848)
+#define   NIC_QSET_SQ_0_7_CNM_CHG		(0x010860)
+#define   NIC_QSET_SQ_0_7_STAT_0_1		(0x010900)
+
+#define   NIC_QSET_RBDR_0_1_CFG			(0x010C00)
+#define   NIC_QSET_RBDR_0_1_THRESH		(0x010C10)
+#define   NIC_QSET_RBDR_0_1_BASE		(0x010C20)
+#define   NIC_QSET_RBDR_0_1_HEAD		(0x010C28)
+#define   NIC_QSET_RBDR_0_1_TAIL		(0x010C30)
+#define   NIC_QSET_RBDR_0_1_DOOR		(0x010C38)
+#define   NIC_QSET_RBDR_0_1_STATUS0		(0x010C40)
+#define   NIC_QSET_RBDR_0_1_STATUS1		(0x010C48)
+#define   NIC_QSET_RBDR_0_1_PREFETCH_STATUS	(0x010C50)
+
+#define   NIC_VF_MSIX_VECTOR_0_19_ADDR		(0x000000)
+#define   NIC_VF_MSIX_VECTOR_0_19_CTL		(0x000008)
+#define   NIC_VF_MSIX_PBA			(0x0F0000)
+
+/* Offsets within registers */
+#define   NIC_MSIX_VEC_SHIFT			4
+#define   NIC_Q_NUM_SHIFT			18
+#define   NIC_QS_ID_SHIFT			21
+#define   NIC_VF_NUM_SHIFT			21
+
+/* Port kind configuration register */
+struct pkind_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_42_63:22;
+	uint64_t hdr_sl:5;	/* Header skip length */
+	uint64_t rx_hdr:3;	/* TNS Receive header present */
+	uint64_t lenerr_en:1;	/* L2 length error check enable */
+	uint64_t reserved_32_32:1;
+	uint64_t maxlen:16;	/* Max frame size */
+	uint64_t minlen:16;	/* Min frame size */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t minlen:16;
+	uint64_t maxlen:16;
+	uint64_t reserved_32_32:1;
+	uint64_t lenerr_en:1;
+	uint64_t rx_hdr:3;
+	uint64_t hdr_sl:5;
+	uint64_t reserved_42_63:22;
+#endif
+};
+
+static inline uint64_t BGXX_PF_BAR0(unsigned long param1)
+				     __attribute__ ((pure, always_inline));
+static inline uint64_t BGXX_PF_BAR0(unsigned long param1)
+{
+	assert(param1 <= 1);
+	return 0x87E0E0000000 + (param1 << 24);
+}
+
+#define BGXX_PF_BAR0_SIZE 0x400000
+#define NIC_PF_BAR0 0x843000000000
+#define NIC_PF_BAR0_SIZE 0x40000000
+
+static inline uint64_t NIC_VFX_BAR0(unsigned long param1)
+				     __attribute__ ((pure, always_inline));
+static inline uint64_t NIC_VFX_BAR0(unsigned long param1)
+{
+	assert(param1 <= 127);
+
+	return 0x8430A0000000 + (param1 << 21);
+}
+
+#define NIC_VFX_BAR0_SIZE 0x200000
+
+#endif /* NIC_REG_H */
diff --git a/drivers/net/octeontx/nicvf_main.c b/drivers/net/octeontx/nicvf_main.c
new file mode 100644
index 0000000000..a0d7b38921
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_main.c
@@ -0,0 +1,581 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+#include <net.h>
+#include <misc.h>
+#include <malloc.h>
+#include <asm/io.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "nicvf_queues.h"
+
+/* Register read/write APIs */
+void nicvf_reg_write(struct nicvf *nic, u64 offset, u64 val)
+{
+	writeq(val, nic->reg_base + offset);
+}
+
+u64 nicvf_reg_read(struct nicvf *nic, u64 offset)
+{
+	return readq(nic->reg_base + offset);
+}
+
+void nicvf_queue_reg_write(struct nicvf *nic, u64 offset,
+			   u64 qidx, u64 val)
+{
+	void *addr = nic->reg_base + offset;
+
+	writeq(val, (void *)(addr + (qidx << NIC_Q_NUM_SHIFT)));
+}
+
+u64 nicvf_queue_reg_read(struct nicvf *nic, u64 offset, u64 qidx)
+{
+	void *addr = nic->reg_base + offset;
+
+	return readq((void *)(addr + (qidx << NIC_Q_NUM_SHIFT)));
+}
+
+static void  nicvf_handle_mbx_intr(struct nicvf *nic);
+
+/* VF -> PF mailbox communication */
+static void nicvf_write_to_mbx(struct nicvf *nic, union nic_mbx *mbx)
+{
+	u64 *msg = (u64 *)mbx;
+
+	nicvf_reg_write(nic, NIC_VF_PF_MAILBOX_0_1 + 0, msg[0]);
+	nicvf_reg_write(nic, NIC_VF_PF_MAILBOX_0_1 + 8, msg[1]);
+}
+
+int nicvf_send_msg_to_pf(struct nicvf *nic, union nic_mbx *mbx)
+{
+	int timeout = NIC_PF_VF_MBX_TIMEOUT;
+	int sleep = 10;
+
+	nic->pf_acked = false;
+	nic->pf_nacked = false;
+
+	nicvf_write_to_mbx(nic, mbx);
+
+	nic_handle_mbx_intr(nic->nicpf, nic->vf_id);
+
+	/* Wait for previous message to be acked, timeout 2sec */
+	while (!nic->pf_acked) {
+		if (nic->pf_nacked)
+			return -1;
+		mdelay(sleep);
+		nicvf_handle_mbx_intr(nic);
+
+		if (nic->pf_acked)
+			break;
+		timeout -= sleep;
+		if (!timeout) {
+			printf("PF didn't ack to mbox msg %d from VF%d\n",
+			       (mbx->msg.msg & 0xFF), nic->vf_id);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/* Checks if VF is able to comminicate with PF
+ * and also gets the VNIC number this VF is associated to.
+ */
+static int nicvf_check_pf_ready(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_READY;
+	if (nicvf_send_msg_to_pf(nic, &mbx)) {
+		printf("PF didn't respond to READY msg\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static void  nicvf_handle_mbx_intr(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+	struct eth_pdata *pdata = dev_get_platdata(nic->dev);
+	u64 *mbx_data;
+	u64 mbx_addr;
+	int i;
+
+	mbx_addr = NIC_VF_PF_MAILBOX_0_1;
+	mbx_data = (u64 *)&mbx;
+
+	for (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {
+		*mbx_data = nicvf_reg_read(nic, mbx_addr);
+		mbx_data++;
+		mbx_addr += sizeof(u64);
+	}
+
+	debug("Mbox message: msg: 0x%x\n", mbx.msg.msg);
+	switch (mbx.msg.msg) {
+	case NIC_MBOX_MSG_READY:
+		nic->pf_acked = true;
+		nic->vf_id = mbx.nic_cfg.vf_id & 0x7F;
+		nic->tns_mode = mbx.nic_cfg.tns_mode & 0x7F;
+		nic->node = mbx.nic_cfg.node_id;
+		if (!nic->set_mac_pending)
+			memcpy(pdata->enetaddr,
+			       mbx.nic_cfg.mac_addr, 6);
+		nic->loopback_supported = mbx.nic_cfg.loopback_supported;
+		nic->link_up = false;
+		nic->duplex = 0;
+		nic->speed = 0;
+		break;
+	case NIC_MBOX_MSG_ACK:
+		nic->pf_acked = true;
+		break;
+	case NIC_MBOX_MSG_NACK:
+		nic->pf_nacked = true;
+		break;
+	case NIC_MBOX_MSG_BGX_LINK_CHANGE:
+		nic->pf_acked = true;
+		nic->link_up = mbx.link_status.link_up;
+		nic->duplex = mbx.link_status.duplex;
+		nic->speed = mbx.link_status.speed;
+		if (nic->link_up) {
+			printf("%s: Link is Up %d Mbps %s\n",
+			       nic->dev->name, nic->speed,
+			       nic->duplex == 1 ?
+			       "Full duplex" : "Half duplex");
+		} else {
+			printf("%s: Link is Down\n", nic->dev->name);
+		}
+		break;
+	default:
+		printf("Invalid message from PF, msg 0x%x\n", mbx.msg.msg);
+		break;
+	}
+
+	nicvf_clear_intr(nic, NICVF_INTR_MBOX, 0);
+}
+
+static int nicvf_hw_set_mac_addr(struct nicvf *nic, struct udevice *dev)
+{
+	union nic_mbx mbx = {};
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+	mbx.mac.msg = NIC_MBOX_MSG_SET_MAC;
+	mbx.mac.vf_id = nic->vf_id;
+	memcpy(mbx.mac.mac_addr, pdata->enetaddr, 6);
+
+	return nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_config_cpi(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+
+	mbx.cpi_cfg.msg = NIC_MBOX_MSG_CPI_CFG;
+	mbx.cpi_cfg.vf_id = nic->vf_id;
+	mbx.cpi_cfg.cpi_alg = nic->cpi_alg;
+	mbx.cpi_cfg.rq_cnt = nic->qs->rq_cnt;
+
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static int nicvf_init_resources(struct nicvf *nic)
+{
+	int err;
+
+	nic->num_qs = 1;
+
+	/* Enable Qset */
+	nicvf_qset_config(nic, true);
+
+	/* Initialize queues and HW for data transfer */
+	err = nicvf_config_data_transfer(nic, true);
+
+	if (err) {
+		printf("Failed to alloc/config VF's QSet resources\n");
+		return err;
+	}
+	return 0;
+}
+
+static void nicvf_snd_pkt_handler(struct nicvf *nic,
+				  struct cmp_queue *cq,
+				  void *cq_desc, int cqe_type)
+{
+	struct cqe_send_t *cqe_tx;
+	struct snd_queue *sq;
+	struct sq_hdr_subdesc *hdr;
+
+	cqe_tx = (struct cqe_send_t *)cq_desc;
+	sq = &nic->qs->sq[cqe_tx->sq_idx];
+
+	hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, cqe_tx->sqe_ptr);
+	if (hdr->subdesc_type != SQ_DESC_TYPE_HEADER)
+		return;
+
+	nicvf_check_cqe_tx_errs(nic, cq, cq_desc);
+	nicvf_put_sq_desc(sq, hdr->subdesc_cnt + 1);
+}
+
+static int nicvf_rcv_pkt_handler(struct nicvf *nic,
+				 struct cmp_queue *cq, void *cq_desc,
+				 void **ppkt, int cqe_type)
+{
+	void *pkt;
+
+	size_t pkt_len;
+	struct cqe_rx_t *cqe_rx = (struct cqe_rx_t *)cq_desc;
+	int err = 0;
+
+	/* Check for errors */
+	err = nicvf_check_cqe_rx_errs(nic, cq, cq_desc);
+	if (err && !cqe_rx->rb_cnt)
+		return -1;
+
+	pkt = nicvf_get_rcv_pkt(nic, cq_desc, &pkt_len);
+	if (!pkt) {
+		debug("Packet not received\n");
+		return -1;
+	}
+
+	if (pkt)
+		*ppkt = pkt;
+
+	return pkt_len;
+}
+
+int nicvf_cq_handler(struct nicvf *nic, void **ppkt, int *pkt_len)
+{
+	int cq_qnum = 0;
+	int processed_sq_cqe = 0;
+	int processed_rq_cqe = 0;
+	int processed_cqe = 0;
+
+	unsigned long cqe_count, cqe_head;
+	struct queue_set *qs = nic->qs;
+	struct cmp_queue *cq = &qs->cq[cq_qnum];
+	struct cqe_rx_t *cq_desc;
+
+	/* Get num of valid CQ entries expect next one to be SQ completion */
+	cqe_count = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS, cq_qnum);
+	cqe_count &= 0xFFFF;
+	if (!cqe_count)
+		return 0;
+
+	/* Get head of the valid CQ entries */
+	cqe_head = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, cq_qnum);
+	cqe_head >>= 9;
+	cqe_head &= 0xFFFF;
+
+	if (cqe_count) {
+		/* Get the CQ descriptor */
+		cq_desc = (struct cqe_rx_t *)GET_CQ_DESC(cq, cqe_head);
+		cqe_head++;
+		cqe_head &= (cq->dmem.q_len - 1);
+		/* Initiate prefetch for next descriptor */
+		prefetch((struct cqe_rx_t *)GET_CQ_DESC(cq, cqe_head));
+
+		switch (cq_desc->cqe_type) {
+		case CQE_TYPE_RX:
+			debug("%s: Got Rx CQE\n", nic->dev->name);
+			*pkt_len = nicvf_rcv_pkt_handler(nic, cq, cq_desc,
+							 ppkt, CQE_TYPE_RX);
+			processed_rq_cqe++;
+			break;
+		case CQE_TYPE_SEND:
+			debug("%s: Got Tx CQE\n", nic->dev->name);
+			nicvf_snd_pkt_handler(nic, cq, cq_desc, CQE_TYPE_SEND);
+			processed_sq_cqe++;
+			break;
+		default:
+			debug("%s: Got CQ type %u\n", nic->dev->name,
+			      cq_desc->cqe_type);
+			break;
+		}
+		processed_cqe++;
+	}
+
+	/* Dequeue CQE */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_DOOR,
+			      cq_qnum, processed_cqe);
+
+	asm volatile ("dsb sy");
+
+	return (processed_sq_cqe | processed_rq_cqe);
+}
+
+/* Qset error interrupt handler
+ *
+ * As of now only CQ errors are handled
+ */
+void nicvf_handle_qs_err(struct nicvf *nic)
+{
+	struct queue_set *qs = nic->qs;
+	int qidx;
+	u64 status;
+
+	/* Check if it is CQ err */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++) {
+		status = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS,
+					      qidx);
+		if (!(status & CQ_ERR_MASK))
+			continue;
+		/* Process already queued CQEs and reconfig CQ */
+		nicvf_sq_disable(nic, qidx);
+		nicvf_cmp_queue_config(nic, qs, qidx, true);
+		nicvf_sq_free_used_descs(nic->dev, &qs->sq[qidx], qidx);
+		nicvf_sq_enable(nic, &qs->sq[qidx], qidx);
+	}
+}
+
+static int nicvf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+
+	if (pkt && pkt_len)
+		free(pkt);
+	nicvf_refill_rbdr(nic);
+	return 0;
+}
+
+static int nicvf_xmit(struct udevice *dev, void *pkt, int pkt_len)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+	int ret = 0;
+	int rcv_len = 0;
+	unsigned int timeout = 5000;
+	void *rpkt = NULL;
+
+	if (!nicvf_sq_append_pkt(nic, pkt, pkt_len)) {
+		printf("VF%d: TX ring full\n", nic->vf_id);
+		return -1;
+	}
+
+	/* check and update CQ for pkt sent */
+	while (!ret && timeout--) {
+		ret = nicvf_cq_handler(nic, &rpkt, &rcv_len);
+		if (!ret) {
+			debug("%s: %d, Not sent\n", __func__, __LINE__);
+			udelay(10);
+		}
+	}
+
+	return 0;
+}
+
+static int nicvf_recv(struct udevice *dev, int flags, uchar **packetp)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+	void *pkt;
+	int pkt_len = 0;
+#ifdef DEBUG
+	u8 *dpkt;
+	int i, j;
+#endif
+
+	nicvf_cq_handler(nic, &pkt, &pkt_len);
+
+	if (pkt_len) {
+#ifdef DEBUG
+		dpkt = pkt;
+		printf("RX packet contents:\n");
+		for (i = 0; i < 8; i++) {
+			puts("\t");
+			for (j = 0; j < 10; j++)
+				printf("%02x ", dpkt[i * 10 + j]);
+			puts("\n");
+		}
+#endif
+		*packetp = pkt;
+	}
+
+	return pkt_len;
+}
+
+void nicvf_stop(struct udevice *dev)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+
+	if (!nic->open)
+		return;
+
+	/* Free resources */
+	nicvf_config_data_transfer(nic, false);
+
+	/* Disable HW Qset */
+	nicvf_qset_config(nic, false);
+
+	nic->open = false;
+}
+
+int nicvf_open(struct udevice *dev)
+{
+	int err;
+	struct nicvf *nic = dev_get_priv(dev);
+
+	nicvf_hw_set_mac_addr(nic, dev);
+
+	/* Configure CPI alorithm */
+	nic->cpi_alg = CPI_ALG_NONE;
+	nicvf_config_cpi(nic);
+
+	/* Initialize the queues */
+	err = nicvf_init_resources(nic);
+	if (err)
+		return -1;
+
+	if (!nicvf_check_pf_ready(nic))
+		return -1;
+
+	nic->open = true;
+
+	/* Make sure queue initialization is written */
+	asm volatile("dsb sy");
+
+	return 0;
+}
+
+int nicvf_write_hwaddr(struct udevice *dev)
+{
+	unsigned char ethaddr[ARP_HLEN];
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+	struct nicvf *nic = dev_get_priv(dev);
+
+	/* If lower level firmware fails to set proper MAC
+	 * u-boot framework updates MAC to random address.
+	 * Use this hook to update mac address in environment.
+	 */
+	if (!eth_env_get_enetaddr_by_index("eth", dev->seq, ethaddr)) {
+		eth_env_set_enetaddr_by_index("eth", dev->seq, pdata->enetaddr);
+		debug("%s: pMAC %pM\n", __func__, pdata->enetaddr);
+	}
+	eth_env_get_enetaddr_by_index("eth", dev->seq, ethaddr);
+	if (memcmp(ethaddr, pdata->enetaddr, ARP_HLEN)) {
+		debug("%s: pMAC %pM\n", __func__, pdata->enetaddr);
+		nicvf_hw_set_mac_addr(nic, dev);
+	}
+	return 0;
+}
+
+static void nicvf_probe_mdio_devices(void)
+{
+	struct udevice *pdev;
+	int err;
+	static int probed;
+
+	if (probed)
+		return;
+
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM, 0xA02B, 0,
+				 &pdev);
+	if (err)
+		debug("%s couldn't find SMI device\n", __func__);
+	probed = 1;
+}
+
+int nicvf_initialize(struct udevice *dev)
+{
+	struct nicvf *nicvf = dev_get_priv(dev);
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+	int    ret = 0, bgx, lmac;
+	char   name[16];
+	unsigned char ethaddr[ARP_HLEN];
+	struct udevice *pfdev;
+	struct nicpf *pf;
+	static int vfid;
+
+	if (dm_pci_find_device(PCI_VENDOR_ID_CAVIUM,
+			       PCI_DEVICE_ID_OCTEONTX_NIC_PF, 0, &pfdev)) {
+		printf("%s NIC PF device not found..VF probe failed\n",
+		       __func__);
+		return -1;
+	}
+	pf = dev_get_priv(pfdev);
+	nicvf->vf_id = vfid++;
+	nicvf->dev = dev;
+	nicvf->nicpf = pf;
+
+	nicvf_probe_mdio_devices();
+
+	/* Enable TSO support */
+	nicvf->hw_tso = true;
+
+	nicvf->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					 PCI_REGION_MEM);
+
+	debug("nicvf->reg_base: %p\n", nicvf->reg_base);
+
+	if (!nicvf->reg_base) {
+		printf("Cannot map config register space, aborting\n");
+		ret = -1;
+		goto fail;
+	}
+
+	ret = nicvf_set_qset_resources(nicvf);
+	if (ret)
+		return -1;
+
+	sprintf(name, "vnic%u", nicvf->vf_id);
+	debug("%s name %s\n", __func__, name);
+	device_set_name(dev, name);
+
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(pf->vf_lmac_map[nicvf->vf_id]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(pf->vf_lmac_map[nicvf->vf_id]);
+	debug("%s VF %d BGX %d LMAC %d\n", __func__, nicvf->vf_id, bgx, lmac);
+	debug("%s PF %p pfdev %p VF %p vfdev %p vf->pdata %p\n",
+	      __func__, nicvf->nicpf, nicvf->nicpf->udev, nicvf, nicvf->dev,
+	      pdata);
+
+	fdt_board_get_ethaddr(bgx, lmac, ethaddr);
+
+	debug("%s bgx %d lmac %d ethaddr %pM\n", __func__, bgx, lmac, ethaddr);
+
+	if (is_valid_ethaddr(ethaddr)) {
+		memcpy(pdata->enetaddr, ethaddr, ARP_HLEN);
+		eth_env_set_enetaddr_by_index("eth", dev->seq, ethaddr);
+	}
+	debug("%s enetaddr %pM ethaddr %pM\n", __func__,
+	      pdata->enetaddr, ethaddr);
+
+fail:
+	return ret;
+}
+
+int octeontx_vnic_probe(struct udevice *dev)
+{
+	return nicvf_initialize(dev);
+}
+
+static const struct eth_ops octeontx_vnic_ops = {
+	.start = nicvf_open,
+	.stop  = nicvf_stop,
+	.send  = nicvf_xmit,
+	.recv  = nicvf_recv,
+	.free_pkt = nicvf_free_pkt,
+	.write_hwaddr = nicvf_write_hwaddr,
+};
+
+U_BOOT_DRIVER(octeontx_vnic) = {
+	.name	= "vnic",
+	.id	= UCLASS_ETH,
+	.probe	= octeontx_vnic_probe,
+	.ops	= &octeontx_vnic_ops,
+	.priv_auto_alloc_size = sizeof(struct nicvf),
+	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
+};
+
+static struct pci_device_id octeontx_vnic_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_VF_1) },
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_VF_2) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_vnic, octeontx_vnic_supported);
diff --git a/drivers/net/octeontx/nicvf_queues.c b/drivers/net/octeontx/nicvf_queues.c
new file mode 100644
index 0000000000..e4868decbc
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_queues.c
@@ -0,0 +1,1141 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <net.h>
+#include <dm/device.h>
+#include <malloc.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "q_struct.h"
+#include "nicvf_queues.h"
+
+static int nicvf_poll_reg(struct nicvf *nic, int qidx,
+			  u64 reg, int bit_pos, int bits, int val)
+{
+	u64 bit_mask;
+	u64 reg_val;
+	int timeout = 10;
+
+	bit_mask = (1ULL << bits) - 1;
+	bit_mask = (bit_mask << bit_pos);
+
+	while (timeout) {
+		reg_val = nicvf_queue_reg_read(nic, reg, qidx);
+		if (((reg_val & bit_mask) >> bit_pos) == val)
+			return 0;
+		udelay(2000);
+		timeout--;
+	}
+	printf("Poll on reg 0x%llx failed\n", reg);
+	return 1;
+}
+
+static int nicvf_alloc_q_desc_mem(struct nicvf *nic, struct q_desc_mem *dmem,
+				  int q_len, int desc_size, int align_bytes)
+{
+	dmem->q_len = q_len;
+	dmem->size = (desc_size * q_len) + align_bytes;
+	/* Save address, need it while freeing */
+	dmem->unalign_base = calloc(1, dmem->size);
+	dmem->dma = (uintptr_t)dmem->unalign_base;
+
+	if (!dmem->unalign_base)
+		return -1;
+
+	/* Align memory address for 'align_bytes' */
+	dmem->phys_base = NICVF_ALIGNED_ADDR((u64)dmem->dma, align_bytes);
+	dmem->base = dmem->unalign_base + (dmem->phys_base - dmem->dma);
+
+	return 0;
+}
+
+static void nicvf_free_q_desc_mem(struct nicvf *nic, struct q_desc_mem *dmem)
+{
+	if (!dmem)
+		return;
+
+	free(dmem->unalign_base);
+
+	dmem->unalign_base = NULL;
+	dmem->base = NULL;
+}
+
+static void *nicvf_rb_ptr_to_pkt(struct nicvf *nic, uintptr_t rb_ptr)
+{
+	return (void *)rb_ptr;
+}
+
+static int nicvf_init_rbdr(struct nicvf *nic, struct rbdr *rbdr,
+			   int ring_len, int buf_size)
+{
+	int idx;
+	uintptr_t rbuf;
+	struct rbdr_entry_t *desc;
+
+	if (nicvf_alloc_q_desc_mem(nic, &rbdr->dmem, ring_len,
+				   sizeof(struct rbdr_entry_t),
+				   NICVF_RCV_BUF_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for rcv buffer ring\n");
+		return -1;
+	}
+
+	rbdr->desc = rbdr->dmem.base;
+	/* Buffer size has to be in multiples of 128 bytes */
+	rbdr->dma_size = buf_size;
+	rbdr->enable = true;
+	rbdr->thresh = RBDR_THRESH;
+
+	debug("%s: %d: allocating %lld bytes for rcv buffers\n",
+	      __func__, __LINE__,
+	      ring_len * buf_size + NICVF_RCV_BUF_ALIGN_BYTES);
+	rbdr->buf_mem = (uintptr_t)calloc(1, ring_len * buf_size
+						+ NICVF_RCV_BUF_ALIGN_BYTES);
+
+	if (!rbdr->buf_mem) {
+		printf("Unable to allocate memory for rcv buffers\n");
+		return -1;
+	}
+
+	rbdr->buffers = NICVF_ALIGNED_ADDR(rbdr->buf_mem,
+					   NICVF_RCV_BUF_ALIGN_BYTES);
+
+	debug("%s: %d: rbdr->buf_mem: %lx, rbdr->buffers: %lx\n",
+	      __func__, __LINE__, rbdr->buf_mem, rbdr->buffers);
+
+	for (idx = 0; idx < ring_len; idx++) {
+		rbuf = rbdr->buffers + DMA_BUFFER_LEN * idx;
+		desc = GET_RBDR_DESC(rbdr, idx);
+		desc->buf_addr = rbuf >> NICVF_RCV_BUF_ALIGN;
+		flush_dcache_range((uintptr_t)desc,
+				   (uintptr_t)desc + sizeof(desc));
+	}
+	return 0;
+}
+
+static void nicvf_free_rbdr(struct nicvf *nic, struct rbdr *rbdr)
+{
+	if (!rbdr)
+		return;
+
+	rbdr->enable = false;
+	if (!rbdr->dmem.base)
+		return;
+
+	debug("%s: %d: rbdr->buf_mem: %p\n", __func__,
+	      __LINE__, (void *)rbdr->buf_mem);
+	free((void *)rbdr->buf_mem);
+
+	/* Free RBDR ring */
+	nicvf_free_q_desc_mem(nic, &rbdr->dmem);
+}
+
+/* Refill receive buffer descriptors with new buffers.
+ * This runs in softirq context .
+ */
+void nicvf_refill_rbdr(struct nicvf *nic)
+{
+	struct queue_set *qs = nic->qs;
+	int rbdr_idx = qs->rbdr_cnt;
+	unsigned long qcount, head, tail, rb_cnt;
+	struct rbdr *rbdr;
+
+	if (!rbdr_idx)
+		return;
+	rbdr_idx--;
+	rbdr = &qs->rbdr[rbdr_idx];
+	/* Check if it's enabled */
+	if (!rbdr->enable) {
+		printf("Receive queue %d is disabled\n", rbdr_idx);
+		return;
+	}
+
+	/* check if valid descs reached or crossed threshold level */
+	qcount = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_STATUS0, rbdr_idx);
+	head = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_HEAD, rbdr_idx);
+	tail = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_TAIL, rbdr_idx);
+
+	qcount &= 0x7FFFF;
+
+	rb_cnt = qs->rbdr_len - qcount - 1;
+
+	debug("%s: %d: qcount: %lu, head: %lx, tail: %lx, rb_cnt: %lu\n",
+	      __func__, __LINE__, qcount, head, tail, rb_cnt);
+
+	/* Notify HW */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_DOOR, rbdr_idx, rb_cnt);
+
+	asm volatile ("dsb sy");
+}
+
+/* TBD: how to handle full packets received in CQ
+ * i.e conversion of buffers into SKBs
+ */
+static int nicvf_init_cmp_queue(struct nicvf *nic,
+				struct cmp_queue *cq, int q_len)
+{
+	if (nicvf_alloc_q_desc_mem(nic, &cq->dmem, q_len,
+				   CMP_QUEUE_DESC_SIZE,
+				   NICVF_CQ_BASE_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for completion queue\n");
+		return -1;
+	}
+	cq->desc = cq->dmem.base;
+	if (!pass1_silicon(nic->rev_id, nic->nicpf->hw->model_id))
+		cq->thresh = CMP_QUEUE_CQE_THRESH;
+	else
+		cq->thresh = 0;
+	cq->intr_timer_thresh = CMP_QUEUE_TIMER_THRESH;
+
+	return 0;
+}
+
+static void nicvf_free_cmp_queue(struct nicvf *nic, struct cmp_queue *cq)
+{
+	if (!cq)
+		return;
+	if (!cq->dmem.base)
+		return;
+
+	nicvf_free_q_desc_mem(nic, &cq->dmem);
+}
+
+static int nicvf_init_snd_queue(struct nicvf *nic,
+				struct snd_queue *sq, int q_len)
+{
+	if (nicvf_alloc_q_desc_mem(nic, &sq->dmem, q_len,
+				   SND_QUEUE_DESC_SIZE,
+				   NICVF_SQ_BASE_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for send queue\n");
+		return -1;
+	}
+
+	sq->desc = sq->dmem.base;
+	sq->skbuff = calloc(q_len, sizeof(u64));
+	sq->head = 0;
+	sq->tail = 0;
+	sq->free_cnt = q_len - 1;
+	sq->thresh = SND_QUEUE_THRESH;
+
+	return 0;
+}
+
+static void nicvf_free_snd_queue(struct nicvf *nic, struct snd_queue *sq)
+{
+	if (!sq)
+		return;
+	if (!sq->dmem.base)
+		return;
+
+	debug("%s: %d\n", __func__, __LINE__);
+	free(sq->skbuff);
+
+	nicvf_free_q_desc_mem(nic, &sq->dmem);
+}
+
+static void nicvf_reclaim_snd_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	/* Disable send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, 0);
+	/* Check if SQ is stopped */
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_SQ_0_7_STATUS, 21, 1, 0x01))
+		return;
+	/* Reset send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, NICVF_SQ_RESET);
+}
+
+static void nicvf_reclaim_rcv_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	union nic_mbx mbx = {};
+
+	/* Make sure all packets in the pipeline are written back into mem */
+	mbx.msg.msg = NIC_MBOX_MSG_RQ_SW_SYNC;
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_reclaim_cmp_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	/* Disable timer threshold (doesn't get reset upon CQ reset */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx, 0);
+	/* Disable completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, 0);
+	/* Reset completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, NICVF_CQ_RESET);
+}
+
+static void nicvf_reclaim_rbdr(struct nicvf *nic,
+			       struct rbdr *rbdr, int qidx)
+{
+	u64 tmp, fifo_state;
+	int timeout = 10;
+
+	/* Save head and tail pointers for feeing up buffers */
+	rbdr->head = nicvf_queue_reg_read(nic,
+					  NIC_QSET_RBDR_0_1_HEAD,
+					  qidx) >> 3;
+	rbdr->tail = nicvf_queue_reg_read(nic,
+					  NIC_QSET_RBDR_0_1_TAIL,
+					  qidx) >> 3;
+
+	/* If RBDR FIFO is in 'FAIL' state then do a reset first
+	 * before relaiming.
+	 */
+	fifo_state = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_STATUS0, qidx);
+	if (((fifo_state >> 62) & 0x03) == 0x3)
+		nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+				      qidx, NICVF_RBDR_RESET);
+
+	/* Disable RBDR */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG, qidx, 0);
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x00))
+		return;
+	while (1) {
+		tmp = nicvf_queue_reg_read(nic,
+					   NIC_QSET_RBDR_0_1_PREFETCH_STATUS,
+					   qidx);
+		if ((tmp & 0xFFFFFFFF) == ((tmp >> 32) & 0xFFFFFFFF))
+			break;
+		mdelay(2000);
+		timeout--;
+		if (!timeout) {
+			printf("Failed polling on prefetch status\n");
+			return;
+		}
+	}
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+			      qidx, NICVF_RBDR_RESET);
+
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x02))
+		return;
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG, qidx, 0x00);
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x00))
+		return;
+}
+
+/* Configures receive queue */
+static void nicvf_rcv_queue_config(struct nicvf *nic, struct queue_set *qs,
+				   int qidx, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct rcv_queue *rq;
+	union {
+		struct rq_cfg s;
+		u64    u;
+	} rq_cfg;
+
+	rq = &qs->rq[qidx];
+	rq->enable = enable;
+
+	/* Disable receive queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_0_7_CFG, qidx, 0);
+
+	if (!rq->enable) {
+		nicvf_reclaim_rcv_queue(nic, qs, qidx);
+		return;
+	}
+
+	rq->cq_qs = qs->vnic_id;
+	rq->cq_idx = qidx;
+	rq->start_rbdr_qs = qs->vnic_id;
+	rq->start_qs_rbdr_idx = qs->rbdr_cnt - 1;
+	rq->cont_rbdr_qs = qs->vnic_id;
+	rq->cont_qs_rbdr_idx = qs->rbdr_cnt - 1;
+	/* all writes of RBDR data to be loaded into L2 Cache as well*/
+	rq->caching = 1;
+
+	/* Send a mailbox msg to PF to config RQ */
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_CFG;
+	mbx.rq.qs_num = qs->vnic_id;
+	mbx.rq.rq_num = qidx;
+	mbx.rq.cfg = (rq->caching << 26) | (rq->cq_qs << 19) |
+			  (rq->cq_idx << 16) | (rq->cont_rbdr_qs << 9) |
+			  (rq->cont_qs_rbdr_idx << 8) |
+			  (rq->start_rbdr_qs << 1) | (rq->start_qs_rbdr_idx);
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_BP_CFG;
+	mbx.rq.cfg = (1ULL << 63) | (1ULL << 62) | (qs->vnic_id << 0);
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	/* RQ drop config
+	 * Enable CQ drop to reserve sufficient CQEs for all tx packets
+	 */
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_DROP_CFG;
+	mbx.rq.cfg = (1ULL << 62) | (RQ_CQ_DROP << 8);
+	nicvf_send_msg_to_pf(nic, &mbx);
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_GEN_CFG, 0, 0x00);
+
+	/* Enable Receive queue */
+	rq_cfg.s.ena = 1;
+	rq_cfg.s.tcp_ena = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_0_7_CFG, qidx, rq_cfg.u);
+}
+
+void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
+			    int qidx, bool enable)
+{
+	struct cmp_queue *cq;
+	union {
+		u64 u;
+		struct cq_cfg s;
+	} cq_cfg;
+
+	cq = &qs->cq[qidx];
+	cq->enable = enable;
+
+	if (!cq->enable) {
+		nicvf_reclaim_cmp_queue(nic, qs, qidx);
+		return;
+	}
+
+	/* Reset completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, NICVF_CQ_RESET);
+
+	if (!cq->enable)
+		return;
+
+	/* Set completion queue base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_BASE,
+			      qidx, (u64)(cq->dmem.phys_base));
+
+	/* Enable Completion queue */
+	cq_cfg.s.ena = 1;
+	cq_cfg.s.reset = 0;
+	cq_cfg.s.caching = 0;
+	cq_cfg.s.qsize = CMP_QSIZE;
+	cq_cfg.s.avg_con = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, cq_cfg.u);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_THRESH, qidx, cq->thresh);
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx,
+			      cq->intr_timer_thresh);
+}
+
+/* Configures transmit queue */
+static void nicvf_snd_queue_config(struct nicvf *nic, struct queue_set *qs,
+				   int qidx, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct snd_queue *sq;
+
+	union {
+		struct sq_cfg s;
+		u64 u;
+	} sq_cfg;
+
+	sq = &qs->sq[qidx];
+	sq->enable = enable;
+
+	if (!sq->enable) {
+		nicvf_reclaim_snd_queue(nic, qs, qidx);
+		return;
+	}
+
+	/* Reset send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, NICVF_SQ_RESET);
+
+	sq->cq_qs = qs->vnic_id;
+	sq->cq_idx = qidx;
+
+	/* Send a mailbox msg to PF to config SQ */
+	mbx.sq.msg = NIC_MBOX_MSG_SQ_CFG;
+	mbx.sq.qs_num = qs->vnic_id;
+	mbx.sq.sq_num = qidx;
+	mbx.sq.sqs_mode = nic->sqs_mode;
+	mbx.sq.cfg = (sq->cq_qs << 3) | sq->cq_idx;
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	/* Set queue base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_BASE,
+			      qidx, (u64)(sq->dmem.phys_base));
+
+	/* Enable send queue  & set queue size */
+	sq_cfg.s.ena = 1;
+	sq_cfg.s.reset = 0;
+	sq_cfg.s.ldwb = 0;
+	sq_cfg.s.qsize = SND_QSIZE;
+	sq_cfg.s.tstmp_bgx_intf = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg.u);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_THRESH, qidx, sq->thresh);
+}
+
+/* Configures receive buffer descriptor ring */
+static void nicvf_rbdr_config(struct nicvf *nic, struct queue_set *qs,
+			      int qidx, bool enable)
+{
+	struct rbdr *rbdr;
+	union {
+		struct rbdr_cfg s;
+		u64 u;
+	} rbdr_cfg;
+
+	rbdr = &qs->rbdr[qidx];
+	nicvf_reclaim_rbdr(nic, rbdr, qidx);
+	if (!enable)
+		return;
+
+	/* Set descriptor base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_BASE,
+			      qidx, (u64)(rbdr->dmem.phys_base));
+
+	/* Enable RBDR  & set queue size */
+	/* Buffer size should be in multiples of 128 bytes */
+	rbdr_cfg.s.ena = 1;
+	rbdr_cfg.s.reset = 0;
+	rbdr_cfg.s.ldwb = 0;
+	rbdr_cfg.s.qsize = RBDR_SIZE;
+	rbdr_cfg.s.avg_con = 0;
+	rbdr_cfg.s.lines = rbdr->dma_size / 128;
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+			      qidx, rbdr_cfg.u);
+
+	/* Notify HW */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_DOOR,
+			      qidx, qs->rbdr_len - 1);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_THRESH,
+			      qidx, rbdr->thresh - 1);
+}
+
+/* Requests PF to assign and enable Qset */
+void nicvf_qset_config(struct nicvf *nic, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct queue_set *qs = nic->qs;
+	struct qs_cfg *qs_cfg;
+
+	if (!qs) {
+		printf("Qset is still not allocated, don't init queues\n");
+		return;
+	}
+
+	qs->enable = enable;
+	qs->vnic_id = nic->vf_id;
+
+	/* Send a mailbox msg to PF to config Qset */
+	mbx.qs.msg = NIC_MBOX_MSG_QS_CFG;
+	mbx.qs.num = qs->vnic_id;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	mbx.qs.sqs_count = nic->sqs_count;
+#endif
+
+	mbx.qs.cfg = 0;
+	qs_cfg = (struct qs_cfg *)&mbx.qs.cfg;
+	if (qs->enable) {
+		qs_cfg->ena = 1;
+#ifdef __BIG_ENDIAN
+		qs_cfg->be = 1;
+#endif
+		qs_cfg->vnic = qs->vnic_id;
+	}
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_free_resources(struct nicvf *nic)
+{
+	int qidx;
+	struct queue_set *qs = nic->qs;
+
+	/* Free receive buffer descriptor ring */
+	for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+		nicvf_free_rbdr(nic, &qs->rbdr[qidx]);
+
+	/* Free completion queue */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+		nicvf_free_cmp_queue(nic, &qs->cq[qidx]);
+
+	/* Free send queue */
+	for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+		nicvf_free_snd_queue(nic, &qs->sq[qidx]);
+}
+
+static int nicvf_alloc_resources(struct nicvf *nic)
+{
+	int qidx;
+	struct queue_set *qs = nic->qs;
+
+	/* Alloc receive buffer descriptor ring */
+	for (qidx = 0; qidx < qs->rbdr_cnt; qidx++) {
+		if (nicvf_init_rbdr(nic, &qs->rbdr[qidx], qs->rbdr_len,
+				    DMA_BUFFER_LEN))
+			goto alloc_fail;
+	}
+
+	/* Alloc send queue */
+	for (qidx = 0; qidx < qs->sq_cnt; qidx++) {
+		if (nicvf_init_snd_queue(nic, &qs->sq[qidx], qs->sq_len))
+			goto alloc_fail;
+	}
+
+	/* Alloc completion queue */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++) {
+		if (nicvf_init_cmp_queue(nic, &qs->cq[qidx], qs->cq_len))
+			goto alloc_fail;
+	}
+
+	return 0;
+alloc_fail:
+	nicvf_free_resources(nic);
+	return -1;
+}
+
+int nicvf_set_qset_resources(struct nicvf *nic)
+{
+	struct queue_set *qs;
+
+	qs = calloc(1, sizeof(struct queue_set));
+	if (!qs)
+		return -1;
+	nic->qs = qs;
+
+	/* Set count of each queue */
+	qs->rbdr_cnt = RBDR_CNT;
+	qs->rq_cnt = 1;
+	qs->sq_cnt = SND_QUEUE_CNT;
+	qs->cq_cnt = CMP_QUEUE_CNT;
+
+	/* Set queue lengths */
+	qs->rbdr_len = RCV_BUF_COUNT;
+	qs->sq_len = SND_QUEUE_LEN;
+	qs->cq_len = CMP_QUEUE_LEN;
+
+	nic->rx_queues = qs->rq_cnt;
+	nic->tx_queues = qs->sq_cnt;
+
+	return 0;
+}
+
+int nicvf_config_data_transfer(struct nicvf *nic, bool enable)
+{
+	bool disable = false;
+	struct queue_set *qs = nic->qs;
+	int qidx;
+
+	if (!qs)
+		return 0;
+
+	if (enable) {
+		if (nicvf_alloc_resources(nic))
+			return -1;
+
+		for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+			nicvf_snd_queue_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+			nicvf_cmp_queue_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+			nicvf_rbdr_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->rq_cnt; qidx++)
+			nicvf_rcv_queue_config(nic, qs, qidx, enable);
+	} else {
+		for (qidx = 0; qidx < qs->rq_cnt; qidx++)
+			nicvf_rcv_queue_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+			nicvf_rbdr_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+			nicvf_snd_queue_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+			nicvf_cmp_queue_config(nic, qs, qidx, disable);
+
+		nicvf_free_resources(nic);
+	}
+
+	return 0;
+}
+
+/* Get a free desc from SQ
+ * returns descriptor ponter & descriptor number
+ */
+static int nicvf_get_sq_desc(struct snd_queue *sq, int desc_cnt)
+{
+	int qentry;
+
+	qentry = sq->tail;
+	sq->free_cnt -= desc_cnt;
+	sq->tail += desc_cnt;
+	sq->tail &= (sq->dmem.q_len - 1);
+
+	return qentry;
+}
+
+/* Free descriptor back to SQ for future use */
+void nicvf_put_sq_desc(struct snd_queue *sq, int desc_cnt)
+{
+	sq->free_cnt += desc_cnt;
+	sq->head += desc_cnt;
+	sq->head &= (sq->dmem.q_len - 1);
+}
+
+static int nicvf_get_nxt_sqentry(struct snd_queue *sq, int qentry)
+{
+	qentry++;
+	qentry &= (sq->dmem.q_len - 1);
+	return qentry;
+}
+
+void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx)
+{
+	u64 sq_cfg;
+
+	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
+	sq_cfg |= NICVF_SQ_EN;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg);
+	/* Ring doorbell so that H/W restarts processing SQEs */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_DOOR, qidx, 0);
+}
+
+void nicvf_sq_disable(struct nicvf *nic, int qidx)
+{
+	u64 sq_cfg;
+
+	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
+	sq_cfg &= ~NICVF_SQ_EN;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg);
+}
+
+void nicvf_sq_free_used_descs(struct udevice *dev, struct snd_queue *sq,
+			      int qidx)
+{
+	u64 head;
+	struct nicvf *nic = dev_get_priv(dev);
+	struct sq_hdr_subdesc *hdr;
+
+	head = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_HEAD, qidx) >> 4;
+
+	while (sq->head != head) {
+		hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, sq->head);
+		if (hdr->subdesc_type != SQ_DESC_TYPE_HEADER) {
+			nicvf_put_sq_desc(sq, 1);
+			continue;
+		}
+		nicvf_put_sq_desc(sq, hdr->subdesc_cnt + 1);
+	}
+}
+
+/* Get the number of SQ descriptors needed to xmit this skb */
+static int nicvf_sq_subdesc_required(struct nicvf *nic)
+{
+	int subdesc_cnt = MIN_SQ_DESC_PER_PKT_XMIT;
+
+	return subdesc_cnt;
+}
+
+/* Add SQ HEADER subdescriptor.
+ * First subdescriptor for every send descriptor.
+ */
+static inline void
+nicvf_sq_add_hdr_subdesc(struct nicvf *nic, struct snd_queue *sq, int qentry,
+			 int subdesc_cnt, void *pkt, size_t pkt_len)
+{
+	struct sq_hdr_subdesc *hdr;
+
+	hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, qentry);
+	sq->skbuff[qentry] = (uintptr_t)pkt;
+
+	memset(hdr, 0, SND_QUEUE_DESC_SIZE);
+	hdr->subdesc_type = SQ_DESC_TYPE_HEADER;
+	/* Enable notification via CQE after processing SQE */
+	hdr->post_cqe = 1;
+	/* No of subdescriptors following this */
+	hdr->subdesc_cnt = subdesc_cnt;
+	hdr->tot_len = pkt_len;
+
+	flush_dcache_range((uintptr_t)hdr,
+			   (uintptr_t)hdr + sizeof(struct sq_hdr_subdesc));
+}
+
+/* SQ GATHER subdescriptor
+ * Must follow HDR descriptor
+ */
+static inline void nicvf_sq_add_gather_subdesc(struct snd_queue *sq, int qentry,
+					       size_t size, uintptr_t data)
+{
+	struct sq_gather_subdesc *gather;
+
+	qentry &= (sq->dmem.q_len - 1);
+	gather = (struct sq_gather_subdesc *)GET_SQ_DESC(sq, qentry);
+
+	memset(gather, 0, SND_QUEUE_DESC_SIZE);
+	gather->subdesc_type = SQ_DESC_TYPE_GATHER;
+	gather->ld_type = NIC_SEND_LD_TYPE_E_LDD;
+	gather->size = size;
+	gather->addr = data;
+
+	flush_dcache_range((uintptr_t)gather,
+			   (uintptr_t)gather + sizeof(struct sq_hdr_subdesc));
+}
+
+/* Append an skb to a SQ for packet transfer. */
+int nicvf_sq_append_pkt(struct nicvf *nic, void *pkt, size_t pkt_size)
+{
+	int subdesc_cnt;
+	int sq_num = 0, qentry;
+	struct queue_set *qs;
+	struct snd_queue *sq;
+
+	qs = nic->qs;
+	sq = &qs->sq[sq_num];
+
+	subdesc_cnt = nicvf_sq_subdesc_required(nic);
+	if (subdesc_cnt > sq->free_cnt)
+		goto append_fail;
+
+	qentry = nicvf_get_sq_desc(sq, subdesc_cnt);
+
+	/* Add SQ header subdesc */
+	nicvf_sq_add_hdr_subdesc(nic, sq, qentry, subdesc_cnt - 1,
+				 pkt, pkt_size);
+
+	/* Add SQ gather subdescs */
+	qentry = nicvf_get_nxt_sqentry(sq, qentry);
+	nicvf_sq_add_gather_subdesc(sq, qentry, pkt_size, (uintptr_t)(pkt));
+
+	flush_dcache_range((uintptr_t)pkt,
+			   (uintptr_t)pkt + pkt_size);
+
+	/* make sure all memory stores are done before ringing doorbell */
+	asm volatile ("dsb sy");
+
+	/* Inform HW to xmit new packet */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_DOOR,
+			      sq_num, subdesc_cnt);
+	return 1;
+
+append_fail:
+	printf("Not enough SQ descriptors to xmit pkt\n");
+	return 0;
+}
+
+static unsigned int frag_num(unsigned int i)
+{
+#ifdef __BIG_ENDIAN
+	return (i & ~3) + 3 - (i & 3);
+#else
+	return i;
+#endif
+}
+
+void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len)
+{
+	int frag;
+	int payload_len = 0, tot_len;
+	void *pkt = NULL, *pkt_buf = NULL, *buffer;
+	struct cqe_rx_t *cqe_rx;
+	struct rbdr *rbdr;
+	struct rcv_queue *rq;
+	struct queue_set *qs = nic->qs;
+	u16 *rb_lens = NULL;
+	u64 *rb_ptrs = NULL;
+
+	cqe_rx = (struct cqe_rx_t *)cq_desc;
+
+	rq = &qs->rq[cqe_rx->rq_idx];
+	rbdr = &qs->rbdr[rq->start_qs_rbdr_idx];
+	rb_lens = cq_desc + (3 * sizeof(u64)); /* Use offsetof */
+	/* Except 88xx pass1 on all other chips CQE_RX2_S is added to
+	 * CQE_RX at word6, hence buffer pointers move by word
+	 *
+	 * Use existing 'hw_tso' flag which will be set for all chips
+	 * except 88xx pass1 instead of a additional cache line
+	 * access (or miss) by using pci dev's revision.
+	 */
+	if (!nic->hw_tso)
+		rb_ptrs = (void *)cqe_rx + (6 * sizeof(u64));
+	else
+		rb_ptrs = (void *)cqe_rx + (7 * sizeof(u64));
+
+	/*
+	 * Figure out packet length to create packet buffer
+	 */
+	for (frag = 0; frag < cqe_rx->rb_cnt; frag++)
+		payload_len += rb_lens[frag_num(frag)];
+	*pkt_len = payload_len;
+	/* round up size to 8 byte multiple */
+	tot_len = (payload_len & (~0x7)) + 8;
+	buffer = calloc(1, tot_len);
+	if (!buffer) {
+		printf("%s - Failed to allocate packet buffer\n", __func__);
+		return NULL;
+	}
+	pkt_buf = buffer;
+	debug("total pkt buf %p len %ld tot_len %d\n", pkt_buf, *pkt_len,
+	      tot_len);
+	for (frag = 0; frag < cqe_rx->rb_cnt; frag++) {
+		payload_len = rb_lens[frag_num(frag)];
+
+		invalidate_dcache_range((uintptr_t)(*rb_ptrs),
+					(uintptr_t)(*rb_ptrs) + rbdr->dma_size);
+
+		/* First fragment */
+		*rb_ptrs = *rb_ptrs - cqe_rx->align_pad;
+
+		pkt = nicvf_rb_ptr_to_pkt(nic, *rb_ptrs);
+
+		invalidate_dcache_range((uintptr_t)pkt,
+					(uintptr_t)pkt + payload_len);
+
+		if (cqe_rx->align_pad)
+			pkt += cqe_rx->align_pad;
+		debug("pkt_buf %p, pkt %p payload_len %d\n", pkt_buf, pkt,
+		      payload_len);
+		memcpy(buffer, pkt, payload_len);
+		buffer += payload_len;
+		/* Next buffer pointer */
+		rb_ptrs++;
+	}
+	return pkt_buf;
+}
+
+/* Clear interrupt */
+void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx)
+{
+	u64 reg_val = 0;
+
+	switch (int_type) {
+	case NICVF_INTR_CQ:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_CQ_SHIFT);
+	break;
+	case NICVF_INTR_SQ:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_SQ_SHIFT);
+	break;
+	case NICVF_INTR_RBDR:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_RBDR_SHIFT);
+	break;
+	case NICVF_INTR_PKT_DROP:
+		reg_val = (1ULL << NICVF_INTR_PKT_DROP_SHIFT);
+	break;
+	case NICVF_INTR_TCP_TIMER:
+		reg_val = (1ULL << NICVF_INTR_TCP_TIMER_SHIFT);
+	break;
+	case NICVF_INTR_MBOX:
+		reg_val = (1ULL << NICVF_INTR_MBOX_SHIFT);
+	break;
+	case NICVF_INTR_QS_ERR:
+		reg_val |= (1ULL << NICVF_INTR_QS_ERR_SHIFT);
+	break;
+	default:
+		printf("Failed to clear interrupt: unknown type\n");
+	break;
+	}
+
+	nicvf_reg_write(nic, NIC_VF_INT, reg_val);
+}
+
+void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx)
+{
+	struct rcv_queue *rq;
+
+#define GET_RQ_STATS(reg) \
+	nicvf_reg_read(nic, NIC_QSET_RQ_0_7_STAT_0_1 |\
+			    (rq_idx << NIC_Q_NUM_SHIFT) | ((reg) << 3))
+
+	rq = &nic->qs->rq[rq_idx];
+	rq->stats.bytes = GET_RQ_STATS(RQ_SQ_STATS_OCTS);
+	rq->stats.pkts = GET_RQ_STATS(RQ_SQ_STATS_PKTS);
+}
+
+void nicvf_update_sq_stats(struct nicvf *nic, int sq_idx)
+{
+	struct snd_queue *sq;
+
+#define GET_SQ_STATS(reg) \
+	nicvf_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1 |\
+			    (sq_idx << NIC_Q_NUM_SHIFT) | ((reg) << 3))
+
+	sq = &nic->qs->sq[sq_idx];
+	sq->stats.bytes = GET_SQ_STATS(RQ_SQ_STATS_OCTS);
+	sq->stats.pkts = GET_SQ_STATS(RQ_SQ_STATS_PKTS);
+}
+
+/* Check for errors in the receive cmp.queue entry */
+int nicvf_check_cqe_rx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc)
+{
+	struct cqe_rx_t *cqe_rx;
+	struct cmp_queue_stats *stats = &cq->stats;
+
+	cqe_rx = (struct cqe_rx_t *)cq_desc;
+	if (!cqe_rx->err_level && !cqe_rx->err_opcode) {
+		stats->rx.errop.good++;
+		return 0;
+	}
+
+	switch (cqe_rx->err_level) {
+	case CQ_ERRLVL_MAC:
+		stats->rx.errlvl.mac_errs++;
+	break;
+	case CQ_ERRLVL_L2:
+		stats->rx.errlvl.l2_errs++;
+	break;
+	case CQ_ERRLVL_L3:
+		stats->rx.errlvl.l3_errs++;
+	break;
+	case CQ_ERRLVL_L4:
+		stats->rx.errlvl.l4_errs++;
+	break;
+	}
+
+	switch (cqe_rx->err_opcode) {
+	case CQ_RX_ERROP_RE_PARTIAL:
+		stats->rx.errop.partial_pkts++;
+	break;
+	case CQ_RX_ERROP_RE_JABBER:
+		stats->rx.errop.jabber_errs++;
+	break;
+	case CQ_RX_ERROP_RE_FCS:
+		stats->rx.errop.fcs_errs++;
+	break;
+	case CQ_RX_ERROP_RE_TERMINATE:
+		stats->rx.errop.terminate_errs++;
+	break;
+	case CQ_RX_ERROP_RE_RX_CTL:
+		stats->rx.errop.bgx_rx_errs++;
+	break;
+	case CQ_RX_ERROP_PREL2_ERR:
+		stats->rx.errop.prel2_errs++;
+	break;
+	case CQ_RX_ERROP_L2_FRAGMENT:
+		stats->rx.errop.l2_frags++;
+	break;
+	case CQ_RX_ERROP_L2_OVERRUN:
+		stats->rx.errop.l2_overruns++;
+	break;
+	case CQ_RX_ERROP_L2_PFCS:
+		stats->rx.errop.l2_pfcs++;
+	break;
+	case CQ_RX_ERROP_L2_PUNY:
+		stats->rx.errop.l2_puny++;
+	break;
+	case CQ_RX_ERROP_L2_MAL:
+		stats->rx.errop.l2_hdr_malformed++;
+	break;
+	case CQ_RX_ERROP_L2_OVERSIZE:
+		stats->rx.errop.l2_oversize++;
+	break;
+	case CQ_RX_ERROP_L2_UNDERSIZE:
+		stats->rx.errop.l2_undersize++;
+	break;
+	case CQ_RX_ERROP_L2_LENMISM:
+		stats->rx.errop.l2_len_mismatch++;
+	break;
+	case CQ_RX_ERROP_L2_PCLP:
+		stats->rx.errop.l2_pclp++;
+	break;
+	case CQ_RX_ERROP_IP_NOT:
+		stats->rx.errop.non_ip++;
+	break;
+	case CQ_RX_ERROP_IP_CSUM_ERR:
+		stats->rx.errop.ip_csum_err++;
+	break;
+	case CQ_RX_ERROP_IP_MAL:
+		stats->rx.errop.ip_hdr_malformed++;
+	break;
+	case CQ_RX_ERROP_IP_MALD:
+		stats->rx.errop.ip_payload_malformed++;
+	break;
+	case CQ_RX_ERROP_IP_HOP:
+		stats->rx.errop.ip_hop_errs++;
+	break;
+	case CQ_RX_ERROP_L3_ICRC:
+		stats->rx.errop.l3_icrc_errs++;
+	break;
+	case CQ_RX_ERROP_L3_PCLP:
+		stats->rx.errop.l3_pclp++;
+	break;
+	case CQ_RX_ERROP_L4_MAL:
+		stats->rx.errop.l4_malformed++;
+	break;
+	case CQ_RX_ERROP_L4_CHK:
+		stats->rx.errop.l4_csum_errs++;
+	break;
+	case CQ_RX_ERROP_UDP_LEN:
+		stats->rx.errop.udp_len_err++;
+	break;
+	case CQ_RX_ERROP_L4_PORT:
+		stats->rx.errop.bad_l4_port++;
+	break;
+	case CQ_RX_ERROP_TCP_FLAG:
+		stats->rx.errop.bad_tcp_flag++;
+	break;
+	case CQ_RX_ERROP_TCP_OFFSET:
+		stats->rx.errop.tcp_offset_errs++;
+	break;
+	case CQ_RX_ERROP_L4_PCLP:
+		stats->rx.errop.l4_pclp++;
+	break;
+	case CQ_RX_ERROP_RBDR_TRUNC:
+		stats->rx.errop.pkt_truncated++;
+	break;
+	}
+
+	return 1;
+}
+
+/* Check for errors in the send cmp.queue entry */
+int nicvf_check_cqe_tx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc)
+{
+	struct cqe_send_t *cqe_tx;
+	struct cmp_queue_stats *stats = &cq->stats;
+
+	cqe_tx = (struct cqe_send_t *)cq_desc;
+	switch (cqe_tx->send_status) {
+	case CQ_TX_ERROP_GOOD:
+		stats->tx.good++;
+		return 0;
+	break;
+	case CQ_TX_ERROP_DESC_FAULT:
+		stats->tx.desc_fault++;
+	break;
+	case CQ_TX_ERROP_HDR_CONS_ERR:
+		stats->tx.hdr_cons_err++;
+	break;
+	case CQ_TX_ERROP_SUBDC_ERR:
+		stats->tx.subdesc_err++;
+	break;
+	case CQ_TX_ERROP_IMM_SIZE_OFLOW:
+		stats->tx.imm_size_oflow++;
+	break;
+	case CQ_TX_ERROP_DATA_SEQUENCE_ERR:
+		stats->tx.data_seq_err++;
+	break;
+	case CQ_TX_ERROP_MEM_SEQUENCE_ERR:
+		stats->tx.mem_seq_err++;
+	break;
+	case CQ_TX_ERROP_LOCK_VIOL:
+		stats->tx.lock_viol++;
+	break;
+	case CQ_TX_ERROP_DATA_FAULT:
+		stats->tx.data_fault++;
+	break;
+	case CQ_TX_ERROP_TSTMP_CONFLICT:
+		stats->tx.tstmp_conflict++;
+	break;
+	case CQ_TX_ERROP_TSTMP_TIMEOUT:
+		stats->tx.tstmp_timeout++;
+	break;
+	case CQ_TX_ERROP_MEM_FAULT:
+		stats->tx.mem_fault++;
+	break;
+	case CQ_TX_ERROP_CK_OVERLAP:
+		stats->tx.csum_overlap++;
+	break;
+	case CQ_TX_ERROP_CK_OFLOW:
+		stats->tx.csum_overflow++;
+	break;
+	}
+
+	return 1;
+}
diff --git a/drivers/net/octeontx/nicvf_queues.h b/drivers/net/octeontx/nicvf_queues.h
new file mode 100644
index 0000000000..390eaa793b
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_queues.h
@@ -0,0 +1,355 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef NICVF_QUEUES_H
+#define NICVF_QUEUES_H
+
+#include "q_struct.h"
+
+#define MAX_QUEUE_SET			128
+#define MAX_RCV_QUEUES_PER_QS		8
+#define MAX_RCV_BUF_DESC_RINGS_PER_QS	2
+#define MAX_SND_QUEUES_PER_QS		8
+#define MAX_CMP_QUEUES_PER_QS		8
+
+/* VF's queue interrupt ranges */
+#define	NICVF_INTR_ID_CQ		0
+#define	NICVF_INTR_ID_SQ		8
+#define	NICVF_INTR_ID_RBDR		16
+#define	NICVF_INTR_ID_MISC		18
+#define	NICVF_INTR_ID_QS_ERR		19
+
+#define RBDR_SIZE0		0ULL /* 8K entries */
+#define RBDR_SIZE1		1ULL /* 16K entries */
+#define RBDR_SIZE2		2ULL /* 32K entries */
+#define RBDR_SIZE3		3ULL /* 64K entries */
+#define RBDR_SIZE4		4ULL /* 126K entries */
+#define RBDR_SIZE5		5ULL /* 256K entries */
+#define RBDR_SIZE6		6ULL /* 512K entries */
+
+#define SND_QUEUE_SIZE0		0ULL /* 1K entries */
+#define SND_QUEUE_SIZE1		1ULL /* 2K entries */
+#define SND_QUEUE_SIZE2		2ULL /* 4K entries */
+#define SND_QUEUE_SIZE3		3ULL /* 8K entries */
+#define SND_QUEUE_SIZE4		4ULL /* 16K entries */
+#define SND_QUEUE_SIZE5		5ULL /* 32K entries */
+#define SND_QUEUE_SIZE6		6ULL /* 64K entries */
+
+#define CMP_QUEUE_SIZE0		0ULL /* 1K entries */
+#define CMP_QUEUE_SIZE1		1ULL /* 2K entries */
+#define CMP_QUEUE_SIZE2		2ULL /* 4K entries */
+#define CMP_QUEUE_SIZE3		3ULL /* 8K entries */
+#define CMP_QUEUE_SIZE4		4ULL /* 16K entries */
+#define CMP_QUEUE_SIZE5		5ULL /* 32K entries */
+#define CMP_QUEUE_SIZE6		6ULL /* 64K entries */
+
+/* Default queue count per QS, its lengths and threshold values */
+#define RBDR_CNT			1
+#define RCV_QUEUE_CNT		1
+#define SND_QUEUE_CNT		1
+#define CMP_QUEUE_CNT		1 /* Max of RCV and SND qcount */
+
+#define SND_QSIZE		SND_QUEUE_SIZE0
+#define SND_QUEUE_LEN		BIT_ULL((SND_QSIZE + 10))
+#define SND_QUEUE_THRESH	2ULL
+#define MIN_SQ_DESC_PER_PKT_XMIT	2
+#define MAX_CQE_PER_PKT_XMIT		2
+
+#define CMP_QSIZE		CMP_QUEUE_SIZE0
+#define CMP_QUEUE_LEN		BIT_ULL((CMP_QSIZE + 10))
+#define CMP_QUEUE_CQE_THRESH	0
+#define CMP_QUEUE_TIMER_THRESH	1 /* 1 ms */
+
+#define RBDR_SIZE		RBDR_SIZE0
+#define RCV_BUF_COUNT		BIT_ULL((RBDR_SIZE + 13))
+#define RBDR_THRESH		(RCV_BUF_COUNT / 2)
+#define DMA_BUFFER_LEN		2048 /* In multiples of 128bytes */
+#define RCV_FRAG_LEN		DMA_BUFFER_LEN
+
+#define MAX_CQES_FOR_TX		((SND_QUEUE_LEN / MIN_SQ_DESC_PER_PKT_XMIT) *\
+				 MAX_CQE_PER_PKT_XMIT)
+#define RQ_CQ_DROP		((CMP_QUEUE_LEN - MAX_CQES_FOR_TX) / 256)
+
+/* Descriptor size */
+#define SND_QUEUE_DESC_SIZE	16   /* 128 bits */
+#define CMP_QUEUE_DESC_SIZE	512
+
+/* Buffer / descriptor alignments */
+#define NICVF_RCV_BUF_ALIGN		7
+#define NICVF_RCV_BUF_ALIGN_BYTES	BIT_ULL(NICVF_RCV_BUF_ALIGN)
+#define NICVF_CQ_BASE_ALIGN_BYTES	512  /* 9 bits */
+#define NICVF_SQ_BASE_ALIGN_BYTES	128  /* 7 bits */
+
+#define NICVF_ALIGNED_ADDR(ADDR, ALIGN_BYTES)	ALIGN(ADDR, ALIGN_BYTES)
+
+/* Queue enable/disable */
+#define NICVF_SQ_EN            BIT_ULL(19)
+
+/* Queue reset */
+#define NICVF_CQ_RESET		BIT_ULL(41)
+#define NICVF_SQ_RESET		BIT_ULL(17)
+#define NICVF_RBDR_RESET	BIT_ULL(43)
+
+enum CQ_RX_ERRLVL_E {
+	CQ_ERRLVL_MAC,
+	CQ_ERRLVL_L2,
+	CQ_ERRLVL_L3,
+	CQ_ERRLVL_L4,
+};
+
+enum CQ_RX_ERROP_E {
+	CQ_RX_ERROP_RE_NONE = 0x0,
+	CQ_RX_ERROP_RE_PARTIAL = 0x1,
+	CQ_RX_ERROP_RE_JABBER = 0x2,
+	CQ_RX_ERROP_RE_FCS = 0x7,
+	CQ_RX_ERROP_RE_TERMINATE = 0x9,
+	CQ_RX_ERROP_RE_RX_CTL = 0xb,
+	CQ_RX_ERROP_PREL2_ERR = 0x1f,
+	CQ_RX_ERROP_L2_FRAGMENT = 0x20,
+	CQ_RX_ERROP_L2_OVERRUN = 0x21,
+	CQ_RX_ERROP_L2_PFCS = 0x22,
+	CQ_RX_ERROP_L2_PUNY = 0x23,
+	CQ_RX_ERROP_L2_MAL = 0x24,
+	CQ_RX_ERROP_L2_OVERSIZE = 0x25,
+	CQ_RX_ERROP_L2_UNDERSIZE = 0x26,
+	CQ_RX_ERROP_L2_LENMISM = 0x27,
+	CQ_RX_ERROP_L2_PCLP = 0x28,
+	CQ_RX_ERROP_IP_NOT = 0x41,
+	CQ_RX_ERROP_IP_CSUM_ERR = 0x42,
+	CQ_RX_ERROP_IP_MAL = 0x43,
+	CQ_RX_ERROP_IP_MALD = 0x44,
+	CQ_RX_ERROP_IP_HOP = 0x45,
+	CQ_RX_ERROP_L3_ICRC = 0x46,
+	CQ_RX_ERROP_L3_PCLP = 0x47,
+	CQ_RX_ERROP_L4_MAL = 0x61,
+	CQ_RX_ERROP_L4_CHK = 0x62,
+	CQ_RX_ERROP_UDP_LEN = 0x63,
+	CQ_RX_ERROP_L4_PORT = 0x64,
+	CQ_RX_ERROP_TCP_FLAG = 0x65,
+	CQ_RX_ERROP_TCP_OFFSET = 0x66,
+	CQ_RX_ERROP_L4_PCLP = 0x67,
+	CQ_RX_ERROP_RBDR_TRUNC = 0x70,
+};
+
+enum CQ_TX_ERROP_E {
+	CQ_TX_ERROP_GOOD = 0x0,
+	CQ_TX_ERROP_DESC_FAULT = 0x10,
+	CQ_TX_ERROP_HDR_CONS_ERR = 0x11,
+	CQ_TX_ERROP_SUBDC_ERR = 0x12,
+	CQ_TX_ERROP_IMM_SIZE_OFLOW = 0x80,
+	CQ_TX_ERROP_DATA_SEQUENCE_ERR = 0x81,
+	CQ_TX_ERROP_MEM_SEQUENCE_ERR = 0x82,
+	CQ_TX_ERROP_LOCK_VIOL = 0x83,
+	CQ_TX_ERROP_DATA_FAULT = 0x84,
+	CQ_TX_ERROP_TSTMP_CONFLICT = 0x85,
+	CQ_TX_ERROP_TSTMP_TIMEOUT = 0x86,
+	CQ_TX_ERROP_MEM_FAULT = 0x87,
+	CQ_TX_ERROP_CK_OVERLAP = 0x88,
+	CQ_TX_ERROP_CK_OFLOW = 0x89,
+	CQ_TX_ERROP_ENUM_LAST = 0x8a,
+};
+
+struct cmp_queue_stats {
+	struct rx_stats {
+		struct {
+			u64 mac_errs;
+			u64 l2_errs;
+			u64 l3_errs;
+			u64 l4_errs;
+		} errlvl;
+		struct {
+			u64 good;
+			u64 partial_pkts;
+			u64 jabber_errs;
+			u64 fcs_errs;
+			u64 terminate_errs;
+			u64 bgx_rx_errs;
+			u64 prel2_errs;
+			u64 l2_frags;
+			u64 l2_overruns;
+			u64 l2_pfcs;
+			u64 l2_puny;
+			u64 l2_hdr_malformed;
+			u64 l2_oversize;
+			u64 l2_undersize;
+			u64 l2_len_mismatch;
+			u64 l2_pclp;
+			u64 non_ip;
+			u64 ip_csum_err;
+			u64 ip_hdr_malformed;
+			u64 ip_payload_malformed;
+			u64 ip_hop_errs;
+			u64 l3_icrc_errs;
+			u64 l3_pclp;
+			u64 l4_malformed;
+			u64 l4_csum_errs;
+			u64 udp_len_err;
+			u64 bad_l4_port;
+			u64 bad_tcp_flag;
+			u64 tcp_offset_errs;
+			u64 l4_pclp;
+			u64 pkt_truncated;
+		} errop;
+	} rx;
+	struct tx_stats {
+		u64 good;
+		u64 desc_fault;
+		u64 hdr_cons_err;
+		u64 subdesc_err;
+		u64 imm_size_oflow;
+		u64 data_seq_err;
+		u64 mem_seq_err;
+		u64 lock_viol;
+		u64 data_fault;
+		u64 tstmp_conflict;
+		u64 tstmp_timeout;
+		u64 mem_fault;
+		u64 csum_overlap;
+		u64 csum_overflow;
+	} tx;
+};
+
+enum RQ_SQ_STATS {
+	RQ_SQ_STATS_OCTS,
+	RQ_SQ_STATS_PKTS,
+};
+
+struct rx_tx_queue_stats {
+	u64	bytes;
+	u64	pkts;
+};
+
+struct q_desc_mem {
+	uintptr_t	dma;
+	u64	size;
+	u16	q_len;
+	uintptr_t	phys_base;
+	void		*base;
+	void		*unalign_base;
+	bool		allocated;
+};
+
+struct rbdr {
+	bool		enable;
+	u32	dma_size;
+	u32	thresh;      /* Threshold level for interrupt */
+	void		*desc;
+	u32	head;
+	u32	tail;
+	struct		q_desc_mem   dmem;
+	uintptr_t	buf_mem;
+	uintptr_t	buffers;
+};
+
+struct rcv_queue {
+	bool		enable;
+	struct	rbdr	*rbdr_start;
+	struct	rbdr	*rbdr_cont;
+	bool		en_tcp_reassembly;
+	u8		cq_qs;  /* CQ's QS to which this RQ is assigned */
+	u8		cq_idx; /* CQ index (0 to 7) in the QS */
+	u8		cont_rbdr_qs;      /* Continue buffer ptrs - QS num */
+	u8		cont_qs_rbdr_idx;  /* RBDR idx in the cont QS */
+	u8		start_rbdr_qs;     /* First buffer ptrs - QS num */
+	u8		start_qs_rbdr_idx; /* RBDR idx in the above QS */
+	u8         caching;
+	struct		rx_tx_queue_stats stats;
+};
+
+struct cmp_queue {
+	bool		enable;
+	u16	intr_timer_thresh;
+	u16	thresh;
+	void		*desc;
+	struct q_desc_mem   dmem;
+	struct cmp_queue_stats	stats;
+};
+
+struct snd_queue {
+	bool		enable;
+	u8		cq_qs;  /* CQ's QS to which this SQ is pointing */
+	u8		cq_idx; /* CQ index (0 to 7) in the above QS */
+	u16	thresh;
+	u32	free_cnt;
+	u32	head;
+	u32	tail;
+	u64	*skbuff;
+	void		*desc;
+	struct q_desc_mem   dmem;
+	struct rx_tx_queue_stats stats;
+};
+
+struct queue_set {
+	bool		enable;
+	bool		be_en;
+	u8		vnic_id;
+	u8		rq_cnt;
+	u8		cq_cnt;
+	u64	cq_len;
+	u8		sq_cnt;
+	u64	sq_len;
+	u8		rbdr_cnt;
+	u64	rbdr_len;
+	struct	rcv_queue	rq[MAX_RCV_QUEUES_PER_QS];
+	struct	cmp_queue	cq[MAX_CMP_QUEUES_PER_QS];
+	struct	snd_queue	sq[MAX_SND_QUEUES_PER_QS];
+	struct	rbdr		rbdr[MAX_RCV_BUF_DESC_RINGS_PER_QS];
+};
+
+#define GET_RBDR_DESC(RING, idx)\
+		(&(((struct rbdr_entry_t *)((RING)->desc))[idx]))
+#define GET_SQ_DESC(RING, idx)\
+		(&(((struct sq_hdr_subdesc *)((RING)->desc))[idx]))
+#define GET_CQ_DESC(RING, idx)\
+		(&(((union cq_desc_t *)((RING)->desc))[idx]))
+
+/* CQ status bits */
+#define	CQ_WR_FULL	BIT(26)
+#define	CQ_WR_DISABLE	BIT(25)
+#define	CQ_WR_FAULT	BIT(24)
+#define	CQ_CQE_COUNT	(0xFFFF << 0)
+
+#define	CQ_ERR_MASK	(CQ_WR_FULL | CQ_WR_DISABLE | CQ_WR_FAULT)
+
+int nicvf_set_qset_resources(struct nicvf *nic);
+int nicvf_config_data_transfer(struct nicvf *nic, bool enable);
+void nicvf_qset_config(struct nicvf *nic, bool enable);
+void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
+			    int qidx, bool enable);
+
+void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx);
+void nicvf_sq_disable(struct nicvf *nic, int qidx);
+void nicvf_put_sq_desc(struct snd_queue *sq, int desc_cnt);
+void nicvf_sq_free_used_descs(struct udevice *dev,
+			      struct snd_queue *sq, int qidx);
+int nicvf_sq_append_pkt(struct nicvf *nic, void *pkt, size_t pkt_len);
+
+void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len);
+void nicvf_refill_rbdr(struct nicvf *nic);
+
+void nicvf_enable_intr(struct nicvf *nic, int int_type, int q_idx);
+void nicvf_disable_intr(struct nicvf *nic, int int_type, int q_idx);
+void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx);
+int nicvf_is_intr_enabled(struct nicvf *nic, int int_type, int q_idx);
+
+/* Register access APIs */
+void nicvf_reg_write(struct nicvf *nic, u64 offset, u64 val);
+u64 nicvf_reg_read(struct nicvf *nic, u64 offset);
+void nicvf_qset_reg_write(struct nicvf *nic, u64 offset, u64 val);
+u64 nicvf_qset_reg_read(struct nicvf *nic, u64 offset);
+void nicvf_queue_reg_write(struct nicvf *nic, u64 offset,
+			   u64 qidx, u64 val);
+u64 nicvf_queue_reg_read(struct nicvf *nic, u64 offset, u64 qidx);
+
+/* Stats */
+void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx);
+void nicvf_update_sq_stats(struct nicvf *nic, int sq_idx);
+int nicvf_check_cqe_rx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc);
+int nicvf_check_cqe_tx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc);
+#endif /* NICVF_QUEUES_H */
diff --git a/drivers/net/octeontx/q_struct.h b/drivers/net/octeontx/q_struct.h
new file mode 100644
index 0000000000..b08b271818
--- /dev/null
+++ b/drivers/net/octeontx/q_struct.h
@@ -0,0 +1,697 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef Q_STRUCT_H
+#define Q_STRUCT_H
+
+/* Load transaction types for reading segment bytes specified by
+ * NIC_SEND_GATHER_S[LD_TYPE].
+ */
+enum nic_send_ld_type_e {
+	NIC_SEND_LD_TYPE_E_LDD = 0x0,
+	NIC_SEND_LD_TYPE_E_LDT = 0x1,
+	NIC_SEND_LD_TYPE_E_LDWB = 0x2,
+	NIC_SEND_LD_TYPE_E_ENUM_LAST = 0x3,
+};
+
+enum ether_type_algorithm {
+	ETYPE_ALG_NONE = 0x0,
+	ETYPE_ALG_SKIP = 0x1,
+	ETYPE_ALG_ENDPARSE = 0x2,
+	ETYPE_ALG_VLAN = 0x3,
+	ETYPE_ALG_VLAN_STRIP = 0x4,
+};
+
+enum layer3_type {
+	L3TYPE_NONE = 0x00,
+	L3TYPE_GRH = 0x01,
+	L3TYPE_IPV4 = 0x04,
+	L3TYPE_IPV4_OPTIONS = 0x05,
+	L3TYPE_IPV6 = 0x06,
+	L3TYPE_IPV6_OPTIONS = 0x07,
+	L3TYPE_ET_STOP = 0x0D,
+	L3TYPE_OTHER = 0x0E,
+};
+
+enum layer4_type {
+	L4TYPE_NONE = 0x00,
+	L4TYPE_IPSEC_ESP = 0x01,
+	L4TYPE_IPFRAG = 0x02,
+	L4TYPE_IPCOMP = 0x03,
+	L4TYPE_TCP = 0x04,
+	L4TYPE_UDP = 0x05,
+	L4TYPE_SCTP = 0x06,
+	L4TYPE_GRE = 0x07,
+	L4TYPE_ROCE_BTH = 0x08,
+	L4TYPE_OTHER = 0x0E,
+};
+
+/* CPI and RSSI configuration */
+enum cpi_algorithm_type {
+	CPI_ALG_NONE = 0x0,
+	CPI_ALG_VLAN = 0x1,
+	CPI_ALG_VLAN16 = 0x2,
+	CPI_ALG_DIFF = 0x3,
+};
+
+enum rss_algorithm_type {
+	RSS_ALG_NONE = 0x00,
+	RSS_ALG_PORT = 0x01,
+	RSS_ALG_IP = 0x02,
+	RSS_ALG_TCP_IP = 0x03,
+	RSS_ALG_UDP_IP = 0x04,
+	RSS_ALG_SCTP_IP = 0x05,
+	RSS_ALG_GRE_IP = 0x06,
+	RSS_ALG_ROCE = 0x07,
+};
+
+enum rss_hash_cfg {
+	RSS_HASH_L2ETC = 0x00,
+	RSS_HASH_IP = 0x01,
+	RSS_HASH_TCP = 0x02,
+	RSS_TCP_SYN_DIS = 0x03,
+	RSS_HASH_UDP = 0x04,
+	RSS_HASH_L4ETC = 0x05,
+	RSS_HASH_ROCE = 0x06,
+	RSS_L3_BIDI = 0x07,
+	RSS_L4_BIDI = 0x08,
+};
+
+/* Completion queue entry types */
+enum cqe_type {
+	CQE_TYPE_INVALID = 0x0,
+	CQE_TYPE_RX = 0x2,
+	CQE_TYPE_RX_SPLIT = 0x3,
+	CQE_TYPE_RX_TCP = 0x4,
+	CQE_TYPE_SEND = 0x8,
+	CQE_TYPE_SEND_PTP = 0x9,
+};
+
+enum cqe_rx_tcp_status {
+	CQE_RX_STATUS_VALID_TCP_CNXT = 0x00,
+	CQE_RX_STATUS_INVALID_TCP_CNXT = 0x0F,
+};
+
+enum cqe_send_status {
+	CQE_SEND_STATUS_GOOD = 0x00,
+	CQE_SEND_STATUS_DESC_FAULT = 0x01,
+	CQE_SEND_STATUS_HDR_CONS_ERR = 0x11,
+	CQE_SEND_STATUS_SUBDESC_ERR = 0x12,
+	CQE_SEND_STATUS_IMM_SIZE_OFLOW = 0x80,
+	CQE_SEND_STATUS_CRC_SEQ_ERR = 0x81,
+	CQE_SEND_STATUS_DATA_SEQ_ERR = 0x82,
+	CQE_SEND_STATUS_MEM_SEQ_ERR = 0x83,
+	CQE_SEND_STATUS_LOCK_VIOL = 0x84,
+	CQE_SEND_STATUS_LOCK_UFLOW = 0x85,
+	CQE_SEND_STATUS_DATA_FAULT = 0x86,
+	CQE_SEND_STATUS_TSTMP_CONFLICT = 0x87,
+	CQE_SEND_STATUS_TSTMP_TIMEOUT = 0x88,
+	CQE_SEND_STATUS_MEM_FAULT = 0x89,
+	CQE_SEND_STATUS_CSUM_OVERLAP = 0x8A,
+	CQE_SEND_STATUS_CSUM_OVERFLOW = 0x8B,
+};
+
+enum cqe_rx_tcp_end_reason {
+	CQE_RX_TCP_END_FIN_FLAG_DET = 0,
+	CQE_RX_TCP_END_INVALID_FLAG = 1,
+	CQE_RX_TCP_END_TIMEOUT = 2,
+	CQE_RX_TCP_END_OUT_OF_SEQ = 3,
+	CQE_RX_TCP_END_PKT_ERR = 4,
+	CQE_RX_TCP_END_QS_DISABLED = 0x0F,
+};
+
+/* Packet protocol level error enumeration */
+enum cqe_rx_err_level {
+	CQE_RX_ERRLVL_RE = 0x0,
+	CQE_RX_ERRLVL_L2 = 0x1,
+	CQE_RX_ERRLVL_L3 = 0x2,
+	CQE_RX_ERRLVL_L4 = 0x3,
+};
+
+/* Packet protocol level error type enumeration */
+enum cqe_rx_err_opcode {
+	CQE_RX_ERR_RE_NONE = 0x0,
+	CQE_RX_ERR_RE_PARTIAL = 0x1,
+	CQE_RX_ERR_RE_JABBER = 0x2,
+	CQE_RX_ERR_RE_FCS = 0x7,
+	CQE_RX_ERR_RE_TERMINATE = 0x9,
+	CQE_RX_ERR_RE_RX_CTL = 0xb,
+	CQE_RX_ERR_PREL2_ERR = 0x1f,
+	CQE_RX_ERR_L2_FRAGMENT = 0x20,
+	CQE_RX_ERR_L2_OVERRUN = 0x21,
+	CQE_RX_ERR_L2_PFCS = 0x22,
+	CQE_RX_ERR_L2_PUNY = 0x23,
+	CQE_RX_ERR_L2_MAL = 0x24,
+	CQE_RX_ERR_L2_OVERSIZE = 0x25,
+	CQE_RX_ERR_L2_UNDERSIZE = 0x26,
+	CQE_RX_ERR_L2_LENMISM = 0x27,
+	CQE_RX_ERR_L2_PCLP = 0x28,
+	CQE_RX_ERR_IP_NOT = 0x41,
+	CQE_RX_ERR_IP_CHK = 0x42,
+	CQE_RX_ERR_IP_MAL = 0x43,
+	CQE_RX_ERR_IP_MALD = 0x44,
+	CQE_RX_ERR_IP_HOP = 0x45,
+	CQE_RX_ERR_L3_ICRC = 0x46,
+	CQE_RX_ERR_L3_PCLP = 0x47,
+	CQE_RX_ERR_L4_MAL = 0x61,
+	CQE_RX_ERR_L4_CHK = 0x62,
+	CQE_RX_ERR_UDP_LEN = 0x63,
+	CQE_RX_ERR_L4_PORT = 0x64,
+	CQE_RX_ERR_TCP_FLAG = 0x65,
+	CQE_RX_ERR_TCP_OFFSET = 0x66,
+	CQE_RX_ERR_L4_PCLP = 0x67,
+	CQE_RX_ERR_RBDR_TRUNC = 0x70,
+};
+
+struct cqe_rx_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   cqe_type:4; /* W0 */
+	u64   stdn_fault:1;
+	u64   rsvd0:1;
+	u64   rq_qs:7;
+	u64   rq_idx:3;
+	u64   rsvd1:12;
+	u64   rss_alg:4;
+	u64   rsvd2:4;
+	u64   rb_cnt:4;
+	u64   vlan_found:1;
+	u64   vlan_stripped:1;
+	u64   vlan2_found:1;
+	u64   vlan2_stripped:1;
+	u64   l4_type:4;
+	u64   l3_type:4;
+	u64   l2_present:1;
+	u64   err_level:3;
+	u64   err_opcode:8;
+
+	u64   pkt_len:16; /* W1 */
+	u64   l2_ptr:8;
+	u64   l3_ptr:8;
+	u64   l4_ptr:8;
+	u64   cq_pkt_len:8;
+	u64   align_pad:3;
+	u64   rsvd3:1;
+	u64   chan:12;
+
+	u64   rss_tag:32; /* W2 */
+	u64   vlan_tci:16;
+	u64   vlan_ptr:8;
+	u64   vlan2_ptr:8;
+
+	u64   rb3_sz:16; /* W3 */
+	u64   rb2_sz:16;
+	u64   rb1_sz:16;
+	u64   rb0_sz:16;
+
+	u64   rb7_sz:16; /* W4 */
+	u64   rb6_sz:16;
+	u64   rb5_sz:16;
+	u64   rb4_sz:16;
+
+	u64   rb11_sz:16; /* W5 */
+	u64   rb10_sz:16;
+	u64   rb9_sz:16;
+	u64   rb8_sz:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   err_opcode:8;
+	u64   err_level:3;
+	u64   l2_present:1;
+	u64   l3_type:4;
+	u64   l4_type:4;
+	u64   vlan2_stripped:1;
+	u64   vlan2_found:1;
+	u64   vlan_stripped:1;
+	u64   vlan_found:1;
+	u64   rb_cnt:4;
+	u64   rsvd2:4;
+	u64   rss_alg:4;
+	u64   rsvd1:12;
+	u64   rq_idx:3;
+	u64   rq_qs:7;
+	u64   rsvd0:1;
+	u64   stdn_fault:1;
+	u64   cqe_type:4; /* W0 */
+	u64   chan:12;
+	u64   rsvd3:1;
+	u64   align_pad:3;
+	u64   cq_pkt_len:8;
+	u64   l4_ptr:8;
+	u64   l3_ptr:8;
+	u64   l2_ptr:8;
+	u64   pkt_len:16; /* W1 */
+	u64   vlan2_ptr:8;
+	u64   vlan_ptr:8;
+	u64   vlan_tci:16;
+	u64   rss_tag:32; /* W2 */
+	u64   rb0_sz:16;
+	u64   rb1_sz:16;
+	u64   rb2_sz:16;
+	u64   rb3_sz:16; /* W3 */
+	u64   rb4_sz:16;
+	u64   rb5_sz:16;
+	u64   rb6_sz:16;
+	u64   rb7_sz:16; /* W4 */
+	u64   rb8_sz:16;
+	u64   rb9_sz:16;
+	u64   rb10_sz:16;
+	u64   rb11_sz:16; /* W5 */
+#endif
+	u64   rb0_ptr:64;
+	u64   rb1_ptr:64;
+	u64   rb2_ptr:64;
+	u64   rb3_ptr:64;
+	u64   rb4_ptr:64;
+	u64   rb5_ptr:64;
+	u64   rb6_ptr:64;
+	u64   rb7_ptr:64;
+	u64   rb8_ptr:64;
+	u64   rb9_ptr:64;
+	u64   rb10_ptr:64;
+	u64   rb11_ptr:64;
+};
+
+struct cqe_rx_tcp_err_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:60;
+
+	u64   rsvd1:4; /* W1 */
+	u64   partial_first:1;
+	u64   rsvd2:27;
+	u64   rbdr_bytes:8;
+	u64   rsvd3:24;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   rsvd0:60;
+	u64   cqe_type:4;
+
+	u64   rsvd3:24;
+	u64   rbdr_bytes:8;
+	u64   rsvd2:27;
+	u64   partial_first:1;
+	u64   rsvd1:4;
+#endif
+};
+
+struct cqe_rx_tcp_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:52;
+	u64   cq_tcp_status:8;
+
+	u64   rsvd1:32; /* W1 */
+	u64   tcp_cntx_bytes:8;
+	u64   rsvd2:8;
+	u64   tcp_err_bytes:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   cq_tcp_status:8;
+	u64   rsvd0:52;
+	u64   cqe_type:4; /* W0 */
+
+	u64   tcp_err_bytes:16;
+	u64   rsvd2:8;
+	u64   tcp_cntx_bytes:8;
+	u64   rsvd1:32; /* W1 */
+#endif
+};
+
+struct cqe_send_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:4;
+	u64   sqe_ptr:16;
+	u64   rsvd1:4;
+	u64   rsvd2:10;
+	u64   sq_qs:7;
+	u64   sq_idx:3;
+	u64   rsvd3:8;
+	u64   send_status:8;
+
+	u64   ptp_timestamp:64; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   send_status:8;
+	u64   rsvd3:8;
+	u64   sq_idx:3;
+	u64   sq_qs:7;
+	u64   rsvd2:10;
+	u64   rsvd1:4;
+	u64   sqe_ptr:16;
+	u64   rsvd0:4;
+	u64   cqe_type:4; /* W0 */
+
+	u64   ptp_timestamp:64; /* W1 */
+#endif
+};
+
+union cq_desc_t {
+	u64 u[64];
+	struct cqe_send_t snd_hdr;
+	struct cqe_rx_t rx_hdr;
+	struct cqe_rx_tcp_t rx_tcp_hdr;
+	struct cqe_rx_tcp_err_t rx_tcp_err_hdr;
+};
+
+struct rbdr_entry_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   rsvd0:15;
+	u64   buf_addr:42;
+	u64   cache_align:7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   cache_align:7;
+	u64   buf_addr:42;
+	u64   rsvd0:15;
+#endif
+};
+
+/* TCP reassembly context */
+struct rbe_tcp_cnxt_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64   tcp_pkt_cnt:12;
+	u64   rsvd1:4;
+	u64   align_hdr_bytes:4;
+	u64   align_ptr_bytes:4;
+	u64   ptr_bytes:16;
+	u64   rsvd2:24;
+	u64   cqe_type:4;
+	u64   rsvd0:54;
+	u64   tcp_end_reason:2;
+	u64   tcp_status:4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64   tcp_status:4;
+	u64   tcp_end_reason:2;
+	u64   rsvd0:54;
+	u64   cqe_type:4;
+	u64   rsvd2:24;
+	u64   ptr_bytes:16;
+	u64   align_ptr_bytes:4;
+	u64   align_hdr_bytes:4;
+	u64   rsvd1:4;
+	u64   tcp_pkt_cnt:12;
+#endif
+};
+
+/* Always Big endian */
+struct rx_hdr_t {
+	u64   opaque:32;
+	u64   rss_flow:8;
+	u64   skip_length:6;
+	u64   disable_rss:1;
+	u64   disable_tcp_reassembly:1;
+	u64   nodrop:1;
+	u64   dest_alg:2;
+	u64   rsvd0:2;
+	u64   dest_rq:11;
+};
+
+enum send_l4_csum_type {
+	SEND_L4_CSUM_DISABLE = 0x00,
+	SEND_L4_CSUM_UDP = 0x01,
+	SEND_L4_CSUM_TCP = 0x02,
+	SEND_L4_CSUM_SCTP = 0x03,
+};
+
+enum send_crc_alg {
+	SEND_CRCALG_CRC32 = 0x00,
+	SEND_CRCALG_CRC32C = 0x01,
+	SEND_CRCALG_ICRC = 0x02,
+};
+
+enum send_load_type {
+	SEND_LD_TYPE_LDD = 0x00,
+	SEND_LD_TYPE_LDT = 0x01,
+	SEND_LD_TYPE_LDWB = 0x02,
+};
+
+enum send_mem_alg_type {
+	SEND_MEMALG_SET = 0x00,
+	SEND_MEMALG_ADD = 0x08,
+	SEND_MEMALG_SUB = 0x09,
+	SEND_MEMALG_ADDLEN = 0x0A,
+	SEND_MEMALG_SUBLEN = 0x0B,
+};
+
+enum send_mem_dsz_type {
+	SEND_MEMDSZ_B64 = 0x00,
+	SEND_MEMDSZ_B32 = 0x01,
+	SEND_MEMDSZ_B8 = 0x03,
+};
+
+enum sq_subdesc_type {
+	SQ_DESC_TYPE_INVALID = 0x00,
+	SQ_DESC_TYPE_HEADER = 0x01,
+	SQ_DESC_TYPE_CRC = 0x02,
+	SQ_DESC_TYPE_IMMEDIATE = 0x03,
+	SQ_DESC_TYPE_GATHER = 0x04,
+	SQ_DESC_TYPE_MEMORY = 0x05,
+};
+
+struct sq_crc_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64    rsvd1:32;
+	u64    crc_ival:32;
+	u64    subdesc_type:4;
+	u64    crc_alg:2;
+	u64    rsvd0:10;
+	u64    crc_insert_pos:16;
+	u64    hdr_start:16;
+	u64    crc_len:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64    crc_len:16;
+	u64    hdr_start:16;
+	u64    crc_insert_pos:16;
+	u64    rsvd0:10;
+	u64    crc_alg:2;
+	u64    subdesc_type:4;
+	u64    crc_ival:32;
+	u64    rsvd1:32;
+#endif
+};
+
+struct sq_gather_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64    subdesc_type:4; /* W0 */
+	u64    ld_type:2;
+	u64    rsvd0:42;
+	u64    size:16;
+
+	u64    rsvd1:15; /* W1 */
+	u64    addr:49;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64    size:16;
+	u64    rsvd0:42;
+	u64    ld_type:2;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    addr:49;
+	u64    rsvd1:15; /* W1 */
+#endif
+};
+
+/* SQ immediate subdescriptor */
+struct sq_imm_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64    subdesc_type:4; /* W0 */
+	u64    rsvd0:46;
+	u64    len:14;
+
+	u64    data:64; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64    len:14;
+	u64    rsvd0:46;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    data:64; /* W1 */
+#endif
+};
+
+struct sq_mem_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64    subdesc_type:4; /* W0 */
+	u64    mem_alg:4;
+	u64    mem_dsz:2;
+	u64    wmem:1;
+	u64    rsvd0:21;
+	u64    offset:32;
+
+	u64    rsvd1:15; /* W1 */
+	u64    addr:49;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64    offset:32;
+	u64    rsvd0:21;
+	u64    wmem:1;
+	u64    mem_dsz:2;
+	u64    mem_alg:4;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    addr:49;
+	u64    rsvd1:15; /* W1 */
+#endif
+};
+
+struct sq_hdr_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64    subdesc_type:4;
+	u64    tso:1;
+	u64    post_cqe:1; /* Post CQE on no error also */
+	u64    dont_send:1;
+	u64    tstmp:1;
+	u64    subdesc_cnt:8;
+	u64    csum_l4:2;
+	u64    csum_l3:1;
+	u64    rsvd0:5;
+	u64    l4_offset:8;
+	u64    l3_offset:8;
+	u64    rsvd1:4;
+	u64    tot_len:20; /* W0 */
+
+	u64    tso_sdc_cont:8;
+	u64    tso_sdc_first:8;
+	u64    tso_l4_offset:8;
+	u64    tso_flags_last:12;
+	u64    tso_flags_first:12;
+	u64    rsvd2:2;
+	u64    tso_max_paysize:14; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64    tot_len:20;
+	u64    rsvd1:4;
+	u64    l3_offset:8;
+	u64    l4_offset:8;
+	u64    rsvd0:5;
+	u64    csum_l3:1;
+	u64    csum_l4:2;
+	u64    subdesc_cnt:8;
+	u64    tstmp:1;
+	u64    dont_send:1;
+	u64    post_cqe:1; /* Post CQE on no error also */
+	u64    tso:1;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    tso_max_paysize:14;
+	u64    rsvd2:2;
+	u64    tso_flags_first:12;
+	u64    tso_flags_last:12;
+	u64    tso_l4_offset:8;
+	u64    tso_sdc_first:8;
+	u64    tso_sdc_cont:8; /* W1 */
+#endif
+};
+
+/* Queue config register formats */
+struct rq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 reserved_2_63:62;
+	u64 ena:1;
+	u64 tcp_ena:1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64 tcp_ena:1;
+	u64 ena:1;
+	u64 reserved_2_63:62;
+#endif
+};
+
+struct cq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 reserved_43_63:21;
+	u64 ena:1;
+	u64 reset:1;
+	u64 caching:1;
+	u64 reserved_35_39:5;
+	u64 qsize:3;
+	u64 reserved_25_31:7;
+	u64 avg_con:9;
+	u64 reserved_0_15:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64 reserved_0_15:16;
+	u64 avg_con:9;
+	u64 reserved_25_31:7;
+	u64 qsize:3;
+	u64 reserved_35_39:5;
+	u64 caching:1;
+	u64 reset:1;
+	u64 ena:1;
+	u64 reserved_43_63:21;
+#endif
+};
+
+struct sq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 reserved_20_63:44;
+	u64 ena:1;
+	u64 reserved_18_18:1;
+	u64 reset:1;
+	u64 ldwb:1;
+	u64 reserved_11_15:5;
+	u64 qsize:3;
+	u64 reserved_3_7:5;
+	u64 tstmp_bgx_intf:3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64 tstmp_bgx_intf:3;
+	u64 reserved_3_7:5;
+	u64 qsize:3;
+	u64 reserved_11_15:5;
+	u64 ldwb:1;
+	u64 reset:1;
+	u64 reserved_18_18:1;
+	u64 ena:1;
+	u64 reserved_20_63:44;
+#endif
+};
+
+struct rbdr_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 reserved_45_63:19;
+	u64 ena:1;
+	u64 reset:1;
+	u64 ldwb:1;
+	u64 reserved_36_41:6;
+	u64 qsize:4;
+	u64 reserved_25_31:7;
+	u64 avg_con:9;
+	u64 reserved_12_15:4;
+	u64 lines:12;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64 lines:12;
+	u64 reserved_12_15:4;
+	u64 avg_con:9;
+	u64 reserved_25_31:7;
+	u64 qsize:4;
+	u64 reserved_36_41:6;
+	u64 ldwb:1;
+	u64 reset:1;
+	u64 ena: 1;
+	u64 reserved_45_63:19;
+#endif
+};
+
+struct qs_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	u64 reserved_32_63:32;
+	u64 ena:1;
+	u64 reserved_27_30:4;
+	u64 sq_ins_ena:1;
+	u64 sq_ins_pos:6;
+	u64 lock_ena:1;
+	u64 lock_viol_cqe_ena:1;
+	u64 send_tstmp_ena:1;
+	u64 be:1;
+	u64 reserved_7_15:9;
+	u64 vnic:7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	u64 vnic:7;
+	u64 reserved_7_15:9;
+	u64 be:1;
+	u64 send_tstmp_ena:1;
+	u64 lock_viol_cqe_ena:1;
+	u64 lock_ena:1;
+	u64 sq_ins_pos:6;
+	u64 sq_ins_ena:1;
+	u64 reserved_27_30:4;
+	u64 ena:1;
+	u64 reserved_32_63:32;
+#endif
+};
+
+#endif /* Q_STRUCT_H */
diff --git a/drivers/net/octeontx/smi.c b/drivers/net/octeontx/smi.c
new file mode 100644
index 0000000000..4abe41cd01
--- /dev/null
+++ b/drivers/net/octeontx/smi.c
@@ -0,0 +1,382 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+#include <phy.h>
+#include <miiphy.h>
+#include <misc.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <env.h>
+#include <linux/ctype.h>
+
+#define PCI_DEVICE_ID_OCTEONTX_SMI 0xA02B
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum octeontx_smi_mode {
+	CLAUSE22 = 0,
+	CLAUSE45 = 1,
+};
+
+enum {
+	SMI_OP_C22_WRITE = 0,
+	SMI_OP_C22_READ = 1,
+
+	SMI_OP_C45_ADDR = 0,
+	SMI_OP_C45_WRITE = 1,
+	SMI_OP_C45_PRIA = 2,
+	SMI_OP_C45_READ = 3,
+};
+
+union smi_x_clk {
+	u64 u;
+	struct smi_x_clk_s {
+		int phase:8;
+		int sample:4;
+		int preamble:1;
+		int clk_idle:1;
+		int reserved_14_14:1;
+		int sample_mode:1;
+		int sample_hi:5;
+		int reserved_21_23:3;
+		int mode:1;
+	} s;
+};
+
+union smi_x_cmd {
+	u64 u;
+	struct smi_x_cmd_s {
+		int reg_adr:5;
+		int reserved_5_7:3;
+		int phy_adr:5;
+		int reserved_13_15:3;
+		int phy_op:2;
+	} s;
+};
+
+union smi_x_wr_dat {
+	u64 u;
+	struct smi_x_wr_dat_s {
+		unsigned int dat:16;
+		int val:1;
+		int pending:1;
+	} s;
+};
+
+union smi_x_rd_dat {
+	u64 u;
+	struct smi_x_rd_dat_s {
+		unsigned int dat:16;
+		int val:1;
+		int pending:1;
+	} s;
+};
+
+union smi_x_en {
+	u64 u;
+	struct smi_x_en_s {
+		int en:1;
+	} s;
+};
+
+#define SMI_X_RD_DAT	0x10ull
+#define SMI_X_WR_DAT	0x08ull
+#define SMI_X_CMD	0x00ull
+#define SMI_X_CLK	0x18ull
+#define SMI_X_EN	0x20ull
+
+struct octeontx_smi_priv {
+	void __iomem *baseaddr;
+	enum octeontx_smi_mode mode;
+};
+
+#define MDIO_TIMEOUT 10000
+
+void octeontx_smi_setmode(struct mii_dev *bus, enum octeontx_smi_mode mode)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_clk smix_clk;
+
+	smix_clk.u = readq(priv->baseaddr + SMI_X_CLK);
+	smix_clk.s.mode = mode;
+	smix_clk.s.preamble = mode == CLAUSE45;
+	writeq(smix_clk.u, priv->baseaddr + SMI_X_CLK);
+
+	priv->mode = mode;
+}
+
+int octeontx_c45_addr(struct mii_dev *bus, int addr, int devad, int regnum)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+
+	union smi_x_cmd smix_cmd;
+	union smi_x_wr_dat smix_wr_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+
+	smix_wr_dat.u = 0;
+	smix_wr_dat.s.dat = regnum;
+
+	writeq(smix_wr_dat.u, priv->baseaddr + SMI_X_WR_DAT);
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_op = SMI_OP_C45_ADDR;
+	smix_cmd.s.phy_adr = addr;
+	smix_cmd.s.reg_adr = devad;
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_wr_dat.u = readq(priv->baseaddr + SMI_X_WR_DAT);
+		udelay(100);
+		timeout--;
+	} while (smix_wr_dat.s.pending && timeout);
+
+	return timeout == 0;
+}
+
+int octeontx_phy_read(struct mii_dev *bus, int addr, int devad, int regnum)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_cmd smix_cmd;
+	union smi_x_rd_dat smix_rd_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+	int ret;
+
+	enum octeontx_smi_mode mode = (devad < 0) ? CLAUSE22 : CLAUSE45;
+
+	debug("RD: Mode: %u, baseaddr: %p, addr: %d, devad: %d, reg: %d\n",
+	      mode, priv->baseaddr, addr, devad, regnum);
+
+	octeontx_smi_setmode(bus, mode);
+
+	if (mode == CLAUSE45) {
+		ret = octeontx_c45_addr(bus, addr, devad, regnum);
+
+		debug("RD: ret: %u\n", ret);
+
+		if (ret)
+			return 0;
+	}
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_adr = addr;
+
+	if (mode == CLAUSE45) {
+		smix_cmd.s.reg_adr = devad;
+		smix_cmd.s.phy_op = SMI_OP_C45_READ;
+	} else {
+		smix_cmd.s.reg_adr = regnum;
+		smix_cmd.s.phy_op = SMI_OP_C22_READ;
+	}
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_rd_dat.u = readq(priv->baseaddr + SMI_X_RD_DAT);
+		udelay(10);
+		timeout--;
+	} while (smix_rd_dat.s.pending && timeout);
+
+	debug("SMIX_RD_DAT: %lx\n", (unsigned long)smix_rd_dat.u);
+
+	return smix_rd_dat.s.dat;
+}
+
+int octeontx_phy_write(struct mii_dev *bus, int addr, int devad, int regnum,
+		       u16 value)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_cmd smix_cmd;
+	union smi_x_wr_dat smix_wr_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+	int ret;
+
+	enum octeontx_smi_mode mode = (devad < 0) ? CLAUSE22 : CLAUSE45;
+
+	debug("WR: Mode: %u, baseaddr: %p, addr: %d, devad: %d, reg: %d\n",
+	      mode, priv->baseaddr, addr, devad, regnum);
+
+	if (mode == CLAUSE45) {
+		ret = octeontx_c45_addr(bus, addr, devad, regnum);
+
+		debug("WR: ret: %u\n", ret);
+
+		if (ret)
+			return ret;
+	}
+
+	smix_wr_dat.u = 0;
+	smix_wr_dat.s.dat = value;
+
+	writeq(smix_wr_dat.u, priv->baseaddr + SMI_X_WR_DAT);
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_adr = addr;
+
+	if (mode == CLAUSE45) {
+		smix_cmd.s.reg_adr = devad;
+		smix_cmd.s.phy_op = SMI_OP_C45_WRITE;
+	} else {
+		smix_cmd.s.reg_adr = regnum;
+		smix_cmd.s.phy_op = SMI_OP_C22_WRITE;
+	}
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_wr_dat.u = readq(priv->baseaddr + SMI_X_WR_DAT);
+		udelay(10);
+		timeout--;
+	} while (smix_wr_dat.s.pending && timeout);
+
+	debug("SMIX_WR_DAT: %lx\n", (unsigned long)smix_wr_dat.u);
+
+	return timeout == 0;
+}
+
+int octeontx_smi_reset(struct mii_dev *bus)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+
+	union smi_x_en smi_en;
+
+	smi_en.s.en = 0;
+	writeq(smi_en.u, priv->baseaddr + SMI_X_EN);
+
+	smi_en.s.en = 1;
+	writeq(smi_en.u, priv->baseaddr + SMI_X_EN);
+
+	octeontx_smi_setmode(bus, CLAUSE22);
+
+	return 0;
+}
+
+/* PHY XS initialization, primarily for RXAUI
+ *
+ */
+int rxaui_phy_xs_init(struct mii_dev *bus, int phy_addr)
+{
+	int reg;
+	ulong start_time;
+	int phy_id1, phy_id2;
+	int oui, model_number;
+
+	phy_id1 = octeontx_phy_read(bus, phy_addr, 1, 0x2);
+	phy_id2 = octeontx_phy_read(bus, phy_addr, 1, 0x3);
+	model_number = (phy_id2 >> 4) & 0x3F;
+	debug("%s model %x\n", __func__, model_number);
+	oui = phy_id1;
+	oui <<= 6;
+	oui |= (phy_id2 >> 10) & 0x3F;
+	debug("%s oui %x\n", __func__, oui);
+	switch (oui) {
+	case 0x5016:
+		if (model_number == 9) {
+			debug("%s +\n", __func__);
+			/* Perform hardware reset in XGXS control */
+			reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
+			if ((reg & 0xffff) < 0)
+				goto read_error;
+			reg |= 0x8000;
+			octeontx_phy_write(bus, phy_addr, 4, 0x0, reg);
+
+			start_time = get_timer(0);
+			do {
+				reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
+				if ((reg & 0xffff) < 0)
+					goto read_error;
+			} while ((reg & 0x8000) && get_timer(start_time) < 500);
+			if (reg & 0x8000) {
+				printf("HW reset for M88X3120 PHY failed");
+				printf("MII_BMCR: 0x%x\n", reg);
+				return -1;
+			}
+			/* program 4.49155 with 0x5 */
+			octeontx_phy_write(bus, phy_addr, 4, 0xc003, 0x5);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+
+read_error:
+	debug("M88X3120 PHY config read failed\n");
+	return -1;
+}
+
+int octeontx_smi_probe(struct udevice *dev)
+{
+	int ret, subnode, cnt = 0, node = dev->node.of_offset;
+	struct mii_dev *bus;
+	struct octeontx_smi_priv *priv;
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+
+	debug("SMI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+	if (!dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0, PCI_REGION_MEM)) {
+		printf("Failed to map PCI region for bdf %x\n", bdf);
+		return -1;
+	}
+
+	fdt_for_each_subnode(subnode, gd->fdt_blob, node) {
+		ret = fdt_node_check_compatible(gd->fdt_blob, subnode,
+						"cavium,thunder-8890-mdio");
+		if (ret)
+			continue;
+
+		bus = mdio_alloc();
+		priv = malloc(sizeof(*priv));
+		if (!bus || !priv) {
+			printf("Failed to allocate OcteonTX MDIO bus # %u\n",
+			       dev->seq);
+			return -1;
+		}
+
+		bus->read = octeontx_phy_read;
+		bus->write = octeontx_phy_write;
+		bus->reset = octeontx_smi_reset;
+		bus->priv = priv;
+
+		priv->mode = CLAUSE22;
+		priv->baseaddr = (void __iomem *)fdtdec_get_addr(gd->fdt_blob,
+								 subnode,
+								 "reg");
+		debug("mdio base addr %p\n", priv->baseaddr);
+
+		/* use given name or generate its own unique name */
+		snprintf(bus->name, MDIO_NAME_LEN, "smi%d", cnt++);
+
+		ret = mdio_register(bus);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static const struct udevice_id octeontx_smi_ids[] = {
+	{ .compatible = "cavium,thunder-8890-mdio-nexus" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_smi) = {
+	.name	= "octeontx_smi",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_smi_probe,
+	.of_match = octeontx_smi_ids,
+};
+
+static struct pci_device_id octeontx_smi_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_SMI) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_smi, octeontx_smi_supported);
diff --git a/drivers/net/octeontx/xcv.c b/drivers/net/octeontx/xcv.c
new file mode 100644
index 0000000000..1186157485
--- /dev/null
+++ b/drivers/net/octeontx/xcv.c
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <net.h>
+#include <dm.h>
+#include <pci.h>
+#include <misc.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_OF_LIBFDT
+ #include <linux/libfdt.h>
+ #include <fdt_support.h>
+#endif
+
+#include <asm/arch/csrs/csrs-xcv.h>
+
+#define XCVX_BASE		0x87E0DB000000ULL
+
+/* Initialize XCV block */
+void xcv_init_hw(void)
+{
+	union xcvx_reset reset;
+	union xcvx_dll_ctl xcv_dll_ctl;
+
+	/* Take the DLL out of reset */
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	reset.s.dllrst = 0;
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+
+	/* Take the clock tree out of reset */
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	reset.s.clkrst = 0;
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+
+	/* Once the 125MHz ref clock is stable, wait 10us for DLL to lock */
+	udelay(10);
+
+	/* Optionally, bypass the DLL setting */
+	xcv_dll_ctl.u = readq(XCVX_BASE + XCVX_DLL_CTL(0));
+	xcv_dll_ctl.s.clkrx_set = 0;
+	xcv_dll_ctl.s.clkrx_byp = 1;
+	xcv_dll_ctl.s.clktx_byp = 0;
+	writeq(xcv_dll_ctl.u, XCVX_BASE + XCVX_DLL_CTL(0));
+
+	/* Enable the compensation controller */
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	reset.s.comp = 1;
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+
+	/* Wait for 1040 reference clock cycles for the compensation state
+	 * machine lock.
+	 */
+	udelay(100);
+
+	/* Enable the XCV block */
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	reset.s.enable = 1;
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+
+	/* set XCV(0)_RESET[CLKRST] to 1 */
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	reset.s.clkrst = 1;
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+}
+
+/*
+ * Configure XCV link based on the speed
+ * link_up   : Set to 1 when link is up otherwise 0
+ * link_speed: The speed of the link.
+ */
+void xcv_setup_link(bool link_up, int link_speed)
+{
+	union xcvx_ctl xcv_ctl;
+	union xcvx_reset reset;
+	union xcvx_batch_crd_ret xcv_crd_ret;
+	int speed = 2;
+
+	/* Check RGMII link */
+	if (link_speed == 100)
+		speed = 1;
+	else if (link_speed == 10)
+		speed = 0;
+
+	if (link_up) {
+		/* Set operating speed */
+		xcv_ctl.u = readq(XCVX_BASE + XCVX_CTL(0));
+		xcv_ctl.s.speed = speed;
+		writeq(xcv_ctl.u, XCVX_BASE + XCVX_CTL(0));
+
+		/* Datapaths come out of reset
+		 * - The datapath resets will disengage BGX from the
+		 *   RGMII interface
+		 * - XCV will continue to return TX credits for each tick
+		 *   that is sent on the TX data path
+		 */
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+		reset.s.tx_dat_rst_n = 1;
+		reset.s.rx_dat_rst_n = 1;
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+
+		/* Enable packet flow */
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+		reset.s.tx_pkt_rst_n = 1;
+		reset.s.rx_pkt_rst_n = 1;
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+
+		xcv_crd_ret.u = readq(XCVX_BASE + XCVX_BATCH_CRD_RET(0));
+		xcv_crd_ret.s.crd_ret = 1;
+		writeq(xcv_crd_ret.u, XCVX_BASE + XCVX_BATCH_CRD_RET(0));
+	} else {
+		/* Enable packet flow */
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+		reset.s.tx_pkt_rst_n = 0;
+		reset.s.rx_pkt_rst_n = 0;
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
+	}
+}
diff --git a/drivers/net/octeontx2/Makefile b/drivers/net/octeontx2/Makefile
new file mode 100644
index 0000000000..bfe4a0c328
--- /dev/null
+++ b/drivers/net/octeontx2/Makefile
@@ -0,0 +1,10 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+
+obj-$(CONFIG_NET_OCTEONTX2) += cgx.o nix_af.o nix.o rvu_pf.o \
+				rvu_af.o rvu_common.o
diff --git a/drivers/net/octeontx2/cgx.c b/drivers/net/octeontx2/cgx.c
new file mode 100644
index 0000000000..d25fc8c16c
--- /dev/null
+++ b/drivers/net/octeontx2/cgx.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/arch/board.h>
+#include <asm/arch/csrs/csrs-cgx.h>
+#include "cgx.h"
+
+char lmac_type_to_str[][8] = {
+	"SGMII",
+	"XAUI",
+	"RXAUI",
+	"10G_R",
+	"40G_R",
+	"RGMII",
+	"QSGMII",
+	"25G_R",
+	"50G_R",
+	"100G_R",
+	"USXGMII",
+};
+
+char lmac_speed_to_str[][8] = {
+	"0",
+	"10M",
+	"100M",
+	"1G",
+	"2.5G",
+	"5G",
+	"10G",
+	"20G",
+	"25G",
+	"40G",
+	"50G",
+	"80G",
+	"100G",
+};
+
+/**
+ * Given an LMAC/PF instance number, return the lmac
+ * Per design, each PF has only one LMAC mapped.
+ *
+ * @param instance	instance to find
+ *
+ * @return	pointer to lmac data structure or NULL if not found
+ */
+struct lmac *nix_get_cgx_lmac(int lmac_instance)
+{
+	struct cgx *cgx;
+	struct udevice *dev;
+	int i, idx, err;
+
+	for (i = 0; i < CGX_PER_NODE; i++) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM,
+					 PCI_DEVICE_ID_OCTEONTX2_CGX, i,
+					 &dev);
+		if (err)
+			continue;
+
+		cgx = dev_get_priv(dev);
+		debug("%s udev %p cgx %p instance %d\n", __func__, dev, cgx,
+		      lmac_instance);
+		for (idx = 0; idx < cgx->lmac_count; idx++) {
+			if (cgx->lmac[idx]->instance == lmac_instance)
+				return cgx->lmac[idx];
+		}
+	}
+	return NULL;
+}
+
+void cgx_lmac_mac_filter_clear(struct lmac *lmac)
+{
+	union cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
+	void *reg_addr;
+
+	dmac_cam0.u = 0x0;
+	reg_addr = lmac->cgx->reg_base +
+			CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+	writeq(dmac_cam0.u, reg_addr);
+	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
+
+	dmac_ctl0.u = 0x0;
+	dmac_ctl0.s.bcst_accept = 1;
+	dmac_ctl0.s.mcst_mode = 1;
+	dmac_ctl0.s.cam_accept = 0;
+	reg_addr = lmac->cgx->reg_base +
+			CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+	writeq(dmac_ctl0.u, reg_addr);
+	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
+}
+
+void cgx_lmac_mac_filter_setup(struct lmac *lmac)
+{
+	union cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
+	u64 mac, tmp;
+	void *reg_addr;
+
+	memcpy((void *)&tmp, lmac->mac_addr, 6);
+	debug("%s: tmp %llx\n", __func__, tmp);
+	debug("%s: swab tmp %llx\n", __func__, swab64(tmp));
+	mac = swab64(tmp) >> 16;
+	debug("%s: mac %llx\n", __func__, mac);
+	dmac_cam0.u = 0x0;
+	dmac_cam0.s.id = lmac->lmac_id;
+	dmac_cam0.s.adr = mac;
+	dmac_cam0.s.en = 1;
+	reg_addr = lmac->cgx->reg_base +
+			CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+	writeq(dmac_cam0.u, reg_addr);
+	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
+	dmac_ctl0.u = 0x0;
+	dmac_ctl0.s.bcst_accept = 1;
+	dmac_ctl0.s.mcst_mode = 0;
+	dmac_ctl0.s.cam_accept = 1;
+	reg_addr = lmac->cgx->reg_base +
+			CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+	writeq(dmac_ctl0.u, reg_addr);
+	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
+}
+
+int cgx_lmac_set_pkind(struct lmac *lmac, u8 lmac_id, int pkind)
+{
+	cgx_write(lmac->cgx, lmac_id, CGXX_CMRX_RX_ID_MAP(0),
+		  (pkind & 0x3f));
+	return 0;
+}
+
+int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status)
+{
+	int ret = 0;
+
+	ret = cgx_intf_get_link_sts(lmac->cgx->cgx_id, lmac_id, status);
+	if (ret) {
+		debug("%s request failed for cgx%d lmac%d\n",
+		      __func__, lmac->cgx->cgx_id, lmac->lmac_id);
+		ret = -1;
+	}
+	return ret;
+}
+
+int cgx_lmac_rx_tx_enable(struct lmac *lmac, int lmac_id, bool enable)
+{
+	struct cgx *cgx = lmac->cgx;
+	union cgxx_cmrx_config cmrx_config;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	cmrx_config.u = cgx_read(cgx, lmac_id, CGXX_CMRX_CONFIG(0));
+	cmrx_config.s.data_pkt_rx_en =
+	cmrx_config.s.data_pkt_tx_en = enable ? 1 : 0;
+	cgx_write(cgx, lmac_id, CGXX_CMRX_CONFIG(0), cmrx_config.u);
+	return 0;
+}
+
+int cgx_lmac_link_enable(struct lmac *lmac, int lmac_id, bool enable,
+			 u64 *status)
+{
+	int ret = 0;
+
+	ret = cgx_intf_link_up_dwn(lmac->cgx->cgx_id, lmac_id, enable,
+				   status);
+	if (ret) {
+		debug("%s request failed for cgx%d lmac%d\n",
+		      __func__, lmac->cgx->cgx_id, lmac->lmac_id);
+		ret = -1;
+	}
+	return ret;
+}
+
+int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable)
+{
+	struct cgx *cgx = lmac->cgx;
+	union cgxx_cmrx_config cmrx_cfg;
+	union cgxx_gmp_pcs_mrx_control mrx_control;
+	union cgxx_spux_control1 spux_control1;
+	enum lmac_type lmac_type;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	cmrx_cfg.u = cgx_read(cgx, lmac_id, CGXX_CMRX_CONFIG(0));
+	lmac_type = cmrx_cfg.s.lmac_type;
+	if (lmac_type == LMAC_MODE_SGMII || lmac_type == LMAC_MODE_QSGMII) {
+		mrx_control.u = cgx_read(cgx, lmac_id,
+					 CGXX_GMP_PCS_MRX_CONTROL(0));
+		mrx_control.s.loopbck1 = enable ? 1 : 0;
+		cgx_write(cgx, lmac_id, CGXX_GMP_PCS_MRX_CONTROL(0),
+			  mrx_control.u);
+	} else {
+		spux_control1.u = cgx_read(cgx, lmac_id,
+					   CGXX_SPUX_CONTROL1(0));
+		spux_control1.s.loopbck = enable ? 1 : 0;
+		cgx_write(cgx, lmac_id, CGXX_SPUX_CONTROL1(0),
+			  spux_control1.u);
+	}
+	return 0;
+}
+
+static int cgx_lmac_init(struct cgx *cgx)
+{
+	struct lmac *lmac;
+	union cgxx_cmrx_config cmrx_cfg;
+	static int instance = 1;
+	int i;
+
+	cgx->lmac_count = cgx_read(cgx, 0, CGXX_CMR_RX_LMACS());
+	debug("%s: Found %d lmacs for cgx %d@%p\n", __func__, cgx->lmac_count,
+	      cgx->cgx_id, cgx->reg_base);
+
+	for (i = 0; i < cgx->lmac_count; i++) {
+		lmac = calloc(1, sizeof(*lmac));
+		if (!lmac)
+			return -ENOMEM;
+		lmac->instance = instance++;
+		snprintf(lmac->name, sizeof(lmac->name), "cgx_fwi_%d_%d",
+			 cgx->cgx_id, i);
+		/* Get LMAC type */
+		cmrx_cfg.u = cgx_read(cgx, i, CGXX_CMRX_CONFIG(0));
+		lmac->lmac_type = cmrx_cfg.s.lmac_type;
+		lmac->p2x_sel = cmrx_cfg.s.p2x_select;
+
+		lmac->lmac_id = i;
+		lmac->cgx = cgx;
+		cgx->lmac[i] = lmac;
+		debug("%s: map id %d to lmac %p (%s), type:%d instance %d\n",
+		      __func__, i, lmac, lmac->name, lmac->lmac_type,
+		      lmac->instance);
+		lmac->init_pend = 1;
+		printf("CGX%d LMAC%d [%s]\n", lmac->cgx->cgx_id,
+		       lmac->lmac_id, lmac_type_to_str[lmac->lmac_type]);
+		octeontx2_board_get_mac_addr((lmac->instance - 1),
+					     lmac->mac_addr);
+		debug("%s: MAC %pM\n", __func__, lmac->mac_addr);
+		cgx_lmac_mac_filter_setup(lmac);
+	}
+	return 0;
+}
+
+int cgx_probe(struct udevice *dev)
+{
+	struct cgx *cgx = dev_get_priv(dev);
+	int err;
+
+	cgx->reg_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+				       PCI_REGION_MEM);
+	cgx->dev = dev;
+	cgx->cgx_id = ((u64)(cgx->reg_base) >> 24) & 0x7;
+
+	debug("%s CGX BAR %p, id: %d\n", __func__, cgx->reg_base,
+	      cgx->cgx_id);
+	debug("%s CGX %p, udev: %p\n", __func__, cgx, dev);
+
+	err = cgx_lmac_init(cgx);
+
+	return err;
+}
+
+int cgx_remove(struct udevice *dev)
+{
+	struct cgx *cgx = dev_get_priv(dev);
+	int i;
+
+	debug("%s: cgx remove reg_base %p cgx_id %d",
+	      __func__, cgx->reg_base, cgx->cgx_id);
+	for (i = 0; i < cgx->lmac_count; i++)
+		cgx_lmac_mac_filter_clear(cgx->lmac[i]);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(cgx) = {
+	.name	= "cgx",
+	.id	= UCLASS_MISC,
+	.probe	= cgx_probe,
+	.remove	= cgx_remove,
+	.priv_auto_alloc_size = sizeof(struct cgx),
+};
+
+static struct pci_device_id cgx_supported[] = {
+	{PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX2_CGX) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(cgx, cgx_supported);
diff --git a/drivers/net/octeontx2/cgx.h b/drivers/net/octeontx2/cgx.h
new file mode 100644
index 0000000000..e1b80abe86
--- /dev/null
+++ b/drivers/net/octeontx2/cgx.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __CGX_H__
+#define __CGX_H__
+
+#include "cgx_intf.h"
+
+#define PCI_DEVICE_ID_OCTEONTX2_CGX	0xA059
+
+#define MAX_LMAC_PER_CGX		4
+#define CGX_PER_NODE			5
+
+enum lmac_type {
+	LMAC_MODE_SGMII		= 0,
+	LMAC_MODE_XAUI		= 1,
+	LMAC_MODE_RXAUI		= 2,
+	LMAC_MODE_10G_R		= 3,
+	LMAC_MODE_40G_R		= 4,
+	LMAC_MODE_QSGMII	= 6,
+	LMAC_MODE_25G_R		= 7,
+	LMAC_MODE_50G_R		= 8,
+	LMAC_MODE_100G_R	= 9,
+	LMAC_MODE_USXGMII	= 10,
+};
+
+enum p2x_select {
+	P2X1_NIX0 = 1,
+	P2X2_NIX1 = 2,
+};
+
+extern char lmac_type_to_str[][8];
+
+extern char lmac_speed_to_str[][8];
+
+struct lmac_priv {
+	u8 enable:1;
+	u8 full_duplex:1;
+	u8 speed:4;
+	u8 mode:1;
+	u8 rsvd:1;
+	u8 mac_addr[6];
+};
+
+struct cgx;
+struct nix;
+struct nix_af;
+
+struct lmac {
+	struct cgx	*cgx;
+	struct nix	*nix;
+	char		name[16];
+	enum lmac_type	lmac_type;
+	enum p2x_select p2x_sel;
+	bool		init_pend;
+	u8		instance;
+	u8		lmac_id;
+	u8		pknd;
+	u8		link_num;
+	u32		chan_num;
+	u8		mac_addr[6];
+};
+
+struct cgx {
+	struct nix_af		*nix_af;
+	void __iomem		*reg_base;
+	struct udevice		*dev;
+	struct lmac		*lmac[MAX_LMAC_PER_CGX];
+	u8			cgx_id;
+	u8			lmac_count;
+};
+
+static inline void cgx_write(struct cgx *cgx, u8 lmac, u64 offset, u64 val)
+{
+	writeq(val, cgx->reg_base + CMR_SHIFT(lmac) + offset);
+}
+
+static inline u64 cgx_read(struct cgx *cgx, u8 lmac, u64 offset)
+{
+	return readq(cgx->reg_base + CMR_SHIFT(lmac) + offset);
+}
+
+/**
+ * Given an LMAC/PF instance number, return the lmac
+ * Per design, each PF has only one LMAC mapped.
+ *
+ * @param instance	instance to find
+ *
+ * @return	pointer to lmac data structure or NULL if not found
+ */
+struct lmac *nix_get_cgx_lmac(int lmac_instance);
+
+int cgx_lmac_set_pkind(struct lmac *lmac, u8 lmac_id, int pkind);
+int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable);
+int cgx_lmac_rx_tx_enable(struct lmac *lmac, int lmac_id, bool enable);
+int cgx_lmac_link_enable(struct lmac *lmac, int lmac_id, bool enable,
+			 u64 *status);
+int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status);
+void cgx_lmac_mac_filter_setup(struct lmac *lmac);
+
+int cgx_intf_get_link_sts(u8 cgx, u8 lmac, u64 *lnk_sts);
+int cgx_intf_link_up_dwn(u8 cgx, u8 lmac, u8 up_dwn, u64 *lnk_sts);
+int cgx_intf_get_mac_addr(u8 cgx, u8 lmac, u8 *mac);
+int cgx_intf_set_macaddr(struct udevice *dev);
+int cgx_intf_prbs(u8 qlm, u8 mode, u32 time, u8 lane);
+int cgx_intf_display_eye(u8 qlm, u8 lane);
+int cgx_intf_display_serdes(u8 qlm, u8 lane);
+
+#endif /* __CGX_H__ */
diff --git a/drivers/net/octeontx2/cgx_intf.c b/drivers/net/octeontx2/cgx_intf.c
new file mode 100644
index 0000000000..dac437770d
--- /dev/null
+++ b/drivers/net/octeontx2/cgx_intf.c
@@ -0,0 +1,714 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/arch/board.h>
+
+#include "cgx_intf.h"
+#include "cgx.h"
+#include "nix.h"
+
+static u64 cgx_rd_scrx(u8 cgx, u8 lmac, u8 index)
+{
+	u64 addr;
+
+	addr = (index == 1) ? CGX_CMR_SCRATCH1 : CGX_CMR_SCRATCH0;
+	addr += CGX_SHIFT(cgx) + CMR_SHIFT(lmac);
+	return readq(addr);
+}
+
+static void cgx_wr_scrx(u8 cgx, u8 lmac, u8 index, u64 val)
+{
+	u64 addr;
+
+	addr = (index == 1) ? CGX_CMR_SCRATCH1 : CGX_CMR_SCRATCH0;
+	addr += CGX_SHIFT(cgx) + CMR_SHIFT(lmac);
+	writeq(val, addr);
+}
+
+static u64 cgx_rd_scr0(u8 cgx, u8 lmac)
+{
+	return cgx_rd_scrx(cgx, lmac, 0);
+}
+
+static u64 cgx_rd_scr1(u8 cgx, u8 lmac)
+{
+	return cgx_rd_scrx(cgx, lmac, 1);
+}
+
+static void cgx_wr_scr0(u8 cgx, u8 lmac, u64 val)
+{
+	return cgx_wr_scrx(cgx, lmac, 0, val);
+}
+
+static void cgx_wr_scr1(u8 cgx, u8 lmac, u64 val)
+{
+	return cgx_wr_scrx(cgx, lmac, 1, val);
+}
+
+static inline void set_ownership(u8 cgx, u8 lmac, u8 val)
+{
+	union cgx_scratchx1 scr1;
+
+	scr1.u = cgx_rd_scr1(cgx, lmac);
+	scr1.s.own_status = val;
+	cgx_wr_scr1(cgx, lmac, scr1.u);
+}
+
+static int wait_for_ownership(u8 cgx, u8 lmac)
+{
+	union cgx_scratchx1 scr1;
+	union cgx_scratchx0 scr0;
+	u64 cmrx_int;
+	int timeout = 5000;
+
+	do {
+		scr1.u = cgx_rd_scr1(cgx, lmac);
+		scr0.u = cgx_rd_scr0(cgx, lmac);
+		/* clear async events if any */
+		if (scr0.s.evt_sts.evt_type == CGX_EVT_ASYNC &&
+		    scr0.s.evt_sts.ack) {
+			/* clear interrupt */
+			cmrx_int = readq(CGX_CMR_INT +
+					 CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+			cmrx_int |= 0x2; // Overflw bit
+			writeq(cmrx_int, CGX_CMR_INT +
+					 CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+
+			/* clear ack */
+			scr0.s.evt_sts.ack = 0;
+			cgx_wr_scr0(cgx, lmac, scr0.u);
+		}
+
+		if (timeout-- < 0) {
+			debug("timeout waiting for ownership\n");
+			return -ETIMEDOUT;
+		}
+		mdelay(1);
+	} while ((scr1.s.own_status == CGX_OWN_FIRMWARE) &&
+		  scr0.s.evt_sts.ack);
+
+	return 0;
+}
+
+int cgx_intf_req(u8 cgx, u8 lmac, union cgx_cmd_s cmd_args, u64 *rsp,
+		 int use_cmd_id_only)
+{
+	union cgx_scratchx1 scr1;
+	union cgx_scratchx0 scr0;
+	u64 cmrx_int;
+	int timeout = 500;
+	int err = 0;
+	u8 cmd = cmd_args.cmd.id;
+
+	if (wait_for_ownership(cgx, lmac)) {
+		err = -ETIMEDOUT;
+		goto error;
+	}
+
+	/* send command */
+	scr1.u = cgx_rd_scr1(cgx, lmac);
+
+	if (use_cmd_id_only) {
+		scr1.s.cmd.id = cmd;
+	} else {
+		cmd_args.own_status = scr1.s.own_status;
+		scr1.s = cmd_args;
+	}
+	cgx_wr_scr1(cgx, lmac, scr1.u);
+
+	set_ownership(cgx, lmac, CGX_OWN_FIRMWARE);
+
+	/* wait for response and ownership */
+	do {
+		scr0.u = cgx_rd_scr0(cgx, lmac);
+		scr1.u = cgx_rd_scr1(cgx, lmac);
+		mdelay(10);
+	} while (timeout-- && (!scr0.s.evt_sts.ack) &&
+		 (scr1.s.own_status == CGX_OWN_FIRMWARE));
+	if (timeout < 0) {
+		debug("%s timeout waiting for ack\n", __func__);
+		err = -ETIMEDOUT;
+		goto error;
+	}
+
+	if (cmd == CGX_CMD_INTF_SHUTDOWN)
+		goto error;
+
+	if (scr0.s.evt_sts.evt_type != CGX_EVT_CMD_RESP) {
+		debug("%s received async event instead of cmd resp event\n",
+		      __func__);
+		err = -1;
+		goto error;
+	}
+	if (scr0.s.evt_sts.id != cmd) {
+		debug("%s received resp for cmd %d expected cmd %d\n",
+		      __func__, scr0.s.evt_sts.id, cmd);
+		err = -1;
+		goto error;
+	}
+	if (scr0.s.evt_sts.stat != CGX_STAT_SUCCESS) {
+		debug("%s cmd%d failed on cgx%u lmac%u with errcode %d\n",
+		      __func__, cmd, cgx, lmac, scr0.s.link_sts.err_type);
+		err = -1;
+	}
+
+error:
+	/* clear interrupt */
+	cmrx_int = readq(CGX_CMR_INT + CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+	cmrx_int |= 0x2; // Overflw bit
+	writeq(cmrx_int, CGX_CMR_INT + CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+
+	/* clear ownership and ack */
+	scr0.s.evt_sts.ack = 0;
+	cgx_wr_scr0(cgx, lmac, scr0.u);
+
+	*rsp = err ? 0 : scr0.u;
+
+	return err;
+}
+
+int cgx_intf_get_mac_addr(u8 cgx, u8 lmac, u8 *mac)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_MAC_ADDR;
+
+	ret = cgx_intf_req(cgx, lmac, cmd, &scr0.u, 1);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	memcpy(mac, &scr0.u, 6);
+
+	return 0;
+}
+
+int cgx_intf_get_ver(u8 cgx, u8 lmac, u8 *ver)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_FW_VER;
+
+	ret = cgx_intf_req(cgx, lmac, cmd, &scr0.u, 1);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	*ver = scr0.u & 0xFFFF;
+
+	return 0;
+}
+
+int cgx_intf_get_link_sts(u8 cgx, u8 lmac, u64 *lnk_sts)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_LINK_STS;
+
+	ret = cgx_intf_req(cgx, lmac, cmd, &scr0.u, 1);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	/* pass the same format as cgx_lnk_sts_s
+	 * err_type:10, speed:4, full_duplex:1, link_up:1
+	 */
+	*lnk_sts = scr0.u & 0xFFFF;
+	return 0;
+}
+
+int cgx_intf_link_up_dwn(u8 cgx, u8 lmac, u8 up_dwn, u64 *lnk_sts)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = up_dwn ? CGX_CMD_LINK_BRING_UP : CGX_CMD_LINK_BRING_DOWN;
+
+	ret = cgx_intf_req(cgx, lmac, cmd, &scr0.u, 1);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	/* pass the same format as cgx_lnk_sts_s
+	 * err_type:10, speed:4, full_duplex:1, link_up:1
+	 */
+	*lnk_sts = scr0.u & 0xFFFF;
+	return 0;
+}
+
+void cgx_intf_shutdown(void)
+{
+	union cgx_scratchx0 scr0;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_INTF_SHUTDOWN;
+
+	cgx_intf_req(0, 0, cmd, &scr0.u, 1);
+}
+
+int cgx_intf_prbs(u8 qlm, u8 mode, u32 time, u8 lane)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_PRBS;
+
+	cmd.prbs_args.qlm = qlm;
+	cmd.prbs_args.mode = mode;
+	cmd.prbs_args.time = time;
+	cmd.prbs_args.lane = lane;
+
+	ret = cgx_intf_req(0, 0, cmd, &scr0.u, 0);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+enum cgx_mode {
+	MODE_10G_C2C,
+	MODE_10G_C2M,
+	MODE_10G_KR,
+	MODE_25G_C2C,
+	MODE_25G_2_C2C,
+	MODE_50G_C2C,
+	MODE_50G_4_C2C
+};
+
+static char intf_speed_to_str[][8] = {
+	"10M",
+	"100M",
+	"1G",
+	"2.5G",
+	"5G",
+	"10G",
+	"20G",
+	"25G",
+	"40G",
+	"50G",
+	"80G",
+	"100G",
+};
+
+static void mode_to_args(int mode, struct cgx_mode_change_args *args)
+{
+	args->an = 0;
+	args->duplex = 0;
+	args->port = 0;
+
+	switch (mode) {
+	case MODE_10G_C2C:
+		args->speed = CGX_LINK_10G;
+		args->mode = BIT_ULL(CGX_MODE_10G_C2C_BIT);
+		break;
+	case MODE_10G_C2M:
+		args->speed = CGX_LINK_10G;
+		args->mode = BIT_ULL(CGX_MODE_10G_C2M_BIT);
+		break;
+	case MODE_10G_KR:
+		args->speed = CGX_LINK_10G;
+		args->mode = BIT_ULL(CGX_MODE_10G_KR_BIT);
+		args->an = 1;
+		break;
+	case MODE_25G_C2C:
+		args->speed = CGX_LINK_25G;
+		args->mode = BIT_ULL(CGX_MODE_25G_C2C_BIT);
+		break;
+	case MODE_25G_2_C2C:
+		args->speed = CGX_LINK_25G;
+		args->mode = BIT_ULL(CGX_MODE_25G_2_C2C_BIT);
+		break;
+	case MODE_50G_C2C:
+		args->speed = CGX_LINK_50G;
+		args->mode = BIT_ULL(CGX_MODE_50G_C2C_BIT);
+		break;
+	case MODE_50G_4_C2C:
+		args->speed = CGX_LINK_50G;
+		args->mode = BIT_ULL(CGX_MODE_50G_4_C2C_BIT);
+	}
+}
+
+int cgx_intf_set_mode(struct udevice *ethdev, int mode)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_MODE_CHANGE;
+
+	mode_to_args(mode, &cmd.mode_change_args);
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 0);
+	if (ret) {
+		printf("Mode change command failed for %s\n", ethdev->name);
+		return -1;
+	}
+
+	cmd.cmd.id = CGX_CMD_GET_LINK_STS;
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 1);
+	if (ret) {
+		printf("Get Link Status failed for %s\n", ethdev->name);
+		return -1;
+	}
+
+	printf("Current Link Status: ");
+	if (scr0.s.link_sts.speed) {
+		printf("%s\n", intf_speed_to_str[scr0.s.link_sts.speed]);
+		switch (scr0.s.link_sts.fec) {
+		case 0:
+			printf("FEC_NONE\n");
+			break;
+		case 1:
+			printf("FEC_BASE_R\n");
+			break;
+		case 2:
+			printf("FEC_RS\n");
+			break;
+		}
+		printf("Auto Negotiation %sabled\n",
+		       scr0.s.link_sts.an ? "En" : "Dis");
+		printf("%s Duplex\n",
+		       scr0.s.link_sts.full_duplex ? "Full" : "Half");
+	} else {
+		printf("Down\n");
+	}
+	return 0;
+}
+
+int cgx_intf_get_mode(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_LINK_STS;
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 1);
+	if (ret) {
+		printf("Get link status failed for %s\n", ethdev->name);
+		return -1;
+	}
+	printf("Current Interface Mode: ");
+	switch (scr0.s.link_sts.mode) {
+	case CGX_MODE_10G_C2C_BIT:
+		printf("10G_C2C\n");
+		break;
+	case CGX_MODE_10G_C2M_BIT:
+		printf("10G_C2M\n");
+		break;
+	case CGX_MODE_10G_KR_BIT:
+		printf("10G_KR\n");
+		break;
+	case CGX_MODE_25G_C2C_BIT:
+		printf("25G_C2C\n");
+		break;
+	case CGX_MODE_25G_2_C2C_BIT:
+		printf("25G_2_C2C\n");
+		break;
+	case CGX_MODE_50G_C2C_BIT:
+		printf("50G_C2C\n");
+		break;
+	case CGX_MODE_50G_4_C2C_BIT:
+		printf("50G_4_C2C\n");
+		break;
+	default:
+		printf("Unknown\n");
+		break;
+	}
+	return 0;
+}
+
+int cgx_intf_get_fec(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_SUPPORTED_FEC;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 1);
+	if (ret) {
+		printf("Get supported FEC failed for %s\n", ethdev->name);
+		return -1;
+	}
+
+	printf("Supported FEC type: ");
+	switch (scr0.s.supported_fec.fec) {
+	case 0:
+		printf("FEC_NONE\n");
+		break;
+	case 1:
+		printf("FEC_BASE_R\n");
+		break;
+	case 2:
+		printf("FEC_RS\n");
+		break;
+	case 3:
+		printf("FEC_BASE_R FEC_RS\n");
+		break;
+	}
+
+	cmd.cmd.id = CGX_CMD_GET_LINK_STS;
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 1);
+	if (ret) {
+		printf("Get active fec failed for %s\n", ethdev->name);
+		return -1;
+	}
+	printf("Active FEC type: ");
+	switch (scr0.s.link_sts.fec) {
+	case 0:
+		printf("FEC_NONE\n");
+		break;
+	case 1:
+		printf("FEC_BASE_R\n");
+		break;
+	case 2:
+		printf("FEC_RS\n");
+		break;
+	}
+	return 0;
+}
+
+int cgx_intf_set_fec(struct udevice *ethdev, int type)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_SET_FEC;
+	cmd.fec_args.fec = type;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 0);
+	if (ret) {
+		printf("Set FEC type %d failed for %s\n", type, ethdev->name);
+		return -1;
+	}
+	return 0;
+}
+
+int cgx_intf_get_phy_mod_type(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_GET_PHY_MOD_TYPE;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 1);
+	if (ret) {
+		printf("Get PHYMOD type failed for %s\n", ethdev->name);
+		return -1;
+	}
+	printf("Current phy mod type %s\n",
+	       scr0.s.phy_mod_type.mod ? "PAM4" : "NRZ");
+	return 0;
+}
+
+int cgx_intf_set_phy_mod_type(struct udevice *ethdev, int type)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_SET_PHY_MOD_TYPE;
+	cmd.phy_mod_args.mod = type;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 0);
+	if (ret) {
+		printf("Set PHYMOD type %d failed for %s\n", type,
+		       ethdev->name);
+		return -1;
+	}
+
+	return 0;
+}
+
+int cgx_intf_set_an_lbk(struct udevice *ethdev, int enable)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_AN_LOOPBACK;
+	cmd.cmd_args.enable = enable;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 0);
+	if (ret) {
+		printf("Set AN loopback command failed on %s\n", ethdev->name);
+		return -1;
+	}
+	printf("AN loopback %s for %s\n", enable ? "set" : "clear",
+	       ethdev->name);
+
+	return 0;
+}
+
+int cgx_intf_get_ignore(struct udevice *ethdev, int cgx, int lmac)
+{
+	struct rvu_pf *rvu;
+	struct nix *nix;
+	union cgx_scratchx0 scr0;
+	int ret, cgx_id = cgx, lmac_id = lmac;
+	union cgx_cmd_s cmd;
+
+	if (ethdev) {
+		rvu = dev_get_priv(ethdev);
+		nix = rvu->nix;
+		cgx_id = nix->lmac->cgx->cgx_id;
+		lmac_id = nix->lmac->lmac_id;
+	}
+	cmd.cmd.id = CGX_CMD_GET_PERSIST_IGNORE;
+
+	ret = cgx_intf_req(cgx_id, lmac_id, cmd, &scr0.u, 1);
+	if (ret) {
+		if (ethdev)
+			printf("Get ignore command failed for %s\n",
+			       ethdev->name);
+		else
+			printf("Get ignore command failed for CGX%d LMAC%d\n",
+			       cgx_id, lmac_id);
+		return -1;
+	}
+	if (ethdev)
+		printf("Persist settings %signored for %s\n",
+		       scr0.s.persist.ignore ? "" : "not ", ethdev->name);
+	else
+		printf("Persist settings %signored for CGX%d LMAC%d\n",
+		       scr0.s.persist.ignore ? "" : "not ", cgx_id, lmac_id);
+
+	return 0;
+}
+
+int cgx_intf_set_ignore(struct udevice *ethdev, int cgx, int lmac, int ignore)
+{
+	struct rvu_pf *rvu;
+	struct nix *nix;
+	union cgx_scratchx0 scr0;
+	int ret, cgx_id = cgx, lmac_id = lmac;
+	union cgx_cmd_s cmd;
+
+	if (ethdev) {
+		rvu = dev_get_priv(ethdev);
+		nix = rvu->nix;
+		cgx_id = nix->lmac->cgx->cgx_id;
+		lmac_id = nix->lmac->lmac_id;
+	}
+	cmd.cmd.id = CGX_CMD_SET_PERSIST_IGNORE;
+	cmd.persist_args.ignore = ignore;
+
+	ret = cgx_intf_req(cgx_id, lmac_id, cmd, &scr0.u, 0);
+	if (ret) {
+		if (ethdev)
+			printf("Set ignore command failed for %s\n",
+			       ethdev->name);
+		else
+			printf("Set ignore command failed for CGX%d LMAC%d\n",
+			       cgx_id, lmac_id);
+		return -1;
+	}
+
+	return 0;
+}
+
+int cgx_intf_set_macaddr(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+	u64 mac, tmp;
+
+	memcpy((void *)&tmp, nix->lmac->mac_addr, 6);
+	mac = swab64(tmp) >> 16;
+	cmd.cmd.id = CGX_CMD_SET_MAC_ADDR;
+	cmd.mac_args.addr = mac;
+	cmd.mac_args.pf_id = rvu->pfid;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   cmd, &scr0.u, 0);
+	if (ret) {
+		printf("Set user mac addr failed for %s\n", ethdev->name);
+		return -1;
+	}
+
+	return 0;
+}
+
+int cgx_intf_display_eye(u8 qlm, u8 lane)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_DISPLAY_EYE;
+
+	cmd.dsp_eye_args.qlm = qlm;
+	cmd.dsp_eye_args.lane = lane;
+
+	ret = cgx_intf_req(0, 0, cmd, &scr0.u, 0);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+int cgx_intf_display_serdes(u8 qlm, u8 lane)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	union cgx_cmd_s cmd;
+
+	cmd.cmd.id = CGX_CMD_DISPLAY_SERDES;
+
+	cmd.dsp_eye_args.qlm = qlm;
+	cmd.dsp_eye_args.lane = lane;
+
+	ret = cgx_intf_req(0, 0, cmd, &scr0.u, 0);
+	if (ret)
+		return -1;
+
+	return 0;
+}
diff --git a/drivers/net/octeontx2/cgx_intf.h b/drivers/net/octeontx2/cgx_intf.h
new file mode 100644
index 0000000000..0b2bf696fe
--- /dev/null
+++ b/drivers/net/octeontx2/cgx_intf.h
@@ -0,0 +1,450 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __CGX_INTF_H__
+#define __CGX_INTF_H__
+
+#define CGX_FIRMWARE_MAJOR_VER		1
+#define CGX_FIRMWARE_MINOR_VER		0
+
+/* Register offsets */
+#define CGX_CMR_INT		0x87e0e0000040
+#define CGX_CMR_SCRATCH0	0x87e0e0001050
+#define CGX_CMR_SCRATCH1	0x87e0e0001058
+
+#define CGX_SHIFT(x)		(0x1000000 * ((x) & 0x3))
+#define CMR_SHIFT(x)		(0x40000 * ((x) & 0x3))
+
+/* CGX error types. set for cmd response status as CGX_STAT_FAIL */
+enum cgx_error_type {
+	CGX_ERR_NONE,
+	CGX_ERR_LMAC_NOT_ENABLED,
+	CGX_ERR_LMAC_MODE_INVALID,
+	CGX_ERR_REQUEST_ID_INVALID,
+	CGX_ERR_PREV_ACK_NOT_CLEAR,
+	CGX_ERR_PHY_LINK_DOWN,
+	CGX_ERR_PCS_RESET_FAIL,
+	CGX_ERR_AN_CPT_FAIL,
+	CGX_ERR_TX_NOT_IDLE,
+	CGX_ERR_RX_NOT_IDLE,
+	CGX_ERR_SPUX_BR_BLKLOCK_FAIL,
+	CGX_ERR_SPUX_RX_ALIGN_FAIL,
+	CGX_ERR_SPUX_TX_FAULT,
+	CGX_ERR_SPUX_RX_FAULT,
+	CGX_ERR_SPUX_RESET_FAIL,
+	CGX_ERR_SPUX_AN_RESET_FAIL,
+	CGX_ERR_SPUX_USX_AN_RESET_FAIL,
+	CGX_ERR_SMUX_RX_LINK_NOT_OK,
+	CGX_ERR_PCS_LINK_FAIL,
+	CGX_ERR_TRAINING_FAIL,
+	CGX_ERR_RX_EQU_FAIL,
+	CGX_ERR_SPUX_BER_FAIL,
+	CGX_ERR_SPUX_RSFEC_ALGN_FAIL,
+	CGX_ERR_SPUX_MARKER_LOCK_FAIL,
+	CGX_ERR_SET_FEC_INVALID,
+	CGX_ERR_SET_FEC_FAIL,
+	CGX_ERR_MODULE_INVALID,
+	CGX_ERR_MODULE_NOT_PRESENT,
+	CGX_ERR_SPEED_CHANGE_INVALID,	/* = 28 */
+	/* FIXME : add more error types when adding support for new modes */
+};
+
+/* LINK speed types */
+enum cgx_link_speed {
+	CGX_LINK_NONE,
+	CGX_LINK_10M,
+	CGX_LINK_100M,
+	CGX_LINK_1G,
+	CGX_LINK_2HG,	/* 2.5 Gbps */
+	CGX_LINK_5G,
+	CGX_LINK_10G,
+	CGX_LINK_20G,
+	CGX_LINK_25G,
+	CGX_LINK_40G,
+	CGX_LINK_50G,
+	CGX_LINK_80G,
+	CGX_LINK_100G,
+	CGX_LINK_MAX,
+};
+
+/* REQUEST ID types. Input to firmware */
+enum cgx_cmd_id {
+	CGX_CMD_NONE = 0,
+	CGX_CMD_GET_FW_VER,
+	CGX_CMD_GET_MAC_ADDR,
+	CGX_CMD_SET_MTU,
+	CGX_CMD_GET_LINK_STS,		/* optional to user */
+	CGX_CMD_LINK_BRING_UP,		/* = 5 */
+	CGX_CMD_LINK_BRING_DOWN,
+	CGX_CMD_INTERNAL_LBK,
+	CGX_CMD_EXTERNAL_LBK,
+	CGX_CMD_HIGIG,
+	CGX_CMD_LINK_STAT_CHANGE,	/* = 10 */
+	CGX_CMD_MODE_CHANGE,		/* hot plug support */
+	CGX_CMD_INTF_SHUTDOWN,
+	CGX_CMD_GET_MKEX_SIZE,
+	CGX_CMD_GET_MKEX_PROFILE,
+	CGX_CMD_GET_FWD_BASE,		/* get base address of shared FW data */
+	CGX_CMD_GET_LINK_MODES,		/* Supported Link Modes */
+	CGX_CMD_SET_LINK_MODE,
+	CGX_CMD_GET_SUPPORTED_FEC,
+	CGX_CMD_SET_FEC,
+	CGX_CMD_GET_AN,			/* = 20 */
+	CGX_CMD_SET_AN,
+	CGX_CMD_GET_ADV_LINK_MODES,
+	CGX_CMD_GET_ADV_FEC,
+	CGX_CMD_GET_PHY_MOD_TYPE, /* line-side modulation type: NRZ or PAM4 */
+	CGX_CMD_SET_PHY_MOD_TYPE,	/* = 25 */
+	CGX_CMD_PRBS,
+	CGX_CMD_DISPLAY_EYE,
+	CGX_CMD_GET_PHY_FEC_STATS,
+	CGX_CMD_DISPLAY_SERDES,
+	CGX_CMD_AN_LOOPBACK,	/* = 30 */
+	CGX_CMD_GET_PERSIST_IGNORE,
+	CGX_CMD_SET_PERSIST_IGNORE,
+	CGX_CMD_SET_MAC_ADDR,
+};
+
+/* async event ids */
+enum cgx_evt_id {
+	CGX_EVT_NONE,
+	CGX_EVT_LINK_CHANGE,
+};
+
+/* event types - cause of interrupt */
+enum cgx_evt_type {
+	CGX_EVT_ASYNC,
+	CGX_EVT_CMD_RESP
+};
+
+enum cgx_stat {
+	CGX_STAT_SUCCESS,
+	CGX_STAT_FAIL
+};
+
+enum cgx_cmd_own {
+	/* default ownership with kernel/uefi/u-boot */
+	CGX_OWN_NON_SECURE_SW,
+	/* set by kernel/uefi/u-boot after posting a new request to ATF */
+	CGX_OWN_FIRMWARE,
+};
+
+/* Supported LINK MODE enums
+ * Each link mode is a bit mask of these
+ * enums which are represented as bits
+ */
+typedef enum {
+	CGX_MODE_SGMII_BIT = 0,
+	CGX_MODE_1000_BASEX_BIT,
+	CGX_MODE_QSGMII_BIT,
+	CGX_MODE_10G_C2C_BIT,
+	CGX_MODE_10G_C2M_BIT,
+	CGX_MODE_10G_KR_BIT,
+	CGX_MODE_20G_C2C_BIT,
+	CGX_MODE_25G_C2C_BIT,
+	CGX_MODE_25G_C2M_BIT,
+	CGX_MODE_25G_2_C2C_BIT,
+	CGX_MODE_25G_CR_BIT,
+	CGX_MODE_25G_KR_BIT,
+	CGX_MODE_40G_C2C_BIT,
+	CGX_MODE_40G_C2M_BIT,
+	CGX_MODE_40G_CR4_BIT,
+	CGX_MODE_40G_KR4_BIT,
+	CGX_MODE_40GAUI_C2C_BIT,
+	CGX_MODE_50G_C2C_BIT,
+	CGX_MODE_50G_C2M_BIT,
+	CGX_MODE_50G_4_C2C_BIT,
+	CGX_MODE_50G_CR_BIT,
+	CGX_MODE_50G_KR_BIT,
+	CGX_MODE_80GAUI_C2C_BIT,
+	CGX_MODE_100G_C2C_BIT,
+	CGX_MODE_100G_C2M_BIT,
+	CGX_MODE_100G_CR4_BIT,
+	CGX_MODE_100G_KR4_BIT,
+	CGX_MODE_MAX_BIT /* = 29 */
+} cgx_mode_t;
+
+/* scratchx(0) CSR used for ATF->non-secure SW communication.
+ * This acts as the status register
+ * Provides details on command ack/status, link status, error details
+ */
+
+/* CAUTION : below structures are placed in order based on the bit positions
+ * For any updates/new bitfields, corresponding structures needs to be updated
+ */
+struct cgx_evt_sts_s {			/* start from bit 0 */
+	u64 ack:1;
+	u64 evt_type:1;		/* cgx_evt_type */
+	u64 stat:1;		/* cgx_stat */
+	u64 id:6;			/* cgx_evt_id/cgx_cmd_id */
+	u64 reserved:55;
+};
+
+/* all the below structures are in the same memory location of SCRATCHX(0)
+ * value can be read/written based on command ID
+ */
+
+/* Resp to command IDs with command status as CGX_STAT_FAIL
+ * Not applicable for commands :
+ *	CGX_CMD_LINK_BRING_UP/DOWN/CGX_EVT_LINK_CHANGE
+ *	check struct cgx_lnk_sts_s comments
+ */
+struct cgx_err_sts_s {			/* start from bit 9 */
+	u64 reserved1:9;
+	u64 type:10;		/* cgx_error_type */
+	u64 reserved2:35;
+};
+
+/* Resp to cmd ID as CGX_CMD_GET_FW_VER with cmd status as CGX_STAT_SUCCESS */
+struct cgx_ver_s {			/* start from bit 9 */
+	u64 reserved1:9;
+	u64 major_ver:4;
+	u64 minor_ver:4;
+	u64 reserved2:47;
+};
+
+/* Resp to cmd ID as CGX_CMD_GET_MAC_ADDR with cmd status as CGX_STAT_SUCCESS
+ * Returns each byte of MAC address in a separate bit field
+ */
+struct cgx_mac_addr_s {			/* start from bit 9 */
+	u64 reserved1:9;
+	u64 addr_0:8;
+	u64 addr_1:8;
+	u64 addr_2:8;
+	u64 addr_3:8;
+	u64 addr_4:8;
+	u64 addr_5:8;
+	u64 reserved2:7;
+};
+
+/* Resp to cmd ID - CGX_CMD_LINK_BRING_UP/DOWN, event ID CGX_EVT_LINK_CHANGE
+ * status can be either CGX_STAT_FAIL or CGX_STAT_SUCCESS
+ * In case of CGX_STAT_FAIL, it indicates CGX configuration failed when
+ * processing link up/down/change command. Both err_type and current link status
+ * will be updated
+ * In case of CGX_STAT_SUCCESS, err_type will be CGX_ERR_NONE and current
+ * link status will be updated
+ */
+struct cgx_lnk_sts_s {
+	u64 reserved1:9;
+	u64 link_up:1;
+	u64 full_duplex:1;
+	u64 speed:4;	/* cgx_link_speed */
+	u64 err_type:10;
+	u64 an:1;		/* Current AN state : enabled/disabled */
+	u64 fec:2;		/* Current FEC type if enabled, if not 0 */
+	u64 port:8;	/* Share the current port info if required */
+	u64 mode:8;	/* cgx_mode_t enum integer value */
+	u64 reserved2:20;
+};
+
+struct sh_fwd_base_s {
+	u64 reserved1:9;
+	u64 addr:55;
+};
+
+struct cgx_link_modes_s {
+	u64 reserved1:9;
+	u64 modes:55;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_ADV_FEC/CGX_CMD_GET_SUPPORTED_FEC
+ * fec : 2 bits
+ * typedef enum cgx_fec_type {
+ *     CGX_FEC_NONE,
+ *     CGX_FEC_BASE_R,
+ *     CGX_FEC_RS
+ * } fec_type_t;
+ */
+struct cgx_fec_types_s {
+	u64 reserved1:9;
+	u64 fec:2;
+	u64 reserved2:53;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_AN */
+struct cgx_get_an_s {
+	u64 reserved1:9;
+	u64 an:1;
+	u64 reserved2:54;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_PHY_MOD_TYPE */
+struct cgx_get_phy_mod_type_s {
+	u64 reserved1:9;
+	u64 mod:1;		/* 0=NRZ, 1=PAM4 */
+	u64 reserved2:54;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_PERSIST_IGNORE */
+struct cgx_get_flash_ignore_s {
+	uint64_t reserved1:9;
+	uint64_t ignore:1;
+	uint64_t reserved2:54;
+};
+
+union cgx_rsp_sts {
+	/* Fixed, applicable for all commands/events */
+	struct cgx_evt_sts_s evt_sts;
+	/* response to CGX_CMD_LINK_BRINGUP/DOWN/LINK_CHANGE */
+	struct cgx_lnk_sts_s link_sts;
+	/* response to CGX_CMD_GET_FW_VER */
+	struct cgx_ver_s ver;
+	/* response to CGX_CMD_GET_MAC_ADDR */
+	struct cgx_mac_addr_s mac_s;
+	/* response to CGX_CMD_GET_FWD_BASE */
+	struct sh_fwd_base_s fwd_base_s;
+	/* response if evt_status = CMD_FAIL */
+	struct cgx_err_sts_s err;
+	/* response to CGX_CMD_GET_SUPPORTED_FEC */
+	struct cgx_fec_types_s supported_fec;
+	/* response to CGX_CMD_GET_LINK_MODES */
+	struct cgx_link_modes_s supported_modes;
+	/* response to CGX_CMD_GET_ADV_LINK_MODES */
+	struct cgx_link_modes_s adv_modes;
+	/* response to CGX_CMD_GET_ADV_FEC */
+	struct cgx_fec_types_s adv_fec;
+	/* response to CGX_CMD_GET_AN */
+	struct cgx_get_an_s an;
+	/* response to CGX_CMD_GET_PHY_MOD_TYPE */
+	struct cgx_get_phy_mod_type_s phy_mod_type;
+	/* response to CGX_CMD_GET_PERSIST_IGNORE */
+	struct cgx_get_flash_ignore_s persist;
+#ifdef NT_FW_CONFIG
+	/* response to CGX_CMD_GET_MKEX_SIZE */
+	struct cgx_mcam_profile_sz_s prfl_sz;
+	/* response to CGX_CMD_GET_MKEX_PROFILE */
+	struct cgx_mcam_profile_addr_s prfl_addr;
+#endif
+};
+
+union cgx_scratchx0 {
+	u64 u;
+	union cgx_rsp_sts s;
+};
+
+/* scratchx(1) CSR used for non-secure SW->ATF communication
+ * This CSR acts as a command register
+ */
+struct cgx_cmd {			/* start from bit 2 */
+	u64 reserved1:2;
+	u64 id:6;			/* cgx_request_id */
+	u64 reserved2:56;
+};
+
+/* all the below structures are in the same memory location of SCRATCHX(1)
+ * corresponding arguments for command Id needs to be updated
+ */
+
+/* Any command using enable/disable as an argument need
+ * to pass the option via this structure.
+ * Ex: Loopback, HiGig...
+ */
+struct cgx_ctl_args {			/* start from bit 8 */
+	u64 reserved1:8;
+	u64 enable:1;
+	u64 reserved2:55;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_MTU */
+struct cgx_mtu_args {
+	u64 reserved1:8;
+	u64 size:16;
+	u64 reserved2:40;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_MODE_CHANGE */
+struct cgx_mode_change_args {
+	uint64_t reserved1:8;
+	uint64_t speed:4; /* cgx_link_speed enum */
+	uint64_t duplex:1; /* 0 - full duplex, 1 - half duplex */
+	uint64_t an:1;	/* 0 - disable AN, 1 - enable AN */
+	uint64_t port:8; /* device port */
+	uint64_t mode:42;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_LINK_CHANGE */
+struct cgx_link_change_args {		/* start from bit 8 */
+	u64 reserved1:8;
+	u64 link_up:1;
+	u64 full_duplex:1;
+	u64 speed:4;		/* cgx_link_speed */
+	u64 reserved2:50;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_LINK_MODE */
+struct cgx_set_mode_args {
+	u64 reserved1:8;
+	u64 mode:56;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_FEC */
+struct cgx_set_fec_args {
+	u64 reserved1:8;
+	u64 fec:2;
+	u64 reserved2:54;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_PHY_MOD_TYPE */
+struct cgx_set_phy_mod_args {
+	u64 reserved1:8;
+	u64 mod:1;		/* 0=NRZ, 1=PAM4 */
+	u64 reserved2:55;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_PERSIST_IGNORE */
+struct cgx_set_flash_ignore_args {
+	uint64_t reserved1:8;
+	uint64_t ignore:1;
+	uint64_t reserved2:55;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_MAC_ADDR */
+struct cgx_mac_addr_args {
+	uint64_t reserved1:8;
+	uint64_t addr:48;
+	uint64_t pf_id:8;
+};
+
+struct cgx_prbs_args {
+	u64 reserved1:8; /* start from bit 8 */
+	u64 lane:8;
+	u64 qlm:8;
+	u64 stop_on_error:1;
+	u64 mode:8;
+	u64 time:31;
+};
+
+struct cgx_display_eye_args {
+	u64 reserved1:8; /* start from bit 8 */
+	u64 qlm:8;
+	u64 lane:47;
+};
+
+union cgx_cmd_s {
+	u64 own_status:2;			/* cgx_cmd_own */
+	struct cgx_cmd cmd;
+	struct cgx_ctl_args cmd_args;
+	struct cgx_mtu_args mtu_size;
+	struct cgx_link_change_args lnk_args; /* Input to CGX_CMD_LINK_CHANGE */
+	struct cgx_set_mode_args mode_args;
+	struct cgx_mode_change_args mode_change_args;
+	struct cgx_set_fec_args fec_args;
+	struct cgx_set_phy_mod_args phy_mod_args;
+	struct cgx_set_flash_ignore_args persist_args;
+	struct cgx_mac_addr_args mac_args;
+	/* any other arg for command id * like : mtu, dmac filtering control */
+	struct cgx_prbs_args prbs_args;
+	struct cgx_display_eye_args dsp_eye_args;
+};
+
+union cgx_scratchx1 {
+	u64 u;
+	union cgx_cmd_s s;
+};
+
+#endif /* __CGX_INTF_H__ */
diff --git a/drivers/net/octeontx2/lmt.h b/drivers/net/octeontx2/lmt.h
new file mode 100644
index 0000000000..97777eab00
--- /dev/null
+++ b/drivers/net/octeontx2/lmt.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/**
+ * Atomically adds a signed value to a 64 bit (aligned) memory location,
+ * and returns previous value.
+ *
+ * This version does not perform 'sync' operations to enforce memory
+ * operations.  This should only be used when there are no memory operation
+ * ordering constraints.  (This should NOT be used for reference counting -
+ * use the standard version instead.)
+ *
+ * @param ptr    address in memory to add incr to
+ * @param incr   amount to increment memory location by (signed)
+ *
+ * @return Value of memory location before increment
+ */
+static inline s64 atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
+{
+	s64 result;
+	/* Atomic add with no ordering */
+	asm volatile("ldadd %x[i], %x[r], [%[b]]"
+		     : [r] "=r" (result), "+m" (*ptr)
+		     : [i] "r" (incr), [b] "r" (ptr)
+		     : "memory");
+	return result;
+}
+
+static inline void lmt_cancel(const struct nix *nix)
+{
+	writeq(0, nix->lmt_base + LMT_LF_LMTCANCEL());
+}
+
+static inline u64 *lmt_store_ptr(struct nix *nix)
+{
+	return (u64 *)((u8 *)(nix->lmt_base) +
+				       LMT_LF_LMTLINEX(0));
+}
+
+static inline s64 lmt_submit(u64 io_address)
+{
+	s64 result = 0;
+
+	asm volatile("ldeor xzr, %x[rf],[%[rs]]"
+			: [rf] "=r"(result) : [rs] "r"(io_address));
+	return result;
+}
diff --git a/drivers/net/octeontx2/nix.c b/drivers/net/octeontx2/nix.c
new file mode 100644
index 0000000000..8d67f3b026
--- /dev/null
+++ b/drivers/net/octeontx2/nix.c
@@ -0,0 +1,831 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/log2.h>
+#include <asm/arch/board.h>
+#include <asm/arch/csrs/csrs-lmt.h>
+#include "nix.h"
+#include "lmt.h"
+#include "cgx.h"
+
+/**
+ * NIX needs a lot of memory areas. Rather than handle all the failure cases,
+ * we'll use a wrapper around alloc that prints an error if a memory
+ * allocation fails.
+ *
+ * @param num_elements
+ *                  Number of elements to allocate
+ * @param elem_size Size of each element
+ * @param msg       Text string to show when allocation fails
+ *
+ * @return A valid memory location or NULL on failure
+ */
+static void *nix_memalloc(int num_elements, size_t elem_size, const char *msg)
+{
+	size_t alloc_size = num_elements * elem_size;
+	void *base = memalign(CONFIG_SYS_CACHELINE_SIZE, alloc_size);
+
+	if (!base)
+		printf("NIX: Mem alloc failed for %s (%d * %zu = %zu bytes)\n",
+		       msg ? msg : __func__, num_elements, elem_size,
+		       alloc_size);
+	else
+		memset(base, 0, alloc_size);
+
+	debug("NIX: Memory alloc for %s (%d * %zu = %zu bytes) at %p\n",
+	      msg ? msg : __func__, num_elements, elem_size, alloc_size, base);
+	return base;
+}
+
+int npc_lf_setup(struct nix *nix)
+{
+	int err;
+
+	err = npc_lf_admin_setup(nix);
+	if (err) {
+		printf("%s: Error setting up npc lf admin\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int npa_setup_pool(struct npa *npa, u32 pool_id,
+			  size_t buffer_size, u32 queue_length, void *buffers[])
+{
+	struct {
+		union npa_lf_aura_op_free0 f0;
+		union npa_lf_aura_op_free1 f1;
+	} aura_descr;
+	int index;
+
+	for (index = 0; index < queue_length; index++) {
+		buffers[index] = memalign(CONFIG_SYS_CACHELINE_SIZE,
+					  buffer_size);
+		if (!buffers[index]) {
+			printf("%s: Out of memory %d, size: %zu\n",
+			       __func__, index, buffer_size);
+			return -ENOMEM;
+		}
+		debug("%s: allocating buffer %d, addr %p size: %zu\n",
+		      __func__, index, buffers[index], buffer_size);
+
+		/* Add the newly obtained pointer to the pool.  128 bit
+		 * writes only.
+		 */
+		aura_descr.f0.s.addr = (u64)buffers[index];
+		aura_descr.f1.u = 0;
+		aura_descr.f1.s.aura = pool_id;
+		st128(npa->npa_base + NPA_LF_AURA_OP_FREE0(),
+		      aura_descr.f0.u, aura_descr.f1.u);
+	}
+
+	return 0;
+}
+
+int npa_lf_setup(struct nix *nix, int npa_lf)
+{
+	struct rvu_pf *rvu = dev_get_priv(nix->dev);
+	struct nix_af *nix_af = nix->nix_af;
+	struct npa *npa;
+	union npa_af_const npa_af_const;
+	union npa_aura_s *aura;
+	union npa_pool_s *pool;
+	union rvu_func_addr_s block_addr;
+	int idx;
+	int stack_page_pointers;
+	int stack_page_bytes;
+	int err;
+
+	npa = (struct npa *)calloc(1, sizeof(struct npa));
+	if (!npa) {
+		printf("%s: out of memory for npa instance\n", __func__);
+		return -ENOMEM;
+	}
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPA;
+	npa->npa_base = rvu->pf_base + block_addr.u;
+	npa->npa_af = nix_af->npa_af;
+	npa->lf = npa_lf;
+	nix->npa = npa;
+
+	npa_af_const.u = npa_af_reg_read(npa->npa_af, NPA_AF_CONST());
+	stack_page_pointers = npa_af_const.s.stack_page_ptrs;
+	stack_page_bytes = npa_af_const.s.stack_page_bytes;
+
+	npa->stack_pages[NPA_POOL_RX] = (RQ_QLEN + stack_page_pointers - 1) /
+							stack_page_pointers;
+	npa->stack_pages[NPA_POOL_TX] = (SQ_QLEN + stack_page_pointers - 1) /
+							stack_page_pointers;
+	npa->stack_pages[NPA_POOL_SQB] = (SQB_QLEN + stack_page_pointers - 1) /
+							stack_page_pointers;
+	npa->pool_stack_pointers = stack_page_pointers;
+
+	npa->q_len[NPA_POOL_RX] = RQ_QLEN;
+	npa->q_len[NPA_POOL_TX] = SQ_QLEN;
+	npa->q_len[NPA_POOL_SQB] = SQB_QLEN;
+
+	npa->buf_size[NPA_POOL_RX] = MAX_MTU + CONFIG_SYS_CACHELINE_SIZE;
+	npa->buf_size[NPA_POOL_TX] = MAX_MTU + CONFIG_SYS_CACHELINE_SIZE;
+	npa->buf_size[NPA_POOL_SQB] = nix_af->sqb_size;
+
+	npa->aura_ctx = nix_memalloc(NPA_POOL_COUNT,
+				     sizeof(union npa_aura_s),
+				     "aura context");
+	if (!npa->aura_ctx) {
+		printf("%s: Out of memory for aura context\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		npa->pool_ctx[idx] = nix_memalloc(1,
+						  sizeof(union npa_pool_s),
+						  "pool context");
+		if (!npa->pool_ctx[idx]) {
+			printf("%s: Out of memory for pool context\n",
+			       __func__);
+			return -ENOMEM;
+		}
+		npa->pool_stack[idx] = nix_memalloc(npa->stack_pages[idx],
+						    stack_page_bytes,
+						    "pool stack");
+		if (!npa->pool_stack[idx]) {
+			printf("%s: Out of memory for pool stack\n", __func__);
+			return -ENOMEM;
+		}
+	}
+
+	err = npa_lf_admin_setup(npa, npa->lf, (dma_addr_t)npa->aura_ctx);
+	if (err) {
+		printf("%s: Error setting up NPA LF admin for lf %d\n",
+		       __func__, npa->lf);
+		return err;
+	}
+
+	/* Set up the auras */
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		aura = npa->aura_ctx + (idx * sizeof(union npa_aura_s));
+		pool = npa->pool_ctx[idx];
+		debug("%s aura %p pool %p\n", __func__, aura, pool);
+		memset(aura, 0, sizeof(union npa_aura_s));
+		aura->s.fc_ena = 0;
+		aura->s.pool_addr = (u64)npa->pool_ctx[idx];
+		debug("%s aura.s.pool_addr %llx pool_addr %p\n", __func__,
+		      aura->s.pool_addr, npa->pool_ctx[idx]);
+		aura->s.shift = 64 - __builtin_clzll(npa->q_len[idx]) - 8;
+		aura->s.count = npa->q_len[idx];
+		aura->s.limit = npa->q_len[idx];
+		aura->s.ena = 1;
+		err = npa_attach_aura(nix_af, npa->lf, aura, idx);
+		if (err)
+			return err;
+
+		memset(pool, 0, sizeof(*pool));
+		pool->s.fc_ena = 0;
+		pool->s.nat_align = 1;
+		pool->s.stack_base = (u64)(npa->pool_stack[idx]);
+		debug("%s pool.s.stack_base %llx stack_base %p\n", __func__,
+		      pool->s.stack_base, npa->pool_stack[idx]);
+		pool->s.buf_size =
+			npa->buf_size[idx] / CONFIG_SYS_CACHELINE_SIZE;
+		pool->s.stack_max_pages = npa->stack_pages[idx];
+		pool->s.shift =
+			64 - __builtin_clzll(npa->pool_stack_pointers) - 8;
+		pool->s.ptr_start = 0;
+		pool->s.ptr_end = (1ULL << 40) -  1;
+		pool->s.ena = 1;
+		err = npa_attach_pool(nix_af, npa->lf, pool, idx);
+		if (err)
+			return err;
+	}
+
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		npa->buffers[idx] = nix_memalloc(npa->q_len[idx],
+						 sizeof(void *),
+						 "buffers");
+		if (!npa->buffers[idx]) {
+			printf("%s: Out of memory\n", __func__);
+			return -ENOMEM;
+		}
+	}
+
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		err = npa_setup_pool(npa, idx, npa->buf_size[idx],
+				     npa->q_len[idx], npa->buffers[idx]);
+		if (err) {
+			printf("%s: Error setting up pool %d\n",
+			       __func__, idx);
+			return err;
+		}
+	}
+	return 0;
+}
+
+int npa_lf_shutdown(struct nix *nix)
+{
+	struct npa *npa = nix->npa;
+	int err;
+	int pool;
+
+	err = npa_lf_admin_shutdown(nix->nix_af, npa->lf, NPA_POOL_COUNT);
+	if (err) {
+		printf("%s: Error %d shutting down NPA LF admin\n",
+		       __func__, err);
+		return err;
+	}
+	free(npa->aura_ctx);
+	npa->aura_ctx = NULL;
+
+	for (pool = 0; pool < NPA_POOL_COUNT; pool++) {
+		free(npa->pool_ctx[pool]);
+		npa->pool_ctx[pool] = NULL;
+		free(npa->pool_stack[pool]);
+		npa->pool_stack[pool] = NULL;
+		free(npa->buffers[pool]);
+		npa->buffers[pool] = NULL;
+	}
+
+	return 0;
+}
+
+int nix_lf_setup(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	int idx;
+	int err = -1;
+
+	/* Alloc NIX RQ HW context memory */
+	nix->rq_ctx_base = nix_memalloc(nix->rq_cnt, nix_af->rq_ctx_sz,
+					"RQ CTX");
+	if (!nix->rq_ctx_base)
+		goto error;
+	memset(nix->rq_ctx_base, 0, nix_af->rq_ctx_sz);
+
+	/* Alloc NIX SQ HW context memory */
+	nix->sq_ctx_base = nix_memalloc(nix->sq_cnt, nix_af->sq_ctx_sz,
+					"SQ CTX");
+	if (!nix->sq_ctx_base)
+		goto error;
+	memset(nix->sq_ctx_base, 0, nix_af->sq_ctx_sz);
+
+	/* Alloc NIX CQ HW context memory */
+	nix->cq_ctx_base = nix_memalloc(nix->cq_cnt, nix_af->cq_ctx_sz,
+					"CQ CTX");
+	if (!nix->cq_ctx_base)
+		goto error;
+	memset(nix->cq_ctx_base, 0, nix_af->cq_ctx_sz * NIX_CQ_COUNT);
+	/* Alloc NIX CQ Ring memory */
+	for (idx = 0; idx < NIX_CQ_COUNT; idx++) {
+		err = qmem_alloc(&nix->cq[idx], CQ_ENTRIES, CQ_ENTRY_SIZE);
+		if (err)
+			goto error;
+	}
+
+	/* Alloc memory for Qints HW contexts */
+	nix->qint_base = nix_memalloc(nix_af->qints, nix_af->qint_ctx_sz,
+				      "Qint CTX");
+	if (!nix->qint_base)
+		goto error;
+	/* Alloc memory for CQints HW contexts */
+	nix->cint_base = nix_memalloc(nix_af->cints, nix_af->cint_ctx_sz,
+				      "Cint CTX");
+	if (!nix->cint_base)
+		goto error;
+	/* Alloc NIX RSS HW context memory and config the base */
+	nix->rss_base = nix_memalloc(nix->rss_grps, nix_af->rsse_ctx_sz,
+				     "RSS CTX");
+	if (!nix->rss_base)
+		goto error;
+
+	err = nix_lf_admin_setup(nix);
+	if (err) {
+		printf("%s: Error setting up LF\n", __func__);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->sq_ctx_base)
+		free(nix->sq_ctx_base);
+	nix->sq_ctx_base = NULL;
+	if (nix->cq_ctx_base)
+		free(nix->cq_ctx_base);
+	nix->cq_ctx_base = NULL;
+
+	for (idx = 0; idx < NIX_CQ_COUNT; idx++)
+		qmem_free(&nix->cq[idx]);
+
+	return err;
+}
+
+int nix_lf_shutdown(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	int index;
+	int err;
+
+	err = nix_lf_admin_shutdown(nix_af, nix->lf, nix->cq_cnt,
+				    nix->rq_cnt, nix->sq_cnt);
+	if (err) {
+		printf("%s: Error shutting down LF admin\n", __func__);
+		return err;
+	}
+
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->sq_ctx_base)
+		free(nix->sq_ctx_base);
+	nix->sq_ctx_base = NULL;
+	if (nix->cq_ctx_base)
+		free(nix->cq_ctx_base);
+	nix->cq_ctx_base = NULL;
+
+	for (index = 0; index < NIX_CQ_COUNT; index++)
+		qmem_free(&nix->cq[index]);
+
+	debug("%s: nix lf %d reset --\n", __func__, nix->lf);
+	return 0;
+}
+
+struct nix *nix_lf_alloc(struct udevice *dev, int nix_id)
+{
+	union rvu_func_addr_s block_addr;
+	struct nix *nix;
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct rvu_af *rvu_af = dev_get_priv(rvu->afdev);
+	union rvu_pf_func_s pf_func;
+	int err;
+
+	debug("%s(%s )\n", __func__, dev->name);
+
+	nix = (struct nix *)calloc(1, sizeof(*nix));
+	if (!nix) {
+		printf("%s: Out of memory for nix instance\n", __func__);
+		return NULL;
+	}
+	nix->nix_af = rvu_af->nix_af[nix_id];
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NIXX(nix_id);
+	nix->nix_base = rvu->pf_base + block_addr.u;
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPC;
+	nix->npc_base = rvu->pf_base + block_addr.u;
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_LMT;
+	nix->lmt_base = rvu->pf_base + block_addr.u;
+
+	pf_func.u = 0;
+	pf_func.s.pf = rvu->pfid;
+	nix->pf_func = pf_func.u;
+	nix->lf = rvu->nix_lfid;
+	nix->pf = rvu->pfid;
+	nix->dev = dev;
+	nix->sq_cnt = 1;
+	nix->rq_cnt = 1;
+	nix->rss_grps = 1;
+	nix->cq_cnt = 2;
+	nix->xqe_sz = NIX_CQE_SIZE_W16;
+
+	debug("NIX%d lf %d nix_base %p pf_func 0x%x nix_af %p\n", nix_id,
+	      nix->lf, nix->nix_base, nix->pf_func, nix->nix_af);
+
+	nix->lmac = nix_get_cgx_lmac(nix->pf);
+	if (!nix->lmac) {
+		printf("%s: Error: could not find lmac for pf %d\n",
+		       __func__, nix->pf);
+		free(nix);
+		return NULL;
+	}
+	nix->lmac->link_num =
+		NIX_LINK_E_CGXX_LMACX(nix->lmac->cgx->cgx_id,
+				      nix->lmac->lmac_id);
+	nix->lmac->chan_num =
+		NIX_CHAN_E_CGXX_LMACX_CHX(nix->lmac->cgx->cgx_id,
+					  nix->lmac->lmac_id, 0);
+	/* This is rx pkind in 1:1 mapping to NIX_LINK_E */
+	nix->lmac->pknd = nix->lmac->link_num;
+
+	cgx_lmac_set_pkind(nix->lmac, nix->lmac->lmac_id, nix->lmac->pknd);
+	debug("%s(%s CGX%x LMAC%x)\n", __func__, dev->name,
+	      nix->lmac->cgx->cgx_id, nix->lmac->lmac_id);
+	debug("%s(%s Link %x Chan %x Pknd %x)\n", __func__, dev->name,
+	      nix->lmac->link_num, nix->lmac->chan_num,	nix->lmac->pknd);
+
+	err = npa_lf_setup(nix, rvu->npa_lfid);
+	if (err)
+		return NULL;
+
+	err = npc_lf_setup(nix);
+	if (err)
+		return NULL;
+
+	err = nix_lf_setup(nix);
+	if (err)
+		return NULL;
+
+	return nix;
+}
+
+u64 npa_aura_op_alloc(struct npa *npa, u64 aura_id)
+{
+	union npa_lf_aura_op_allocx op_allocx;
+
+	op_allocx.u = atomic_fetch_and_add64_nosync(npa->npa_base +
+			NPA_LF_AURA_OP_ALLOCX(0), aura_id);
+	return op_allocx.s.addr;
+}
+
+u64 nix_cq_op_status(struct nix *nix, u64 cq_id)
+{
+	union nixx_lf_cq_op_status op_status;
+	s64 *reg = nix->nix_base + NIXX_LF_CQ_OP_STATUS();
+
+	op_status.u = atomic_fetch_and_add64_nosync(reg, cq_id << 32);
+	return op_status.u;
+}
+
+/* TX */
+static inline void nix_write_lmt(struct nix *nix, void *buffer,
+				 int num_words)
+{
+	int i;
+
+	u64 *lmt_ptr = lmt_store_ptr(nix);
+	u64 *ptr = buffer;
+
+	debug("%s lmt_ptr %p %p\n", __func__, nix->lmt_base, lmt_ptr);
+	for (i = 0; i < num_words; i++) {
+		debug("%s data %llx lmt_ptr %p\n", __func__, ptr[i],
+		      lmt_ptr + i);
+		lmt_ptr[i] = ptr[i];
+	}
+}
+
+void nix_cqe_tx_pkt_handler(struct nix *nix, void *cqe)
+{
+	union nix_cqe_hdr_s *txcqe = (union nix_cqe_hdr_s *)cqe;
+
+	debug("%s: txcqe: %p\n", __func__, txcqe);
+
+	if (txcqe->s.cqe_type != NIX_XQE_TYPE_E_SEND) {
+		printf("%s: Error: Unsupported CQ header type %d\n",
+		       __func__, txcqe->s.cqe_type);
+		return;
+	}
+	nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
+			 (NIX_CQ_TX << 32) | 1);
+}
+
+void nix_lf_flush_tx(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union nixx_lf_cq_op_status op_status;
+	u32 head, tail;
+	void *cq_tx_base = nix->cq[NIX_CQ_TX].base;
+	union nix_cqe_hdr_s *cqe;
+
+	/* ack tx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_TX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_TX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_TX].qsize - 1);
+
+	debug("%s cq tx head %d tail %d\n", __func__, head, tail);
+	while (head != tail) {
+		cqe = cq_tx_base + head * nix->cq[NIX_CQ_TX].entry_sz;
+		nix_cqe_tx_pkt_handler(nix, cqe);
+		op_status.u = nix_cq_op_status(nix, NIX_CQ_TX);
+		head = op_status.s.head;
+		tail = op_status.s.tail;
+		head &= (nix->cq[NIX_CQ_TX].qsize - 1);
+		tail &= (nix->cq[NIX_CQ_TX].qsize - 1);
+		debug("%s cq tx head %d tail %d\n", __func__, head, tail);
+	}
+}
+
+int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct nix_tx_dr tx_dr;
+	int dr_sz = (sizeof(struct nix_tx_dr) + 15) / 16 - 1;
+	s64 result;
+	void *packet;
+
+	nix_lf_flush_tx(dev);
+	memset((void *)&tx_dr, 0, sizeof(struct nix_tx_dr));
+	/* Dump TX packet in to NPA buffer */
+	packet = (void *)npa_aura_op_alloc(nix->npa, NPA_POOL_TX);
+	if (!packet) {
+		printf("%s TX buffers unavailable\n", __func__);
+		return -1;
+	}
+	memcpy(packet, pkt, pkt_len);
+	debug("%s TX buffer %p\n", __func__, packet);
+
+	tx_dr.hdr.s.aura = NPA_POOL_TX;
+	tx_dr.hdr.s.df = 0;
+	tx_dr.hdr.s.pnc = 1;
+	tx_dr.hdr.s.sq = 0;
+	tx_dr.hdr.s.total = pkt_len;
+	tx_dr.hdr.s.sizem1 = dr_sz - 2; /* FIXME - for now hdr+sg+sg1addr */
+	debug("%s dr_sz %d\n", __func__, dr_sz);
+
+	tx_dr.tx_sg.s.segs = 1;
+	tx_dr.tx_sg.s.subdc = NIX_SUBDC_E_SG;
+	tx_dr.tx_sg.s.seg1_size = pkt_len;
+	tx_dr.tx_sg.s.ld_type = NIX_SENDLDTYPE_E_LDT;
+	tx_dr.sg1_addr = (dma_addr_t)packet;
+
+#define DEBUG_PKT
+#ifdef DEBUG_PKT
+	debug("TX PKT Data\n");
+	for (int i = 0; i < pkt_len; i++) {
+		if (i && (i % 8 == 0))
+			debug("\n");
+		debug("%02x ", *((u8 *)pkt + i));
+	}
+	debug("\n");
+#endif
+	do {
+		nix_write_lmt(nix, &tx_dr, (dr_sz - 1) * 2);
+		__iowmb();
+		result = lmt_submit((u64)(nix->nix_base +
+					       NIXX_LF_OP_SENDX(0)));
+		WATCHDOG_RESET();
+	} while (result == 0);
+
+	return 0;
+}
+
+/* RX */
+void nix_lf_flush_rx(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union nixx_lf_cq_op_status op_status;
+	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
+	struct nix_rx_dr *rx_dr;
+	union nix_rx_parse_s *rxparse;
+	u32 head, tail;
+	u32 rx_cqe_sz = nix->cq[NIX_CQ_RX].entry_sz;
+	u64 *seg;
+
+	/* flush rx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+
+	debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	while (head != tail) {
+		rx_dr = (struct nix_rx_dr *)cq_rx_base + head * rx_cqe_sz;
+		rxparse = &rx_dr->rx_parse;
+
+		debug("%s: rx parse: %p\n", __func__, rxparse);
+		debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x\n",
+		      __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+
+		seg = (dma_addr_t *)(&rx_dr->rx_sg + 1);
+
+		st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
+		      seg[0], (1ULL << 63) | NPA_POOL_RX);
+
+		debug("%s return %llx to NPA\n", __func__, seg[0]);
+		nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
+				 (NIX_CQ_RX << 32) | 1);
+
+		op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+		head = op_status.s.head;
+		tail = op_status.s.tail;
+		head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+		tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+		debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	}
+}
+
+int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+
+	/* Return rx packet to NPA */
+	debug("%s return %p to NPA\n", __func__, pkt);
+	st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(), (u64)pkt,
+	      (1ULL << 63) | NPA_POOL_RX);
+	nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
+			 (NIX_CQ_RX << 32) | 1);
+
+	nix_lf_flush_tx(dev);
+	return 0;
+}
+
+int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union nixx_lf_cq_op_status op_status;
+	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
+	struct nix_rx_dr *rx_dr;
+	union nix_rx_parse_s *rxparse;
+	void *pkt, *cqe;
+	int pkt_len = 0;
+	u64 *addr;
+	u32 head, tail;
+
+	/* fetch rx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	if (head == tail)
+		return -EAGAIN;
+
+	debug("%s: rx_base %p head %d sz %d\n", __func__, cq_rx_base, head,
+	      nix->cq[NIX_CQ_RX].entry_sz);
+	cqe = cq_rx_base + head * nix->cq[NIX_CQ_RX].entry_sz;
+	rx_dr = (struct nix_rx_dr *)cqe;
+	rxparse = &rx_dr->rx_parse;
+
+	debug("%s: rx completion: %p\n", __func__, cqe);
+	debug("%s: rx dr: %p\n", __func__, rx_dr);
+	debug("%s: rx parse: %p\n", __func__, rxparse);
+	debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x\n",
+	      __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+	debug("%s: rx parse: pkind %x chan %x\n",
+	      __func__, rxparse->s.pkind, rxparse->s.chan);
+
+	if (rx_dr->hdr.s.cqe_type != NIX_XQE_TYPE_E_RX) {
+		printf("%s: Error: Unsupported CQ header type in Rx %d\n",
+		       __func__, rx_dr->hdr.s.cqe_type);
+		return -1;
+	}
+
+	pkt_len = rxparse->s.pkt_lenm1 + 1;
+	addr = (dma_addr_t *)(&rx_dr->rx_sg + 1);
+	pkt = (void *)addr[0];
+
+	debug("%s: segs: %d (%d@0x%llx, %d@0x%llx, %d@0x%llx)\n", __func__,
+	      rx_dr->rx_sg.s.segs, rx_dr->rx_sg.s.seg1_size, addr[0],
+	      rx_dr->rx_sg.s.seg2_size, addr[1],
+	      rx_dr->rx_sg.s.seg3_size, addr[2]);
+	if (pkt_len < rx_dr->rx_sg.s.seg1_size + rx_dr->rx_sg.s.seg2_size +
+			rx_dr->rx_sg.s.seg3_size) {
+		debug("%s: Error: rx buffer size too small\n", __func__);
+		return -1;
+	}
+
+	__iowmb();
+#define DEBUG_PKT
+#ifdef DEBUG_PKT
+	debug("RX PKT Data\n");
+	for (int i = 0; i < pkt_len; i++) {
+		if (i && (i % 8 == 0))
+			debug("\n");
+		debug("%02x ", *((u8 *)pkt + i));
+	}
+	debug("\n");
+#endif
+
+	*packetp = (uchar *)pkt;
+
+	return pkt_len;
+}
+
+int nix_lf_setup_mac(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+	/* If lower level firmware fails to set proper MAC
+	 * u-boot framework updates MAC to random address.
+	 * Use this hook to update mac address in cgx lmac
+	 * and call mac filter setup to update new address.
+	 */
+	if (memcmp(nix->lmac->mac_addr, pdata->enetaddr, ARP_HLEN)) {
+		memcpy(nix->lmac->mac_addr, pdata->enetaddr, 6);
+		eth_env_set_enetaddr_by_index("eth", rvu->dev->seq,
+					      pdata->enetaddr);
+		cgx_lmac_mac_filter_setup(nix->lmac);
+		/* Update user given MAC address to ATF for update
+		 * in sh_fwdata to use in Linux.
+		 */
+		cgx_intf_set_macaddr(dev);
+		debug("%s: lMAC %pM\n", __func__, nix->lmac->mac_addr);
+		debug("%s: pMAC %pM\n", __func__, pdata->enetaddr);
+	}
+	debug("%s: setupMAC %pM\n", __func__, pdata->enetaddr);
+	return 0;
+}
+
+void nix_lf_halt(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+
+	cgx_lmac_rx_tx_enable(nix->lmac, nix->lmac->lmac_id, false);
+
+	mdelay(1);
+
+	/* Flush tx and rx descriptors */
+	nix_lf_flush_rx(dev);
+	nix_lf_flush_tx(dev);
+}
+
+int nix_lf_init(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+	int ret;
+	u64 link_sts;
+	u8 link, speed;
+	u16 errcode;
+
+	printf("Waiting for CGX%d LMAC%d [%s] link status...",
+	       lmac->cgx->cgx_id, lmac->lmac_id,
+	       lmac_type_to_str[lmac->lmac_type]);
+
+	if (lmac->init_pend) {
+		/* Bring up LMAC */
+		ret = cgx_lmac_link_enable(lmac, lmac->lmac_id,
+					   true, &link_sts);
+		lmac->init_pend = 0;
+	} else {
+		ret = cgx_lmac_link_status(lmac, lmac->lmac_id, &link_sts);
+	}
+
+	if (ret) {
+		printf(" [Down]\n");
+		return -1;
+	}
+
+	link = link_sts & 0x1;
+	speed = (link_sts >> 2) & 0xf;
+	errcode = (link_sts >> 6) & 0x2ff;
+	debug("%s: link %x speed %x errcode %x\n",
+	      __func__, link, speed, errcode);
+
+	/* Print link status */
+	printf(" [%s]\n", link ? lmac_speed_to_str[speed] : "Down");
+	if (!link)
+		return -1;
+
+	if (!lmac->init_pend)
+		cgx_lmac_rx_tx_enable(lmac, lmac->lmac_id, true);
+
+	return 0;
+}
+
+void nix_get_cgx_lmac_id(struct udevice *dev, int *cgxid, int *lmacid)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+
+	*cgxid = lmac->cgx->cgx_id;
+	*lmacid = lmac->lmac_id;
+}
+
+void nix_print_mac_info(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+
+	printf(" CGX%d LMAC%d [%s]", lmac->cgx->cgx_id, lmac->lmac_id,
+	       lmac_type_to_str[lmac->lmac_type]);
+}
diff --git a/drivers/net/octeontx2/nix.h b/drivers/net/octeontx2/nix.h
new file mode 100644
index 0000000000..00fa5d59dd
--- /dev/null
+++ b/drivers/net/octeontx2/nix.h
@@ -0,0 +1,356 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __NIX_H__
+#define	__NIX_H__
+
+#include <asm/arch/csrs/csrs-npa.h>
+#include <asm/arch/csrs/csrs-nix.h>
+#include "rvu.h"
+
+/** Maximum number of LMACs supported */
+#define MAX_LMAC			12
+
+/* NIX RX action operation*/
+#define NIX_RX_ACTIONOP_DROP		(0x0ull)
+#define NIX_RX_ACTIONOP_UCAST		(0x1ull)
+#define NIX_RX_ACTIONOP_UCAST_IPSEC	(0x2ull)
+#define NIX_RX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_RX_ACTIONOP_RSS		(0x4ull)
+
+/* NIX TX action operation*/
+#define NIX_TX_ACTIONOP_DROP		(0x0ull)
+#define NIX_TX_ACTIONOP_UCAST_DEFAULT	(0x1ull)
+#define NIX_TX_ACTIONOP_UCAST_CHAN	(0x2ull)
+#define NIX_TX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_TX_ACTIONOP_DROP_VIOL	(0x5ull)
+
+#define NIX_INTF_RX			0
+#define NIX_INTF_TX			1
+
+#define NIX_INTF_TYPE_CGX		0
+#define NIX_INTF_TYPE_LBK		1
+#define NIX_MAX_HW_MTU			9212
+#define NIX_MIN_HW_MTU			40
+#define MAX_MTU				1536
+
+#define NPA_POOL_COUNT			3
+#define NPA_AURA_COUNT(x)		(1ULL << ((x) + 6))
+#define NPA_POOL_RX			0ULL
+#define NPA_POOL_TX			1ULL
+#define NPA_POOL_SQB			2ULL
+#define RQ_QLEN				Q_COUNT(Q_SIZE_1K)
+#define SQ_QLEN				Q_COUNT(Q_SIZE_1K)
+#define SQB_QLEN			Q_COUNT(Q_SIZE_16)
+
+#define NIX_CQ_RX			0ULL
+#define NIX_CQ_TX			1ULL
+#define NIX_CQ_COUNT			2ULL
+#define NIX_CQE_SIZE_W16		(16 * sizeof(u64))
+#define NIX_CQE_SIZE_W64		(64 * sizeof(u64))
+
+/** Size of aura hardware context */
+#define NPA_AURA_HW_CTX_SIZE		48
+/** Size of pool hardware context */
+#define NPA_POOL_HW_CTX_SIZE		64
+
+#define NPA_DEFAULT_PF_FUNC		0xffff
+
+#define NIX_CHAN_CGX_LMAC_CHX(a, b, c)	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
+#define NIX_LINK_CGX_LMAC(a, b)		(0 + 4 * (a) + (b))
+#define NIX_LINK_LBK(a)			(12 + (a))
+#define NIX_CHAN_LBK_CHX(a, b)		(0 + 0x100 * (a) + (b))
+#define MAX_LMAC_PKIND			12
+
+/** Number of Admin queue entries */
+#define AQ_RING_SIZE	Q_COUNT(Q_SIZE_16)
+
+/** Each completion queue contains 256 entries, see NIC_CQ_CTX_S[qsize] */
+#define CQS_QSIZE			Q_SIZE_256
+#define CQ_ENTRIES			Q_COUNT(CQS_QSIZE)
+/**
+ * Each completion queue entry contains 128 bytes, see
+ * NIXX_AF_LFX_CFG[xqe_size]
+ */
+#define CQ_ENTRY_SIZE			NIX_CQE_SIZE_W16
+
+enum npa_aura_size {
+	NPA_AURA_SZ_0,
+	NPA_AURA_SZ_128,
+	NPA_AURA_SZ_256,
+	NPA_AURA_SZ_512,
+	NPA_AURA_SZ_1K,
+	NPA_AURA_SZ_2K,
+	NPA_AURA_SZ_4K,
+	NPA_AURA_SZ_8K,
+	NPA_AURA_SZ_16K,
+	NPA_AURA_SZ_32K,
+	NPA_AURA_SZ_64K,
+	NPA_AURA_SZ_128K,
+	NPA_AURA_SZ_256K,
+	NPA_AURA_SZ_512K,
+	NPA_AURA_SZ_1M,
+	NPA_AURA_SZ_MAX,
+};
+
+#define NPA_AURA_SIZE_DEFAULT		NPA_AURA_SZ_128
+
+/* NIX Transmit schedulers */
+enum nix_scheduler {
+	NIX_TXSCH_LVL_SMQ = 0x0,
+	NIX_TXSCH_LVL_MDQ = 0x0,
+	NIX_TXSCH_LVL_TL4 = 0x1,
+	NIX_TXSCH_LVL_TL3 = 0x2,
+	NIX_TXSCH_LVL_TL2 = 0x3,
+	NIX_TXSCH_LVL_TL1 = 0x4,
+	NIX_TXSCH_LVL_CNT = 0x5,
+};
+
+struct cgx;
+
+struct nix_stats {
+	u64	num_packets;
+	u64	num_bytes;
+};
+
+struct nix;
+struct lmac;
+
+struct npa_af {
+	void __iomem		*npa_af_base;
+	struct admin_queue	aq;
+	u32			aura;
+};
+
+struct npa {
+	struct npa_af		*npa_af;
+	void __iomem		*npa_base;
+	void __iomem		*npc_base;
+	void __iomem		*lmt_base;
+	/** Hardware aura context */
+	void			*aura_ctx;
+	/** Hardware pool context */
+	void			*pool_ctx[NPA_POOL_COUNT];
+	void			*pool_stack[NPA_POOL_COUNT];
+	void                    **buffers[NPA_POOL_COUNT];
+	u32                     pool_stack_pages[NPA_POOL_COUNT];
+	u32			pool_stack_pointers;
+	u32			q_len[NPA_POOL_COUNT];
+	u32			buf_size[NPA_POOL_COUNT];
+	u32			stack_pages[NPA_POOL_COUNT];
+	int			lf;
+};
+
+struct nix_af {
+	struct udevice			*dev;
+	struct nix			*lmacs[MAX_LMAC];
+	struct npa_af			*npa_af;
+	void __iomem			*nix_af_base;
+	void __iomem			*npc_af_base;
+	struct admin_queue		aq;
+	u8				num_lmacs;
+	s8				index;
+	u8				xqe_size;
+	u32				sqb_size;
+	u32				qints;
+	u32				cints;
+	u32				sq_ctx_sz;
+	u32				rq_ctx_sz;
+	u32				cq_ctx_sz;
+	u32				rsse_ctx_sz;
+	u32				cint_ctx_sz;
+	u32				qint_ctx_sz;
+};
+
+struct nix_tx_dr {
+	union nix_send_hdr_s	hdr;
+	union nix_send_sg_s	tx_sg;
+	dma_addr_t			sg1_addr;
+	dma_addr_t			sg2_addr;
+	dma_addr_t			sg3_addr;
+	u64				in_use;
+};
+
+struct nix_rx_dr {
+	union nix_cqe_hdr_s hdr;
+	union nix_rx_parse_s rx_parse;
+	union nix_rx_sg_s rx_sg;
+};
+
+struct nix {
+	struct udevice			*dev;
+	struct eth_device		*netdev;
+	struct nix_af			*nix_af;
+	struct npa			*npa;
+	struct lmac			*lmac;
+	union nix_cint_hw_s	*cint_base;
+	union nix_cq_ctx_s		*cq_ctx_base;
+	union nix_qint_hw_s	*qint_base;
+	union nix_rq_ctx_s		*rq_ctx_base;
+	union nix_rsse_s		*rss_base;
+	union nix_sq_ctx_s		*sq_ctx_base;
+	void				*cqe_base;
+	struct qmem			sq;
+	struct qmem			cq[NIX_CQ_COUNT];
+	struct qmem			rq;
+	struct qmem			rss;
+	struct qmem			cq_ints;
+	struct qmem			qints;
+	char				name[16];
+	void __iomem			*nix_base;	/** PF reg base */
+	void __iomem			*npc_base;
+	void __iomem			*lmt_base;
+	struct nix_stats		tx_stats;
+	struct nix_stats		rx_stats;
+	u32				aura;
+	int				pknd;
+	int				lf;
+	int				pf;
+	u16				pf_func;
+	u32				rq_cnt;	/** receive queues count */
+	u32				sq_cnt;	/** send queues count */
+	u32				cq_cnt;	/** completion queues count */
+	u16				rss_sz;
+	u16				sqb_size;
+	u8				rss_grps;
+	u8				xqe_sz;
+};
+
+struct nix_aq_cq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_cq_ctx_s	cq ALIGNED;
+	union nix_cq_ctx_s	mcq ALIGNED;
+};
+
+struct nix_aq_rq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_rq_ctx_s	rq ALIGNED;
+	union nix_rq_ctx_s	mrq ALIGNED;
+};
+
+struct nix_aq_sq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_sq_ctx_s	sq ALIGNED;
+	union nix_sq_ctx_s	msq ALIGNED;
+};
+
+struct nix_aq_cq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_cq_ctx_s	cq ALIGNED;
+};
+
+struct nix_aq_rq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_rq_ctx_s	rq ALIGNED;
+};
+
+struct nix_aq_sq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_sq_ctx_s	sq ALIGNED;
+};
+
+static inline u64 nix_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->nix_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void nix_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+	      val);
+	writeq(val, nix_af->nix_af_base + offset);
+}
+
+static inline u64 nix_pf_reg_read(struct nix *nix, u64 offset)
+{
+	u64 val = readq(nix->nix_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+	      val);
+	return val;
+}
+
+static inline void nix_pf_reg_write(struct nix *nix, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+	      val);
+	writeq(val, nix->nix_base + offset);
+}
+
+static inline u64 npa_af_reg_read(struct npa_af *npa_af, u64 offset)
+{
+	u64 val = readq(npa_af->npa_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void npa_af_reg_write(struct npa_af *npa_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+	      val);
+	writeq(val, npa_af->npa_af_base + offset);
+}
+
+static inline u64 npc_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->npc_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void npc_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+	      val);
+	writeq(val, nix_af->npc_af_base + offset);
+}
+
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+		    const union npa_aura_s *desc, u32 aura_id);
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+		    const union npa_pool_s *desc, u32 pool_id);
+int npa_af_setup(struct npa_af *npa_af);
+int npa_af_shutdown(struct npa_af *npa_af);
+int npa_lf_setup(struct nix *nix, int npa_lf);
+int npa_lf_shutdown(struct nix *nix);
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base);
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count);
+
+int npc_lf_admin_setup(struct nix *nix);
+int npc_af_shutdown(struct nix_af *nix_af);
+
+int nix_af_setup(struct nix_af *nix_af);
+int nix_af_shutdown(struct nix_af *nix_af);
+int nix_lf_setup(struct nix *nix);
+int nix_lf_shutdown(struct nix *nix);
+struct nix *nix_lf_alloc(struct udevice *dev, int nix_id);
+int nix_lf_admin_setup(struct nix *nix);
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count);
+struct rvu_af *get_af(void);
+
+int nix_lf_setup_mac(struct udevice *dev);
+int nix_lf_read_rom_mac(struct udevice *dev);
+void nix_lf_halt(struct udevice *dev);
+int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len);
+int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp);
+int nix_lf_init(struct udevice *dev);
+int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len);
+
+#endif /* __NIX_H__ */
diff --git a/drivers/net/octeontx2/nix_af.c b/drivers/net/octeontx2/nix_af.c
new file mode 100644
index 0000000000..f84d1613fe
--- /dev/null
+++ b/drivers/net/octeontx2/nix_af.c
@@ -0,0 +1,1104 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/log2.h>
+#include <asm/arch/board.h>
+#include "asm/arch/csrs/csrs-npc.h"
+#include "asm/arch/csrs/csrs-lmt.h"
+#include "nix.h"
+#include "lmt.h"
+#include "cgx.h"
+
+static struct nix_aq_cq_dis cq_dis ALIGNED;
+static struct nix_aq_rq_dis rq_dis ALIGNED;
+static struct nix_aq_sq_dis sq_dis ALIGNED;
+
+/***************
+ * NPA API
+ ***************/
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+		    const union npa_aura_s *desc, u32 aura_id)
+{
+	struct npa_af *npa = nix_af->npa_af;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
+	union npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, lf %d, %p, aura id %u)\n", __func__, nix_af, lf, desc,
+	      aura_id);
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+	inst->s.cindex = aura_id;
+
+	context = (union npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+		    const union npa_pool_s *desc, u32 pool_id)
+{
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
+	struct npa_af *npa = nix_af->npa_af;
+	union npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, pool_id);
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.cindex = pool_id;
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+
+	context = (union npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base)
+{
+	union npa_af_lf_rst lf_rst;
+	union npa_af_lfx_auras_cfg auras_cfg;
+	struct npa_af *npa_af = npa->npa_af;
+
+	debug("%s(%p, %d, 0x%llx)\n", __func__, npa_af, lf, aura_base);
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa_af, NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa_af, NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Set Aura size and enable caching of contexts */
+	auras_cfg.u = npa_af_reg_read(npa_af, NPA_AF_LFX_AURAS_CFG(lf));
+	auras_cfg.s.loc_aura_size = NPA_AURA_SIZE_DEFAULT; //FIXME aura_size;
+	auras_cfg.s.caching = 1;
+	auras_cfg.s.rmt_aura_size = 0;
+	auras_cfg.s.rmt_aura_offset = 0;
+	auras_cfg.s.rmt_lf = 0;
+	npa_af_reg_write(npa_af, NPA_AF_LFX_AURAS_CFG(lf), auras_cfg.u);
+	/* Configure aura HW context base */
+	npa_af_reg_write(npa_af, NPA_AF_LFX_LOC_AURAS_BASE(lf),
+			 aura_base);
+
+	return 0;
+}
+
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
+{
+	int pool_id;
+	u32 head;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	struct npa_aq_pool_request {
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_pool_s p0 ALIGNED;
+		union npa_pool_s p1 ALIGNED;
+	} pool_req ALIGNED;
+	struct npa_aq_aura_request {
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_aura_s a0 ALIGNED;
+		union npa_aura_s a1 ALIGNED;
+	} aura_req ALIGNED;
+	union npa_af_aq_status aq_stat;
+	union npa_af_lf_rst lf_rst;
+	struct npa_af *npa = nix_af->npa_af;
+	ulong start;
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &pool_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&pool_req.resp;
+
+		memset((void *)&pool_req, 0, sizeof(pool_req));
+		pool_req.p0.s.ena = 0;
+		pool_req.p1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+				pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, pool id %d) disabled\n", __func__, lf,
+		      pool_id);
+	}
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &aura_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&aura_req.resp;
+
+		memset((void *)&aura_req, 0, sizeof(aura_req));
+		aura_req.a0.s.ena = 0;
+		aura_req.a1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+			       pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, aura id %d) disabled\n", __func__, lf,
+		      pool_id);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa, NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa, NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+
+int npa_af_setup(struct npa_af *npa_af)
+{
+	int err;
+	union npa_af_gen_cfg npa_cfg;
+	union npa_af_ndc_cfg ndc_cfg;
+	union npa_af_aq_cfg aq_cfg;
+	union npa_af_blk_rst blk_rst;
+
+	err = rvu_aq_alloc(&npa_af->aq, Q_COUNT(AQ_SIZE),
+			   sizeof(union npa_aq_inst_s),
+			   sizeof(union npa_aq_res_s));
+	if (err) {
+		printf("%s: Error %d allocating admin queue\n", __func__, err);
+		return err;
+	}
+	debug("%s: NPA admin queue allocated at %p %llx\n", __func__,
+	      npa_af->aq.inst.base, npa_af->aq.inst.iova);
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Set little Endian */
+	npa_cfg.u = npa_af_reg_read(npa_af, NPA_AF_GEN_CFG());
+	npa_cfg.s.af_be = 0;
+	npa_af_reg_write(npa_af, NPA_AF_GEN_CFG(), npa_cfg.u);
+	/* Enable NDC cache */
+	ndc_cfg.u = npa_af_reg_read(npa_af, NPA_AF_NDC_CFG());
+	ndc_cfg.s.ndc_bypass = 0;
+	npa_af_reg_write(npa_af, NPA_AF_NDC_CFG(), ndc_cfg.u);
+	/* Set up queue size */
+	aq_cfg.u = npa_af_reg_read(npa_af, NPA_AF_AQ_CFG());
+	aq_cfg.s.qsize = AQ_SIZE;
+	npa_af_reg_write(npa_af, NPA_AF_AQ_CFG(), aq_cfg.u);
+	/* Set up queue base address */
+	npa_af_reg_write(npa_af, NPA_AF_AQ_BASE(), npa_af->aq.inst.iova);
+
+	return 0;
+}
+
+int npa_af_shutdown(struct npa_af *npa_af)
+{
+	union npa_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&npa_af->aq);
+
+	debug("%s: npa af reset --\n", __func__);
+
+	return 0;
+}
+
+/***************
+ * NIX API
+ ***************/
+/**
+ * Setup SMQ -> TL4 -> TL3 -> TL2 -> TL1 -> MAC mapping
+ *
+ * @param nix     Handle to setup
+ *
+ * @return 0, or negative on failure
+ */
+static int nix_af_setup_sq(struct nix *nix)
+{
+	union nixx_af_tl1x_schedule tl1_sched;
+	union nixx_af_tl2x_parent tl2_parent;
+	union nixx_af_tl3x_parent tl3_parent;
+	union nixx_af_tl3_tl2x_cfg tl3_tl2_cfg;
+	union nixx_af_tl3_tl2x_linkx_cfg tl3_tl2_link_cfg;
+	union nixx_af_tl4x_parent tl4_parent;
+	union nixx_af_tl4x_sdp_link_cfg tl4_sdp_link_cfg;
+	union nixx_af_smqx_cfg smq_cfg;
+	union nixx_af_mdqx_schedule mdq_sched;
+	union nixx_af_mdqx_parent mdq_parent;
+	union nixx_af_rx_linkx_cfg link_cfg;
+	int tl1_index = nix->lmac->link_num; /* NIX_LINK_E enum */
+	int tl2_index = tl1_index;
+	int tl3_index = tl2_index;
+	int tl4_index = tl3_index;
+	int smq_index = tl4_index;
+	struct nix_af *nix_af = nix->nix_af;
+	u64 offset = 0;
+
+	tl1_sched.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_TL1X_SCHEDULE(tl1_index));
+	tl1_sched.s.rr_quantum = MAX_MTU;
+	nix_af_reg_write(nix_af, NIXX_AF_TL1X_SCHEDULE(tl1_index),
+			 tl1_sched.u);
+
+	tl2_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL2X_PARENT(tl2_index));
+	tl2_parent.s.parent = tl1_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL2X_PARENT(tl2_index),
+			 tl2_parent.u);
+
+	tl3_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL3X_PARENT(tl3_index));
+	tl3_parent.s.parent = tl2_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL3X_PARENT(tl3_index),
+			 tl3_parent.u);
+	tl3_tl2_cfg.u = nix_af_reg_read(nix_af,
+					NIXX_AF_TL3_TL2X_CFG(tl3_index));
+	tl3_tl2_cfg.s.express = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_TL3_TL2X_CFG(tl3_index),
+			 tl3_tl2_cfg.u);
+
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	tl3_tl2_link_cfg.u = nix_af_reg_read(nix_af, offset);
+	tl3_tl2_link_cfg.s.bp_ena = 1;
+	tl3_tl2_link_cfg.s.ena = 1;
+	tl3_tl2_link_cfg.s.relchan = 0;
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	nix_af_reg_write(nix_af, offset, tl3_tl2_link_cfg.u);
+
+	tl4_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL4X_PARENT(tl4_index));
+	tl4_parent.s.parent = tl3_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL4X_PARENT(tl4_index),
+			 tl4_parent.u);
+
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	tl4_sdp_link_cfg.u = nix_af_reg_read(nix_af, offset);
+	tl4_sdp_link_cfg.s.bp_ena = 0;
+	tl4_sdp_link_cfg.s.ena = 0;
+	tl4_sdp_link_cfg.s.relchan = 0;
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	nix_af_reg_write(nix_af, offset, tl4_sdp_link_cfg.u);
+
+	smq_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_SMQX_CFG(smq_index));
+	smq_cfg.s.express = 0;
+	smq_cfg.s.lf = nix->lf;
+	smq_cfg.s.desc_shp_ctl_dis = 1;
+	smq_cfg.s.maxlen = MAX_MTU;
+	smq_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix_af, NIXX_AF_SMQX_CFG(smq_index), smq_cfg.u);
+
+	mdq_sched.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_MDQX_SCHEDULE(smq_index));
+	mdq_sched.s.rr_quantum = MAX_MTU;
+	offset = NIXX_AF_MDQX_SCHEDULE(smq_index);
+	nix_af_reg_write(nix_af, offset, mdq_sched.u);
+	mdq_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_MDQX_PARENT(smq_index));
+	mdq_parent.s.parent = tl4_index;
+	nix_af_reg_write(nix_af, NIXX_AF_MDQX_PARENT(smq_index),
+			 mdq_parent.u);
+
+	link_cfg.u = 0;
+	link_cfg.s.maxlen = NIX_MAX_HW_MTU;
+	link_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix->nix_af,
+			 NIXX_AF_RX_LINKX_CFG(nix->lmac->link_num),
+			 link_cfg.u);
+
+	return 0;
+}
+
+/**
+ * Issue a command to the NIX AF Admin Queue
+ *
+ * @param nix    nix handle
+ * @param lf     Logical function number for command
+ * @param op     Operation
+ * @param ctype  Context type
+ * @param cindex Context index
+ * @param resp   Result pointer
+ *
+ * @return	0 for success, -EBUSY on failure
+ */
+static int nix_aq_issue_command(struct nix_af *nix_af,
+				int lf,
+				int op,
+				int ctype,
+				int cindex, union nix_aq_res_s *resp)
+{
+	union nixx_af_aq_status aq_status;
+	union nix_aq_inst_s *aq_inst;
+	union nix_aq_res_s *result = resp;
+	ulong start;
+
+	debug("%s(%p, 0x%x, 0x%x, 0x%x, 0x%x, %p)\n", __func__, nix_af, lf,
+	      op, ctype, cindex, resp);
+	aq_status.u = nix_af_reg_read(nix_af, NIXX_AF_AQ_STATUS());
+	aq_inst = (union nix_aq_inst_s *)(nix_af->aq.inst.base) +
+						aq_status.s.head_ptr;
+	aq_inst->u[0] = 0;
+	aq_inst->u[1] = 0;
+	aq_inst->s.op = op;
+	aq_inst->s.ctype = ctype;
+	aq_inst->s.lf = lf;
+	aq_inst->s.cindex = cindex;
+	aq_inst->s.doneint = 0;
+	aq_inst->s.res_addr = (u64)resp;
+	debug("%s: inst@%p: 0x%llx 0x%llx\n", __func__, aq_inst,
+	      aq_inst->u[0], aq_inst->u[1]);
+	__iowmb();
+
+	/* Ring doorbell and wait for result */
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	/* Wait for completion */
+	do {
+		WATCHDOG_RESET();
+		dsb();
+	} while (result->s.compcode == 0 && get_timer(start) < 2);
+
+	if (result->s.compcode != NIX_AQ_COMP_E_GOOD) {
+		printf("NIX:AQ fail or time out with code %d after %ld ms\n",
+		       result->s.compcode, get_timer(start));
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int nix_attach_receive_queue(struct nix_af *nix_af, int lf)
+{
+	struct nix_aq_rq_request rq_req ALIGNED;
+	int err;
+
+	debug("%s(%p, %d)\n", __func__, nix_af, lf);
+
+	memset(&rq_req, 0, sizeof(struct nix_aq_rq_request));
+
+	rq_req.rq.s.ena = 1;
+	rq_req.rq.s.spb_ena = 1;
+	rq_req.rq.s.ipsech_ena = 0;
+	rq_req.rq.s.ena_wqwd = 0;
+	rq_req.rq.s.cq = NIX_CQ_RX;
+	rq_req.rq.s.substream = 0;	/* FIXME: Substream IDs? */
+	rq_req.rq.s.wqe_aura = -1;	/* No WQE aura */
+	rq_req.rq.s.spb_aura = NPA_POOL_RX;
+	rq_req.rq.s.lpb_aura = NPA_POOL_RX;
+	/* U-Boot doesn't use WQE group for anything */
+	rq_req.rq.s.pb_caching = 1;
+	rq_req.rq.s.xqe_drop_ena = 0;	/* Disable RED dropping */
+	rq_req.rq.s.spb_drop_ena = 0;
+	rq_req.rq.s.lpb_drop_ena = 0;
+	rq_req.rq.s.spb_sizem1 = (MAX_MTU / (3 * 8)) - 1; /* 512 bytes */
+	rq_req.rq.s.lpb_sizem1 = (MAX_MTU / 8) - 1;
+	rq_req.rq.s.first_skip = 0;
+	rq_req.rq.s.later_skip = 0;
+	rq_req.rq.s.xqe_imm_copy = 0;
+	rq_req.rq.s.xqe_hdr_split = 0;
+	rq_req.rq.s.xqe_drop = 0;
+	rq_req.rq.s.xqe_pass = 0;
+	rq_req.rq.s.wqe_pool_drop = 0;	/* No WQE pool */
+	rq_req.rq.s.wqe_pool_pass = 0;	/* No WQE pool */
+	rq_req.rq.s.spb_aura_drop = 255;
+	rq_req.rq.s.spb_aura_pass = 255;
+	rq_req.rq.s.spb_pool_drop = 0;
+	rq_req.rq.s.spb_pool_pass = 0;
+	rq_req.rq.s.lpb_aura_drop = 255;
+	rq_req.rq.s.lpb_aura_pass = 255;
+	rq_req.rq.s.lpb_pool_drop = 0;
+	rq_req.rq.s.lpb_pool_pass = 0;
+	rq_req.rq.s.qint_idx = 0;
+
+	err = nix_aq_issue_command(nix_af, lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_RQ,
+				   0, &rq_req.resp);
+	if (err) {
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_send_queue(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_sq_request sq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = nix_af_setup_sq(nix);
+
+	memset(&sq_req, 0, sizeof(sq_req));
+
+	sq_req.sq.s.ena = 1;
+	sq_req.sq.s.cq_ena = 1;
+	sq_req.sq.s.max_sqe_size = NIX_MAXSQESZ_E_W16;
+	sq_req.sq.s.substream = 0; // FIXME: Substream IDs?
+	sq_req.sq.s.sdp_mcast = 0;
+	sq_req.sq.s.cq = NIX_CQ_TX;
+	sq_req.sq.s.cq_limit = 0;
+	sq_req.sq.s.smq = nix->lmac->link_num; // scheduling index
+	sq_req.sq.s.sso_ena = 0;
+	sq_req.sq.s.smq_rr_quantum = MAX_MTU / 4;
+	sq_req.sq.s.default_chan = nix->lmac->chan_num;
+	sq_req.sq.s.sqe_stype = NIX_STYPE_E_STP;
+	sq_req.sq.s.qint_idx = 0;
+	sq_req.sq.s.sqb_aura = NPA_POOL_SQB;
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_SQ,
+				   0, &sq_req.resp);
+	if (err) {
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_completion_queue(struct nix *nix, int cq_idx)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_cq_request cq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	memset(&cq_req, 0, sizeof(cq_req));
+	cq_req.cq.s.ena = 1;
+	cq_req.cq.s.bpid = nix->lmac->pknd;
+	cq_req.cq.s.substream = 0;	/* FIXME: Substream IDs? */
+	cq_req.cq.s.drop_ena = 0;
+	cq_req.cq.s.caching = 1;
+	cq_req.cq.s.qsize = CQS_QSIZE;
+	cq_req.cq.s.drop = 255 * 7 / 8;
+	cq_req.cq.s.qint_idx = 0;
+	cq_req.cq.s.cint_idx = 0;
+	cq_req.cq.s.base = nix->cq[cq_idx].iova;
+	debug("%s: CQ(%d)  base %p\n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_CQ,
+				   cq_idx, &cq_req.resp);
+	if (err) {
+		printf("%s: Error requesting completion queue\n", __func__);
+		return err;
+	}
+	debug("%s: CQ(%d) allocated, base %p\n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	return 0;
+}
+
+int nix_lf_admin_setup(struct nix *nix)
+{
+	union nixx_af_lfx_rqs_cfg rqs_cfg;
+	union nixx_af_lfx_sqs_cfg sqs_cfg;
+	union nixx_af_lfx_cqs_cfg cqs_cfg;
+	union nixx_af_lfx_rss_cfg rss_cfg;
+	union nixx_af_lfx_cints_cfg cints_cfg;
+	union nixx_af_lfx_qints_cfg qints_cfg;
+	union nixx_af_lfx_rss_grpx rss_grp;
+	union nixx_af_lfx_tx_cfg2 tx_cfg2;
+	union nixx_af_lfx_cfg lfx_cfg;
+	union nixx_af_lf_rst lf_rst;
+	u32 index;
+	struct nix_af *nix_af = nix->nix_af;
+	int err;
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = nix->lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Config NIX RQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_BASE(nix->lf),
+			 (u64)nix->rq_ctx_base);
+	/* Set caching and queue count in HW */
+	rqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf));
+	rqs_cfg.s.caching = 1;
+	rqs_cfg.s.max_queuesm1 = nix->rq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf), rqs_cfg.u);
+
+	/* Config NIX SQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_BASE(nix->lf),
+			 (u64)nix->sq_ctx_base);
+	sqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf));
+	sqs_cfg.s.caching = 1;
+	sqs_cfg.s.max_queuesm1 = nix->sq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf), sqs_cfg.u);
+
+	/* Config NIX CQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_BASE(nix->lf),
+			 (u64)nix->cq_ctx_base);
+	cqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf));
+	cqs_cfg.s.caching = 1;
+	cqs_cfg.s.max_queuesm1 = nix->cq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf), cqs_cfg.u);
+
+	/* Config NIX RSS HW context and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_BASE(nix->lf),
+			 (u64)nix->rss_base);
+	rss_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf));
+	rss_cfg.s.ena = 1;
+	rss_cfg.s.size = ilog2(nix->rss_sz) / 256;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf), rss_cfg.u);
+
+	for (index = 0; index < nix->rss_grps; index++) {
+		rss_grp.u = 0;
+		rss_grp.s.sizem1 = 0x7;
+		rss_grp.s.offset = nix->rss_sz * index;
+		nix_af_reg_write(nix_af,
+				 NIXX_AF_LFX_RSS_GRPX(nix->lf, index),
+				 rss_grp.u);
+	}
+
+	/* Config CQints HW contexts and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_BASE(nix->lf),
+			 (u64)nix->cint_base);
+	cints_cfg.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_LFX_CINTS_CFG(nix->lf));
+	cints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_CFG(nix->lf),
+			 cints_cfg.u);
+
+	/* Config Qints HW context and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_BASE(nix->lf),
+			 (u64)nix->qint_base);
+	qints_cfg.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_LFX_QINTS_CFG(nix->lf));
+	qints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_CFG(nix->lf),
+			 qints_cfg.u);
+
+	debug("%s(%p, %d, %d)\n", __func__, nix_af, nix->lf, nix->pf);
+
+	/* Enable LMTST for this NIX LF */
+	tx_cfg2.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf));
+	tx_cfg2.s.lmt_ena = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf), tx_cfg2.u);
+
+	/* Use 16-word XQEs, write the npa pf_func number only */
+	lfx_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CFG(nix->lf));
+	lfx_cfg.s.xqe_size = NIX_XQESZ_E_W16;
+	lfx_cfg.s.npa_pf_func = nix->pf_func;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CFG(nix->lf), lfx_cfg.u);
+
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RX_CFG(nix->lf), 0);
+
+	for (index = 0; index < nix->cq_cnt; index++) {
+		err = nix_attach_completion_queue(nix, index);
+		if (err) {
+			printf("%s: Error attaching completion queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->rq_cnt; index++) {
+		err = nix_attach_receive_queue(nix_af, nix->lf);
+		if (err) {
+			printf("%s: Error attaching receive queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->sq_cnt; index++) {
+		err = nix_attach_send_queue(nix);
+		if (err) {
+			printf("%s: Error attaching send queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count)
+{
+	union nixx_af_rx_sw_sync sw_sync;
+	union nixx_af_lf_rst lf_rst;
+	int index, err;
+
+	/* Flush all tx packets */
+	sw_sync.u = 0;
+	sw_sync.s.ena = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_RX_SW_SYNC(), sw_sync.u);
+
+	do {
+		sw_sync.u = nix_af_reg_read(nix_af, NIXX_AF_RX_SW_SYNC());
+		WATCHDOG_RESET();
+	} while (sw_sync.s.ena);
+
+	for (index = 0; index < rq_count; index++) {
+		memset((void *)&rq_dis, 0, sizeof(rq_dis));
+		rq_dis.rq.s.ena = 0;	/* Context */
+		rq_dis.mrq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_RQ,
+					   index, &rq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d RQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d RQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < sq_count; index++) {
+		memset((void *)&sq_dis, 0, sizeof(sq_dis));
+		sq_dis.sq.s.ena = 0;	/* Context */
+		sq_dis.msq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_SQ,
+					   index, &sq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d SQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d SQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < cq_count; index++) {
+		memset((void *)&cq_dis, 0, sizeof(cq_dis));
+		cq_dis.cq.s.ena = 0;	/* Context */
+		cq_dis.mcq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_CQ,
+					   index, &cq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d CQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d CQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+
+int npc_lf_admin_setup(struct nix *nix)
+{
+	union npc_af_const af_const;
+	union npc_af_pkindx_action0 action0;
+	union npc_af_pkindx_action1 action1;
+	union npc_af_intfx_kex_cfg kex_cfg;
+	union npc_af_intfx_miss_stat_act intfx_stat_act;
+	union npc_af_mcamex_bankx_camx_intf camx_intf;
+	union npc_af_mcamex_bankx_camx_w0 camx_w0;
+	union npc_af_mcamex_bankx_cfg bankx_cfg;
+	union npc_af_mcamex_bankx_stat_act mcamex_stat_act;
+
+	union nix_rx_action_s rx_action;
+	union nix_tx_action_s tx_action;
+
+	struct nix_af *nix_af = nix->nix_af;
+	u32 kpus;
+	int pkind = nix->lmac->link_num;
+	int index;
+	u64 offset;
+
+	debug("%s(%p, pkind 0x%x)\n", __func__, nix_af, pkind);
+	af_const.u = npc_af_reg_read(nix_af, NPC_AF_CONST());
+	kpus = af_const.s.kpus;
+
+	action0.u = 0;
+	action0.s.parse_done = 1;
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION0(pkind), action0.u);
+
+	action1.u = 0;
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION1(pkind), action1.u);
+
+	kex_cfg.u = 0;
+	kex_cfg.s.keyw = NPC_MCAMKEYW_E_X1;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_RX(0)),
+			 kex_cfg.u);
+
+	/* HW Issue */
+	kex_cfg.u = 0;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_TX(0)),
+			 kex_cfg.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = ~NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 0),
+			 camx_intf.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 1),
+			 camx_intf.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = ~(nix->lmac->chan_num) & (~((~0x0ull) << 12));
+	debug("NPC LF ADMIN camx_w0.u %llx\n", camx_w0.u);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 0),
+			 camx_w0.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = nix->lmac->chan_num;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 1),
+			 camx_w0.u);
+
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 0),
+			 0);
+
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 1),
+			 0);
+
+	/* Enable stats for NPC INTF RX */
+	mcamex_stat_act.u = 0;
+	mcamex_stat_act.s.ena = 1;
+	mcamex_stat_act.s.stat_sel = pkind;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_STAT_ACT(pkind, 0),
+			 mcamex_stat_act.u);
+	intfx_stat_act.u = 0;
+	intfx_stat_act.s.ena = 1;
+	intfx_stat_act.s.stat_sel = 16;
+	offset = NPC_AF_INTFX_MISS_STAT_ACT(NPC_INTF_E_NIXX_RX(0));
+	npc_af_reg_write(nix_af, offset, intfx_stat_act.u);
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = NIX_RX_ACTIONOP_E_UCAST;
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_ACTION(pkind, 0),
+			 rx_action.u);
+
+	for (index = 0; index < kpus; index++)
+		npc_af_reg_write(nix_af, NPC_AF_KPUX_CFG(index), 0);
+
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = NIX_RX_ACTIONOP_E_DROP;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_RX(0)),
+			 rx_action.u);
+	bankx_cfg.u = 0;
+	bankx_cfg.s.ena = 1;
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CFG(pkind, 0),
+			 bankx_cfg.u);
+
+	tx_action.u = 0;
+	tx_action.s.op = NIX_TX_ACTIONOP_E_UCAST_DEFAULT;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_TX(0)),
+			 tx_action.u);
+
+#ifdef DEBUG
+	/* Enable debug capture on RX intf */
+	npc_af_reg_write(nix_af, NPC_AF_DBG_CTL(), 0x4);
+#endif
+
+	return 0;
+}
+
+int npc_af_shutdown(struct nix_af *nix_af)
+{
+	union npc_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npc_af_reg_write(nix_af, NPC_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npc_af_reg_read(nix_af, NPC_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	debug("%s: npc af reset --\n", __func__);
+
+	return 0;
+}
+
+int nix_af_setup(struct nix_af *nix_af)
+{
+	int err;
+	union nixx_af_const2 af_const2;
+	union nixx_af_const3 af_const3;
+	union nixx_af_sq_const sq_const;
+	union nixx_af_cfg af_cfg;
+	union nixx_af_status af_status;
+	union nixx_af_ndc_cfg ndc_cfg;
+	union nixx_af_aq_cfg aq_cfg;
+	union nixx_af_blk_rst blk_rst;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = rvu_aq_alloc(&nix_af->aq, Q_COUNT(AQ_SIZE),
+			   sizeof(union nix_aq_inst_s),
+			   sizeof(union nix_aq_res_s));
+	if (err) {
+		printf("%s: Error allocating nix admin queue\n", __func__);
+		return err;
+	}
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Put in LE mode */
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	if (af_cfg.s.force_cond_clk_en || af_cfg.s.calibrate_x2p ||
+	    af_cfg.s.force_intf_clk_en) {
+		printf("%s: Error: Invalid NIX_AF_CFG value 0x%llx\n",
+		       __func__, af_cfg.u);
+		return -1;
+	}
+	af_cfg.s.af_be = 0;
+	af_cfg.u |= 0x5E;	/* HW Issue */
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Perform Calibration */
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Wait for calibration to complete */
+	do {
+		af_status.u = nix_af_reg_read(nix_af, NIXX_AF_STATUS());
+		WATCHDOG_RESET();
+	} while (af_status.s.calibrate_done == 0);
+
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Enable NDC cache */
+	ndc_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_NDC_CFG());
+	ndc_cfg.s.ndc_ign_pois = 0;
+	ndc_cfg.s.byp_sq = 0;
+	ndc_cfg.s.byp_sqb = 0;
+	ndc_cfg.s.byp_cqs = 0;
+	ndc_cfg.s.byp_cints = 0;
+	ndc_cfg.s.byp_dyno = 0;
+	ndc_cfg.s.byp_mce = 0;
+	ndc_cfg.s.byp_rqc = 0;
+	ndc_cfg.s.byp_rsse = 0;
+	ndc_cfg.s.byp_mc_data = 0;
+	ndc_cfg.s.byp_mc_wqe = 0;
+	ndc_cfg.s.byp_mr_data = 0;
+	ndc_cfg.s.byp_mr_wqe = 0;
+	ndc_cfg.s.byp_qints = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_NDC_CFG(), ndc_cfg.u);
+
+	/* Set up queue size */
+	aq_cfg.u = 0;
+	aq_cfg.s.qsize = AQ_SIZE;
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_CFG(), aq_cfg.u);
+
+	/* Set up queue base address */
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_BASE(), nix_af->aq.inst.iova);
+
+	af_const3.u = nix_af_reg_read(nix_af, NIXX_AF_CONST3());
+	af_const2.u = nix_af_reg_read(nix_af, NIXX_AF_CONST2());
+	sq_const.u = nix_af_reg_read(nix_af, NIXX_AF_SQ_CONST());
+	nix_af->rq_ctx_sz = 1ULL << af_const3.s.rq_ctx_log2bytes;
+	nix_af->sq_ctx_sz = 1ULL << af_const3.s.sq_ctx_log2bytes;
+	nix_af->cq_ctx_sz = 1ULL << af_const3.s.cq_ctx_log2bytes;
+	nix_af->rsse_ctx_sz = 1ULL << af_const3.s.rsse_log2bytes;
+	nix_af->qints = af_const2.s.qints;
+	nix_af->cints = af_const2.s.cints;
+	nix_af->cint_ctx_sz = 1ULL << af_const3.s.cint_log2bytes;
+	nix_af->qint_ctx_sz = 1ULL << af_const3.s.qint_log2bytes;
+	nix_af->sqb_size = sq_const.s.sqb_size;
+
+	return 0;
+}
+
+int nix_af_shutdown(struct nix_af *nix_af)
+{
+	union nixx_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&nix_af->aq);
+
+	debug("%s: nix af reset --\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/net/octeontx2/npc.h b/drivers/net/octeontx2/npc.h
new file mode 100644
index 0000000000..a9158a84ee
--- /dev/null
+++ b/drivers/net/octeontx2/npc.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __NPC_H__
+#define __NPC_H__
+
+#define RSVD_MCAM_ENTRIES_PER_PF	2	/** Ucast and Bcast */
+#define RSVD_MCAM_ENTRIES_PER_NIXLF	1	/** Ucast for VFs */
+
+struct npc_kpu_profile_cam {
+	u8 state;
+	u8 state_mask;
+	u16 dp0;
+	u16 dp0_mask;
+	u16 dp1;
+	u16 dp1_mask;
+	u16 dp2;
+	u16 dp2_mask;
+};
+
+struct npc_kpu_profile_action {
+	u8 errlev;
+	u8 errcode;
+	u8 dp0_offset;
+	u8 dp1_offset;
+	u8 dp2_offset;
+	u8 bypass_count;
+	u8 parse_done;
+	u8 next_state;
+	u8 ptr_advance;
+	u8 cap_ena;
+	u8 lid;
+	u8 ltype;
+	u8 flags;
+	u8 offset;
+	u8 mask;
+	u8 right;
+	u8 shift;
+};
+
+struct npc_kpu_profile {
+	int cam_entries;
+	int action_entries;
+	struct npc_kpu_profile_cam *cam;
+	struct npc_kpu_profile_action *action;
+};
+
+struct npc_pkind {
+	struct rsrc_bmap rsrc;
+	u32	*pfchan_map;
+};
+
+struct npc_mcam {
+	struct rsrc_bmap rsrc;
+	u16	*pfvf_map;
+	u16	total_entries; /* Total number of MCAM entries */
+	u16	entries;  /* Total - reserved for NIX LFs */
+	u8	banks_per_entry;  /* Number of keywords in key */
+	u8	keysize;
+	u8	banks;    /* Number of MCAM banks */
+	u16	banksize; /* Number of MCAM entries in each bank */
+	u16	counters; /* Number of match counters */
+	u16	nixlf_offset;
+	u16	pf_offset;
+};
+
+struct nix_af_handle;
+struct nix_handle;
+struct rvu_hwinfo;
+
+struct npc_af {
+	struct nix_af_handle	*nix_af;
+	struct npc_pkind	pkind;
+	void __iomem		*npc_af_base;
+	u8			npc_kpus;	/** Number of parser units */
+	struct npc_mcam		mcam;
+	struct rvu_block	block;
+	struct rvu_hwinfo	*hw;
+};
+
+struct npc {
+	struct npc_af		*npc_af;
+	void __iomem		*npc_base;
+	struct nix_handle	*nix;
+}
+
+#endif /* __NPC_H__ */
diff --git a/drivers/net/octeontx2/rvu.h b/drivers/net/octeontx2/rvu.h
new file mode 100644
index 0000000000..c4af0c8bce
--- /dev/null
+++ b/drivers/net/octeontx2/rvu.h
@@ -0,0 +1,143 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __RVU_H__
+#define __RVU_H__
+
+#include <asm/arch/csrs/csrs-rvu.h>
+
+#define ALIGNED		__aligned(CONFIG_SYS_CACHELINE_SIZE)
+
+/* PCI device IDs */
+#define	PCI_DEVID_OCTEONTX2_CGX			0xA059
+#define	PCI_DEVID_OCTEONTX2_RVU_AF		0xA065
+#define	PCI_DEVID_OCTEONTX2_RVU_PF		0xA063
+#define	PCI_DEVID_OCTEONTX2_RVU_VF		0xA064
+
+/* Maximum number of NIX blocks supported */
+#define MAX_RVU_NIX             2
+
+#define Q_SIZE_16		0ULL /* 16 entries */
+#define Q_SIZE_64		1ULL /* 64 entries */
+#define Q_SIZE_256		2ULL
+#define Q_SIZE_1K		3ULL
+#define Q_SIZE_4K		4ULL
+#define Q_SIZE_16K		5ULL
+#define Q_SIZE_64K		6ULL
+#define Q_SIZE_256K		7ULL
+#define Q_SIZE_1M		8ULL /* Million entries */
+#define Q_SIZE_MIN		Q_SIZE_16
+#define Q_SIZE_MAX		Q_SIZE_1M
+
+#define Q_COUNT(x)		(16ULL << (2 * (x)))
+#define Q_SIZE(x, n)		((ilog2(x) - (n)) / 2)
+
+/* Admin queue info */
+
+/* Since we intend to add only one instruction at a time,
+ * keep queue size to it's minimum.
+ */
+#define AQ_SIZE			Q_SIZE_16
+/* HW head & tail pointer mask */
+#define AQ_PTR_MASK		0xFFFFF
+
+struct qmem {
+	void		*base;
+	dma_addr_t	iova;
+	size_t		alloc_sz;
+	u32		qsize;
+	u8		entry_sz;
+};
+
+struct admin_queue {
+	struct qmem inst;
+	struct qmem res;
+};
+
+struct rvu_af {
+	struct udevice *dev;
+	void __iomem *af_base;
+	struct nix_af *nix_af[MAX_RVU_NIX];
+};
+
+struct rvu_pf {
+	struct udevice *dev;
+	struct udevice *afdev;
+	void __iomem *pf_base;
+	struct nix *nix;
+	u8 pfid;
+	int nix_lfid;
+	int npa_lfid;
+};
+
+/**
+ * Store 128 bit value
+ *
+ * @param[out]	dest	pointer to destination address
+ * @param	val0	first 64 bits to write
+ * @param	val1	second 64 bits to write
+ */
+static inline void st128(void *dest, u64 val0, u64 val1)
+{
+	__asm__ __volatile__("stp %x[x0], %x[x1], [%[pm]]" :
+		: [x0]"r"(val0), [x1]"r"(val1), [pm]"r"(dest)
+		: "memory");
+}
+
+/**
+ * Load 128 bit value
+ *
+ * @param[in]	source		pointer to 128 bits of data to load
+ * @param[out]	val0		first 64 bits of data
+ * @param[out]	val1		second 64 bits of data
+ */
+static inline void ld128(const u64 *src, u64 *val0, u64 *val1)
+{
+	__asm__ __volatile__ ("ldp %x[x0], %x[x1], [%[pm]]" :
+		 : [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
+}
+
+void qmem_free(struct qmem *q);
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz);
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size);
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq);
+
+void rvu_get_lfid_for_pf(int pf, int nix_id, int *nix_lfid, int *npa_lfid);
+
+/**
+ * Reads an RVU PF (BAR2) register.
+ *
+ * @param       base    RVU PF BAR2 base
+ * @param       offset  register address to read (offset into RVU PF BAR2)
+ */
+static inline u64 rvu_bar2_reg_read(void __iomem *bar2_base, u64 offset)
+{
+	u64 val = readq(bar2_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, bar2_base + offset, val);
+	return val;
+}
+
+#endif /* __RVU_H__ */
diff --git a/drivers/net/octeontx2/rvu_af.c b/drivers/net/octeontx2/rvu_af.c
new file mode 100644
index 0000000000..96c2c2b530
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_af.c
@@ -0,0 +1,219 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+#include <asm/arch/csrs/csrs-npa.h>
+#include "nix.h"
+
+struct udevice *rvu_af_dev;
+
+inline struct rvu_af *get_af(void)
+{
+	return rvu_af_dev ? dev_get_priv(rvu_af_dev) : NULL;
+}
+
+void rvu_get_lfid_for_pf(int pf, int nix_id, int *nix_lfid, int *npa_lfid)
+{
+	union nixx_af_rvu_lf_cfg_debug nix_lf_dbg;
+	union npa_af_rvu_lf_cfg_debug npa_lf_dbg;
+	union rvu_pf_func_s pf_func;
+	struct rvu_af *af = dev_get_priv(rvu_af_dev);
+	struct nix_af *nix_af = af->nix_af[nix_id];
+
+	pf_func.u = 0;
+	pf_func.s.pf = pf;
+
+	nix_lf_dbg.u = 0;
+	nix_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	nix_lf_dbg.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_RVU_LF_CFG_DEBUG(),
+			 nix_lf_dbg.u);
+	do {
+		nix_lf_dbg.u = nix_af_reg_read(nix_af,
+					       NIXX_AF_RVU_LF_CFG_DEBUG());
+	} while (nix_lf_dbg.s.exec);
+
+	if (nix_lf_dbg.s.lf_valid)
+		*nix_lfid = nix_lf_dbg.s.lf;
+
+	debug("%s: NIX%d lf_valid %d lf %d\n", __func__, nix_id,
+	      nix_lf_dbg.s.lf_valid, nix_lf_dbg.s.lf);
+
+	npa_lf_dbg.u = 0;
+	npa_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	npa_lf_dbg.s.exec = 1;
+	npa_af_reg_write(nix_af->npa_af, NPA_AF_RVU_LF_CFG_DEBUG(),
+			 npa_lf_dbg.u);
+	do {
+		npa_lf_dbg.u = npa_af_reg_read(nix_af->npa_af,
+					       NPA_AF_RVU_LF_CFG_DEBUG());
+	} while (npa_lf_dbg.s.exec);
+
+	if (npa_lf_dbg.s.lf_valid)
+		*npa_lfid = npa_lf_dbg.s.lf;
+	debug("%s: npa lf_valid %d lf %d\n", __func__,
+	      npa_lf_dbg.s.lf_valid, npa_lf_dbg.s.lf);
+}
+
+struct nix_af *rvu_af_init(struct rvu_af *rvu_af, int nix_id)
+{
+	struct nix_af *nix_af;
+	union rvu_af_addr_s block_addr;
+	int err;
+
+	nix_af = (struct nix_af *)calloc(1, sizeof(struct nix_af));
+	if (!nix_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	nix_af->dev = rvu_af->dev;
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NIXX(nix_id);
+	nix_af->nix_af_base = rvu_af->af_base + block_addr.u;
+
+	/* Allocate an NPA_AF structure for the first NIX_AF.
+	 * Share this NPA_AF pointer amongst all subsequent NIX_AFs
+	 * as only a single NPA AF exists in hardware.
+	 */
+	if (nix_id == 0) {
+		nix_af->npa_af = (struct npa_af *)
+				calloc(1, sizeof(struct npa_af));
+	} else {
+		nix_af->npa_af = rvu_af->nix_af[0]->npa_af;
+	}
+	if (!nix_af->npa_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPA;
+	nix_af->npa_af->npa_af_base = rvu_af->af_base + block_addr.u;
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPC;
+	nix_af->npc_af_base = rvu_af->af_base + block_addr.u;
+
+	/* Only initialize NPA_AF for first NIX_AF instance.
+	 * It is shared amongst all NIX_AF instances (see allocation above).
+	 */
+	if (nix_id == 0) {
+		debug("%s: Setting up npa admin\n", __func__);
+		err = npa_af_setup(nix_af->npa_af);
+		if (err) {
+			printf("%s: Error %d setting up NPA admin\n",
+			       __func__, err);
+			goto error;
+		}
+	}
+
+	debug("%s: Setting up nix af\n", __func__);
+	err = nix_af_setup(nix_af);
+	if (err) {
+		printf("%s: Error %d setting up NIX%d admin\n",
+		       __func__, err, nix_id);
+		goto error;
+	}
+	debug("%s: NIX%d nix_af: %p\n", __func__, nix_id, nix_af);
+	return nix_af;
+
+error:
+	if (nix_af->npa_af) {
+		/* only free the actual allocation (i.e. first one) */
+		if (nix_id == 0) {
+			free(nix_af->npa_af);
+			memset(nix_af, 0, sizeof(*nix_af));
+		}
+	}
+	if (nix_af)
+		free(nix_af);
+	return NULL;
+}
+
+int rvu_af_probe(struct udevice *dev)
+{
+	struct rvu_af *af_ptr = dev_get_priv(dev);
+	union rvu_pf_block_addrx_disc addr_disc;
+	void __iomem *bar2_base;
+	int nix_id, blk;
+
+	af_ptr->af_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					 PCI_REGION_MEM);
+	bar2_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_2,
+				   PCI_REGION_MEM);
+	debug("%s RVU AF BAR0 %p, BAR2 %p\n", __func__, af_ptr->af_base,
+	      bar2_base);
+	af_ptr->dev = dev;
+	rvu_af_dev = dev;
+
+	for (nix_id = 0; nix_id < MAX_RVU_NIX; nix_id++) {
+		/* Verify that this NIX block is implemented in h/w. */
+		blk = RVU_BLOCK_ADDR_E_NIXX(nix_id);
+		addr_disc.u = rvu_bar2_reg_read(bar2_base,
+						RVU_PF_BLOCK_ADDRX_DISC(blk));
+		if (!addr_disc.s.imp)
+			break;
+
+		af_ptr->nix_af[nix_id] = rvu_af_init(af_ptr, nix_id);
+		if (!af_ptr->nix_af) {
+			printf("%s: Error: could not initialize NIX%d AF\n",
+			       __func__, nix_id);
+			return -1;
+		}
+		debug("%s: Initialized NIX%d\n", __func__, nix_id);
+	}
+
+	return 0;
+}
+
+int rvu_af_remove(struct udevice *dev)
+{
+	struct rvu_af *rvu_af = dev_get_priv(dev);
+	struct nix_af *nix_af;
+	int i;
+
+	for (i = MAX_RVU_NIX - 1; (int)i >= 0; i--) {
+		nix_af = rvu_af->nix_af[i];
+		if (!nix_af)
+			continue;
+		nix_af_shutdown(nix_af);
+
+		/* Only a single instance of NPA & NPC exists in h/w. */
+		if (i != 0)
+			continue;
+		npa_af_shutdown(nix_af->npa_af);
+		npc_af_shutdown(nix_af);
+	}
+
+	debug("%s: rvu af down --\n", __func__);
+	return 0;
+}
+
+U_BOOT_DRIVER(rvu_af) = {
+	.name   = "rvu_af",
+	.id     = UCLASS_MISC,
+	.probe  = rvu_af_probe,
+	.remove = rvu_af_remove,
+	.priv_auto_alloc_size = sizeof(struct rvu_af),
+};
+
+static struct pci_device_id rvu_af_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(rvu_af, rvu_af_supported);
diff --git a/drivers/net/octeontx2/rvu_common.c b/drivers/net/octeontx2/rvu_common.c
new file mode 100644
index 0000000000..02ad27bebe
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_common.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+
+#include "rvu.h"
+
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz)
+{
+	q->base = memalign(CONFIG_SYS_CACHELINE_SIZE, qsize * entry_sz);
+	if (!q->base)
+		return -ENOMEM;
+	q->entry_sz = entry_sz;
+	q->qsize = qsize;
+	q->alloc_sz = (size_t)qsize * entry_sz;
+	q->iova = (dma_addr_t)(q->base);
+	debug("NIX: qmem alloc for (%d * %d = %ld bytes) at %p\n",
+	      q->qsize, q->entry_sz, q->alloc_sz, q->base);
+	return 0;
+}
+
+void qmem_free(struct qmem *q)
+{
+	if (q->base)
+		free(q->base);
+	memset(q, 0, sizeof(*q));
+}
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size)
+{
+	int err;
+
+	err = qmem_alloc(&aq->inst, qsize, inst_size);
+	if (err)
+		return err;
+	err = qmem_alloc(&aq->res, qsize, res_size);
+	if (err)
+		qmem_free(&aq->inst);
+
+	return err;
+}
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq)
+{
+	qmem_free(&aq->inst);
+	qmem_free(&aq->res);
+	memset(aq, 0, sizeof(*aq));
+}
diff --git a/drivers/net/octeontx2/rvu_pf.c b/drivers/net/octeontx2/rvu_pf.c
new file mode 100644
index 0000000000..02241d9a5e
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_pf.c
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <asm/arch/board.h>
+#include "cgx.h"
+#include "nix.h"
+
+extern struct udevice *rvu_af_dev;
+
+int rvu_pf_init(struct rvu_pf *rvu, int nix_id)
+{
+	struct nix *nix;
+	struct eth_pdata *pdata = dev_get_platdata(rvu->dev);
+
+	debug("%s: Allocating nix%d lf\n", __func__, nix_id);
+	nix = nix_lf_alloc(rvu->dev, nix_id);
+	if (!nix) {
+		printf("%s: Error allocating lf for pf %d\n",
+		       __func__, rvu->pfid);
+		return -1;
+	}
+	rvu->nix = nix;
+
+	/* to make post_probe happy */
+	if (is_valid_ethaddr(nix->lmac->mac_addr)) {
+		memcpy(pdata->enetaddr, nix->lmac->mac_addr, 6);
+		eth_env_set_enetaddr_by_index("eth", rvu->dev->seq,
+					      pdata->enetaddr);
+	}
+
+	return 0;
+}
+
+static const struct eth_ops nix_eth_ops = {
+	.start			= nix_lf_init,
+	.send			= nix_lf_xmit,
+	.recv			= nix_lf_recv,
+	.free_pkt		= nix_lf_free_pkt,
+	.stop			= nix_lf_halt,
+	.write_hwaddr		= nix_lf_setup_mac,
+};
+
+int rvu_pf_probe(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct lmac *cgx_lmac;
+	int err, nix_id;
+	char name[16];
+
+	debug("%s: name: %s\n", __func__, dev->name);
+
+	rvu->pf_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_2, PCI_REGION_MEM);
+	rvu->pfid = dev->seq + 1; // RVU PF's start from 1;
+	rvu->dev = dev;
+	if (!rvu_af_dev) {
+		printf("%s: Error: Could not find RVU AF device\n",
+		       __func__);
+		return -1;
+	}
+	rvu->afdev = rvu_af_dev;
+
+	/* Retrieve the NIX ID from the LMAC pointer. */
+	cgx_lmac = nix_get_cgx_lmac(rvu->pfid);
+	if (!cgx_lmac) {
+		printf("RVU PF%d: cannot locate LMAC, unknown NIX ID\n",
+		       rvu->pfid);
+		return -1;
+	}
+
+	switch (cgx_lmac->p2x_sel) {
+	case P2X1_NIX0:
+	case P2X2_NIX1:
+		nix_id = cgx_lmac->p2x_sel - P2X1_NIX0;
+		break;
+	default:
+		printf("RVU PF%d: invalid LMAC P2X_SEL %d, unknown NIX ID\n",
+		       rvu->pfid, (int)cgx_lmac->p2x_sel);
+		return -1;
+	}
+
+	debug("RVU PF%d: using NIX%d\n", rvu->pfid, nix_id);
+
+	rvu_get_lfid_for_pf(rvu->pfid, nix_id, &rvu->nix_lfid, &rvu->npa_lfid);
+
+	err = rvu_pf_init(rvu, nix_id);
+	if (err)
+		printf("%s: Error %d adding nix\n", __func__, err);
+
+	/*
+	 * modify device name to include index/sequence number,
+	 * for better readability, this is 1:1 mapping with eth0/1/2.. names.
+	 */
+	sprintf(name, "rvu_pf#%d", dev->seq);
+	device_set_name(dev, name);
+	debug("%s: name: %s\n", __func__, dev->name);
+	return err;
+}
+
+int rvu_pf_remove(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+
+	nix_lf_shutdown(rvu->nix);
+	npa_lf_shutdown(rvu->nix);
+
+	debug("%s: rvu pf%d down --\n", __func__,  rvu->pfid);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(rvu_pf) = {
+	.name   = "rvu_pf",
+	.id     = UCLASS_ETH,
+	.probe	= rvu_pf_probe,
+	.remove = rvu_pf_remove,
+	.ops    = &nix_eth_ops,
+	.priv_auto_alloc_size = sizeof(struct rvu_pf),
+	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
+};
+
+static struct pci_device_id rvu_pf_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_PF) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(rvu_pf, rvu_pf_supported);
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 2a3da068c9..3b46ab87a2 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -5,6 +5,15 @@ config BITBANGMII
 config MV88E6352_SWITCH
 	bool "Marvell 88E6352 switch support"
 
+config MV88E6XXX_SWITCH
+	bool "Marvel 88E6xxx switch support"
+	select PHYLIB
+	help
+	  Initialize peridot(MV88E6390/290/190) and topaz(MV88E6341/141)
+	  switches connected to SOC. This driver provide basic functionality
+	  like switch info, read/write switch and phy registers, get link
+	  status etc.
+
 menuconfig PHYLIB
 	bool "Ethernet PHY (physical media interface) support"
 	depends on NET
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 555da83630..5d02ea6eed 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_BITBANGMII) += miiphybb.o
 obj-$(CONFIG_B53_SWITCH) += b53.o
 obj-$(CONFIG_MV88E61XX_SWITCH) += mv88e61xx.o
 obj-$(CONFIG_MV88E6352_SWITCH) += mv88e6352.o
+obj-$(CONFIG_MV88E6XXX_SWITCH) += mv88e6xxx.o
 
 obj-$(CONFIG_PHYLIB) += phy.o
 obj-$(CONFIG_PHYLIB_10G) += generic_10g.o
@@ -30,3 +31,4 @@ obj-$(CONFIG_PHY_XILINX) += xilinx_phy.o
 obj-$(CONFIG_PHY_VITESSE) += vitesse.o
 obj-$(CONFIG_PHY_MSCC) += mscc.o
 obj-$(CONFIG_PHY_FIXED) += fixed.o
+obj-$(CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD) += mvebu_fw_download.o
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index efbbd31ff7..144ff228b8 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -6,6 +6,7 @@
  * author Andy Fleming
  */
 #include <common.h>
+#include <console.h>
 #include <errno.h>
 #include <phy.h>
 
@@ -102,6 +103,17 @@
 #define MIIM_88E151x_MODE_SGMII		1
 #define MIIM_88E151x_RESET_OFFS		15
 
+/* 88E2110 PHY defines */
+#define MIIM_88E2110_PHY_STATUS		0x8008
+#define MIIM_88E2110_PHYSTAT_SPEED	0xc00c
+#define MIIM_88E2110_PHYSTAT_GBIT	0x8000
+#define MIIM_88E2110_PHYSTAT_100	0x4000
+#define MIIM_88E2110_PHYSTAT_DUPLEX	0x2000
+#define MIIM_88E2110_PHYSTAT_SPDDONE	0x0800
+#define MIIM_88E2110_PHYSTAT_LINK	0x0400
+#define MIIM_88E2110_PHYSTAT_5GBIT	0xc008
+#define MIIM_88E2110_PHYSTAT_2_5GBIT	0xc004
+
 static int m88e1xxx_phy_extread(struct phy_device *phydev, int addr,
 				int devaddr, int regnum)
 {
@@ -331,7 +343,7 @@ static int m88e1518_config(struct phy_device *phydev)
 	 * As per Marvell Release Notes - Alaska 88E1510/88E1518/88E1512
 	 * /88E1514 Rev A0, Errata Section 3.1
 	 */
-
+	debug("%s(%s)\n", __func__, phydev->dev->name);
 	/* EEE initialization */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE, 0x00ff);
 	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x214B);
@@ -404,6 +416,7 @@ static int m88e1518_config(struct phy_device *phydev)
 /* Marvell 88E1510 */
 static int m88e1510_config(struct phy_device *phydev)
 {
+	debug("%s(%s)\n", __func__, phydev->dev->name);
 	/* Select page 3 */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE,
 		  MIIM_88E1118_PHY_LED_PAGE);
@@ -424,8 +437,72 @@ static int m88e1510_config(struct phy_device *phydev)
 
 	/* Reset page selection */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE, 0);
+	debug("%s: interface mode: %s\n", __func__,
+	      phy_string_for_interface(phydev->interface));
+	/* SGMII-to-Copper mode initialization (88E1512 & 88E1514 only) */
+	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+		/* Select page 18 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 18);
 
-	return m88e1518_config(phydev);
+		/* In reg 20, write MODE[2:0] = 0x1 (SGMII to Copper) */
+		m88e1518_phy_writebits(phydev, 20, 0, 3, 1);
+
+		/* PHY reset is necessary after changing MODE[2:0] */
+		m88e1518_phy_writebits(phydev, 20, 15, 1, 1);
+
+		/* Reset page selection */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII      ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_ID   ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+		/* RGMII-to-Copper mode initialization */
+
+		/* Select page 2 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 2);
+		/* Set rx and tx delay as needed */
+		switch (phydev->interface) {
+		default:
+		case PHY_INTERFACE_MODE_RGMII:	/* no delay */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 0);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_ID:	/* delay both */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 3);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_RXID:	/* delay rx */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 2);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_TXID:	/* delay tx */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 1);
+			break;
+		}
+		/* Select page 18 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 18);
+
+		/* In reg 20, write MODE[2:0] = 0x1 (RGMII to Copper) */
+		m88e1518_phy_writebits(phydev, 20, 0, 3, 0);
+
+		/* PHY reset is necessary after changing MODE[2:0] */
+		m88e1518_phy_writebits(phydev, 20, 15, 1, 1);
+
+		/* Reset page selection */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	} else {
+		printf("%s(%s): Error: unsupported mode %s\n", __func__,
+		       phydev->dev->name,
+		       phy_string_for_interface(phydev->interface));
+		return -1;
+	}
+
+	udelay(100);
+
+	/* soft reset */
+	phy_reset(phydev);
+
+	genphy_config_aneg(phydev);
+	genphy_restart_aneg(phydev);
+
+	return 0;
 }
 
 /* Marvell 88E1118 */
@@ -615,6 +692,182 @@ static int m88e1680_config(struct phy_device *phydev)
 	return 0;
 }
 
+/* Marvell 88E2110 */
+static int m88e2110_probe(struct phy_device *phydev)
+{
+	/*
+	 * skip reset since phy has its own initial value.
+	 * resettting leads to weird behavior
+	 */
+	phydev->flags |= PHY_FLAG_BROKEN_RESET;
+
+	return 0;
+}
+
+static int m88e2110_config(struct phy_device *phydev)
+{
+	u16 reg;
+	ofnode node = phy_get_ofnode(phydev);
+
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
+	if (ofnode_read_bool(node, "enet-phy-lane-swap")) {
+		/* Perform lane swap */
+		reg = phy_read(phydev, 1, 0xc000);
+		reg |= 0x1;
+		phy_write(phydev, 1, 0xc000, reg);
+	}
+
+	/* Configure auto-negotiation advertisement */
+	if (phydev->interface == PHY_INTERFACE_MODE_SFI) {
+		/* Disabled 10G advertisement */
+		phy_write(phydev, 7, 0x20, 0x1e1);
+	} else {
+		if (phydev->interface == PHY_INTERFACE_MODE_SGMII_2500 ||
+		    phydev->interface == PHY_INTERFACE_MODE_2500BASEX) {
+			/* Disabled 10G/5G advertisements */
+			phy_write(phydev, 7, 0x20, 0xa1);
+		} else {
+			/* Disable 10G/5G/2.5G auto-negotiation advertisement */
+			phy_write(phydev, 7, 0x20, 0x1);
+		}
+	}
+
+	/* Restart auto-negotiation */
+	phy_write(phydev, 7, 0, 0x3200);
+
+	return 0;
+}
+
+/* Parse the 88E2110's status register for speed and duplex
+ * information
+ */
+static uint m88e2110_parse_status(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, 3, MIIM_88E2110_PHY_STATUS);
+
+	if (!(mii_reg & MIIM_88E2110_PHYSTAT_LINK)) {
+		int i = 0;
+
+		puts("Waiting for PHY realtime link");
+		while (!(mii_reg & MIIM_88E2110_PHYSTAT_LINK)) {
+			/* Timeout reached ? */
+			if (i > PHY_AUTONEGOTIATE_TIMEOUT) {
+				puts(" TIMEOUT !\n");
+				phydev->link = 0;
+				break;
+			}
+
+			if ((i++ % 1000) == 0)
+				putc('.');
+			udelay(1000);
+			mii_reg = phy_read(phydev, 3, MIIM_88E2110_PHY_STATUS);
+		}
+		puts(" done\n");
+		mdelay(500);	/* another 500 ms (results in faster booting) */
+	}
+
+	if (mii_reg & MIIM_88E2110_PHYSTAT_LINK)
+		phydev->link = 1;
+	else
+		phydev->link = 0;
+
+	if (mii_reg & MIIM_88E2110_PHYSTAT_DUPLEX)
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	switch (mii_reg & MIIM_88E2110_PHYSTAT_SPEED) {
+	case MIIM_88E2110_PHYSTAT_5GBIT:
+		phydev->speed = SPEED_5000;
+		break;
+	case MIIM_88E2110_PHYSTAT_2_5GBIT:
+		phydev->speed = SPEED_2500;
+		break;
+	case MIIM_88E2110_PHYSTAT_GBIT:
+		phydev->speed = SPEED_1000;
+		break;
+	case MIIM_88E2110_PHYSTAT_100:
+		phydev->speed = SPEED_100;
+		break;
+	default:
+		phydev->speed = SPEED_10;
+		break;
+	}
+
+	return 0;
+}
+
+static int m88e2110_update_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	/*
+	 * Wait if the link is up, and autonegotiation is in progress
+	 * (ie - we're capable and it's not done)
+	 */
+	mii_reg = phy_read(phydev, 7, MII_BMSR);
+
+	/*
+	 * If we already saw the link up, and it hasn't gone down, then
+	 * we don't need to wait for autoneg again
+	 */
+	if (phydev->link && mii_reg & BMSR_LSTATUS)
+		return 0;
+
+	if ((mii_reg & BMSR_ANEGCAPABLE) && !(mii_reg & BMSR_ANEGCOMPLETE)) {
+		int i = 0;
+
+		debug("%s Waiting for PHY auto negotiation to complete",
+		      phydev->drv->name);
+		while (!(mii_reg & BMSR_ANEGCOMPLETE)) {
+			/*
+			 * Timeout reached ?
+			 */
+			if (i > PHY_ANEG_TIMEOUT) {
+				debug(" TIMEOUT !\n");
+				phydev->link = 0;
+				return 0;
+			}
+
+			if (ctrlc()) {
+				puts("user interrupt!\n");
+				phydev->link = 0;
+				return -EINTR;
+			}
+
+			if ((i++ % 500) == 0)
+				debug(".");
+
+			udelay(1000);	/* 1 ms */
+			mii_reg = phy_read(phydev, 7, MII_BMSR);
+		}
+		debug(" done\n");
+		phydev->link = 1;
+	} else {
+		/* Read the link a second time to clear the latched state */
+		mii_reg = phy_read(phydev, 7, MII_BMSR);
+
+		if (mii_reg & BMSR_LSTATUS)
+			phydev->link = 1;
+		else
+			phydev->link = 0;
+	}
+
+	return 0;
+}
+
+static int m88e2110_startup(struct phy_device *phydev)
+{
+	m88e2110_update_link(phydev);
+	m88e2110_parse_status(phydev);
+
+	return 0;
+}
+
 static struct phy_driver M88E1011S_driver = {
 	.name = "Marvell 88E1011S",
 	.uid = 0x1410c60,
@@ -734,6 +987,17 @@ static struct phy_driver M88E1680_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
+static struct phy_driver M88E2110_driver = {
+	.name = "Marvell 88E2110",
+	.uid = 0x2b09b8,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.probe = &m88e2110_probe,
+	.config = &m88e2110_config,
+	.startup = &m88e2110_startup,
+	.shutdown = &genphy_shutdown,
+};
+
 int phy_marvell_init(void)
 {
 	phy_register(&M88E1310_driver);
@@ -747,6 +1011,7 @@ int phy_marvell_init(void)
 	phy_register(&M88E1510_driver);
 	phy_register(&M88E1518_driver);
 	phy_register(&M88E1680_driver);
+	phy_register(&M88E2110_driver);
 
 	return 0;
 }
diff --git a/drivers/net/phy/mv88e6xxx.c b/drivers/net/phy/mv88e6xxx.c
new file mode 100644
index 0000000000..e58669d7c4
--- /dev/null
+++ b/drivers/net/phy/mv88e6xxx.c
@@ -0,0 +1,604 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "mv88e6xxx.h"
+/* If the switch's ADDR[4:0] strap pins are strapped to zero, it will
+ * use all 32 SMI bus addresses on its SMI bus, and all switch registers
+ * will be directly accessible on some {device address,register address}
+ * pair.  If the ADDR[4:0] pins are not strapped to zero, the switch
+ * will only respond to SMI transactions to that specific address, and
+ * an indirect addressing mechanism needs to be used to access its
+ * registers.
+ */
+
+static struct mv88e6xxx_dev soho_dev;
+static struct mv88e6xxx_dev *soho_dev_handle;
+static int REG_PORT_BASE = REG_PORT_BASE_UNDEFINED;
+
+static int mv88e6xxx_reg_wait_ready(struct mv88e6xxx_dev *dev)
+{
+	int ret;
+	int i;
+	int loop_timeout = 16;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = miiphy_read(name, dev->phy_addr, SMI_CMD, &val);
+		if (ret < 0)
+			return ret;
+		if ((val & SMI_CMD_BUSY) == 0)
+			return 0;
+	}
+
+	return -ETIMEDOUT;
+}
+
+int mv88e6xxx_read_register(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0) {
+		ret = miiphy_read(name, port, reg, &val);
+		if (ret < 0)
+			return ret;
+		else
+			return (int)val;
+	}
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the read command. */
+	ret = miiphy_write(
+		name, dev->phy_addr, SMI_CMD,
+		SMI_CMD_OP_22_READ |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Read the data. */
+	ret = miiphy_read(name, dev->phy_addr, SMI_DATA, &val);
+	if (ret < 0)
+		return ret;
+
+	return (int)val;
+}
+
+int mv88e6xxx_write_register(struct mv88e6xxx_dev *dev, int port, int reg,
+			     unsigned short val)
+{
+	int ret;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0)
+		return miiphy_write(name, port, reg, val);
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit data to write. */
+	ret = miiphy_write(name, dev->phy_addr, SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the write command. */
+	ret = miiphy_write(
+		name, dev->phy_addr, SMI_CMD,
+		SMI_CMD_OP_22_WRITE |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mv88e6xxx_reg_wait_ready_indirect(struct mv88e6xxx_dev *dev)
+{
+	int ret, i;
+	int loop_timeout = 16;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP);
+		if (ret < 0)
+			return ret;
+		if (!(ret & GLOBAL2_SMI_OP_BUSY))
+			return 0;
+	}
+	return -ETIMEDOUT;
+}
+
+static int mv88e6xxx_read_indirect(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(
+		dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+		GLOBAL2_SMI_OP_22_READ |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_reg_wait_ready_indirect(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA);
+
+	return ret;
+}
+
+static int mv88e6xxx_write_indirect(struct mv88e6xxx_dev *dev, int port,
+				    int reg, unsigned short val)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_write_register(
+		dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+		GLOBAL2_SMI_OP_22_WRITE |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+
+	return mv88e6xxx_reg_wait_ready_indirect(dev);
+}
+
+int mv88e6xxx_read_phy_register(struct mv88e6xxx_dev *dev, int port, int page,
+				int reg)
+{
+	int ret;
+
+	if (!dev)
+		return -ENODEV;
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret < 0)
+		goto restore_page_0;
+
+	ret = mv88e6xxx_read_indirect(dev, port, reg);
+
+restore_page_0:
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+int mv88e6xxx_write_phy_register(struct mv88e6xxx_dev *dev, int port, int page,
+				 int reg, unsigned short val)
+{
+	int ret;
+
+	if (!dev) {
+		printf("Soho dev not initialized\n");
+		return -1;
+	}
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret < 0)
+		goto restore_page_0;
+
+	ret = mv88e6xxx_write_indirect(dev, port, reg, val);
+
+restore_page_0:
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+void mv88e6xxx_display_switch_info(struct mv88e6xxx_dev *dev)
+{
+	unsigned int product_num;
+
+	if (dev->id < 0) {
+		printf("No Switch Device Found\n");
+		return;
+	}
+
+	product_num = ((unsigned int)dev->id) >> 4;
+	if (product_num == PORT_SWITCH_ID_PROD_NUM_6390 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6390X ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6290 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6190) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Peridot\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+		if (dev->cpu_port != -1)
+			printf("Cpu port  : %d\n", dev->cpu_port);
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Topaz\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+		if (dev->cpu_port != -1)
+			printf("Cpu port  : %d\n", dev->cpu_port);
+	} else {
+		printf("Unknown switch with Device ID: 0x%X\n", dev->id);
+	}
+}
+
+/* We expect the switch to perform auto negotiation if there is a real phy. */
+int mv88e6xxx_get_link_status(struct mv88e6xxx_dev *dev, int port)
+{
+	int ret;
+
+	ret = mv88e6xxx_read_register(dev, REG_PORT(port), PORT_STATUS);
+	if (ret < 0)
+		return ret;
+
+	printf("Port: 0x%X, ", port);
+	if (ret & PORT_STATUS_LINK) {
+		printf("Link: UP, ");
+	} else {
+		printf("Link: Down\n");
+		return 0;
+	}
+
+	if (ret & PORT_STATUS_DUPLEX)
+		printf("Duplex: FULL, ");
+	else
+		printf("Duplex: HALF, ");
+
+	if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_10)
+		printf("Speed: 10 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_100)
+		printf("Speed: 100 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_1000)
+		printf("Speed: 1000 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_2500_10G)
+		printf("Speed: 10 Gb or 2500 Mbps\n");
+	else
+		printf("Speed: Unknown\n");
+
+	return 0;
+}
+
+int mv88e6xxx_get_switch_id(struct mv88e6xxx_dev *dev)
+{
+	int id, product_num;
+
+	/* Peridot switch port device address starts from 0
+	 * Legacy switch port device address starts from 0x10
+	 *
+	 * In order to determine which switch is used, we need to
+	 * read the ID, but inorder to read the ID, we need to know
+	 * the port device address - classic chicken or the egg case.
+	 *
+	 * Let's read with both port device addresses, if we get 0xFFFF,
+	 * the address is incorrect and we need to ready with the second
+	 * address.
+	 */
+	id = mv88e6xxx_read_register(dev, REG_PORT_BASE_LEGACY, PORT_SWITCH_ID);
+	if (id == 0xFFFF)
+		id = mv88e6xxx_read_register(dev, REG_PORT_BASE_PERIDOT,
+					     PORT_SWITCH_ID);
+
+	if (id < 0)
+		return id;
+
+	product_num = id >> 4;
+	if ((product_num == PORT_SWITCH_ID_PROD_NUM_6190) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6290) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6390) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6390X)) {
+		/* Peridot switch port device address starts from 0 */
+		REG_PORT_BASE = REG_PORT_BASE_PERIDOT;
+		return id;
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		/* Legacy switch port device address starts from 0x10 */
+		REG_PORT_BASE = REG_PORT_BASE_LEGACY;
+		return id;
+	} else {
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+int mv88e6xxx_initialize(const void *blob)
+{
+	int node = 0;
+	int ret;
+	int port;
+
+	soho_dev_handle = NULL;
+
+	/* Read Device Tree */
+	node = fdt_node_offset_by_compatible(blob, -1, "marvell,mv88e6xxx");
+
+	if (node == -FDT_ERR_NOTFOUND)
+		return -ENXIO;
+
+	/* Check whether switch node is enabled */
+	ret = fdtdec_get_is_enabled(blob, node);
+	if (ret == 0)
+		return -EACCES;
+
+	/* Initizalize Switch Device Structure */
+	soho_dev.phy_addr = fdtdec_get_uint(blob, node, "phy-addr", 0);
+	soho_dev.port_mask = fdtdec_get_int(blob, node, "port-mask", 0);
+	if (soho_dev.phy_addr == 0)
+		soho_dev.addr_mode = 0;  /* Single Addressing mode */
+	else
+		soho_dev.addr_mode = 1;  /* Multi Addressing mode */
+
+	soho_dev.id = mv88e6xxx_get_switch_id(&soho_dev);
+
+	soho_dev.cpu_port = fdtdec_get_int(blob, node, "cpu-port", -1);
+	if (soho_dev.cpu_port != -1) {
+		u16 reg;
+
+		/* For 88e6390X switch we need to configure C_MODE field
+		 * in Port Status Register to 0xb (2500 base-x).
+		 * NOTE: Port Status Register is generally RO, but it can
+		 * be written for port9 and port10 (cpu ports).
+		 */
+		if ((soho_dev.id >> 4) == PORT_SWITCH_ID_PROD_NUM_6390X) {
+			reg = mv88e6xxx_read_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_STATUS);
+			reg &= ~PORT_STATUS_CMODE_MASK;
+			reg |= PORT_STATUS_CMODE_2500BASE_X;
+			ret = mv88e6xxx_write_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_STATUS, reg);
+		} else {
+			reg = mv88e6xxx_read_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_PCS_CTRL);
+			/* CPU port is forced link-up, duplex and 1GB speed */
+			reg &= ~PORT_PCS_CTRL_UNFORCED;
+			reg |= PORT_PCS_CTRL_FORCE_LINK |
+			       PORT_PCS_CTRL_LINK_UP |
+			       PORT_PCS_CTRL_DUPLEX_FULL |
+			       PORT_PCS_CTRL_FORCE_DUPLEX |
+			       PORT_PCS_CTRL_1000;
+
+			if ((soho_dev.id >> 4) ==
+			    PORT_SWITCH_ID_PROD_NUM_6341) {
+				/* Configure RGMII Delay on cpu port */
+				reg |= PORT_PCS_CTRL_FORCE_SPEED |
+				       PORT_PCS_CTRL_RGMII_DELAY_TXCLK |
+				       PORT_PCS_CTRL_RGMII_DELAY_RXCLK;
+			}
+
+			ret = mv88e6xxx_write_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_PCS_CTRL, reg);
+		}
+
+		if (ret)
+			return ret;
+	}
+
+	/* Force port setup */
+	for (port = 0; port < sizeof(soho_dev.port_mask) * 8; port++) {
+		if (!(soho_dev.port_mask & BIT(port)))
+			continue;
+
+		/* Set port control register */
+		mv88e6xxx_write_register(&soho_dev,
+					 REG_PORT(port),
+					 PORT_CONTROL,
+					 PORT_CONTROL_STATE_FORWARDING |
+					 PORT_CONTROL_FORWARD_UNKNOWN |
+					 PORT_CONTROL_FORWARD_UNKNOWN_MC |
+					 PORT_CONTROL_USE_TAG |
+					 PORT_CONTROL_USE_IP |
+					 PORT_CONTROL_TAG_IF_BOTH);
+		/* Set port based vlan table */
+		mv88e6xxx_write_register(&soho_dev,
+					 REG_PORT(port),
+					 PORT_BASE_VLAN,
+					 soho_dev.port_mask & ~BIT(port));
+
+		if (port == soho_dev.cpu_port)
+			continue;
+
+		/* Set phy copper control for lan ports */
+		mv88e6xxx_write_phy_register(&soho_dev,
+					     REG_PORT(port),
+					     0,
+					     PHY_COPPER_CONTROL,
+					     PHY_COPPER_CONTROL_SPEED_1G |
+					     PHY_COPPER_CONTROL_DUPLEX |
+					     PHY_COPPER_CONTROL_AUTO_NEG_EN);
+	}
+
+	soho_dev_handle = &soho_dev;
+
+	return 0;
+}
+
+static int sw_resolve_options(char *str)
+{
+	if (strcmp(str, "info") == 0)
+		return SW_INFO;
+	else if (strcmp(str, "read") == 0)
+		return SW_READ;
+	else if (strcmp(str, "write") == 0)
+		return SW_WRITE;
+	else if (strcmp(str, "phy_read") == 0)
+		return SW_PHY_READ;
+	else if (strcmp(str, "phy_write") == 0)
+		return SW_PHY_WRITE;
+	else if (strcmp(str, "link") == 0)
+		return SW_LINK;
+	else
+		return SW_NA;
+}
+
+static int do_sw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct mv88e6xxx_dev *dev;
+	int port, reg, page, val = 0, ret = 0;
+
+	dev = soho_dev_handle;
+
+	if (!dev) {
+		printf("Switch Device not found\n");
+		return -ENODEV;
+	}
+
+	switch (sw_resolve_options(argv[1])) {
+	case SW_INFO:
+		mv88e6xxx_display_switch_info(dev);
+		break;
+	case SW_READ:
+		if (argc < 4) {
+			printf("Syntax Error: switch read <port> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		reg  = (int)simple_strtoul(argv[3], NULL, 16);
+		ret = mv88e6xxx_read_register(dev, REG_PORT(port), reg);
+		if (ret < 0) {
+			printf("Failed: Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, ret: %d\n", reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n", reg, ret);
+		}
+		break;
+
+	case SW_WRITE:
+		if (argc < 5) {
+			printf("Syntax Error: ");
+			printf("switch write <port> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		reg  = (int)simple_strtoul(argv[3], NULL, 16);
+		val  = (int)simple_strtoul(argv[4], NULL, 16);
+		ret = mv88e6xxx_write_register(dev, REG_PORT(port), reg,
+					       (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X, ret: %d\n",
+			       reg, val, ret);
+		} else {
+			printf("Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n",
+			       reg, val);
+		}
+		break;
+
+	case SW_PHY_READ:
+		if (argc < 5) {
+			printf("Syntax Error: ");
+			printf("switch phy_read <port> <page> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		page = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		ret = mv88e6xxx_read_phy_register(dev, REG_PORT(port),
+						  page, reg);
+		if (ret < 0) {
+			printf("Failed: Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X\n, ret: %d",
+			       page, reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, ret);
+		}
+		break;
+
+	case SW_PHY_WRITE:
+		if (argc < 6) {
+			printf("Syntax Error: ");
+			printf("switch phy_write <port> <page> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		page = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		val  = (int)simple_strtoul(argv[5], NULL, 16);
+		ret = mv88e6xxx_write_phy_register(dev, REG_PORT(port),
+						   page, reg,
+						   (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X, ret: %d\n",
+			       page, reg, val, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, val);
+		}
+		break;
+
+	case SW_LINK:
+		if (argc < 3) {
+			printf("Error: Too few arguments\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		ret = mv88e6xxx_get_link_status(dev, port);
+		break;
+
+	case SW_NA:
+		printf("\"switch %s\" - Wrong command. Try \"help switch\"\n",
+		       argv[1]);
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+/***************************************************/
+U_BOOT_CMD(
+	switch,	6,	1,	do_sw,
+	"Switch Access commands",
+	"switch info - Display switch information\n"
+	"switch read <port> <reg> - read switch register <reg> of a <port>\n"
+	"switch write <port> <reg> <val> - write <val> to switch register <reg> of a <port>\n"
+	"switch phy_read <port> <page> <reg> - read internal switch phy register <reg> at <page> of a switch <port>\n"
+	"switch phy_write <port> <page> <reg> <val>- write <val> to internal phy register at <page> of a <port>\n"
+	"switch link <port> - Display link state and speed of a <port>\n"
+);
diff --git a/drivers/net/phy/mv88e6xxx.h b/drivers/net/phy/mv88e6xxx.h
new file mode 100644
index 0000000000..453cfa584f
--- /dev/null
+++ b/drivers/net/phy/mv88e6xxx.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MV88E6XXX_H__
+#define _MV88E6XXX_H__
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <config/arch/mvebu.h>
+#include <fdtdec.h>
+#include <fdt.h>
+#include <linux/compat.h>
+#include <linux/mbus.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <net.h>
+#include <netdev.h>
+#include <pci.h>
+#include <phy.h>
+#include <watchdog.h>
+
+#define SMI_CMD					0x00
+#define SMI_CMD_BUSY				BIT(15)
+#define SMI_CMD_CLAUSE_22			BIT(12)
+#define SMI_CMD_OP_22_WRITE			\
+			((1 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_22_READ			\
+			((2 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_45_WRITE_ADDR		((0 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_WRITE_DATA		((1 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA			((2 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA_INC		((3 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_DEV_ADDR_MASK			0x1f
+#define SMI_CMD_DEV_ADDR_SIZE			5
+#define SMI_CMD_REG_ADDR_MASK			0x1f
+#define SMI_DATA				0x01
+
+#define SMI_PHY_PAGE_REG			0x16
+
+/* Fiber/SERDES Registers are located at SMI address F, page 1 */
+#define REG_FIBER_SERDES			0x0f
+#define PAGE_FIBER_SERDES			0x01
+
+#define REG_PORT_BASE_UNDEFINED			0xFFFF
+#define REG_PORT_BASE_LEGACY			0x10
+#define REG_PORT_BASE_PERIDOT			0
+#define REG_PORT(p)				(REG_PORT_BASE + (p))
+#define PORT_STATUS				0x00
+#define PORT_STATUS_PAUSE_EN			BIT(15)
+#define PORT_STATUS_MY_PAUSE			BIT(14)
+#define PORT_STATUS_HD_FLOW			BIT(13)
+#define PORT_STATUS_PHY_DETECT			BIT(12)
+#define PORT_STATUS_LINK			BIT(11)
+#define PORT_STATUS_DUPLEX			BIT(10)
+#define PORT_STATUS_SPEED_MASK			0x0300
+#define PORT_STATUS_SPEED_10			0x0000
+#define PORT_STATUS_SPEED_100			0x0100
+#define PORT_STATUS_SPEED_1000			0x0200
+#define PORT_STATUS_SPEED_2500_10G		0x0300
+#define PORT_STATUS_EEE				BIT(6) /* 6352 */
+#define PORT_STATUS_AM_DIS			BIT(6) /* 6165 */
+#define PORT_STATUS_MGMII			BIT(6) /* 6185 */
+#define PORT_STATUS_TX_PAUSED			BIT(5)
+#define PORT_STATUS_FLOW_CTRL			BIT(4)
+#define PORT_STATUS_CMODE_MASK			0x0f
+#define PORT_STATUS_CMODE_100BASE_X		0x8
+#define PORT_STATUS_CMODE_1000BASE_X		0x9
+#define PORT_STATUS_CMODE_SGMII			0xa
+#define PORT_STATUS_CMODE_2500BASE_X		0xb
+#define PORT_PCS_CTRL				0x01
+#define PORT_PCS_CTRL_RGMII_DELAY_RXCLK		BIT(15)
+#define PORT_PCS_CTRL_RGMII_DELAY_TXCLK		BIT(14)
+#define PORT_PCS_CTRL_FORCE_SPEED		BIT(13)
+#define PORT_PCS_CTRL_FC			BIT(7)
+#define PORT_PCS_CTRL_FORCE_FC			BIT(6)
+#define PORT_PCS_CTRL_LINK_UP			BIT(5)
+#define PORT_PCS_CTRL_FORCE_LINK		BIT(4)
+#define PORT_PCS_CTRL_DUPLEX_FULL		BIT(3)
+#define PORT_PCS_CTRL_FORCE_DUPLEX		BIT(2)
+#define PORT_PCS_CTRL_10			0x00
+#define PORT_PCS_CTRL_100			0x01
+#define PORT_PCS_CTRL_1000			0x02
+#define PORT_PCS_CTRL_UNFORCED			0x03
+#define PORT_PAUSE_CTRL				0x02
+#define PORT_SWITCH_ID				0x03
+
+#define PORT_SWITCH_ID_PROD_NUM_6190		0x190
+#define PORT_SWITCH_ID_PROD_NUM_6290		0x290
+#define PORT_SWITCH_ID_PROD_NUM_6390		0x390
+#define PORT_SWITCH_ID_PROD_NUM_6390X		0x0a1
+#define PORT_SWITCH_ID_PROD_NUM_6141		0x141
+#define PORT_SWITCH_ID_PROD_NUM_6341		0x341
+
+#define PORT_CONTROL				0x04
+#define PORT_CONTROL_USE_CORE_TAG		BIT(15)
+#define PORT_CONTROL_DROP_ON_LOCK		BIT(14)
+#define PORT_CONTROL_EGRESS_UNMODIFIED		(0x0 << 12)
+#define PORT_CONTROL_EGRESS_UNTAGGED		(0x1 << 12)
+#define PORT_CONTROL_EGRESS_TAGGED		(0x2 << 12)
+#define PORT_CONTROL_EGRESS_ADD_TAG		(0x3 << 12)
+#define PORT_CONTROL_HEADER			BIT(11)
+#define PORT_CONTROL_IGMP_MLD_SNOOP		BIT(10)
+#define PORT_CONTROL_DOUBLE_TAG			BIT(9)
+#define PORT_CONTROL_FRAME_MODE_NORMAL		(0x0 << 8)
+#define PORT_CONTROL_FRAME_MODE_DSA		(0x1 << 8)
+#define PORT_CONTROL_FRAME_MODE_PROVIDER	(0x2 << 8)
+#define PORT_CONTROL_FRAME_ETHER_TYPE_DSA	(0x3 << 8)
+#define PORT_CONTROL_DSA_TAG			BIT(8)
+#define PORT_CONTROL_VLAN_TUNNEL		BIT(7)
+#define PORT_CONTROL_TAG_IF_BOTH		BIT(6)
+#define PORT_CONTROL_USE_IP			BIT(5)
+#define PORT_CONTROL_USE_TAG			BIT(4)
+#define PORT_CONTROL_FORWARD_UNKNOWN_MC		BIT(3)
+#define PORT_CONTROL_FORWARD_UNKNOWN		BIT(2)
+#define PORT_CONTROL_STATE_MASK			0x03
+#define PORT_CONTROL_STATE_DISABLED		0x00
+#define PORT_CONTROL_STATE_BLOCKING		0x01
+#define PORT_CONTROL_STATE_LEARNING		0x02
+#define PORT_CONTROL_STATE_FORWARDING		0x03
+#define PORT_CONTROL_1				0x05
+#define PORT_CONTROL_1_FID_11_4_MASK		(0xff << 0)
+#define PORT_BASE_VLAN				0x06
+#define PORT_BASE_VLAN_FID_3_0_MASK		(0xf << 12)
+#define PORT_DEFAULT_VLAN			0x07
+#define PORT_DEFAULT_VLAN_MASK			0xfff
+#define PORT_CONTROL_2				0x08
+#define PORT_CONTROL_2_IGNORE_FCS		BIT(15)
+#define PORT_CONTROL_2_VTU_PRI_OVERRIDE		BIT(14)
+#define PORT_CONTROL_2_SA_PRIO_OVERRIDE		BIT(13)
+#define PORT_CONTROL_2_DA_PRIO_OVERRIDE		BIT(12)
+#define PORT_CONTROL_2_JUMBO_1522		(0x00 << 12)
+#define PORT_CONTROL_2_JUMBO_2048		(0x01 << 12)
+#define PORT_CONTROL_2_JUMBO_10240		(0x02 << 12)
+#define PORT_CONTROL_2_8021Q_MASK		(0x03 << 10)
+#define PORT_CONTROL_2_8021Q_DISABLED		(0x00 << 10)
+#define PORT_CONTROL_2_8021Q_FALLBACK		(0x01 << 10)
+#define PORT_CONTROL_2_8021Q_CHECK		(0x02 << 10)
+#define PORT_CONTROL_2_8021Q_SECURE		(0x03 << 10)
+#define PORT_CONTROL_2_DISCARD_TAGGED		BIT(9)
+#define PORT_CONTROL_2_DISCARD_UNTAGGED		BIT(8)
+#define PORT_CONTROL_2_MAP_DA			BIT(7)
+#define PORT_CONTROL_2_DEFAULT_FORWARD		BIT(6)
+#define PORT_CONTROL_2_FORWARD_UNKNOWN		BIT(6)
+#define PORT_CONTROL_2_EGRESS_MONITOR		BIT(5)
+#define PORT_CONTROL_2_INGRESS_MONITOR		BIT(4)
+#define PORT_RATE_CONTROL			0x09
+#define PORT_RATE_CONTROL_2			0x0a
+#define PORT_ASSOC_VECTOR			0x0b
+#define PORT_ASSOC_VECTOR_HOLD_AT_1		BIT(15)
+#define PORT_ASSOC_VECTOR_INT_AGE_OUT		BIT(14)
+#define PORT_ASSOC_VECTOR_LOCKED_PORT		BIT(13)
+#define PORT_ASSOC_VECTOR_IGNORE_WRONG		BIT(12)
+#define PORT_ASSOC_VECTOR_REFRESH_LOCKED	BIT(11)
+#define PORT_ATU_CONTROL			0x0c
+#define PORT_PRI_OVERRIDE			0x0d
+#define PORT_ETH_TYPE				0x0f
+#define PORT_IN_DISCARD_LO			0x10
+#define PORT_IN_DISCARD_HI			0x11
+#define PORT_IN_FILTERED			0x12
+#define PORT_OUT_FILTERED			0x13
+#define PORT_TAG_REGMAP_0123			0x18
+#define PORT_TAG_REGMAP_4567			0x19
+
+#define REG_GLOBAL				0x1b
+#define GLOBAL_STATUS				0x00
+#define GLOBAL_STATUS_PPU_STATE			BIT(15) /* 6351 and 6171 */
+/* Two bits for 6165, 6185 etc */
+#define GLOBAL_STATUS_PPU_MASK			(0x3 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED_RST		(0x0 << 14)
+#define GLOBAL_STATUS_PPU_INITIALIZING		(0x1 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED		(0x2 << 14)
+#define GLOBAL_STATUS_PPU_POLLING		(0x3 << 14)
+#define GLOBAL_MAC_01				0x01
+#define GLOBAL_MAC_23				0x02
+#define GLOBAL_MAC_45				0x03
+#define GLOBAL_ATU_FID				0x01 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID				0x02 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID_MASK			0xfff
+#define GLOBAL_VTU_SID				0x03 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_SID_MASK			0x3f
+#define GLOBAL_CONTROL				0x04
+#define GLOBAL_CONTROL_SW_RESET			BIT(15)
+#define GLOBAL_CONTROL_PPU_ENABLE		BIT(14)
+#define GLOBAL_CONTROL_DISCARD_EXCESS		BIT(13) /* 6352 */
+#define GLOBAL_CONTROL_SCHED_PRIO		BIT(11) /* 6152 */
+#define GLOBAL_CONTROL_MAX_FRAME_1632		BIT(10) /* 6152 */
+#define GLOBAL_CONTROL_RELOAD_EEPROM		BIT(9)	/* 6152 */
+#define GLOBAL_CONTROL_DEVICE_EN		BIT(7)
+#define GLOBAL_CONTROL_STATS_DONE_EN		BIT(6)
+#define GLOBAL_CONTROL_VTU_PROBLEM_EN		BIT(5)
+#define GLOBAL_CONTROL_VTU_DONE_EN		BIT(4)
+#define GLOBAL_CONTROL_ATU_PROBLEM_EN		BIT(3)
+#define GLOBAL_CONTROL_ATU_DONE_EN		BIT(2)
+#define GLOBAL_CONTROL_TCAM_EN			BIT(1)
+#define GLOBAL_CONTROL_EEPROM_DONE_EN		BIT(0)
+#define GLOBAL_VTU_OP				0x05
+#define GLOBAL_VTU_OP_BUSY			BIT(15)
+#define GLOBAL_VTU_OP_FLUSH_ALL			\
+					((0x01 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_LOAD_PURGE		\
+					((0x03 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_GET_NEXT		\
+					((0x04 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_LOAD_PURGE		\
+					((0x05 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_GET_NEXT		\
+					((0x06 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_VID				0x06
+#define GLOBAL_VTU_VID_MASK			0xfff
+#define GLOBAL_VTU_VID_VALID			BIT(12)
+#define GLOBAL_VTU_DATA_0_3			0x07
+#define GLOBAL_VTU_DATA_4_7			0x08
+#define GLOBAL_VTU_DATA_8_11			0x09
+#define GLOBAL_VTU_STU_DATA_MASK		0x03
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNMODIFIED	0x00
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNTAGGED	0x01
+#define GLOBAL_VTU_DATA_MEMBER_TAG_TAGGED	0x02
+#define GLOBAL_VTU_DATA_MEMBER_TAG_NON_MEMBER	0x03
+#define GLOBAL_STU_DATA_PORT_STATE_DISABLED	0x00
+#define GLOBAL_STU_DATA_PORT_STATE_BLOCKING	0x01
+#define GLOBAL_STU_DATA_PORT_STATE_LEARNING	0x02
+#define GLOBAL_STU_DATA_PORT_STATE_FORWARDING	0x03
+#define GLOBAL_ATU_CONTROL			0x0a
+#define GLOBAL_ATU_CONTROL_LEARN2ALL		BIT(3)
+#define GLOBAL_ATU_OP				0x0b
+#define GLOBAL_ATU_OP_BUSY			BIT(15)
+#define GLOBAL_ATU_OP_NOP			(0 << 12)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL		\
+					((1 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC	\
+					((2 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_LOAD_DB			\
+					((3 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_NEXT_DB		\
+					((4 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL_DB		\
+					((5 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC_DB	\
+					((6 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_CLR_VIOLATION		\
+					((7 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_DATA				0x0c
+#define GLOBAL_ATU_DATA_TRUNK			BIT(15)
+#define GLOBAL_ATU_DATA_TRUNK_ID_MASK		0x00f0
+#define GLOBAL_ATU_DATA_TRUNK_ID_SHIFT		4
+#define GLOBAL_ATU_DATA_PORT_VECTOR_MASK	0x3ff0
+#define GLOBAL_ATU_DATA_PORT_VECTOR_SHIFT	4
+#define GLOBAL_ATU_DATA_STATE_MASK		0x0f
+#define GLOBAL_ATU_DATA_STATE_UNUSED		0x00
+#define GLOBAL_ATU_DATA_STATE_UC_MGMT		0x0d
+#define GLOBAL_ATU_DATA_STATE_UC_STATIC		0x0e
+#define GLOBAL_ATU_DATA_STATE_UC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_DATA_STATE_MC_NONE_RATE	0x05
+#define GLOBAL_ATU_DATA_STATE_MC_STATIC		0x07
+#define GLOBAL_ATU_DATA_STATE_MC_MGMT		0x0e
+#define GLOBAL_ATU_DATA_STATE_MC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_MAC_01			0x0d
+#define GLOBAL_ATU_MAC_23			0x0e
+#define GLOBAL_ATU_MAC_45			0x0f
+#define GLOBAL_IP_PRI_0				0x10
+#define GLOBAL_IP_PRI_1				0x11
+#define GLOBAL_IP_PRI_2				0x12
+#define GLOBAL_IP_PRI_3				0x13
+#define GLOBAL_IP_PRI_4				0x14
+#define GLOBAL_IP_PRI_5				0x15
+#define GLOBAL_IP_PRI_6				0x16
+#define GLOBAL_IP_PRI_7				0x17
+#define GLOBAL_IEEE_PRI				0x18
+#define GLOBAL_CORE_TAG_TYPE			0x19
+#define GLOBAL_MONITOR_CONTROL			0x1a
+#define GLOBAL_MONITOR_CONTROL_INGRESS_SHIFT	12
+#define GLOBAL_MONITOR_CONTROL_EGRESS_SHIFT	8
+#define GLOBAL_MONITOR_CONTROL_ARP_SHIFT	4
+#define GLOBAL_MONITOR_CONTROL_MIRROR_SHIFT	0
+#define GLOBAL_MONITOR_CONTROL_ARP_DISABLED	(0xf0)
+#define GLOBAL_CONTROL_2			0x1c
+#define GLOBAL_CONTROL_2_NO_CASCADE		0xe000
+#define GLOBAL_CONTROL_2_MULTIPLE_CASCADE	0xf000
+
+#define GLOBAL_STATS_OP			0x1d
+#define GLOBAL_STATS_OP_BUSY		BIT(15)
+#define GLOBAL_STATS_OP_NOP		(0 << 12)
+#define GLOBAL_STATS_OP_FLUSH_ALL	((1 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_FLUSH_PORT	((2 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_READ_CAPTURED	((4 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_CAPTURE_PORT	((5 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX		((1 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_TX		((2 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX_TX	((3 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_BANK_1		BIT(9)
+#define GLOBAL_STATS_COUNTER_32		0x1e
+#define GLOBAL_STATS_COUNTER_01		0x1f
+
+#define REG_GLOBAL2				0x1c
+#define GLOBAL2_INT_SOURCE			0x00
+#define GLOBAL2_INT_MASK			0x01
+#define GLOBAL2_MGMT_EN_2X			0x02
+#define GLOBAL2_MGMT_EN_0X			0x03
+#define GLOBAL2_FLOW_CONTROL			0x04
+#define GLOBAL2_SWITCH_MGMT			0x05
+#define GLOBAL2_SWITCH_MGMT_USE_DOUBLE_TAG_DATA	BIT(15)
+#define GLOBAL2_SWITCH_MGMT_PREVENT_LOOPS	BIT(14)
+#define GLOBAL2_SWITCH_MGMT_FLOW_CONTROL_MSG	BIT(13)
+#define GLOBAL2_SWITCH_MGMT_FORCE_FLOW_CTRL_PRI	BIT(7)
+#define GLOBAL2_SWITCH_MGMT_RSVD2CPU		BIT(3)
+#define GLOBAL2_DEVICE_MAPPING			0x06
+#define GLOBAL2_DEVICE_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_DEVICE_MAPPING_TARGET_SHIFT	8
+#define GLOBAL2_DEVICE_MAPPING_PORT_MASK	0x0f
+#define GLOBAL2_TRUNK_MASK			0x07
+#define GLOBAL2_TRUNK_MASK_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MASK_NUM_SHIFT		12
+#define GLOBAL2_TRUNK_MAPPING			0x08
+#define GLOBAL2_TRUNK_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MAPPING_ID_SHIFT		11
+#define GLOBAL2_INGRESS_OP			0x09
+#define GLOBAL2_INGRESS_DATA			0x0a
+#define GLOBAL2_PVT_ADDR			0x0b
+#define GLOBAL2_PVT_DATA			0x0c
+#define GLOBAL2_SWITCH_MAC			0x0d
+#define GLOBAL2_SWITCH_MAC_BUSY			BIT(15)
+#define GLOBAL2_ATU_STATS			0x0e
+#define GLOBAL2_PRIO_OVERRIDE			0x0f
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_SNOOP	BIT(7)
+#define GLOBAL2_PRIO_OVERRIDE_SNOOP_SHIFT	4
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_ARP		BIT(3)
+#define GLOBAL2_PRIO_OVERRIDE_ARP_SHIFT		0
+#define GLOBAL2_EEPROM_OP			0x14
+#define GLOBAL2_EEPROM_OP_BUSY			BIT(15)
+#define GLOBAL2_EEPROM_OP_WRITE			\
+		((3 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_READ			\
+		((4 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_LOAD			BIT(11)
+#define GLOBAL2_EEPROM_OP_WRITE_EN		BIT(10)
+#define GLOBAL2_EEPROM_OP_ADDR_MASK		0xff
+#define GLOBAL2_EEPROM_DATA			0x15
+#define GLOBAL2_PTP_AVB_OP			0x16
+#define GLOBAL2_PTP_AVB_DATA			0x17
+#define GLOBAL2_SMI_OP				0x18
+#define GLOBAL2_SMI_OP_BUSY			BIT(15)
+#define GLOBAL2_SMI_OP_CLAUSE_22		BIT(12)
+#define GLOBAL2_SMI_OP_22_WRITE			\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_22_READ			\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_45_WRITE_ADDR		\
+		((0 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_WRITE_DATA		\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_READ_DATA		\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_DATA			0x19
+#define GLOBAL2_SCRATCH_MISC			0x1a
+#define GLOBAL2_SCRATCH_BUSY			BIT(15)
+#define GLOBAL2_SCRATCH_REGISTER_SHIFT		8
+#define GLOBAL2_SCRATCH_VALUE_MASK		0xff
+#define GLOBAL2_WDOG_CONTROL			0x1b
+#define GLOBAL2_QOS_WEIGHT			0x1c
+#define GLOBAL2_MISC				0x1d
+
+#define PHY_COPPER_CONTROL		0x0
+#define PHY_COPPER_CONTROL_SPEED_1G	BIT(6)
+#define PHY_COPPER_CONTROL_DUPLEX	BIT(8)
+#define PHY_COPPER_CONTROL_POWER_DOWN	BIT(11)
+#define PHY_COPPER_CONTROL_AUTO_NEG_EN	BIT(12)
+#define PHY_COPPER_CONTROL_SPEED_100M	BIT(13)
+
+struct mv88e6xxx_dev {
+	unsigned int phy_addr;
+	unsigned int port_mask;
+	unsigned int addr_mode;
+	int id;
+	int cpu_port;	/* The switch port to which the CPU is attached */
+};
+
+enum sw_opts {
+	SW_INFO,
+	SW_READ,
+	SW_WRITE,
+	SW_PHY_READ,
+	SW_PHY_WRITE,
+	SW_LINK,
+	SW_NA
+};
+
+#endif /* _MV88E6XXX_H__*/
diff --git a/drivers/net/phy/mvebu_fw_download.c b/drivers/net/phy/mvebu_fw_download.c
new file mode 100644
index 0000000000..8850deeca0
--- /dev/null
+++ b/drivers/net/phy/mvebu_fw_download.c
@@ -0,0 +1,559 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+
+#define MV_MAX_APP_SIZE			(216 * 1024UL)
+#define MV_HEADER_SIZE			32
+
+struct device_para {
+	u32 dev_id;
+	u32 dev_rev;
+	u32 mem_size;
+};
+
+enum device_errors {
+	MVEBU_FLASH_UPDATE_OK			=  0,
+	/* Slave code did not start */
+	MVEBU_SLAVE_CODE_DID_NOT_START		= -1,
+	/* Flash verified FAILED */
+	MVEBU_VERIFY_ERR			= -2,
+	/* Unknown error */
+	MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL	= -3,
+	/* Error reading or writing MDIO register */
+	MVEBU_IO_ERROR				= -4,
+	/*size must be an even number of bytes*/
+	MVEBU_SIZE_NOT_EVEN			= -5,
+	/* Slave encountered error while erasing flash */
+	MVEBU_ERR_ERASING_FLASH			= -6,
+	/* unexpected value read back from download code */
+	MVEBU_ERR_VALUE_READ_BACK		= -7,
+	/* Did not get MVEBU_SLAVE_OK for writing the data */
+	MVEBU_ERR_START_WRITE_DATA		= -8,
+	/* Slave failed to get all the data correctly*/
+	MVEBU_START_WRITE_DATA			= -9,
+	/* Some kind of error occurred on Slave */
+	MVEBU_ERR_ON_SLAVE			= -10,
+	/* Checksum error */
+	MVEBU_ERR_CHECKSUM			= -11,
+	/* Slave didn't write enough words to flash */
+	MVEBU_ERR_SLAVE_WRITE_FULL		= -12,
+	/* last transfer failed */
+	MVEBU_ERR_LAST_TRANSFER			= -13,
+	/* wrong checksum */
+	MVEBU_RAM_HW_CHECKSUM_ERR		= -14,
+	/* PHY wasn't waiting in download mode */
+	MVEBU_PHY_NOT_IN_DOWNLOAD_MODE		= -15,
+	MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD	= -16,
+	MVEBU_ERR_GET_DEVICE			= -17,
+};
+
+#define MDIO_DEVICE_ADDRESS		1
+/* Master-Slave Protocol Definitions */
+#define MDIO_MAX_BUFF_SIZE		49192
+#define MDIO_ACTUAL_BUFF_SIZE		49193
+#define MDIO_COMMAND			49194
+#define MDIO_WORDS_WRITTEN		49195
+#define MDIO_LOW_ADDRESS		49196
+#define MDIO_HIGH_ADDRESS		49197
+#define MDIO_DATA			49198
+#define MDIO_CHECKSUM			49199
+#define MDIO_WORDS_RCVD			49200
+#define MDIO_NUM_SECTIONS		49202 /*0xC032*/
+/* Host Commands */
+#define MDIO_CMD_ERASE_FLASH		0x1
+#define MDIO_CMD_FILL_BUFFER		0x2
+#define MDIO_CMD_WRITE_BUFFER		0x6
+#define MDIO_CMD_VERIFY_FLASH		0x7
+/* Slave Responses */
+#define MDIO_CMD_SLV_OK			0x100
+#define MDIO_CMD_SLV_ERR		0x200
+#define MDIO_CMD_SLV_FLASH_BUSY		0x300
+#define MDIO_CMD_SLV_VERIFY_ERR		0x400
+/* 88X3240/3220 Device Number Definitions */
+#define MVEBU_T_UNIT_PMA_PMD		1
+#define MVEBU_T_UNIT_PCS_CU		3
+#define MVEBU_H_UNIT			4
+#define MVEBU_C_UNIT_GENERAL		31
+/* 88X3240/3220 T Unit Registers MMD 1 */
+#define MVEBU_BOOT_STATUS_REG		0xC050
+/* 88X3240/3220 C Unit Registers MMD 31 */
+#define MVEBU_CUNIT_MODE_CONFIG		0xF000
+#define MVEBU_CUNIT_PORT_CTRL		0xF001
+/* Internal PHY Registers for downloading to RAM */
+/* register to set the low part of the address */
+#define MVEBU_LOW_WORD_REG		0xD0F0
+/* register to set the hi part of the address */
+#define MVEBU_HI_WORD_REG		0xD0F1
+/* register to write or read to/from ram */
+#define MVEBU_RAM_DATA_REG		0xD0F2
+/* register to read the checksum from */
+#define MVEBU_RAM_CHECKSUM_REG		0xD0F3
+
+static u32 mvebu_get_reg_field_from_wrod(u16 data, u8 field_off, u8 field_len)
+{
+	u16 mask;
+
+	if ((field_len + field_off) >= 16)
+		mask = (0 - (1 << field_off));
+	else
+		mask = (((1 << (field_len + field_off))) - (1 << field_off));
+
+	return (data & mask) >> field_off;
+}
+
+static void mvebu_set_phy_reg_field(struct mii_dev *bus, u16 port, u16 dev,
+				    u16 reg_addr, u8 field_off, u8 field_len,
+				    u16 data)
+{
+	u16 reg, mask;
+
+	reg = bus->read(bus, port, dev, reg_addr);
+	/* Set register field to word */
+	if ((field_len + field_off) >= 16)
+		mask = (0 - (1 << field_off));
+	else
+		mask = (((1 << (field_len + field_off))) - (1 << field_off));
+	/* Set the desired bits to 0. */
+	reg &= ~mask;
+	/* Set the given data into the above reset bits. */
+	reg |= ((data << field_off) & mask);
+	bus->write(bus, port, dev, reg_addr, reg);
+}
+
+static void mvebu_phy_reset(struct mii_dev *bus, u16 port)
+{
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				MVEBU_CUNIT_PORT_CTRL, 12, 1, 1);
+}
+
+static u32 mvebu_flash_transfer(struct mii_dev *bus, u16 port, u8 data[],
+				u32 max_buff_size, u32 *byte_index, int error)
+{
+	u16 buf_checksum, tmp_checksum, reported_checksum;
+	u16 words_rcvd, words_written, reg;
+	u32 stop_index;
+
+	/* Set the flash start address*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_LOW_ADDRESS, (u16)(*byte_index));
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_HIGH_ADDRESS, (u16)((*byte_index) >> 16));
+	/* Set the size of the buffer we're going to send*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_ACTUAL_BUFF_SIZE, (u16)(max_buff_size / 2));
+	/* Tell the slave we've written the start address and size */
+	/* and now we're going to start writing data*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_FILL_BUFFER);
+	/* Wait for MDIO_CMD_SLV_OK*/
+	if (error == MVEBU_ERR_LAST_TRANSFER) {
+		do {
+			reg = bus->read(bus, port,
+					MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		} while (reg == MDIO_CMD_FILL_BUFFER);
+	} else {
+		do {
+			reg = bus->read(bus, port,
+					MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		} while (reg == MDIO_CMD_ERASE_FLASH ||
+			 reg == MDIO_CMD_SLV_FLASH_BUSY);
+	}
+
+	if (reg != MDIO_CMD_SLV_OK)
+		return error;
+
+	/* Write a buffer of data to the slave RAM*/
+	stop_index = (*byte_index) + max_buff_size;
+	buf_checksum = 0;
+	while ((*byte_index) < stop_index) {
+		u16 value;
+
+		value = data[(*byte_index)++];
+		value |= (((u16)data[(*byte_index)++]) << 8);
+		buf_checksum += value;
+		bus->write(bus, port, MDIO_DEVICE_ADDRESS, MDIO_DATA, value);
+	}
+	if (error != MVEBU_ERR_LAST_TRANSFER) {
+		/* check and see if we can go on to the write*/
+		tmp_checksum = bus->read(bus, port,
+					 MDIO_DEVICE_ADDRESS, MDIO_CHECKSUM);
+		words_rcvd = bus->read(bus, port,
+				       MDIO_DEVICE_ADDRESS, MDIO_WORDS_RCVD);
+		if (tmp_checksum != buf_checksum ||
+		    words_rcvd != (u16)(max_buff_size / 2)) {
+			debug("ERROR: phy checksum=0x%x vs buf chksum 0x%x\n",
+			      tmp_checksum, buf_checksum);
+			return MVEBU_START_WRITE_DATA;
+		}
+	}
+
+	/* One full RAM buffer inside DSP is ready to write to flash now*/
+	/* Tell the slave to write it*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_WRITE_BUFFER);
+	if (error == MVEBU_ERR_LAST_TRANSFER)
+		debug("Waiting for slave to programe last buffer to flash\n");
+	else
+		debug("Waiting for slave to finish programming flash\n");
+
+	/* Wait for MDIO_CMD_SLV_OK */
+	do {
+		/*
+		 * This can take several 2-3 seconds, don't poll phy too
+		 * frequently since every read causes an interrupt on the phy.
+		 */
+		reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		mdelay(500);
+	} while (reg == MDIO_CMD_WRITE_BUFFER ||
+		 reg == MDIO_CMD_SLV_FLASH_BUSY);
+
+	if (reg != MDIO_CMD_SLV_OK) {
+		debug("ERROR: slave returns error 0x%x\n", reg);
+
+		if (reg == MDIO_CMD_SLV_VERIFY_ERR) {
+			reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS,
+					MDIO_NUM_SECTIONS);
+			debug("ERROR: Verification failed on section nr %d\n",
+			      reg);
+		}
+
+		return error;
+	}
+
+	/* readback checksum of what was stored in flash */
+	reported_checksum = bus->read(bus, port,
+				      MDIO_DEVICE_ADDRESS, MDIO_CHECKSUM);
+	if (reported_checksum != buf_checksum)
+		return MVEBU_ERR_CHECKSUM;
+
+	words_written = bus->read(bus, port,
+				  MDIO_DEVICE_ADDRESS, MDIO_WORDS_WRITTEN);
+	if (words_written != (max_buff_size / 2))
+		return MVEBU_ERR_SLAVE_WRITE_FULL;
+
+	return 0;
+}
+
+/*
+ * This handles downloading an image pointed to by data which is size bytes
+ * long to the phy's flash interfacing with the slave code as a helper program.
+ * Size must be an even number (the flash can only be written to in words).
+ */
+static u32 mvebu_mdio_flash_download(struct mii_dev *bus, u16 port,
+				     u8 data[], u32 size)
+{
+	u32 max_buff_size, num_trans, last_trans_size, trans_index;
+	u32 byte_index = 0;
+	u16 reg;
+
+	/* size must be an even number of bytes */
+	if (size % 2)
+		return MVEBU_SIZE_NOT_EVEN;
+
+	/* first erase the flash*/
+	printf("Slave will now erase flash. This may take up to 30 seconds.\n");
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_ERASE_FLASH);
+	do {
+		reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+	} while (reg == MDIO_CMD_ERASE_FLASH || reg == MDIO_CMD_SLV_FLASH_BUSY);
+
+	if (reg == MDIO_CMD_SLV_ERR)
+		return MVEBU_ERR_ERASING_FLASH;
+
+	if (reg != MDIO_CMD_SLV_OK)
+		return MVEBU_ERR_VALUE_READ_BACK;
+	printf("Flash program have been erased.\n");
+
+	/* read in the maximum buffer size from the slave */
+	max_buff_size = bus->read(bus, port,
+				  MDIO_DEVICE_ADDRESS, MDIO_MAX_BUFF_SIZE);
+	max_buff_size *= 2;
+	num_trans = size / max_buff_size;
+	last_trans_size = size % max_buff_size;
+
+	debug("trans num %d, max_buff_size %d, size %d, last trans size %d\n",
+	      num_trans, max_buff_size, size, last_trans_size);
+
+	/* handle all the full transfers */
+	for (trans_index = 0; trans_index < num_trans; trans_index++)
+		mvebu_flash_transfer(bus, port, data, max_buff_size,
+				     &byte_index, MVEBU_ERR_ON_SLAVE);
+
+	if (last_trans_size)
+		mvebu_flash_transfer(bus, port, data, last_trans_size,
+				     &byte_index, MVEBU_ERR_LAST_TRANSFER);
+
+	return 0;
+}
+
+/*
+ * This function downloads code to RAM in the DSP and then starts the
+ * application which was downloaded. "size" should be an even number
+ * (memory can only be written word-wise)
+ */
+static u32 mvebu_mdio_ram_download(struct mii_dev *bus, u8 data[],
+				   u32 size, u16 port, u8 ram_checksum_flag)
+{
+	u32 buff_count = 0;
+	u16 reg, ram_checksum, checksum = 0;
+	u8  low_byte, high_byte;
+
+	/* size must be an even number of bytes */
+	if (size % 2)
+		return MVEBU_SIZE_NOT_EVEN;
+
+	/* Put PHY in download mode and reset PHY */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				0xF008, 5, 1, 1);
+	mvebu_phy_reset(bus, port);
+
+	/* Allow reset to complete */
+	mdelay(2500);
+
+	/*
+	 * Make sure we can access the PHY and it's in the correct mode
+	 * (waiting for download)
+	 */
+	reg = bus->read(bus, port,
+			MVEBU_T_UNIT_PMA_PMD, MVEBU_BOOT_STATUS_REG);
+	if (reg != 0x000A)
+		return MVEBU_PHY_NOT_IN_DOWNLOAD_MODE;
+
+	printf("Downloading code to PHY RAM, please wait...\n");
+	/* clear the checksum */
+	if (ram_checksum_flag)
+		bus->read(bus, port, MVEBU_T_UNIT_PCS_CU,
+			  MVEBU_RAM_CHECKSUM_REG);
+
+	/* Set starting address in RAM to 0x00100000 */
+	bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_LOW_WORD_REG, 0);
+	bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_HI_WORD_REG, 0x0010);
+
+	/*
+	 * Copy the code to the phy's internal RAM,
+	 * calculating checksum as we go.
+	 */
+	while (buff_count < size) {
+		low_byte = data[buff_count++];
+		high_byte = data[buff_count++];
+		checksum += (low_byte + high_byte);
+		bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_RAM_DATA_REG,
+			   (((u16)high_byte) << 8) | low_byte);
+	}
+
+	if (ram_checksum_flag) {
+		ram_checksum = bus->read(bus, port, MVEBU_T_UNIT_PCS_CU,
+					 MVEBU_RAM_CHECKSUM_REG);
+		if (checksum != ram_checksum)
+			return MVEBU_RAM_HW_CHECKSUM_ERR;
+	}
+
+	/* Now start code which was downloaded */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_T_UNIT_PMA_PMD,
+				MVEBU_BOOT_STATUS_REG, 6, 1, 1);
+	/* Give application code time to start */
+	mdelay(100);
+
+	return 0;
+}
+
+static u32 mvebu_get_device(struct mii_dev *bus, u16 port,
+			    struct device_para *dev_param)
+{
+	u16 reg3;
+	u16 model_num;
+	u16 rev_num;
+	u16 oui1, oui2;
+
+	/* Check if this is a Marvell PHY */
+	oui1 = bus->read(bus, port, 1, 2);
+	reg3 = bus->read(bus, port, 1, 3);
+	oui2 = mvebu_get_reg_field_from_wrod(reg3, 10, 6);
+	model_num = mvebu_get_reg_field_from_wrod(reg3, 4, 6);
+	rev_num = mvebu_get_reg_field_from_wrod(reg3, 0, 4);
+
+	debug("%s: OUI oui1 0x%x, oui2 0x%x, model_num 0x%x, rev_num 0x%x\n",
+	      __func__, oui1, oui2, model_num, rev_num);
+	/* Check if the PHY OUI belongs to Marvell */
+	if (!(oui1 == 0x141 && oui2 == 3) && !(oui1 == 0x2b && oui2 == 2))
+		return MVEBU_ERR_GET_DEVICE;
+
+	dev_param->dev_id = model_num;
+	dev_param->dev_rev = rev_num;
+	dev_param->mem_size = MV_MAX_APP_SIZE;
+
+	printf("device id = %x, device revision = %x, memory size = %x\n",
+	       dev_param->dev_id, dev_param->dev_rev, dev_param->mem_size);
+	return 0;
+}
+
+u32 mvebu_update_flash_image(struct mii_dev *bus, u16 port, u8 app_data[],
+			     u32 app_size, u8 salve_data[], u32 slave_size)
+{
+	struct device_para dev;
+	int error;
+	u32 data;
+
+	/*
+	 * All X32X0 have a ram checksum register, can change to 0 if wish to
+	 * ignore it for some reason (not advised but might want to for debug
+	 * purposes)
+	 */
+	u8 ram_checksum = 1;
+
+	error = mvebu_get_device(bus, port, &dev);
+	if (error < 0)
+		return error;
+
+	/* Check if the code can fit into the device's memory */
+	if (app_size > dev.mem_size + MV_HEADER_SIZE)
+		return MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD;
+
+	/* Download slave code to PHY's RAM and start it */
+	error = mvebu_mdio_ram_download(bus, salve_data,
+					slave_size, port, ram_checksum);
+	if (error < 0)
+		return error;
+
+	/* make sure the slave code started */
+	data = bus->read(bus, port, MVEBU_T_UNIT_PMA_PMD,
+			 MVEBU_BOOT_STATUS_REG);
+	data = mvebu_get_reg_field_from_wrod(data, 4, 1);
+	if (!data)
+		return MVEBU_SLAVE_CODE_DID_NOT_START;
+
+	/* Write the image to flash */
+	error = mvebu_mdio_flash_download(bus, port, app_data, app_size);
+	if (error < 0)
+		return error;
+
+	/*
+	 * Using slave code to verify image.
+	 * This commands slave to read in entire flash image and calculate
+	 * checksum and make sure checksum matches the checksum in the header.
+	 * A failure means flash was corrupted.
+	 * Another method would be to reset the phy (with SPI_CONFIG[1]= 0)
+	 * and see that the new code starts successfully, since a bad checksum
+	 * will result in the code not being started
+	 */
+	printf("Flash programming complete. Verifying image via slave.\n");
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_VERIFY_FLASH);
+
+	do {
+		data = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		mdelay(100);
+	} while (data == MDIO_CMD_VERIFY_FLASH ||
+		 data == MDIO_CMD_SLV_FLASH_BUSY);
+
+	switch (data) {
+	case MDIO_CMD_SLV_OK:
+		printf("Flash image verified. ");
+		printf("Reset F_CFG1 to 0 and reboot to execute new code\n");
+		return MVEBU_FLASH_UPDATE_OK;
+	case MDIO_CMD_SLV_VERIFY_ERR:
+		return MVEBU_VERIFY_ERR;
+	default:
+		return MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL;
+	}
+
+	return MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL;
+}
+
+/*
+ * mvebu_phy_firmware_download: Update flash image in the PHY
+ *
+ * @port:	MDIO port address, 0-31
+ * @app_data:	application code to be downloaded in to the flash
+ * @app_size:	file size
+ * @slave_data:	slave code to be downloaded in to the RAM
+ * @slave_size:	file size of the slave code
+ * @returns 0 on success, error code otherwise.
+ */
+u32 mvebu_phy_firmware_download(u16 port, u8 app_data[],
+				u32 app_size, u8 salve_data[], u32 slave_size)
+{
+	struct mii_dev *bus;
+	int error;
+
+	printf("Ethernet transceiver PHY firmware download started:\n");
+	bus = mdio_get_current_dev();
+	if (!bus) {
+		pr_err("failed to detect MDIO bus\n");
+		return -1;
+	}
+
+	error = mvebu_update_flash_image(bus, port, app_data, app_size,
+					 salve_data, slave_size);
+	switch (error) {
+	case MVEBU_FLASH_UPDATE_OK:
+		printf("mvebu_update_flash_image succeeded\n");
+		break;
+	case MVEBU_ERR_GET_DEVICE:
+		printf("failed to read device id\n");
+		break;
+	case MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD:
+		printf("image is larger than the device memory size\n");
+		break;
+	case MVEBU_SIZE_NOT_EVEN:
+		printf("size must be an even number of bytes\n");
+		break;
+	case MVEBU_VERIFY_ERR:
+		printf("Flash verified FAILED! ");
+		printf("Flash probably corrupted. Re-try download.\n");
+		break;
+	case MVEBU_SLAVE_CODE_DID_NOT_START:
+		printf("Slave download failed. Exiting...\n");
+		break;
+	case MVEBU_PHY_NOT_IN_DOWNLOAD_MODE:
+		printf("Download failed, ");
+		printf("PHY is not in waiting on download mode. ");
+		printf("Expected 0x000A\n");
+		break;
+	case MVEBU_RAM_HW_CHECKSUM_ERR:
+		printf("Error downloading code. ");
+		printf("Got another val from the Expected RAM HW checksum\n");
+		break;
+	case MVEBU_ERR_VALUE_READ_BACK:
+		printf("Unexpected response from PHY. Exiting...\n");
+		break;
+	case MVEBU_ERR_ON_SLAVE:
+		printf("Unexpected error occurred on slave. Exiting...\n");
+		break;
+	case MVEBU_ERR_LAST_TRANSFER:
+		printf("Unexpected error occurred last transfer. ");
+		printf("Exiting...\n");
+		break;
+	case MVEBU_START_WRITE_DATA:
+		printf("Slave failed to get all the data correctly\n");
+		break;
+	case MVEBU_ERR_SLAVE_WRITE_FULL:
+		printf("Slave didn't write enough words to flash. ");
+		printf("Exiting...\n");
+		break;
+	case MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL:
+	default:
+		printf("Unknown download to flash fail. Exiting...\n");
+		break;
+	}
+
+	if (error < 0) {
+		printf("Ethernet transceiver PHY firmware download failed.\n");
+		return -1;
+	}
+
+	printf("Ethernet transceiver PHY firmware download succeeded.\n");
+	/* disable download mode in the PHY */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				0xF008, 5, 1, 0);
+	mvebu_phy_reset(bus, port);
+
+	return 0;
+}
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index ae37dd6c1e..192ae5aa0f 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -256,7 +256,7 @@ int genphy_update_link(struct phy_device *phydev)
 				return -EINTR;
 			}
 
-			if ((i++ % 500) == 0)
+			if ((i++ % 1000) == 0)
 				printf(".");
 
 			udelay(1000);	/* 1 ms */
diff --git a/drivers/nvme/nvme.c b/drivers/nvme/nvme.c
index 47f101e280..4af00f4d92 100644
--- a/drivers/nvme/nvme.c
+++ b/drivers/nvme/nvme.c
@@ -780,8 +780,7 @@ static int nvme_probe(struct udevice *udev)
 	ndev->instance = trailing_strtol(udev->name);
 
 	INIT_LIST_HEAD(&ndev->namespaces);
-	ndev->bar = dm_pci_map_bar(udev, PCI_BASE_ADDRESS_0,
-			PCI_REGION_MEM);
+	ndev->bar = dm_pci_map_bar(udev, PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
 	if (readl(&ndev->bar->csts) == -1) {
 		ret = -ENODEV;
 		printf("Error: %s: Out of memory!\n", udev->name);
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index bdfc0c1796..ac4c5ad7a6 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -43,6 +43,15 @@ config PCI_PNP
 	help
 	  Enable PCI memory and I/O space resource allocation and assignment.
 
+config PCI_REGION_MULTI_ENTRY
+	bool "Enable Multiple entries of MEMORY region for PCI"
+	depends on PCI || DM_PCI
+	default n
+	help
+	  Enable PCI memory regions to be of multiple entry. This helps to
+	  add support for SoC's like OcteonTX/TX2 where every peripheral is
+	  on PCI bus.
+
 config PCIE_ECAM_GENERIC
 	bool "Generic ECAM-based PCI host controller support"
 	default n
@@ -106,6 +115,14 @@ config PCI_TEGRA
 	  with a total of 5 lanes. Some boards require this for Ethernet
 	  support to work (e.g. beaver, jetson-tk1).
 
+config PCI_OCTEONTX
+	bool "OcteonTX PCI support"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	help
+	  Enable support for the OcteonTX/TX2 SoC family ECAM/PEM controllers.
+	  These controllers provide PCI configuration access to all on-board
+	  peripherals so it should only be disabled for testing purposes
+
 config PCI_XILINX
 	bool "Xilinx AXI Bridge for PCI Express"
 	depends on DM_PCI
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index e54a98b8c9..615c3ca724 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -39,3 +39,4 @@ obj-$(CONFIG_PCIE_LAYERSCAPE_GEN4) += pcie_layerscape_gen4.o \
 obj-$(CONFIG_PCI_XILINX) += pcie_xilinx.o
 obj-$(CONFIG_PCIE_INTEL_FPGA) += pcie_intel_fpga.o
 obj-$(CONFIG_PCI_KEYSTONE) += pcie_dw_ti.o
+obj-$(CONFIG_PCI_OCTEONTX) += pci_octeontx.o
diff --git a/drivers/pci/pci-aardvark.c b/drivers/pci/pci-aardvark.c
index 864ac16f57..bc1080baa3 100644
--- a/drivers/pci/pci-aardvark.c
+++ b/drivers/pci/pci-aardvark.c
@@ -92,6 +92,11 @@
 #define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE	BIT(5)
 #define     PCIE_CORE_CTRL2_ADDRWIN_MAP_ENABLE	BIT(6)
 
+#define PCIE_PHY_REF_CLOCK			(CONTROL_BASE_ADDR + 0x14)
+#define     PCIE_PHY_CTRL_OFF			16
+#define     PCIE_PHY_BUF_CTRL_OFF		0
+#define     PCIE_PHY_BUF_CTRL_INIT_VAL		0x1342
+
 /* LMI registers base address and register offsets */
 #define LMI_BASE_ADDR				0x6000
 #define CFG_REG					(LMI_BASE_ADDR + 0x0)
@@ -511,6 +516,9 @@ static int pcie_advk_setup_hw(struct pcie_advk *pcie)
 {
 	u32 reg;
 
+	/* Set HW Reference Clock Buffer Control */
+	advk_writel(pcie, PCIE_PHY_BUF_CTRL_INIT_VAL, PCIE_PHY_REF_CLOCK);
+
 	/* Set to Direct mode */
 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
diff --git a/drivers/pci/pci-uclass.c b/drivers/pci/pci-uclass.c
index ab3e1310eb..eb4eda0e8c 100644
--- a/drivers/pci/pci-uclass.c
+++ b/drivers/pci/pci-uclass.c
@@ -599,10 +599,19 @@ int dm_pci_hose_probe_bus(struct udevice *bus)
 {
 	int sub_bus;
 	int ret;
+	int ea_pos;
+	u8 reg;
 
 	debug("%s\n", __func__);
 
-	sub_bus = pci_get_bus_max() + 1;
+	ea_pos = dm_pci_find_capability(bus, PCI_CAP_ID_EA);
+
+	if (ea_pos) {
+		dm_pci_read_config8(bus, ea_pos + sizeof(u32) + sizeof(u8), &reg);
+		sub_bus = reg;
+	} else {
+		sub_bus = pci_get_bus_max() + 1;
+	}
 	debug("%s: bus = %d/%s\n", __func__, sub_bus, bus->name);
 	dm_pciauto_prescan_setup_bridge(bus, sub_bus);
 
@@ -612,12 +621,15 @@ int dm_pci_hose_probe_bus(struct udevice *bus)
 		      ret);
 		return ret;
 	}
-	if (sub_bus != bus->seq) {
-		printf("%s: Internal error, bus '%s' got seq %d, expected %d\n",
-		       __func__, bus->name, bus->seq, sub_bus);
-		return -EPIPE;
+
+	if (!ea_pos) {
+		if (sub_bus != bus->seq) {
+			printf("%s: Internal error, bus '%s' got seq %d, expected %d\n",
+			       __func__, bus->name, bus->seq, sub_bus);
+			return -EPIPE;
+		}
+		sub_bus = pci_get_bus_max();
 	}
-	sub_bus = pci_get_bus_max();
 	dm_pciauto_postscan_setup_bridge(bus, sub_bus);
 
 	return sub_bus;
@@ -675,7 +687,8 @@ static int pci_find_and_bind_driver(struct udevice *parent,
 	      find_id->vendor, find_id->device);
 
 	/* Determine optional OF node */
-	pci_dev_find_ofnode(parent, bdf, &node);
+	if (ofnode_valid(dev_ofnode(parent)))
+		pci_dev_find_ofnode(parent, bdf, &node);
 
 	start = ll_entry_start(struct pci_driver_entry, pci_driver_entry);
 	n_ents = ll_entry_count(struct pci_driver_entry, pci_driver_entry);
@@ -759,7 +772,7 @@ int pci_bind_bus_devices(struct udevice *bus)
 	ulong header_type;
 	pci_dev_t bdf, end;
 	bool found_multi;
-	int ret;
+	int ret, ari_off;
 
 	found_multi = false;
 	end = PCI_BDF(bus->seq, PCI_MAX_PCI_DEVICES - 1,
@@ -831,6 +844,22 @@ int pci_bind_bus_devices(struct udevice *bus)
 		pplat->vendor = vendor;
 		pplat->device = device;
 		pplat->class = class;
+
+		ari_off = dm_pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+		if (ari_off) {
+			u16 ari_cap;
+
+			/* Read Next Function number in ARI Cap Register */
+			dm_pci_read_config16(dev, ari_off + 4, &ari_cap);
+			/* Update next scan on this function number,
+			 * subtract 1 in BDF to satisfy loop increment.
+			 */
+			if (ari_cap & 0xff00) {
+				bdf = PCI_BDF(PCI_BUS(bdf), PCI_DEV(ari_cap),
+					      PCI_FUNC(ari_cap));
+				bdf = bdf - 0x100;
+			}
+		}
 	}
 
 	return 0;
@@ -900,10 +929,12 @@ static void decode_regions(struct pci_controller *hose, ofnode parent_node,
 		}
 
 		pos = -1;
+#if !CONFIG_IS_ENABLED(PCI_REGION_MULTI_ENTRY)
 		for (i = 0; i < hose->region_count; i++) {
 			if (hose->regions[i].flags == type)
 				pos = i;
 		}
+#endif
 		if (pos == -1)
 			pos = hose->region_count++;
 		debug(" - type=%d, pos=%d\n", type, pos);
@@ -1342,13 +1373,19 @@ pci_addr_t dm_pci_phys_to_bus(struct udevice *dev, phys_addr_t phys_addr,
 }
 
 static void *dm_pci_map_ea_bar(struct udevice *dev, int bar, int flags,
-			       int ea_off)
+			       int ea_off, struct pci_child_platdata *pdata)
 {
 	int ea_cnt, i, entry_size;
 	int bar_id = (bar - PCI_BASE_ADDRESS_0) >> 2;
 	u32 ea_entry;
 	phys_addr_t addr;
 
+	/* In case of Virtual Function devices, device is Physical function,
+	 * so pdata will point to required VF specific data.
+	 */
+	if (pdata->is_virtfn)
+		bar_id += PCI_EA_BEI_VF_BAR0;
+
 	/* EA capability structure header */
 	dm_pci_read_config32(dev, ea_off, &ea_entry);
 	ea_cnt = (ea_entry >> 16) & PCI_EA_NUM_ENT_MASK;
@@ -1371,8 +1408,28 @@ static void *dm_pci_map_ea_bar(struct udevice *dev, int bar, int flags,
 			addr |= ((u64)ea_entry) << 32;
 		}
 
+		/* In case of Virtual Function devices using BAR
+		 * base and size, add offset for VFn BAR(1, 2, 3...n)
+		 */
+		if (pdata->is_virtfn) {
+			size_t sz;
+
+			/* MaxOffset, 1st DW */
+			dm_pci_read_config32(dev, ea_off + 8, &ea_entry);
+			sz = ea_entry & PCI_EA_FIELD_MASK;
+			/* Fill up lower 2 bits */
+			sz |= (~PCI_EA_FIELD_MASK);
+			if (ea_entry & PCI_EA_IS_64) {
+				/* MaxOffset 2nd DW */
+				dm_pci_read_config32(dev, ea_off + 16,
+						     &ea_entry);
+				sz |= ((u64)ea_entry) << 32;
+			}
+			addr += (pdata->virtid - 1) * (sz + 1);
+		}
+
 		/* size ignored for now */
-		return map_physmem(addr, flags, 0);
+		return map_physmem(addr, 0, flags);
 	}
 
 	return 0;
@@ -1383,26 +1440,36 @@ void *dm_pci_map_bar(struct udevice *dev, int bar, int flags)
 	pci_addr_t pci_bus_addr;
 	u32 bar_response;
 	int ea_off;
+	struct udevice *udev = dev;
+	struct pci_child_platdata *pdata = dev_get_parent_platdata(dev);
+
+	/* In case of Virtual Function devices, use PF udevice
+	 * as EA capability is defined in Physical Function
+	 */
+	if (pdata->is_virtfn)
+		udev = pdata->pfdev;
 
 	/*
 	 * if the function supports Enhanced Allocation use that instead of
 	 * BARs
+	 * Incase of virtual functions, pdata will help read VF BEI
+	 * and EA entry size.
 	 */
-	ea_off = dm_pci_find_capability(dev, PCI_CAP_ID_EA);
+	ea_off = dm_pci_find_capability(udev, PCI_CAP_ID_EA);
 	if (ea_off)
-		return dm_pci_map_ea_bar(dev, bar, flags, ea_off);
+		return dm_pci_map_ea_bar(udev, bar, flags, ea_off, pdata);
 
 	/* read BAR address */
-	dm_pci_read_config32(dev, bar, &bar_response);
+	dm_pci_read_config32(udev, bar, &bar_response);
 	pci_bus_addr = (pci_addr_t)(bar_response & ~0xf);
 
 	/*
 	 * Pass "0" as the length argument to pci_bus_to_virt.  The arg
-	 * isn't actualy used on any platform because u-boot assumes a static
+	 * isn't actually used on any platform because u-boot assumes a static
 	 * linear mapping.  In the future, this could read the BAR size
 	 * and pass that as the size if needed.
 	 */
-	return dm_pci_bus_to_virt(dev, pci_bus_addr, flags, 0, MAP_NOCACHE);
+	return dm_pci_bus_to_virt(udev, pci_bus_addr, flags, 0, MAP_NOCACHE);
 }
 
 static int _dm_pci_find_next_capability(struct udevice *dev, u8 pos, int cap)
@@ -1518,6 +1585,120 @@ int dm_pci_flr(struct udevice *dev)
 	return 0;
 }
 
+int pci_sriov_init(struct udevice *pdev, int vf_en)
+{
+	u16 vendor, device;
+	struct udevice *bus;
+	struct udevice *dev;
+	pci_dev_t bdf;
+	u16 ctrl;
+	u16 num_vfs;
+	u16 total_vf;
+	u16 vf_offset;
+	u16 vf_stride;
+	int vf, ret;
+	int pos;
+
+	pos = dm_pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+	if (!pos) {
+		printf("Error: SRIOV capability not found\n");
+		return -ENOENT;
+	}
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_CTRL, &ctrl);
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_TOTAL_VF, &total_vf);
+	if (vf_en > total_vf)
+		vf_en = total_vf;
+	dm_pci_write_config16(pdev, pos + PCI_SRIOV_NUM_VF, vf_en);
+
+	ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;
+	dm_pci_write_config16(pdev, pos + PCI_SRIOV_CTRL, ctrl);
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_NUM_VF, &num_vfs);
+	if (num_vfs > vf_en)
+		num_vfs = vf_en;
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_OFFSET, &vf_offset);
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_STRIDE, &vf_stride);
+
+	dm_pci_read_config16(pdev, PCI_VENDOR_ID, &vendor);
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_DID, &device);
+
+	bdf = dm_pci_get_bdf(pdev);
+
+	pci_get_bus(PCI_BUS(bdf), &bus);
+
+	if (!bus)
+		return -ENODEV;
+
+	bdf += PCI_BDF(0, 0, vf_offset);
+
+	for (vf = 0; vf < num_vfs; vf++) {
+		struct pci_child_platdata *pplat;
+		ulong class;
+
+		pci_bus_read_config(bus, bdf, PCI_CLASS_DEVICE,
+				    &class, PCI_SIZE_16);
+
+		debug("%s: bus %d/%s: found VF %x:%x\n", __func__,
+		      bus->seq, bus->name, PCI_DEV(bdf), PCI_FUNC(bdf));
+
+		/* Find this device in the device tree */
+		ret = pci_bus_find_devfn(bus, PCI_MASK_BUS(bdf), &dev);
+
+		if (ret == -ENODEV) {
+			struct pci_device_id find_id;
+
+			memset(&find_id, 0, sizeof(find_id));
+
+			find_id.vendor = vendor;
+			find_id.device = device;
+			find_id.class = class;
+
+			ret = pci_find_and_bind_driver(bus, &find_id,
+						       bdf, &dev);
+
+			if (ret)
+				return ret;
+		}
+
+		/* Update the platform data */
+		pplat = dev_get_parent_platdata(dev);
+		pplat->devfn = PCI_MASK_BUS(bdf);
+		pplat->vendor = vendor;
+		pplat->device = device;
+		pplat->class = class;
+		pplat->is_virtfn = true;
+		pplat->pfdev = pdev;
+		pplat->virtid = vf * vf_stride + vf_offset;
+
+		debug("%s: bus %d/%s: found VF %x:%x %x:%x class %lx id %x\n",
+		      __func__, dev->seq, dev->name, PCI_DEV(bdf),
+		      PCI_FUNC(bdf), vendor, device, class, pplat->virtid);
+		bdf += PCI_BDF(0, 0, vf_stride);
+	}
+
+	return 0;
+
+}
+
+int pci_sriov_get_totalvfs(struct udevice *pdev)
+{
+	u16 total_vf;
+	int pos;
+
+	pos = dm_pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+	if (!pos) {
+		printf("Error: SRIOV capability not found\n");
+		return -ENOENT;
+	}
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_TOTAL_VF, &total_vf);
+
+	return total_vf;
+}
+
 UCLASS_DRIVER(pci) = {
 	.id		= UCLASS_PCI,
 	.name		= "pci",
diff --git a/drivers/pci/pci_mvebu.c b/drivers/pci/pci_mvebu.c
index f9b08f38a1..31dcfc2814 100644
--- a/drivers/pci/pci_mvebu.c
+++ b/drivers/pci/pci_mvebu.c
@@ -272,6 +272,19 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie *pcie)
 	       pcie->base + PCIE_BAR_CTRL_OFF(1));
 }
 
+static void mvebu_pci_fixup_classid(struct mvebu_pcie *pcie)
+{
+	/* Setting pci class id to "bridge other" together with defining flag
+	 * CONFIG_PCIAUTO_SKIP_HOST_BRIDGE allows to skip autoconfiguration
+	 * of BDF=0.0.0 during pci enumeration. Thanks to that the driver
+	 * settings will not be overwritten as it happen with defaults
+	 * configuration where the pcie under BDF 0.0.0 introduce itself as
+	 * Memory controller with classid "0x0580" and in reality is pointing to
+	 * RC itself.
+	 */
+	writew(PCI_CLASS_BRIDGE_OTHER, pcie->base + PCI_CLASS_DEVICE);
+}
+
 static int mvebu_pcie_probe(struct udevice *dev)
 {
 	struct mvebu_pcie *pcie = dev_get_platdata(dev);
@@ -313,6 +326,9 @@ static int mvebu_pcie_probe(struct udevice *dev)
 	reg |= BIT(10);		/* disable interrupts */
 	writel(reg, pcie->base + PCIE_CMD_OFF);
 
+	/* Fixup classid */
+	mvebu_pci_fixup_classid(pcie);
+
 	/* PCI memory space */
 	pci_set_region(hose->regions + 0, pcie->mem.start,
 		       pcie->mem.start, PCIE_MEM_SIZE, PCI_REGION_MEM);
diff --git a/drivers/pci/pci_octeontx.c b/drivers/pci/pci_octeontx.c
new file mode 100644
index 0000000000..1d6b603e78
--- /dev/null
+++ b/drivers/pci/pci_octeontx.c
@@ -0,0 +1,553 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <pci.h>
+
+#include <asm/io.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+#include <asm/arch/soc.h>
+
+#define PEM_CFG_WR 0x18
+#define PEM_CFG_RD 0x20
+
+#define PCIERC_RASDP_DE_ME		0x440
+#define PCIERC_RASDP_EP_CTL		0x420
+#define PCIERC_RAS_EINJ_EN		0x348
+#define PCIERC_RAS_EINJ_CTL6PE		0x3A4
+#define PCIERC_RAS_EINJ_CTL6_CMPP0	0x364
+#define PCIERC_RAS_EINJ_CTL6_CMPV0	0x374
+#define PCIERC_RAS_EINJ_CTL6_CHGP1	0x388
+#define PCIERC_RAS_EINJ_CTL6_CHGV1	0x398
+
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct octeontx_pci {
+	unsigned int type;
+
+	struct fdt_resource cfg;
+	struct fdt_resource bus;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	struct fdt_resource pem;
+#endif
+};
+
+static int pci_octeontx_ecam_read_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong *valuep,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + pcie->bus.start - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12) | offset;
+
+	address += pcie->cfg.start;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = readb(address);
+		break;
+	case PCI_SIZE_16:
+		*valuep = readw(address);
+		break;
+	case PCI_SIZE_32:
+		*valuep = readl(address);
+		break;
+	};
+
+	debug("%02x.%02x.%02x: u%d %x -> %lx\n",
+	      b, d, f, size, offset, *valuep);
+	return 0;
+}
+
+static int pci_octeontx_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
+					  uint offset, ulong valuep,
+					  enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + pcie->bus.start - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12) | offset;
+
+	address += pcie->cfg.start;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		writeb(valuep, address);
+		break;
+	case PCI_SIZE_16:
+		writew(valuep, address);
+		break;
+	case PCI_SIZE_32:
+		writel(valuep, address);
+		break;
+	};
+
+	debug("%02x.%02x.%02x: u%d %x <- %lx\n",
+	      b, d, f, size, offset, valuep);
+	return 0;
+}
+
+static int pci_octeontx_pem_read_config(struct udevice *bus, pci_dev_t bdf,
+					uint offset, ulong *valuep,
+					enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 24) | (d << 19) | (f << 16);
+
+	address += pcie->cfg.start;
+
+	*valuep = pci_conv_32_to_size(~0UL, offset, size);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = readb(address + offset);
+		break;
+	case PCI_SIZE_16:
+		*valuep = readw(address + offset);
+		break;
+	case PCI_SIZE_32:
+		*valuep = readl(address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if (hdrtype == PCI_HEADER_TYPE_BRIDGE &&
+	    offset >= PCI_PRIMARY_BUS &&
+	    offset <= PCI_SUBORDINATE_BUS &&
+	    *valuep != pci_conv_32_to_size(~0UL, offset, size)) {
+		*valuep -= pci_conv_32_to_size(bus_offs, offset, size);
+	}
+	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
+	      b, d, f, size, offset, address, *valuep);
+	return 0;
+}
+
+static int pci_octeontx_pem_write_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong value,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 24) | (d << 19) | (f << 16);
+
+	address += pcie->cfg.start;
+
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if (hdrtype == PCI_HEADER_TYPE_BRIDGE &&
+	    offset >= PCI_PRIMARY_BUS &&
+	    offset <= PCI_SUBORDINATE_BUS &&
+	    value != pci_conv_32_to_size(~0UL, offset, size)) {
+		value +=  pci_conv_32_to_size(bus_offs, offset, size);
+	}
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		writeb(value, address + offset);
+		break;
+	case PCI_SIZE_16:
+		writew(value, address + offset);
+		break;
+	case PCI_SIZE_32:
+		writel(value, address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
+	      b, d, f, size, offset, address, value);
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+static inline bool use_workaround(void)
+{
+	u8 var = read_partvar();
+
+	/* HW issue workaround should be applied only to older silicons */
+	if (otx_is_soc(CN96XX) && var <= 1)
+		return true;
+
+	return false;
+}
+
+static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong *valuep,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12);
+
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx)\n",
+	      bdf, b, d, f, size, offset, address);
+	address += pcie->cfg.start;
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx\n",
+	      b, d, f, size, offset, address, *valuep);
+	*valuep = pci_conv_32_to_size(~0UL, offset, size);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		debug("byte %lx\n", address + offset);
+		*valuep = readb(address + offset);
+		break;
+	case PCI_SIZE_16:
+		debug("word %lx\n", address + offset);
+		*valuep = readw(address + offset);
+		break;
+	case PCI_SIZE_32:
+		debug("long %lx\n", address + offset);
+		*valuep = readl(address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
+	      b, d, f, size, offset, address, *valuep);
+
+	return 0;
+}
+
+static void pci_octeontx2_pem_workaround(struct udevice *bus, uint offset,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	u64 rval, wval;
+	u32 cfg_off, data;
+	u64 raddr, waddr;
+	u8 shift;
+
+	raddr = pcie->pem.start + PEM_CFG_RD;
+	waddr = pcie->pem.start + PEM_CFG_WR;
+
+	debug("%s raddr %llx waddr %llx\n", __func__, raddr, waddr);
+		cfg_off = PCIERC_RASDP_DE_ME;
+		wval = cfg_off;
+	debug("%s DE_ME raddr %llx wval %llx\n", __func__, raddr, wval);
+		writeq(wval, raddr);
+		rval = readq(raddr);
+	debug("%s DE_ME raddr %llx rval %llx\n", __func__, raddr, rval);
+		data = rval >> 32;
+		if (data & 0x1) {
+			data = (data & (~0x1));
+			wval |= ((u64)data << 32);
+	debug("%s DE_ME waddr %llx wval %llx\n", __func__, waddr, wval);
+			writeq(wval, waddr);
+		}
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CMPP0;
+		wval = cfg_off;
+		data = 0xFE000000;
+		wval |= ((u64)data << 32);
+	debug("%s CMPP0 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CMPV0;
+		wval = cfg_off;
+		data = 0x44000000;
+		wval |= ((u64)data << 32);
+	debug("%s CMPV0 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CHGP1;
+		wval = cfg_off;
+		data = 0xFF;
+		wval |= ((u64)data << 32);
+	debug("%s CHGP1 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+	cfg_off = PCIERC_RAS_EINJ_EN;
+	wval = cfg_off;
+	data = 0x40;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_EN waddr %llx wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	cfg_off = PCIERC_RAS_EINJ_CTL6PE;
+	wval = cfg_off;
+	data = 0x1;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_CTL6PE waddr %llx wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	switch (size) {
+	case PCI_SIZE_8:
+		shift = offset % 4;
+		data = (0x1 << shift);
+		break;
+	case PCI_SIZE_16:
+		shift = (offset % 4) ? 2 : 0;
+		data = (0x3 << shift);
+		break;
+	default:
+	case PCI_SIZE_32:
+		data = 0xF;
+		break;
+	}
+
+	cfg_off = PCIERC_RAS_EINJ_CTL6_CHGV1;
+	wval = cfg_off;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_CHGV1 waddr %llx <= wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	cfg_off = PCIERC_RASDP_EP_CTL;
+	wval = cfg_off;
+	wval |= ((u64)0x1 << 32);
+	debug("%s EP_CTL waddr %llx <= wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	wval = readq(waddr);
+	debug("%s EP_CTL waddr %llx => wval %llx\n", __func__, waddr, wval);
+}
+
+static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
+					  uint offset, ulong value,
+					  enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address, addr;
+	u32 b, d, f;
+	u32 data;
+	int tmp;
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12);
+
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx)\n",
+	      bdf, b, d, f, size, offset, address);
+	address += pcie->cfg.start;
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx\n",
+	      b, d, f, size, offset, address, value);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	addr = (address + offset) & ~0x3UL;
+	switch (size) {
+	case PCI_SIZE_8:
+		tmp = (address + offset) & 0x3;
+		size = PCI_SIZE_32;
+		data = readl(addr);
+		debug("tmp 8 long %lx %x\n", addr, data);
+		tmp *= 8;
+		value = (data & ~(0xFFUL << tmp)) | ((value & 0xFF) << tmp);
+	break;
+	case PCI_SIZE_16:
+		tmp = (address + offset) & 0x3;
+		size = PCI_SIZE_32;
+		data = readl(addr);
+		debug("tmp 16 long %lx %x\n", addr, data);
+		tmp *= 8;
+		value = (data & 0xFFFF) | (value << tmp);
+	break;
+	case PCI_SIZE_32:
+	break;
+	}
+	debug("tmp long %lx %lx\n", addr, value);
+
+	if (use_workaround())
+		pci_octeontx2_pem_workaround(bus, offset, size);
+
+	switch (size) {
+	case PCI_SIZE_8:
+		debug("byte %lx %lx\n", address + offset, value);
+		writeb(value, address + offset);
+		break;
+	case PCI_SIZE_16:
+		debug("word %lx %lx\n", address + offset, value);
+		writew(value, address + offset);
+		break;
+	case PCI_SIZE_32:
+		debug("long %lx %lx\n", addr, value);
+		writel(value, addr);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
+	      b, d, f, size, offset, addr, value);
+
+	return 0;
+}
+#endif
+
+static int pci_octeontx_ofdata_to_platdata(struct udevice *dev)
+{
+	return 0;
+}
+
+static int pci_octeontx_ecam_probe(struct udevice *dev)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(dev);
+	int err;
+
+	err = fdt_get_resource(gd->fdt_blob, dev->node.of_offset, "reg", 0,
+			       &pcie->cfg);
+
+	if (err) {
+		printf("Error reading resource: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	err = fdt_node_check_compatible(gd->fdt_blob, dev->node.of_offset,
+					"marvell,pci-host-octeontx2-pem");
+	if (!err) {
+		err = fdt_get_resource(gd->fdt_blob, dev->node.of_offset,
+				       "reg", 1, &pcie->pem);
+
+		if (err) {
+			printf("Error reading resource: %s\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	}
+#endif
+	err = fdtdec_get_pci_bus_range(gd->fdt_blob, dev->node.of_offset,
+				       &pcie->bus);
+
+	if (err) {
+		printf("Error reading resource: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+	return 0;
+}
+
+static const struct dm_pci_ops pci_octeontx_ecam_ops = {
+	.read_config	= pci_octeontx_ecam_read_config,
+	.write_config	= pci_octeontx_ecam_write_config,
+};
+
+static const struct udevice_id pci_octeontx_ecam_ids[] = {
+	{ .compatible = "cavium,pci-host-thunder-ecam" },
+	{ .compatible = "cavium,pci-host-octeontx-ecam" },
+	{ .compatible = "pci-host-ecam-generic" },
+	{ }
+};
+
+U_BOOT_DRIVER(pci_octeontx_ecam) = {
+	.name	= "pci_octeontx_ecam",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx_ecam_ids,
+	.ops	= &pci_octeontx_ecam_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+	.flags = DM_FLAG_PRE_RELOC,
+};
+
+static const struct dm_pci_ops pci_octeontx_pem_ops = {
+	.read_config	= pci_octeontx_pem_read_config,
+	.write_config	= pci_octeontx_pem_write_config,
+};
+
+static const struct udevice_id pci_octeontx_pem_ids[] = {
+	{ .compatible = "cavium,pci-host-thunder-pem" },
+	{ }
+};
+
+U_BOOT_DRIVER(pci_octeontx_pcie) = {
+	.name	= "pci_octeontx_pem",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx_pem_ids,
+	.ops	= &pci_octeontx_pem_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+};
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+static const struct dm_pci_ops pci_octeontx2_pem_ops = {
+	.read_config	= pci_octeontx2_pem_read_config,
+	.write_config	= pci_octeontx2_pem_write_config,
+};
+
+static const struct udevice_id pci_octeontx2_pem_ids[] = {
+	{ .compatible = "marvell,pci-host-octeontx2-pem" },
+	{ }
+};
+
+U_BOOT_DRIVER(pci_octeontx2_pcie) = {
+	.name	= "pci_octeontx2_pem",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx2_pem_ids,
+	.ops	= &pci_octeontx2_pem_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+};
+#endif
diff --git a/drivers/pci/pcie_dw_mvebu.c b/drivers/pci/pcie_dw_mvebu.c
index 95fb41966f..2e74833add 100644
--- a/drivers/pci/pcie_dw_mvebu.c
+++ b/drivers/pci/pcie_dw_mvebu.c
@@ -112,6 +112,7 @@ struct pcie_dw_mvebu {
 	int first_busno;
 
 	/* IO and MEM PCI regions */
+	int region_count;
 	struct pci_region io;
 	struct pci_region mem;
 };
@@ -264,9 +265,10 @@ static int pcie_dw_mvebu_read_config(struct udevice *bus, pci_dev_t bdf,
 	debug("(addr,val)=(0x%04x, 0x%08lx)\n", offset, value);
 	*valuep = pci_conv_32_to_size(value, offset, size);
 
-	pcie_dw_prog_outbound_atu(pcie, PCIE_ATU_REGION_INDEX0,
-				  PCIE_ATU_TYPE_IO, pcie->io.phys_start,
-				  pcie->io.bus_start, pcie->io.size);
+	if (pcie->region_count > 1)
+		pcie_dw_prog_outbound_atu(pcie, PCIE_ATU_REGION_INDEX0,
+					  PCIE_ATU_TYPE_IO, pcie->io.phys_start,
+					  pcie->io.bus_start, pcie->io.size);
 
 	return 0;
 }
@@ -309,9 +311,10 @@ static int pcie_dw_mvebu_write_config(struct udevice *bus, pci_dev_t bdf,
 	value = pci_conv_size_to_32(old, value, offset, size);
 	writel(value, va_address);
 
-	pcie_dw_prog_outbound_atu(pcie, PCIE_ATU_REGION_INDEX0,
-				  PCIE_ATU_TYPE_IO, pcie->io.phys_start,
-				  pcie->io.bus_start, pcie->io.size);
+	if (pcie->region_count > 1)
+		pcie_dw_prog_outbound_atu(pcie, PCIE_ATU_REGION_INDEX0,
+					  PCIE_ATU_TYPE_IO, pcie->io.phys_start,
+					  pcie->io.bus_start, pcie->io.size);
 
 	return 0;
 }
@@ -510,14 +513,24 @@ static int pcie_dw_mvebu_probe(struct udevice *dev)
 		       hose->first_busno);
 	}
 
+	pcie->region_count = hose->region_count - CONFIG_NR_DRAM_BANKS;
+
 	/* Store the IO and MEM windows settings for future use by the ATU */
-	pcie->io.phys_start = hose->regions[0].phys_start; /* IO base */
-	pcie->io.bus_start  = hose->regions[0].bus_start;  /* IO_bus_addr */
-	pcie->io.size	    = hose->regions[0].size;	   /* IO size */
+	if (pcie->region_count > 1) {
+		/* IO base */
+		pcie->io.phys_start = hose->regions[0].phys_start;
+		/* IO_bus_addr */
+		pcie->io.bus_start  = hose->regions[0].bus_start;
+		/* IO size */
+		pcie->io.size       = hose->regions[0].size;
+	}
 
-	pcie->mem.phys_start = hose->regions[1].phys_start; /* MEM base */
-	pcie->mem.bus_start  = hose->regions[1].bus_start;  /* MEM_bus_addr */
-	pcie->mem.size	     = hose->regions[1].size;	    /* MEM size */
+	/* MEM base */
+	pcie->mem.phys_start = hose->regions[pcie->region_count - 1].phys_start;
+	/* MEM_bus_addr */
+	pcie->mem.bus_start  = hose->regions[pcie->region_count - 1].bus_start;
+	/* MEM size */
+	pcie->mem.size       = hose->regions[pcie->region_count - 1].size;
 
 	pcie_dw_prog_outbound_atu(pcie, PCIE_ATU_REGION_INDEX1,
 				  PCIE_ATU_TYPE_MEM, pcie->mem.phys_start,
diff --git a/drivers/phy/marvell/Makefile b/drivers/phy/marvell/Makefile
index 51be0399ea..a5c28fe12e 100644
--- a/drivers/phy/marvell/Makefile
+++ b/drivers/phy/marvell/Makefile
@@ -1,6 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0+
 
 obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_core.o
-obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_mux.o
 obj-$(CONFIG_ARMADA_3700) += comphy_a3700.o
 obj-$(CONFIG_ARMADA_8K) += comphy_cp110.o
diff --git a/drivers/phy/marvell/comphy_a3700.c b/drivers/phy/marvell/comphy_a3700.c
index 3b2902f362..b1b0b47e49 100644
--- a/drivers/phy/marvell/comphy_a3700.c
+++ b/drivers/phy/marvell/comphy_a3700.c
@@ -13,135 +13,53 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct comphy_mux_data a3700_comphy_mux_data[] = {
-/* Lane 0 */
-	{
-		4,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0 },
-			{ PHY_TYPE_SGMII1,	0x0 },
-			{ PHY_TYPE_USB3_HOST0,	0x1 },
-			{ PHY_TYPE_USB3_DEVICE,	0x1 }
-		}
-	},
-/* Lane 1 */
-	{
-		3,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0},
-			{ PHY_TYPE_SGMII0,	0x0},
-			{ PHY_TYPE_PEX0,	0x1}
-		}
-	},
-/* Lane 2 */
-	{
-		4,
-		{
-			{ PHY_TYPE_UNCONNECTED,	0x0},
-			{ PHY_TYPE_SATA0,	0x0},
-			{ PHY_TYPE_USB3_HOST0,	0x1},
-			{ PHY_TYPE_USB3_DEVICE,	0x1}
-		}
-	},
-};
-
-struct sgmii_phy_init_data_fix {
-	u16 addr;
-	u16 value;
-};
-
-/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
-static struct sgmii_phy_init_data_fix sgmii_phy_init_fix[] = {
-	{0x005, 0x07CC}, {0x015, 0x0000}, {0x01B, 0x0000}, {0x01D, 0x0000},
-	{0x01E, 0x0000}, {0x01F, 0x0000}, {0x020, 0x0000}, {0x021, 0x0030},
-	{0x026, 0x0888}, {0x04D, 0x0152}, {0x04F, 0xA020}, {0x050, 0x07CC},
-	{0x053, 0xE9CA}, {0x055, 0xBD97}, {0x071, 0x3015}, {0x076, 0x03AA},
-	{0x07C, 0x0FDF}, {0x0C2, 0x3030}, {0x0C3, 0x8000}, {0x0E2, 0x5550},
-	{0x0E3, 0x12A4}, {0x0E4, 0x7D00}, {0x0E6, 0x0C83}, {0x101, 0xFCC0},
-	{0x104, 0x0C10}
-};
-
-/* 40M1G25 mode init data */
-static u16 sgmii_phy_init[512] = {
-	/* 0       1       2       3       4       5       6       7 */
-	/*-----------------------------------------------------------*/
-	/* 8       9       A       B       C       D       E       F */
-	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,	/* 00 */
-	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,	/* 08 */
-	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,	/* 10 */
-	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,	/* 18 */
-	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,	/* 20 */
-	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,	/* 28 */
-	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* 30 */
-	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,	/* 38 */
-	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,	/* 40 */
-	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,	/* 48 */
-	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,	/* 50 */
-	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,	/* 58 */
-	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,	/* 60 */
-	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,	/* 68 */
-	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,	/* 70 */
-	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,	/* 78 */
-	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,	/* 80 */
-	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,	/* 88 */
-	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,	/* 90 */
-	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,	/* 98 */
-	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,	/* A0 */
-	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* B0 */
-	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,	/* B8 */
-	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,	/* C0 */
-	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,	/* C8 */
-	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,	/* D0 */
-	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,	/* D8 */
-	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,	/* E0 */
-	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,	/* E8 */
-	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,	/* F0 */
-	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,	/* F8 */
-	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,	/*100 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*108 */
-	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,	/*110 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*118 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*120 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*128 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*130 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*138 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*140 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*148 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*150 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*158 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*160 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*168 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*170 */
-	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,	/*178 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*180 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*188 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*190 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*198 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1F0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000	/*1F8 */
-};
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+
+#define COMPHY_FW_MODE_FORMAT(mode, invert)	((mode) << 12 | (invert) << 0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
+#define A3700_LANE_MAX_NUM	3
+
+static int comphy_smc(u32 function_id, u32 lane, u32 mode)
+{
+#ifndef CONFIG_MVEBU_PALLADIUM
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = lane;
+	pregs.regs[2] = mode;
+
+	smc_call(&pregs);
+
+	return pregs.regs[0];
+#else
+	return 1;
+#endif
+}
 
 /*
  * comphy_poll_reg
  *
  * return: 1 on success, 0 on timeout
  */
-static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u8 op_type)
+static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout,
+			   u8 op_type)
 {
-	u32 rval = 0xDEAD, timeout;
+	u32 rval = 0xDEAD;
 
-	for (timeout = PLL_LOCK_TIMEOUT; timeout > 0; timeout--) {
+	for (; timeout > 0; timeout--) {
 		if (op_type == POLL_16B_REG)
 			rval = readw(addr);	/* 16 bit */
 		else
@@ -157,367 +75,72 @@ static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u8 op_type)
 	return 0;
 }
 
-/*
- * comphy_pcie_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
- */
-static int comphy_pcie_power_up(u32 speed, u32 invert)
-{
-	int ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Enable max PLL.
-	 */
-	reg_set16(phy_addr(PCIE, LANE_CFG1), bf_use_max_pll_rate, 0);
-
-	/*
-	 * 2. Select 20 bit SERDES interface.
-	 */
-	reg_set16(phy_addr(PCIE, GLOB_CLK_SRC_LO), bf_cfg_sel_20b, 0);
-
-	/*
-	 * 3. Force to use reg setting for PCIe mode
-	 */
-	reg_set16(phy_addr(PCIE, MISC_REG1), bf_sel_bits_pcie_force, 0);
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16(phy_addr(PCIE, PWR_MGM_TIM1), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16(phy_addr(PCIE, UNIT_CTRL), 0x60 | rb_idle_sync_en, 0xFFFF);
-
-	/*
-	 * 6. Enable the output of 100M/125M/500M clock
-	 */
-	reg_set16(phy_addr(PCIE, MISC_REG0),
-		  0xA00D | rb_clk500m_en | rb_clk100m_125m_en, 0xFFFF);
-
-	/*
-	 * 7. Enable TX
-	 */
-	reg_set(PCIE_REF_CLK_ADDR, 0x1342, 0xFFFFFFFF);
-
-	/*
-	 * 8. Check crystal jumper setting and program the Power and PLL
-	 *    Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		reg_set16(phy_addr(PCIE, PWR_PLL_CTRL), 0xFC63, 0xFFFF);
-	} else {
-		/* 25 MHz */
-		reg_set16(phy_addr(PCIE, PWR_PLL_CTRL), 0xFC62, 0xFFFF);
-	}
-
-	/*
-	 * 9. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16(phy_addr(PCIE, KVCO_CAL_CTRL), 0x0040 | rb_use_max_pll_rate,
-		  0xFFFF);
-
-	/*
-	 * 10. Check the Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT)
-		reg_set16(phy_addr(PCIE, SYNC_PATTERN), phy_txd_inv, 0);
-
-	if (invert & PHY_POLARITY_RXD_INVERT)
-		reg_set16(phy_addr(PCIE, SYNC_PATTERN), phy_rxd_inv, 0);
-
-	/*
-	 * 11. Release SW reset
-	 */
-	reg_set16(phy_addr(PCIE, GLOB_PHY_CTRL0),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32,
-		  bf_soft_rst | bf_mode_refdiv);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg(phy_addr(PCIE, LANE_STAT1),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      POLL_16B_REG);			/* 16bit */
-	if (!ret)
-		printf("Failed to lock PCIe PLL\n");
-
-	debug_exit();
-
-	/* Return the status of the PLL */
-	return ret;
-}
-
-/*
- * reg_set_indirect
- *
- * return: void
- */
-static void reg_set_indirect(u32 reg, u16 data, u16 mask)
-{
-	reg_set(rh_vsreg_addr, reg, 0xFFFFFFFF);
-	reg_set(rh_vsreg_data, data, mask);
-}
-
 /*
  * comphy_sata_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_sata_power_up(void)
+static int comphy_sata_power_up(u32 invert, u32 lane)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
 	/*
-	 * 0. Swap SATA TX lines
-	 */
-	reg_set_indirect(vphy_sync_pattern_reg, bs_txd_inv, bs_txd_inv);
-
-	/*
-	 * 1. Select 40-bit data width width
-	 */
-	reg_set_indirect(vphy_loopback_reg0, 0x800, bs_phyintf_40bit);
-
-	/*
-	 * 2. Select reference clock and PHY mode (SATA)
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		reg_set_indirect(vphy_power_reg0, 0x3, 0x00FF);
-	} else {
-		/* 20 MHz */
-		reg_set_indirect(vphy_power_reg0, 0x1, 0x00FF);
-	}
-
-	/*
-	 * 3. Use maximum PLL rate (no power save)
+	 * Set vendor-specific configuration (??).
+	 * It was done in the middle of comphy initialization but test shows
+	 * that moving it before strict comphy init works ok. Thanks to that the
+	 * comphy init can be done with pure comphy range access, not touching
+	 * ahci range.
 	 */
-	reg_set_indirect(vphy_calctl_reg, bs_max_pll_rate, bs_max_pll_rate);
+	reg_set((void __iomem *)rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
+	reg_set((void __iomem *)rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
 
-	/*
-	 * 4. Reset reserved bit (??)
-	 */
-	reg_set_indirect(vphy_reserve_reg, 0, bs_phyctrl_frm_pin);
-
-	/*
-	 * 5. Set vendor-specific configuration (??)
-	 */
-	reg_set(rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
-	reg_set(rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
-
-	/* Wait for > 55 us to allow PLL be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert SATA PLL enabled */
-	reg_set(rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	ret = comphy_poll_reg(rh_vsreg_data,	/* address */
-			      bs_pll_ready_tx,	/* value */
-			      bs_pll_ready_tx,	/* mask */
-			      POLL_32B_REG);	/* 32bit */
-	if (!ret)
-		printf("Failed to lock SATA PLL\n");
-
-	debug_exit();
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE, invert));
 
 	return ret;
 }
 
-/*
- * usb3_reg_set16
- *
- * return: void
- */
-static void usb3_reg_set16(u32 reg, u16 data, u16 mask, u32 lane)
-{
-	/*
-	 * When Lane 2 PHY is for USB3, access the PHY registers
-	 * through indirect Address and Data registers INDIR_ACC_PHY_ADDR
-	 * (RD00E0178h [31:0]) and INDIR_ACC_PHY_DATA (RD00E017Ch [31:0])
-	 * within the SATA Host Controller registers, Lane 2 base register
-	 * offset is 0x200
-	 */
-
-	if (lane == 2)
-		reg_set_indirect(USB3PHY_LANE2_REG_BASE_OFFSET + reg, data,
-				 mask);
-	else
-		reg_set16(phy_addr(USB3, reg), data, mask);
-}
-
 /*
  * comphy_usb3_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_usb3_power_up(u32 lane, u32 type, u32 speed, u32 invert)
+static int comphy_usb3_power_up(u32 speed, u32 invert, u32 lane,
+				bool indirect_reg_access)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
 	/*
 	 * 1. Power up OTG module
 	 */
-	reg_set(USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+	reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
 
 	/*
 	 * 2. Set counter for 100us pulse in USB3 Host and Device
 	 * restore default burst size limit (Reference Clock 31:24)
 	 */
-	reg_set(USB3_CTRPUL_VAL_REG, 0x8 << 24, rb_usb3_ctr_100ns);
+	reg_set((void __iomem *)USB3_CTRPUL_VAL_REG,
+		0x8 << 24, rb_usb3_ctr_100ns);
 
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_USB3_MODE, invert));
 
-	/* 0xd005c300 = 0x1001 */
-	/* set PRD_TXDEEMPH (3.5db de-emph) */
-	usb3_reg_set16(LANE_CFG0, 0x1, 0xFF, lane);
-
-	/*
-	 * Set BIT0: enable transmitter in high impedance mode
-	 * Set BIT[3:4]: delay 2 clock cycles for HiZ off latency
-	 * Set BIT6: Tx detect Rx at HiZ mode
-	 * Unset BIT15: set to 0 to set USB3 De-emphasize level to -3.5db
-	 *              together with bit 0 of COMPHY_REG_LANE_CFG0_ADDR
-	 *              register
-	 */
-	usb3_reg_set16(LANE_CFG1,
-		       tx_det_rx_mode | gen2_tx_data_dly_deft
-		       | tx_elec_idle_mode_en,
-		       prd_txdeemph1_mask | tx_det_rx_mode
-		       | gen2_tx_data_dly_mask | tx_elec_idle_mode_en, lane);
-
-	/* 0xd005c310 = 0x93: set Spread Spectrum Clock Enabled */
-	usb3_reg_set16(LANE_CFG4, bf_spread_spectrum_clock_en, 0x80, lane);
-
-	/*
-	 * set Override Margining Controls From the MAC: Use margining signals
-	 * from lane configuration
-	 */
-	usb3_reg_set16(TEST_MODE_CTRL, rb_mode_margin_override, 0xFFFF, lane);
-
-	/* set Lane-to-Lane Bundle Clock Sampling Period = per PCLK cycles */
-	/* set Mode Clock Source = PCLK is generated from REFCLK */
-	usb3_reg_set16(GLOB_CLK_SRC_LO, 0x0, 0xFF, lane);
-
-	/* set G2 Spread Spectrum Clock Amplitude at 4K */
-	usb3_reg_set16(GEN2_SETTINGS_2, g2_tx_ssc_amp, 0xF000, lane);
-
-	/*
-	 * unset G3 Spread Spectrum Clock Amplitude & set G3 TX and RX Register
-	 * Master Current Select
+	/* No matter host mode and device mode, it works with Hard ID detection
+	 * Unset DP and DM pulldown for USB2 Device mode
 	 */
-	usb3_reg_set16(GEN2_SETTINGS_3, 0x0, 0xFFFF, lane);
+	reg_set((void __iomem *)USB2_OTG_PHY_CTRL_ADDR, 0x0,
+		rb_usb2_dp_pulldn_dev_mode | rb_usb2_dm_pulldn_dev_mode);
 
-	/*
-	 * 3. Check crystal jumper setting and program the Power and PLL
-	 * Control accordingly
-	 * 4. Change RX wait
-	 */
-	if (get_ref_clk() == 40) {
-		/* 40 MHz */
-		usb3_reg_set16(PWR_PLL_CTRL, 0xFCA3, 0xFFFF, lane);
-		usb3_reg_set16(PWR_MGM_TIM1, 0x10C, 0xFFFF, lane);
-	} else {
-		/* 25 MHz */
-		usb3_reg_set16(PWR_PLL_CTRL, 0xFCA2, 0xFFFF, lane);
-		usb3_reg_set16(PWR_MGM_TIM1, 0x107, 0xFFFF, lane);
-	}
+	/* Disbale VBus interrupt which will be enable again in kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0, vbus_int_enable);
 
-	/*
-	 * 5. Enable idle sync
-	 */
-	usb3_reg_set16(UNIT_CTRL, 0x60 | rb_idle_sync_en, 0xFFFF, lane);
-
-	/*
-	 * 6. Enable the output of 500M clock
-	 */
-	usb3_reg_set16(MISC_REG0, 0xA00D | rb_clk500m_en, 0xFFFF, lane);
-
-	/*
-	 * 7. Set 20-bit data width
-	 */
-	usb3_reg_set16(DIG_LB_EN, 0x0400, 0xFFFF, lane);
-
-	/*
-	 * 8. Override Speed_PLL value and use MAC PLL
-	 */
-	usb3_reg_set16(KVCO_CAL_CTRL, 0x0040 | rb_use_max_pll_rate, 0xFFFF,
-		       lane);
-
-	/*
-	 * 9. Check the Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT)
-		usb3_reg_set16(SYNC_PATTERN, phy_txd_inv, 0, lane);
-
-	if (invert & PHY_POLARITY_RXD_INVERT)
-		usb3_reg_set16(SYNC_PATTERN, phy_rxd_inv, 0, lane);
-
-	/*
-	 * 10. Set max speed generation to USB3.0 5Gbps
-	 */
-	usb3_reg_set16(SYNC_MASK_GEN, 0x0400, 0x0C00, lane);
-
-	/*
-	 * 11. Set capacitor value for FFE gain peaking to 0xF
-	 */
-	usb3_reg_set16(GEN3_SETTINGS_3, 0xF, 0xF, lane);
-
-	/*
-	 * 12. Release SW reset
-	 */
-	usb3_reg_set16(GLOB_PHY_CTRL0,
-		       rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32
-		       | 0x20, 0xFFFF, lane);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	if (lane == 2) {
-		reg_set(rh_vsreg_addr,
-			LANE_STAT1 + USB3PHY_LANE2_REG_BASE_OFFSET,
-			0xFFFFFFFF);
-		ret = comphy_poll_reg(rh_vsreg_data,		/* address */
-				      rb_txdclk_pclk_en,	/* value */
-				      rb_txdclk_pclk_en,	/* mask */
-				      POLL_32B_REG);		/* 32bit */
-	} else {
-		ret = comphy_poll_reg(phy_addr(USB3, LANE_STAT1), /* address */
-				      rb_txdclk_pclk_en,	  /* value */
-				      rb_txdclk_pclk_en,	  /* mask */
-				      POLL_16B_REG);		  /* 16bit */
-	}
-	if (!ret)
-		printf("Failed to lock USB3 PLL\n");
-
-	/*
-	 * Set Soft ID for Host mode (Device mode works with Hard ID
-	 * detection)
-	 */
-	if (type == PHY_TYPE_USB3_HOST0) {
-		/*
-		 * set   BIT0: set ID_MODE of Host/Device = "Soft ID" (BIT1)
-		 * clear BIT1: set SOFT_ID = Host
-		 * set   BIT4: set INT_MODE = ID. Interrupt Mode: enable
-		 *             interrupt by ID instead of using both interrupts
-		 *             of HOST and Device ORed simultaneously
-		 *             INT_MODE=ID in order to avoid unexpected
-		 *             behaviour or both interrupts together
-		 */
-		reg_set(USB32_CTRL_BASE,
-			usb32_ctrl_id_mode | usb32_ctrl_int_mode,
-			usb32_ctrl_id_mode | usb32_ctrl_soft_id |
-			usb32_ctrl_int_mode);
-	}
+	/* Clear VBus interrupt to prepare a clean state for kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+		vbus_int_state, vbus_int_state);
 
 	debug_exit();
 
@@ -531,7 +154,7 @@ static int comphy_usb3_power_up(u32 lane, u32 type, u32 speed, u32 invert)
  */
 static int comphy_usb2_power_up(u8 usb32)
 {
-	int ret;
+	int	ret;
 
 	debug_enter();
 
@@ -547,63 +170,79 @@ static int comphy_usb2_power_up(u8 usb32)
 	 *    See "PLL Settings for Typical REFCLK" table
 	 */
 	if (get_ref_clk() == 25) {
-		reg_set(USB2_PHY_BASE(usb32), 5 | (96 << 16),
-			0x3F | (0xFF << 16) | (0x3 << 28));
+		reg_set((void __iomem *)USB2_PHY_BASE(usb32),
+			5 | (96 << 16), 0x3F | (0xFF << 16) | (0x3 << 28));
 	}
 
 	/*
 	 * 1. PHY pull up and disable USB2 suspend
 	 */
-	reg_set(USB2_PHY_CTRL_ADDR(usb32),
+	reg_set((void __iomem *)USB2_PHY_CTRL_ADDR(usb32),
 		RB_USB2PHY_SUSPM(usb32) | RB_USB2PHY_PU(usb32), 0);
 
 	if (usb32 != 0) {
 		/*
 		 * 2. Power up OTG module
 		 */
-		reg_set(USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+		reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
 
 		/*
 		 * 3. Configure PHY charger detection
 		 */
-		reg_set(USB2_PHY_CHRGR_DET_ADDR, 0,
+		reg_set((void __iomem *)USB2_PHY_CHRGR_DET_ADDR, 0,
 			rb_cdp_en | rb_dcp_en | rb_pd_en | rb_cdp_dm_auto |
 			rb_enswitch_dp | rb_enswitch_dm | rb_pu_chrg_dtc);
 	}
 
 	/* Assert PLL calibration done */
-	ret = comphy_poll_reg(USB2_PHY_CAL_CTRL_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_CAL_CTRL_ADDR(usb32),
 			      rb_usb2phy_pllcal_done,	/* value */
 			      rb_usb2phy_pllcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 PLL calibration\n");
 
 	/* Assert impedance calibration done */
-	ret = comphy_poll_reg(USB2_PHY_CAL_CTRL_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_CAL_CTRL_ADDR(usb32),
 			      rb_usb2phy_impcal_done,	/* value */
 			      rb_usb2phy_impcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 impedance calibration\n");
 
 	/* Assert squetch calibration done */
-	ret = comphy_poll_reg(USB2_PHY_RX_CHAN_CTRL1_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_RX_CHAN_CTRL1_ADDR(usb32),
 			      rb_usb2phy_sqcal_done,	/* value */
 			      rb_usb2phy_sqcal_done,	/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to end USB2 unknown calibration\n");
 
 	/* Assert PLL is ready */
-	ret = comphy_poll_reg(USB2_PHY_PLL_CTRL0_ADDR(usb32),
+	ret = comphy_poll_reg((void *)USB2_PHY_PLL_CTRL0_ADDR(usb32),
 			      rb_usb2phy_pll_ready,		/* value */
 			      rb_usb2phy_pll_ready,		/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
 			      POLL_32B_REG);		/* 32bit */
 
-	if (!ret)
+	if (ret == 0)
 		printf("Failed to lock USB2 PLL\n");
 
+	if (usb32) {
+		/*
+		 * Disbale VBus interrupt which will be
+		 * enable again in kernel
+		 */
+		reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0,
+			vbus_int_enable);
+		/* Clear VBus interrupt to prepare a clean state for kernel */
+		reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+			vbus_int_state, vbus_int_state);
+	}
+
 	debug_exit();
 
 	return ret;
@@ -621,34 +260,35 @@ static int comphy_emmc_power_up(void)
 	/*
 	 * 1. Bus power ON, Bus voltage 1.8V
 	 */
-	reg_set(SDIO_HOST_CTRL1_ADDR, 0xB00, 0xF00);
+	reg_set((void __iomem *)SDIO_HOST_CTRL1_ADDR, 0xB00, 0xF00);
 
 	/*
 	 * 2. Set FIFO parameters
 	 */
-	reg_set(SDIO_SDHC_FIFO_ADDR, 0x315, 0xFFFFFFFF);
+	reg_set((void __iomem *)SDIO_SDHC_FIFO_ADDR, 0x315, 0xFFFFFFFF);
 
 	/*
 	 * 3. Set Capabilities 1_2
 	 */
-	reg_set(SDIO_CAP_12_ADDR, 0x25FAC8B2, 0xFFFFFFFF);
+	reg_set((void __iomem *)SDIO_CAP_12_ADDR, 0x25FAC8B2, 0xFFFFFFFF);
 
 	/*
 	 * 4. Set Endian
 	 */
-	reg_set(SDIO_ENDIAN_ADDR, 0x00c00000, 0);
+	reg_set((void __iomem *)SDIO_ENDIAN_ADDR, 0x00c00000, 0);
 
 	/*
 	 * 4. Init PHY
 	 */
-	reg_set(SDIO_PHY_TIMING_ADDR, 0x80000000, 0x80000000);
-	reg_set(SDIO_PHY_PAD_CTRL0_ADDR, 0x50000000, 0xF0000000);
+	reg_set((void __iomem *)SDIO_PHY_TIMING_ADDR, 0x80000000, 0x80000000);
+	reg_set((void __iomem *)SDIO_PHY_PAD_CTRL0_ADDR, 0x50000000,
+		0xF0000000);
 
 	/*
 	 * 5. DLL reset
 	 */
-	reg_set(SDIO_DLL_RST_ADDR, 0xFFFEFFFF, 0);
-	reg_set(SDIO_DLL_RST_ADDR, 0x00010000, 0);
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0xFFFEFFFF, 0);
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0x00010000, 0);
 
 	debug_exit();
 
@@ -656,236 +296,9 @@ static int comphy_emmc_power_up(void)
 }
 
 /*
- * comphy_sgmii_power_up
- *
- * return:
- */
-static void comphy_sgmii_phy_init(u32 lane, u32 speed)
-{
-	const int fix_arr_sz = ARRAY_SIZE(sgmii_phy_init_fix);
-	int addr, fix_idx;
-	u16 val;
-
-	fix_idx = 0;
-	for (addr = 0; addr < 512; addr++) {
-		/*
-		 * All PHY register values are defined in full for 3.125Gbps
-		 * SERDES speed. The values required for 1.25 Gbps are almost
-		 * the same and only few registers should be "fixed" in
-		 * comparison to 3.125 Gbps values. These register values are
-		 * stored in "sgmii_phy_init_fix" array.
-		 */
-		if ((speed != PHY_SPEED_1_25G) &&
-		    (sgmii_phy_init_fix[fix_idx].addr == addr)) {
-			/* Use new value */
-			val = sgmii_phy_init_fix[fix_idx].value;
-			if (fix_idx < fix_arr_sz)
-				fix_idx++;
-		} else {
-			val = sgmii_phy_init[addr];
-		}
-
-		reg_set16(sgmiiphy_addr(lane, addr), val, 0xFFFF);
-	}
-}
-
-/*
- * comphy_sgmii_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ * comphy_dedicated_phys_init initialize the dedicated PHYs
+ * - not muxed SerDes lanes e.g. UTMI PHY
  */
-static int comphy_sgmii_power_up(u32 lane, u32 speed, u32 invert)
-{
-	int ret;
-	u32 saved_selector;
-
-	debug_enter();
-
-	/*
-	 * 1. Configure PHY to SATA/SAS mode by setting pin PIN_PIPE_SEL=0
-	 */
-	saved_selector = readl(COMPHY_SEL_ADDR);
-	reg_set(COMPHY_SEL_ADDR, 0, 0xFFFFFFFF);
-
-	/*
-	 * 2. Reset PHY by setting PHY input port PIN_RESET=1.
-	 * 3. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
-	 *    PHY TXP/TXN output to idle state during PHY initialization
-	 * 4. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_reset_comphy | rb_pin_tx_idle | rb_pin_pu_iveref,
-		rb_pin_reset_core | rb_pin_pu_pll |
-		rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 5. Release reset to the PHY by setting PIN_RESET=0.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), 0, rb_pin_reset_comphy);
-
-	/*
-	 * 7. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide
-	 *    COMPHY bit rate
-	 */
-	if (speed == PHY_SPEED_3_125G) { /* 3.125 GHz */
-		reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-			(0x8 << rf_gen_rx_sel_shift) |
-			(0x8 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-
-	} else if (speed == PHY_SPEED_1_25G) { /* 1.25 GHz */
-		reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-			(0x6 << rf_gen_rx_sel_shift) |
-			(0x6 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-	} else {
-		printf("Unsupported COMPHY speed!\n");
-		return 0;
-	}
-
-	/*
-	 * 8. Wait 1mS for bandgap and reference clocks to stabilize;
-	 *    then start SW programming.
-	 */
-	mdelay(10);
-
-	/* 9. Program COMPHY register PHY_MODE */
-	reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-		  PHY_MODE_SGMII << rf_phy_mode_shift, rf_phy_mode_mask);
-
-	/*
-	 * 10. Set COMPHY register REFCLK_SEL to select the correct REFCLK
-	 *     source
-	 */
-	reg_set16(sgmiiphy_addr(lane, MISC_REG0), 0, rb_ref_clk_sel);
-
-	/*
-	 * 11. Set correct reference clock frequency in COMPHY register
-	 *     REF_FREF_SEL.
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-			  0x4 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	} else {
-		/* 25MHz */
-		reg_set16(sgmiiphy_addr(lane, PWR_PLL_CTRL),
-			  0x1 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	}
-
-	/* 12. Program COMPHY register PHY_GEN_MAX[1:0] */
-	/*
-	 * This step is mentioned in the flow received from verification team.
-	 * However the PHY_GEN_MAX value is only meaningful for other
-	 * interfaces (not SGMII). For instance, it selects SATA speed
-	 * 1.5/3/6 Gbps or PCIe speed  2.5/5 Gbps
-	 */
-
-	/*
-	 * 13. Program COMPHY register SEL_BITS to set correct parallel data
-	 *     bus width
-	 */
-	/* 10bit */
-	reg_set16(sgmiiphy_addr(lane, DIG_LB_EN), 0, rf_data_width_mask);
-
-	/*
-	 * 14. As long as DFE function needs to be enabled in any mode,
-	 *     COMPHY register DFE_UPDATE_EN[5:0] shall be programmed to 0x3F
-	 *     for real chip during COMPHY power on.
-	 */
-	/*
-	 * The step 14 exists (and empty) in the original initialization flow
-	 * obtained from the verification team. According to the functional
-	 * specification DFE_UPDATE_EN already has the default value 0x3F
-	 */
-
-	/*
-	 * 15. Program COMPHY GEN registers.
-	 *     These registers should be programmed based on the lab testing
-	 *     result to achieve optimal performance. Please contact the CEA
-	 *     group to get the related GEN table during real chip bring-up.
-	 *     We only requred to run though the entire registers programming
-	 *     flow defined by "comphy_sgmii_phy_init" when the REF clock is
-	 *     40 MHz. For REF clock 25 MHz the default values stored in PHY
-	 *     registers are OK.
-	 */
-	debug("Running C-DPI phy init %s mode\n",
-	      speed == PHY_SPEED_3_125G ? "2G5" : "1G");
-	if (get_ref_clk() == 40)
-		comphy_sgmii_phy_init(lane, speed);
-
-	/*
-	 * 16. [Simulation Only] should not be used for real chip.
-	 *     By pass power up calibration by programming EXT_FORCE_CAL_DONE
-	 *     (R02h[9]) to 1 to shorten COMPHY simulation time.
-	 */
-	/*
-	 * 17. [Simulation Only: should not be used for real chip]
-	 *     Program COMPHY register FAST_DFE_TIMER_EN=1 to shorten RX
-	 *     training simulation time.
-	 */
-
-	/*
-	 * 18. Check the PHY Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT)
-		reg_set16(sgmiiphy_addr(lane, SYNC_PATTERN), phy_txd_inv, 0);
-
-	if (invert & PHY_POLARITY_RXD_INVERT)
-		reg_set16(sgmiiphy_addr(lane, SYNC_PATTERN), phy_rxd_inv, 0);
-
-	/*
-	 * 19. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1
-	 *     to start PHY power up sequence. All the PHY register
-	 *     programming should be done before PIN_PU_PLL=1. There should be
-	 *     no register programming for normal PHY operation from this point.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx,
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 20. Wait for PHY power up sequence to finish by checking output ports
-	 *     PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
-	 */
-	ret = comphy_poll_reg(COMPHY_PHY_STAT1_ADDR(lane),	/* address */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* value */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* mask */
-			      POLL_32B_REG);			/* 32bit */
-	if (!ret)
-		printf("Failed to lock PLL for SGMII PHY %d\n", lane);
-
-	/*
-	 * 21. Set COMPHY input port PIN_TX_IDLE=0
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), 0x0, rb_pin_tx_idle);
-
-	/*
-	 * 22. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1.
-	 *     to start RX initialization. PIN_RX_INIT_DONE will be cleared to
-	 *     0 by the PHY. After RX initialization is done, PIN_RX_INIT_DONE
-	 *     will be set to 1 by COMPHY. Set PIN_RX_INIT=0 after
-	 *     PIN_RX_INIT_DONE= 1.
-	 *     Please refer to RX initialization part for details.
-	 */
-	reg_set(COMPHY_PHY_CFG1_ADDR(lane), rb_phy_rx_init, 0x0);
-
-	ret = comphy_poll_reg(COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_rx_init_done,			/* value */
-			      rb_rx_init_done,			/* mask */
-			      POLL_32B_REG);			/* 32bit */
-	if (!ret)
-		printf("Failed to init RX of SGMII PHY %d\n", lane);
-
-	/*
-	 * Restore saved selector.
-	 */
-	reg_set(COMPHY_SEL_ADDR, saved_selector, 0xFFFFFFFF);
-
-	debug_exit();
-
-	return ret;
-}
-
 void comphy_dedicated_phys_init(void)
 {
 	int node, usb32, ret = 1;
@@ -909,7 +322,7 @@ void comphy_dedicated_phys_init(void)
 		if (node > 0) {
 			if (fdtdec_get_is_enabled(blob, node)) {
 				ret = comphy_usb2_power_up(usb32);
-				if (!ret)
+				if (ret == 0)
 					printf("Failed to initialize UTMI PHY\n");
 				else
 					debug("UTMI PHY init succeed\n");
@@ -922,22 +335,6 @@ void comphy_dedicated_phys_init(void)
 		}
 	}
 
-	node = fdt_node_offset_by_compatible(blob, -1,
-					     "marvell,armada-3700-ahci");
-	if (node > 0) {
-		if (fdtdec_get_is_enabled(blob, node)) {
-			ret = comphy_sata_power_up();
-			if (!ret)
-				printf("Failed to initialize SATA PHY\n");
-			else
-				debug("SATA PHY init succeed\n");
-		} else {
-			debug("SATA node is disabled\n");
-		}
-	}  else {
-		debug("No SATA node in DT\n");
-	}
-
 	node = fdt_node_offset_by_compatible(blob, -1,
 					     "marvell,armada-8k-sdhci");
 	if (node <= 0) {
@@ -948,7 +345,7 @@ void comphy_dedicated_phys_init(void)
 	if (node > 0) {
 		if (fdtdec_get_is_enabled(blob, node)) {
 			ret = comphy_emmc_power_up();
-			if (!ret)
+			if (ret == 0)
 				printf("Failed to initialize SDIO/eMMC PHY\n");
 			else
 				debug("SDIO/eMMC PHY init succeed\n");
@@ -968,12 +365,14 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 	struct comphy_map *comphy_map;
 	u32 comphy_max_count = chip_cfg->comphy_lanes_count;
 	u32 lane, ret = 0;
+	u32 mode = 0, fw_format = 0;
 
 	debug_enter();
 
-	/* Initialize PHY mux */
-	chip_cfg->mux_data = a3700_comphy_mux_data;
-	comphy_mux_init(chip_cfg, serdes_map, COMPHY_SEL_ADDR);
+	if (comphy_max_count > A3700_LANE_MAX_NUM) {
+		printf("Comphy number %d is too large\n", comphy_max_count);
+		return 1;
+	}
 
 	for (lane = 0, comphy_map = serdes_map; lane < comphy_max_count;
 	     lane++, comphy_map++) {
@@ -982,27 +381,46 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 		      comphy_map->type, comphy_map->invert);
 
 		switch (comphy_map->type) {
-		case PHY_TYPE_UNCONNECTED:
+		case COMPHY_TYPE_UNCONNECTED:
 			continue;
 			break;
 
-		case PHY_TYPE_PEX0:
-			ret = comphy_pcie_power_up(comphy_map->speed,
-						   comphy_map->invert);
+		case COMPHY_TYPE_PEX0:
+			fw_format = COMPHY_FW_MODE_FORMAT(COMPHY_PCIE_MODE,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
 			break;
 
-		case PHY_TYPE_USB3_HOST0:
-		case PHY_TYPE_USB3_DEVICE:
-			ret = comphy_usb3_power_up(lane,
-						   comphy_map->type,
-						   comphy_map->speed,
-						   comphy_map->invert);
+		case COMPHY_TYPE_USB3:
+		case COMPHY_TYPE_USB3_HOST0:
+		case COMPHY_TYPE_USB3_DEVICE:
+
+			ret = comphy_usb3_power_up(comphy_map->speed,
+						   comphy_map->invert,
+						   lane,
+						   (lane == 2) ? true : false);
 			break;
 
-		case PHY_TYPE_SGMII0:
-		case PHY_TYPE_SGMII1:
-			ret = comphy_sgmii_power_up(lane, comphy_map->speed,
-						    comphy_map->invert);
+		case COMPHY_TYPE_SGMII0:
+		case COMPHY_TYPE_SGMII1:
+			if (comphy_map->speed == COMPHY_SPEED_1_25G)
+				mode = COMPHY_SGMII_MODE;
+			else if (comphy_map->speed == COMPHY_SPEED_3_125G)
+				mode = COMPHY_HS_SGMII_MODE;
+			else
+				printf("Unsupported COMPHY speed!\n");
+
+			fw_format = COMPHY_FW_MODE_FORMAT(mode,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
+
+			break;
+
+		case COMPHY_TYPE_SATA0:
+			ret = comphy_sata_power_up(comphy_map->invert, lane);
+
 			break;
 
 		default:
@@ -1011,7 +429,7 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			ret = 1;
 			break;
 		}
-		if (!ret)
+		if (ret != 0)
 			printf("PLL is not locked - Failed to initialize lane %d\n",
 			       lane);
 	}
diff --git a/drivers/phy/marvell/comphy_a3700.h b/drivers/phy/marvell/comphy_a3700.h
index b0941ffb37..0634800b05 100644
--- a/drivers/phy/marvell/comphy_a3700.h
+++ b/drivers/phy/marvell/comphy_a3700.h
@@ -7,174 +7,32 @@
 #define _COMPHY_A3700_H_
 
 #include "comphy_core.h"
-#include "comphy_hpipe.h"
 
-#define MVEBU_REG(offs)			\
-	((void __iomem *)(ulong)MVEBU_REGISTER(offs))
+#define MVEBU_REG(offs)			((uintptr_t)MVEBU_REGISTER(offs))
 
-#define DEFAULT_REFCLK_MHZ		25
-#define PLL_SET_DELAY_US		600
 #define PLL_LOCK_TIMEOUT		1000
 #define POLL_16B_REG			1
 #define POLL_32B_REG			0
 
 /*
- * COMPHY SB definitions
+ * USB definitions
  */
-#define COMPHY_SEL_ADDR			MVEBU_REG(0x0183FC)
-
-#define COMPHY_PHY_CFG1_ADDR(lane)	MVEBU_REG(0x018300 + (1 - lane) * 0x28)
-#define rb_pin_pu_iveref		BIT(1)
-#define rb_pin_reset_core		BIT(11)
-#define rb_pin_reset_comphy		BIT(12)
-#define rb_pin_pu_pll			BIT(16)
-#define rb_pin_pu_rx			BIT(17)
-#define rb_pin_pu_tx			BIT(18)
-#define rb_pin_tx_idle			BIT(19)
-#define rf_gen_rx_sel_shift		22
-#define rf_gen_rx_select		(0x0F << rf_gen_rx_sel_shift)
-#define rf_gen_tx_sel_shift		26
-#define rf_gen_tx_select		(0x0F << rf_gen_tx_sel_shift)
-#define rb_phy_rx_init			BIT(30)
-
-#define COMPHY_PHY_STAT1_ADDR(lane)	MVEBU_REG(0x018318 + (1 - lane) * 0x28)
-#define rb_rx_init_done			BIT(0)
-#define rb_pll_ready_rx			BIT(2)
-#define rb_pll_ready_tx			BIT(3)
-
-/*
- * PCIe/USB/SGMII definitions
- */
-#define PCIE_BASE			MVEBU_REG(0x070000)
-#define PCIETOP_BASE			MVEBU_REG(0x080000)
-#define PCIE_RAMBASE			MVEBU_REG(0x08C000)
-#define PCIEPHY_BASE			MVEBU_REG(0x01F000)
-#define PCIEPHY_SHFT			2
-
 #define USB32_BASE			MVEBU_REG(0x050000) /* usb3 device */
-#define USB32H_BASE			MVEBU_REG(0x058000) /* usb3 host */
-#define USB3PHY_BASE			MVEBU_REG(0x05C000)
 #define USB2PHY_BASE			MVEBU_REG(0x05D000)
 #define USB2PHY2_BASE			MVEBU_REG(0x05F000)
-#define USB32_CTRL_BASE			MVEBU_REG(0x05D800)
-#define USB3PHY_SHFT			2
-#define USB3PHY_LANE2_REG_BASE_OFFSET	0x200
-
-static inline void __iomem *sgmiiphy_addr(u32 lane, u32 addr)
-{
-	addr = (addr & 0x00007FF) * 2;
-	if (lane == 1)
-		return PCIEPHY_BASE + addr;
-	else
-		return USB3PHY_BASE + addr;
-}
-
-/* units */
-enum phy_unit {
-	PCIE = 1,
-	USB3 = 2,
-};
-
-static inline void __iomem *phy_addr(enum phy_unit unit, u32 addr)
-{
-	if (unit == PCIE)
-		return PCIEPHY_BASE + addr * PCIEPHY_SHFT;
-	else
-		return USB3PHY_BASE + addr * USB3PHY_SHFT;
-}
-
-/* bit definition for USB32_CTRL_BASE (USB32 Control Mode) */
-#define usb32_ctrl_id_mode		BIT(0)
-#define usb32_ctrl_soft_id		BIT(1)
-#define usb32_ctrl_int_mode		BIT(4)
-
-#define PWR_PLL_CTRL			0x01
-#define rf_phy_mode_shift		5
-#define rf_phy_mode_mask		(0x7 << rf_phy_mode_shift)
-#define rf_ref_freq_sel_shift		0
-#define rf_ref_freq_sel_mask		(0x1F << rf_ref_freq_sel_shift)
-#define PHY_MODE_SGMII			0x4
-
-#define KVCO_CAL_CTRL			0x02
-#define rb_use_max_pll_rate		BIT(12)
-#define rb_force_calibration_done	BIT(9)
-
-#define DIG_LB_EN			0x23
-#define rf_data_width_shift		10
-#define rf_data_width_mask		(0x3 << rf_data_width_shift)
-
-#define SYNC_PATTERN			0x24
-#define phy_txd_inv			BIT(10)
-#define phy_rxd_inv			BIT(11)
-
-#define SYNC_MASK_GEN			0x25
-#define rb_idle_sync_en			BIT(12)
-
-#define UNIT_CTRL			0x48
-
-#define GEN2_SETTINGS_2			0x3e
-#define g2_tx_ssc_amp			BIT(14)
-
-#define GEN2_SETTINGS_3			0x3f
-
-#define GEN3_SETTINGS_3			0x112
-
-#define MISC_REG0			0x4f
-#define rb_clk100m_125m_en		BIT(4)
-#define rb_clk500m_en			BIT(7)
-#define rb_ref_clk_sel			BIT(10)
-
-#define UNIT_IFACE_REF_CLK_CTRL		0x51
-#define rb_ref1m_gen_div_force		BIT(8)
-#define rf_ref1m_gen_div_value_shift	0
-#define rf_ref1m_gen_div_value_mask	(0xFF << rf_ref1m_gen_div_value_shift)
-
-#define UNIT_ERR_CNT_CONST_CTRL		0x6a
-#define rb_fast_dfe_enable		BIT(13)
-
-#define MISC_REG1			0x73
-#define bf_sel_bits_pcie_force		BIT(15)
-
-#define LANE_CFG0			0x180
-#define bf_use_max_pll_rate		BIT(9)
-
-#define LANE_CFG1			0x181
-#define bf_use_max_pll_rate		BIT(9)
-#define prd_txdeemph1_mask		BIT(15)
-#define tx_det_rx_mode			BIT(6)
-#define gen2_tx_data_dly_deft		(2 << 3)
-#define gen2_tx_data_dly_mask		(BIT(3) | BIT(4))
-#define tx_elec_idle_mode_en		BIT(0)
-
-#define LANE_CFG4			0x188
-#define bf_spread_spectrum_clock_en	BIT(7)
-
-#define LANE_STAT1			0x183
-#define rb_txdclk_pclk_en		BIT(0)
-
-#define GLOB_PHY_CTRL0			0x1c1
-#define bf_soft_rst			BIT(0)
-#define bf_mode_refdiv			0x30
-#define rb_mode_core_clk_freq_sel	BIT(9)
-#define rb_mode_pipe_width_32		BIT(3)
-
-#define TEST_MODE_CTRL			0x1c2
-#define rb_mode_margin_override		BIT(2)
-
-#define GLOB_CLK_SRC_LO			0x1c3
-#define bf_cfg_sel_20b			BIT(15)
-
-#define PWR_MGM_TIM1			0x1d0
-
-#define PCIE_REF_CLK_ADDR		(PCIE_BASE + 0x4814)
 
 #define USB3_CTRPUL_VAL_REG		(0x20 + USB32_BASE)
-#define USB3H_CTRPUL_VAL_REG		(0x3454 + USB32H_BASE)
+#define USB3_TOP_INT_STATUS_REG		(0xd8 + USB32_BASE)
+#define vbus_int_state			BIT(5)
+#define USB3_TOP_INT_ENABLE_REG		(0xdc + USB32_BASE)
+#define vbus_int_enable			BIT(5)
 #define rb_usb3_ctr_100ns		0xff000000
 
 #define USB2_OTG_PHY_CTRL_ADDR		(0x820 + USB2PHY_BASE)
 #define rb_usb2phy_suspm		BIT(14)
 #define rb_usb2phy_pu			BIT(0)
+#define rb_usb2_dp_pulldn_dev_mode	BIT(5)
+#define rb_usb2_dm_pulldn_dev_mode	BIT(6)
 
 #define USB2_PHY_OTG_CTRL_ADDR		(0x34 + USB2PHY_BASE)
 #define rb_pu_otg			BIT(4)
@@ -224,27 +82,9 @@ static inline void __iomem *phy_addr(enum phy_unit unit, u32 addr)
  */
 #define AHCI_BASE			MVEBU_REG(0xE0000)
 
-#define rh_vsreg_addr			(AHCI_BASE + 0x178)
-#define rh_vsreg_data			(AHCI_BASE + 0x17C)
 #define rh_vs0_a			(AHCI_BASE + 0xA0)
 #define rh_vs0_d			(AHCI_BASE + 0xA4)
 
-#define vphy_sync_pattern_reg		0x224
-#define bs_txd_inv			BIT(10)
-#define bs_rxd_inv			BIT(11)
-
-#define vphy_loopback_reg0		0x223
-#define bs_phyintf_40bit		0x0C00
-#define bs_pll_ready_tx			0x10
-
-#define vphy_power_reg0			0x201
-
-#define vphy_calctl_reg			0x202
-#define bs_max_pll_rate			BIT(12)
-
-#define vphy_reserve_reg		0x0e
-#define bs_phyctrl_frm_pin		BIT(13)
-
 #define vsata_ctrl_reg			0x00
 #define bs_phy_pu_pll			BIT(6)
 
diff --git a/drivers/phy/marvell/comphy_core.c b/drivers/phy/marvell/comphy_core.c
index 9c24692629..8f4919a30e 100644
--- a/drivers/phy/marvell/comphy_core.c
+++ b/drivers/phy/marvell/comphy_core.c
@@ -19,13 +19,13 @@ DECLARE_GLOBAL_DATA_PTR;
 
 static const char *get_speed_string(u32 speed)
 {
-	static const char * const speed_strings[] = {
-		"1.25 Gbps", "1.5 Gbps", "2.5 Gbps",
-		"3.0 Gbps", "3.125 Gbps", "5 Gbps", "6 Gbps",
-		"6.25 Gbps", "10.31 Gbps"
+	char * const speed_strings[] = {
+		"1.25 Gbps", "2.5 Gbps", "3.125 Gbps",
+		"5 Gbps", "5.125 Gpbs", "6 Gbps",
+		"10.3125 Gbps"
 	};
 
-	if (speed < 0 || speed > PHY_SPEED_MAX)
+	if (speed < 0 || speed > COMPHY_SPEED_MAX)
 		return "invalid";
 
 	return speed_strings[speed];
@@ -33,16 +33,15 @@ static const char *get_speed_string(u32 speed)
 
 static const char *get_type_string(u32 type)
 {
-	static const char * const type_strings[] = {
+	char * const type_strings[] = {
 		"UNCONNECTED", "PEX0", "PEX1", "PEX2", "PEX3",
-		"SATA0", "SATA1", "SATA2", "SATA3", "SGMII0",
-		"SGMII1", "SGMII2", "SGMII3", "QSGMII",
-		"USB3_HOST0", "USB3_HOST1", "USB3_DEVICE",
-		"XAUI0", "XAUI1", "XAUI2", "XAUI3",
-		"RXAUI0", "RXAUI1", "SFI", "IGNORE"
+		"SATA0", "SATA1", "SGMII0", "SGMII1", "SGMII2",
+		"USB3", "USB3_HOST0", "USB3_HOST1",
+		"USB3_DEVICE", "RXAUI0", "RXAUI1", "SFI0", "SFI1", "AP",
+		"IGNORE"
 	};
 
-	if (type < 0 || type > PHY_TYPE_MAX)
+	if (type < 0 || type > COMPHY_TYPE_MAX)
 		return "invalid";
 
 	return type_strings[type];
@@ -55,7 +54,7 @@ void comphy_print(struct chip_serdes_phy_config *chip_cfg,
 
 	for (lane = 0; lane < chip_cfg->comphy_lanes_count;
 	     lane++, comphy_map_data++) {
-		if (comphy_map_data->speed == PHY_SPEED_INVALID) {
+		if (comphy_map_data->speed == COMPHY_SPEED_INVALID) {
 			printf("Comphy-%d: %-13s\n", lane,
 			       get_type_string(comphy_map_data->type));
 		} else {
@@ -66,6 +65,16 @@ void comphy_print(struct chip_serdes_phy_config *chip_cfg,
 	}
 }
 
+int comphy_rx_training(struct udevice *dev, u32 lane)
+{
+	struct chip_serdes_phy_config *chip_cfg = dev_get_priv(dev);
+
+	if (chip_cfg->rx_training)
+		return chip_cfg->rx_training(chip_cfg, lane);
+
+	return 0;
+}
+
 __weak int comphy_update_map(struct comphy_map *serdes_map, int count)
 {
 	return 0;
@@ -76,7 +85,6 @@ static int comphy_probe(struct udevice *dev)
 	const void *blob = gd->fdt_blob;
 	int node = dev_of_offset(dev);
 	struct chip_serdes_phy_config *chip_cfg = dev_get_priv(dev);
-	struct comphy_map comphy_map_data[MAX_LANE_OPTIONS];
 	int subnode;
 	int lane;
 	int last_idx = 0;
@@ -110,11 +118,15 @@ static int comphy_probe(struct udevice *dev)
 		fdtdec_locate_array(blob, node, "mux-lane-order",
 				    chip_cfg->comphy_lanes_count);
 
-	if (device_is_compatible(dev, "marvell,comphy-armada-3700"))
+	if (device_is_compatible(dev, "marvell,comphy-armada-3700")) {
 		chip_cfg->ptr_comphy_chip_init = comphy_a3700_init;
+		chip_cfg->rx_training = NULL;
+	}
 
-	if (device_is_compatible(dev, "marvell,comphy-cp110"))
+	if (device_is_compatible(dev, "marvell,comphy-cp110")) {
 		chip_cfg->ptr_comphy_chip_init = comphy_cp110_init;
+		chip_cfg->rx_training = comphy_cp110_sfi_rx_training;
+	}
 
 	/*
 	 * Bail out if no chip_init function is defined, e.g. no
@@ -131,36 +143,45 @@ static int comphy_probe(struct udevice *dev)
 		if (!fdtdec_get_is_enabled(blob, subnode))
 			continue;
 
-		comphy_map_data[lane].speed = fdtdec_get_int(
-			blob, subnode, "phy-speed", PHY_TYPE_INVALID);
-		comphy_map_data[lane].type = fdtdec_get_int(
-			blob, subnode, "phy-type", PHY_SPEED_INVALID);
-		comphy_map_data[lane].invert = fdtdec_get_int(
-			blob, subnode, "phy-invert", PHY_POLARITY_NO_INVERT);
-		comphy_map_data[lane].clk_src = fdtdec_get_bool(blob, subnode,
-								"clk-src");
-		comphy_map_data[lane].end_point = fdtdec_get_bool(blob, subnode,
-								  "end_point");
-		if (comphy_map_data[lane].type == PHY_TYPE_INVALID) {
+		chip_cfg->comphy_map_data[lane].type =
+			fdtdec_get_int(blob, subnode, "phy-type",
+				       COMPHY_TYPE_INVALID);
+
+		if (chip_cfg->comphy_map_data[lane].type ==
+		    COMPHY_TYPE_INVALID) {
 			printf("no phy type for lane %d, setting lane as unconnected\n",
 			       lane + 1);
+			continue;
 		}
 
+		chip_cfg->comphy_map_data[lane].speed =
+			fdtdec_get_int(blob, subnode, "phy-speed",
+				       COMPHY_SPEED_INVALID);
+
+		chip_cfg->comphy_map_data[lane].invert =
+			fdtdec_get_int(blob, subnode, "phy-invert",
+				       COMPHY_POLARITY_NO_INVERT);
+
+		chip_cfg->comphy_map_data[lane].clk_src =
+			fdtdec_get_bool(blob, subnode, "clk-src");
+
+		chip_cfg->comphy_map_data[lane].end_point =
+			fdtdec_get_bool(blob, subnode, "end_point");
+
 		lane++;
 	}
 
-	res = comphy_update_map(comphy_map_data, chip_cfg->comphy_lanes_count);
+	res = comphy_update_map(chip_cfg->comphy_map_data, chip_cfg->comphy_lanes_count);
 	if (res < 0)
 		return res;
 
 	/* Save CP index for MultiCP devices (A8K) */
 	chip_cfg->cp_index = current_idx++;
 	/* PHY power UP sequence */
-	chip_cfg->ptr_comphy_chip_init(chip_cfg, comphy_map_data);
+	chip_cfg->ptr_comphy_chip_init(chip_cfg, chip_cfg->comphy_map_data);
 	/* PHY print SerDes status */
-	if (of_machine_is_compatible("marvell,armada8040"))
-		printf("Comphy chip #%d:\n", chip_cfg->cp_index);
-	comphy_print(chip_cfg, comphy_map_data);
+	printf("Comphy chip #%d:\n", chip_cfg->cp_index);
+	comphy_print(chip_cfg, chip_cfg->comphy_map_data);
 
 	/*
 	 * Only run the dedicated PHY init code once, in the last PHY init call
diff --git a/drivers/phy/marvell/comphy_core.h b/drivers/phy/marvell/comphy_core.h
index 12ab921d24..7c778fd74a 100644
--- a/drivers/phy/marvell/comphy_core.h
+++ b/drivers/phy/marvell/comphy_core.h
@@ -17,79 +17,20 @@
 #define debug_exit()
 #endif
 
-/* COMPHY registers */
-#define COMMON_PHY_CFG1_REG			0x0
-#define COMMON_PHY_CFG1_PWR_UP_OFFSET		1
-#define COMMON_PHY_CFG1_PWR_UP_MASK		\
-	(0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET)
-#define COMMON_PHY_CFG1_PIPE_SELECT_OFFSET	2
-#define COMMON_PHY_CFG1_PIPE_SELECT_MASK	\
-	(0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET)
-#define COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET	13
-#define COMMON_PHY_CFG1_PWR_ON_RESET_MASK	\
-	(0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET)
-#define COMMON_PHY_CFG1_CORE_RSTN_OFFSET	14
-#define COMMON_PHY_CFG1_CORE_RSTN_MASK		\
-	(0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET)
-#define COMMON_PHY_PHY_MODE_OFFSET		15
-#define COMMON_PHY_PHY_MODE_MASK		\
-	(0x1 << COMMON_PHY_PHY_MODE_OFFSET)
-
-#define COMMON_PHY_CFG6_REG			0x14
-#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
-#define COMMON_PHY_CFG6_IF_40_SEL_MASK		\
-	(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
-
-#define COMMON_SELECTOR_PHY_OFFSET		0x140
-#define COMMON_SELECTOR_PIPE_OFFSET		0x144
-
-#define COMMON_PHY_SD_CTRL1			0x148
-#define COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET	0
-#define COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK	0xFFFF
-#define COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET	24
-#define COMMON_PHY_SD_CTRL1_PCIE_X4_EN_MASK	\
-	(0x1 << COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET)
-#define COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET	25
-#define COMMON_PHY_SD_CTRL1_PCIE_X2_EN_MASK	\
-	(0x1 << COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET)
-#define COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET	26
-#define COMMON_PHY_SD_CTRL1_RXAUI1_MASK		\
-	(0x1 << COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET)
-#define COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET	27
-#define COMMON_PHY_SD_CTRL1_RXAUI0_MASK		\
-	(0x1 << COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET)
-
-/* ToDo: Get this address via DT */
-#define MVEBU_CP0_REGS_BASE			0xF2000000UL
-
-#define DFX_DEV_GEN_CTRL12			(MVEBU_CP0_REGS_BASE + 0x400280)
-#define DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET		7
-#define DFX_DEV_GEN_PCIE_CLK_SRC_MASK		\
-	(0x3 << DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET)
-
 #define MAX_LANE_OPTIONS			10
-#define MAX_UTMI_PHY_COUNT			3
-
-struct comphy_mux_options {
-	u32 type;
-	u32 mux_value;
-};
-
-struct comphy_mux_data {
-	u32 max_lane_values;
-	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
-};
+#define MAX_UTMI_PHY_COUNT			6
 
 struct chip_serdes_phy_config {
-	struct comphy_mux_data *mux_data;
 	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *,
 				    struct comphy_map *);
+	int (*rx_training)(struct chip_serdes_phy_config *, u32);
 	void __iomem *comphy_base_addr;
 	void __iomem *hpipe3_base_addr;
 	u32 comphy_lanes_count;
 	u32 comphy_mux_bitcount;
 	const fdt32_t *comphy_mux_lane_order;
 	u32 cp_index;
+	struct comphy_map comphy_map_data[MAX_LANE_OPTIONS];
 };
 
 /* Register helper functions */
@@ -150,6 +91,8 @@ static inline int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 #ifdef CONFIG_ARMADA_8K
 int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		      struct comphy_map *serdes_map);
+int comphy_cp110_sfi_rx_training(struct chip_serdes_phy_config *ptr_chip_cfg,
+				 u32 lane);
 #else
 static inline int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		      struct comphy_map *serdes_map)
@@ -160,6 +103,17 @@ static inline int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 	 */
 	return -1;
 }
+
+static inline int comphy_cp110_sfi_rx_training(
+	struct chip_serdes_phy_config *ptr_chip_cfg,
+	u32 lane)
+{
+	/*
+	 * This function should never be called in this configuration, so
+	 * lets return an error here.
+	 */
+	return -1;
+}
 #endif
 
 void comphy_dedicated_phys_init(void);
diff --git a/drivers/phy/marvell/comphy_cp110.c b/drivers/phy/marvell/comphy_cp110.c
index 9998c07a47..805636fb3f 100644
--- a/drivers/phy/marvell/comphy_cp110.c
+++ b/drivers/phy/marvell/comphy_cp110.c
@@ -10,63 +10,54 @@
 #include <asm/arch/soc.h>
 
 #include "comphy_core.h"
-#include "comphy_hpipe.h"
 #include "sata.h"
 #include "utmi_phy.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#define SD_ADDR(base, lane)			(base + 0x1000 * lane)
-#define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
-#define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+#define MV_SIP_COMPHY_POWER_OFF	0x82000002
+#define MV_SIP_COMPHY_PLL_LOCK	0x82000003
+#define MV_SIP_COMPHY_XFI_TRAIN	0x82000004
+
+/* Used to distinguish between different possible callers (U-boot/Linux) */
+#define COMPHY_CALLER_UBOOT			(0x1 << 21)
+
+#define COMPHY_FW_MODE_FORMAT(mode)		((mode) << 12)
+#define COMPHY_FW_FORMAT(mode, idx, speeds)	\
+			(((mode) << 12) | ((idx) << 8) | ((speeds) << 2))
+
+#define COMPHY_FW_PCIE_FORMAT(pcie_width, clk_src, mode, speeds)	\
+			(COMPHY_CALLER_UBOOT | ((pcie_width) << 18) |	\
+			((clk_src) << 17) | COMPHY_FW_FORMAT(mode, 0, speeds))
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
+/* Comphy unit index macro */
+#define COMPHY_UNIT_ID0		0
+#define COMPHY_UNIT_ID1		1
+#define COMPHY_UNIT_ID2		2
+#define COMPHY_UNIT_ID3		3
 
 struct utmi_phy_data {
+	void __iomem *utmi_pll_addr;
 	void __iomem *utmi_base_addr;
 	void __iomem *usb_cfg_addr;
 	void __iomem *utmi_cfg_addr;
 	u32 utmi_phy_port;
 };
 
-/*
- * For CP-110 we have 2 Selector registers "PHY Selectors",
- * and "PIPE Selectors".
- * PIPE selector include USB and PCIe options.
- * PHY selector include the Ethernet and SATA options, every Ethernet
- * option has different options, for example: serdes lane2 had option
- * Eth_port_0 that include (SGMII0, RXAUI0, SFI)
- */
-struct comphy_mux_data cp110_comphy_phy_mux_data[] = {
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII1, 0x1}, /* Lane 0 */
-	     {PHY_TYPE_SATA1, 0x4} } },
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII2, 0x1}, /* Lane 1 */
-	     {PHY_TYPE_SATA0, 0x4} } },
-	{6, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII0, 0x1}, /* Lane 2 */
-	     {PHY_TYPE_RXAUI0, 0x1}, {PHY_TYPE_SFI, 0x1},
-	     {PHY_TYPE_SATA0, 0x4} } },
-	{8, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_RXAUI1, 0x1}, /* Lane 3 */
-	     {PHY_TYPE_SGMII1, 0x2}, {PHY_TYPE_SATA1, 0x4} } },
-	{7, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII0, 0x2}, /* Lane 4 */
-	     {PHY_TYPE_RXAUI0, 0x2}, {PHY_TYPE_SFI, 0x2},
-	     {PHY_TYPE_SGMII1, 0x1} } },
-	{6, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII2, 0x1}, /* Lane 5 */
-	     {PHY_TYPE_RXAUI1, 0x2}, {PHY_TYPE_SATA1, 0x4} } },
-};
-
-struct comphy_mux_data cp110_comphy_pipe_mux_data[] = {
-	{2, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_PEX0, 0x4} } }, /* Lane 0 */
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 1 */
-	     {PHY_TYPE_USB3_HOST0, 0x1}, {PHY_TYPE_USB3_DEVICE, 0x2},
-	     {PHY_TYPE_PEX0, 0x4} } },
-	{3, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 2 */
-	     {PHY_TYPE_USB3_HOST0, 0x1}, {PHY_TYPE_PEX0, 0x4} } },
-	{3, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 3 */
-	     {PHY_TYPE_USB3_HOST1, 0x1}, {PHY_TYPE_PEX0, 0x4} } },
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 4 */
-	     {PHY_TYPE_USB3_HOST1, 0x1},
-	     {PHY_TYPE_USB3_DEVICE, 0x2}, {PHY_TYPE_PEX1, 0x4} } },
-	{2, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_PEX2, 0x4} } }, /* Lane 5 */
-};
-
 static u32 polling_with_timeout(void __iomem *addr, u32 val,
 				u32 mask, unsigned long usec_timout)
 {
@@ -83,572 +74,31 @@ static u32 polling_with_timeout(void __iomem *addr, u32 val,
 	return 0;
 }
 
-static int comphy_pcie_power_up(u32 lane, u32 pcie_width, bool clk_src,
-				bool is_end_point, void __iomem *hpipe_base,
-				void __iomem *comphy_base)
+static int comphy_smc(u32 function_id, void __iomem *comphy_base_addr,
+		      u32 lane, u32 mode)
 {
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-	u32 pcie_clk = 0; /* set input by default */
-
-	debug_enter();
+	struct pt_regs pregs = {0};
 
-	/*
-	 * ToDo:
-	 * Add SAR (Sample-At-Reset) configuration for the PCIe clock
-	 * direction. SAR code is currently not ported from Marvell
-	 * U-Boot to mainline version.
-	 *
-	 * SerDes Lane 4/5 got the PCIe ref-clock #1,
-	 * and SerDes Lane 0 got PCIe ref-clock #0
-	 */
-	debug("PCIe clock = %x\n", pcie_clk);
-	debug("PCIe RC    = %d\n", !is_end_point);
-	debug("PCIe width = %d\n", pcie_width);
-
-	/* enable PCIe by4 and by2 */
-	if (lane == 0) {
-		if (pcie_width == 4) {
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x1 << COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET,
-				COMMON_PHY_SD_CTRL1_PCIE_X4_EN_MASK);
-		} else if (pcie_width == 2) {
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x1 << COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET,
-				COMMON_PHY_SD_CTRL1_PCIE_X2_EN_MASK);
-		}
-	}
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = (unsigned long)comphy_base_addr;
+	pregs.regs[2] = lane;
+	pregs.regs[3] = mode;
 
-	/*
-	 * If PCIe clock is output and clock source from SerDes lane 5,
-	 * we need to configure the clock-source MUX.
-	 * By default, the clock source is from lane 4
-	 */
-	if (pcie_clk && clk_src && (lane == 5)) {
-		reg_set((void __iomem *)DFX_DEV_GEN_CTRL12,
-			0x3 << DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET,
-			DFX_DEV_GEN_PCIE_CLK_SRC_MASK);
-	}
+	smc_call(&pregs);
 
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	mask |= COMMON_PHY_PHY_MODE_MASK;
-	data |= 0x0 << COMMON_PHY_PHY_MODE_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* Set PIPE soft reset */
-	mask = HPIPE_RST_CLK_CTRL_PIPE_RST_MASK;
-	data = 0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET;
-	/* Set PHY datapath width mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK;
-	data |= 0x1 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET;
-	/* Set Data bus width USB mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET;
-	/* Set CORE_CLK output frequency for 250Mhz */
-	mask |= HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG, data, mask);
-	/* Set PLL ready delay for 0x2 */
-	data = 0x2 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET;
-	mask = HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK;
-	if (pcie_width != 1) {
-		data |= 0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET;
-		mask |= HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_MASK;
-		data |= 0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET;
-		mask |= HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_MASK;
-	}
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_LO_REG, data, mask);
-
-	/* Set PIPE mode interface to PCIe3 - 0x1  & set lane order */
-	data = 0x1 << HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET;
-	mask = HPIPE_CLK_SRC_HI_MODE_PIPE_MASK;
-	if (pcie_width != 1) {
-		mask |= HPIPE_CLK_SRC_HI_LANE_STRT_MASK;
-		mask |= HPIPE_CLK_SRC_HI_LANE_MASTER_MASK;
-		mask |= HPIPE_CLK_SRC_HI_LANE_BREAK_MASK;
-		if (lane == 0) {
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET;
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET;
-		} else if (lane == (pcie_width - 1)) {
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET;
-		}
-	}
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_HI_REG, data, mask);
-	/* Config update polarity equalization */
-	reg_set(hpipe_addr + HPIPE_LANE_EQ_CFG1_REG,
-		0x1 << HPIPE_CFG_UPDATE_POLARITY_OFFSET,
-		HPIPE_CFG_UPDATE_POLARITY_MASK);
-	/* Set PIPE version 4 to mode enable */
-	reg_set(hpipe_addr + HPIPE_DFE_CTRL_28_REG,
-		0x1 << HPIPE_DFE_CTRL_28_PIPE4_OFFSET,
-		HPIPE_DFE_CTRL_28_PIPE4_MASK);
-	/* TODO: check if pcie clock is output/input - for bringup use input*/
-	/* Enable PIN clock 100M_125M */
-	mask = 0;
-	data = 0;
-	/* Only if clock is output, configure the clock-source mux */
-	if (pcie_clk) {
-		mask |= HPIPE_MISC_CLK100M_125M_MASK;
-		data |= 0x1 << HPIPE_MISC_CLK100M_125M_OFFSET;
-	}
 	/*
-	 * Set PIN_TXDCLK_2X Clock Frequency Selection for outputs 500MHz
-	 * clock
+	 * TODO: Firmware return 0 on success, temporary map it to u-boot
+	 * convention, but after all comphy will be reworked the convention in
+	 * u-boot should be change and this conversion removed
 	 */
-	mask |= HPIPE_MISC_TXDCLK_2X_MASK;
-	data |= 0x0 << HPIPE_MISC_TXDCLK_2X_OFFSET;
-	/* Enable 500MHz Clock */
-	mask |= HPIPE_MISC_CLK500_EN_MASK;
-	data |= 0x1 << HPIPE_MISC_CLK500_EN_OFFSET;
-	if (pcie_clk) { /* output */
-		/* Set reference clock comes from group 1 */
-		mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-		data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	} else {
-		/* Set reference clock comes from group 2 */
-		mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-		data |= 0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	}
-	mask |= HPIPE_MISC_ICP_FORCE_MASK;
-	data |= 0x1 << HPIPE_MISC_ICP_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	if (pcie_clk) { /* output */
-		/* Set reference frequcency select - 0x2 for 25MHz*/
-		mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-		data = 0x2 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	} else {
-		/* Set reference frequcency select - 0x0 for 100MHz*/
-		mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-		data = 0x0 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	}
-	/* Set PHY mode to PCIe */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x3 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-
-	/* ref clock alignment */
-	if (pcie_width != 1) {
-		mask = HPIPE_LANE_ALIGN_OFF_MASK;
-		data = 0x0 << HPIPE_LANE_ALIGN_OFF_OFFSET;
-		reg_set(hpipe_addr + HPIPE_LANE_ALIGN_REG, data, mask);
-	}
-
-	/*
-	 * Set the amount of time spent in the LoZ state - set for 0x7 only if
-	 * the PCIe clock is output
-	 */
-	if (pcie_clk) {
-		reg_set(hpipe_addr + HPIPE_GLOBAL_PM_CTRL,
-			0x7 << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET,
-			HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK);
-	}
-
-	/* Set Maximal PHY Generation Setting(8Gbps) */
-	mask = HPIPE_INTERFACE_GEN_MAX_MASK;
-	data = 0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET;
-	/* Bypass frame detection and sync detection for RX DATA */
-	mask = HPIPE_INTERFACE_DET_BYPASS_MASK;
-	data = 0x1 << HPIPE_INTERFACE_DET_BYPASS_OFFSET;
-	/* Set Link Train Mode (Tx training control pins are used) */
-	mask |= HPIPE_INTERFACE_LINK_TRAIN_MASK;
-	data |= 0x1 << HPIPE_INTERFACE_LINK_TRAIN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG, data, mask);
-
-	/* Set Idle_sync enable */
-	mask = HPIPE_PCIE_IDLE_SYNC_MASK;
-	data = 0x1 << HPIPE_PCIE_IDLE_SYNC_OFFSET;
-	/* Select bits for PCIE Gen3(32bit) */
-	mask |= HPIPE_PCIE_SEL_BITS_MASK;
-	data |= 0x2 << HPIPE_PCIE_SEL_BITS_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PCIE_REG0, data, mask);
-
-	/* Enable Tx_adapt_g1 */
-	mask = HPIPE_TX_TRAIN_CTRL_G1_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_CTRL_G1_OFFSET;
-	/* Enable Tx_adapt_gn1 */
-	mask |= HPIPE_TX_TRAIN_CTRL_GN1_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_CTRL_GN1_OFFSET;
-	/* Disable Tx_adapt_g0 */
-	mask |= HPIPE_TX_TRAIN_CTRL_G0_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_CTRL_G0_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_REG, data, mask);
-
-	/* Set reg_tx_train_chk_init */
-	mask = HPIPE_TX_TRAIN_CHK_INIT_MASK;
-	data = 0x0 << HPIPE_TX_TRAIN_CHK_INIT_OFFSET;
-	/* Enable TX_COE_FM_PIN_PCIE3_EN */
-	mask |= HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_REG, data, mask);
-
-	debug("stage: TRx training parameters\n");
-	/* Set Preset sweep configurations */
-	mask = HPIPE_TX_TX_STATUS_CHECK_MODE_MASK;
-	data = 0x1 << HPIPE_TX_STATUS_CHECK_MODE_OFFSET;
-
-	mask |= HPIPE_TX_NUM_OF_PRESET_MASK;
-	data |= 0x7 << HPIPE_TX_NUM_OF_PRESET_OFFSET;
-
-	mask |= HPIPE_TX_SWEEP_PRESET_EN_MASK;
-	data |= 0x1 << HPIPE_TX_SWEEP_PRESET_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_11_REG, data, mask);
-
-	/* Tx train start configuration */
-	mask = HPIPE_TX_TRAIN_START_SQ_EN_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_START_SQ_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_START_FRM_DET_EN_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_START_FRM_LOCK_EN_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_WAIT_TIME_EN_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_5_REG, data, mask);
-
-	/* Enable Tx train P2P */
-	mask = HPIPE_TX_TRAIN_P2P_HOLD_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_0_REG, data, mask);
-
-	/* Configure Tx train timeout */
-	mask = HPIPE_TRX_TRAIN_TIMER_MASK;
-	data = 0x17 << HPIPE_TRX_TRAIN_TIMER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_4_REG, data, mask);
-
-	/* Disable G0/G1/GN1 adaptation */
-	mask = HPIPE_TX_TRAIN_CTRL_G1_MASK | HPIPE_TX_TRAIN_CTRL_GN1_MASK
-		| HPIPE_TX_TRAIN_CTRL_G0_OFFSET;
-	data = 0;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_REG, data, mask);
-
-	/* Disable DTL frequency loop */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Configure G3 DFE */
-	mask = HPIPE_G3_DFE_RES_MASK;
-	data = 0x3 << HPIPE_G3_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_4_REG, data, mask);
-
-	/* Use TX/RX training result for DFE */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x0 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0,  data, mask);
-
-	/* Configure initial and final coefficient value for receiver */
-	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
-	data = 0x1 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
-
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
-	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
-
-	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG,  data, mask);
-
-	/* Trigger sampler enable pulse */
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	udelay(5);
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, 0, mask);
-
-	/* FFE resistor tuning for different bandwidth  */
-	mask = HPIPE_G3_FFE_DEG_RES_LEVEL_MASK;
-	data = 0x1 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET;
-
-	mask |= HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_3_REG, data, mask);
-
-	/* Pattern lock lost timeout disable */
-	mask = HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK;
-	data = 0x0 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_3_REG, data, mask);
-
-	/* Configure DFE adaptations */
-	mask = HPIPE_CDR_MAX_DFE_ADAPT_1_MASK;
-	data = 0x1 << HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET;
-	mask |= HPIPE_CDR_MAX_DFE_ADAPT_0_MASK;
-	data |= 0x0 << HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET;
-	mask |= HPIPE_CDR_RX_MAX_DFE_ADAPT_1_MASK;
-	data |= 0x0 << HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET;
-	reg_set(hpipe_addr + HPIPE_CDR_CONTROL_REG, data, mask);
-	mask = HPIPE_DFE_TX_MAX_DFE_ADAPT_MASK;
-	data = 0x0 << HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_CONTROL_REG, data, mask);
-
-	/* Genration 2 setting 1*/
-	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
-
-	/* DFE enable */
-	mask = HPIPE_G2_DFE_RES_MASK;
-	data = 0x3 << HPIPE_G2_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SETTINGS_4_REG, data, mask);
-
-	/* Configure DFE Resolution */
-	mask = HPIPE_LANE_CFG4_DFE_EN_SEL_MASK;
-	data = 0x1 << HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_CFG4_REG, data, mask);
-
-	/* VDD calibration control */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x16 << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	/* Set PLL Charge-pump Current Control */
-	mask = HPIPE_G3_SETTING_5_G3_ICP_MASK;
-	data = 0x4 << HPIPE_G3_SETTING_5_G3_ICP_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_5_REG, data, mask);
-
-	/* Set lane rqualization remote setting */
-	mask = HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_MASK;
-	data = 0x1 << HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET;
-	mask |= HPIPE_LANE_CFG_FOM_ONLY_MODE_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET;
-	mask |= HPIPE_LANE_CFG_FOM_PRESET_VECTOR_MASK;
-	data |= 0x2 << HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_EQ_REMOTE_SETTING_REG, data, mask);
-
-	if (!is_end_point) {
-		/* Set phy in root complex mode */
-		mask = HPIPE_CFG_PHY_RC_EP_MASK;
-		data = 0x1 << HPIPE_CFG_PHY_RC_EP_OFFSET;
-		reg_set(hpipe_addr + HPIPE_LANE_EQU_CONFIG_0_REG, data, mask);
-	}
-
-	debug("stage: Comphy power up\n");
-
-	/*
-	 * For PCIe by4 or by2 - release from reset only after finish to
-	 * configure all lanes
-	 */
-	if ((pcie_width == 1) || (lane == (pcie_width - 1))) {
-		u32 i, start_lane, end_lane;
-
-		if (pcie_width != 1) {
-			/* allows writing to all lanes in one write */
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x0 <<
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET,
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK);
-			start_lane = 0;
-			end_lane = pcie_width;
-
-			/*
-			 * Release from PIPE soft reset
-			 * for PCIe by4 or by2 - release from soft reset
-			 * all lanes - can't use read modify write
-			 */
-			reg_set(HPIPE_ADDR(hpipe_base, 0) +
-				HPIPE_RST_CLK_CTRL_REG, 0x24, 0xffffffff);
-		} else {
-			start_lane = lane;
-			end_lane = lane + 1;
-
-			/*
-			 * Release from PIPE soft reset
-			 * for PCIe by4 or by2 - release from soft reset
-			 * all lanes
-			 */
-			reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG,
-				0x0 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET,
-				HPIPE_RST_CLK_CTRL_PIPE_RST_MASK);
-		}
-
-
-		if (pcie_width != 1) {
-			/* disable writing to all lanes with one write */
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x3210 <<
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET,
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK);
-		}
-
-		debug("stage: Check PLL\n");
-		/* Read lane status */
-		for (i = start_lane; i < end_lane; i++) {
-			addr = HPIPE_ADDR(hpipe_base, i) +
-				HPIPE_LANE_STATUS1_REG;
-			data = HPIPE_LANE_STATUS1_PCLK_EN_MASK;
-			mask = data;
-			data = polling_with_timeout(addr, data, mask, 15000);
-			if (data != 0) {
-				debug("Read from reg = %p - value = 0x%x\n",
-				      hpipe_addr + HPIPE_LANE_STATUS1_REG,
-				      data);
-				pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
-				ret = 0;
-			}
-		}
-	}
-
-	debug_exit();
-	return ret;
-}
-
-static int comphy_usb3_power_up(u32 lane, void __iomem *hpipe_base,
-				void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	mask |= COMMON_PHY_PHY_MODE_MASK;
-	data |= 0x1 << COMMON_PHY_PHY_MODE_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* Set PIPE soft reset */
-	mask = HPIPE_RST_CLK_CTRL_PIPE_RST_MASK;
-	data = 0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET;
-	/* Set PHY datapath width mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET;
-	/* Set Data bus width USB mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET;
-	/* Set CORE_CLK output frequency for 250Mhz */
-	mask |= HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG, data, mask);
-	/* Set PLL ready delay for 0x2 */
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_LO_REG,
-		0x2 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET,
-		HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK);
-	/* Set reference clock to come from group 1 - 25Mhz */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Set reference frequcency select - 0x2 */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x2 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	/* Set PHY mode to USB - 0x5 */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x5 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Set the amount of time spent in the LoZ state - set for 0x7 */
-	reg_set(hpipe_addr + HPIPE_GLOBAL_PM_CTRL,
-		0x7 << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET,
-		HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK);
-	/* Set max PHY generation setting - 5Gbps */
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
-		0x1 << HPIPE_INTERFACE_GEN_MAX_OFFSET,
-		HPIPE_INTERFACE_GEN_MAX_MASK);
-	/* Set select data width 20Bit (SEL_BITS[2:0]) */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x1 << HPIPE_LOOPBACK_SEL_OFFSET,
-		HPIPE_LOOPBACK_SEL_MASK);
-	/* select de-emphasize 3.5db */
-	reg_set(hpipe_addr + HPIPE_LANE_CONFIG0_REG,
-		0x1 << HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET,
-		HPIPE_LANE_CONFIG0_TXDEEMPH0_MASK);
-	/* override tx margining from the MAC */
-	reg_set(hpipe_addr + HPIPE_TST_MODE_CTRL_REG,
-		0x1 << HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET,
-		HPIPE_TST_MODE_CTRL_MODE_MARGIN_MASK);
-
-	/* Start analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* Set Pin DFE_PAT_DIS -> Bit[1]: PIN_DFE_PAT_DIS = 0x0 */
-	mask = HPIPE_LANE_CFG4_DFE_CTRL_MASK;
-	data = 0x1 << HPIPE_LANE_CFG4_DFE_CTRL_OFFSET;
-	/* Set Override PHY DFE control pins for 0x1 */
-	mask |= HPIPE_LANE_CFG4_DFE_OVER_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG4_DFE_OVER_OFFSET;
-	/* Set Spread Spectrum Clock Enable fot 0x1 */
-	mask |= HPIPE_LANE_CFG4_SSC_CTRL_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG4_SSC_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_CFG4_REG, data, mask);
-	/* End of analog parameters */
-
-	debug("stage: Comphy power up\n");
-	/* Release from PIPE soft reset */
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG,
-		0x0 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET,
-		HPIPE_RST_CLK_CTRL_PIPE_RST_MASK);
-
-	/* wait 15ms - for comphy calibration done */
-	debug("stage: Check PLL\n");
-	/* Read lane status */
-	addr = hpipe_addr + HPIPE_LANE_STATUS1_REG;
-	data = HPIPE_LANE_STATUS1_PCLK_EN_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
-		ret = 0;
-	}
-
-	debug_exit();
-	return ret;
+	return pregs.regs[0] ? 0 : 1;
 }
 
 static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
-				void __iomem *comphy_base, int cp_index,
-				u32 invert)
+				void __iomem *comphy_base_addr, int cp_index,
+				u32 type)
 {
 	u32 mask, data, i, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
 	void __iomem *sata_base = NULL;
 	int sata_node = -1; /* Set to -1 in order to read the first sata node */
 
@@ -701,255 +151,8 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 	data |= 0x0 << SATA3_CTRL_SATA_SSU_OFFSET;
 	reg_set(sata_base + SATA3_VENDOR_DATA, data, mask);
 
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Set select data  width 40Bit - SATA mode only */
-	reg_set(comphy_addr + COMMON_PHY_CFG6_REG,
-		0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET,
-		COMMON_PHY_CFG6_IF_40_SEL_MASK);
-
-	/* release from hard reset in SD external */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, comphy_base_addr, lane, type);
 
-	debug("stage: Comphy configuration\n");
-	/* Start comphy Configuration */
-	/* Set reference clock to comes from group 1 - choose 25Mhz */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Reference frequency select set 1 (for SATA = 25Mhz) */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	/* PHY mode select (set SATA = 0x0 */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x0 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Set max PHY generation setting - 6Gbps */
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
-		0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET,
-		HPIPE_INTERFACE_GEN_MAX_MASK);
-	/* Set select data  width 40Bit (SEL_BITS[2:0]) */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x2 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
-
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* Set analog parameters from ETP(HW) */
-	/* G1 settings */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-
-	mask = HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
-	data = 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
-	data |= 0x2 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	/* G2 settings */
-	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
-
-	/* G3 settings */
-	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
-	data = 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG, data, mask);
-
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Trigger sampler enable pulse (by toggleing the bit) */
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x0 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-
-	/* VDD Calibration Control 3 */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x10 << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	/* DFE Resolution Control */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
-
-	/* DFE F3-F5 Coefficient Control */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* G3 Setting 3 */
-	mask = HPIPE_G3_FFE_CAP_SEL_MASK;
-	data = 0xf << HPIPE_G3_FFE_CAP_SEL_OFFSET;
-	mask |= HPIPE_G3_FFE_RES_SEL_MASK;
-	data |= 0x4 << HPIPE_G3_FFE_RES_SEL_OFFSET;
-	mask |= HPIPE_G3_FFE_SETTING_FORCE_MASK;
-	data |= 0x1 << HPIPE_G3_FFE_SETTING_FORCE_OFFSET;
-	mask |= HPIPE_G3_FFE_DEG_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET;
-	mask |= HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_3_REG, data, mask);
-
-	/* G3 Setting 4 */
-	mask = HPIPE_G3_DFE_RES_MASK;
-	data = 0x2 << HPIPE_G3_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_4_REG, data, mask);
-
-	/* Offset Phase Control */
-	mask = HPIPE_OS_PH_OFFSET_MASK;
-	data = 0x5c << HPIPE_OS_PH_OFFSET_OFFSET;
-	mask |= HPIPE_OS_PH_OFFSET_FORCE_MASK;
-	data |= 0x1 << HPIPE_OS_PH_OFFSET_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-	mask = HPIPE_OS_PH_VALID_MASK;
-	data = 0x1 << HPIPE_OS_PH_VALID_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-	mask = HPIPE_OS_PH_VALID_MASK;
-	data = 0x0 << HPIPE_OS_PH_VALID_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-
-	/* Set G1 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
-	data = 0x8 << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
-
-	/* Set G2 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G2_SET_0_G2_TX_AMP_MASK;
-	data = 0xa << HPIPE_G2_SET_0_G2_TX_AMP_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_EMPH1_MASK;
-	data |= 0x2 << HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_0_REG, data, mask);
-
-	/* Set G3 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G3_SET_0_G3_TX_AMP_MASK;
-	data = 0xe << HPIPE_G3_SET_0_G3_TX_AMP_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_EMPH1_MASK;
-	data |= 0x6 << HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_MASK;
-	data |= 0x4 << HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_0_REG, data, mask);
-
-	/* SERDES External Configuration 2 register */
-	mask = SD_EXTERNAL_CONFIG2_SSC_ENABLE_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
-
-	/* DFE reset sequence */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET,
-		HPIPE_PWR_CTR_RST_DFE_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_RST_DFE_OFFSET,
-		HPIPE_PWR_CTR_RST_DFE_MASK);
-
-	/* Set RX / TX swaps */
-	data = mask = 0;
-	if (invert & PHY_POLARITY_TXD_INVERT) {
-		data |= (1 << HPIPE_SYNC_PATTERN_TXD_SWAP_OFFSET);
-		mask |= HPIPE_SYNC_PATTERN_TXD_SWAP_MASK;
-	}
-	if (invert & PHY_POLARITY_RXD_INVERT) {
-		data |= (1 << HPIPE_SYNC_PATTERN_RXD_SWAP_OFFSET);
-		mask |= HPIPE_SYNC_PATTERN_RXD_SWAP_MASK;
-	}
-	reg_set(hpipe_addr + HPIPE_SYNC_PATTERN_REG, data, mask);
-
-	/* SW reset for interupt logic */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET,
-		HPIPE_PWR_CTR_SFT_RST_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_SFT_RST_OFFSET,
-		HPIPE_PWR_CTR_SFT_RST_MASK);
-
-	debug("stage: Comphy power up\n");
 	/*
 	 * MAC configuration power up comphy - power up PLL/TX/RX
 	 * use indirect address for vendor spesific SATA control register
@@ -979,649 +182,38 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 	reg_set(sata_base + SATA3_VENDOR_DATA,
 		0x1 << SATA_MBUS_REGRET_EN_OFFSET, SATA_MBUS_REGRET_EN_MASK);
 
-	debug("stage: Check PLL\n");
-
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_TX_MASK &
-		SD_EXTERNAL_STATUS0_PLL_RX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_TX is %d, SD_EXTERNAL_STATUS0_PLL_RX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK));
-		ret = 0;
-	}
-
-	debug_exit();
-	return ret;
-}
-
-static int comphy_sgmii_power_up(u32 lane, u32 sgmii_speed,
-				 void __iomem *hpipe_base,
-				 void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	if (sgmii_speed == PHY_SPEED_1_25G) {
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	} else {
-		/* 3.125G */
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	}
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_REFCLK_SEL_MASK;
-	data = 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x0 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Set analog paramters from ETP(HW) - for now use the default datas */
-	debug("stage: Analog paramters from ETP(HW)\n");
-
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
-		0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET,
-		HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
-	}
-
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+	ret = comphy_smc(MV_SIP_COMPHY_PLL_LOCK, comphy_base_addr, lane, type);
 
 	debug_exit();
 	return ret;
 }
 
-static int comphy_sfi_power_up(u32 lane, void __iomem *hpipe_base,
-			       void __iomem *comphy_base, u32 speed)
+/* This function performs RX training for all FFE possible values.
+ * We get the result for each FFE and eventually the best FFE will
+ * be used and set to the HW.
+ *
+ * Return '1' on succsess.
+ * Return '0' on failure.
+ */
+int comphy_cp110_sfi_rx_training(struct chip_serdes_phy_config *ptr_chip_cfg,
+				 u32 lane)
 {
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
+	int ret;
+	u32 type = ptr_chip_cfg->comphy_map_data[lane].type;
 
 	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
 
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_ICP_FORCE_MASK;
-	data = (speed == PHY_SPEED_5_15625G) ?
-		(0x0 << HPIPE_MISC_ICP_FORCE_OFFSET) :
-		(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET);
-	mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-	data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Transmitter/Receiver Speed Divider Force */
-	if (speed == PHY_SPEED_5_15625G) {
-		mask = HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_MASK;
-		data = 1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET;
-	} else {
-		mask = HPIPE_TXDIGCK_DIV_FORCE_MASK;
-		data = 0x1 << HPIPE_TXDIGCK_DIV_FORCE_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_SPD_DIV_FORCE_REG, data, mask);
-
-	/* Set analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* SERDES External Configuration 2 */
-	mask = SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
-	/* 0x7-DFE Resolution control */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
-	/* 0xd-G1_Setting_0 */
-	if (speed == PHY_SPEED_5_15625G) {
-		mask = HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-		data = 0x6 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	} else {
-		mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
-		data = 0x1c << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
-		mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-		data |= 0xe << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
-	/* Genration 1 setting 2 (G1_Setting_2) */
-	mask = HPIPE_G1_SET_2_G1_TX_EMPH0_MASK;
-	data = 0x0 << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET;
-	mask |= HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_2_REG, data, mask);
-	/* Transmitter Slew Rate Control register (tx_reg1) */
-	mask = HPIPE_TX_REG1_TX_EMPH_RES_MASK;
-	data = 0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET;
-	mask |= HPIPE_TX_REG1_SLC_EN_MASK;
-	data |= 0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_REG1_REG, data, mask);
-	/* Impedance Calibration Control register (cal_reg1) */
-	mask = HPIPE_CAL_REG_1_EXT_TXIMP_MASK;
-	data = 0xe << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	mask |= HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK;
-	data |= 0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_CAL_REG1_REG, data, mask);
-	/* Generation 1 Setting 5 (g1_setting_5) */
-	mask = HPIPE_G1_SETTING_5_G1_ICP_MASK;
-	data = 0 << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTING_5_REG, data, mask);
-	/* 0xE-G1_Setting_1 */
-	mask = HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
-	data = 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
-	if (speed == PHY_SPEED_5_15625G) {
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	} else {
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-		data |= 0x2 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-		data |= 0x2 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
-		data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
-		data |= 0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-
-	/* 0xA-DFE_Reg3 */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* 0x111-G1_Setting_4 */
-	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
-	/* Genration 1 setting 3 (G1_Setting_3) */
-	mask = HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET;
-	if (speed == PHY_SPEED_5_15625G) {
-		/* Force FFE (Feed Forward Equalization) to 5G */
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
-		data |= 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
-		data |= 0x4 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
-		data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	/* Connfigure RX training timer */
-	mask = HPIPE_RX_TRAIN_TIMER_MASK;
-	data = 0x13 << HPIPE_RX_TRAIN_TIMER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_5_REG, data, mask);
-
-	/* Enable TX train peak to peak hold */
-	mask = HPIPE_TX_TRAIN_P2P_HOLD_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_0_REG, data, mask);
-
-	/* Configure TX preset index */
-	mask = HPIPE_TX_PRESET_INDEX_MASK;
-	data = 0x2 << HPIPE_TX_PRESET_INDEX_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_PRESET_INDEX_REG, data, mask);
-
-	/* Disable pattern lock lost timeout */
-	mask = HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK;
-	data = 0x0 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_3_REG, data, mask);
-
-	/* Configure TX training pattern and TX training 16bit auto */
-	mask = HPIPE_TX_TRAIN_16BIT_AUTO_EN_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET;
-	mask |= HPIPE_TX_TRAIN_PAT_SEL_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_PAT_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_REG, data, mask);
-
-	/* Configure Training patten number */
-	mask = HPIPE_TRAIN_PAT_NUM_MASK;
-	data = 0x88 << HPIPE_TRAIN_PAT_NUM_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_0_REG, data, mask);
-
-	/* Configure differencial manchester encoter to ethernet mode */
-	mask = HPIPE_DME_ETHERNET_MODE_MASK;
-	data = 0x1 << HPIPE_DME_ETHERNET_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DME_REG, data, mask);
-
-	/* Configure VDD Continuous Calibration */
-	mask = HPIPE_CAL_VDD_CONT_MODE_MASK;
-	data = 0x1 << HPIPE_CAL_VDD_CONT_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_0_REG, data, mask);
-
-	/* Trigger sampler enable pulse (by toggleing the bit) */
-	mask = HPIPE_RX_SAMPLER_OS_GAIN_MASK;
-	data = 0x3 << HPIPE_RX_SAMPLER_OS_GAIN_OFFSET;
-	mask |= HPIPE_SMAPLER_MASK;
-	data |= 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x0 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-
-	/* Set External RX Regulator Control */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x1A << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
+	if (type != COMPHY_TYPE_SFI0 && type != COMPHY_TYPE_SFI1) {
+		pr_err("Comphy %d isn't configured to SFI\n", lane);
+		return 0;
 	}
 
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+	/* Mode is not relevant for xfi training */
+	ret = comphy_smc(MV_SIP_COMPHY_XFI_TRAIN,
+			 ptr_chip_cfg->comphy_base_addr, lane, 0);
 
 	debug_exit();
-	return ret;
-}
-
-static int comphy_rxauii_power_up(u32 lane, void __iomem *hpipe_base,
-				  void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
 
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	if (lane == 2) {
-		reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-			0x1 << COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET,
-			COMMON_PHY_SD_CTRL1_RXAUI0_MASK);
-	}
-	if (lane == 4) {
-		reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-			0x1 << COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET,
-			COMMON_PHY_SD_CTRL1_RXAUI1_MASK);
-	}
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	data |= 0xB << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	data |= 0xB << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_MEDIA_MODE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x1 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG,
-		0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET,
-		HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK);
-
-	/* Set analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* SERDES External Configuration 2 */
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG,
-		0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET,
-		SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK);
-	/* 0x7-DFE Resolution control */
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, 0x1 << HPIPE_DFE_RES_FORCE_OFFSET,
-		HPIPE_DFE_RES_FORCE_MASK);
-	/* 0xd-G1_Setting_0 */
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
-		0xd << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET,
-		HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
-	/* 0xE-G1_Setting_1 */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-	/* 0xA-DFE_Reg3 */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* 0x111-G1_Setting_4 */
-	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG,
-		0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET,
-		SD_EXTERNAL_CONFIG1_RX_INIT_MASK);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
-	}
-
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	debug_exit();
 	return ret;
 }
 
@@ -1670,7 +262,8 @@ static void comphy_utmi_power_down(u32 utmi_index, void __iomem *utmi_base_addr,
 	return;
 }
 
-static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
+static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_pll_addr,
+				   void __iomem *utmi_base_addr,
 				   void __iomem *usb_cfg_addr,
 				   void __iomem *utmi_cfg_addr,
 				   u32 utmi_phy_port)
@@ -1688,27 +281,37 @@ static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
 	/* Select LPFR - 0x0 for 25Mhz/5=5Mhz*/
 	mask |= UTMI_PLL_CTRL_SEL_LPFR_MASK;
 	data |= 0x0 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET;
-	reg_set(utmi_base_addr + UTMI_PLL_CTRL_REG, data, mask);
+	reg_set(utmi_pll_addr + UTMI_PLL_CTRL_REG, data, mask);
 
 	/* Impedance Calibration Threshold Setting */
-	reg_set(utmi_base_addr + UTMI_CALIB_CTRL_REG,
-		0x6 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET,
-		UTMI_CALIB_CTRL_IMPCAL_VTH_MASK);
+	mask = UTMI_CALIB_CTRL_IMPCAL_VTH_MASK;
+	data = 0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET;
+	reg_set(utmi_pll_addr + UTMI_CALIB_CTRL_REG, data, mask);
+
+	/* Start Impedance and PLL Calibration */
+	mask = UTMI_CALIB_CTRL_PLLCAL_START_MASK;
+	data = (0x1 << UTMI_CALIB_CTRL_PLLCAL_START_OFFSET);
+	mask |= UTMI_CALIB_CTRL_IMPCAL_START_MASK;
+	data |= (0x1 << UTMI_CALIB_CTRL_IMPCAL_START_OFFSET);
+	reg_set(utmi_pll_addr + UTMI_CALIB_CTRL_REG, data, mask);
 
 	/* Set LS TX driver strength coarse control */
-	mask = UTMI_TX_CH_CTRL_DRV_EN_LS_MASK;
-	data = 0x3 << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET;
-	/* Set LS TX driver fine adjustment */
+	mask = UTMI_TX_CH_CTRL_AMP_MASK;
+	data = 0x4 << UTMI_TX_CH_CTRL_AMP_OFFSET;
 	mask |= UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK;
 	data |= 0x3 << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET;
+	mask |= UTMI_TX_CH_CTRL_DRV_EN_LS_MASK;
+	data |= 0x3 << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET;
 	reg_set(utmi_base_addr + UTMI_TX_CH_CTRL_REG, data, mask);
 
 	/* Enable SQ */
 	mask = UTMI_RX_CH_CTRL0_SQ_DET_MASK;
-	data = 0x0 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
+	data = 0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
 	/* Enable analog squelch detect */
 	mask |= UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK;
-	data |= 0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	data |= 0x0 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	mask |= UTMI_RX_CH_CTRL0_DISCON_THRESH_MASK;
+	data |= 0x0 << UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET;
 	reg_set(utmi_base_addr + UTMI_RX_CH_CTRL0_REG, data, mask);
 
 	/* Set External squelch calibration number */
@@ -1731,7 +334,8 @@ static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
 	return;
 }
 
-static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
+static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_pll_addr,
+				void __iomem *utmi_base_addr,
 				void __iomem *usb_cfg_addr,
 				void __iomem *utmi_cfg_addr, u32 utmi_phy_port)
 {
@@ -1750,7 +354,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 		UTMI_CTRL_STATUS0_TEST_SEL_MASK);
 
 	debug("stage: Polling for PLL and impedance calibration done, and PLL ready done\n");
-	addr = utmi_base_addr + UTMI_CALIB_CTRL_REG;
+	addr = utmi_pll_addr + UTMI_CALIB_CTRL_REG;
 	data = UTMI_CALIB_CTRL_IMPCAL_DONE_MASK;
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
@@ -1769,7 +373,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 		ret = 0;
 	}
 
-	addr = utmi_base_addr + UTMI_PLL_CTRL_REG;
+	addr = utmi_pll_addr + UTMI_PLL_CTRL_REG;
 	data = UTMI_PLL_CTRL_PLL_RDY_MASK;
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
@@ -1793,7 +397,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
  * the init split in 3 parts:
  * 1. Power down transceiver and PLL
  * 2. UTMI PHY configure
- * 3. Powe up transceiver and PLL
+ * 3. Power up transceiver and PLL
  * Note: - Power down/up should be once for both UTMI PHYs
  *       - comphy_dedicated_phys_init call this function if at least there is
  *         one UTMI PHY exists in FDT blob. access to cp110_utmi_data[0] is
@@ -1820,14 +424,16 @@ static void comphy_utmi_phy_init(u32 utmi_phy_count,
 	}
 	/* UTMI configure */
 	for (i = 0; i < utmi_phy_count; i++) {
-		comphy_utmi_phy_config(i, cp110_utmi_data[i].utmi_base_addr,
+		comphy_utmi_phy_config(i, cp110_utmi_data[i].utmi_pll_addr,
+				       cp110_utmi_data[i].utmi_base_addr,
 				       cp110_utmi_data[i].usb_cfg_addr,
 				       cp110_utmi_data[i].utmi_cfg_addr,
 				       cp110_utmi_data[i].utmi_phy_port);
 	}
 	/* UTMI Power up */
 	for (i = 0; i < utmi_phy_count; i++) {
-		if (!comphy_utmi_power_up(i, cp110_utmi_data[i].utmi_base_addr,
+		if (!comphy_utmi_power_up(i, cp110_utmi_data[i].utmi_pll_addr,
+					  cp110_utmi_data[i].utmi_base_addr,
 					  cp110_utmi_data[i].usb_cfg_addr,
 					  cp110_utmi_data[i].utmi_cfg_addr,
 					  cp110_utmi_data[i].utmi_phy_port)) {
@@ -1860,45 +466,61 @@ static void comphy_utmi_phy_init(u32 utmi_phy_count,
 void comphy_dedicated_phys_init(void)
 {
 	struct utmi_phy_data cp110_utmi_data[MAX_UTMI_PHY_COUNT];
-	int node;
-	int i;
+	int node = -1;
+	int node_idx;
+	int parent = -1;
 
 	debug_enter();
 	debug("Initialize USB UTMI PHYs\n");
 
-	/* Find the UTMI phy node in device tree and go over them */
-	node = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
-					     "marvell,mvebu-utmi-2.6.0");
+	for (node_idx = 0; node_idx < MAX_UTMI_PHY_COUNT;) {
+		/* Find the UTMI phy node in device tree */
+		node = fdt_node_offset_by_compatible(gd->fdt_blob, node,
+						     "marvell,mvebu-utmi-2.6.0");
+		if (node <= 0)
+			break;
+
+		/* check if node is enabled */
+		if (!fdtdec_get_is_enabled(gd->fdt_blob, node))
+			continue;
+
+		parent = fdt_parent_offset(gd->fdt_blob, node);
+		if (parent <= 0)
+			break;
+
+		/* get base address of UTMI PLL */
+		cp110_utmi_data[node_idx].utmi_pll_addr =
+			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
+				gd->fdt_blob, parent, "reg", 0, NULL, true);
+		if (!cp110_utmi_data[node_idx].utmi_pll_addr) {
+			pr_err("UTMI PHY PLL address is invalid\n");
+			continue;
+		}
 
-	i = 0;
-	while (node > 0) {
 		/* get base address of UTMI phy */
-		cp110_utmi_data[i].utmi_base_addr =
+		cp110_utmi_data[node_idx].utmi_base_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 0, NULL, true);
-		if (cp110_utmi_data[i].utmi_base_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].utmi_base_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
 		/* get usb config address */
-		cp110_utmi_data[i].usb_cfg_addr =
+		cp110_utmi_data[node_idx].usb_cfg_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 1, NULL, true);
-		if (cp110_utmi_data[i].usb_cfg_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].usb_cfg_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
 		/* get UTMI config address */
-		cp110_utmi_data[i].utmi_cfg_addr =
+		cp110_utmi_data[node_idx].utmi_cfg_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 2, NULL, true);
-		if (cp110_utmi_data[i].utmi_cfg_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].utmi_cfg_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
@@ -1906,71 +528,32 @@ void comphy_dedicated_phys_init(void)
 		 * get the port number (to check if the utmi connected to
 		 * host/device)
 		 */
-		cp110_utmi_data[i].utmi_phy_port = fdtdec_get_int(
+		cp110_utmi_data[node_idx].utmi_phy_port = fdtdec_get_int(
 			gd->fdt_blob, node, "utmi-port", UTMI_PHY_INVALID);
-		if (cp110_utmi_data[i].utmi_phy_port == UTMI_PHY_INVALID) {
+		if (cp110_utmi_data[node_idx].utmi_phy_port ==
+							UTMI_PHY_INVALID) {
 			pr_err("UTMI PHY port type is invalid\n");
-			i++;
 			continue;
 		}
 
-		node = fdt_node_offset_by_compatible(
-			gd->fdt_blob, node, "marvell,mvebu-utmi-2.6.0");
-		i++;
+		/* count valid UTMI unit */
+		node_idx++;
 	}
 
-	if (i > 0)
-		comphy_utmi_phy_init(i, cp110_utmi_data);
+	if (node_idx > 0)
+		comphy_utmi_phy_init(node_idx, cp110_utmi_data);
 
 	debug_exit();
 }
 
-static void comphy_mux_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-				  struct comphy_map *serdes_map)
-{
-	void __iomem *comphy_base_addr;
-	struct comphy_map comphy_map_pipe_data[MAX_LANE_OPTIONS];
-	struct comphy_map comphy_map_phy_data[MAX_LANE_OPTIONS];
-	u32 lane, comphy_max_count;
-
-	comphy_max_count = ptr_chip_cfg->comphy_lanes_count;
-	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
-
-	/*
-	 * Copy the SerDes map configuration for PIPE map and PHY map
-	 * the comphy_mux_init modify the type of the lane if the type
-	 * is not valid because we have 2 selectores run the
-	 * comphy_mux_init twice and after that update the original
-	 * serdes_map
-	 */
-	for (lane = 0; lane < comphy_max_count; lane++) {
-		comphy_map_pipe_data[lane].type = serdes_map[lane].type;
-		comphy_map_pipe_data[lane].speed = serdes_map[lane].speed;
-		comphy_map_phy_data[lane].type = serdes_map[lane].type;
-		comphy_map_phy_data[lane].speed = serdes_map[lane].speed;
-	}
-	ptr_chip_cfg->mux_data = cp110_comphy_phy_mux_data;
-	comphy_mux_init(ptr_chip_cfg, comphy_map_phy_data,
-			comphy_base_addr + COMMON_SELECTOR_PHY_OFFSET);
-
-	ptr_chip_cfg->mux_data = cp110_comphy_pipe_mux_data;
-	comphy_mux_init(ptr_chip_cfg, comphy_map_pipe_data,
-			comphy_base_addr + COMMON_SELECTOR_PIPE_OFFSET);
-	/* Fix the type after check the PHY and PIPE configuration */
-	for (lane = 0; lane < comphy_max_count; lane++) {
-		if ((comphy_map_pipe_data[lane].type == PHY_TYPE_UNCONNECTED) &&
-		    (comphy_map_phy_data[lane].type == PHY_TYPE_UNCONNECTED))
-			serdes_map[lane].type = PHY_TYPE_UNCONNECTED;
-	}
-}
-
 int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		      struct comphy_map *serdes_map)
 {
 	struct comphy_map *ptr_comphy_map;
 	void __iomem *comphy_base_addr, *hpipe_base_addr;
-	u32 comphy_max_count, lane, ret = 0;
+	u32 comphy_max_count, lane, id, ret = 0;
 	u32 pcie_width = 0;
+	u32 mode;
 
 	debug_enter();
 
@@ -1978,13 +561,10 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
 	hpipe_base_addr = ptr_chip_cfg->hpipe3_base_addr;
 
-	/* Config Comphy mux configuration */
-	comphy_mux_cp110_init(ptr_chip_cfg, serdes_map);
-
 	/* Check if the first 4 lanes configured as By-4 */
 	for (lane = 0, ptr_comphy_map = serdes_map; lane < 4;
 	     lane++, ptr_comphy_map++) {
-		if (ptr_comphy_map->type != PHY_TYPE_PEX0)
+		if (ptr_comphy_map->type != COMPHY_TYPE_PEX0)
 			break;
 		pcie_width++;
 	}
@@ -2001,56 +581,88 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 			pcie_width = 1;
 		}
 		switch (ptr_comphy_map->type) {
-		case PHY_TYPE_UNCONNECTED:
-		case PHY_TYPE_IGNORE:
+		case COMPHY_TYPE_UNCONNECTED:
+			mode = COMPHY_TYPE_UNCONNECTED | COMPHY_CALLER_UBOOT;
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_OFF,
+					 ptr_chip_cfg->comphy_base_addr,
+					 lane, mode);
+		case COMPHY_TYPE_IGNORE:
 			continue;
 			break;
-		case PHY_TYPE_PEX0:
-		case PHY_TYPE_PEX1:
-		case PHY_TYPE_PEX2:
-		case PHY_TYPE_PEX3:
-			ret = comphy_pcie_power_up(
-				lane, pcie_width, ptr_comphy_map->clk_src,
-				serdes_map->end_point,
-				hpipe_base_addr, comphy_base_addr);
+		case COMPHY_TYPE_PEX0:
+		case COMPHY_TYPE_PEX1:
+		case COMPHY_TYPE_PEX2:
+		case COMPHY_TYPE_PEX3:
+			mode = COMPHY_FW_PCIE_FORMAT(pcie_width,
+						     ptr_comphy_map->clk_src,
+						     COMPHY_PCIE_MODE,
+						     ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
+			break;
+		case COMPHY_TYPE_SATA0:
+		case COMPHY_TYPE_SATA1:
+			mode =  COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE);
+			ret = comphy_sata_power_up(lane, hpipe_base_addr,
+						   comphy_base_addr,
+						   ptr_chip_cfg->cp_index,
+						   mode);
 			break;
-		case PHY_TYPE_SATA0:
-		case PHY_TYPE_SATA1:
-		case PHY_TYPE_SATA2:
-		case PHY_TYPE_SATA3:
-			ret = comphy_sata_power_up(
-				lane, hpipe_base_addr, comphy_base_addr,
-				ptr_chip_cfg->cp_index,
-				serdes_map[lane].invert);
+		case COMPHY_TYPE_USB3_HOST0:
+		case COMPHY_TYPE_USB3_HOST1:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_USB3H_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_USB3_HOST0:
-		case PHY_TYPE_USB3_HOST1:
-		case PHY_TYPE_USB3_DEVICE:
-			ret = comphy_usb3_power_up(lane, hpipe_base_addr,
-						   comphy_base_addr);
+		case COMPHY_TYPE_USB3_DEVICE:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_USB3D_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_SGMII0:
-		case PHY_TYPE_SGMII1:
-		case PHY_TYPE_SGMII2:
-		case PHY_TYPE_SGMII3:
-			if (ptr_comphy_map->speed == PHY_SPEED_INVALID) {
-				debug("Warning: SGMII PHY speed in lane %d is invalid, set PHY speed to 1.25G\n",
+		case COMPHY_TYPE_SGMII0:
+		case COMPHY_TYPE_SGMII1:
+		case COMPHY_TYPE_SGMII2:
+			/* Calculate SGMII ID */
+			id = ptr_comphy_map->type - COMPHY_TYPE_SGMII0;
+
+			if (ptr_comphy_map->speed == COMPHY_SPEED_INVALID) {
+				debug("Warning: ");
+				debug("SGMII PHY speed in lane %d is invalid,",
 				      lane);
-				ptr_comphy_map->speed = PHY_SPEED_1_25G;
+				debug(" set PHY speed to 1.25G\n");
+				ptr_comphy_map->speed = COMPHY_SPEED_1_25G;
 			}
-			ret = comphy_sgmii_power_up(
-				lane, ptr_comphy_map->speed, hpipe_base_addr,
-				comphy_base_addr);
+
+			mode = COMPHY_FW_FORMAT(COMPHY_SGMII_MODE, id,
+						ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
+			break;
+		case COMPHY_TYPE_SFI0:
+		case COMPHY_TYPE_SFI1:
+			/* Calculate SFI id */
+			id = ptr_comphy_map->type - COMPHY_TYPE_SFI0;
+			mode = COMPHY_FW_FORMAT(COMPHY_SFI_MODE, id,
+						ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+				ptr_chip_cfg->comphy_base_addr, lane, mode);
 			break;
-		case PHY_TYPE_SFI:
-			ret = comphy_sfi_power_up(lane, hpipe_base_addr,
-						  comphy_base_addr,
-						  ptr_comphy_map->speed);
+		case COMPHY_TYPE_RXAUI0:
+		case COMPHY_TYPE_RXAUI1:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_RXAUI_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_RXAUI0:
-		case PHY_TYPE_RXAUI1:
-			ret = comphy_rxauii_power_up(lane, hpipe_base_addr,
-						     comphy_base_addr);
+		case COMPHY_TYPE_AP:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_AP_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
 		default:
 			debug("Unknown SerDes type, skip initialize SerDes %d\n",
@@ -2060,9 +672,9 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		if (ret == 0) {
 			/*
 			 * If interface wans't initialized, set the lane to
-			 * PHY_TYPE_UNCONNECTED state.
+			 * COMPHY_TYPE_UNCONNECTED state.
 			 */
-			ptr_comphy_map->type = PHY_TYPE_UNCONNECTED;
+			ptr_comphy_map->type = COMPHY_TYPE_UNCONNECTED;
 			pr_err("PLL is not locked - Failed to initialize lane %d\n",
 			      lane);
 		}
diff --git a/drivers/phy/marvell/comphy_hpipe.h b/drivers/phy/marvell/comphy_hpipe.h
deleted file mode 100644
index a692035c94..0000000000
--- a/drivers/phy/marvell/comphy_hpipe.h
+++ /dev/null
@@ -1,660 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- */
-
-#ifndef _COMPHY_HPIPE_H_
-#define _COMPHY_HPIPE_H_
-
-/* SerDes IP register */
-#define SD_EXTERNAL_CONFIG0_REG			0
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET	1
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET 3
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK	\
-	(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET 7
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK	\
-	(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET	11
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET	12
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET 14
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET)
-#define SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET	15
-#define SD_EXTERNAL_CONFIG0_MEDIA_MODE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET)
-
-#define SD_EXTERNAL_CONFIG1_REG			0x4
-#define SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET	3
-#define SD_EXTERNAL_CONFIG1_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_CONFIG1_RX_INIT_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET	5
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET	6
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET)
-
-#define SD_EXTERNAL_CONFIG2_REG			0x8
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET	4
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET)
-#define SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET	7
-#define SD_EXTERNAL_CONFIG2_SSC_ENABLE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET)
-
-#define SD_EXTERNAL_STATUS0_REG			0x18
-#define SD_EXTERNAL_STATUS0_PLL_TX_OFFSET	2
-#define SD_EXTERNAL_STATUS0_PLL_TX_MASK		\
-	(0x1 << SD_EXTERNAL_STATUS0_PLL_TX_OFFSET)
-#define SD_EXTERNAL_STATUS0_PLL_RX_OFFSET	3
-#define SD_EXTERNAL_STATUS0_PLL_RX_MASK		\
-	(0x1 << SD_EXTERNAL_STATUS0_PLL_RX_OFFSET)
-#define SD_EXTERNAL_STATUS0_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_STATUS0_RX_INIT_MASK	\
-	(0x1 << SD_EXTERNAL_STATUS0_RX_INIT_OFFSET)
-#define SD_EXTERNAL_STATUS0_RF_RESET_IN_OFFSET	6
-#define SD_EXTERNAL_STATUS0_RF_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_STATUS0_RF_RESET_IN_OFFSET)
-
-/* HPIPE register */
-#define HPIPE_PWR_PLL_REG			0x4
-#define HPIPE_PWR_PLL_REF_FREQ_OFFSET		0
-#define HPIPE_PWR_PLL_REF_FREQ_MASK		\
-	(0x1f << HPIPE_PWR_PLL_REF_FREQ_OFFSET)
-#define HPIPE_PWR_PLL_PHY_MODE_OFFSET		5
-#define HPIPE_PWR_PLL_PHY_MODE_MASK		\
-	(0x7 << HPIPE_PWR_PLL_PHY_MODE_OFFSET)
-
-#define HPIPE_KVCO_CALIB_CTRL_REG		0x8
-#define HPIPE_KVCO_CALIB_CTRL_MAX_PLL_OFFSET	12
-#define HPIPE_KVCO_CALIB_CTRL_MAX_PLL_MASK	\
-	(0x1 << HPIPE_KVCO_CALIB_CTRL_MAX_PLL_OFFSET)
-
-#define HPIPE_CAL_REG1_REG			0xc
-#define HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET	10
-#define HPIPE_CAL_REG_1_EXT_TXIMP_MASK		\
-	(0x1f << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET)
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET	15
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK	\
-	(0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET)
-
-#define HPIPE_SQUELCH_FFE_SETTING_REG           0x018
-
-#define HPIPE_DFE_REG0				0x01C
-#define HPIPE_DFE_RES_FORCE_OFFSET		15
-#define HPIPE_DFE_RES_FORCE_MASK		\
-	(0x1 << HPIPE_DFE_RES_FORCE_OFFSET)
-
-#define HPIPE_DFE_F3_F5_REG			0x028
-#define HPIPE_DFE_F3_F5_DFE_EN_OFFSET		14
-#define HPIPE_DFE_F3_F5_DFE_EN_MASK		\
-	(0x1 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET)
-#define HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET		15
-#define HPIPE_DFE_F3_F5_DFE_CTRL_MASK		\
-	(0x1 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET)
-
-#define HPIPE_G1_SET_0_REG			0x034
-#define HPIPE_G1_SET_0_G1_TX_AMP_OFFSET		1
-#define HPIPE_G1_SET_0_G1_TX_AMP_MASK		\
-	(0x1f << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G1_SET_0_G1_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET	7
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET)
-
-#define HPIPE_G1_SET_1_REG			0x038
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET	0
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET	3
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK	\
-	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET	6
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET	8
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET	10
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET)
-
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G2_SET_0_REG			0x3c
-#define HPIPE_G2_SET_0_G2_TX_AMP_OFFSET		1
-#define HPIPE_G2_SET_0_G2_TX_AMP_MASK		\
-	(0x1f << HPIPE_G2_SET_0_G2_TX_AMP_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G2_SET_0_G2_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET	7
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET)
-
-#define HPIPE_G2_SET_1_REG			0x040
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET	0
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET	3
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK	\
-	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET	6
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET	8
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET	10
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G3_SET_0_REG			0x44
-#define HPIPE_G3_SET_0_G3_TX_AMP_OFFSET		1
-#define HPIPE_G3_SET_0_G3_TX_AMP_MASK		\
-	(0x1f << HPIPE_G3_SET_0_G3_TX_AMP_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G3_SET_0_G3_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET	7
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET 12
-#define HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_MASK	\
-	(0x7 << HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET 15
-#define HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET)
-
-#define HPIPE_G3_SET_1_REG			0x048
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET	0
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET	3
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK	\
-	(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET	6
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET	8
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET	10
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK	 \
-	(0x3 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET)
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET	13
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET)
-
-#define HPIPE_LOOPBACK_REG			0x08c
-#define HPIPE_LOOPBACK_SEL_OFFSET		1
-#define HPIPE_LOOPBACK_SEL_MASK			\
-	(0x7 << HPIPE_LOOPBACK_SEL_OFFSET)
-
-#define HPIPE_SYNC_PATTERN_REG                  0x090
-#define HPIPE_SYNC_PATTERN_TXD_SWAP_OFFSET	10
-#define HPIPE_SYNC_PATTERN_TXD_SWAP_MASK	\
-	(0x1 << HPIPE_SYNC_PATTERN_TXD_SWAP_OFFSET)
-#define HPIPE_SYNC_PATTERN_RXD_SWAP_OFFSET	11
-#define HPIPE_SYNC_PATTERN_RXD_SWAP_MASK	\
-	(0x1 << HPIPE_SYNC_PATTERN_RXD_SWAP_OFFSET)
-
-#define HPIPE_INTERFACE_REG			0x94
-#define HPIPE_INTERFACE_GEN_MAX_OFFSET		10
-#define HPIPE_INTERFACE_GEN_MAX_MASK		\
-	(0x3 << HPIPE_INTERFACE_GEN_MAX_OFFSET)
-#define HPIPE_INTERFACE_DET_BYPASS_OFFSET	12
-#define HPIPE_INTERFACE_DET_BYPASS_MASK		\
-	(0x1 << HPIPE_INTERFACE_DET_BYPASS_OFFSET)
-#define HPIPE_INTERFACE_LINK_TRAIN_OFFSET	14
-#define HPIPE_INTERFACE_LINK_TRAIN_MASK		\
-	(0x1 << HPIPE_INTERFACE_LINK_TRAIN_OFFSET)
-
-#define HPIPE_ISOLATE_MODE_REG			0x98
-#define HPIPE_ISOLATE_MODE_GEN_RX_OFFSET	0
-#define HPIPE_ISOLATE_MODE_GEN_RX_MASK		\
-	(0xf << HPIPE_ISOLATE_MODE_GEN_RX_OFFSET)
-#define HPIPE_ISOLATE_MODE_GEN_TX_OFFSET	4
-#define HPIPE_ISOLATE_MODE_GEN_TX_MASK		\
-	(0xf << HPIPE_ISOLATE_MODE_GEN_TX_OFFSET)
-
-#define HPIPE_G1_SET_2_REG			0xf4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET	0
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_MASK		\
-	(0xf << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET)
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET	4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_MASK)
-
-#define HPIPE_VTHIMPCAL_CTRL_REG                0x104
-
-#define HPIPE_VDD_CAL_CTRL_REG			0x114
-#define HPIPE_EXT_SELLV_RXSAMPL_OFFSET		5
-#define HPIPE_EXT_SELLV_RXSAMPL_MASK		\
-	(0x1f << HPIPE_EXT_SELLV_RXSAMPL_OFFSET)
-
-#define HPIPE_VDD_CAL_0_REG			0x108
-#define HPIPE_CAL_VDD_CONT_MODE_OFFSET		15
-#define HPIPE_CAL_VDD_CONT_MODE_MASK		\
-	(0x1 << HPIPE_CAL_VDD_CONT_MODE_OFFSET)
-
-#define HPIPE_PCIE_REG0                         0x120
-#define HPIPE_PCIE_IDLE_SYNC_OFFSET		12
-#define HPIPE_PCIE_IDLE_SYNC_MASK		\
-	(0x1 << HPIPE_PCIE_IDLE_SYNC_OFFSET)
-#define HPIPE_PCIE_SEL_BITS_OFFSET		13
-#define HPIPE_PCIE_SEL_BITS_MASK		\
-	(0x3 << HPIPE_PCIE_SEL_BITS_OFFSET)
-
-#define HPIPE_LANE_ALIGN_REG			0x124
-#define HPIPE_LANE_ALIGN_OFF_OFFSET		12
-#define HPIPE_LANE_ALIGN_OFF_MASK		\
-	(0x1 << HPIPE_LANE_ALIGN_OFF_OFFSET)
-
-#define HPIPE_MISC_REG				0x13C
-#define HPIPE_MISC_CLK100M_125M_OFFSET		4
-#define HPIPE_MISC_CLK100M_125M_MASK		\
-	(0x1 << HPIPE_MISC_CLK100M_125M_OFFSET)
-#define HPIPE_MISC_ICP_FORCE_OFFSET		5
-#define HPIPE_MISC_ICP_FORCE_MASK		\
-	(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET)
-#define HPIPE_MISC_TXDCLK_2X_OFFSET		6
-#define HPIPE_MISC_TXDCLK_2X_MASK		\
-	(0x1 << HPIPE_MISC_TXDCLK_2X_OFFSET)
-#define HPIPE_MISC_CLK500_EN_OFFSET		7
-#define HPIPE_MISC_CLK500_EN_MASK		\
-	(0x1 << HPIPE_MISC_CLK500_EN_OFFSET)
-#define HPIPE_MISC_REFCLK_SEL_OFFSET		10
-#define HPIPE_MISC_REFCLK_SEL_MASK		\
-	(0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET)
-
-#define HPIPE_RX_CONTROL_1_REG			0x140
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET	11
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK	\
-	(0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET)
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET	12
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_MASK	\
-	(0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_REG			0x148
-#define HPIPE_PWR_CTR_RST_DFE_OFFSET		0
-#define HPIPE_PWR_CTR_RST_DFE_MASK		\
-	(0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET)
-#define HPIPE_PWR_CTR_SFT_RST_OFFSET		10
-#define HPIPE_PWR_CTR_SFT_RST_MASK		\
-	(0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET)
-
-#define HPIPE_SPD_DIV_FORCE_REG				0x154
-#define HPIPE_TXDIGCK_DIV_FORCE_OFFSET			7
-#define HPIPE_TXDIGCK_DIV_FORCE_MASK			\
-	(0x1 << HPIPE_TXDIGCK_DIV_FORCE_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET		8
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_MASK		\
-	(0x3 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET	10
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET		13
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_MASK		\
-	(0x3 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET	15
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET)
-
-#define HPIPE_PLLINTP_REG1			0x150
-
-#define HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG	0x16C
-#define HPIPE_RX_SAMPLER_OS_GAIN_OFFSET		6
-#define HPIPE_RX_SAMPLER_OS_GAIN_MASK		\
-	(0x3 << HPIPE_RX_SAMPLER_OS_GAIN_OFFSET)
-#define HPIPE_SMAPLER_OFFSET			12
-#define HPIPE_SMAPLER_MASK			\
-	(0x1 << HPIPE_SMAPLER_OFFSET)
-
-#define HPIPE_TX_REG1_REG			0x174
-#define HPIPE_TX_REG1_TX_EMPH_RES_OFFSET	5
-#define HPIPE_TX_REG1_TX_EMPH_RES_MASK		\
-	(0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET)
-#define HPIPE_TX_REG1_SLC_EN_OFFSET		10
-#define HPIPE_TX_REG1_SLC_EN_MASK		\
-	(0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_DTL_REG				0x184
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET		0
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK		\
-	(0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET		1
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK		\
-	(0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET		2
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK			\
-	(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET		4
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK		\
-	(0x7 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET)
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET	10
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET		12
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_MASK			\
-	(0x3 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET		14
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK		\
-	(1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET)
-
-#define HPIPE_PHASE_CONTROL_REG			0x188
-#define HPIPE_OS_PH_OFFSET_OFFSET		0
-#define HPIPE_OS_PH_OFFSET_MASK			\
-	(0x7f << HPIPE_OS_PH_OFFSET_OFFSET)
-#define HPIPE_OS_PH_OFFSET_FORCE_OFFSET		7
-#define HPIPE_OS_PH_OFFSET_FORCE_MASK		\
-	(0x1 << HPIPE_OS_PH_OFFSET_FORCE_OFFSET)
-#define HPIPE_OS_PH_VALID_OFFSET		8
-#define HPIPE_OS_PH_VALID_MASK			\
-	(0x1 << HPIPE_OS_PH_VALID_OFFSET)
-
-#define HPIPE_FRAME_DETECT_CTRL_0_REG			0x214
-#define HPIPE_TRAIN_PAT_NUM_OFFSET			0x7
-#define HPIPE_TRAIN_PAT_NUM_MASK			\
-	(0x1FF << HPIPE_TRAIN_PAT_NUM_OFFSET)
-
-#define HPIPE_FRAME_DETECT_CTRL_3_REG			0x220
-#define HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET	12
-#define HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK		\
-	(0x1 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET)
-
-#define HPIPE_DME_REG					0x228
-#define HPIPE_DME_ETHERNET_MODE_OFFSET			7
-#define HPIPE_DME_ETHERNET_MODE_MASK			\
-	(0x1 << HPIPE_DME_ETHERNET_MODE_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_0_REG		0x268
-#define HPIPE_TX_TRAIN_P2P_HOLD_OFFSET		15
-#define HPIPE_TX_TRAIN_P2P_HOLD_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_REG			0x26C
-#define HPIPE_TX_TRAIN_CTRL_G1_OFFSET		0
-#define HPIPE_TX_TRAIN_CTRL_G1_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_G1_OFFSET)
-#define HPIPE_TX_TRAIN_CTRL_GN1_OFFSET		1
-#define HPIPE_TX_TRAIN_CTRL_GN1_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_GN1_OFFSET)
-#define HPIPE_TX_TRAIN_CTRL_G0_OFFSET		2
-#define HPIPE_TX_TRAIN_CTRL_G0_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_G0_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_4_REG		0x278
-#define HPIPE_TRX_TRAIN_TIMER_OFFSET		0
-#define HPIPE_TRX_TRAIN_TIMER_MASK		\
-	(0x3FF << HPIPE_TRX_TRAIN_TIMER_OFFSET)
-
-#define HPIPE_PCIE_REG1				0x288
-#define HPIPE_PCIE_REG3				0x290
-
-#define HPIPE_TX_TRAIN_CTRL_5_REG		0x2A4
-#define HPIPE_RX_TRAIN_TIMER_OFFSET		0
-#define HPIPE_RX_TRAIN_TIMER_MASK		\
-	(0x3ff << HPIPE_RX_TRAIN_TIMER_OFFSET)
-#define HPIPE_TX_TRAIN_START_SQ_EN_OFFSET	11
-#define HPIPE_TX_TRAIN_START_SQ_EN_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_START_SQ_EN_OFFSET)
-#define HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET	12
-#define HPIPE_TX_TRAIN_START_FRM_DET_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET)
-#define HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET	13
-#define HPIPE_TX_TRAIN_START_FRM_LOCK_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET)
-#define HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET	14
-#define HPIPE_TX_TRAIN_WAIT_TIME_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET)
-
-#define HPIPE_TX_TRAIN_REG			0x31C
-#define HPIPE_TX_TRAIN_CHK_INIT_OFFSET		4
-#define HPIPE_TX_TRAIN_CHK_INIT_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CHK_INIT_OFFSET)
-#define HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET	7
-#define HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET)
-#define HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET	8
-#define HPIPE_TX_TRAIN_16BIT_AUTO_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET)
-#define HPIPE_TX_TRAIN_PAT_SEL_OFFSET		9
-#define HPIPE_TX_TRAIN_PAT_SEL_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_PAT_SEL_OFFSET)
-
-#define HPIPE_CDR_CONTROL_REG			0x418
-#define HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET	12
-#define HPIPE_CDR_RX_MAX_DFE_ADAPT_1_MASK	\
-	(0x3 << HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET)
-#define HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET	9
-#define HPIPE_CDR_MAX_DFE_ADAPT_0_MASK		\
-	(0x7 << HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET)
-#define HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET	6
-#define HPIPE_CDR_MAX_DFE_ADAPT_1_MASK		\
-	(0x7 << HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_11_REG		0x438
-#define HPIPE_TX_STATUS_CHECK_MODE_OFFSET	6
-#define HPIPE_TX_TX_STATUS_CHECK_MODE_MASK	\
-	(0x1 << HPIPE_TX_STATUS_CHECK_MODE_OFFSET)
-#define HPIPE_TX_NUM_OF_PRESET_OFFSET		10
-#define HPIPE_TX_NUM_OF_PRESET_MASK		\
-	(0x7 << HPIPE_TX_NUM_OF_PRESET_OFFSET)
-#define HPIPE_TX_SWEEP_PRESET_EN_OFFSET		15
-#define HPIPE_TX_SWEEP_PRESET_EN_MASK		\
-	(0x1 << HPIPE_TX_SWEEP_PRESET_EN_OFFSET)
-
-#define HPIPE_G1_SETTINGS_3_REG				0x440
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET	0
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK		\
-	(0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET	4
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK		\
-	(0x7 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET	7
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK	\
-	(0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET		9
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK		\
-	(0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET	12
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET	14
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET)
-
-#define HPIPE_G1_SETTINGS_4_REG			0x444
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET	8
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET)
-
-#define HPIPE_G2_SETTINGS_3_REG			0x448
-
-#define HPIPE_G2_SETTINGS_4_REG			0x44c
-#define HPIPE_G2_DFE_RES_OFFSET			8
-#define HPIPE_G2_DFE_RES_MASK			\
-	(0x3 << HPIPE_G2_DFE_RES_OFFSET)
-
-#define HPIPE_G3_SETTING_3_REG			0x450
-#define HPIPE_G3_FFE_CAP_SEL_OFFSET		0
-#define HPIPE_G3_FFE_CAP_SEL_MASK		\
-	(0xf << HPIPE_G3_FFE_CAP_SEL_OFFSET)
-#define HPIPE_G3_FFE_RES_SEL_OFFSET		4
-#define HPIPE_G3_FFE_RES_SEL_MASK		\
-	(0x7 << HPIPE_G3_FFE_RES_SEL_OFFSET)
-#define HPIPE_G3_FFE_SETTING_FORCE_OFFSET	7
-#define HPIPE_G3_FFE_SETTING_FORCE_MASK		\
-	(0x1 << HPIPE_G3_FFE_SETTING_FORCE_OFFSET)
-#define HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET	12
-#define HPIPE_G3_FFE_DEG_RES_LEVEL_MASK		\
-	(0x3 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET)
-#define HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET	14
-#define HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET)
-
-#define HPIPE_G3_SETTING_4_REG			0x454
-#define HPIPE_G3_DFE_RES_OFFSET			8
-#define HPIPE_G3_DFE_RES_MASK			\
-	(0x3 << HPIPE_G3_DFE_RES_OFFSET)
-
-#define HPIPE_TX_PRESET_INDEX_REG		0x468
-#define HPIPE_TX_PRESET_INDEX_OFFSET		0
-#define HPIPE_TX_PRESET_INDEX_MASK		\
-	(0xf << HPIPE_TX_PRESET_INDEX_OFFSET)
-
-#define HPIPE_DFE_CONTROL_REG			0x470
-#define HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET	14
-#define HPIPE_DFE_TX_MAX_DFE_ADAPT_MASK		\
-	(0x3 << HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET)
-
-#define HPIPE_DFE_CTRL_28_REG			0x49C
-#define HPIPE_DFE_CTRL_28_PIPE4_OFFSET		7
-#define HPIPE_DFE_CTRL_28_PIPE4_MASK		\
-	(0x1 << HPIPE_DFE_CTRL_28_PIPE4_OFFSET)
-
-#define HPIPE_G1_SETTING_5_REG			0x538
-#define HPIPE_G1_SETTING_5_G1_ICP_OFFSET	0
-#define HPIPE_G1_SETTING_5_G1_ICP_MASK		\
-	(0xf << HPIPE_G1_SETTING_5_G1_ICP_OFFSET)
-
-#define HPIPE_G3_SETTING_5_REG			0x548
-#define HPIPE_G3_SETTING_5_G3_ICP_OFFSET	0
-#define HPIPE_G3_SETTING_5_G3_ICP_MASK		\
-	(0xf << HPIPE_G3_SETTING_5_G3_ICP_OFFSET)
-
-#define HPIPE_LANE_CONFIG0_REG			0x600
-#define HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET	0
-#define HPIPE_LANE_CONFIG0_TXDEEMPH0_MASK	\
-	(0x1 << HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET)
-
-#define HPIPE_LANE_CONFIG1_REG			0x604
-#define HPIPE_LANE_CONFIG1_MAX_PLL_OFFSET	9
-#define HPIPE_LANE_CONFIG1_MAX_PLL_MASK		\
-	(0x1 << HPIPE_LANE_CONFIG1_MAX_PLL_OFFSET)
-#define HPIPE_LANE_CONFIG1_GEN2_PLL_OFFSET	10
-#define HPIPE_LANE_CONFIG1_GEN2_PLL_MASK	\
-	(0x1 << HPIPE_LANE_CONFIG1_GEN2_PLL_OFFSET)
-
-#define HPIPE_LANE_STATUS1_REG			0x60C
-#define HPIPE_LANE_STATUS1_PCLK_EN_OFFSET	0
-#define HPIPE_LANE_STATUS1_PCLK_EN_MASK		\
-	(0x1 << HPIPE_LANE_STATUS1_PCLK_EN_OFFSET)
-
-#define HPIPE_LANE_CFG4_REG                     0x620
-#define HPIPE_LANE_CFG4_DFE_CTRL_OFFSET		0
-#define HPIPE_LANE_CFG4_DFE_CTRL_MASK		\
-	(0x7 << HPIPE_LANE_CFG4_DFE_CTRL_OFFSET)
-#define HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET	3
-#define HPIPE_LANE_CFG4_DFE_EN_SEL_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET)
-#define HPIPE_LANE_CFG4_DFE_OVER_OFFSET		6
-#define HPIPE_LANE_CFG4_DFE_OVER_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_DFE_OVER_OFFSET)
-#define HPIPE_LANE_CFG4_SSC_CTRL_OFFSET		7
-#define HPIPE_LANE_CFG4_SSC_CTRL_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_SSC_CTRL_OFFSET)
-
-#define HPIPE_LANE_EQU_CONFIG_0_REG		0x69C
-#define HPIPE_CFG_PHY_RC_EP_OFFSET		12
-#define HPIPE_CFG_PHY_RC_EP_MASK		\
-	(0x1 << HPIPE_CFG_PHY_RC_EP_OFFSET)
-
-#define HPIPE_LANE_EQ_CFG1_REG			0x6a0
-#define HPIPE_CFG_UPDATE_POLARITY_OFFSET	12
-#define HPIPE_CFG_UPDATE_POLARITY_MASK		\
-	(0x1 << HPIPE_CFG_UPDATE_POLARITY_OFFSET)
-
-#define HPIPE_LANE_EQ_REMOTE_SETTING_REG	0x6f8
-#define HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET	0
-#define HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_MASK	\
-	(0x1 << HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET)
-#define HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET	1
-#define HPIPE_LANE_CFG_FOM_ONLY_MODE_MASK	\
-	(0x1 << HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET)
-#define HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET	2
-#define HPIPE_LANE_CFG_FOM_PRESET_VECTOR_MASK	\
-	(0xf << HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET)
-
-#define HPIPE_RST_CLK_CTRL_REG			0x704
-#define HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET	0
-#define HPIPE_RST_CLK_CTRL_PIPE_RST_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET)
-#define HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET	2
-#define HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET)
-#define HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET	3
-#define HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET)
-#define HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET	9
-#define HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET)
-
-#define HPIPE_TST_MODE_CTRL_REG			0x708
-#define HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET	2
-#define HPIPE_TST_MODE_CTRL_MODE_MARGIN_MASK	\
-	(0x1 << HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET)
-
-#define HPIPE_CLK_SRC_LO_REG			0x70c
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET 1
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_MASK	\
-	(0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET)
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET 2
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_MASK \
-	(0x3 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET)
-#define HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET	5
-#define HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK	\
-	(0x7 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET)
-
-#define HPIPE_CLK_SRC_HI_REG			0x710
-#define HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET	0
-#define HPIPE_CLK_SRC_HI_LANE_STRT_MASK		\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET)
-#define HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET	1
-#define HPIPE_CLK_SRC_HI_LANE_BREAK_MASK	\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET)
-#define HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET	2
-#define HPIPE_CLK_SRC_HI_LANE_MASTER_MASK	\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET)
-#define HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET	7
-#define HPIPE_CLK_SRC_HI_MODE_PIPE_MASK		\
-	(0x1 << HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET)
-
-#define HPIPE_GLOBAL_MISC_CTRL                  0x718
-#define HPIPE_GLOBAL_PM_CTRL                    0x740
-#define HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET	0
-#define HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK	\
-	(0xFF << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET)
-
-#endif /* _COMPHY_HPIPE_H_ */
-
diff --git a/drivers/phy/marvell/comphy_mux.c b/drivers/phy/marvell/comphy_mux.c
deleted file mode 100644
index c67ba99762..0000000000
--- a/drivers/phy/marvell/comphy_mux.c
+++ /dev/null
@@ -1,135 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- */
-
-#include <common.h>
-#include <asm/io.h>
-
-#include "comphy_core.h"
-#include "comphy_hpipe.h"
-
-/*
- * comphy_mux_check_config()
- * description: this function passes over the COMPHY lanes and check if the type
- *              is valid for specific lane. If the type is not valid,
- *              the function update the struct and set the type of the lane as
- *              PHY_TYPE_UNCONNECTED
- */
-static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes)
-{
-	struct comphy_mux_options *mux_opt;
-	int lane, opt, valid;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		/* Don't check ignored COMPHYs */
-		if (comphy_map_data->type == PHY_TYPE_IGNORE)
-			continue;
-
-		mux_opt = mux_data->mux_values;
-		for (opt = 0, valid = 0; opt < mux_data->max_lane_values;
-		     opt++, mux_opt++) {
-			if (mux_opt->type == comphy_map_data->type) {
-				valid = 1;
-				break;
-			}
-		}
-		if (valid == 0) {
-			debug("lane number %d, had invalid type %d\n",
-			      lane, comphy_map_data->type);
-			debug("set lane %d as type %d\n", lane,
-			      PHY_TYPE_UNCONNECTED);
-			comphy_map_data->type = PHY_TYPE_UNCONNECTED;
-		} else {
-			debug("lane number %d, has type %d\n",
-			      lane, comphy_map_data->type);
-		}
-	}
-
-	debug_exit();
-}
-
-static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data,
-				    u32 type, int lane)
-{
-	struct comphy_mux_options *mux_opt;
-	int opt;
-	u32 value = 0;
-
-	debug_enter();
-
-	mux_opt = mux_data->mux_values;
-	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, mux_opt++) {
-		if (mux_opt->type == type) {
-			value = mux_opt->mux_value;
-			break;
-		}
-	}
-
-	debug_exit();
-
-	return value;
-}
-
-static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
-				 struct comphy_map *comphy_map_data,
-				 int comphy_max_lanes,
-				 void __iomem *selector_base,
-				 const fdt32_t *mux_lane_order, u32 bitcount)
-{
-	u32 lane, value, offset, mask;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		if (comphy_map_data->type == PHY_TYPE_IGNORE)
-			continue;
-
-		/*
-		 * if the order of nodes in selector base register is
-		 * nontrivial, use mapping from mux_lane_order
-		 */
-		if (mux_lane_order)
-			offset = fdt32_to_cpu(mux_lane_order[lane]) * bitcount;
-		else
-			offset = lane * bitcount;
-
-		mask = (((1 << bitcount) - 1) << offset);
-		value = (comphy_mux_get_mux_value(mux_data,
-						  comphy_map_data->type,
-						  lane) << offset);
-		reg_set(selector_base, value, mask);
-	}
-
-	debug_exit();
-}
-
-void comphy_mux_init(struct chip_serdes_phy_config *chip_cfg,
-		     struct comphy_map *comphy_map_data,
-		     void __iomem *selector_base)
-{
-	struct comphy_mux_data *mux_data;
-	const fdt32_t *mux_lane_order;
-	u32 mux_bitcount;
-	u32 comphy_max_lanes;
-
-	debug_enter();
-
-	comphy_max_lanes = chip_cfg->comphy_lanes_count;
-	mux_data = chip_cfg->mux_data;
-	mux_lane_order = chip_cfg->comphy_mux_lane_order;
-	mux_bitcount = chip_cfg->comphy_mux_bitcount;
-
-	/* check if the configuration is valid */
-	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
-	/* Init COMPHY selectors */
-	comphy_mux_reg_write(mux_data, comphy_map_data, comphy_max_lanes,
-			     selector_base, mux_lane_order, mux_bitcount);
-
-	debug_exit();
-}
diff --git a/drivers/phy/marvell/utmi_phy.h b/drivers/phy/marvell/utmi_phy.h
index 682a3acc40..2ca406f1e6 100644
--- a/drivers/phy/marvell/utmi_phy.h
+++ b/drivers/phy/marvell/utmi_phy.h
@@ -20,6 +20,7 @@
 #define UTMI_PHY_CFG_PU_MASK			\
 	(0x1 << UTMI_PHY_CFG_PU_OFFSET)
 
+/* PLL and Calibration register are common for both UTMI ports */
 #define UTMI_PLL_CTRL_REG			0x0
 #define UTMI_PLL_CTRL_REFDIV_OFFSET		0
 #define UTMI_PLL_CTRL_REFDIV_MASK		\
@@ -38,6 +39,12 @@
 #define UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET	8
 #define UTMI_CALIB_CTRL_IMPCAL_VTH_MASK		\
 	(0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET)
+#define UTMI_CALIB_CTRL_IMPCAL_START_OFFSET	13
+#define UTMI_CALIB_CTRL_IMPCAL_START_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_IMPCAL_START_OFFSET)
+#define UTMI_CALIB_CTRL_PLLCAL_START_OFFSET	22
+#define UTMI_CALIB_CTRL_PLLCAL_START_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_PLLCAL_START_OFFSET)
 #define UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET	23
 #define UTMI_CALIB_CTRL_IMPCAL_DONE_MASK	\
 	(0x1 << UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET)
@@ -45,15 +52,25 @@
 #define UTMI_CALIB_CTRL_PLLCAL_DONE_MASK	\
 	(0x1 << UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET)
 
-#define UTMI_TX_CH_CTRL_REG			0xC
+/* NOTE: all bellow are register used per UTMI port, which base address is
+ * 058x00C, so bellow offset may be misleading. E.g UTMI_TX_CH_CTRL_REG refers
+ * to 0x58x00c, UTMI_RX_CH_CTRL0_REG refers to 0x58x014 etc.
+ */
+#define UTMI_TX_CH_CTRL_REG			0x0
 #define UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET	12
 #define UTMI_TX_CH_CTRL_DRV_EN_LS_MASK		\
 	(0xf << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET)
 #define UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET	16
 #define UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK		\
 	(0xf << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET)
+#define UTMI_TX_CH_CTRL_AMP_OFFSET		20
+#define UTMI_TX_CH_CTRL_AMP_MASK		\
+	(0x7 << UTMI_TX_CH_CTRL_AMP_OFFSET)
 
-#define UTMI_RX_CH_CTRL0_REG			0x14
+#define UTMI_RX_CH_CTRL0_REG			0x8
+#define UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET	8
+#define UTMI_RX_CH_CTRL0_DISCON_THRESH_MASK	\
+	(0x3 << UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET)
 #define UTMI_RX_CH_CTRL0_SQ_DET_OFFSET		15
 #define UTMI_RX_CH_CTRL0_SQ_DET_MASK		\
 	(0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET)
@@ -61,15 +78,15 @@
 #define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK	\
 	(0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET)
 
-#define UTMI_RX_CH_CTRL1_REG			0x18
+#define UTMI_RX_CH_CTRL1_REG			0xc
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET	0
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK	\
-	(0x3 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
+	(0x7 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET	3
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK	\
 	(0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET)
 
-#define UTMI_CTRL_STATUS0_REG			0x24
+#define UTMI_CTRL_STATUS0_REG			0x18
 #define UTMI_CTRL_STATUS0_SUSPENDM_OFFSET	22
 #define UTMI_CTRL_STATUS0_SUSPENDM_MASK		\
 	(0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET)
@@ -77,7 +94,7 @@
 #define UTMI_CTRL_STATUS0_TEST_SEL_MASK		\
 	(0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET)
 
-#define UTMI_CHGDTC_CTRL_REG			0x38
+#define UTMI_CHGDTC_CTRL_REG			0x2c
 #define UTMI_CHGDTC_CTRL_VDAT_OFFSET		8
 #define UTMI_CHGDTC_CTRL_VDAT_MASK		\
 	(0x3 << UTMI_CHGDTC_CTRL_VDAT_OFFSET)
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
index f197f4a142..42350ac16b 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
@@ -168,8 +168,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
 	PIN_GRP_GPIO("onewire", 4, 1, BIT(16), "onewire"),
 	PIN_GRP_GPIO("uart1", 25, 2, BIT(17), "uart"),
 	PIN_GRP_GPIO("spi_quad", 15, 2, BIT(18), "spi"),
-	PIN_GRP_EXTRA("uart2", 9, 2, BIT(1) | BIT(13) | BIT(14) | BIT(19),
-		      BIT(1) | BIT(13) | BIT(14), BIT(1) | BIT(19),
+	PIN_GRP_EXTRA("uart2", 9, 2, BIT(1) | BIT(19),
+		      BIT(1), BIT(1) | BIT(19),
 		      18, 2, "gpio", "uart"),
 	PIN_GRP_GPIO("led0_od", 11, 1, BIT(20), "led"),
 	PIN_GRP_GPIO("led1_od", 12, 1, BIT(21), "led"),
diff --git a/drivers/pinctrl/mvebu/pinctrl-mvebu.c b/drivers/pinctrl/mvebu/pinctrl-mvebu.c
index 0b9c9e1d6a..e8423d550b 100644
--- a/drivers/pinctrl/mvebu/pinctrl-mvebu.c
+++ b/drivers/pinctrl/mvebu/pinctrl-mvebu.c
@@ -49,7 +49,11 @@ void mvebu_pinctl_emmc_set_mux(struct udevice *dev, u32 pin, u32 func)
 				     EMMC_PHY_CTRL_SDPHY_EN);
 		}
 	} else if (!fdt_node_check_compatible(blob, node,
-					"marvell,armada-8k-cpm-pinctrl")) {
+					"marvell,armada-8k-cpm-pinctrl") ||
+		   !fdt_node_check_compatible(blob, node,
+					"marvell,armada-7k-pinctrl") ||
+		   !fdt_node_check_compatible(blob, node,
+					"marvell,cp115-standalone-pinctrl")) {
 		if ((pin == CP110_EMMC_CLK_PIN_ID) &&
 		    (func == CP110_EMMC_CLK_FUNC)) {
 			clrbits_le32(priv->base_reg + CP_EMMC_PHY_CTRL_REG,
@@ -220,6 +224,7 @@ static const struct udevice_id mvebu_pinctrl_ids[] = {
 	{ .compatible = "marvell,armada-7k-pinctrl" },
 	{ .compatible = "marvell,armada-8k-cpm-pinctrl" },
 	{ .compatible = "marvell,armada-8k-cps-pinctrl" },
+	{ .compatible = "marvell,cp115-standalone-pinctrl" },
 	{ }
 };
 
diff --git a/drivers/power/regulator/regulator-uclass.c b/drivers/power/regulator/regulator-uclass.c
index 76be95bcd1..21bb83b645 100644
--- a/drivers/power/regulator/regulator-uclass.c
+++ b/drivers/power/regulator/regulator-uclass.c
@@ -252,6 +252,17 @@ int regulator_autoset(struct udevice *dev)
 	return ret;
 }
 
+int regulator_unset(struct udevice *dev)
+{
+	struct dm_regulator_uclass_platdata *uc_pdata;
+
+	uc_pdata = dev_get_uclass_platdata(dev);
+	if (uc_pdata->force_off)
+		return regulator_set_enable(dev, false);
+
+	return -EMEDIUMTYPE;
+}
+
 static void regulator_show(struct udevice *dev, int ret)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
@@ -381,6 +392,7 @@ static int regulator_pre_probe(struct udevice *dev)
 	uc_pdata->boot_on = dev_read_bool(dev, "regulator-boot-on");
 	uc_pdata->ramp_delay = dev_read_u32_default(dev, "regulator-ramp-delay",
 						    0);
+	uc_pdata->force_off = dev_read_bool(dev, "regulator-force-boot-off");
 
 	/* Those values are optional (-ENODATA if unset) */
 	if ((uc_pdata->min_uV != -ENODATA) &&
@@ -423,6 +435,32 @@ int regulators_enable_boot_on(bool verbose)
 	return ret;
 }
 
+int regulators_enable_boot_off(bool verbose)
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+
+	ret = uclass_get(UCLASS_REGULATOR, &uc);
+	if (ret)
+		return ret;
+	for (uclass_first_device(UCLASS_REGULATOR, &dev);
+	     dev;
+	     uclass_next_device(&dev)) {
+		ret = regulator_unset(dev);
+		if (ret == -EMEDIUMTYPE) {
+			ret = 0;
+			continue;
+		}
+		if (verbose)
+			regulator_show(dev, ret);
+		if (ret == -ENOSYS)
+			ret = 0;
+	}
+
+	return ret;
+}
+
 UCLASS_DRIVER(regulator) = {
 	.id		= UCLASS_REGULATOR,
 	.name		= "regulator",
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 8778cc7b26..0df9689bfe 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -37,6 +37,15 @@ config RTC_ENABLE_32KHZ_OUTPUT
 	   Some real-time clocks support the output of 32kHz square waves (such as ds3231),
 	   the config symbol choose Real Time Clock device 32Khz output feature.
 
+config MARVELL_RTC
+	bool "MARVELL RTC support"
+	depends on DM_RTC
+	help
+	  Choose this option to add
+	  support for Marvell's
+	  RTC driver, which is used
+	  by Armada 7K, 8K, 3900 and OcteonTX2 CN913x.
+
 config RTC_PCF2127
 	bool "Enable PCF2127 driver"
 	depends on DM_RTC
@@ -54,6 +63,13 @@ config RTC_DS1307
 	  Support for Dallas Semiconductor (now Maxim) DS1307 and DS1338/9 and
 	  compatible Real Time Clock devices.
 
+config RTC_DS1337
+	bool "Enable DS1337 driver"
+	depends on DM_RTC
+	help
+	  Support for Dallas Semiconductor (now Maxim) DS1337/39 and DS1388 and
+	  compatible Real Time Clock devices.
+
 config RTC_ISL1208
 	bool "Enable ISL1208 driver"
 	depends on DM_RTC
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index f97a669982..d56df548a4 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_$(SPL_TPL_)DM_RTC) += rtc-uclass.o
 obj-$(CONFIG_RTC_AT91SAM9_RTT) += at91sam9_rtt.o
 obj-y += date.o
 obj-y += rtc-lib.o
+obj-$(CONFIG_MARVELL_RTC) += marvell_rtc.o
 obj-$(CONFIG_RTC_DAVINCI) += davinci.o
 obj-$(CONFIG_RTC_DS1302) += ds1302.o
 obj-$(CONFIG_RTC_DS1306) += ds1306.o
diff --git a/drivers/rtc/ds1337.c b/drivers/rtc/ds1337.c
index 9b31048e97..e91bdce6f4 100644
--- a/drivers/rtc/ds1337.c
+++ b/drivers/rtc/ds1337.c
@@ -1,8 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
  * (C) Copyright 2001-2008
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  * Keith Outwater, keith_outwater@mvis.com`
+ *
  */
 
 /*
@@ -14,6 +17,10 @@
 #include <command.h>
 #include <rtc.h>
 #include <i2c.h>
+#include <dm.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
 
 /*
  * RTC register addresses
@@ -59,6 +66,168 @@
 #define RTC_STAT_BIT_A2F	0x2	/* Alarm 2 flag			*/
 #define RTC_STAT_BIT_OSF	0x80	/* Oscillator stop flag		*/
 
+#ifdef CONFIG_DM_RTC
+
+/*
+ * Helper functions
+ */
+static uchar dm_rtc_read(struct udevice *dev, uchar reg)
+{
+	return dm_i2c_reg_read(dev, reg);
+}
+
+static void dm_rtc_write(struct udevice *dev, uchar reg, uchar val)
+{
+	dm_i2c_reg_write(dev, reg, val);
+}
+
+static int ds1337_rtc_get(struct udevice *dev, struct rtc_time *tmp)
+{
+	int rel = 0;
+	uchar sec, min, hour, mday, wday, mon_cent, year, control, status;
+
+	control = dm_rtc_read(dev, RTC_CTL_REG_ADDR);
+	status = dm_rtc_read(dev, RTC_STAT_REG_ADDR);
+	sec = dm_rtc_read(dev, RTC_SEC_REG_ADDR);
+	min = dm_rtc_read(dev, RTC_MIN_REG_ADDR);
+	hour = dm_rtc_read(dev, RTC_HR_REG_ADDR);
+	wday = dm_rtc_read(dev, RTC_DAY_REG_ADDR);
+	mday = dm_rtc_read(dev, RTC_DATE_REG_ADDR);
+	mon_cent = dm_rtc_read(dev, RTC_MON_REG_ADDR);
+	year = dm_rtc_read(dev, RTC_YR_REG_ADDR);
+
+	/* No century bit, assume year 2000 */
+#ifdef CONFIG_RTC_DS1388
+	mon_cent |= 0x80;
+#endif
+
+	debug("Get RTC year: %02x mon/cent: %02x mday: %02x wday: %02x",
+	      year, mon_cent, mday, wday);
+	debug(" hr: %02x min: %02x sec: %02x control: %02x status: %02x\n",
+	      hour, min, sec, control, status);
+
+	if (status & RTC_STAT_BIT_OSF) {
+		printf("### Warning: RTC oscillator has stopped\n");
+		/* clear the OSF flag */
+		dm_rtc_write(dev, RTC_STAT_REG_ADDR,
+			     dm_rtc_read(dev, RTC_STAT_REG_ADDR) &
+			     ~RTC_STAT_BIT_OSF);
+		rel = -1;
+	}
+
+	tmp->tm_sec  = bcd2bin(sec & 0x7F);
+	tmp->tm_min  = bcd2bin(min & 0x7F);
+	tmp->tm_hour = bcd2bin(hour & 0x3F);
+	tmp->tm_mday = bcd2bin(mday & 0x3F);
+	tmp->tm_mon  = bcd2bin(mon_cent & 0x1F);
+	tmp->tm_year = bcd2bin(year) + ((mon_cent & 0x80) ? 2100 : 2000);
+	tmp->tm_wday = bcd2bin((wday - 1) & 0x07);
+	tmp->tm_yday = 0;
+	tmp->tm_isdst = 0;
+
+	debug("Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+	      tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+	      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	return rel;
+}
+
+static int ds1337_rtc_set(struct udevice *dev, const struct rtc_time *tmp)
+{
+	uchar century;
+
+	debug("Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+	      tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+	      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	if (tmp->tm_year < 2000 || tmp->tm_year > 2199)
+		return -1;
+
+	dm_rtc_write(dev, RTC_YR_REG_ADDR, bin2bcd(tmp->tm_year % 100));
+
+	/* Assume 20YY as base, to fix mismatch with linux */
+	century = (tmp->tm_year >= 2100) ? 0x80 : 0;
+	dm_rtc_write(dev, RTC_MON_REG_ADDR, bin2bcd(tmp->tm_mon) | century);
+
+	dm_rtc_write(dev, RTC_DAY_REG_ADDR, bin2bcd(tmp->tm_wday + 1));
+	dm_rtc_write(dev, RTC_DATE_REG_ADDR, bin2bcd(tmp->tm_mday));
+	dm_rtc_write(dev, RTC_HR_REG_ADDR, bin2bcd(tmp->tm_hour));
+	dm_rtc_write(dev, RTC_MIN_REG_ADDR, bin2bcd(tmp->tm_min));
+	dm_rtc_write(dev, RTC_SEC_REG_ADDR, bin2bcd(tmp->tm_sec));
+
+	return 0;
+}
+
+/*
+ * Reset the RTC.  We also enable the oscillator output on the
+ * SQW/INTB* pin and program it for 32,768 Hz output. Note that
+ * according to the datasheet, turning on the square wave output
+ * increases the current drain on the backup battery from about
+ * 600 nA to 2uA. Define CONFIG_RTC_DS1337_NOOSC if you wish to turn
+ * off the OSC output.
+ */
+static int ds1337_rtc_reset(struct udevice *dev)
+{
+	uchar resetval = RTC_CTL_BIT_RS1 | RTC_CTL_BIT_RS2; /* Default DS1337 */
+
+#ifdef CONFIG_RTC_DS1337_NOOSC
+	resetval |= RTC_CTL_BIT_INTCN;
+#elif defined CONFIG_RTC_DS1388
+	resetval = 0x0;
+#endif
+	dm_rtc_write(dev, RTC_CTL_REG_ADDR, resetval);
+
+#ifdef CONFIG_DS1339_TCR_VAL
+	dm_rtc_write(dev, RTC_TC_REG_ADDR, CONFIG_SYS_DS1339_TCR_VAL);
+#endif
+#ifdef CONFIG_DS1388_TCR_VAL
+	dm_rtc_write(dev, RTC_TC_REG_ADDR, CONFIG_SYS_DS1388_TCR_VAL);
+#endif
+	return 0;
+}
+
+static int ds1337_rtc_read8(struct udevice *dev, unsigned int reg)
+{
+	return dm_rtc_read(dev, reg);
+}
+
+static int ds1337_rtc_write8(struct udevice *dev, unsigned int reg, int val)
+{
+	dm_rtc_write(dev, reg, val);
+
+	return 0;
+}
+
+static int ds1337_rtc_probe(struct udevice *dev)
+{
+	ds1337_rtc_reset(dev);
+
+	return 0;
+}
+
+static const struct rtc_ops ds1337_rtc_ops = {
+	.get = ds1337_rtc_get,
+	.set = ds1337_rtc_set,
+	.reset = ds1337_rtc_reset,
+	.read8 = ds1337_rtc_read8,
+	.write8 = ds1337_rtc_write8,
+};
+
+static const struct udevice_id ds1337_rtc_ids[] = {
+	{ .compatible = "dallas,ds1337" },
+	{ .compatible = "isil,isl12057" },
+	{ }
+};
+
+U_BOOT_DRIVER(ds1337_rtc) = {
+	.name = "rtc-ds1337",
+	.id = UCLASS_RTC,
+	.of_match = ds1337_rtc_ids,
+	.probe = ds1337_rtc_probe,
+	.ops = &ds1337_rtc_ops,
+};
+
+#else /* !CONFIG_DM_RTC */
 
 static uchar rtc_read (uchar reg);
 static void rtc_write (uchar reg, uchar val);
@@ -188,3 +357,5 @@ static void rtc_write (uchar reg, uchar val)
 {
 	i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, reg, val);
 }
+
+#endif /* !CONFIG_DM_RTC */
diff --git a/drivers/rtc/marvell_rtc.c b/drivers/rtc/marvell_rtc.c
new file mode 100644
index 0000000000..a4bb3762b0
--- /dev/null
+++ b/drivers/rtc/marvell_rtc.c
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <rtc.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include "marvell_rtc.h"
+
+static int marvell_rtc_get(struct udevice *dev, struct rtc_time *time)
+{
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	rtc_to_tm(RTC_READ_REG(rtc_base, RTC_TIME_REG_OFFS), time);
+
+	return 0;
+}
+
+static int marvell_rtc_set(struct udevice *dev, const struct rtc_time *time)
+{
+	unsigned long tm;
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	tm = rtc_mktime(time);
+
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(tm, rtc_base, RTC_TIME_REG_OFFS);
+
+	/* Give registers time to stabilize */
+	mdelay(100);
+
+	return 0;
+}
+
+static int marvell_rtc_reset(struct udevice *dev)
+{
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Reset Test register */
+	RTC_WRITE_REG(0, rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+	/* Oscillator startup time */
+	mdelay(500);
+
+	/* Reset time register */
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(0, rtc_base, RTC_TIME_REG_OFFS);
+	udelay(62);
+
+	/* Reset Status register */
+	RTC_WRITE_REG((RTC_SZ_STATUS_ALARM1_MASK | RTC_SZ_STATUS_ALARM2_MASK),
+		      rtc_base, RTC_STATUS_REG_OFFS);
+	udelay(62);
+
+	/* Turn off Int1 and Int2 sources & clear the Alarm count */
+	RTC_WRITE_REG(0, rtc_base, RTC_IRQ_1_CONFIG_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_IRQ_2_CONFIG_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_ALARM_1_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_ALARM_2_REG_OFFS);
+
+	/* Setup nominal register access timing */
+	RTC_WRITE_REG(RTC_NOMINAL_TIMING, rtc_base, RTC_CLOCK_CORR_REG_OFFS);
+
+	/* Reset time register */
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(0, rtc_base, RTC_TIME_REG_OFFS);
+	udelay(10);
+
+	/* Reset Status register */
+	RTC_WRITE_REG((RTC_SZ_STATUS_ALARM1_MASK | RTC_SZ_STATUS_ALARM2_MASK),
+		      rtc_base, RTC_STATUS_REG_OFFS);
+	udelay(50);
+
+	return 0;
+}
+
+void marvell_rtc_errata(struct udevice *dev)
+{
+	unsigned long reg;
+
+	/* Get the rtc register base address */
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base;
+
+	rtc_cfg->rtc_base = (void *)devfdt_get_addr_index(dev, 0);
+	rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Update RTC-MBUS bridge timing parameters */
+	/* Functional Errata Ref #:
+	 * FE-3124064 - WA for failing time read attempts.
+	 * Description:
+	 *	The device supports CPU write and read access
+	 *	to the RTC Time register.
+	 *	However, due to this erratum,
+	 *	Write to RTC TIME register may fail.
+	 *	Read from RTC TIME register may fail.
+	 * Workaround:
+	 * 1. Configure the RTC Mbus Bridge Timing Control register
+	 *    (offset 0x284080 and 0x284084)
+	 *	- Write RTC WRCLK Period 0x3FF (default value is 0xFA)
+	 *	- Write RTC WRCLK setup to 0x29 (default value is 0x53)
+	 *	- Write RTC Read Output Delay to 0x3F (default value is 0x10)
+	 *	- Write RTC WRCLK High Time to 0x53 (default value)
+	 *	- Mbus - Read All Byte Enable to 0x1 (default value)
+	 * 2. Configure the RTC Test Configuration Register (offset 0x28401C)
+	 *    bit3 to '1' (Reserved, Marvell internal)
+	 *
+	 * RTC Time register write operation:
+	 *	- Issue two dummy writes of 0x0 to the RTC Status register
+	 *	  (offset 0x284000).
+	 *	- Write the time to the RTC Time register (offset 0x28400C).
+	 */
+	reg = RTC_READ_REG(rtc_base, MV_RTC0_SOC_OFFSET);
+	reg &= ~RTC_WRCLK_PERIOD_MASK;
+	reg |= 0x3FF << RTC_WRCLK_PERIOD_OFFS;
+	reg &= ~RTC_WRCLK_SETUP_MASK;
+	reg |= 0x29 << RTC_WRCLK_SETUP_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC0_SOC_OFFSET);
+
+	reg = RTC_READ_REG(rtc_base, MV_RTC1_SOC_OFFSET);
+	reg &= ~RTC_READ_OUTPUT_DELAY_MASK;
+	reg |= 0x3F << RTC_READ_OUTPUT_DELAY_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC1_SOC_OFFSET);
+
+	reg = RTC_READ_REG(rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+	reg |= 0x8;
+	RTC_WRITE_REG(reg, rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+}
+
+static int marvell_rtc_probe(struct udevice *dev)
+{
+#ifdef ERRATA_FE_3124064
+	marvell_rtc_errata(dev);
+#else
+	/* Get the rtc register base address */
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base;
+	unsigned long reg;
+
+	rtc_cfg->rtc_base = (void *)devfdt_get_addr_index(dev, 0);
+	rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Update RTC-MBUS bridge timing parameters */
+	reg = RTC_READ_REG(rtc_base, MV_RTC1_SOC_OFFSET);
+	reg &= ~RTC_READ_OUTPUT_DELAY_MASK;
+	reg |= 0x1F << RTC_READ_OUTPUT_DELAY_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC1_SOC_OFFSET);
+#endif
+
+	return 0;
+}
+
+static const struct rtc_ops marvell_rtc_ops = {
+	.get = marvell_rtc_get,
+	.set = marvell_rtc_set,
+	.reset = marvell_rtc_reset,
+};
+
+static const struct udevice_id marvell_rtc_ids[] = {
+	{ .compatible = "marvell,armada-8k-rtc" },
+	{ }
+};
+
+U_BOOT_DRIVER(marvell_rtc) = {
+	.name	= "marvell_rtc",
+	.id	= UCLASS_RTC,
+	.of_match = marvell_rtc_ids,
+	.ops	= &marvell_rtc_ops,
+	.probe = marvell_rtc_probe,
+	.priv_auto_alloc_size = sizeof(struct rtc_unit_config),
+};
diff --git a/drivers/rtc/marvell_rtc.h b/drivers/rtc/marvell_rtc.h
new file mode 100644
index 0000000000..cba639a504
--- /dev/null
+++ b/drivers/rtc/marvell_rtc.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MARVELL_RTC_H
+#define _MARVELL_RTC_H
+
+/* The RTC DRS revision 1.2 indicates that firmware should wait
+ * 5us after every register write to the RTC hard macro,
+ * so that the required update can occur without holding off the system bus
+ */
+#define RTC_READ_REG(rtc_base, reg)		readl((rtc_base) + (reg))
+#define RTC_WRITE_REG(val, rtc_base, reg)		\
+	{ writel((val), (rtc_base) + (reg)); udelay(5); }
+
+#define RTC_NOMINAL_TIMING		0x2000
+
+#define RTC_STATUS_REG_OFFS		0x0
+#define RTC_IRQ_1_CONFIG_REG_OFFS	0x4
+#define RTC_IRQ_2_CONFIG_REG_OFFS	0x8
+#define RTC_TIME_REG_OFFS		0xC
+#define RTC_ALARM_1_REG_OFFS		0x10
+#define RTC_ALARM_2_REG_OFFS		0x14
+#define RTC_CLOCK_CORR_REG_OFFS		0x18
+#define RTC_TEST_CONFIG_REG_OFFS	0x1C
+#define MV_RTC0_SOC_OFFSET		0x80
+#define MV_RTC1_SOC_OFFSET		0x84
+
+#define RTC_WRCLK_PERIOD_OFFS		0
+#define RTC_WRCLK_PERIOD_MASK		(0xFFFF << RTC_WRCLK_PERIOD_OFFS)
+#define RTC_WRCLK_SETUP_OFFS		16
+#define RTC_WRCLK_SETUP_MASK		(0xFFFF << RTC_WRCLK_SETUP_OFFS)
+
+#define RTC_READ_OUTPUT_DELAY_OFFS	0
+#define RTC_READ_OUTPUT_DELAY_MASK	(0xFFFF << RTC_READ_OUTPUT_DELAY_OFFS)
+#define RTC_WRCLK_CLOCK_HIGH_OFFS	16
+#define RTC_WRCLK_CLOCK_HIGH_MASK	(0xFFFF << RTC_WRCLK_CLOCK_HIGH_OFFS)
+
+#define RTC_SZ_STATUS_ALARM1_MASK		0x1
+#define RTC_SZ_STATUS_ALARM2_MASK		0x2
+#define RTC_SZ_TIMING_RESERVED1_MASK		0xFFFF0000
+#define RTC_SZ_INTERRUPT1_INT1AE_MASK		0x1
+#define RTC_SZ_INTERRUPT1_RESERVED1_MASK	0xFFFFFFC0
+#define RTC_SZ_INTERRUPT2_INT2FE_MASK		0x2
+#define RTC_SZ_INTERRUPT2_RESERVED1_MASK	0xFFFFFFC0
+
+struct rtc_unit_config {
+	void __iomem *rtc_base;
+};
+
+#endif /* _MARVELL_RTC_H */
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index ae2d819ba9..56e8553675 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -710,6 +710,31 @@ config OWL_SERIAL
 	  serial port, say Y to this option. If unsure, say N.
 	  Single baudrate is supported in current implementation (115200).
 
+config OCTEONTX_SERIAL_BOOTCMD
+	bool "OcteonTX/OcteonTX2 PCI remote bootcmd input"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2 || ARCH_MVEBU)
+	depends on DM_SERIAL
+	select SYS_IS_IN_ENV
+	select CONSOLE_MUX
+	help
+	 This driver supports remote input over the PCIe bus from a host
+	 to U-Boot for entering commands.  It is utilized by the host
+	 commands cavm-remote-load and mrvl-remote-bootcmd.  This driver
+	 should be used in addition to the standard PL011 serial driver.
+
+config OCTEONTX_SERIAL_PCIE_CONSOLE
+	bool "OcteonTX/OcteonTX2 PCIE remote console"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	depends on DM_SERIAL
+	select SYS_STDIO_DEREGISTER
+	select SYS_CONSOLE_IS_IN_ENV
+	select CONSOLE_MUX
+	help
+	 This driver supports remote console over the PCIe bus when the
+	 OcteonTX is running in PCIe target mode.  The host program
+	 mrvl-remote-console can be used to connect to this console.  The
+	 console number will likely be 0 or 1.
+
 config PXA_SERIAL
 	bool "PXA serial port support"
 	help
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 06ee30697d..e7a9dce01f 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -63,6 +63,8 @@ obj-$(CONFIG_BCM283X_PL011_SERIAL) += serial_bcm283x_pl011.o
 obj-$(CONFIG_MSM_SERIAL) += serial_msm.o
 obj-$(CONFIG_MVEBU_A3700_UART) += serial_mvebu_a3700.o
 obj-$(CONFIG_MPC8XX_CONS) += serial_mpc8xx.o
+obj-$(CONFIG_OCTEONTX_SERIAL_PCIE_CONSOLE) += serial_octeontx_pcie_console.o
+obj-$(CONFIG_OCTEONTX_SERIAL_BOOTCMD) += serial_octeontx_bootcmd.o
 obj-$(CONFIG_NULLDEV_SERIAL) += serial_nulldev.o
 obj-$(CONFIG_OWL_SERIAL) += serial_owl.o
 obj-$(CONFIG_OMAP_SERIAL) += serial_omap.o
diff --git a/drivers/serial/serial_octeontx_bootcmd.c b/drivers/serial/serial_octeontx_bootcmd.c
new file mode 100644
index 0000000000..af94c1a7b6
--- /dev/null
+++ b/drivers/serial/serial_octeontx_bootcmd.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:     BSD-3-Clause
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <serial.h>
+#include <linux/compiler.h>
+#include <watchdog.h>
+#include <stdio_dev.h>
+#include <input.h>
+
+#undef CONFIG_LOGLEVEL
+#define CONFIG_LOGLEVEL 10
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OCTEONTX_BOOTCMD_BUF_SIZE		4096
+
+/** "BOOTCMD!" */
+#define OCTEONTX_PIC_IO_BUF_MAGIC		0x21444d43544f4f42
+#define OCTEONTX_PCI_IO_BUF_OWNER_INVALID	0
+#define OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX	1
+#define OCTEONTX_PCI_IO_BUF_OWNER_HOST		2
+
+#define DRIVER_NAME				"pci-bootcmd"
+
+#ifndef CONFIG_DM_SERIAL
+# error CONFIG_DM_SERIAL required
+#endif
+
+struct octeontx_pci_io_buf {
+	u64 magic;
+	u32 owner;
+	u32 len;
+	char data[0];
+};
+
+struct octeontx_bootcmd_platdata {
+	fdt_addr_t base;
+	fdt_size_t size;
+};
+
+struct octeontx_bootcmd_data {
+	struct octeontx_pci_io_buf *buf;
+	struct udevice *dev;
+	fdt_size_t size;	/** Size of buffer descriptor & data */
+	unsigned long data_size;/** Size of buffer data */
+	u32 copy_offset;
+	bool eol;
+	bool started;
+	bool unlocked;
+};
+
+static struct udevice *bootcmd_dev;
+
+static int octeontx_bootcmd_start(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(bc->dev);
+
+	if (bc->started) {
+		debug("%s: Already started\n", __func__);
+		return 0;
+	}
+
+	dev_dbg(bc->dev, "%s(%s)\n", __func__, dev->name);
+	/* Get address of IO buffer and check it */
+	bc->size = plat->size;
+	bc->data_size = bc->size - sizeof(struct octeontx_pci_io_buf);
+	bc->copy_offset = 0;
+	bc->eol = false;
+
+	buf->len = 0;
+	buf->data[0] = '\0';
+	buf->magic = OCTEONTX_PIC_IO_BUF_MAGIC;
+	if (bc->unlocked)
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_HOST;
+	else
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX;
+
+	bc->unlocked = true;
+	bc->started = true;
+	__iowmb();
+	flush_dcache_range((ulong)buf, (ulong)buf + bc->size);
+
+	return 0;
+}
+
+/**
+ * Return if there are any pending characters for input or output
+ * @param	dev	serial device
+ * @param	input	true to check for pending input
+ *
+ * @return	1 if pending data, 0 if no data available
+ */
+static int octeontx_bootcmd_pending(struct udevice *dev, bool input)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+
+	if (!bc->started) {
+		dev_dbg("%s: Error: not started\n", __func__);
+		return 0;
+	}
+
+	invalidate_dcache_range((ulong)buf,
+				(ulong)buf + bc->size);
+	__iormb();
+	if (input) {
+		if (bc->eol)
+			return 1;
+		if (buf->owner != OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX)
+			return 0;
+		if ((buf->len > bc->copy_offset) &&
+		    (buf->data[bc->copy_offset] != '\0'))
+			return 1;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int octeontx_bootcmd_putc(struct udevice *dev, const char ch)
+{
+	return 0;
+}
+
+static int octeontx_bootcmd_getc(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+	char c;
+	int end;
+
+	if (!bc->started) {
+		dev_dbg(dev, "%s: Error: start not called\n", __func__);
+		return -1;
+	}
+	/* There's no EOL for boot commands so we fake it. */
+	if (bc->eol) {
+		bc->eol = false;
+		return '\n';
+	}
+
+	while (!octeontx_bootcmd_pending(dev, true)) {
+		WATCHDOG_RESET();
+		udelay(0);
+	}
+
+	__iormb();
+	c = buf->data[bc->copy_offset];
+	buf->data[bc->copy_offset++] = '\0';
+
+	end = bc->data_size < CONFIG_SYS_CBSIZE ?
+			bc->data_size - 1 : CONFIG_SYS_CBSIZE - 1;
+	if ((bc->copy_offset >= end) || (buf->data[bc->copy_offset] == '\0')) {
+		bc->copy_offset = 0;
+		buf->len = 0;
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_HOST;
+		bc->eol = true;
+	}
+	__iowmb();
+	flush_dcache_range((ulong)buf, (ulong)buf + bc->size);
+
+	return c;
+}
+
+/**
+ * stdio driver getc
+ *
+ * @param	dev	stdio device
+ * @return	character returned from input
+ */
+static int bootcmd_stdio_getc(struct stdio_dev *dev)
+{
+	const struct dm_serial_ops *ops;
+
+	if (!bootcmd_dev) {
+		printf("%s(%s): Error: bootcmd_dev NULL!\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	ops = device_get_ops(bootcmd_dev);
+	return ops->getc(bootcmd_dev);
+}
+
+/**
+ * stdio driver testc
+ *
+ * @param	dev	stdio device
+ *
+ * @return	-1 on error, 1 if pending data, 0 if no data
+ */
+static int bootcmd_stdio_tstc(struct stdio_dev *dev)
+{
+	const struct dm_serial_ops *ops;
+
+	if (!bootcmd_dev) {
+		printf("%s(%s): Error: bootcmd_dev NULL!\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	ops = device_get_ops(bootcmd_dev);
+
+	return ops->pending(bootcmd_dev, true);
+}
+
+/**
+ * Probe function for bootcmd driver
+ *
+ * @param	dev	serial device
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_bootcmd_probe(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc;
+	struct octeontx_pci_io_buf *buf;
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(dev);
+	struct stdio_dev bdev;
+	int ret;
+
+	dev_dbg(dev, "%s(%s)\n", __func__, dev->name);
+	bc = dev_get_priv(dev);
+	buf = (struct octeontx_pci_io_buf *)(plat->base);
+	bc->buf = buf;
+	bc->dev = dev;
+	bc->unlocked = true;
+	dev_dbg(dev, "%s: bootcmd IO buffer: %p\n", __func__, buf);
+	ret = octeontx_bootcmd_start(dev);
+	if (!ret) {
+		bootcmd_dev = dev;
+		memset(&bdev, 0, sizeof(bdev));
+		snprintf(bdev.name, sizeof(bdev.name), DRIVER_NAME);
+		bdev.flags = DEV_FLAGS_INPUT;
+		bdev.getc = bootcmd_stdio_getc;
+		bdev.tstc = bootcmd_stdio_tstc;
+		pr_debug("%s: Registering stdin driver %s from device %s, bootcmd_dev: %p\n",
+			 __func__, bdev.name, bootcmd_dev->name, bootcmd_dev);
+		ret = stdio_register(&bdev);
+		if (ret)
+			printf("%s: Error registering stdin device %s\n",
+			       __func__, bdev.name);
+	}
+	return ret;
+}
+
+/**
+ * Extracts the platform data from the device tree
+ *
+ * @param	dev	serial device
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_bootcmd_ofdata_to_platdata(struct udevice *dev)
+{
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(dev);
+	fdt_addr_t addr;
+	fdt_size_t size;
+
+	addr = devfdt_get_addr_size_index(dev, 0, &size);
+	dev_dbg(dev, "%s(%s): base: 0x%llx, size: 0x%llx\n", __func__,
+		dev->name, addr, size);
+	if (addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	plat->base = addr;
+	plat->size = size;
+	return 0;
+}
+
+static const struct dm_serial_ops octeontx_bootcmd_ops = {
+	.putc = octeontx_bootcmd_putc,
+	.pending = octeontx_bootcmd_pending,
+	.getc = octeontx_bootcmd_getc,
+};
+
+static const struct udevice_id octeontx_bootcmd_serial_id[] = {
+	{ .compatible = "marvell,pci-bootcmd", },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_bootcmd) = {
+	.name	= DRIVER_NAME,
+	.id	= UCLASS_SERIAL,
+	.of_match = of_match_ptr(octeontx_bootcmd_serial_id),
+	.ofdata_to_platdata = of_match_ptr(octeontx_bootcmd_ofdata_to_platdata),
+	.platdata_auto_alloc_size = sizeof(struct octeontx_bootcmd_platdata),
+	.probe = octeontx_bootcmd_probe,
+	.ops = &octeontx_bootcmd_ops,
+	.priv_auto_alloc_size = sizeof(struct octeontx_bootcmd_data),
+	.flags = DM_FLAG_PRE_RELOC,
+};
diff --git a/drivers/serial/serial_octeontx_pcie_console.c b/drivers/serial/serial_octeontx_pcie_console.c
new file mode 100644
index 0000000000..4545c5c417
--- /dev/null
+++ b/drivers/serial/serial_octeontx_pcie_console.c
@@ -0,0 +1,1156 @@
+// SPDX-License-Identifier: GPL-2.0+    BSD-3-Clause
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/uclass.h>
+#include <dm/lists.h>
+#include <dm/uclass-internal.h>
+#include <linux/ioport.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <serial.h>
+#include <linux/compiler.h>
+#include <watchdog.h>
+#include <stdio_dev.h>
+#include <input.h>
+#include <asm/arch/lock.h>
+#include "serial_octeontx_pcie_console.h"
+#include <string.h>
+#include <iomux.h>
+
+/* This driver provides a PCIe console for OcteonTX processors.  It behaves
+ * similar to a serial console but it works by using shared memory between
+ * the host controller and the target (this being the target).
+ *
+ * Multiple consoles are supported and the consoles themselves are designed
+ * to be shared.  This design allows for U-Boot and ATF to share a console,
+ * for example, however this initial version does not support this sharing.
+ *
+ * Because the main data structure is shared between ATF, U-Boot and Linux
+ * as well as the host, atomic operations are required.  Locks are also
+ * required for the data structures if they are shared between "processes."
+ *
+ * The pcie lock uses Peterson's algorithm to lock between the host and
+ * the target.
+ *
+ * Memory write barriers are also used and are essential to maintain
+ * the integrity between the host and target.
+ */
+
+#ifndef CONFIG_DM_STDIO
+# error CONFIG_DM_STDIO is required!
+#endif
+
+#define DRIVER_NAME	"pci-console"
+
+struct driver octeontx_pcie_console_nexus;
+struct driver octeontx_pcie_console;
+
+#ifdef DEBUG
+bool in_debug;
+#endif
+
+/**
+ * Returns the number of available bytes in the buffer
+ *
+ * @param buffer_size	size of buffer
+ * @param wr_idx	write index
+ * @param rd_idx	read index
+ *
+ * @return number of bytes free
+ */
+static int octeontx_pcie_console_buffer_free_bytes(size_t buffer_size,
+						   u32 wr_idx, u32 rd_idx)
+{
+	if (rd_idx >= buffer_size || wr_idx >= buffer_size)
+		return -1;
+	return ((buffer_size - 1) - (wr_idx - rd_idx)) % buffer_size;
+}
+
+static int octeontx_pcie_console_buffer_avail_bytes(size_t buffer_size,
+						    u32 wr_idx, u32 rd_idx)
+{
+	if (rd_idx >= buffer_size || wr_idx >= buffer_size)
+		return -1;
+	return buffer_size - 1 -
+	       octeontx_pcie_console_buffer_free_bytes(buffer_size, wr_idx,
+						       rd_idx);
+}
+
+/**
+ * Check that the console version is acceptable.
+ */
+static bool octeontx_pcie_console_check_ver(u8 major, u8 minor)
+{
+	if (major > OCTEONTX_PCIE_CONSOLE_MAJOR)
+		return true;
+	if (major == OCTEONTX_PCIE_CONSOLE_MAJOR &&
+	    minor >= OCTEONTX_PCIE_CONSOLE_MINOR)
+		return true;
+	return false;
+}
+
+/**
+ * Clears bytes from the output buffer if the host console is not connected
+ *
+ * @param console		console to clear output from
+ * @param bytes_to_clear	Number of bytes to free up
+ *
+ * @return	0 for success, -1 on error.  If positive, it returns
+ *		the amount of available space that is less than
+ *		bytes_to_clear.
+ */
+int octeontx_pcie_console_output_trunc(struct octeontx_pcie_console *console,
+				       size_t bytes_to_clear)
+{
+	u64 old_val;
+	u64 new_val;
+	size_t bytes_avail;
+	const u32 out_buf_size = le32_to_cpu(console->output_buf_size);
+	u32 out_wr_idx = le32_to_cpu(console->output_write_index);
+	u32 out_rd_idx = le32_to_cpu(console->output_read_index);
+	int ret;
+
+	if (console->host_console_connected)
+		return -1;
+
+	old_val = cpu_to_le64((u64)out_rd_idx << 32);
+	bytes_avail = octeontx_pcie_console_buffer_avail_bytes(out_buf_size,
+							       out_wr_idx,
+							       out_rd_idx);
+	if (bytes_avail < 0)
+		return bytes_avail;
+	/* Not enough space */
+	if (bytes_to_clear > bytes_avail)
+		return bytes_avail;
+
+	out_rd_idx = (out_rd_idx + bytes_to_clear) % out_buf_size;
+	new_val = cpu_to_le64((u64)out_rd_idx << 32);
+
+	/*
+	 * We need to use an atomic operation here in case the host
+	 * console should connect.  This guarantees that if the host
+	 * connects that it will always see a consistent state.  Normally
+	 * only the host can modify the read pointer.  This assures us
+	 * that the read pointer will only be modified if the host
+	 * is disconnected.
+	 */
+	ret = __atomic_compare_exchange_n
+			((u64 *)(&console->host_console_connected),
+			 &old_val, new_val, 0,
+			 __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+
+	return ret ? 0 : -1;
+}
+
+int octeontx_pcie_console_write(struct octeontx_pcie_console *console,
+				const u8 *buffer, size_t bytes_to_write,
+				u32 flags)
+{
+	u8 *buf_ptr;
+	size_t bytes_available;
+	size_t bytes_written;
+	int ret;
+
+	buf_ptr = (u8 *)le64_to_cpu(console->output_base_addr);
+	bytes_written = 0;
+
+	while (bytes_to_write > 0) {
+		u32 out_size = le32_to_cpu(console->output_buf_size);
+		u32 out_wr_idx = le32_to_cpu(console->output_write_index);
+		u32 out_rd_idx = le32_to_cpu(console->output_read_index);
+
+		bytes_available =
+			octeontx_pcie_console_buffer_free_bytes(out_size,
+								out_wr_idx,
+								out_rd_idx);
+		if (bytes_available > 0) {
+			int write_size = min(bytes_available, bytes_to_write);
+
+			if (out_wr_idx + write_size >= out_size)
+				write_size = out_size - out_wr_idx;
+			memcpy(buf_ptr + out_wr_idx,
+			       buffer + bytes_written, write_size);
+			__iowmb();
+			console->output_write_index =  cpu_to_le32
+					((out_wr_idx + write_size) % out_size);
+			__iowmb();
+			bytes_to_write -= write_size;
+			bytes_written += write_size;
+		} else if (bytes_available == 0) {
+			/* Check to see if we should wait for room, or return
+			 * after partial write
+			 */
+			if (!(flags & OCTEONTX_PCIE_CONSOLE_FLAG_NONBLOCK))
+				continue;
+
+			ret = octeontx_pcie_console_output_trunc(console,
+							bytes_to_write);
+			if (ret < 0) {
+				mdelay(1);
+			} else if (ret > 0) {
+				octeontx_pcie_console_output_trunc(console,
+								   ret);
+				mdelay(1);
+			}
+		} else {
+			bytes_written = -1;
+			goto done;
+		}
+	}
+done:
+	return bytes_written;
+}
+
+static bool
+octeontx_pcie_console_input_empty(struct octeontx_pcie_console *console)
+{
+	/* endian conversion is not needed */
+	return console->input_read_index == console->input_write_index;
+}
+
+static int octeontx_pcie_console_readc(struct octeontx_pcie_console *console,
+				       u32 flags)
+{
+	const u32 in_buf_size = le32_to_cpu(console->input_buf_size);
+	u32 in_rd_idx = le32_to_cpu(console->input_read_index);
+	u8 *buf_ptr = (u8 *)le64_to_cpu(console->input_base_addr);
+	int ret;
+
+	assert(in_rd_idx < in_buf_size);
+
+	if (octeontx_pcie_console_input_empty(console)) {
+		debug("input empty: rd_idx: %#x\n", in_rd_idx);
+		return -1;
+	}
+
+	ret = buf_ptr[in_rd_idx++];
+	if (in_rd_idx >= in_buf_size)
+		in_rd_idx = 0;
+	console->input_read_index = cpu_to_le32(in_rd_idx);
+	assert(le32_to_cpu(console->input_write_index) < in_buf_size);
+	__iowmb();
+
+	return ret;
+}
+
+static int octeontx_pcie_console_read_avail
+				(const struct octeontx_pcie_console *console)
+{
+	int bytes_available;
+	u32 in_size = le32_to_cpu(console->input_buf_size);
+	u32 in_wr_idx = le32_to_cpu(console->input_write_index);
+	u32 in_rd_idx = le32_to_cpu(console->input_read_index);
+
+	bytes_available =
+		octeontx_pcie_console_buffer_avail_bytes(in_size, in_wr_idx,
+							 in_rd_idx);
+	assert(bytes_available < in_size);
+	return (bytes_available >= 0) ? bytes_available : 0;
+}
+
+static int octeontx_pcie_console_write_avail
+				(const struct octeontx_pcie_console *console)
+{
+	int bytes_available;
+	u32 out_size = le32_to_cpu(console->output_buf_size);
+	u32 out_wr_idx = le32_to_cpu(console->output_write_index);
+	u32 out_rd_idx = le32_to_cpu(console->output_read_index);
+
+	bytes_available =
+		octeontx_pcie_console_buffer_free_bytes(out_size, out_wr_idx,
+							out_rd_idx);
+	assert(bytes_available < out_size);
+	return (bytes_available >= 0) ? bytes_available : 0;
+}
+
+static int octeontx_pcie_console_clear_rx(struct octeontx_pcie_console *console)
+{
+	/* No need for endian conversion */
+	console->input_read_index = console->input_write_index;
+	__iowmb();
+	return 0;
+}
+
+static int octeontx_pcie_console_stdio_start(struct stdio_dev *dev)
+{
+	debug("%s(%s)\n", __func__, dev->name);
+	return 0;
+}
+
+/**
+ * Removes the console
+ *
+ * @param	dev	stdio device
+ *
+ * @return	0 for success, -EINVAL if the console descriptor is corrupt
+ */
+static int octeontx_pcie_console_stdio_stop(struct stdio_dev *dev)
+{
+	struct udevice *udev = dev->priv;
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(udev);
+	struct octeontx_pcie_console *console = priv->console;
+	struct octeontx_pcie_console_nexus *desc = priv->nexus;
+	u32 old_in_use;
+	u64 old_val;
+	u64 mask = (1 << priv->console_num);
+
+	debug("%s(%s)\n", __func__, dev->name);
+	if (!(le32_to_cpu(desc->exclusive) & 1 << priv->console_num))
+		if (le32_to_cpu(console->owner_id) !=
+					OCTEONTX_PCIE_CONSOLE_OWNER_UBOOT) {
+			dev_dbg(dev,
+				"Console %d is shared, not shutting it down\n",
+				priv->console_num);
+			return 0;
+		}
+
+	console->owner_id = cpu_to_le32(OCTEONTX_PCIE_CONSOLE_OWNER_UNUSED);
+
+	mask |= mask << 32;
+	debug("%s(%s): mask: %#llx\n", __func__, dev->name, mask);
+	/* Atomically remove ourselves from the nexus descriptor */
+#ifdef __LITTLE_ENDIAN
+	old_val = __atomic_fetch_nand((u64 *)&(desc->in_use), mask,
+				      __ATOMIC_SEQ_CST);
+#else
+	old_val = __atomic_fetch_nand((u64 *)&(desc->exclusive), mask,
+				      __ATOMIC_SEQ_CST);
+#endif
+	old_val = le64_to_cpu(old_val);
+	old_in_use = lower_32_bits(old_val);
+
+	if (!(old_in_use & mask)) {
+		dev_err(udev,
+			"Error: console %d not in descriptor usage mask %#x\n",
+			priv->console_num, old_in_use);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int octeontx_pcie_console_stdio_getc(struct stdio_dev *dev)
+{
+	struct udevice *udev = dev->priv;
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(udev);
+	struct octeontx_pcie_console *console = priv->console;
+
+	return octeontx_pcie_console_readc(console, 0);
+}
+
+static int octeontx_pcie_console_stdio_tstc(struct stdio_dev *dev)
+{
+	struct udevice *udev = dev->priv;
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(udev);
+	struct octeontx_pcie_console *console = priv->console;
+
+	return !octeontx_pcie_console_input_empty(console);
+}
+
+static void octeontx_pcie_console_stdio_putc(struct stdio_dev *dev,
+					     const char c)
+{
+	struct udevice *udev = dev->priv;
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(udev);
+	struct octeontx_pcie_console *console = priv->console;
+	u8 v = c;
+
+#ifdef DEBUG
+	if (in_debug)
+		return;
+#endif
+	octeontx_pcie_console_write(console, &v, 1,
+				    OCTEONTX_PCIE_CONSOLE_FLAG_NONBLOCK);
+}
+
+static void octeontx_pcie_console_stdio_puts(struct stdio_dev *dev,
+					     const char *s)
+{
+	struct udevice *udev = dev->priv;
+	size_t len = strlen(s);
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(udev);
+	struct octeontx_pcie_console *console = priv->console;
+
+#ifdef DEBUG
+	if (in_debug)
+		return;
+#endif
+	octeontx_pcie_console_write(console, (u8 *)s, len,
+				    OCTEONTX_PCIE_CONSOLE_FLAG_NONBLOCK);
+}
+
+static int octeontx_pcie_console_setbrg(struct udevice *dev, int baudrate)
+{
+	return 0;
+}
+
+static int octeontx_pcie_console_getc(struct udevice *dev)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *console = priv->console;
+	int ret;
+
+#ifdef DEBUG
+	if (in_debug)
+		return 0;
+#endif
+	ret = octeontx_pcie_console_readc(console, 0);
+	debug("%s(%s): ret=%d\n", __func__, dev->name, ret);
+	return ret;
+}
+
+static int octeontx_pcie_console_putc(struct udevice *dev, const char c)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *console = priv->console;
+	int ret;
+	u8 v = (u8)c;
+
+#ifdef DEBUG
+	if (in_debug)
+		return 0;
+#endif
+	ret = octeontx_pcie_console_write(console, &v, 1,
+					  OCTEONTX_PCIE_CONSOLE_FLAG_NONBLOCK);
+	return ret > 0 ? 0 : -1;
+}
+
+static int octeontx_pcie_console_pending(struct udevice *dev, bool input)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *console = priv->console;
+	bool ret;
+
+	if (input)
+		ret = octeontx_pcie_console_read_avail(console);
+	else
+		ret = octeontx_pcie_console_write_avail(console);
+
+	return ret;
+}
+
+static int octeontx_pcie_console_clear(struct udevice *dev)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *console = priv->console;
+	int ret;
+
+#ifdef DEBUG
+	if (in_debug)
+		return 0;
+#endif
+	/* We cannot cleanly clear the write buffer */
+	ret = octeontx_pcie_console_clear_rx(console);
+	if (ret < 0)
+		return ret;
+	if (octeontx_pcie_console_write_avail(console) > 0)
+		return -EAGAIN;
+	return 0;
+}
+
+/**
+ * Initialize the nexus console descriptor
+ *
+ * If it is not already initialized, this parses the device tree and
+ * initializes the nexus console descriptor.  We need it to point to
+ * all of the consoles since the remote console utility does not have
+ * access to the device tree.
+ *
+ * Note that this tries to initialize the magic number and version atomically.
+ *
+ * The order this is written tries to minimize any locking needed
+ * or atomic operations.  It should be safe for multiple clients to try and
+ * initialize this at the same time.
+ */
+int octeontx_pcie_console_available(struct udevice *ndev, int console_num,
+				    bool *in_use, bool *exclusive)
+{
+	struct octeontx_pcie_console_nexus_priv *npriv = dev_get_priv(ndev);
+	struct octeontx_pcie_console_nexus *cdesc = npriv->nexus;
+	bool used;
+
+	if ((le64_to_cpu(cdesc->magic) != OCTEONTX_PCIE_CONSOLE_NEXUS_MAGIC) ||
+	    !octeontx_pcie_console_check_ver(cdesc->major_version,
+					     cdesc->minor_version)) {
+		dev_warn(ndev,
+			 "Console nexus not initialized or invalid version\n");
+		return -1;
+	}
+
+	used = !!(le32_to_cpu(cdesc->in_use) & (1 << console_num));
+	if (in_use)
+		*in_use = used;
+	if (exclusive)
+		*exclusive =
+			!!(le32_to_cpu(cdesc->exclusive) & (1 << console_num));
+	return !used;
+}
+
+/**
+ * Extracts the platform data from the device tree
+ *
+ * @param	dev	serial device
+ *
+ * @return	0 for success, otherwise error
+ */
+/**
+ * Initializes a PCIe console
+ *
+ * @param	dev	console device
+ * @param	pcd	console descriptor
+ * @param	console_num	console number
+ *
+ * NOTE: When this is called it is assumed that we already have exclusive
+ * access to this console.
+ */
+static int octeontx_pcie_console_init(struct udevice *dev)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *cons;
+	ofnode node = dev_ofnode(dev);
+	fdt_addr_t addr;
+	fdt_addr_t size;
+	u32 input_buf_size, output_buf_size;
+	int ret = 0;
+
+	addr = ofnode_get_addr_size_index(node, 0, &size);
+	if (addr == FDT_ADDR_T_NONE) {
+		dev_err("%s: Could not read address and size\n", __func__);
+		return -EINVAL;
+	}
+	input_buf_size = ofnode_read_u32_default(node, "rx-buffer-size", 0);
+	output_buf_size = ofnode_read_u32_default(node, "tx-buffer-size", 0);
+	debug("%s(%s) addr: %#llx, size: %#llx, input_buf_size: %#x, output_buf_size: %#x\n",
+	      __func__, dev->name, addr, size, input_buf_size, output_buf_size);
+	if (!input_buf_size) {
+		dev_err(dev, "input-buf-size not defined for console %s\n",
+			ofnode_get_name(node));
+		return -EINVAL;
+	}
+	if (!output_buf_size) {
+		dev_err(dev, "output-buf-size not defined for console %s\n",
+			ofnode_get_name(node));
+		return -ENOMEM;
+	}
+	if (size < sizeof(struct octeontx_pcie_console) +
+			input_buf_size + output_buf_size) {
+		dev_err(dev, "Not enough space reserved for buffers for %s, %#llx < %#lx + %#x + %#x\n",
+			ofnode_get_name(node), size, sizeof(*cons),
+			input_buf_size, output_buf_size);
+		return -ENOMEM;
+	}
+
+	cons = (struct octeontx_pcie_console *)addr;
+	if (cons->magic != OCTEONTX_PCIE_CONSOLE_MAGIC) {
+		memset(cons, 0, sizeof(*cons));
+		/*
+		 * Note that the locks are not used yet but are planned
+		 * in a future release update.
+		 */
+		octeontx_init_spin_lock(&cons->excl_lock);
+		octeontx_pcie_init_target_lock(&cons->pcie_lock);
+	}
+
+	octeontx_pcie_target_lock(&cons->pcie_lock);
+	snprintf(cons->name, sizeof(cons->name), dev->name);
+	cons->owner_id = cpu_to_le32(OCTEONTX_PCIE_CONSOLE_OWNER_UBOOT);
+
+	if (cons->host_console_connected) {
+		/*
+		 * If we're here then a host console is already connected
+		 * so we can't change the pointers manipulated by the host.
+		 */
+		if (le32_to_cpu(cons->input_buf_size) != input_buf_size) {
+			dev_err(dev,
+				"host connected, input buffer size mismatch\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		if (le32_to_cpu(cons->output_buf_size) != output_buf_size) {
+			dev_err(dev,
+				"host connected, output buffer size mismatch\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		if (le64_to_cpu(cons->input_base_addr) +
+		    le32_to_cpu(cons->input_buf_size) > size) {
+			dev_err(dev, "Input buffer address invalid\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		if (le64_to_cpu(cons->output_base_addr) +
+		    le32_to_cpu(cons->output_buf_size) > size) {
+			dev_err(dev, "Output buffer address invalid\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		/* We should check for overlaps */
+		/* Verify indices */
+		/*
+		 * We don't clear the indices so any data still in them can
+		 * be read from input or printed from the output by the
+		 * host client.
+		 */
+		if (le32_to_cpu(cons->input_write_index) >=
+		    le32_to_cpu(cons->input_buf_size)) {
+			dev_err(dev, "Input write index %u out of range\n",
+				cons->input_write_index);
+			ret = -EINVAL;
+			goto error;
+		}
+		if (cons->input_read_index >= cons->input_buf_size) {
+			dev_err(dev, "Input read index %u out of range\n",
+				cons->input_read_index);
+			ret = -EINVAL;
+			goto error;
+		}
+		if (cons->output_write_index >= cons->output_buf_size) {
+			dev_err(dev, "Output write index %u out of range\n",
+				cons->output_write_index);
+			ret = -EINVAL;
+			goto error;
+		}
+
+		if (cons->output_read_index >= cons->output_buf_size) {
+			dev_err(dev, "Output read index %u out of range\n",
+				cons->output_read_index);
+			ret = -EINVAL;
+			goto error;
+		}
+	} else {
+		debug("%s: Initializing console at %p\n", __func__, cons);
+		/* Allocate input buffer immediately after the header */
+		cons->input_base_addr = cpu_to_le64(addr + sizeof(*cons));
+		cons->input_buf_size = cpu_to_le32(input_buf_size);
+		/* Allocate the output buffer immediately after the input */
+		cons->output_base_addr =
+			cpu_to_le64(cons->input_base_addr + input_buf_size);
+		cons->output_buf_size = cpu_to_le32(output_buf_size);
+
+		cons->input_read_index = 0;
+		cons->input_write_index = 0;
+		cons->output_read_index = 0;
+		cons->output_write_index = 0;
+		cons->user = dev;
+		debug("%s: input buffer: %#llx, %#x bytes, output buffer: %#llx, %#x bytes\n",
+		      __func__, cons->input_base_addr, cons->input_buf_size,
+		      cons->output_base_addr, cons->output_buf_size);
+		__iowmb();
+		cons->magic = OCTEONTX_PCIE_CONSOLE_MAGIC;
+		__iowmb();
+	}
+error:
+	octeontx_pcie_target_unlock(&cons->pcie_lock);
+
+	if (!ret)
+		priv->console = cons;
+
+	return ret;
+}
+
+/**
+ * Probe function for the PCIe console driver
+ *
+ * @param	dev	console device
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_pcie_console_probe(struct udevice *dev)
+{
+	ofnode node = dev_ofnode(dev);
+	struct udevice *parent = dev_get_parent(dev);
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console_nexus_priv *ppriv = dev_get_priv(parent);
+	struct octeontx_pcie_console_nexus *nexus = ppriv->nexus;
+	fdt_addr_t addr, size;
+	struct stdio_dev sdev;
+	int console_num;
+	u64 old_mask, new_mask;
+	bool ok;
+	ulong start;
+	int ret;
+#ifdef DEBUG
+	struct stdio_dev *_sdev;
+#endif
+
+	debug("%s(%s), parent: %p, ppriv: %p\n", __func__, dev->name,
+	      parent, ppriv);
+	if (!parent) {
+		dev_err(dev, "Parent not available!\n");
+		return -EINVAL;
+	}
+	if (ppriv->console) {
+		debug("%s: console already bound\n", dev->name);
+		return -ENODEV;
+	}
+
+	console_num = (int)dev_read_u32_default(dev, "reg", -1);
+	if (console_num < 0) {
+		dev_err(dev, "Invalid console number from reg\n");
+		return -EINVAL;
+	}
+	debug("%s(%s): console number %d\n", __func__, dev->name, console_num);
+
+	addr = ofnode_get_addr_size_index(node, 0, &size);
+	if (addr == FDT_ADDR_T_NONE) {
+		dev_err(dev, "Invalid address in device tree\n");
+		return -EINVAL;
+	}
+
+
+	priv->nexus = ppriv->nexus;
+	ret = ofnode_read_s32(node, "reg", &priv->console_num);
+	if (ret) {
+		dev_err(dev,
+			"Could not read \"reg\" property from device tree!\n");
+		return -EINVAL;
+	}
+	debug("%s(%s): console #%d\n", __func__, dev->name, priv->console_num);
+
+	ret = octeontx_pcie_console_init(dev);
+	if (ret) {
+		dev_err(dev, "Error initializing console %s\n", dev->name);
+		return ret;
+	}
+
+	if (ppriv->console) {
+		debug("%s: Console already selected\n", __func__);
+		return -ENODEV;
+	}
+
+	/* Set both in_use and exclusive */
+	new_mask = 1ULL << console_num;
+	new_mask |= (new_mask << 32);
+	start = get_timer(0);
+	do {
+		if (nexus->in_use & (1 << console_num)) {
+			debug("%s: console %d already in use\n",
+			      __func__, console_num);
+			return -ENODEV;
+		}
+		old_mask = nexus->in_use | (u64)(nexus->exclusive) << 32;
+		debug("%s: in_use: %p, exclusive: %p\n", __func__,
+		      &nexus->in_use, &nexus->exclusive);
+		ok = __atomic_compare_exchange_n((u64 *)&nexus->in_use,
+						 &old_mask, new_mask, false,
+						 __ATOMIC_SEQ_CST,
+						 __ATOMIC_SEQ_CST);
+		debug("%s: ok: %d in_use: %#x, exclusive: %#x\n",
+		      __func__, ok, nexus->in_use, nexus->exclusive);
+	} while (!ok && get_timer(start) < 10);
+
+	if (!ok) {
+		dev_err(dev,
+			"Atomic in_use failed, old_mask: %#llx, new_mask: %#llx\n",
+				old_mask, new_mask);
+		return -EIO;
+	}
+
+	memset(&sdev, 0, sizeof(sdev));
+
+	sdev.flags = DEV_FLAGS_INPUT | DEV_FLAGS_OUTPUT | DEV_FLAGS_DM;
+	strncpy(sdev.name, "pci-console", sizeof(sdev.name));
+	sdev.start = octeontx_pcie_console_stdio_start;
+	sdev.stop = octeontx_pcie_console_stdio_stop;
+	sdev.putc = octeontx_pcie_console_stdio_putc;
+	sdev.puts = octeontx_pcie_console_stdio_puts;
+	sdev.getc = octeontx_pcie_console_stdio_getc;
+	sdev.tstc = octeontx_pcie_console_stdio_tstc;
+	sdev.priv = dev;
+	debug("%s: Registering stdio driver %s\n", __func__, sdev.name);
+	ret = stdio_register_dev(&sdev, &priv->sdev);
+#ifdef DEBUG
+	_sdev = priv->sdev;
+	debug("%s: stdio_register_dev returned %d, output: %p\n", __func__,
+	      ret, _sdev);
+	if (!ret) {
+		struct list_head *pos;
+		struct list_head *list = stdio_get_list();
+
+		debug("%s: _sdev: %p, list: %p, next: %p, _sdev->next: %p, _sdev->prev: %p\n",
+		      __func__, _sdev, list, list->next,
+		      _sdev->list.next, _sdev->list.prev);
+		list_for_each(pos, list) {
+			debug("  pos: %p\n", pos);
+			_sdev = list_entry(pos, struct stdio_dev, list);
+			printf("stdio dev %s, %p, next: %p, prev: %p\n",
+			       _sdev->name, _sdev, _sdev->list.next,
+			       _sdev->list.prev);
+		}
+	}
+#endif
+	if (ret)
+		dev_err(dev, "Error registering stdio device\n");
+	else if (!ppriv->console)
+		ppriv->console = priv->console;
+
+	return ret;
+}
+
+int octeontx_pcie_console_ofdata_to_platdata(struct udevice *dev)
+{
+	struct octeontx_pcie_console_plat_data *plat = dev_get_platdata(dev);
+	struct octeontx_pcie_console_plat_data *pplat;
+	ofnode node = dev_ofnode(dev);
+	fdt_addr_t addr;
+	fdt_size_t size;
+	int ret;
+
+	addr = devfdt_get_addr_size_index(dev, 0, &size);
+	debug("%s(%s): base: %#llx, size: %#llx\n", __func__, dev->name,
+	      addr, size);
+	if (addr == FDT_ADDR_T_NONE) {
+		dev_err(dev, "Address and/or size not found in reg field\n");
+		return -EINVAL;
+	}
+	pplat = dev_get_platdata(dev_get_parent(dev));
+	if (!pplat) {
+		dev_err(dev, "%s(%s): Error: parent platdata is NULL!\n",
+			__func__, dev->name);
+		return -EINVAL;
+	}
+	plat->nexus = pplat->nexus;
+	plat->addr = ofnode_get_addr_size_index(node, 0, &plat->size);
+	plat->base = (void *)plat->addr;
+	plat->console = plat->base;
+	ret = ofnode_read_resource(node, 0, &plat->res);
+	debug("%s(%s): ret: %d\n", __func__, dev->name, ret);
+
+	return ret;
+}
+
+static int modify_env(const char *name, const char *remove_name)
+{
+	char *env, *start, *end;
+	char new_env[128];
+	char temp[128];
+	int len = strlen(remove_name);
+	int dev;
+
+	env = env_get(name);
+	if (!env)
+		return -1;
+
+	strncpy(temp, env, sizeof(temp));
+	new_env[0] = '\0';
+	start = temp;
+	do {
+		end = strchr(start, ',');
+		if (end)
+			*end = '\0';
+
+		if (strncmp(start, remove_name, len)) {
+			if (start != temp)
+				strncat(new_env, ",", sizeof(new_env));
+			strncat(new_env, start, sizeof(new_env));
+		}
+		if (end)
+			start = end + 1;
+	} while (end && *start);
+	if (!strcmp(name, "stdin"))
+		dev = stdin;
+	else if (!strcmp(name, "stdout"))
+		dev = stdout;
+	else if (!strcmp(name, "stderr"))
+		dev = stderr;
+	else
+		return -ENODEV;
+
+	return iomux_doenv(dev, new_env);
+}
+
+static int octeontx_pcie_console_remove(struct udevice *dev)
+{
+	struct octeontx_pcie_console_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console *cons = priv->console;
+	struct octeontx_pcie_console_nexus *desc = priv->nexus;
+	u64 mask = (1ULL << priv->console_num);
+
+	dev_dbg(dev, "%s(%s): Performing cleanup\n", __func__, dev->name);
+
+	/* We first need to remove ourselves from stdin, stdout and stderr */
+	modify_env("stdin", DRIVER_NAME);
+	modify_env("stdout", DRIVER_NAME);
+	modify_env("stderr", DRIVER_NAME);
+
+	stdio_deregister_dev(priv->sdev, 1);
+
+	mask |= mask << 32;
+	memset(cons->name, 0, sizeof(cons->name));
+	if (cons->owner_id == OCTEONTX_PCIE_CONSOLE_OWNER_UBOOT)
+		cons->owner_id = OCTEONTX_PCIE_CONSOLE_OWNER_UNUSED;
+
+	/* Remove console from being in-use atomically */
+	__atomic_fetch_and((u64 *)&desc->in_use, ~mask, __ATOMIC_SEQ_CST);
+
+	dev_dbg(dev, "%s(%s): Performing cleanup done\n", __func__, dev->name);
+	return 0;
+}
+
+int octeontx_pcie_console_init_nexus(struct udevice *dev)
+{
+	struct octeontx_pcie_console_plat_data *pdata = dev_get_platdata(dev);
+	struct octeontx_pcie_console_nexus *pcd = pdata->nexus;
+	ofnode node;
+	fdt_addr_t addr;
+	fdt_size_t size = 0;
+	u64 new_hi, new_lo;
+	u64 prev_hi, prev_lo;
+	int num_consoles = 0;
+	bool cmp;
+
+	debug("%s(%s): Initializing main console descriptor\n",
+	      __func__, dev->name);
+
+#ifdef DEBUG
+	debug("Start PCD\n");
+	print_buffer(0, pcd, 1, sizeof(*pcd), 0);
+#endif
+
+	if (pcd->magic == cpu_to_le64(OCTEONTX_PCIE_CONSOLE_NEXUS_MAGIC)) {
+		if (!octeontx_pcie_console_check_ver(pcd->major_version,
+						     pcd->minor_version)) {
+			dev_err(dev,
+				"Error: console descriptor previously initialized to an unsupported version %u.%u\n",
+				pcd->major_version, pcd->minor_version);
+			return -EINVAL;
+		}
+		debug("%s: console descriptor already initialized\n",
+		      dev->name);
+		/* If already initialized then we're done. */
+		if (pcd->num_consoles)
+			return 0;
+	}
+
+	/*
+	 * Fill in the number of consoles and their addresses.  This
+	 * should be safe without requiring locks since if this is being
+	 * initialized elsewhere the values will be identical.
+	 */
+	dev_for_each_subnode(node, dev) {
+		if (num_consoles >= OCTEONTX_PCIE_MAX_CONSOLES) {
+			dev_err(dev, "Too many PCIe consoles!  Max is %d\n",
+				OCTEONTX_PCIE_MAX_CONSOLES);
+			return -EINVAL;
+		}
+		addr = ofnode_get_addr_size_index(node, 0, &size);
+		debug("%s: Address: %#llx, size: %#llx\n",
+		      __func__, addr, size);
+		if (addr == FDT_ADDR_T_NONE) {
+			dev_err(dev, "Could not get console %s address\n",
+				ofnode_get_name(node));
+			return -EINVAL;
+		}
+		debug("%s: %s addr: %#llx, size: %#llx\n", __func__,
+		      ofnode_get_name(node), addr, size);
+		if (!addr || !size) {
+			dev_err(dev, "Console %s resources are 0!\n",
+				ofnode_get_name(node));
+			return -EINVAL;
+		}
+		/*
+		 * It's safe to write to this even if previously initialized
+		 * because the values are the same.
+		 */
+		pcd->console_addr[num_consoles++] = addr;
+	}
+
+	/*
+	 * Make sure to flush the addresses before updating the number
+	 * of consoles.
+	 */
+	__iowmb();
+	/*
+	 * It's safe to override this also since the value should be the same.
+	 */
+	if (num_consoles == 0) {
+		dev_err(dev, "No consoles found in device tree!\n");
+		return -ENODEV;
+	}
+
+	new_hi = cpu_to_le64(OCTEONTX_PCIE_CONSOLE_NEXUS_MAGIC);
+	new_lo = ((u64)OCTEONTX_PCIE_CONSOLE_MAJOR << 0) |
+		  (u64)OCTEONTX_PCIE_CONSOLE_MINOR << 8 |
+		  (u64)0 /*i.e. flags */ << 16 |
+		  (u64)num_consoles << 24;
+	new_lo = cpu_to_le64(new_lo);
+
+	debug("%s: Writing %#llx %#llx to %p\n", __func__, new_hi, new_lo, pcd);
+	/* Now fill in the header atomically */
+	cmp = octeontx_cmpxchg_atomic128(pcd, 0, 0, new_hi, new_lo,
+					 &prev_hi, &prev_lo);
+	/* If the old header is non-zero and the magic number matches... */
+	if (!cmp && le64_to_cpu(prev_hi) == OCTEONTX_PCIE_CONSOLE_NEXUS_MAGIC) {
+		prev_hi = le64_to_cpu(prev_hi);
+		prev_lo = le64_to_cpu(prev_lo);
+		debug("%s(%s): Pevious header: %#llx %#llx\n",
+		      __func__, dev->name, prev_hi, prev_lo);
+		if (!octeontx_pcie_console_check_ver(pcd->major_version,
+						     pcd->minor_version)) {
+			dev_err(dev,
+				"Version mismatch during atomic operation, other version is %u.%u\n",
+				pcd->major_version, pcd->minor_version);
+			return -EINVAL;
+		}
+	}
+
+#ifdef DEBUG
+	debug("PCD after cmpxchg 128, cmp: %d\n", cmp);
+	print_buffer(0, pcd, 1, sizeof(*pcd), 0);
+#endif
+
+	return 0;
+}
+
+static int octeontx_pcie_console_nexus_child_pre_probe(struct udevice *dev)
+{
+	debug("%s(%s)\n", __func__, dev->name);
+	return 0;
+}
+
+static int octeontx_pcie_console_nexus_probe(struct udevice *dev)
+{
+	struct octeontx_pcie_console_nexus_priv *priv = dev_get_priv(dev);
+	struct octeontx_pcie_console_plat_data *plat = dev_get_platdata(dev);
+	struct octeontx_pcie_console_nexus *pcd;
+	struct uclass *uc;
+	struct udevice *sdev, *next;
+	ofnode node = dev_ofnode(dev);
+	int ret;
+	static bool recursive_probe;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	if (recursive_probe) {
+		debug("%s(%s): recursive\n", __func__, dev->name);
+		return 0;
+	}
+
+	debug("%s: dev: %p, priv: %p\n", __func__, dev, priv);
+	pcd = (struct octeontx_pcie_console_nexus *)plat->nexus;
+	if (!plat->nexus) {
+		dev_err(dev, "Nexus pointer NULL!\n");
+		return -ENODEV;
+	}
+
+	priv->console = NULL;
+	priv->nexus = pcd;
+	priv->console_node = node;
+	ret = dev_read_resource(dev, 0, &priv->res);
+	if (ret) {
+		dev_err(dev, "Could not read resources\n");
+		return -EINVAL;
+	}
+
+	ret = octeontx_pcie_console_init_nexus(dev);
+	if (ret) {
+		dev_err(dev,
+			"Could not initialize PCIE console nexus descriptor\n");
+		return -ENOENT;
+	}
+
+	ret = uclass_get(UCLASS_SERIAL, &uc);
+	if (ret) {
+		dev_err(dev, "%s: Could not get serial uclass\n", __func__);
+		return ret;
+	}
+	device_foreach_child_safe(sdev, next, dev) {
+		debug("%s: probing %s\n", __func__, sdev->name);
+		ret = device_probe(sdev);
+		if (!ret) {
+			debug("%s(%s): Probed %s, done.\n",
+			      __func__, dev->name, sdev->name);
+			break;
+		}
+		if (ret != -ENODEV)
+			dev_err(dev, "Error %d probing %s\n", ret, sdev->name);
+	}
+	return 0;
+}
+
+/**
+ * Read device tree data for the platform data
+ *
+ * @param	dev	device to read
+ *
+ * @return	0 for success, -EINVAL if invalid address
+ */
+static int octeontx_pcie_console_nexus_ofdata_to_platdata(struct udevice *dev)
+{
+	struct octeontx_pcie_console_plat_data *plat = dev_get_platdata(dev);
+	fdt_addr_t addr;
+	fdt_size_t size;
+	ofnode node = dev_ofnode(dev);
+
+	if (!dev_of_valid(dev) || !dev_read_enabled(dev))
+		return -ENOENT;
+
+
+	addr = ofnode_get_addr_size_index(node, 0, &size);
+	dev_dbg(dev, "%s(%s): base: 0x%llx, size: 0x%llx\n", __func__,
+		dev->name, addr, size);
+	if (addr == FDT_ADDR_T_NONE) {
+		dev_err(dev, "Address and/or size not found in reg field\n");
+		return -EINVAL;
+	}
+	if (size < sizeof(struct octeontx_pcie_console_nexus)) {
+		dev_err(dev, "Nexus device tree size too small\n");
+		return -EINVAL;
+	}
+
+	plat->size = size;
+	plat->base = (void *)addr;
+	plat->nexus = (struct octeontx_pcie_console_nexus *)addr;
+	debug("%s(%s): address: %#llx, size: %#llx\n",
+	      __func__, dev->name, addr, size);
+	return 0;
+}
+
+static const struct udevice_id octeontx_pcie_console_nexus_serial_id[] = {
+	{ .compatible = "marvell,pci-console-nexus", },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_pcie_console_nexus) = {
+	.name = DRIVER_NAME "-nexus",
+	.id = UCLASS_MISC,
+	.flags = DM_FLAG_PRE_RELOC,
+	.of_match = of_match_ptr(octeontx_pcie_console_nexus_serial_id),
+	.ofdata_to_platdata = octeontx_pcie_console_nexus_ofdata_to_platdata,
+	.platdata_auto_alloc_size =
+				sizeof(struct octeontx_pcie_console_plat_data),
+	.probe = octeontx_pcie_console_nexus_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pcie_console_nexus_priv),
+	.child_pre_probe = octeontx_pcie_console_nexus_child_pre_probe,
+};
+
+static const struct dm_serial_ops octeontx_pcie_console_ops = {
+	.setbrg = octeontx_pcie_console_setbrg,
+	.getc = octeontx_pcie_console_getc,
+	.putc = octeontx_pcie_console_putc,
+	.pending = octeontx_pcie_console_pending,
+	.clear = octeontx_pcie_console_clear,
+};
+
+static const struct udevice_id octeontx_pcie_console_serial_id[] = {
+	{ .compatible = "marvell,pci-console", },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_pcie_console) = {
+	.name = DRIVER_NAME,
+	.id = UCLASS_SERIAL,
+	.ops = &octeontx_pcie_console_ops,
+	.of_match = of_match_ptr(octeontx_pcie_console_serial_id),
+	.probe = octeontx_pcie_console_probe,
+	.ofdata_to_platdata = octeontx_pcie_console_ofdata_to_platdata,
+	.remove = octeontx_pcie_console_remove,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pcie_console_priv),
+	.platdata_auto_alloc_size =
+				sizeof(struct octeontx_pcie_console_plat_data),
+	.flags = DM_FLAG_OS_PREPARE | DM_FLAG_PRE_RELOC | DM_FLAG_ACTIVE_DMA,
+};
diff --git a/drivers/serial/serial_octeontx_pcie_console.h b/drivers/serial/serial_octeontx_pcie_console.h
new file mode 100644
index 0000000000..465c935fdc
--- /dev/null
+++ b/drivers/serial/serial_octeontx_pcie_console.h
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier: GPL-2.0+    BSD-3-Clause
+ */
+#ifndef __SERIAL_OCTEONTX_PCIE_CONSOLE_H__
+#define __SERIAL_OCTEONTX_PCIE_CONSOLE_H__
+
+/** CONSOLE! converted to little-endian */
+#define OCTEONTX_PCIE_CONSOLE_MAGIC		0x21454C4F534E4F43
+
+/** CONDSCR! converted to little-endian */
+#define OCTEONTX_PCIE_CONSOLE_NEXUS_MAGIC	0x21524353444E4F43
+
+#define OCTEONTX_PCIE_CONSOLE_MAJOR		1
+#define OCTEONTX_PCIE_CONSOLE_MINOR		0
+
+#define TURN_HOST				0
+#define TURN_TARGET				1
+
+/** Maximum number of supported consoles */
+#define OCTEONTX_PCIE_MAX_CONSOLES		16
+
+/** Set if writes should not block if the buffer is full */
+#define OCTEONTX_PCIE_CONSOLE_FLAG_NONBLOCK	BIT(0)
+
+/** Set if the PCIE console cannot be shared */
+#define OCTEONTX_PCIE_CONSOLE_FLAG_EXCLUSIVE	BIT(1)
+
+#define OCTEONTX_PCIE_CONSOLE_NAME_LEN		16
+
+#define OCTEONTX_PCIE_CONSOLE_NAME		"U-Boot"
+
+#define OCTEONTX_PCIE_CONSOLE_OWNER_UNUSED	0
+#define OCTEONTX_PCIE_CONSOLE_OWNER_UBOOT	1
+
+/**
+ * Use Peterson's algorithm since atomics aren't supported by
+ * most PCIe hosts (i.e. X86)
+ *
+ * @param	turn		Set to whoever is modifying it
+ * @param	host_lock	Set if the host has it
+ * @param	target_lock	Set if the target has it
+ * @param	pad		padding
+ *
+ * NOTE: This data structure is 64-bits for endian purposes and alignment.
+ */
+struct octeontx_pcie_lock {
+#ifdef __LITTLE_ENDIAN
+	volatile u8	turn;
+	volatile u8	host_lock;
+	volatile u8	target_lock;
+	u8		pad[5];
+#else
+	u8		pad[5];
+	volatile u8	target_lock;
+	volatile u8	host_lock;
+	volatile u8	turn;
+#endif
+} __aligned(8);
+
+/**
+ * Structure that defines a single console.
+ *
+ * Note: when read_index == write_index, the buffer is empty.
+ * The actual usable size  of each console is console_buf_size -1;
+ *
+ * There are two different types of locks.  pcie_lock is for locking
+ * between the host and target.  excl_lock should always be acquired
+ * before pcie_lock is acquired and released after pcie_lock is released.
+ *
+ * excl_lock is a spinlock held between different tasks, such as u-boot
+ * and atf or the atf and the Linux kernel.  It should be held whenever
+ * any of the indices are changed or when the pcie_lock is held.
+ *
+ * @param magic		console magic number OCTEONTX_PCIE_CONSOLE_MAGIC
+ * @param name		name assigned to the console, i.e. "ATF" or "U-Boot"
+ * @param flags		flags associated with console, see
+ *			OCTEONTX_PCIE_CONSOLE_FLAG_...
+ * @param owner_id		owning task id of last user, 0 if unused.
+ * @param input_buf_size	Input buffer size in bytes
+ * @param output_buf_size	Output buffer size in bytes
+ * @param input_base_addr	Base address of input buffer
+ * @param input_read_index	index target begins reading data from
+ * @param input_write_index	index host starts writing from
+ * @param output_base_addr	Base address of output buffer
+ * @param host_console_connected	non-zero if host console is connected
+ * @param output_read_index	index host reads from
+ * @param output_write_index	index target writes to
+ * @param pcie_lock		lock held whenever the indices are updated
+ *				using Peterson's algorithm.  Use
+ *				octeontx_pcie_target_lock() and
+ *				octeontx_pcie_target_unlock() to lock and
+ *				unlock this data structure.
+ * @param user			User-defined pointer
+ *				(octeontx_pcie_console_priv *) for U-Boot
+ * @param excl_lock		cpu core lock.  This lock should be held
+ *				whenever this data structure is updated by
+ *				the target since it can be shared by multiple
+ *				targets.
+ * @param pad			pads header to 128 bytes
+ *
+ * Typically the input and output buffers immediately follow this data
+ * structure, however, this is not a requirement.
+ *
+ * Note that the host_console_connected and output_read_index MUST be
+ * next to each other and should be 64-bit aligned. This is due to the
+ * fact that if the output buffer fills up and no host is connected that
+ * the read pointer must be modified atomically in case the host should
+ * connect within that window.
+ */
+struct octeontx_pcie_console {
+	__le64			magic;
+	char			name[OCTEONTX_PCIE_CONSOLE_NAME_LEN];
+	volatile __le32		flags;
+	volatile __le32		owner_id;
+	__le32			input_buf_size;
+	__le32			output_buf_size;
+	__le64			input_base_addr;
+	__le32			input_read_index;
+	volatile __le32		input_write_index;
+	__le64			output_base_addr;
+	volatile __le32		host_console_connected;
+	volatile __le32		output_read_index;
+	__le32			output_write_index;
+	octeontx_spinlock_t	excl_lock;
+	void			*user;
+	struct octeontx_pcie_lock	pcie_lock;
+	u32			pad[8];
+} __packed;
+
+/**
+ * This is the main container structure that contains all the information
+ * about all PCI consoles.  The address of this structure is passed to
+ * various routines that operation on PCI consoles.
+ *
+ * @param magic		console descriptor magic number
+ * @param major_version	major version of console data structure
+ * @param minor_version	minor version of console data structure
+ * @param flags		flags applied to all consoles
+ * @param num_consoles	number of console data structures available
+ * @param excl_lock	lock between cores for this data structure
+ * @param in_use	Set if the console is claimed by anyone (shared or not)
+ * @param exclusive	bitmap of consoles exclusively used
+ * @param pad		padding for header for future versions
+ * @param console_addr	array of addresses for each console, 0 if unavailable.
+ *
+ * Note that in_use and exclusive need to be next to each other and that
+ * they must remain in the same cacheline due to the need for atomic operations.
+ */
+struct octeontx_pcie_console_nexus {
+	__le64		magic;
+	u8		major_version;
+	u8		minor_version;
+	u8		flags;
+	u8		num_consoles;
+	octeontx_spinlock_t excl_lock;
+	volatile __le32	in_use;
+	volatile __le32	exclusive;
+	u64		pad[13];
+	/* Starts at offset 128 */
+	__le64		console_addr[OCTEONTX_PCIE_MAX_CONSOLES];
+} __packed;
+
+struct octeontx_pcie_console_priv {
+	struct resource res;
+	struct octeontx_pcie_console *console;
+	struct octeontx_pcie_console_nexus *nexus;
+	struct stdio_dev *sdev;
+	int console_num;
+};
+
+/**
+ * Platform data
+ *
+ * @param addr	PCIe console descriptor address
+ * @param size	PCIe console descriptor size (including all consoles)
+ * @param base	user base address (if different) but usually the same as addr
+ * @param desc	PCIe console descriptor pointer
+ * @param console U-Boot's pcie console
+ */
+struct octeontx_pcie_console_plat_data {
+	fdt_addr_t addr;
+	fdt_addr_t size;
+	void *base;
+	struct octeontx_pcie_console_nexus *nexus;
+	struct octeontx_pcie_console *console;	/* Only one console in U-Boot */
+	struct resource res;
+};
+
+struct octeontx_pcie_console_nexus_priv {
+	struct octeontx_pcie_console *console;
+	struct octeontx_pcie_console_nexus *nexus;
+	struct resource res;
+	ofnode console_node;
+};
+
+/**
+ * Peterson's algorithm for locking of data structures shared with PCIe host.
+ * See https://en.wikipedia.org/wiki/Peterson%27s_algorithm
+ *
+ * The two flags are instead called target_lock and host_lock.  Since it's
+ * possible that multiple CPU cores (target) may want to acquire this lock,
+ * use octeontx_spin_lock() and octeontx_spin_unlock() around any PCIe locks.
+ *
+ * @param	lock	pointer to PCIe lock datastructure
+ *
+ */
+static inline void octeontx_pcie_init_target_lock(
+				struct octeontx_pcie_lock *lock)
+{
+	lock->host_lock = 0;
+	lock->target_lock = 0;
+	lock->turn = TURN_TARGET;
+
+}
+
+/**
+ * Peterson's algorithm for locking of data structures shared with PCIe host.
+ * See https://en.wikipedia.org/wiki/Peterson%27s_algorithm
+ *
+ * The two flags are instead called target_lock and host_lock.  Since it's
+ * possible that multiple CPU cores (target) may want to acquire this lock,
+ * use octeontx_spin_lock() and octeontx_spin_unlock() around any PCIe locks.
+ *
+ * @param	lock	pointer to PCIe lock datastructure
+ *
+ */
+static inline void octeontx_pcie_target_lock(struct octeontx_pcie_lock *lock)
+{
+	lock->target_lock = 1;
+	__iowmb();
+	lock->turn = TURN_TARGET;
+	__iowmb();
+	while (lock->host_lock && lock->turn == TURN_TARGET)
+		__iormb();
+}
+
+/**
+ * Peterson's algorithm for unlocking of data structures shared with PCIe host
+ *
+ * @param	lock	pointer to PCIe lock datastructure
+ *
+ */
+static inline void octeontx_pcie_target_unlock(struct octeontx_pcie_lock *lock)
+{
+	lock->target_lock = 0;
+	__iowmb();
+}
+
+/**
+ * This is basically the algorithm that should be called on the PCIe host
+ */
+static inline void octeontx_pcie_host_lock(struct octeontx_pcie_lock *lock)
+{
+	lock->host_lock = 1;
+	__iowmb();
+	lock->turn = TURN_HOST;
+	__iowmb();
+}
+
+/**
+ * This is basically the algorithm that should be called on the PCIe host
+ */
+static inline void octeontx_pcie_host_unlock(struct octeontx_pcie_lock *lock)
+{
+	lock->host_lock = 0;
+	__iowmb();
+}
+
+#endif /* __SERIAL_OCTEONTX_PCIE_CONSOLE_H__ */
diff --git a/drivers/serial/serial_pl01x.c b/drivers/serial/serial_pl01x.c
index 2a5f256184..92c85b2da6 100644
--- a/drivers/serial/serial_pl01x.c
+++ b/drivers/serial/serial_pl01x.c
@@ -40,6 +40,9 @@ static int pl01x_putc(struct pl01x_regs *regs, char c)
 	/* Send the character */
 	writel(c, &regs->dr);
 
+	while (!(readl(&regs->fr) & UART_PL01x_FR_TXFE))
+		WATCHDOG_RESET();
+
 	return 0;
 }
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 8dd3213d48..bc1d79743f 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -101,6 +101,12 @@ config CF_SPI
           Enable the ColdFire SPI driver. This driver can be used on
           some m68k SoCs.
 
+config OCTEONTX_SPI
+	bool "OcteonTX SPI driver"
+	help
+	  Enable the OcteonTX SPI driver. This driver can be used to
+	  access the SPI NOR flash on OcteonTX SoC platforms.
+
 config DESIGNWARE_SPI
 	bool "Designware SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index ae4f2958f8..296eb11da8 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_BCM63XX_HSSPI) += bcm63xx_hsspi.o
 obj-$(CONFIG_BCM63XX_SPI) += bcm63xx_spi.o
 obj-$(CONFIG_BCMSTB_SPI) += bcmstb_spi.o
 obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
+obj-$(CONFIG_OCTEONTX_SPI) += octeontx_spi.o
 obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 obj-$(CONFIG_DESIGNWARE_SPI) += designware_spi.o
diff --git a/drivers/spi/kirkwood_spi.c b/drivers/spi/kirkwood_spi.c
index c725625146..55feda274f 100644
--- a/drivers/spi/kirkwood_spi.c
+++ b/drivers/spi/kirkwood_spi.c
@@ -17,6 +17,15 @@
 #include <asm/arch/mpp.h>
 #endif
 #include <asm/arch-mvebu/spi.h>
+#include <mach/clock.h>
+
+/* This weak implementation is for handling older platforms (A38x, A39x)
+ * with pre-defined core clock value
+ */
+__weak u32 soc_tclk_get(void)
+{
+	return CONFIG_SYS_TCLK;
+}
 
 static void _spi_cs_activate(struct kwspi_registers *reg)
 {
@@ -28,6 +37,33 @@ static void _spi_cs_deactivate(struct kwspi_registers *reg)
 	clrbits_le32(&reg->ctrl, KWSPI_CSN_ACT);
 }
 
+static int _spi_direct_write(struct kwspi_registers *reg, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags,
+			     void *direct_addr)
+{
+	unsigned int count = bitlen / 8;
+	unsigned int words = count / 4;
+	unsigned int rem = count % 4;
+
+	if (flags & SPI_XFER_BEGIN)
+		_spi_cs_activate(reg);
+
+	clrsetbits_le32(&reg->cfg, KWSPI_XFERLEN_MASK, KWSPI_XFERLEN_1BYTE);
+
+	if (words)
+		writesl(direct_addr, dout, words);
+	if (rem) {
+		u32 *buf = (u32 *)dout;
+
+		writesb(direct_addr, &buf[words], rem);
+	}
+
+	if (flags & SPI_XFER_END)
+		_spi_cs_deactivate(reg);
+
+	return 0;
+}
+
 static int _spi_xfer(struct kwspi_registers *reg, unsigned int bitlen,
 		     const void *dout, void *din, unsigned long flags)
 {
@@ -203,8 +239,15 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 }
 
 #else
+DECLARE_GLOBAL_DATA_PTR;
 
 /* Here now the DM part */
+#define CHIPSELECTS_NUM		8
+
+struct mvebu_spi_direct_acc {
+	void __iomem		*addr;
+	u32			size;
+};
 
 struct mvebu_spi_dev {
 	bool			is_errata_50mhz_ac;
@@ -213,6 +256,7 @@ struct mvebu_spi_dev {
 struct mvebu_spi_platdata {
 	struct kwspi_registers *spireg;
 	bool is_errata_50mhz_ac;
+	struct mvebu_spi_direct_acc	direct_access[CHIPSELECTS_NUM];
 };
 
 struct mvebu_spi_priv {
@@ -222,17 +266,75 @@ struct mvebu_spi_priv {
 static int mvebu_spi_set_speed(struct udevice *bus, uint hz)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	struct dm_spi_bus *spi = dev_get_uclass_priv(bus);
 	struct kwspi_registers *reg = plat->spireg;
-	u32 data;
+	u32 data, divider;
+	unsigned int spr, sppr;
 
-	/* calculate spi clock prescaller using max_hz */
-	data = ((CONFIG_SYS_TCLK / 2) / hz) + 0x10;
-	data = data < KWSPI_CLKPRESCL_MIN ? KWSPI_CLKPRESCL_MIN : data;
-	data = data > KWSPI_CLKPRESCL_MASK ? KWSPI_CLKPRESCL_MASK : data;
+	if (spi->max_hz && (hz > spi->max_hz)) {
+		debug("%s: limit speed to the max_hz of the bus %d\n",
+		      __func__, spi->max_hz);
+		hz = spi->max_hz;
+	}
+
+	/*
+	 * Calculate spi clock prescaller using max_hz.
+	 * SPPR is SPI Baud Rate Pre-selection, it holds bits 5 and 7:6 in
+	 * SPI Interface Configuration Register;
+	 * SPR is SPI Baud Rate Selection, it holds bits 3:0 in SPI Interface
+	 * Configuration Register.
+	 * The SPR together with the SPPR define the SPI CLK frequency as
+	 * follows:
+	 * SPI actual frequency = core_clk / (SPR * (2 ^ SPPR))
+	 */
+	divider = DIV_ROUND_UP(soc_tclk_get(), hz);
+	if (divider < 16) {
+		/* This is the easy case, divider is less than 16 */
+		spr = divider;
+		sppr = 0;
+
+	} else {
+		unsigned int two_pow_sppr;
+		/*
+		 * Find the highest bit set in divider. This and the
+		 * three next bits define SPR (apart from rounding).
+		 * SPPR is then the number of zero bits that must be
+		 * appended:
+		 */
+		sppr = fls(divider) - 4;
+
+		/*
+		 * As SPR only has 4 bits, we have to round divider up
+		 * to the next multiple of 2 ** sppr.
+		 */
+		two_pow_sppr = 1 << sppr;
+		divider = (divider + two_pow_sppr - 1) & -two_pow_sppr;
+
+		/*
+		 * recalculate sppr as rounding up divider might have
+		 * increased it enough to change the position of the
+		 * highest set bit. In this case the bit that now
+		 * doesn't make it into SPR is 0, so there is no need to
+		 * round again.
+		 */
+		sppr = fls(divider) - 4;
+		spr = divider >> sppr;
+
+		/*
+		 * Now do range checking. SPR is constructed to have a
+		 * width of 4 bits, so this is fine for sure. So we
+		 * still need to check for sppr to fit into 3 bits:
+		 */
+		if (sppr > 7)
+			return -EINVAL;
+	}
+
+	data = ((sppr & 0x6) << 5) | ((sppr & 0x1) << 4) | spr;
 
 	/* program spi clock prescaler using max_hz */
 	writel(KWSPI_ADRLEN_3BYTE | data, &reg->cfg);
-	debug("data = 0x%08x\n", data);
+	debug("Core clock %d Hz, SPI CTRL data = 0x%08x\n",
+	      soc_tclk_get(), data);
 
 	return 0;
 }
@@ -298,8 +400,13 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 {
 	struct udevice *bus = dev->parent;
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	void *direct_addr = plat->direct_access[spi_chip_select(dev)].addr;
 
-	return _spi_xfer(plat->spireg, bitlen, dout, din, flags);
+	if (dout && direct_addr)
+		return _spi_direct_write(plat->spireg, bitlen, dout,
+					 din, flags, direct_addr);
+	else
+		return _spi_xfer(plat->spireg, bitlen, dout, din, flags);
 }
 
 __attribute__((weak)) int mvebu_board_spi_claim_bus(struct udevice *dev)
@@ -339,6 +446,9 @@ static int mvebu_spi_probe(struct udevice *bus)
 	writel(KWSPI_SMEMRDIRQ, &reg->irq_cause);
 	writel(KWSPI_IRQMASK, &reg->irq_mask);
 
+	/* Don't deassert CS between the direct mapped SPI transfers */
+	writel(0, &reg->dw_cfg);
+
 	return 0;
 }
 
@@ -347,10 +457,47 @@ static int mvebu_spi_ofdata_to_platdata(struct udevice *bus)
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	const struct mvebu_spi_dev *drvdata =
 		(struct mvebu_spi_dev *)dev_get_driver_data(bus);
+	struct udevice *child_dev;
 
 	plat->spireg = (struct kwspi_registers *)devfdt_get_addr(bus);
 	plat->is_errata_50mhz_ac = drvdata->is_errata_50mhz_ac;
 
+	list_for_each_entry(child_dev, &bus->child_head, sibling_node) {
+		int cs;
+		fdt_addr_t direct_addr;
+		fdt_size_t size;
+
+		/* Get chip-select number from the "reg" property */
+		cs = fdtdec_get_int(gd->fdt_blob, dev_of_offset(child_dev),
+				    "reg", -1);
+		if (cs == -1) {
+			printf("%s has no valid 'reg' property\n",
+			       child_dev->name);
+			continue;
+		}
+
+		/*
+		 * Check if an address is configured for this SPI device. If
+		 * not, the MBus mapping via the 'ranges' property in the 'soc'
+		 * node is not configured and this device should not use the
+		 * direct mode. In this case, just continue with the next
+		 * device.
+		 */
+		direct_addr = devfdt_get_addr_size_index(bus, cs + 1, &size);
+		if (direct_addr == FDT_ADDR_T_NONE) {
+			printf("\nBus %s CS%d address is not set correct.\n",
+			       bus->name, cs);
+			plat->direct_access[cs].addr = NULL;
+			continue;
+		}
+		plat->direct_access[cs].addr = (void *)direct_addr;
+		plat->direct_access[cs].size = size;
+		printf("\nBus %s CS%d configured for direct access %p:0x%x\n",
+		       bus->name, cs,
+		       plat->direct_access[cs].addr,
+		       plat->direct_access[cs].size);
+	}
+
 	return 0;
 }
 
diff --git a/drivers/spi/mvebu_a3700_spi.c b/drivers/spi/mvebu_a3700_spi.c
index 99ad505f24..58ed409fd5 100644
--- a/drivers/spi/mvebu_a3700_spi.c
+++ b/drivers/spi/mvebu_a3700_spi.c
@@ -22,8 +22,20 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MVEBU_SPI_A3700_CLK_POL			BIT(7)
 #define MVEBU_SPI_A3700_FIFO_EN			BIT(17)
 #define MVEBU_SPI_A3700_SPI_EN_0		BIT(16)
+#define MVEBU_SPI_A3700_WFIFO_FULL		BIT(7)
+#define MVEBU_SPI_A3700_WFIFO_EMPTY		BIT(6)
+#define MVEBU_SPI_A3700_RFIFO_EMPTY		BIT(4)
+#define MVEBU_SPI_A3700_WFIFO_RDY		BIT(3)
+#define MVEBU_SPI_A3700_RFIFO_RDY		BIT(2)
+#define MVEBU_SPI_A3700_XFER_START		BIT(15)
+#define MVEBU_SPI_A3700_XFER_STOP		BIT(14)
+#define MVEBU_SPI_A3700_RW_EN			BIT(8)
+#define MVEBU_SPI_A3700_WFIFO_THRS_BIT		28
+#define MVEBU_SPI_A3700_RFIFO_THRS_BIT		24
+#define MVEBU_SPI_A3700_FIFO_THRS_MASK		0x7
 #define MVEBU_SPI_A3700_CLK_PRESCALE_MASK	0x1f
-
+#define MVEBU_SPI_A3700_ADDR_CNT_BIT		4
+#define MVEBU_SPI_A3700_ADDR_CNT_MASK		0x7
 
 /* SPI registers */
 struct spi_reg {
@@ -31,6 +43,11 @@ struct spi_reg {
 	u32 cfg;	/* 0x10604 */
 	u32 dout;	/* 0x10608 */
 	u32 din;	/* 0x1060c */
+	u32 inst_addr;	/* 0x10610 */
+	u32 addr;	/* 0x10614 */
+	u32 rmode;	/* 0x10618 */
+	u32 hdr_cnt;	/* 0x1061c */
+	u32 din_cnt;	/* 0x10620 */
 };
 
 struct mvebu_spi_platdata {
@@ -48,86 +65,266 @@ static void spi_cs_deactivate(struct spi_reg *reg, int cs)
 	clrbits_le32(&reg->ctrl, MVEBU_SPI_A3700_SPI_EN_0 << cs);
 }
 
-/**
- * spi_legacy_shift_byte() - triggers the real SPI transfer
- * @bytelen:	Indicate how many bytes to transfer.
- * @dout:	Buffer address of what to send.
- * @din:	Buffer address of where to receive.
- *
- * This function triggers the real SPI transfer in legacy mode. It
- * will shift out char buffer from @dout, and shift in char buffer to
- * @din, if necessary.
- *
- * This function assumes that only one byte is shifted at one time.
- * However, it is not its responisbility to set the transfer type to
- * one-byte. Also, it does not guarantee that it will work if transfer
- * type becomes two-byte. See spi_set_legacy() for details.
- *
- * In legacy mode, simply write to the SPI_DOUT register will trigger
- * the transfer.
- *
- * If @dout == NULL, which means no actual data needs to be sent out,
- * then the function will shift out 0x00 in order to shift in data.
- * The XFER_RDY flag is checked every time before accessing SPI_DOUT
- * and SPI_DIN register.
- *
- * The number of transfers to be triggerred is decided by @bytelen.
- *
- * Return:	0 - cool
- *		-ETIMEDOUT - XFER_RDY flag timeout
- */
-static int spi_legacy_shift_byte(struct spi_reg *reg, unsigned int bytelen,
-				 const void *dout, void *din)
+static inline void spi_bytelen_set(struct spi_reg *reg, unsigned int len)
 {
-	const u8 *dout_8;
-	u8 *din_8;
-	int ret;
+	unsigned int data;
+
+	data = readl(&reg->cfg);
+	if (len == 4)
+		data = data | MVEBU_SPI_A3700_BYTE_LEN;
+	else
+		data = data & (~MVEBU_SPI_A3700_BYTE_LEN);
+
+	writel(data, &reg->cfg);
+}
+
+static inline int spi_is_wfifo_full(struct spi_reg *reg)
+{
+	u32 val;
+
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_WFIFO_FULL;
+}
+
+static inline int spi_is_wfifo_empty(struct spi_reg *reg)
+{
+	u32 val;
+
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_WFIFO_EMPTY;
+}
+
+static int spi_fifo_out(struct spi_reg *reg, unsigned int buf_len,
+			unsigned char *tx_buf)
+{
+	unsigned int val = 0;
+
+	while (!spi_is_wfifo_full(reg) && buf_len) {
+		val = (tx_buf[3] << 24) | (tx_buf[2] << 16) |
+				 (tx_buf[1] << 8) | tx_buf[0];
+
+		writel(val, &reg->dout);
+
+		buf_len -= 4;
+		tx_buf += 4;
+	}
+
+	/* Return the unwritten bytes number */
+	return buf_len;
+}
+
+static inline int spi_is_rfifo_empty(struct spi_reg *reg)
+{
+	u32 val;
+
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_RFIFO_EMPTY;
+}
+
+static int spi_fifo_in(struct spi_reg *reg, unsigned int buf_len,
+		       unsigned char *rx_buf)
+{
+	unsigned int val;
+
+	while (!spi_is_rfifo_empty(reg)) {
+		val = readl(&reg->din);
+		if (buf_len >= 4) {
+			rx_buf[0] = val & 0xff;
+			rx_buf[1] = (val >> 8) & 0xff;
+			rx_buf[2] = (val >> 16) & 0xff;
+			rx_buf[3] = (val >> 24) & 0xff;
+			buf_len -= 4;
+			rx_buf += 4;
+		} else {
+			/*
+			 * When remain bytes is smaller than 4, we should
+			 * avoid memory overwriting and and just write the
+			 * left rx buffer bytes.
+			 */
+			while (buf_len) {
+				*rx_buf++ = val & 0xff;
+				val >>= 8;
+				buf_len--;
+			}
+			break;
+		}
+	}
+
+	/* Return the unread bytes number */
+	return buf_len;
+}
+
+static int spi_fifo_xfer_finisher(struct spi_reg *reg, bool force_stop)
+{
+	unsigned int val;
+	int ret = 0;
+
+	val = readl(&reg->cfg);
+	if (force_stop) {
+		val |= MVEBU_SPI_A3700_XFER_STOP;
+		writel(val, &reg->cfg);
+	}
+
+	ret = wait_for_bit_le32(&reg->ctrl,
+				MVEBU_SPI_A3700_XFER_START, false, 100, false);
+	if (ret) {
+		printf("spi_fifo_abort_xfer timeout\n");
+		return ret;
+	}
 
-	/* Use 0x00 as dummy dout */
-	const u8 dummy_dout = 0x0;
-	u32 pending_dout = 0x0;
+	val = readl(&reg->cfg);
+	if (force_stop) {
+		val &= ~MVEBU_SPI_A3700_XFER_STOP;
+		writel(val, &reg->cfg);
+	}
+
+	return ret;
+}
 
-	/* dout_8: pointer of current dout */
-	dout_8 = dout;
-	/* din_8: pointer of current din */
-	din_8 = din;
+static unsigned int spi_fifo_header_set(struct spi_reg *reg,
+					unsigned int bytelen, const void *dout)
+{
+	unsigned int addr_cnt = 0, val = 0, done_len = 0;
+	unsigned char *dout_ptr = (unsigned char *)dout;
 
+	/*
+	 * Clean number of bytes for instruction, address,
+	 * dummy field and read mode
+	 */
+	writel(0x0, &reg->inst_addr);
+	writel(0x0, &reg->addr);
+	writel(0x0, &reg->rmode);
+	writel(0x0, &reg->hdr_cnt);
+
+	if (bytelen % 4) {
+		addr_cnt = bytelen % 4;
+		val = ((addr_cnt & MVEBU_SPI_A3700_ADDR_CNT_MASK)
+			<< MVEBU_SPI_A3700_ADDR_CNT_BIT);
+
+		writel(val, &reg->hdr_cnt);
+		done_len = addr_cnt;
+
+		/* transfer 1~3 bytes by address count */
+		val = 0;
+		while (addr_cnt--) {
+			val = (val << 8) | dout_ptr[0];
+			dout_ptr++;
+		}
+		writel(val, &reg->addr);
+	}
+	return done_len;
+}
+
+static int spi_fifo_write(struct spi_reg *reg, unsigned int bytelen,
+			  const void *dout)
+{
+	unsigned int val;
+	int ret = 0;
+	unsigned char *char_p;
+	unsigned int len_done;
+	int remain_len;
+
+	/* when tx data is not 4 bytes aligned, there will be unexpected
+	 * MSB bytes of SPI output register, since it always shifts out
+	 * as whole 4 bytes. Which might causes incorrect transaction with
+	 * some device and flash. To fix this, Serial Peripheral Interface
+	 * Address (0xd0010614) in header count is used to transfer
+	 * 1 to 3 bytes to make the rest of data 4 bytes aligned.
+	 */
+	len_done = spi_fifo_header_set(reg, bytelen, dout);
+	bytelen -= len_done;
+
+	/* Start Write transfer */
+	val = readl(&reg->cfg);
+	val |= (MVEBU_SPI_A3700_XFER_START | MVEBU_SPI_A3700_RW_EN);
+	writel(val, &reg->cfg);
+
+	/* Write data to spi */
+	char_p = (unsigned char *)dout + len_done;
 	while (bytelen) {
 		ret = wait_for_bit_le32(&reg->ctrl,
-					MVEBU_SPI_A3700_XFER_RDY,
-					true,100, false);
-		if (ret)
+					MVEBU_SPI_A3700_WFIFO_RDY, true, 100,
+					false);
+		if (ret) {
+			printf("SPI: waiting write_fifo_ready timeout.n");
 			return ret;
+		}
+
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_WFIFO_FULL,
+					false, 100, false);
+		if (ret) {
+			printf("SPI: write fifo is full.\n");
+			return ret;
+		}
+
+		remain_len = spi_fifo_out(reg, bytelen, char_p);
+		/* move fifo out pointer to unfinished data for next shift */
+		char_p += bytelen - remain_len;
+		bytelen = remain_len;
+	}
 
-		if (dout)
-			pending_dout = (u32)*dout_8;
-		else
-			pending_dout = (u32)dummy_dout;
+	ret = wait_for_bit_le32(&reg->ctrl,
+				MVEBU_SPI_A3700_WFIFO_EMPTY, true, 100, false);
+	if (ret) {
+		printf("SPI: waiting write_fifo_empty timeout.\n");
+		return ret;
+	}
 
-		/* Trigger the xfer */
-		writel(pending_dout, &reg->dout);
+	/* When write xfer finishes, force stop is needed */
+	ret = spi_fifo_xfer_finisher(reg, true);
 
-		if (din) {
-			ret = wait_for_bit_le32(&reg->ctrl,
-						MVEBU_SPI_A3700_XFER_RDY,
-						true, 100, false);
-			if (ret)
-				return ret;
+	return ret;
+}
 
-			/* Read what is transferred in */
-			*din_8 = (u8)readl(&reg->din);
-		}
+static int spi_fifo_read(struct spi_reg *reg, unsigned int bytelen,
+			 void *din)
+{
+	unsigned int val;
+	int ret = 0;
+	unsigned char *char_p;
+	int remain_len;
+
+	/*
+	 * Clean number of bytes for instruction, address,
+	 * dummy field and read mode
+	 */
+	writel(0x0, &reg->inst_addr);
+	writel(0x0, &reg->addr);
+	writel(0x0, &reg->rmode);
+	writel(0x0, &reg->hdr_cnt);
+
+	/* Set read data length */
+	writel(bytelen, &reg->din_cnt);
+	/* Start READ transfer */
+	val = readl(&reg->cfg);
+	val &= ~MVEBU_SPI_A3700_RW_EN;
+	val |= MVEBU_SPI_A3700_XFER_START;
+
+	writel(val, &reg->cfg);
 
-		/* Don't increment the current pointer if NULL */
-		if (dout)
-			dout_8++;
-		if (din)
-			din_8++;
+	/* Read data from spi */
+	char_p = (unsigned char *)din;
 
-		bytelen--;
+	while (bytelen) {
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_RFIFO_RDY,
+					true, 100, false);
+		if (ret) {
+			printf("SPI: read fifo ready is timeout.\n");
+			return ret;
+		}
+
+		remain_len = spi_fifo_in(reg, bytelen, char_p);
+		/* Move fifo in pointer to unfinished data for next shift */
+		char_p += bytelen - remain_len;
+		bytelen = remain_len;
 	}
 
-	return 0;
+	/* When read xfer finishes, force stop is not needed. */
+	ret = spi_fifo_xfer_finisher(reg, false);
+
+	return ret;
 }
 
 static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
@@ -137,7 +334,8 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	struct spi_reg *reg = plat->spireg;
 	unsigned int bytelen;
-	int ret;
+	int ret = 0;
+	u32 data;
 
 	bytelen = bitlen / 8;
 
@@ -150,34 +348,51 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		spi_cs_activate(reg, spi_chip_select(dev));
 	}
 
-	/* Send and/or receive */
-	if (dout || din) {
-		ret = spi_legacy_shift_byte(reg, bytelen, dout, din);
-		if (ret)
-			return ret;
+	/* Flush read/write FIFO */
+	data = readl(&reg->cfg);
+	writel(data | MVEBU_SPI_A3700_FIFO_FLUSH, &reg->cfg);
+	ret = wait_for_bit_le32(&reg->cfg, MVEBU_SPI_A3700_FIFO_FLUSH,
+				false, 1000, false);
+	if (ret) {
+		printf("SPI: fifo flush action is timeout.\n");
+		return ret;
 	}
 
+	/* Send and/or receive */
+	if (dout)
+		ret = spi_fifo_write(reg, bytelen, dout);
+	else if (din)
+		ret = spi_fifo_read(reg, bytelen, din);
+
 	/* Deactivate CS */
 	if (flags & SPI_XFER_END) {
-		ret = wait_for_bit_le32(&reg->ctrl,
-					MVEBU_SPI_A3700_XFER_RDY,
+		ret = wait_for_bit_le32(&reg->ctrl, MVEBU_SPI_A3700_XFER_RDY,
 					true, 100, false);
-		if (ret)
+		if (ret) {
+			printf("SPI: spi transfer data ready timeout\n");
 			return ret;
+		}
 
 		debug("SPI: deactivate cs.\n");
 		spi_cs_deactivate(reg, spi_chip_select(dev));
 	}
 
-	return 0;
+	return ret;
 }
 
 static int mvebu_spi_set_speed(struct udevice *bus, uint hz)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	struct dm_spi_bus *spi = dev_get_uclass_priv(bus);
 	struct spi_reg *reg = plat->spireg;
 	u32 data, prescale;
 
+	if (hz > spi->max_hz) {
+		debug("%s: limit speed to the max_hz of the bus %d\n",
+		      __func__, spi->max_hz);
+		hz = spi->max_hz;
+	}
+
 	data = readl(&reg->cfg);
 
 	prescale = DIV_ROUND_UP(clk_get_rate(&plat->clk), hz);
@@ -222,11 +437,6 @@ static int mvebu_spi_probe(struct udevice *bus)
 	u32 data;
 	int ret;
 
-	/*
-	 * Settings SPI controller to be working in legacy mode, which
-	 * means use only DO pin (I/O 1) for Data Out, and DI pin (I/O 0)
-	 * for Data In.
-	 */
 
 	/* Flush read/write FIFO */
 	data = readl(&reg->cfg);
@@ -236,14 +446,25 @@ static int mvebu_spi_probe(struct udevice *bus)
 	if (ret)
 		return ret;
 
-	/* Disable FIFO mode */
-	data &= ~MVEBU_SPI_A3700_FIFO_EN;
+	/* Enable FIFO mode */
+	data |= MVEBU_SPI_A3700_FIFO_EN;
 
-	/* Always shift 1 byte at a time */
-	data &= ~MVEBU_SPI_A3700_BYTE_LEN;
+	/*
+	 * Set FIFO threshold
+	 * For read FIFO threshold, value 0 presents 1 data entry, which means
+	 * when data in the read FIFO is equal to or greater than 1 entry,
+	 * flag RFIFO_RDY_IS will be set;
+	 * For write FIFO threshold, value 7 presents 7 data entry, which means
+	 * when data in the write FIFO is less than or equal to 7 entry,
+	 * flag WFIFO_RDY_IS will be set;
+	 */
+	data |= 0 << MVEBU_SPI_A3700_RFIFO_THRS_BIT;
+	data |= 7 << MVEBU_SPI_A3700_WFIFO_THRS_BIT;
 
 	writel(data, &reg->cfg);
 
+	/* set shift 4 bytes for writing and reading */
+	spi_bytelen_set(reg, 4);
 	return 0;
 }
 
diff --git a/drivers/spi/octeontx_spi.c b/drivers/spi/octeontx_spi.c
new file mode 100644
index 0000000000..a4c7c32c9a
--- /dev/null
+++ b/drivers/spi/octeontx_spi.c
@@ -0,0 +1,766 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <dm.h>
+#include <asm/arch/clock.h>
+#include <asm/unaligned.h>
+#include <watchdog.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+#include <asm/arch/board.h>
+#endif
+
+#if !defined(CONFIG_ARCH_OCTEONTX)
+#include <spi-mem.h>
+#define USE_TBI_CLK
+#endif
+
+#define OCTEONTX_SPI_MAX_BYTES		9
+#define OCTEONTX_SPI_MAX_CLOCK_HZ	50000000
+
+#define OCTEONTX2_TBI_CLK		100000000
+
+#define OCTEONTX_SPI_NUM_CS		4
+
+#define OCTEONTX_SPI_CS_VALID(cs)	((cs) < OCTEONTX_SPI_NUM_CS)
+
+#define MPI_CFG				0x1000
+#define MPI_STS				0x1008
+#define MPI_TX				0x1010
+#define MPI_XMIT			0x1018
+#define MPI_WIDE_DAT			0x1040
+#define MPI_IO_CTL			0x1048
+#define MPI_DAT(X)			(0x1080 + ((X) << 3))
+#define MPI_WIDE_BUF(X)			(0x1800 + ((X) << 3))
+#define MPI_CYA_CFG			0x2000
+#define MPI_CLKEN			0x2080
+
+union mpi_cfg {
+	u64 u;
+	struct mpi_cfg_s {
+		/** MPI/SPI enable, 0 = pins are tristated, 1 = pins driven */
+		u64 enable	:1;
+		/**
+		 * Clock idle low/clock invert
+		 * 0 = SPI_CLK idles high, first transition is high-to-low.
+		 *     This correspondes to SPI Block Guide options CPOL = 1,
+		 *     CPHA = 0.
+		 * 1 = SPI_CLK idles low, first transition is low-to-high.  This
+		 *     corresponds to SPI Block Guide options CPOL = 0,
+		 *     CPHA = 0.
+		 */
+		u64 idlelo	:1;
+		/**
+		 * Clock control.
+		 * 0 = Clock idles to value given by IDLELO after completion of
+		 *     MPI/SPI transaction.
+		 * 1 = Clock never idles, requires SPI_CSn_L
+		 *     deassertion/assertion between commands.
+		 */
+		u64 clk_cont	:1;
+		/**
+		 * Wire-or DO and DI.
+		 * 0 = SPI_DO and SPI_DI are separate wires (SPI).  SPI_DO pin
+		 *     is always driven.
+		 * 1 = SPI_DO/DI is all from SPI_DO pin (MPI).  SPI_DO pin is
+		 *     tristated when not transmitting.  If WIREOR = 1, SPI_DI
+		 *     pin is not used by the MPI/SPI engine.
+		 */
+		u64 wireor	:1;
+		/** 0 = shift MSB first, 1 = shift LSB first */
+		u64 lsbfirst	:1;
+		u64 cs_sticky	:1;	/** cs sticky bit */
+		u64 rsvd	:1;	/** Reserved */
+		/**
+		 * SPI_CSn_L high.  1 = SPI_CSn_L is asserted high,
+		 * 0 = SPI_CS_n asserted low.
+		 */
+		u64 cshi	:1;
+		/**
+		 * When set, guarantees idle coprocessor-clock cycles between
+		 * commands.
+		 */
+		u64 idleclks	:2;
+		/**
+		 * Tristate TX.  Set to 1 to tristate SPI_DO when not
+		 * transmitting.
+		 */
+		u64 tritx	:1;
+		/**
+		 * 0 = SPI_CSn asserts 1/2 coprocessor-clock cycle before
+		 *     transaction
+		 * 1 = SPI_CSn asserts coincident with transaction
+		 */
+		u64 cslate	:1;
+		u64 csena0	:1;	/** cs enable 0 */
+		u64 csena1	:1;	/** cs enable 1 */
+		u64 csena2	:1;	/** cs enable 2 */
+		u64 csena3	:1;	/** cs enable 3 */
+		u64 clkdiv	:13;	/** clock divisor */
+		u64 rsvd1	:2;
+		u64 legacy_dis	:1;	/** Disable legacy mode */
+		u64 rsvd2	:2;
+		/**
+		 * I/O Mode (legacy_dis must be 1):
+		 *   0x0	One-lane unidirectional mode.
+		 *   0x1	One-lane bidirectional mode.
+		 *   0x2	Two-lane bidirectional mode.
+		 *   0x3	Four-lane bidirectional mode.
+		 */
+		u64 iomode	:2;
+		u64 rsvd3	:8;
+		/**
+		 * Enable ESPI mode per slave.  Each bit corresponds to each
+		 * of the four possible CS's.
+		 * If 0, CRC hardware is disabled, turn-around time is the
+		 * default for SPI and no special parsing in hardware.
+		 * If 1, CRC hardware is enabled and the hardware will
+		 * automatically calculate the CRC for one transaction and then
+		 * apply it to the end of the transaction and then check the
+		 * CRC on the response and if there is an error the
+		 * MPI(0..1)_STS[CRC_ERR] bit will be set. The turn around
+		 * time (TAR in the ESPI spec) is set to two cicles and parsing
+		 * for special state is enabled.
+		 */
+		u64 cs_espi_en	:4;
+		u64 rsvd4	:1;
+		/**
+		 * SPI 100MHz clock enable.
+		 *
+		 * 0	Use the system clock (sclk) as the base frequency.
+		 *	This provides higher granularity but may require
+		 *	changing clkdiv if the system clock is changed.
+		 * 1	Use a 100MHz clock as the base frequency.  This is
+		 *	the reset value to enable the boot frequency to be
+		 *	sclk agnostic.
+		 */
+		u64 tb100_en	:1;
+		u64 rsvd5	:14;
+	} s;
+	/* struct mpi_cfg_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_dat#
+ *
+ * MPI/SPI Data Registers
+ */
+union mpi_dat {
+	u64 u;
+	struct mpi_datx_s {
+		u64 data		:8;	/** Data to transmit/receive. */
+		u64 reserved_8_63	:56;
+	} s;
+	/* struct mpi_datx_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_sts
+ *
+ * MPI/SPI STS Register
+ */
+union mpi_sts {
+	u64 u;
+	struct mpi_sts_s {
+		u64 busy	:1;	/** SPI engine busy */
+		u64 mpi_intr	:1;	/** Transaction done int */
+		u64 reserved_2_7:6;
+		u64 rxnum	:5;	/** ESPI number of rx bytes */
+		u64 rsvd	:6;
+		u64 crc_err	:1;	/** CRC error from ESPI */
+		u64 rsvd1	:5;
+		u64 crc		:8;	/** ESPI CRC received */
+		u64 reserved_40_63	:24;
+	} s;
+	/* struct mpi_sts_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_tx
+ *
+ * MPI/SPI Transmit Register
+ */
+union mpi_tx {
+	u64 u;
+	struct mpi_tx_s {
+		u64 totnum	:5;	/** Total bytes to shift */
+		u64 rsvd	:3;
+		u64 txnum	:5;	/** Number of words to tx */
+		u64 rsvd1	:3;
+		u64 leavecs	:1;	/** Leave CS asserted */
+		u64 rsvd2	:3;
+		u64 csid	:2;	/** Which CS to assert */
+		u64 rsvd3	:42;
+	} s;
+	/* struct mpi_tx_s cn; */
+};
+
+#if !defined(CONFIG_ARCH_OCTEONTX)
+/**
+ * Register (NCB) mpi#_xmit
+ *
+ * MPI/SPI Transmit Register
+ */
+union mpi_xmit {
+	u64 u;
+	struct mpi_xmit_s {
+		/** Total number of bytes for transmit and receive. */
+		u64 totnum		: 11;
+		u64 reserved_11_19	: 9;
+		/** Number of bytes to transmit (max 1152) */
+		u64 txnum		: 11;
+		u64 reserved_31_59	: 29;
+		u64 leavecs		: 1;	/** Leave SPI_CSn_L asserted */
+		u64 csid		: 2;	/** Which CS to assert */
+		u64 reserved_63		: 1;
+	} s;
+};
+#endif
+
+/** Local driver data structure */
+struct octeontx_spi {
+	void *baseaddr;		/** Register base address */
+	u32 clkdiv;		/** Clock divisor for device speed */
+	bool is_otx2;		/** Gen 2 SoC */
+};
+
+static union mpi_cfg octeontx_spi_set_mpicfg(struct udevice *dev)
+{
+	struct dm_spi_slave_platdata *slave = dev_get_parent_platdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	union mpi_cfg mpi_cfg;
+	uint max_speed = slave->max_hz;
+	bool cpha, cpol;
+
+	if (!max_speed)
+		max_speed = 12500000;
+	if (max_speed > OCTEONTX_SPI_MAX_CLOCK_HZ)
+		max_speed = OCTEONTX_SPI_MAX_CLOCK_HZ;
+
+	debug("\n slave params %d %d %d\n", slave->cs,
+	      slave->max_hz, slave->mode);
+	cpha = !!(slave->mode & SPI_CPHA);
+	cpol = !!(slave->mode & SPI_CPOL);
+
+	mpi_cfg.u = 0;
+	mpi_cfg.s.clkdiv = priv->clkdiv & 0x1fff;
+	mpi_cfg.s.cshi = !!(slave->mode & SPI_CS_HIGH);
+	mpi_cfg.s.lsbfirst = !!(slave->mode & SPI_LSB_FIRST);
+	mpi_cfg.s.wireor = !!(slave->mode & SPI_3WIRE);
+	mpi_cfg.s.idlelo = cpha != cpol;
+	mpi_cfg.s.cslate = cpha;
+	mpi_cfg.s.enable = 1;
+	mpi_cfg.s.csena0 = 1;
+	mpi_cfg.s.csena1 = 1;
+	mpi_cfg.s.csena2 = 1;
+	mpi_cfg.s.csena3 = 1;
+
+	debug("\n mpi_cfg %llx\n", mpi_cfg.u);
+	return mpi_cfg;
+}
+
+/**
+ * Wait until the SPI bus is ready
+ *
+ * @param	dev	SPI device to wait for
+ */
+static void octeontx_spi_wait_ready(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_sts mpi_sts;
+
+	do {
+		mpi_sts.u = readq(baseaddr + MPI_STS);
+		WATCHDOG_RESET();
+	} while (mpi_sts.s.busy);
+	debug("%s(%s)\n", __func__, dev->name);
+}
+
+/**
+ * Claim the bus for a slave device
+ *
+ * @param	dev	SPI bus
+ *
+ * @return	0 for success, -EINVAL if chip select is invalid
+ */
+static int octeontx_spi_claim_bus(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_cfg mpi_cfg;
+
+	debug("\n\n%s(%s)\n", __func__, dev->name);
+	if (!OCTEONTX_SPI_CS_VALID(spi_chip_select(dev)))
+		return -EINVAL;
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	acquire_flash_arb(true);
+#endif
+
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	mpi_cfg.s.tritx = 0;
+	mpi_cfg.s.enable = 1;
+	writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	udelay(5);	/** Wait for bus to settle */
+
+	return 0;
+}
+
+/**
+ * Release the bus to a slave device
+ *
+ * @param	dev	SPI bus
+ *
+ * @return	0 for success, -EINVAL if chip select is invalid
+ */
+static int octeontx_spi_release_bus(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_cfg mpi_cfg;
+
+	debug("%s(%s)\n\n", __func__, dev->name);
+	if (!OCTEONTX_SPI_CS_VALID(spi_chip_select(dev)))
+		return -EINVAL;
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	acquire_flash_arb(false);
+#endif
+
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	mpi_cfg.s.enable = 0;
+	writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	udelay(1);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+static int octeontx_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_tx mpi_tx;
+	union mpi_cfg mpi_cfg;
+	u64 wide_dat = 0;
+	int len = bitlen / 8;
+	int i;
+	const u8 *tx_data = dout;
+	u8 *rx_data = din;
+	int cs = spi_chip_select(dev);
+
+	if (!OCTEONTX_SPI_CS_VALID(cs))
+		return -EINVAL;
+
+	debug("\n %s(%s, %u, %p, %p, 0x%lx), cs: %d\n",
+	      __func__, dev->name, bitlen, dout, din, flags, cs);
+
+	mpi_cfg = octeontx_spi_set_mpicfg(dev);
+
+	if (mpi_cfg.u != readq(baseaddr + MPI_CFG)) {
+		writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+		mpi_cfg.u = readq(baseaddr + MPI_CFG);
+		udelay(10);
+	}
+
+	debug("\n mpi_cfg upd %llx\n", mpi_cfg.u);
+
+	/*
+	 * Start by writing and reading 8 bytes at a time.  While we can support
+	 * up to 10, it's easier to just use 8 with the MPI_WIDE_DAT register.
+	 */
+	while (len > 8) {
+		if (tx_data) {
+			wide_dat = get_unaligned((u64 *)tx_data);
+			debug("  tx: %016llx \t", (unsigned long long)wide_dat);
+			tx_data += 8;
+			writeq(wide_dat, baseaddr + MPI_WIDE_DAT);
+		}
+
+		mpi_tx.u = 0;
+		mpi_tx.s.csid = cs;
+		mpi_tx.s.leavecs = 1;
+		mpi_tx.s.txnum = tx_data ? 8 : 0;
+		mpi_tx.s.totnum = 8;
+		writeq(mpi_tx.u, baseaddr + MPI_TX);
+
+		octeontx_spi_wait_ready(dev);
+
+		debug("\n ");
+
+		if (rx_data) {
+			wide_dat = readq(baseaddr + MPI_WIDE_DAT);
+			debug("  rx: %016llx\t", (unsigned long long)wide_dat);
+			*(u64 *)rx_data = wide_dat;
+			rx_data += 8;
+		}
+		len -= 8;
+	}
+
+	debug("\n ");
+
+	/* Write and read the rest of the data */
+	if (tx_data) {
+		for (i = 0; i < len; i++) {
+			debug("  tx: %02x\n", *tx_data);
+			writeq(*tx_data++, baseaddr + MPI_DAT(i));
+		}
+	}
+	mpi_tx.u = 0;
+	mpi_tx.s.csid = cs;
+	mpi_tx.s.leavecs = !(flags & SPI_XFER_END);
+	mpi_tx.s.txnum = tx_data ? len : 0;
+	mpi_tx.s.totnum = len;
+	writeq(mpi_tx.u, baseaddr + MPI_TX);
+
+	octeontx_spi_wait_ready(dev);
+
+	debug("\n ");
+
+	if (rx_data) {
+		for (i = 0; i < len; i++) {
+			*rx_data = readq(baseaddr + MPI_DAT(i)) & 0xff;
+			debug("  rx: %02x\n", *rx_data);
+			rx_data++;
+		}
+	}
+
+	return 0;
+}
+
+#else
+
+static int octeontx_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_xmit mpi_xmit;
+	union mpi_cfg mpi_cfg;
+	u64 wide_dat = 0;
+	int len = bitlen / 8;
+	int rem;
+	int i;
+	const u8 *tx_data = dout;
+	u8 *rx_data = din;
+	int cs = spi_chip_select(dev);
+
+	if (!OCTEONTX_SPI_CS_VALID(cs))
+		return -EINVAL;
+
+	debug("\n %s(%s, %u, %p, %p, 0x%lx), cs: %d\n",
+	      __func__, dev->name, bitlen, dout, din, flags, cs);
+
+	mpi_cfg = octeontx_spi_set_mpicfg(dev);
+
+	/* TRITX must be set to 1 for proper operation */
+	mpi_cfg.s.tritx = 1;
+	mpi_cfg.s.legacy_dis = 1;
+	mpi_cfg.s.cs_sticky = 1;
+#ifdef USE_TBI_CLK
+	mpi_cfg.s.tb100_en = 1;
+#endif
+	mpi_cfg.s.iomode = 0;
+	if (flags & (SPI_TX_DUAL | SPI_RX_DUAL))
+		mpi_cfg.s.iomode = 2;
+	if (flags & (SPI_TX_QUAD | SPI_RX_QUAD))
+		mpi_cfg.s.iomode = 3;
+
+	if (mpi_cfg.u != readq(baseaddr + MPI_CFG)) {
+		writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+		mpi_cfg.u = readq(baseaddr + MPI_CFG);
+		udelay(10);
+	}
+
+	debug("\n mpi_cfg upd %llx\n\n", mpi_cfg.u);
+
+	/* Start by writing or reading 1024 bytes at a time. */
+	while (len > 1024) {
+		if (tx_data) {
+			/* 8 bytes per iteration */
+			for (i = 0; i < 128; i++) {
+				wide_dat = get_unaligned((u64 *)tx_data);
+				debug("  tx: %016llx \t",
+				      (unsigned long long)wide_dat);
+				if ((i % 4) == 3)
+					debug("\n");
+				tx_data += 8;
+				writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+			}
+		}
+
+		mpi_xmit.u = 0;
+		mpi_xmit.s.csid = cs;
+		mpi_xmit.s.leavecs = 1;
+		mpi_xmit.s.txnum = tx_data ? 1024 : 0;
+		mpi_xmit.s.totnum = 1024;
+		writeq(mpi_xmit.u, baseaddr + MPI_XMIT);
+
+		octeontx_spi_wait_ready(dev);
+
+		debug("\n ");
+
+		if (rx_data) {
+			/* 8 bytes per iteration */
+			for (i = 0; i < 128; i++) {
+				wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+				debug("  rx: %016llx\t",
+				      (unsigned long long)wide_dat);
+				if ((i % 4) == 3)
+					debug("\n");
+				*(u64 *)rx_data = wide_dat;
+				rx_data += 8;
+			}
+		}
+		len -= 1024;
+	}
+
+	if (tx_data) {
+		rem = len % 8;
+		/* 8 bytes per iteration */
+		for (i = 0; i < len / 8; i++) {
+			wide_dat = get_unaligned((u64 *)tx_data);
+			debug("  tx: %016llx \t",
+			      (unsigned long long)wide_dat);
+			if ((i % 4) == 3)
+				debug("\n");
+			tx_data += 8;
+			writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+		}
+		if (rem) {
+			memcpy(&wide_dat, tx_data, rem);
+			debug("  rtx: %016llx\t", wide_dat);
+			writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+		}
+	}
+
+	mpi_xmit.u = 0;
+	mpi_xmit.s.csid = cs;
+	mpi_xmit.s.leavecs = !(flags & SPI_XFER_END);
+	mpi_xmit.s.txnum = tx_data ? len : 0;
+	mpi_xmit.s.totnum = len;
+	writeq(mpi_xmit.u, baseaddr + MPI_XMIT);
+
+	octeontx_spi_wait_ready(dev);
+
+	debug("\n ");
+
+	if (rx_data) {
+		rem = len % 8;
+		/* 8 bytes per iteration */
+		for (i = 0; i < len / 8; i++) {
+			wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+			debug("  rx: %016llx\t",
+			      (unsigned long long)wide_dat);
+			if ((i % 4) == 3)
+				debug("\n");
+			*(u64 *)rx_data = wide_dat;
+			rx_data += 8;
+		}
+		if (rem) {
+			wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+			debug("  rrx: %016llx\t",
+			      (unsigned long long)wide_dat);
+			memcpy(rx_data, &wide_dat, rem);
+			rx_data += rem;
+		}
+	}
+
+	return 0;
+}
+
+static bool octeontx_spi_supports_op(struct spi_slave *slave,
+				     const struct spi_mem_op *op)
+{
+	/* For now, support only below combinations
+	 * 1-1-1
+	 * 1-1-2 1-2-2
+	 * 1-1-4 1-4-4
+	 */
+	if (op->cmd.buswidth != 1)
+		return false;
+	return true;
+}
+
+static int octeontx_spi_exec_op(struct spi_slave *slave,
+				const struct spi_mem_op *op)
+{
+	unsigned long flags = SPI_XFER_BEGIN;
+	const void *tx;
+	void *rx;
+	u8 opcode, *buf;
+	u8 *addr;
+	int i, temp, ret;
+
+	if (op->cmd.buswidth != 1)
+		return -ENOTSUPP;
+
+	/* Send CMD */
+	i = 0;
+	opcode = op->cmd.opcode;
+
+	if (!op->data.nbytes && !op->addr.nbytes && !op->dummy.nbytes)
+		flags |= SPI_XFER_END;
+
+	ret = octeontx_spi_xfer(slave->dev, 8, (void *)&opcode, NULL,
+				flags);
+	if (ret < 0)
+		return ret;
+
+	/* Send Address and dummy */
+	if (op->addr.nbytes) {
+		/* Alloc buffer for address+dummy */
+		buf = (u8 *)calloc(1, op->addr.nbytes + op->dummy.nbytes);
+		if (!buf) {
+			printf("%s Out of memory\n", __func__);
+			return -ENOMEM;
+		}
+		addr = (u8 *)&op->addr.val;
+		for (temp = 0; temp < op->addr.nbytes; temp++)
+			buf[i++] = *(u8 *)(addr + op->addr.nbytes - 1 - temp);
+		for (temp = 0; temp < op->dummy.nbytes; temp++)
+			buf[i++] = 0xff;
+		if (op->addr.buswidth == 2)
+			flags |= SPI_RX_DUAL;
+		if (op->addr.buswidth == 4)
+			flags |= SPI_RX_QUAD;
+
+		if (!op->data.nbytes)
+			flags |= SPI_XFER_END;
+		ret = octeontx_spi_xfer(slave->dev, i * 8, (void *)buf, NULL,
+					flags);
+		free(buf);
+		if (ret < 0)
+			return ret;
+	}
+	if (!op->data.nbytes)
+		return 0;
+
+	/* Send/Receive Data */
+	flags |= SPI_XFER_END;
+	if (op->data.buswidth == 2)
+		flags |= SPI_RX_DUAL;
+	if (op->data.buswidth == 4)
+		flags |= SPI_RX_QUAD;
+
+	rx = (op->data.dir == SPI_MEM_DATA_IN) ? op->data.buf.in : NULL;
+	tx = (op->data.dir == SPI_MEM_DATA_OUT) ? op->data.buf.out : NULL;
+
+	ret = octeontx_spi_xfer(slave->dev, (op->data.nbytes * 8), tx, rx,
+				flags);
+	return ret;
+}
+
+static const struct spi_controller_mem_ops octeontx_spi_mem_ops = {
+	.supports_op = octeontx_spi_supports_op,
+	.exec_op = octeontx_spi_exec_op,
+};
+
+#endif
+
+/**
+ * Set the speed of the SPI bus
+ *
+ * @param	bus	bus to set
+ * @param	max_hz	maximum speed supported
+ */
+static int octeontx_spi_set_speed(struct udevice *bus, uint max_hz)
+{
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	u64 refclk = octeontx_get_io_clock();
+	u32 calc_hz;
+
+	debug("%s(%s, %u, %llu)\n", __func__, bus->name, max_hz, refclk);
+
+	if (max_hz > OCTEONTX_SPI_MAX_CLOCK_HZ)
+		max_hz = OCTEONTX_SPI_MAX_CLOCK_HZ;
+
+#ifdef USE_TBI_CLK
+	refclk = OCTEONTX2_TBI_CLK;
+#endif
+	priv->clkdiv = refclk / (2 * max_hz);
+	while (1) {
+		calc_hz = refclk / (2 * priv->clkdiv);
+		if (calc_hz <= max_hz)
+			break;
+		priv->clkdiv += 1;
+	}
+	if (priv->clkdiv > 8191)
+		return -1;
+
+	debug("%s %d\n", __func__, priv->clkdiv);
+
+	return 0;
+}
+
+static int octeontx_spi_set_mode(struct udevice *bus, uint mode)
+{
+	/* We don't set it here */
+	return 0;
+}
+
+static int octeontx_pci_spi_probe(struct udevice *dev)
+{
+	struct octeontx_spi *priv = dev_get_priv(dev);
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+
+	debug("SPI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+	priv->baseaddr = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					PCI_REGION_MEM);
+
+	debug("SPI bus %s %d at %p\n", dev->name, dev->seq, priv->baseaddr);
+
+	return 0;
+}
+
+static const struct dm_spi_ops octeontx_spi_ops = {
+	.claim_bus	= octeontx_spi_claim_bus,
+	.release_bus	= octeontx_spi_release_bus,
+	.xfer		= octeontx_spi_xfer,
+	.set_speed	= octeontx_spi_set_speed,
+	.set_mode	= octeontx_spi_set_mode,
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	.mem_ops	= &octeontx_spi_mem_ops,
+#endif
+};
+
+static const struct udevice_id octeontx_spi_ids[] = {
+	{ .compatible	= "cavium,thunder-8890-spi" },
+	{ .compatible	= "cavium,thunder-8190-spi" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_pci_spi) = {
+	.name			= "spi_octeontx",
+	.id			= UCLASS_SPI,
+	.of_match		= octeontx_spi_ids,
+	.probe			= octeontx_pci_spi_probe,
+	.priv_auto_alloc_size	= sizeof(struct octeontx_spi),
+	.ops			= &octeontx_spi_ops,
+};
+
+static struct pci_device_id octeontx_spi_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, 0xa00b) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_spi, octeontx_spi_supported);
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index bdf8dc6fef..f1d822a6f3 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -8,6 +8,37 @@ config DM_THERMAL
 
 if DM_THERMAL
 
+menu "Thermal Sensor driver"
+
+config MVEBU_THERMAL_SENSOR
+        bool "Enable Thermal Sensor Core driver"
+	depends on MVEBU_THERMAL_SENSOR_28NM || MVEBU_THERMAL_EXT_SENSOR_28NM
+        help
+          This config enables thermal sensor core driver.
+          This driver scans for thermal sensor units,
+          and initializes them.
+	  The config is enabled once one of the thermal
+	  sensors drive is enabled.
+
+config MVEBU_THERMAL_SENSOR_28NM
+	bool "Enable Thermal Sensor 28NM driver"
+	select MVEBU_THERMAL_SENSOR
+	help
+	  Choose this option to add support for
+	  thermal sensor 28nm driver.
+	  This driver init the thermal sensor unit,
+	  and read the tempreture from the unit.
+
+config MVEBU_THERMAL_EXT_SENSOR_28NM
+	bool "Enable Thermal External Sensor 28NM driver"
+	select MVEBU_THERMAL_SENSOR
+	help
+	  Choose this option to add support for
+	  thermal external sensor 28nm driver.
+	  This driver init the External thermal sensor unit,
+	  and read the tempreture from the unit.
+endmenu
+
 config IMX_THERMAL
 	bool "Temperature sensor driver for Freescale i.MX SoCs"
 	depends on MX6 || MX7
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index ef2929d180..f613a8ec32 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -7,3 +7,6 @@ obj-$(CONFIG_DM_THERMAL) += thermal-uclass.o
 obj-$(CONFIG_IMX_THERMAL) += imx_thermal.o
 obj-$(CONFIG_IMX_SCU_THERMAL) += imx_scu_thermal.o
 obj-$(CONFIG_TI_DRA7_THERMAL) += ti-bandgap.o
+obj-$(CONFIG_MVEBU_THERMAL_SENSOR) += mvebu_thermal_core.o
+obj-$(CONFIG_MVEBU_THERMAL_SENSOR_28NM) += mvebu_thermal_28nm.o
+obj-$(CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM) += mvebu_ext_thermal_28nm.o
diff --git a/drivers/thermal/mvebu_ext_thermal_28nm.c b/drivers/thermal/mvebu_ext_thermal_28nm.c
new file mode 100644
index 0000000000..62801d7ba0
--- /dev/null
+++ b/drivers/thermal/mvebu_ext_thermal_28nm.c
@@ -0,0 +1,141 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define THERMAL_TIMEOUT					1200
+
+#define THERMAL_SEN_CTRL_LSB				0x0
+#define THERMAL_SEN_CTRL_LSB_STRT_OFFSET		0
+#define THERMAL_SEN_CTRL_LSB_STRT_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_STRT_OFFSET)
+#define THERMAL_SEN_CTRL_LSB_RST_OFFSET			1
+#define THERMAL_SEN_CTRL_LSB_RST_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_RST_OFFSET)
+#define THERMAL_SEN_CTRL_LSB_EN_OFFSET			2
+#define THERMAL_SEN_CTRL_LSB_EN_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_EN_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS				0x8
+#define THERMAL_SEN_CTRL_STATS_VALID_OFFSET		16
+#define THERMAL_SEN_CTRL_STATS_VALID_MASK		\
+	(0x1 << THERMAL_SEN_CTRL_STATS_VALID_OFFSET)
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET		0
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK		\
+	(0x3FF << THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET)
+
+#define THERMAL_SEN_OUTPUT_MSB				512
+#define THERMAL_SEN_OUTPUT_COMP				1024
+
+s32 mvebu_thermal_ext_sensor_read(struct thermal_unit_config *tsen, int *temp)
+{
+	u32 reg;
+	int ret = 0;
+
+	if (!tsen->tsen_ready) {
+		printf("External Thermal Sensor was not initialized\n");
+		return 0;
+	}
+
+	if (tsen->fw_smc_support) {
+		ret = mvebu_dfx_smc_thermal(MV_SIP_DFX_THERMAL_READ, &reg);
+		if (ret)
+			return ret;
+
+		*temp = reg / tsen->tsen_divisor;
+
+		return ret;
+	}
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	reg = ((reg & THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK) >>
+	      THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET);
+
+	/*
+	 * TSEN output format is signed as a 2s complement number
+	 * ranging from-512 to +511. when MSB is set, need to
+	 * calculate the complement number
+	 */
+	if (reg >= THERMAL_SEN_OUTPUT_MSB)
+		reg -= THERMAL_SEN_OUTPUT_COMP;
+
+	*temp = ((tsen->tsen_gain * ((s32)reg)) + tsen->tsen_offset) /
+	       tsen->tsen_divisor;
+
+	return ret;
+}
+
+static u32 mvebu_thermal_ext_fw_validation(struct thermal_unit_config *tsen)
+{
+	u32 reg = 0, timeout = 0;
+	int ret = SMCCC_RET_SUCCESS;
+
+	debug("%s: fw smc support\n", __func__);
+
+	tsen->fw_smc_support = true;
+
+	while (reg == 0 && timeout < THERMAL_TIMEOUT &&
+	       ret == SMCCC_RET_SUCCESS) {
+		udelay(10);
+		ret = mvebu_dfx_smc_thermal(MV_SIP_DFX_THERMAL_IS_VALID, &reg);
+		timeout++;
+	}
+
+	if (reg == 0 || ret != SMCCC_RET_SUCCESS) {
+		pr_err("%s: thermal.%lx: external sensor is not ready\n",
+		       __func__, (uintptr_t)tsen->regs_base);
+		return -1;
+	}
+
+	debug("thermal.%lx: Initialization done\n", (uintptr_t)tsen->regs_base);
+
+	return 0;
+}
+
+u32 mvebu_thermal_ext_sensor_probe(struct thermal_unit_config *tsen)
+{
+	u32 reg = 0, timeout = 0;
+	int ret;
+
+	debug("thermal.%lx Initializing sensor unit\n",
+	      (uintptr_t)tsen->regs_base);
+
+	/* Try init thermal sensor via firmware, if fails try legacy */
+	ret = mvebu_dfx_smc_thermal(MV_SIP_DFX_THERMAL_INIT, 0x0);
+	if (ret == SMCCC_RET_SUCCESS)
+		return mvebu_thermal_ext_fw_validation(tsen);
+
+	/* Initialize thermal sensor hardware reset once */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_LSB);
+	/* De-assert TSEN_RESET */
+	reg &= ~THERMAL_SEN_CTRL_LSB_RST_OFFSET;
+	/* Set TSEN_EN to 1 */
+	reg |= THERMAL_SEN_CTRL_LSB_EN_MASK;
+	/* Set TSEN_START to 1 */
+	reg |= THERMAL_SEN_CTRL_LSB_STRT_MASK;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL_LSB);
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	while ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0 &&
+	       timeout < THERMAL_TIMEOUT) {
+		udelay(10);
+		reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+		timeout++;
+	}
+	if ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0) {
+		pr_err("%s: thermal.%lx: external sensor is not ready\n",
+		       __func__, (uintptr_t)tsen->regs_base);
+		return -1;
+	}
+
+	debug("thermal.%lx: Initialization done\n", (uintptr_t)tsen->regs_base);
+
+	return 0;
+}
diff --git a/drivers/thermal/mvebu_thermal_28nm.c b/drivers/thermal/mvebu_thermal_28nm.c
new file mode 100644
index 0000000000..1cb5367398
--- /dev/null
+++ b/drivers/thermal/mvebu_thermal_28nm.c
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define THERMAL_SEN_CTRL			0x0
+#define THERMAL_SEN_TC_TRIM_OFFSET		0
+#define THERMAL_SEN_TC_TRIM_MASK		\
+	(0x7 << THERMAL_SEN_TC_TRIM_OFFSET)
+
+#define THERMAL_SEN_CTRL_MSB			0x4
+#define THERMAL_SEN_CTRL_MSB_RST_OFFSET		8
+#define THERMAL_SEN_CTRL_MSB_RST_MASK		\
+	(0x1 << THERMAL_SEN_CTRL_MSB_RST_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS			0x8
+#define THERMAL_SEN_CTRL_STATS_VALID_OFFSET	10
+#define THERMAL_SEN_CTRL_STATS_VALID_MASK	\
+	(0x1 << THERMAL_SEN_CTRL_STATS_VALID_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET	0
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK	\
+	(0x3FF << THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET)
+
+s32 mvebu_thermal_sensor_read(struct thermal_unit_config *tsen, int *temp)
+{
+	u32 reg;
+
+	if (!tsen->tsen_ready) {
+		printf("Thermal Sensor was not initialized\n");
+		return 0;
+	}
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	reg = ((reg & THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK) >>
+	      THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET);
+
+	*temp = ((tsen->tsen_gain * ((s32)reg)) - tsen->tsen_offset) /
+	       tsen->tsen_divisor;
+
+	return 0;
+}
+
+u32 mvebu_thermal_sensor_probe(struct thermal_unit_config *tsen)
+{
+	u32 reg, timeout = 0;
+
+	debug("thermal.%lx Initializing sensor unit\n",
+	      (uintptr_t)tsen->regs_base);
+
+	/* Initialize thermal sensor hardware reset once */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_MSB);
+	reg |= THERMAL_SEN_CTRL_MSB_RST_MASK;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL_MSB);
+
+	/* set Tsen Tc Trim to correct default value (errata #132698) */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL);
+	reg &= ~THERMAL_SEN_TC_TRIM_MASK;
+	reg |= 0x3;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL);
+
+	/* Check that Sensor is ready */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	while ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0 &&
+	       timeout < 300) {
+		udelay(1);
+		reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+		timeout++;
+	}
+
+	if ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0) {
+		pr_err("%s: thermal.%lx: sensor is not ready\n", __func__,
+		       (uintptr_t)tsen->regs_base);
+		return -1;
+	}
+
+	debug("thermal.%lx: Initialization done\n", (uintptr_t)tsen->regs_base);
+
+	return 0;
+}
diff --git a/drivers/thermal/mvebu_thermal_core.c b/drivers/thermal/mvebu_thermal_core.c
new file mode 100644
index 0000000000..8b8190babf
--- /dev/null
+++ b/drivers/thermal/mvebu_thermal_core.c
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+#include <dm.h>
+#include <thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct thermal_unit_config *init_thermal_config(struct udevice *dev)
+{
+	struct thermal_unit_config *thermal_cfg = dev_get_priv(dev);
+	void *blob = (void *)gd->fdt_blob;
+	int node = dev_of_offset(dev);
+
+	/* Read register base */
+	thermal_cfg->regs_base = (void *)devfdt_get_addr_index(dev, 0);
+
+	if (thermal_cfg->regs_base == 0) {
+		pr_err("thermal: base address is missing in device-tree\n");
+		return NULL;
+	}
+
+	/* Register functions (according to compatible) */
+	if (device_is_compatible(dev, "marvell,thermal-sensor")) {
+		thermal_cfg->ptr_thermal_sensor_probe =
+			mvebu_thermal_sensor_probe;
+		thermal_cfg->ptr_thermal_sensor_read =
+			mvebu_thermal_sensor_read;
+	}
+
+	if (device_is_compatible(dev, "marvell,thermal-ext-sensor")) {
+		thermal_cfg->ptr_thermal_sensor_probe =
+			mvebu_thermal_ext_sensor_probe;
+		thermal_cfg->ptr_thermal_sensor_read =
+			mvebu_thermal_ext_sensor_read;
+	}
+
+	if (!thermal_cfg->ptr_thermal_sensor_probe ||
+	    !thermal_cfg->ptr_thermal_sensor_read) {
+		pr_err("thermal.%lx: compatible is not supported\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	/* Read temperature calculation parameters */
+	thermal_cfg->tsen_gain = fdtdec_get_int(blob, node, "gain", 0);
+	if (thermal_cfg->tsen_gain <= 0) {
+		pr_err("thermal%lx: gain is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	thermal_cfg->tsen_offset = fdtdec_get_int(blob, node, "offset", 0);
+	if (thermal_cfg->tsen_offset <= 0) {
+		pr_err("thermal%lx: offset is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	thermal_cfg->tsen_divisor = fdtdec_get_int(blob, node, "divisor", 0);
+	if (thermal_cfg->tsen_divisor <= 0) {
+		pr_err("thermal%lx: divisor is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	return thermal_cfg;
+}
+
+int mvebu_thermal_read(struct udevice *dev, int *temp)
+{
+	struct thermal_unit_config *thermal_cfg;
+
+	if (!temp) {
+		pr_err("NULL pointer for temperature read\n");
+		return -1;
+	}
+
+	thermal_cfg = dev_get_priv(dev);
+
+	if (thermal_cfg->ptr_thermal_sensor_read == 0 ||
+	    thermal_cfg->tsen_ready == 0) {
+		debug("Thermal unit was not initialized\n");
+		return -1;
+	}
+
+	return thermal_cfg->ptr_thermal_sensor_read(thermal_cfg, temp);
+}
+
+static const struct dm_thermal_ops mvebu_thermal_ops = {
+	.get_temp	= mvebu_thermal_read,
+};
+
+static int mvebu_thermal_probe(struct udevice *dev)
+{
+	struct thermal_unit_config *thermal_cfg = dev_get_priv(dev);
+
+	/* Init Sensor data structure */
+	thermal_cfg = init_thermal_config(dev);
+	if (!thermal_cfg) {
+		pr_err("Thermal: failed to initialize thermal data structure\n");
+		return -1;
+	}
+
+	/* set flag to indicate that Thermal Sensor is not ready */
+	thermal_cfg->tsen_ready = 0;
+
+	/* Sensor init */
+	if (thermal_cfg->ptr_thermal_sensor_probe(thermal_cfg)) {
+		pr_err("thermal.%lx: failed to initialize thermal info\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return -1; /* initialization failed */
+	}
+
+	/* Thermal Sensor is ready to use */
+	thermal_cfg->tsen_ready = 1;
+
+	debug("thermal.%lx: Initialized\n", (uintptr_t)thermal_cfg->regs_base);
+
+	return 0;
+}
+
+static const struct udevice_id mvebu_thermal_ids[] = {
+	{ .compatible = "marvell,mvebu-thermal" },
+	{ }
+};
+
+U_BOOT_DRIVER(mvebu_thermal) = {
+	.name	= "mvebu-thermal",
+	.id	= UCLASS_THERMAL,
+	.ops	= &mvebu_thermal_ops,
+	.of_match = mvebu_thermal_ids,
+	.probe	= mvebu_thermal_probe,
+	.priv_auto_alloc_size = sizeof(struct thermal_unit_config),
+};
diff --git a/drivers/usb/eth/usb_ether.c b/drivers/usb/eth/usb_ether.c
index 3aca9ac265..8821f7bcc6 100644
--- a/drivers/usb/eth/usb_ether.c
+++ b/drivers/usb/eth/usb_ether.c
@@ -240,6 +240,7 @@ static void probe_valid_drivers(struct usb_device *dev)
 			if (eth_write_hwaddr(eth, "usbeth",
 					usb_max_eth_dev - 1))
 				puts("Warning: failed to set MAC address\n");
+			printf("	%s ", eth->name);
 			break;
 			}
 		}
diff --git a/drivers/usb/host/ehci-marvell.c b/drivers/usb/host/ehci-marvell.c
index 8efe6b63b9..a52560d719 100644
--- a/drivers/usb/host/ehci-marvell.c
+++ b/drivers/usb/host/ehci-marvell.c
@@ -12,6 +12,7 @@
 #include <linux/mbus.h>
 #include <asm/arch/cpu.h>
 #include <dm.h>
+#include <power/regulator.h>
 
 #if defined(CONFIG_KIRKWOOD)
 #include <asm/arch/soc.h>
@@ -103,6 +104,10 @@ static int ehci_mvebu_probe(struct udevice *dev)
 	struct ehci_mvebu_priv *priv = dev_get_priv(dev);
 	struct ehci_hccr *hccr;
 	struct ehci_hcor *hcor;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *regulator;
+	int ret;
+#endif
 
 	/*
 	 * Get the base address for EHCI controller from the device node
@@ -125,6 +130,18 @@ static int ehci_mvebu_probe(struct udevice *dev)
 	else
 		usb_brg_adrdec_setup((void *)priv->hcd_base);
 
+	/* Enable VBUS */
+#ifdef CONFIG_DM_REGULATOR
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, true);
+		if (ret) {
+			printf("Failed to turn ON the VBUS regulator\n");
+			return ret;
+		}
+	}
+#endif
+
 	hccr = (struct ehci_hccr *)(priv->hcd_base + 0x100);
 	hcor = (struct ehci_hcor *)
 		((uintptr_t)hccr + HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
@@ -137,6 +154,32 @@ static int ehci_mvebu_probe(struct udevice *dev)
 			     USB_INIT_HOST);
 }
 
+static int ehci_usb_remove(struct udevice *dev)
+{
+	int ret;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *regulator;
+#endif
+
+	ret = ehci_deregister(dev);
+	if (ret)
+		return ret;
+
+	/* Disable VBUS */
+#ifdef CONFIG_DM_REGULATOR
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the VBUS regulator\n");
+			return ret;
+		}
+	}
+#endif
+
+	return 0;
+}
+
 static const struct udevice_id ehci_usb_ids[] = {
 	{ .compatible = "marvell,orion-ehci", },
 	{ .compatible = "marvell,armada3700-ehci", },
@@ -148,7 +191,7 @@ U_BOOT_DRIVER(ehci_mvebu) = {
 	.id	= UCLASS_USB,
 	.of_match = ehci_usb_ids,
 	.probe = ehci_mvebu_probe,
-	.remove = ehci_deregister,
+	.remove = ehci_usb_remove,
 	.ops	= &ehci_usb_ops,
 	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
 	.priv_auto_alloc_size = sizeof(struct ehci_mvebu_priv),
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 84c2c3344a..977f6507a0 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -177,6 +177,9 @@ void xhci_cleanup(struct xhci_ctrl *ctrl)
 	xhci_free_virt_devices(ctrl);
 	free(ctrl->erst.entries);
 	free(ctrl->dcbaa);
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	free(ctrl->rx_bounce_buffer);
+#endif
 	memset(ctrl, '\0', sizeof(struct xhci_ctrl));
 }
 
@@ -509,6 +512,13 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 	int i;
 	struct xhci_segment *seg;
 
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	ctrl->rx_bounce_buffer = memalign(65536, 65536);
+	if (!ctrl->rx_bounce_buffer) {
+		puts("unable to allocate OcteonTX2 RX bounce buffer\n");
+		return -ENOMEM;
+	}
+#endif
 	/* DCBAA initialization */
 	ctrl->dcbaa = (struct xhci_device_context_array *)
 			xhci_malloc(sizeof(struct xhci_device_context_array));
diff --git a/drivers/usb/host/xhci-mvebu.c b/drivers/usb/host/xhci-mvebu.c
index b6c6aaf78e..a5e1978523 100644
--- a/drivers/usb/host/xhci-mvebu.c
+++ b/drivers/usb/host/xhci-mvebu.c
@@ -58,12 +58,53 @@ static int xhci_usb_probe(struct udevice *dev)
 		}
 	}
 
+	ret = device_get_supply_regulator(dev, "current-limiter", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, true);
+		if (ret) {
+			printf("Failed to turn ON the %s regulator\n",
+			       regulator->name);
+			return ret;
+		}
+	}
+
 	/* Enable USB xHCI (VBUS, reset etc) in board specific code */
 	board_xhci_enable(devfdt_get_addr_index(dev, 1));
 
 	return xhci_register(dev, ctx->hcd, hcor);
 }
 
+static int xhci_usb_remove(struct udevice *dev)
+{
+	int ret;
+	struct udevice *regulator;
+
+	ret = xhci_deregister(dev);
+	if (ret)
+		return ret;
+
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the VBUS regulator\n");
+			return ret;
+		}
+	}
+
+	ret = device_get_supply_regulator(dev, "current-limiter", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the %s regulator\n",
+			       regulator->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int xhci_usb_ofdata_to_platdata(struct udevice *dev)
 {
 	struct mvebu_xhci_platdata *plat = dev_get_platdata(dev);
@@ -93,7 +134,7 @@ U_BOOT_DRIVER(usb_xhci) = {
 	.of_match = xhci_usb_ids,
 	.ofdata_to_platdata = xhci_usb_ofdata_to_platdata,
 	.probe = xhci_usb_probe,
-	.remove = xhci_deregister,
+	.remove = xhci_usb_remove,
 	.ops	= &xhci_usb_ops,
 	.platdata_auto_alloc_size = sizeof(struct mvebu_xhci_platdata),
 	.priv_auto_alloc_size = sizeof(struct mvebu_xhci),
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index b2cfd948f8..17987ad559 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -575,6 +575,10 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	int ret;
 	u32 trb_fields[4];
 	u64 val_64 = (uintptr_t)buffer;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	void *orig_buffer = buffer;
+	bool use_rx_bounce = false;
+#endif
 
 	debug("dev=%p, pipe=%lx, buffer=%p, length=%d\n",
 		udev, pipe, buffer, length);
@@ -594,6 +598,21 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	 * that the buffer should not span 64KB boundary. if so
 	 * we send request in more than 1 TRB by chaining them.
 	 */
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	/* There is a bug in the designware core used in the OcteonTX2 where
+	 * buffers that cross TRB boundaries cause an extra event to be
+	 * generated and the lengths reported by those events are corrupt.
+	 * In order to work around this, a 64K bounce buffer is used.
+	 */
+	if (usb_pipein(pipe) && (length <= TRB_MAX_BUFF_SIZE) &&
+	    (((uintptr_t)buffer & ~(TRB_MAX_BUFF_SIZE - 1)) !=
+	     (((uintptr_t)buffer + length) & ~(TRB_MAX_BUFF_SIZE - 1)))) {
+		use_rx_bounce = true;
+		orig_buffer = buffer;
+		buffer = ctrl->rx_bounce_buffer;
+		val_64 = (uintptr_t)buffer;
+	}
+#endif
 	running_total = TRB_MAX_BUFF_SIZE -
 			(lower_32_bits(val_64) & (TRB_MAX_BUFF_SIZE - 1));
 	trb_buff_len = running_total;
@@ -730,6 +749,10 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	xhci_acknowledge_event(ctrl);
 	xhci_inval_cache((uintptr_t)buffer, length);
 
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	if (use_rx_bounce)
+		memcpy(orig_buffer, buffer, udev->act_len);
+#endif
 	return (udev->status != USB_ST_NOT_PROC) ? 0 : -1;
 }
 
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index b3e4dcd66f..575ba5cbd2 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1164,6 +1164,8 @@ static int _xhci_submit_control_msg(struct usb_device *udev, unsigned long pipe,
 	struct xhci_ctrl *ctrl = xhci_get_ctrl(udev);
 	int ret = 0;
 
+	udelay(100);
+
 	if (usb_pipetype(pipe) != PIPE_CONTROL) {
 		printf("non-control pipe (type=%lu)", usb_pipetype(pipe));
 		return -EINVAL;
@@ -1513,7 +1515,6 @@ int xhci_register(struct udevice *dev, struct xhci_hccr *hccr,
 
 	return 0;
 err:
-	free(ctrl);
 	debug("%s: failed, ret=%d\n", __func__, ret);
 	return ret;
 }
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6017504488..65f44fb637 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1230,6 +1230,16 @@ struct xhci_ctrl {
 	struct xhci_scratchpad *scratchpad;
 	struct xhci_virt_device *devs[MAX_HC_SLOTS];
 	int rootdev;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	/* The Marvell OcteonTX2 SOCs have a problem where if the receive
+	 * buffer crosses a 64K boundary then the response events get
+	 * corrupted.  In this case, a 64K bounce buffer is used instead,
+	 * guaranteeing that this case will never happen.  It introduces
+	 * a slight performance penalty since all received data must be
+	 * copied from the bounce buffer to the user-supplied buffer.
+	 */
+	void *rx_bounce_buffer;
+#endif
 };
 
 unsigned long trb_addr(struct xhci_segment *seg, union xhci_trb *trb);
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index a66a9bcbe2..68bfa92f41 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -112,6 +112,16 @@ config WDT_MTK
 	  The watchdog timer is stopped when initialized.
 	  It performs full SoC reset.
 
+config WDT_OCTEONTX
+	bool "OcteonTX core watchdog support"
+	depends on WDT && (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	default y if WDT && ARCH_OCTEONTX || ARCH_OCTEONTX2
+	imply WATCHDOG
+	help
+	  This enables OcteonTX watchdog driver, which can be
+	  found on OcteonTX/TX2 chipsets and inline with driver model.
+	  Only supports watchdog reset.
+
 config WDT_OMAP3
         bool "TI OMAP watchdog timer support"
         depends on WDT && ARCH_OMAP2PLUS
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 955caef815..66b20b0e98 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_WDT_CDNS) += cdns_wdt.o
 obj-$(CONFIG_WDT_MPC8xx) += mpc8xx_wdt.o
 obj-$(CONFIG_WDT_MT7621) += mt7621_wdt.o
 obj-$(CONFIG_WDT_MTK) += mtk_wdt.o
+obj-$(CONFIG_WDT_OCTEONTX) += octeontx_wdt.o
 obj-$(CONFIG_WDT_OMAP3) += omap_wdt.o
 obj-$(CONFIG_WDT_SP805) += sp805_wdt.o
 obj-$(CONFIG_WDT_STM32MP) += stm32mp_wdt.o
diff --git a/drivers/watchdog/octeontx_wdt.c b/drivers/watchdog/octeontx_wdt.c
new file mode 100644
index 0000000000..9362ad99bf
--- /dev/null
+++ b/drivers/watchdog/octeontx_wdt.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <wdt.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define CORE0_POKE_OFFSET 0x50000
+
+#if CONFIG_IS_ENABLED(ARCH_OCTEONTX)
+#define REG_BASE 0x844000000000
+#elif CONFIG_IS_ENABLED(ARCH_OCTEONTX2)
+#define REG_BASE 0x802000000000
+#endif
+
+struct octeontx_wdt {
+	void __iomem *reg;
+};
+
+static struct udevice *wdt_dev;
+
+static int octeontx_wdt_reset(struct udevice *dev)
+{
+	struct octeontx_wdt *priv;
+	u64 poke_reg;
+
+	if (dev) {
+		priv = dev_get_priv(dev);
+		poke_reg = ((u64)priv->reg & ~0xfffffULL) | CORE0_POKE_OFFSET;
+	} else {
+		poke_reg = REG_BASE + CORE0_POKE_OFFSET;
+	}
+	writeq(~0ULL, poke_reg);
+
+	return 0;
+}
+
+static int octeontx_wdt_probe(struct udevice *dev)
+{
+	struct octeontx_wdt *priv = dev_get_priv(dev);
+	fdt_addr_t addr;
+
+	addr = dev_read_addr_index(dev, 0);
+	if (addr == FDT_ADDR_T_NONE)
+		return -ENODEV;
+
+	priv->reg = (void __iomem *)addr;
+	wdt_dev = dev;
+
+	return 0;
+}
+
+static const struct wdt_ops octeontx_wdt_ops = {
+	.reset = octeontx_wdt_reset,
+};
+
+static const struct udevice_id octeontx_wdt_ids[] = {
+	{ .compatible = "arm,sbsa-gwdt" },
+	{}
+};
+
+U_BOOT_DRIVER(wdt_octeontx) = {
+	.name = "wdt_octeontx",
+	.id = UCLASS_WDT,
+	.of_match = octeontx_wdt_ids,
+	.ops = &octeontx_wdt_ops,
+	.priv_auto_alloc_size = sizeof(struct octeontx_wdt),
+	.probe = octeontx_wdt_probe,
+};
diff --git a/env/common.c b/env/common.c
index 4daaa6faea..4e5cd23252 100644
--- a/env/common.c
+++ b/env/common.c
@@ -85,6 +85,18 @@ void env_set_default(const char *s, int flags)
 
 	gd->flags |= GD_FLG_ENV_READY;
 	gd->flags |= GD_FLG_ENV_DEFAULT;
+
+#ifdef CONFIG_CMD_MVEBU_HW_INFO
+		/* load the HW configuration from EEPROM to env variables and
+		 * saveenv.
+		 * This is because when the env varibles are reset, need to
+		 * recover the HW configuration related env varibles from
+		 * EEPROM.
+		 * The only generic U-Boot env variable that will be overwrote
+		 * here will be the Marvell specific variables
+		 */
+		cmd_hw_info_load(NULL, 1);
+#endif /* CONFIG_CMD_MVEBU_HW_INFO */
 }
 
 
diff --git a/env/sf.c b/env/sf.c
index 590d0cedd8..8313193bd5 100644
--- a/env/sf.c
+++ b/env/sf.c
@@ -42,8 +42,19 @@ static int setup_flash_device(void)
 	struct udevice *new;
 	int	ret;
 
+#ifdef CONFIG_ARCH_OCTEONTX2
+	int bus, cs;
+extern void board_get_env_spi_bus_cs(int *bus, int *cs);
+
+	board_get_env_spi_bus_cs(&bus, &cs);
+	if (bus < 0) {
+		/* Default to config */
+		bus = CONFIG_ENV_SPI_BUS;
+		cs = CONFIG_ENV_SPI_CS;
+	}
+
 	/* speed and mode will be read from DT */
-	ret = spi_flash_probe_bus_cs(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+	ret = spi_flash_probe_bus_cs(bus, cs,
 				     CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE,
 				     &new);
 	if (ret) {
@@ -51,6 +62,16 @@ static int setup_flash_device(void)
 		return ret;
 	}
 
+#else
+	/* speed and mode will be read from DT */
+	ret = spi_flash_probe_bus_cs(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+				     CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE,
+				     &new);
+	if (ret) {
+		env_set_default("spi_flash_probe_bus_cs() failed", 0);
+		return ret;
+	}
+#endif
 	env_flash = dev_get_uclass_priv(new);
 #else
 
diff --git a/fs/ext4/ext4_common.c b/fs/ext4/ext4_common.c
index 5bf78b530a..f67c9aee51 100644
--- a/fs/ext4/ext4_common.c
+++ b/fs/ext4/ext4_common.c
@@ -26,6 +26,7 @@
 #include <stddef.h>
 #include <linux/stat.h>
 #include <linux/time.h>
+#include <u-boot/crc.h>
 #include <asm/byteorder.h>
 #include "ext4_common.h"
 
@@ -105,6 +106,15 @@ static inline void ext4fs_bg_itable_unused_dec
 		bg->bg_itable_unused_high = cpu_to_le16(free_inodes >> 16);
 }
 
+static inline void ext4fs_bg_itable_unused_set(struct ext2_block_group *bg,
+					       const struct ext_filesystem *fs,
+					       uint32_t free_inodes)
+{
+	bg->bg_itable_unused = cpu_to_le16(free_inodes & 0xffff);
+	if (fs->gdsize == 64)
+		bg->bg_itable_unused_high = cpu_to_le16(free_inodes >> 16);
+}
+
 uint64_t ext4fs_sb_get_free_blocks(const struct ext2_sblock *sb)
 {
 	uint64_t free_blocks = le32_to_cpu(sb->free_blocks);
@@ -413,27 +423,48 @@ void ext4fs_reset_inode_bmap(int inode_no, unsigned char *buffer, int index)
 		*ptr = *ptr & ~(operand);
 }
 
+static inline uint32_t ext4_chksum(uint32_t crc, const void *address,
+				   uint32_t length)
+{
+	return crc32(crc, address, length);
+}
+
 uint16_t ext4fs_checksum_update(uint32_t i)
 {
 	struct ext2_block_group *desc;
 	struct ext_filesystem *fs = get_fs();
 	uint16_t crc = 0;
 	__le32 le32_i = cpu_to_le32(i);
+	int offset = offsetof(struct ext2_block_group, bg_checksum);
 
 	desc = ext4fs_get_group_descriptor(fs, i);
 	if (le32_to_cpu(fs->sb->feature_ro_compat) & EXT4_FEATURE_RO_COMPAT_GDT_CSUM) {
-		int offset = offsetof(struct ext2_block_group, bg_checksum);
 
 		crc = ext2fs_crc16(~0, fs->sb->unique_id,
 				   sizeof(fs->sb->unique_id));
 		crc = ext2fs_crc16(crc, &le32_i, sizeof(le32_i));
 		crc = ext2fs_crc16(crc, desc, offset);
 		offset += sizeof(desc->bg_checksum);	/* skip checksum */
-		assert(offset == sizeof(*desc));
+		/*assert(offset == sizeof(*desc));*/
 		if (offset < fs->gdsize) {
 			crc = ext2fs_crc16(crc, (__u8 *)desc + offset,
 					   fs->gdsize - offset);
 		}
+	} else if (le32_to_cpu(fs->sb->feature_ro_compat) &
+		   EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) {
+		uint32_t crc32;
+		uint16_t dummy_csum = 0;
+
+		crc32 = ext4_chksum(~0, fs->sb->unique_id,
+				    sizeof(fs->sb->unique_id));
+		crc32 = ext4_chksum(crc32, &le32_i, sizeof(le32_i));
+		crc32 = ext4_chksum(crc32, desc, offset);
+		offset += sizeof(dummy_csum);
+		crc32 = ext4_chksum(crc32, &dummy_csum, sizeof(dummy_csum));
+		if (offset < fs->gdsize)
+			crc32 = ext4_chksum(crc32, (uint8_t *)desc + offset,
+					    fs->gdsize - offset);
+		crc = crc32 & 0xffff;
 	}
 
 	return crc;
@@ -763,7 +794,8 @@ int ext4fs_get_parent_inode_num(const char *dirname, char *dname, int flags)
 	struct ext2_inode temp_inode;
 
 	if (*dirname != '/') {
-		printf("Please supply Absolute path\n");
+		printf("Please supply Absolute path, \"%s\" invalid\n",
+		       dirname);
 		return -1;
 	}
 
@@ -1110,7 +1142,8 @@ int ext4fs_get_new_inode_no(void)
 				uint64_t i_bitmap_blk =
 					ext4fs_bg_get_inode_id(bgd, fs);
 				if (has_gdt_chksum)
-					bgd->bg_itable_unused = free_inodes;
+					ext4fs_bg_itable_unused_set(bgd, fs,
+								free_inodes);
 				if (bg_flags & EXT4_BG_INODE_UNINIT) {
 					put_ext4(i_bitmap_blk * fs->blksz,
 						 zero_buffer, fs->blksz);
diff --git a/fs/ext4/ext4_write.c b/fs/ext4/ext4_write.c
index 3368bd8c00..3e6ef61841 100644
--- a/fs/ext4/ext4_write.c
+++ b/fs/ext4/ext4_write.c
@@ -918,7 +918,7 @@ int ext4fs_write(const char *fname, const char *buffer,
 	blks_reqd_for_file = lldiv(bytes_reqd_for_file, fs->blksz);
 	if (do_div(bytes_reqd_for_file, fs->blksz) != 0) {
 		blks_reqd_for_file++;
-		debug("total bytes for a file %u\n", blks_reqd_for_file);
+		debug("total blocks for a file %u\n", blks_reqd_for_file);
 	}
 	blocks_remaining = blks_reqd_for_file;
 	/* test for available space in partition */
diff --git a/include/ahci.h b/include/ahci.h
index fb96dd8861..673473deeb 100644
--- a/include/ahci.h
+++ b/include/ahci.h
@@ -40,6 +40,9 @@
 #define HOST_IRQ_EN		(1 << 1)  /* global IRQ enable */
 #define HOST_AHCI_EN		(1 << 31) /* AHCI enabled */
 
+/* HOST_CAP bits */
+#define HOST_64BIT		(1 << 31) /* 64-Bit Addressing */
+
 /* Registers for each SATA port */
 #define PORT_LST_ADDR		0x00 /* command list DMA addr */
 #define PORT_LST_ADDR_HI	0x04 /* command list DMA addr hi */
@@ -137,8 +140,8 @@ struct ahci_ioports {
 	void __iomem	*port_mmio;
 	struct ahci_cmd_hdr	*cmd_slot;
 	struct ahci_sg		*cmd_tbl_sg;
-	ulong	cmd_tbl;
-	u32	rx_fis;
+	u64	cmd_tbl;
+	u64	rx_fis;
 };
 
 /**
diff --git a/include/cavium/atf.h b/include/cavium/atf.h
index 3cf05c43d7..1658e9c5a5 100644
--- a/include/cavium/atf.h
+++ b/include/cavium/atf.h
@@ -17,5 +17,5 @@ ssize_t atf_dram_size(unsigned int node);
 ssize_t atf_node_count(void);
 ssize_t atf_env_count(void);
 ssize_t atf_env_string(size_t index, char *str);
-
+ssize_t atf_get_bdk_fdt(void *buffer, size_t buffer_size);
 #endif
diff --git a/include/cavium/thunderx_svc.h b/include/cavium/thunderx_svc.h
index de36d66230..a75b968a13 100644
--- a/include/cavium/thunderx_svc.h
+++ b/include/cavium/thunderx_svc.h
@@ -63,4 +63,7 @@
 
 #define THUNDERX_NODE_COUNT		0x43000601
 
+/* x1 - user buffer, x2 - buffer size */
+#define THUNDERX_FDT_GET                0x43000701
+
 #endif /* __THUNDERX_SVC_H__ */
diff --git a/include/configs/db-88f6820-ap.h b/include/configs/db-88f6820-ap.h
new file mode 100644
index 0000000000..9170ef7464
--- /dev/null
+++ b/include/configs/db-88f6820-ap.h
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ */
+
+#ifndef _CONFIG_DB_88F6820_AP_H
+#define _CONFIG_DB_88F6820_AP_H
+
+/*
+ * High Level Configuration Options (easy to change)
+ */
+
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+/*
+ * TEXT_BASE needs to be below 16MiB, since this area is scrubbed
+ * for DDR ECC byte filling in the SPL before loading the main
+ * U-Boot into it.
+ */
+/* #define	CONFIG_SYS_TEXT_BASE	0x01800000 */
+#define	CONFIG_SYS_TEXT_BASE	0x00800000
+#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
+
+/*
+ * Commands configuration
+ */
+#define CONFIG_CMD_PCI
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MVTWSI
+#define CONFIG_I2C_MVTWSI_BASE0		MVEBU_TWSI_BASE
+#define CONFIG_SYS_I2C_SLAVE		0x0
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* SPI NOR flash default params, used by sf commands */
+#define CONFIG_SF_DEFAULT_SPEED		1000000
+
+/*
+ * SDIO/MMC Card Configuration
+ */
+#define CONFIG_SYS_MMC_BASE		MVEBU_SDIO_BASE
+
+/*
+ * SATA/SCSI/AHCI configuration
+ */
+#define CONFIG_LIBATA
+#define CONFIG_SCSI_AHCI
+#define CONFIG_SCSI_AHCI_PLAT
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
+#define CONFIG_SYS_SCSI_MAX_LUN		1
+#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+					 CONFIG_SYS_SCSI_MAX_LUN)
+
+/* Partition support */
+
+/* USB/EHCI configuration */
+#define CONFIG_EHCI_IS_TDI
+
+/* NAND configuration */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+
+/* Environment in NAND flash */
+#define CONFIG_ENV_OFFSET		(5 << 20) /* 5MiB in */
+#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
+#define CONFIG_ENV_SECT_SIZE		(256 << 10) /* 256KiB sectors */
+
+#define CONFIG_PHY_MARVELL		/* there is a marvell phy */
+#define PHY_ANEG_TIMEOUT	8000	/* PHY needs a longer aneg time */
+
+/* PCIe support */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_PCI_SCAN_SHOW
+#endif
+
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlyprintk=ttyS0,115200"
+
+/* SPL */
+/*
+ * Select the boot device here
+ *
+ * Currently supported are:
+ * SPL_BOOT_SPI_NOR_FLASH	- Booting via SPI NOR flash
+ * SPL_BOOT_SDIO_MMC_CARD	- Booting via SDIO/MMC card (partition 1)
+ */
+#define SPL_BOOT_SPI_NOR_FLASH		1
+#define SPL_BOOT_SDIO_MMC_CARD		2
+#define SPL_BOOT_SDIO_NAND		3
+#define CONFIG_SPL_BOOT_DEVICE		SPL_BOOT_SDIO_NAND
+
+/* Defines for SPL */
+#define CONFIG_SPL_SIZE			(150 << 10)
+#define CONFIG_SPL_TEXT_BASE		0x40000030
+#define CONFIG_SPL_MAX_SIZE		(CONFIG_SPL_SIZE - 0x0030)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MALLOC_SIMPLE
+#endif
+
+#define CONFIG_SPL_STACK		(0x40000000 + ((192 - 16) << 10))
+#define CONFIG_SPL_BOOTROM_SAVE		(CONFIG_SPL_STACK + 4)
+
+#if CONFIG_SPL_BOOT_DEVICE == SPL_BOOT_SPI_NOR_FLASH
+/* SPL related SPI defines */
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x26000
+#define CONFIG_SYS_U_BOOT_OFFS		CONFIG_SYS_SPI_U_BOOT_OFFS
+#endif
+
+#if CONFIG_SPL_BOOT_DEVICE == SPL_BOOT_SDIO_MMC_CARD
+/* SPL related MMC defines */
+#define CONFIG_SYS_MMC_U_BOOT_OFFS		(160 << 10)
+#define CONFIG_SYS_U_BOOT_OFFS			CONFIG_SYS_MMC_U_BOOT_OFFS
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_FIXED_SDHCI_ALIGNED_BUFFER	0x00180000	/* in SDRAM */
+#endif
+#endif
+
+/*
+ * mv-common.h should be defined after CMD configs since it used them
+ * to enable certain macros
+ */
+#include "mv-common.h"
+
+#endif /* _CONFIG_DB_88F6820_AP_H */
diff --git a/include/configs/db-88f6820-gp.h b/include/configs/db-88f6820-gp.h
index 900c962679..929a71c2c5 100644
--- a/include/configs/db-88f6820-gp.h
+++ b/include/configs/db-88f6820-gp.h
@@ -23,6 +23,12 @@
 #define CONFIG_SYS_I2C_SLAVE		0x0
 #define CONFIG_SYS_I2C_SPEED		100000
 
+/*
+ * SPI Flash configuration for the environemnt access
+ */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+
 /*
  * SDIO/MMC Card Configuration
  */
@@ -52,10 +58,8 @@
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
-/* Keep device tree and initrd in lower memory so the kernel can access them */
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-	"fdt_high=0x10000000\0"		\
-	"initrd_high=0x10000000\0"
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlyprintk=ttyS0,115200"
 
 /* SPL */
 /*
diff --git a/include/configs/mv-common.h b/include/configs/mv-common.h
index a041ddb79b..171e8cc83e 100644
--- a/include/configs/mv-common.h
+++ b/include/configs/mv-common.h
@@ -75,4 +75,61 @@
 #define CONFIG_SYS_MAX_NAND_DEVICE     1
 #endif
 
+/* Default Env vars */
+#define CONFIG_IPADDR			0.0.0.0	/* In order to cause an error */
+#define CONFIG_SERVERIP			0.0.0.0	/* In order to cause an error */
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		10.4.50.254
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETHPRIME			"eth0"
+#define CONFIG_ROOTPATH                 "/srv/nfs/" /* Default Dir for NFS */
+#define CONFIG_ENV_OVERWRITE		/* ethaddr can be reprogrammed */
+#define CONFIG_EXTRA_ENV_SETTINGS	"bootcmd=run get_images; " \
+						"run set_bootargs; " \
+						"bootz $kernel_addr_r " \
+						"$ramdisk_addr_r " \
+						"$fdt_addr_r\0" \
+					"extra_params=pci=pcie_bus_safe\0" \
+					"kernel_addr_r=0x7000000\0"	\
+					"initrd_addr=0xa00000\0"	\
+					"initrd_size=0x2000000\0"	\
+					"fdt_addr_r=0x6f00000\0"	\
+					"loadaddr=0x6000000\0"		\
+					"fdt_high=0xffffffffffffffff\0"	\
+					"hostname=marvell\0"		\
+					"ramdisk_addr_r=0x8000000\0"	\
+					"ramfs_name=-\0"		\
+					"cpuidle=cpuidle.off=1\0"	\
+					"fdt_name=fdt.dtb\0"		\
+					"netdev=eth0\0"			\
+					"ethaddr=00:51:82:11:22:00\0"	\
+					"eth1addr=00:51:82:11:22:01\0"	\
+					"eth2addr=00:51:82:11:22:02\0"	\
+					"eth3addr=00:51:82:11:22:03\0"	\
+					"image_name=zImage\0"		\
+					"get_ramfs=if test \"${ramfs_name}\"" \
+						" != \"-\"; then setenv " \
+						"ramdisk_addr_r 0x8000000; " \
+						"tftpboot $ramdisk_addr_r " \
+						"$ramfs_name; else setenv " \
+						"ramdisk_addr_r -;fi\0"	\
+					"get_images=tftpboot $kernel_addr_r " \
+						"$image_name; tftpboot " \
+						"$fdt_addr_r $fdt_name; " \
+						"run get_ramfs\0"	\
+					"console=" CONFIG_DEFAULT_CONSOLE "\0"\
+					"root=root=/dev/nfs rw\0"	\
+					"set_bootargs=setenv bootargs $console"\
+						" $root ip=$ipaddr:$serverip:" \
+						"$gatewayip:$netmask:$hostname"\
+						":$netdev:none nfsroot="\
+						"$serverip:$rootpath,tcp,v3 " \
+						"$extra_params " \
+						"$cpuidle\0"
+
+/*
+ * PCI
+ */
+#define CONFIG_PCIAUTO_SKIP_HOST_BRIDGE     1
+
 #endif /* _MV_COMMON_H */
diff --git a/include/configs/mvebu_armada-37xx.h b/include/configs/mvebu_armada-37xx.h
index bc249039c8..7b701d10a0 100644
--- a/include/configs/mvebu_armada-37xx.h
+++ b/include/configs/mvebu_armada-37xx.h
@@ -6,45 +6,10 @@
 #ifndef _CONFIG_MVEBU_ARMADA_37XX_H
 #define _CONFIG_MVEBU_ARMADA_37XX_H
 
-/*
- * High Level Configuration Options (easy to change)
- */
-
-/* additions for new ARM relocation support */
-#define CONFIG_SYS_SDRAM_BASE	0x00000000
-
-/* auto boot */
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
-					  115200, 230400, 460800, 921600 }
-
-/*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
-#define CONFIG_INITRD_TAG		/* enable INITRD tag */
-#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyMV0,115200 "\
+					"earlycon=ar3700_uart,0xd0012000"
 
-#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN	(4 << 20) /* 4MiB for malloc() */
-
-/*
- * Other required minimal configurations
- */
-#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
-#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
-#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
-#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
-#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
-
-/* End of 16M scrubbed by training in bootrom */
-#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
+#include <configs/mvebu_armada-common.h>
 
 /*
  * I2C
@@ -52,57 +17,6 @@
 #define CONFIG_I2C_MV
 #define CONFIG_SYS_I2C_SLAVE		0x0
 
-/*
- * SPI Flash configuration
- */
-
-#define CONFIG_MTD_DEVICE		/* needed for mtdparts commands */
-#define CONFIG_MTD_PARTITIONS		/* required for UBI partition support */
-
-/* Environment in SPI NOR flash */
-#define CONFIG_ENV_OFFSET		0x180000 /* as Marvell U-Boot version */
-#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
-#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
-
-/*
- * Ethernet Driver configuration
- */
-#define CONFIG_ENV_OVERWRITE	/* ethaddr can be reprogrammed */
-#define CONFIG_ARP_TIMEOUT	200
-#define CONFIG_NET_RETRY_COUNT	50
-
-#define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
-
-/* USB ethernet */
-
-/*
- * SATA/SCSI/AHCI configuration
- */
-#define CONFIG_SCSI_AHCI_PLAT
-#define CONFIG_LBA48
-#define CONFIG_SYS_64BIT_LBA
-
-#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
-#define CONFIG_SYS_SCSI_MAX_LUN		1
-#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
-					 CONFIG_SYS_SCSI_MAX_LUN)
-
-#define BOOT_TARGET_DEVICES(func) \
-	func(MMC, mmc, 1) \
-	func(MMC, mmc, 0) \
-	func(USB, usb, 0) \
-	func(SCSI, scsi, 0) \
-	func(PXE, pxe, na) \
-	func(DHCP, dhcp, na)
-
-#include <config_distro_bootcmd.h>
-
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-	"scriptaddr=0x4d00000\0"	\
-	"pxefile_addr_r=0x4e00000\0"	\
-	"fdt_addr_r=0x4f00000\0"	\
-	"kernel_addr_r=0x5000000\0"	\
-	"ramdisk_addr_r=0x8000000\0"	\
-	BOOTENV
+#define CONFIG_USB_MAX_CONTROLLER_COUNT (1 + 2)
 
 #endif /* _CONFIG_MVEBU_ARMADA_37XX_H */
diff --git a/include/configs/mvebu_armada-8k.h b/include/configs/mvebu_armada-8k.h
index 3be36833de..e63e53e665 100644
--- a/include/configs/mvebu_armada-8k.h
+++ b/include/configs/mvebu_armada-8k.h
@@ -6,88 +6,24 @@
 #ifndef _CONFIG_MVEBU_ARMADA_8K_H
 #define _CONFIG_MVEBU_ARMADA_8K_H
 
-/*
- * High Level Configuration Options (easy to change)
- */
-#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
-
-/* additions for new ARM relocation support */
-#define CONFIG_SYS_SDRAM_BASE	0x00000000
-
-/* auto boot */
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
-					  115200, 230400, 460800, 921600 }
-
-/*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
-#define CONFIG_INITRD_TAG		/* enable INITRD tag */
-#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlycon=uart8250,mmio32,0xf0512000"
 
-#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN	(4 << 20) /* 4MiB for malloc() */
+#include <configs/mvebu_armada-common.h>
 
 /*
- * Other required minimal configurations
+ * High Level Configuration Options (easy to change)
  */
-#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
-#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
-#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
-#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
-#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
-
-/* End of 16M scrubbed by training in bootrom */
-#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
-
-#define CONFIG_ENV_OFFSET		0x180000 /* as Marvell U-Boot version */
-#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
-#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
+#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
 
-/* When runtime detection fails this is the default */
-#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_BOARD_EARLY_INIT_R
 
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #define CONFIG_SYS_NAND_MAX_CHIPS	1
 #define CONFIG_SYS_NAND_ONFI_DETECTION
 
-/*
- * Ethernet Driver configuration
- */
-#define CONFIG_ENV_OVERWRITE	/* ethaddr can be reprogrammed */
-#define CONFIG_ARP_TIMEOUT	200
-#define CONFIG_NET_RETRY_COUNT	50
-
 #define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
 
-/* USB ethernet */
-
-/*
- * SATA/SCSI/AHCI configuration
- */
-#define CONFIG_SCSI_AHCI_PLAT
-#define CONFIG_LBA48
-#define CONFIG_SYS_64BIT_LBA
-
-#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
-#define CONFIG_SYS_SCSI_MAX_LUN		1
-#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
-					 CONFIG_SYS_SCSI_MAX_LUN)
-
-/*
- * PCI configuration
- */
-#ifdef CONFIG_PCIE_DW_MVEBU
-#define CONFIG_E1000
-#endif
-
 #define BOOT_TARGET_DEVICES(func) \
 	func(MMC, mmc, 1) \
 	func(MMC, mmc, 0) \
@@ -96,15 +32,9 @@
 	func(PXE, pxe, na) \
 	func(DHCP, dhcp, na)
 
-#include <config_distro_bootcmd.h>
-
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-	"scriptaddr=0x4d00000\0"	\
-	"pxefile_addr_r=0x4e00000\0"	\
-	"fdt_addr_r=0x4f00000\0"	\
-	"kernel_addr_r=0x5000000\0"	\
-	"ramdisk_addr_r=0x8000000\0"	\
-	"fdtfile=marvell/" CONFIG_DEFAULT_DEVICE_TREE ".dtb\0" \
-	BOOTENV
+/* RTC configuration */
+#ifdef CONFIG_MARVELL_RTC
+#define ERRATA_FE_3124064
+#endif
 
 #endif /* _CONFIG_MVEBU_ARMADA_8K_H */
diff --git a/include/configs/mvebu_armada-common.h b/include/configs/mvebu_armada-common.h
new file mode 100644
index 0000000000..d3669ff022
--- /dev/null
+++ b/include/configs/mvebu_armada-common.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _CONFIG_MVEBU_ARMADA_H
+#define _CONFIG_MVEBU_ARMADA_H
+
+#include <asm/arch/soc.h>
+
+/* Additions for new ARM relocation support */
+#define CONFIG_SYS_SDRAM_BASE		0x00000000
+
+/* Console */
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
+					  115200, 230400, 460800, 921600 }
+
+/* Default Env vars */
+#define CONFIG_IPADDR			0.0.0.0	/* In order to cause an error */
+#define CONFIG_SERVERIP			0.0.0.0	/* In order to cause an error */
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		10.4.50.254
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETHPRIME			"eth0"
+#define CONFIG_ROOTPATH			"/srv/nfs/" /* Default Dir for NFS */
+#define CONFIG_ENV_OVERWRITE		/* ethaddr can be reprogrammed */
+#define CONFIG_EXTRA_ENV_SETTINGS	"bootcmd=run get_images; " \
+						"run set_bootargs; " \
+						"booti $kernel_addr_r " \
+						"$ramdisk_addr_r " \
+						"$fdt_addr_r\0" \
+					"extra_params=pci=pcie_bus_safe\0" \
+					"kernel_addr_r=0x7000000\0"	\
+					"initrd_addr=0xa00000\0"	\
+					"initrd_size=0x2000000\0"	\
+					"fdt_addr_r=0x6f00000\0"	\
+					"loadaddr=0x6000000\0"		\
+					"fdt_high=0xffffffffffffffff\0"	\
+					"hostname=marvell\0"		\
+					"ramdisk_addr_r=0x9000000\0"	\
+					"ramfs_name=-\0"		\
+					"cpuidle=cpuidle.off=1\0"	\
+					"fdt_name=fdt.dtb\0"		\
+					"netdev=eth0\0"			\
+					"ethaddr=00:51:82:11:22:00\0"	\
+					"eth1addr=00:51:82:11:22:01\0"	\
+					"eth2addr=00:51:82:11:22:02\0"	\
+					"eth3addr=00:51:82:11:22:03\0"	\
+					"eth4addr=00:51:82:11:22:04\0"	\
+					"image_name=Image\0"		\
+					"get_ramfs=if test \"${ramfs_name}\"" \
+						" != \"-\"; then setenv " \
+						"ramdisk_addr_r $ramdisk_addr_r; " \
+						"tftpboot $ramdisk_addr_r " \
+						"$ramfs_name; else setenv " \
+						"ramdisk_addr_r -;fi\0"	\
+					"get_images=tftpboot $kernel_addr_r " \
+						"$image_name; tftpboot " \
+						"$fdt_addr_r $fdt_name; " \
+						"run get_ramfs\0"	\
+					"console=" CONFIG_DEFAULT_CONSOLE "\0"\
+					"root=root=/dev/nfs rw\0"	\
+					"set_bootargs=setenv bootargs $console"\
+						" $root ip=$ipaddr:$serverip:" \
+						"$gatewayip:$netmask:$hostname"\
+						":$netdev:none nfsroot="\
+						"$serverip:$rootpath,tcp,v3 " \
+						"$extra_params " \
+						"$cpuidle\0" \
+					"usb_pgood_delay=5000"
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
+#define CONFIG_INITRD_TAG		/* enable INITRD tag */
+#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
+
+#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
+#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE \
+		+ sizeof(CONFIG_SYS_PROMPT) + 16)	/* Print Buff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN	(9 << 20) /* 16MiB for malloc() */
+
+/*
+ * Other required minimal configurations
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
+#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
+#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
+#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
+#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
+
+#define CONFIG_SYS_ALT_MEMTEST
+
+/* End of 16M scrubbed by training in bootrom */
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
+
+/*
+ * SPI Flash configuration
+ */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+
+/* SPI NOR flash default params, used by sf commands */
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+
+#ifdef CONFIG_MVEBU_NAND_BOOT
+/* In case of NAND, we want to start the environment on page boundary
+ * Linux DTS uses 2MB partition size for u-boot.
+ */
+#define CONFIG_ENV_SIZE			(256 << 10)
+#define CONFIG_ENV_OFFSET		(0x200000 - CONFIG_ENV_SIZE)
+
+#else /* !CONFIG_MVEBU_NAND_BOOT */
+/*
+ * Assume minimum flash/eMMC boot partition size of 4MB
+ * and save the environment at the end of the boot device
+ * There are some exclusions from this rule, for instance EspressoBIN board.
+ * The eMMC device found on some EspressoBIN V7 boards has 2MB boot partition.
+ */
+#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
+#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
+
+#if defined(CONFIG_ENV_IS_IN_MMC) && \
+((defined(CONFIG_TARGET_MVEBU_ARMADA_37XX) && \
+	defined(CONFIG_MV88E6XXX_SWITCH))  || \
+defined(CONFIG_TARGET_OCTEONTX2_CN913x) && (CONFIG_MVEBU_BOOT_PART != 0))
+/* A3700 + MV88E6XXX == EspressoBIN board OR
+ * CN913x CRB that boots from eMMC partition BOOT0/BOOT1 (ID 1/2)
+ */
+#define CONFIG_ENV_OFFSET		(0x200000 - CONFIG_ENV_SIZE)
+#else
+#define CONFIG_ENV_OFFSET		(0x400000 - CONFIG_ENV_SIZE)
+#endif
+#endif /* CONFIG_MVEBU_NAND_BOOT */
+
+/*
+ * Device ID and Boot partition defined in external script
+ */
+#define CONFIG_SYS_MMC_ENV_DEV		(CONFIG_MVEBU_BOOT_DEVICE)
+#define CONFIG_SYS_MMC_ENV_PART		(CONFIG_MVEBU_BOOT_PART)
+
+/*
+ * SATA/SCSI/AHCI configuration
+ */
+#define CONFIG_SCSI_AHCI_PLAT
+#define CONFIG_LBA48
+#define CONFIG_SYS_64BIT_LBA
+
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
+#define CONFIG_SYS_SCSI_MAX_LUN		1
+#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+					 CONFIG_SYS_SCSI_MAX_LUN)
+
+/*
+ * Ethernet Driver configuration
+ */
+#define CONFIG_ARP_TIMEOUT	200
+#define CONFIG_NET_RETRY_COUNT	50
+
+/*
+ * The EEPROM ST M24C64 has 32 byte page write mode and takes up to 10 msec.
+ */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+#endif /* _CONFIG_MVEBU_ARMADA_H */
diff --git a/include/configs/octeontx2_95mm.h b/include/configs/octeontx2_95mm.h
new file mode 100644
index 0000000000..4377d27a75
--- /dev/null
+++ b/include/configs/octeontx2_95mm.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_95MM_H__
+#define __OCTEONTX2_95MM_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_CMD_BKOPS_ENABLE
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#if defined(CONFIG_MMC_OCTEONTX)
+#define MMC_SUPPORTS_TUNING
+#endif
+
+#endif /* __OCTEONTX2_95MM_H__ */
diff --git a/include/configs/octeontx2_95xx.h b/include/configs/octeontx2_95xx.h
new file mode 100644
index 0000000000..7023c7ea8b
--- /dev/null
+++ b/include/configs/octeontx2_95xx.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_95XX_H__
+#define __OCTEONTX2_95XX_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_CMD_BKOPS_ENABLE
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#if defined(CONFIG_MMC_OCTEONTX)
+#define MMC_SUPPORTS_TUNING
+#endif
+
+#endif /* __OCTEONTX2_95XX_H__ */
diff --git a/include/configs/octeontx2_96xx.h b/include/configs/octeontx2_96xx.h
new file mode 100644
index 0000000000..411ae7f292
--- /dev/null
+++ b/include/configs/octeontx2_96xx.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_96XX_H__
+#define __OCTEONTX2_96XX_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"ethrotate=yes\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#if defined(CONFIG_MMC_OCTEONTX)
+#define MMC_SUPPORTS_TUNING
+#endif
+
+#endif /* __OCTEONTX2_96XX_H__ */
diff --git a/include/configs/octeontx2_98xx.h b/include/configs/octeontx2_98xx.h
new file mode 100644
index 0000000000..8cf638908a
--- /dev/null
+++ b/include/configs/octeontx2_98xx.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_98XX_H__
+#define __OCTEONTX2_98XX_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+/*#define CONFIG_LAST_STAGE_INIT */
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"ethrotate=yes\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#if defined(CONFIG_MMC_OCTEONTX)
+#define MMC_SUPPORTS_TUNING
+#endif
+
+#endif /* __OCTEONTX2_98XX_H__ */
diff --git a/include/configs/octeontx2_cn913x.h b/include/configs/octeontx2_cn913x.h
new file mode 100644
index 0000000000..2ae70e5efe
--- /dev/null
+++ b/include/configs/octeontx2_cn913x.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _CONFIG_OCTEONTX2_CN913X_H
+#define _CONFIG_OCTEONTX2_CN913X_H
+
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlycon=uart8250,mmio32,0xf0512000"
+
+#include <configs/mvebu_armada-common.h>
+
+/*
+ * High Level Configuration Options (easy to change)
+ */
+#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
+
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+
+#define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 1) \
+	func(MMC, mmc, 0) \
+	func(USB, usb, 0) \
+	func(SCSI, scsi, 0) \
+	func(PXE, pxe, na) \
+	func(DHCP, dhcp, na)
+
+/* RTC configuration */
+#ifdef CONFIG_MARVELL_RTC
+#define ERRATA_FE_3124064
+#endif
+
+#endif /* _CONFIG_OCTEONTX2_CN913X_H */
diff --git a/include/configs/octeontx2_loki.h b/include/configs/octeontx2_loki.h
new file mode 100644
index 0000000000..570e5e9b99
--- /dev/null
+++ b/include/configs/octeontx2_loki.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_LOKI_H__
+#define __OCTEONTX2_LOKI_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_CMD_BKOPS_ENABLE
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#if defined(CONFIG_MMC_OCTEONTX)
+#define MMC_SUPPORTS_TUNING
+#endif
+
+#endif /* __OCTEONTX2_LOKI_H__ */
diff --git a/include/configs/octeontx_common.h b/include/configs/octeontx_common.h
new file mode 100644
index 0000000000..dcea2d152c
--- /dev/null
+++ b/include/configs/octeontx_common.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_COMMON_H__
+#define __OCTEONTX_COMMON_H__
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+/* Allow environment variable to be overwritten */
+#define CONFIG_ENV_OVERWRITE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* Autoboot options */
+#define CONFIG_RESET_TO_RETRY
+#define CONFIG_BOOT_RETRY_TIME		-1
+#define CONFIG_BOOT_RETRY_MIN		30
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+# define CONFIG_SF_DEFAULT_BUS	0
+# define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8192
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#if defined(CONFIG_NAND_OCTEONTX)
+#define CONFIG_MTD_DEVICE
+/*#define CONFIG_MTD_CONCAT */
+#define CONFIG_SYS_MAX_NAND_DEVICE 8
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#endif
+
+#endif /* __OCTEONTX_COMMON_H__ */
diff --git a/include/configs/thunderx_88xx.h b/include/configs/thunderx_88xx.h
index 619571d45b..baf47f71dc 100644
--- a/include/configs/thunderx_88xx.h
+++ b/include/configs/thunderx_88xx.h
@@ -3,22 +3,103 @@
  * (C) Copyright 2014, Cavium Inc.
 **/
 
-#ifndef __THUNDERX_88XX_H__
-#define __THUNDERX_88XX_H__
+#ifndef __OCTEONTX_88XX_H__
+#define __OCTEONTX_88XX_H__
 
-#define CONFIG_REMAKE_ELF
+#define CONFIG_SPECIAL_SYNC_HANDLER
 
-#define CONFIG_THUNDERX
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
 
 #define CONFIG_SYS_64BIT
 
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN (256 << 20)
+
+#define CONFIG_SYS_VSNPRINTF
+
+#define CONFIG_IDENT_STRING	\
+	" for Cavium Thunder CN88XX ARM v8 Multi-Core"
+#define CONFIG_BOOTP_VCI_STRING		"Diagnostics"
+
 #define MEM_BASE			0x00500000
 
 #define CONFIG_SYS_LOWMEM_BASE		MEM_BASE
 
+#define CONFIG_SYS_MEM_MAP		{{0x000000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_NORMAL) |	     \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x800000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x840000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x880000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x900000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x940000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0x980000000000UL, 0x40000000000UL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					 {0xffffffffffffUL, 0xfffffffffffUL, \
+					  PTL2_MEMTYPE(MT_DEVICE_NGNRNE) |   \
+					  PTL2_BLOCK_NON_SHARE},	     \
+					}
+
+#define CONFIG_SYS_MEM_MAP_SIZE		7
+
+#define CONFIG_COREID_MASK		0xffffff
+#define CONFIG_SYS_FULL_VA
+
+#define CONFIG_SYS_VA_BITS		48
+#define CONFIG_SYS_PTL2_BITS		42
+#define CONFIG_SYS_BLOCK_SHIFT		29
+#define CONFIG_SYS_PTL1_ENTRIES		64
+#define CONFIG_SYS_PTL2_ENTRIES		8192
+
+#define CONFIG_SYS_PGTABLE_SIZE		\
+	((CONFIG_SYS_PTL1_ENTRIES + \
+	  CONFIG_SYS_MEM_MAP_SIZE * CONFIG_SYS_PTL2_ENTRIES) * 8)
+#define CONFIG_SYS_TCR_EL1_IPS_BITS	(5UL << 32)
+#define CONFIG_SYS_TCR_EL2_IPS_BITS	(5 << 16)
+#define CONFIG_SYS_TCR_EL3_IPS_BITS	(5 << 16)
+
+#define CONFIG_SYS_PCI_MEM_CPU	{0x881010000000UL, 0x885010000000UL, 0x889010000000UL,\
+				 0x891010000000UL, 0x895010000000UL, 0x899010000000UL}
+
+#define CONFIG_SYS_PCI_PREF_CPU	{0x882100000000UL, 0x886100000000UL, 0x88a100000000UL,\
+				 0x892080000000UL, 0x896080000000UL, 0x89a080000000UL}
+
+#define CONFIG_SYS_PCI_IO_CPU	{0x883000000000UL, 0x887000000000UL, 0x88b000000000UL,\
+				 0x893000000000UL, 0x897000000000UL, 0x89b000000000UL}
+
+#define CONFIG_SYS_PCI_MEM_BUS	 0x10000000
+#define CONFIG_SYS_PCI_PREF_BUS	 0x80000000
+#define CONFIG_SYS_PCI_IO_BUS	 0x1000000000
+
+#define CONFIG_SYS_PCI_MEM_SIZE  0xf0000000
+#define CONFIG_SYS_PCI_PREF_SIZE 0xf000000000
+#define CONFIG_SYS_PCI_IO_SIZE   0x10000
+
+#define CONFIG_SLT
+
 /* Link Definitions */
 #define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x7fff0)
 
+#define CONFIG_BOARD_LATE_INIT
+
+/* Flat Device Tree Definitions */
+#define CONFIG_OF_LIBFDT
+
 /* SMP Spin Table Definitions */
 #define CPU_RELEASE_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x7fff0)
 
@@ -29,7 +110,12 @@
 #define CONFIG_SYS_MEMTEST_END		(MEM_BASE + PHYS_SDRAM_1_SIZE)
 
 /* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024 * 1024)
+
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+#define CONFIG_SYS_MEM_TOP_HIDE		0x1000000
+
+#define CONFIG_AP_STACK_SIZE		65536
+#define CONFIG_AP_STACK_ALIGN		16
 
 /* PL011 Serial Configuration */
 
@@ -41,8 +127,107 @@
 #define CONFIG_SYS_SERIAL0		0x87e024000000
 #define CONFIG_SYS_SERIAL1		0x87e025000000
 
+#define CONFIG_BAUDRATE			115200
+
+/* Net */
+#define CONFIG_OCTEONTX_BGX
+#define CONFIG_OCTEONTX_SMI
+#define CONFIG_OCTEONTX_VNIC
+#define CONFIG_RANDOM_MACADDR
+
+#ifndef CONFIG_RANDOM_MACADDR
+#define CONFIG_ETHADDR			aa:d3:31:40:11:00
+#endif
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+#define CONFIG_PHYLIB
+
+#define CONFIG_MAX_BGX_PER_NODE		2
+#define CONFIG_MAX_BGX			4 /* 2 nodes, 2 bgx per node */
+
+/* Command line configuration */
+#define CONFIG_MENU
+
+/*#define CONFIG_MENU_SHOW*/
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_DIAG
+#define CONFIG_CMD_ENV
+#undef  CONFIG_CMD_IMLS
+#define CONFIG_CMD_BOOTI
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_TFTP
+
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_DIAG
+#define CONFIG_CMD_PART
+#define CONFIG_CMD_SATA
+
+#define CONFIG_CMD_ATF
+#define CONFIG_CMD_PCI
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_ENV_FLAGS
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_ENV_CALLBACK
+
+/* AHCI support Definitions */
+#ifdef CONFIG_CMD_SATA
+  #define CONFIG_SATA_AHCI
+  #define CONFIG_SYS_SATA_MAX_DEVICE	32
+  #define CONFIG_SATA_BASE_ADDR		0x810000000000
+  #define CONFIG_LBA48
+  #define CONFIG_LIBATA
+  #define CONFIG_SYS_64BIT_LBA
+#endif
+
+/* Partition systems */
+#define CONFIG_DOS_PARTITION
+#define CONFIG_EFI_PARTITION
+#define CONFIG_PARTITION_UUIDS
+
+/* PCIe */
+#define CONFIG_PCI
+#define CONFIG_SYS_PCI_64BIT
+#define CONFIG_PCI_SCAN_SHOW
+#undef CONFIG_PCI_ENUM_ONLY
+#define CONFIG_PCI_PNP
+#define CONFIG_SYS_PCI_ARI
+#define CONFIG_OCTEONTX_ECAMS 8
+#define CONFIG_OCTEONTX_RCS 12
+#define CONFIG_OCTEONTX_RCS_PER_NODE 6
+
+#define CONFIG_SYS_CACHELINE_SIZE 128
+
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_OCTEONTX
+#define CONFIG_SYS_I2C_OCTEONTX_SPEED_0 100000
+#define CONFIG_SYS_I2C_OCTEONTX_SLAVE_0 0
+#define CONFIG_SYS_I2C_OCTEONTX_SPEED_1 100000
+#define CONFIG_SYS_I2C_OCTEONTX_SLAVE_1 0
+
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_SPD_ADDR_LIST {0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57}
+#define CONFIG_SYS_SPD_I2C_BUS 1
+
+#define CONFIG_CMD_SAVES
+
+/* Partition systems */
+#define CONFIG_DOS_PARTITION
+#define CONFIG_EFI_PARTITION
+#define CONFIG_PARTITION_UUIDS
+
+#define CONFIG_SYS_CACHELINE_SIZE 128
+
 /* BOOTP options */
 #define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
 
 /* Miscellaneous configurable options */
 #define CONFIG_SYS_LOAD_ADDR		(MEM_BASE)
@@ -52,16 +237,52 @@
 #define PHYS_SDRAM_1_SIZE		(0x80000000-MEM_BASE)	/* 2048 MB */
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
 
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_PCI
+#define CONFIG_USB_STORAGE
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 8
+
+
+/* PCIe network controller drivers */
+#define CONFIG_E1000
+#define CONFIG_E1000_SPI
+#define CONFIG_CMD_E1000
+
+/* #define E1000_DEBUG */
+
 /* Initial environment variables */
 #define UBOOT_IMG_HEAD_SIZE		0x40
 /* C80000 - 0x40 */
 #define CONFIG_EXTRA_ENV_SETTINGS	\
 					"kernel_addr=08007ffc0\0"	\
 					"fdt_addr=0x94C00000\0"		\
-					"fdt_high=0x9fffffff\0"
+					"fdt_high=0x9fffffff\0"		\
+					"autoload=0\0"
 
 /* Do not preserve environment */
-#define CONFIG_ENV_SIZE			0x1000
+#define CONFIG_BOOTARGS			\
+					"console=ttyAMA0,115200n8 " \
+					"earlycon=pl011,0x87e024000000 " \
+					"debug maxcpus=48 rootwait rw "\
+					"root=/dev/sda2 coherent_pool=16M"
+#define CONFIG_BOOTDELAY		5
+
+#define CONFIG_ENV_IS_IN_ATF
+#define CONFIG_SYS_ENV_ATF_NOR
+#define CONFIG_ENV_SIZE			0x80000
+#define CONFIG_ENV_OFFSET		0xf00000
+
+#define CONFIG_BDK_FDT_START		0xa00000
+#define CONFIG_BDK_FDT_SIZE		0x20000
+
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_THUNDERX
+#define CONFIG_SYS_I2C_THUNDERX_SPEED_0	100000
+#define CONFIG_SYS_I2C_THUNDERX_SLAVE_0	0
+#define CONFIG_SYS_I2C_THUNDERX_SPEED_1	100000
+#define CONFIG_SYS_I2C_THUNDERX_SLAVE_1	0
+
 
 /* Monitor Command Prompt */
 #define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
@@ -70,4 +291,4 @@
 #define PLL_REF_CLK			50000000	/* 50 MHz */
 #define NS_PER_REF_CLK_TICK		(1000000000/PLL_REF_CLK)
 
-#endif /* __THUNDERX_88XX_H__ */
+#endif /* __OCTEONTX_88XX_H__ */
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index d4d96106b3..a8d6976be7 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -84,6 +84,7 @@ enum uclass_id {
 	UCLASS_REGULATOR,	/* Regulator device */
 	UCLASS_REMOTEPROC,	/* Remote Processor device */
 	UCLASS_RESET,		/* Reset controller device */
+	UCLASS_SAR,		/* Reset Sample Configuration */
 	UCLASS_RTC,		/* Real time clock device */
 	UCLASS_SCSI,		/* SCSI device */
 	UCLASS_SERIAL,		/* Serial UART */
diff --git a/include/dt-bindings/comphy/comphy_data.h b/include/dt-bindings/comphy/comphy_data.h
index 4f7e2821b8..8353a78740 100644
--- a/include/dt-bindings/comphy/comphy_data.h
+++ b/include/dt-bindings/comphy/comphy_data.h
@@ -6,52 +6,44 @@
 #ifndef _COMPHY_DATA_H_
 #define _COMPHY_DATA_H_
 
-#define PHY_SPEED_1_25G			0
-#define PHY_SPEED_1_5G			1
-#define PHY_SPEED_2_5G			2
-#define PHY_SPEED_3G			3
-#define PHY_SPEED_3_125G		4
-#define PHY_SPEED_5G			5
-#define PHY_SPEED_5_15625G		6
-#define PHY_SPEED_6G			7
-#define PHY_SPEED_6_25G			8
-#define PHY_SPEED_10_3125G		9
-#define PHY_SPEED_MAX			10
-#define PHY_SPEED_INVALID		0xff
+#define COMPHY_SPEED_1_25G		0
+#define COMPHY_SPEED_2_5G		1
+#define COMPHY_SPEED_3_125G		2
+#define COMPHY_SPEED_5G			3
+#define COMPHY_SPEED_5_15625G		4
+#define COMPHY_SPEED_6G			5
+#define COMPHY_SPEED_10_3125G		6
+#define COMPHY_SPEED_MAX		7
+#define COMPHY_SPEED_INVALID		0xff
 
-#define PHY_TYPE_UNCONNECTED		0
-#define PHY_TYPE_PEX0			1
-#define PHY_TYPE_PEX1			2
-#define PHY_TYPE_PEX2			3
-#define PHY_TYPE_PEX3			4
-#define PHY_TYPE_SATA0			5
-#define PHY_TYPE_SATA1			6
-#define PHY_TYPE_SATA2			7
-#define PHY_TYPE_SATA3			8
-#define PHY_TYPE_SGMII0			9
-#define PHY_TYPE_SGMII1			10
-#define PHY_TYPE_SGMII2			11
-#define PHY_TYPE_SGMII3			12
-#define PHY_TYPE_QSGMII			13
-#define PHY_TYPE_USB3_HOST0		14
-#define PHY_TYPE_USB3_HOST1		15
-#define PHY_TYPE_USB3_DEVICE		16
-#define PHY_TYPE_XAUI0			17
-#define PHY_TYPE_XAUI1			18
-#define PHY_TYPE_XAUI2			19
-#define PHY_TYPE_XAUI3			20
-#define PHY_TYPE_RXAUI0			21
-#define PHY_TYPE_RXAUI1			22
-#define PHY_TYPE_SFI			23
-#define PHY_TYPE_IGNORE			24
-#define PHY_TYPE_MAX			25
-#define PHY_TYPE_INVALID		0xff
+#define COMPHY_TYPE_UNCONNECTED		0
+#define COMPHY_TYPE_PEX0		1
+#define COMPHY_TYPE_PEX1		2
+#define COMPHY_TYPE_PEX2		3
+#define COMPHY_TYPE_PEX3		4
+#define COMPHY_TYPE_SATA0		5
+#define COMPHY_TYPE_SATA1		6
+#define COMPHY_TYPE_SGMII0		7
+#define COMPHY_TYPE_SGMII1		8
+#define COMPHY_TYPE_SGMII2		9
+#define COMPHY_TYPE_USB3		10
+#define COMPHY_TYPE_USB3_HOST0		11
+#define COMPHY_TYPE_USB3_HOST1		12
+#define COMPHY_TYPE_USB3_DEVICE		13
+#define COMPHY_TYPE_RXAUI0		14
+#define COMPHY_TYPE_RXAUI1		15
+#define COMPHY_TYPE_SFI0		16
+#define COMPHY_TYPE_SFI1		17
+#define COMPHY_TYPE_AP			18
+#define COMPHY_TYPE_IGNORE		19
+#define COMPHY_TYPE_MAX			20
+#define COMPHY_TYPE_INVALID		0xff
 
-#define PHY_POLARITY_NO_INVERT		0
-#define PHY_POLARITY_TXD_INVERT		1
-#define PHY_POLARITY_RXD_INVERT		2
-#define PHY_POLARITY_ALL_INVERT		\
-	(PHY_POLARITY_TXD_INVERT | PHY_POLARITY_RXD_INVERT)
+#define COMPHY_POLARITY_NO_INVERT	0
+#define COMPHY_POLARITY_TXD_INVERT	1
+#define COMPHY_POLARITY_RXD_INVERT	2
+#define COMPHY_POLARITY_ALL_INVERT	\
+	(COMPHY_POLARITY_TXD_INVERT | COMPHY_POLARITY_RXD_INVERT)
 
 #define UTMI_PHY_TO_USB3_HOST0		0
 #define UTMI_PHY_TO_USB3_HOST1		1
diff --git a/include/env.h b/include/env.h
index b72239f6a5..c2490ab665 100644
--- a/include/env.h
+++ b/include/env.h
@@ -333,4 +333,14 @@ int env_get_char(int index);
  */
 void env_reloc(void);
 
+/*  */
+/**
+ * cmd_hw_info_load() - load HW information to environment
+ *
+ * This is updates environment with HW info.
+ */
+#ifdef CONFIG_CMD_MVEBU_HW_INFO
+int cmd_hw_info_load(char *name, int silence);
+#endif
+
 #endif
diff --git a/include/ext4fs.h b/include/ext4fs.h
index 34585d407d..92e6782174 100644
--- a/include/ext4fs.h
+++ b/include/ext4fs.h
@@ -37,6 +37,9 @@
 #define EXT4_FEATURE_INCOMPAT_64BIT	0x0080
 #define EXT4_INDIRECT_BLOCKS		12
 
+#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM		0x0010
+#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM	0x0400
+
 #define EXT4_BG_INODE_UNINIT		0x0001
 #define EXT4_BG_BLOCK_UNINIT		0x0002
 #define EXT4_BG_INODE_ZEROED		0x0004
diff --git a/include/fdtdec.h b/include/fdtdec.h
index 635f53083b..e19709dd09 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -165,6 +165,10 @@ enum fdt_compat_id {
 	COMPAT_ALTERA_SOCFPGA_FPGA0,		/* SOCFPGA FPGA manager */
 	COMPAT_ALTERA_SOCFPGA_NOC,		/* SOCFPGA Arria 10 NOC */
 	COMPAT_ALTERA_SOCFPGA_CLK_INIT,		/* SOCFPGA Arria 10 clk init */
+	COMPAT_MVEBU_SAR,
+	COMPAT_MVEBU_SAR_REG_COMMON,
+	COMPAT_MVEBU_SAR_REG_AP806,
+	COMPAT_MVEBU_SAR_REG_CP110,
 
 	COMPAT_COUNT,
 };
@@ -458,6 +462,17 @@ int fdtdec_get_pci_vendev(const void *blob, int node,
 int fdtdec_get_pci_bar32(struct udevice *dev, struct fdt_pci_addr *addr,
 			 u32 *bar);
 
+/**
+ * Look at the bus range property of a device node and return the pci bus
+ * range for this node.
+ * The property must hold one fdt_pci_addr with a lengh.
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param res		the resource structure to return the bus range
+ */
+
+int fdtdec_get_pci_bus_range(const void *blob, int node,
+			     struct fdt_resource *res);
 /**
  * Look up a 32-bit integer property in a node and return it. The property
  * must have at least 4 bytes of data. The value of the first cell is
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index f6dbdb096d..a97bde48df 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -614,11 +614,12 @@ enum ethtool_sfeatures_retval_bits {
  * it was foced up into this mode or autonegotiated.
  */
 
-/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */
+/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb,  5Gb, 10GbE. */
 #define SPEED_10		10
 #define SPEED_100		100
 #define SPEED_1000		1000
 #define SPEED_2500		2500
+#define SPEED_5000		5000
 #define SPEED_10000		10000
 
 /* Duplex, half or full. */
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 709b49d393..cfbef0351e 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -123,6 +123,7 @@
 #define SR_BP0			BIT(2)	/* Block protect 0 */
 #define SR_BP1			BIT(3)	/* Block protect 1 */
 #define SR_BP2			BIT(4)	/* Block protect 2 */
+#define SR_BP3			BIT(5)	/* Block protect 3 */
 #define SR_TB			BIT(5)	/* Top/Bottom protect */
 #define SR_SRWD			BIT(7)	/* SR write protect */
 /* Spansion/Cypress specific status bits */
diff --git a/include/miiphy.h b/include/miiphy.h
index 9b97d09f18..81492d1f2c 100644
--- a/include/miiphy.h
+++ b/include/miiphy.h
@@ -187,4 +187,8 @@ struct mdio_mux_ops {
 
 #endif
 
+#ifdef CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD
+u32 mvebu_phy_firmware_download(u16 port, u8 app_data[], u32 app_size,
+				u8 salve_data[], u32 slave_size);
+#endif
 #endif
diff --git a/include/mmc.h b/include/mmc.h
index 686ba00656..a76667aa60 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -852,6 +852,7 @@ int mmc_get_env_dev(void);
 /* Minimum partition switch timeout in units of 10-milliseconds */
 #define MMC_MIN_PART_SWITCH_TIME	30 /* 300 ms */
 
+int mmc_power_init(struct mmc *mmc);
 /* Set block count limit because of 16 bit register limit on some hardware*/
 #ifndef CONFIG_SYS_MMC_MAX_BLK_COUNT
 #define CONFIG_SYS_MMC_MAX_BLK_COUNT 65535
diff --git a/include/mvebu/cfg_eeprom.h b/include/mvebu/cfg_eeprom.h
new file mode 100644
index 0000000000..d4fb8f9f08
--- /dev/null
+++ b/include/mvebu/cfg_eeprom.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#ifndef _MCEBU_CFG_EEPROM_H_
+#define _MVEBU_CFG_EEPROM_H_
+#include <common.h>
+#include <i2c.h>
+#include <errno.h>
+#include <asm/io.h>
+
+#define BOARD_DEV_TWSI_INIT_EEPROM		0x57
+#define BOARD_HW_INFO_EEPROM_ADDR_LEN		2
+#define BOARD_HW_INFO_EEPROM_DEV		0
+
+enum mv_config_type_id {
+	MV_CONFIG_CHECKSUM,
+	MV_CONFIG_PATTERN,
+	MV_CONFIG_LENGTH,
+	MV_CONFIG_HW_INFO,
+	MV_CONFIG_TYPE_MAX_OPTION,  /* limit for user read/write routines */
+};
+
+/* #pragma pack(1) */
+#define MVEBU_HW_INFO_LEN			512
+struct manufacturing_information_struct {
+	u8 hw_info[MVEBU_HW_INFO_LEN];
+};
+
+/* #pragma pack(1) */
+struct eeprom_struct {
+	u32 checksum;
+	u32 pattern;
+	u16 length;
+	struct manufacturing_information_struct man_info;
+};
+
+struct config_types_info {
+	enum mv_config_type_id config_id;
+	char name[30];
+	u32 byte_num;
+	u32 byte_cnt;
+};
+
+#define I2C_PAGE_WRITE_SIZE			32
+#define EEPROM_STRUCT_SIZE			(sizeof(struct eeprom_struct))
+#define HW_INFO_MAX_PARAM_NUM			32
+
+struct hw_info_point_struct {
+	char *name;
+	char *value;
+};
+
+#define READ_SPECIFIC_FIELD			-1
+#define HW_INFO_MAX_NAME_LEN			32
+#define HW_INFO_MAX_VALUE_LEN			32
+struct hw_info_data_struct {
+	char name[HW_INFO_MAX_NAME_LEN];
+	char value[HW_INFO_MAX_VALUE_LEN];
+};
+
+#define offset_in_eeprom(a)	((u32)(offsetof(struct eeprom_struct, a)))
+
+/* MV_CONFIG_TYPE_ID */
+/* {{configId,		name,		byte_num,	byte_cnt}} */
+#define MV_EEPROM_CONFIG_INFO { \
+{ MV_CONFIG_CHECKSUM,	"Checksum",	offset_in_eeprom(checksum),	   \
+				sizeof(board_config_val.checksum)},	   \
+{ MV_CONFIG_PATTERN,	"Pattern",	offset_in_eeprom(pattern),	   \
+				sizeof(board_config_val.pattern)},	   \
+{ MV_CONFIG_LENGTH,	"Data length",	offset_in_eeprom(length),	   \
+				sizeof(board_config_val.length)},	   \
+{ MV_CONFIG_HW_INFO,	"Box Info",	offset_in_eeprom(man_info.hw_info),\
+				sizeof(board_config_val.man_info.hw_info)} \
+}
+
+#define CFG_DEFAULT_VALUE  {						     \
+	0x00000000,				     /* checksum */	     \
+	0xfecadefa,				     /* EEPROM pattern */    \
+	EEPROM_STRUCT_SIZE,			     /* length = 0x10A B */  \
+	{{[0 ... (MVEBU_HW_INFO_LEN - 1)] = 0x00} }   /* man info */	     \
+}
+
+int cfg_eeprom_init(void);
+void cfg_eeprom_save(int length);
+struct eeprom_struct *cfg_eeprom_get_board_config(void);
+void cfg_eeprom_get_hw_info_str(uchar *hw_info_str);
+void cfg_eeprom_set_hw_info_str(uchar *hw_info_str);
+int cfg_eeprom_parse_hw_info(struct hw_info_data_struct *hw_info_data_array);
+int cfg_eeprom_parse_env(struct hw_info_data_struct *data_array,
+			 int size);
+int cfg_eeprom_validate_name(char *name);
+
+#endif /* _MVEBU_CFG_EEPROM_H_ */
diff --git a/include/mvebu/comphy.h b/include/mvebu/comphy.h
index cde7a022af..4d1b70393b 100644
--- a/include/mvebu/comphy.h
+++ b/include/mvebu/comphy.h
@@ -16,7 +16,7 @@ struct comphy_map {
 	bool end_point;
 };
 
+int comphy_rx_training(struct udevice *dev, u32 lane);
 int comphy_update_map(struct comphy_map *serdes_map, int count);
 
 #endif /* _MVEBU_COMPHY_H_ */
-
diff --git a/include/mvebu/fuse-mvebu.h b/include/mvebu/fuse-mvebu.h
new file mode 100644
index 0000000000..fbb483f9b1
--- /dev/null
+++ b/include/mvebu/fuse-mvebu.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_EFUSE_H
+#define _MVEBU_EFUSE_H
+
+#include <common.h>
+
+#if defined(CONFIG_MVEBU_EFUSE_READ_ONLY)
+#define EFUSE_READ_ONLY
+#else
+#undef EFUSE_READ_ONLY
+#endif
+
+#define MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER	BIT(6)
+#define MVEBU_EFUSE_CTRL_LD_SEC_EN_MASK		BIT(7)
+#define MVEBU_EFUSE_CTRL_PROGRAM_ENABLE		BIT(31)
+
+struct mvebu_fuse_platform_data {
+	unsigned int row_bit_width;
+	unsigned int row_step;
+};
+
+struct mvebu_fuse_block_data {
+	struct mvebu_fuse_platform_data	*pdata;
+	unsigned int	row_base;
+	unsigned int	row_num;
+	void	*control_reg;
+	void	*target_otp_mem;
+	bool	hd_ld_flag;
+	char	block_name[64];
+};
+
+struct fuse_ops {
+	int (*fuse_init)(struct udevice *dev);
+	int (*fuse_hd_read)(struct udevice *dev, int row_id, u32 *val);
+	int (*fuse_hd_prog)(struct udevice *dev, int word, int row_id,
+			    u32 new_val);
+	int (*fuse_ld_read)(struct udevice *dev, int row_id, u32 *val);
+	int (*fuse_ld_prog)(struct udevice *dev, int word, int row_id,
+			    u32 new_val);
+};
+
+int mvebu_efuse_hd_read(struct udevice *dev, int row_id, u32 *val);
+int mvebu_efuse_hd_prog(struct udevice *dev, int word, int row_id, u32 new_val);
+int mvebu_efuse_ld_read(struct udevice *dev, int row_id, u32 *val);
+int mvebu_efuse_ld_prog(struct udevice *dev, int word, int row_id, u32 new_val);
+int reg_fuse_ops(struct fuse_ops *ops);
+int mvebu_efuse_init_hw(struct udevice *dev);
+
+#endif
diff --git a/include/mvebu/mvebu_chip_sar.h b/include/mvebu/mvebu_chip_sar.h
new file mode 100644
index 0000000000..cd78aa55b5
--- /dev/null
+++ b/include/mvebu/mvebu_chip_sar.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_CHIP_SAR_H_
+#define _MVEBU_CHIP_SAR_H_
+
+#include <asm/types.h>
+
+/*
+ * List of boot source options.
+ * Return value for each of the options:
+ *  - SAR_CPU_FREQ: Frequency (Hz)
+ *  - SAR_DDR_FREQ: Frequency (Hz)
+ *  - SAR_AP_FABRIC_FREQ: Frequency (Hz)
+ *  - SAR_CP_FABRIC_FREQ: Frequency (Hz)
+ *  - SAR_BOOT_SRC: Boot source type (see mvebu_bootsrc_type)
+ */
+enum mvebu_sar_opts {
+	SAR_CPU_FREQ = 0,
+	SAR_DDR_FREQ,
+	SAR_AP_FABRIC_FREQ,
+	SAR_CP_FABRIC_FREQ,
+	SAR_CP0_PCIE0_CLK,
+	SAR_CP0_PCIE1_CLK,
+	SAR_CP1_PCIE0_CLK,
+	SAR_CP1_PCIE1_CLK,
+	SAR_BOOT_SRC,
+	SAR_MAX_IDX
+};
+
+enum mvebu_bootsrc_type {
+	BOOTSRC_NAND,
+	BOOTSRC_SPI,
+	BOOTSRC_AP_SPI,
+	BOOTSRC_SD_EMMC,
+	BOOTSRC_AP_SD_EMMC,
+	BOOTSRC_NOR,
+	BOOTSRC_MAX_IDX
+};
+
+/*
+ * sample-at-reset information
+ *  raw_sar_val: Raw value out of the sample-at-reset register.
+ *		This is hw dependent and should not be used for comparison
+ *		purposes (useful for debug, or verbose information).
+ *  bootsrc (SAR_BOOT_SRC):
+ *	type: Boot source interface type.
+ *	index: When applicable, indicates the interface index (e.g. SPI #1,
+ *		NAND #0).
+ *	width: When applicable, indicates the interface bus width (e.g. NAND
+ *	8-bit).
+ *  freq: Frequency in Hz.
+ */
+struct sar_val {
+	u32 raw_sar_val;
+	union {
+		struct {
+			enum mvebu_bootsrc_type type;
+			int index;
+		} bootsrc;
+		u32 freq;
+		u32 clk_direction; /* input = 0 */
+	};
+};
+
+int mvebu_sar_init(void);
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val);
+void mvebu_sar_dump(struct udevice *dev);
+char *mvebu_sar_bootsrc_to_name(enum mvebu_bootsrc_type src);
+
+#endif	/* _MVEBU_CHIP_SAR_H_ */
diff --git a/include/mvebu/sar.h b/include/mvebu/sar.h
new file mode 100644
index 0000000000..82ec543514
--- /dev/null
+++ b/include/mvebu/sar.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _SAR_H_
+#define _SAR_H_
+
+#include <common.h>
+#include <linux/compiler.h>
+#include <mvebu/var.h>
+
+#define MAX_SAR_CHIPS	4
+#define MAX_SAR 8
+
+enum sar_variables {
+	CPUS_NUM_SAR = 0,
+	CPU0_ENDIANES_SAR,
+	FREQ_SAR,
+	CPU_FREQ_SAR,
+	FAB_REQ_SAR,
+	BOOT_SRC_SAR,
+	BOOT_WIDTH_SAR,
+	PEX_MODE_SAR,
+	L2_SIZE_SAR,
+	DRAM_ECC_SAR,
+	DRAM_BUS_WIDTH_SAR,
+};
+
+struct sar_var {
+	u8 start_bit;
+	u8 bit_length;
+	u8 option_cnt;
+	u8 active;
+	bool swap_bit;
+	char *desc;
+	char *key;
+	struct var_opts option_desc[MAX_VAR_OPTIONS];
+};
+
+struct sar_data {
+	u32	chip_addr[MAX_SAR_CHIPS];
+	u8	chip_count;
+	u8	bit_width;
+	struct sar_var sar_lookup[MAX_SAR];
+};
+
+int  sar_read_all(void);
+int  sar_default_key(const char *key);
+int  sar_default_all(void);
+int  sar_write_key(const char *key, int val);
+int  sar_print_key(const char *key);
+void sar_list_keys(void);
+int  sar_list_key_opts(const char *key);
+int  sar_is_available(void);
+void sar_init(void);
+
+#endif /* _SAR_H_ */
diff --git a/include/mvebu/var.h b/include/mvebu/var.h
new file mode 100644
index 0000000000..419eeda5c4
--- /dev/null
+++ b/include/mvebu/var.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _VAR_H_
+#define _VAR_H_
+
+#include <common.h>
+#include <linux/compiler.h>
+
+#define INVALID_KEY	0xFF
+#define MAX_VAR_OPTIONS	10
+
+#define VAR_IS_DEFAULT	0x1
+#define VAR_IS_LAST	0x2
+
+struct var_opts {
+	u8 value;
+	char *desc;
+	u8 flags;
+};
+
+struct var_desc {
+	char *key;
+	char *description;
+};
+
+#endif /* _VAR_H_ */
diff --git a/include/net.h b/include/net.h
index 75a16e4c8f..20942c7f30 100644
--- a/include/net.h
+++ b/include/net.h
@@ -237,6 +237,10 @@ int eth_initialize(void);		/* Initialize network subsystem */
 void eth_try_another(int first_restart);	/* Change the device */
 void eth_set_current(void);		/* set nterface to ethcur var */
 
+#ifdef CONFIG_MV88E6XXX_SWITCH
+int mv88e6xxx_initialize(const void *blob);
+#endif
+
 int eth_get_dev_index(void);		/* get the device index */
 
 /**
diff --git a/include/pci.h b/include/pci.h
index 298d0d4355..85163baea9 100644
--- a/include/pci.h
+++ b/include/pci.h
@@ -461,6 +461,9 @@
 #define PCI_EA_FIRST_ENT	4	/* First EA Entry in List */
 #define  PCI_EA_ES		0x00000007 /* Entry Size */
 #define  PCI_EA_BEI		0x000000f0 /* BAR Equivalent Indicator */
+/* 9-14 map to VF BARs 0-5 respectively */
+#define  PCI_EA_BEI_VF_BAR0	9
+#define  PCI_EA_BEI_VF_BAR5	14
 /* Base, MaxOffset registers */
 /* bit 0 is reserved */
 #define  PCI_EA_IS_64		0x00000002	/* 64-bit field flag */
@@ -471,6 +474,17 @@
 #define  PCI_EXP_DEVCAP_FLR     0x10000000 /* Function Level Reset */
 #define PCI_EXP_DEVCTL		8	/* Device Control */
 #define  PCI_EXP_DEVCTL_BCR_FLR 0x8000  /* Bridge Configuration Retry / FLR */
+/* Single Root I/O Virtualization Registers */
+#define PCI_SRIOV_CAP		0x04	/* SR-IOV Capabilities */
+#define PCI_SRIOV_CTRL		0x08	/* SR-IOV Control */
+#define  PCI_SRIOV_CTRL_VFE	0x01	/* VF Enable */
+#define  PCI_SRIOV_CTRL_MSE	0x08	/* VF Memory Space Enable */
+#define PCI_SRIOV_INITIAL_VF	0x0c	/* Initial VFs */
+#define PCI_SRIOV_TOTAL_VF	0x0e	/* Total VFs */
+#define PCI_SRIOV_NUM_VF	0x10	/* Number of VFs */
+#define PCI_SRIOV_VF_OFFSET	0x14	/* First VF Offset */
+#define PCI_SRIOV_VF_STRIDE	0x16	/* Following VF Stride */
+#define PCI_SRIOV_VF_DID	0x1a	/* VF Device ID */
 
 /* Include the ID list */
 
@@ -563,7 +577,7 @@ extern void pci_cfgfunc_do_nothing(struct pci_controller* hose, pci_dev_t dev,
 extern void pci_cfgfunc_config_device(struct pci_controller* hose, pci_dev_t dev,
 				      struct pci_config_table *);
 
-#define MAX_PCI_REGIONS		7
+#define MAX_PCI_REGIONS		10
 
 #define INDIRECT_TYPE_NO_PCIE_LINK	1
 
@@ -858,12 +872,19 @@ struct udevice;
  * @vendor:	PCI vendor ID (see pci_ids.h)
  * @device:	PCI device ID (see pci_ids.h)
  * @class:	PCI class, 3 bytes: (base, sub, prog-if)
+ * @is_virtfn:	Whether device is virtual function
+ * @pfdev:	Physical function device for VFs
+ * @virtid:	VF identifier
  */
 struct pci_child_platdata {
 	int devfn;
 	unsigned short vendor;
 	unsigned short device;
 	unsigned int class;
+
+	bool is_virtfn;
+	struct udevice *pfdev;
+	int virtid;
 };
 
 /* PCI bus operations */
@@ -1174,6 +1195,9 @@ int pci_generic_mmap_read_config(
 	ulong *valuep,
 	enum pci_size_t size);
 
+int pci_sriov_init(struct udevice *pdev, int vf_en);
+int pci_sriov_get_totalvfs(struct udevice *pdev);
+
 #ifdef CONFIG_DM_PCI_COMPAT
 /* Compatibility with old naming */
 static inline int pci_write_config_dword(pci_dev_t pcidev, int offset,
diff --git a/include/pci_ep.h b/include/pci_ep.h
index 00e8c6d8ab..ddde08ba4f 100644
--- a/include/pci_ep.h
+++ b/include/pci_ep.h
@@ -66,6 +66,7 @@ struct pci_bar {
  * struct pci_ep_header - represents standard configuration header
  * @vendorid: identifies device manufacturer
  * @deviceid: identifies a particular device
+ * @vf_deviceid: identifies virtual function device id for SRIOV
  * @revid: specifies a device-specific revision identifier
  * @progif_code: identifies a specific register-level programming interface
  * @subclass_code: identifies more specifically the function of the device
@@ -78,6 +79,7 @@ struct pci_bar {
 struct pci_ep_header {
 	u16	vendorid;
 	u16	deviceid;
+	u16     vf_deviceid;
 	u8	revid;
 	u8	progif_code;
 	u8	subclass_code;
diff --git a/include/pci_ids.h b/include/pci_ids.h
index bd59578ccb..f8b4f28996 100644
--- a/include/pci_ids.h
+++ b/include/pci_ids.h
@@ -2360,6 +2360,8 @@
 #define PCI_DEVICE_ID_ALTIMA_AC9100	0x03ea
 #define PCI_DEVICE_ID_ALTIMA_AC1003	0x03eb
 
+#define PCI_VENDOR_ID_CAVIUM		0x177d
+
 #define PCI_VENDOR_ID_BELKIN		0x1799
 #define PCI_DEVICE_ID_BELKIN_F5D7010V7	0x701f
 
diff --git a/include/phy.h b/include/phy.h
index f4530faeb9..b71c296b08 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -16,6 +16,10 @@
 #include <linux/mdio.h>
 #include <phy_interface.h>
 
+#ifdef CONFIG_DM_ETH
+#include <dm/device.h>
+#endif
+
 #define PHY_FIXED_ID		0xa5a55a5a
 
 #define PHY_MAX_ADDR 32
@@ -46,7 +50,7 @@
 				SUPPORTED_10000baseT_Full)
 
 #ifndef PHY_ANEG_TIMEOUT
-#define PHY_ANEG_TIMEOUT	4000
+#define PHY_ANEG_TIMEOUT	8000
 #endif
 
 
@@ -241,7 +245,10 @@ extern struct phy_driver gen10g_driver;
 /* For now, XGMII is the only 10G interface */
 static inline int is_10g_interface(phy_interface_t interface)
 {
-	return interface == PHY_INTERFACE_MODE_XGMII;
+	return (interface == PHY_INTERFACE_MODE_XGMII) ||
+	       (interface == PHY_INTERFACE_MODE_XAUI)  ||
+	       (interface == PHY_INTERFACE_MODE_XLAUI) ||
+	       (interface == PHY_INTERFACE_MODE_RXAUI);
 }
 
 #endif
diff --git a/include/phy_interface.h b/include/phy_interface.h
index c6823189f8..52809b1297 100644
--- a/include/phy_interface.h
+++ b/include/phy_interface.h
@@ -22,6 +22,8 @@ typedef enum {
 	PHY_INTERFACE_MODE_RGMII_RXID,
 	PHY_INTERFACE_MODE_RGMII_TXID,
 	PHY_INTERFACE_MODE_RTBI,
+	PHY_INTERFACE_MODE_1000BASEX,
+	PHY_INTERFACE_MODE_2500BASEX,
 	PHY_INTERFACE_MODE_XGMII,
 	PHY_INTERFACE_MODE_XAUI,
 	PHY_INTERFACE_MODE_RXAUI,
@@ -31,6 +33,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_XLAUI,
 	PHY_INTERFACE_MODE_CAUI2,
 	PHY_INTERFACE_MODE_CAUI4,
+	PHY_INTERFACE_MODE_AP,
 	PHY_INTERFACE_MODE_NONE,	/* Must be last */
 
 	PHY_INTERFACE_MODE_COUNT,
@@ -49,6 +52,8 @@ static const char * const phy_interface_strings[] = {
 	[PHY_INTERFACE_MODE_RGMII_RXID]		= "rgmii-rxid",
 	[PHY_INTERFACE_MODE_RGMII_TXID]		= "rgmii-txid",
 	[PHY_INTERFACE_MODE_RTBI]		= "rtbi",
+	[PHY_INTERFACE_MODE_1000BASEX]		= "1000base-x",
+	[PHY_INTERFACE_MODE_2500BASEX]		= "2500base-x",
 	[PHY_INTERFACE_MODE_XGMII]		= "xgmii",
 	[PHY_INTERFACE_MODE_XAUI]		= "xaui",
 	[PHY_INTERFACE_MODE_RXAUI]		= "rxaui",
@@ -58,6 +63,7 @@ static const char * const phy_interface_strings[] = {
 	[PHY_INTERFACE_MODE_XLAUI]		= "xlaui4",
 	[PHY_INTERFACE_MODE_CAUI2]		= "caui2",
 	[PHY_INTERFACE_MODE_CAUI4]		= "caui4",
+	[PHY_INTERFACE_MODE_AP]			= "ap",
 	[PHY_INTERFACE_MODE_NONE]		= "",
 };
 
diff --git a/include/power/regulator.h b/include/power/regulator.h
index 6c6e2cd4f9..b6883a53d2 100644
--- a/include/power/regulator.h
+++ b/include/power/regulator.h
@@ -149,6 +149,7 @@ enum regulator_flag {
  * @max_uA*    - maximum amperage (micro Amps)
  * @always_on* - bool type, true or false
  * @boot_on*   - bool type, true or false
+ * @force_off* - bool type, true or false
  * TODO(sjg@chromium.org): Consider putting the above two into @flags
  * @ramp_delay - Time to settle down after voltage change (unit: uV/us)
  * @flags:     - flags value (see REGULATOR_FLAG_...)
@@ -173,6 +174,7 @@ struct dm_regulator_uclass_platdata {
 	unsigned int ramp_delay;
 	bool always_on;
 	bool boot_on;
+	bool force_off;
 	const char *name;
 	int flags;
 	u8 ctrl_reg;
@@ -354,6 +356,15 @@ int regulator_set_mode(struct udevice *dev, int mode_id);
  */
 int regulators_enable_boot_on(bool verbose);
 
+/**
+ * regulators_enable_boot_off() - disable regulators needed for boot
+ *
+ * This disables all regulators which are marked to be off at boot time.
+ *
+ * This effectively calls regulator_unset() for every regulator.
+ */
+int regulators_enable_boot_off(bool verbose);
+
 /**
  * regulator_autoset: setup the voltage/current on a regulator
  *
@@ -373,6 +384,18 @@ int regulators_enable_boot_on(bool verbose);
  */
 int regulator_autoset(struct udevice *dev);
 
+/**
+ * regulator_unset: turn off a regulator
+ *
+ * The setup depends on constraints found in device's uclass's platform data
+ * (struct dm_regulator_uclass_platdata):
+ *
+ * - Disable - will set - if  'force_off' is set to true,
+ *
+ * The function returns on the first-encountered error.
+  */
+int regulator_unset(struct udevice *dev);
+
 /**
  * regulator_autoset_by_name: setup the regulator given by its uclass's
  * platform data name field. The setup depends on constraints found in device's
diff --git a/include/sar-uclass.h b/include/sar-uclass.h
new file mode 100644
index 0000000000..35de57d1d5
--- /dev/null
+++ b/include/sar-uclass.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <fdtdec.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+
+struct sar_ops {
+	int (*sar_init_func)(struct udevice *dev);
+	int (*sar_dump_func)(struct udevice *dev);
+	int (*sar_value_get_func)(struct udevice *dev, enum mvebu_sar_opts sar,
+				  struct sar_val *val);
+	int (*sar_bootsrc_get)(struct udevice *dev, u32 *idx);
+};
+
+struct dm_sar_pdata {
+	void __iomem *sar_base;
+	const char *sar_name;
+};
+
+int mvebu_sar_id_register(struct udevice *dev, u32 sar_id);
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 74430c8b2f..9de0152753 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -68,7 +68,12 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(ALTERA_SOCFPGA_F2SDR2, "altr,socfpga-fpga2sdram2-bridge"),
 	COMPAT(ALTERA_SOCFPGA_FPGA0, "altr,socfpga-a10-fpga-mgr"),
 	COMPAT(ALTERA_SOCFPGA_NOC, "altr,socfpga-a10-noc"),
-	COMPAT(ALTERA_SOCFPGA_CLK_INIT, "altr,socfpga-a10-clk-init")
+	COMPAT(ALTERA_SOCFPGA_CLK_INIT, "altr,socfpga-a10-clk-init"),
+	COMPAT(MVEBU_SAR, "marvell,sample-at-reset"),
+	COMPAT(MVEBU_SAR_REG_COMMON, "marvell,sample-at-reset-common"),
+	COMPAT(MVEBU_SAR_REG_AP806, "marvell,sample-at-reset-ap806"),
+	COMPAT(MVEBU_SAR_REG_CP110, "marvell,sample-at-reset-cp110"),
+
 };
 
 const char *fdtdec_get_compatible(enum fdt_compat_id id)
@@ -291,6 +296,23 @@ int fdtdec_get_pci_bar32(struct udevice *dev, struct fdt_pci_addr *addr,
 
 	return 0;
 }
+
+int fdtdec_get_pci_bus_range(const void *blob, int node,
+			     struct fdt_resource *res)
+{
+	const u32 *values;
+	int len;
+
+	values = fdt_getprop(blob, node, "bus-range", &len);
+	if (!values || len < sizeof(*values) * 2)
+		return -EINVAL;
+
+	res->start = be32_to_cpup(values++);
+	res->end = be32_to_cpup(values);
+
+	return 0;
+}
+
 #endif
 
 uint64_t fdtdec_get_uint64(const void *blob, int node, const char *prop_name,
diff --git a/localversion b/localversion
new file mode 100644
index 0000000000..fba5dc16c8
--- /dev/null
+++ b/localversion
@@ -0,0 +1 @@
+-10.0.0
diff --git a/net/bootp.c b/net/bootp.c
index 505489140e..e051cd2ade 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -595,6 +595,10 @@ static int dhcp_extended(u8 *e, int message_type, struct in_addr server_ip,
 #if defined(CONFIG_BOOTP_NTPSERVER)
 	*e++  = 42;
 	*cnt += 1;
+#endif
+#if defined(CONFIG_BOOTP_TFTP_SERVERIP)
+	*e++ = 150;
+	*cnt += 1;
 #endif
 	/* no options, so back up to avoid sending an empty request list */
 	if (*cnt == 0)
@@ -904,6 +908,11 @@ static void dhcp_process_options(uchar *popt, uchar *end)
 				net_boot_file_name[size] = 0;
 			}
 			break;
+#if defined(CONFIG_BOOTP_TFTP_SERVERIP)
+		case 150:
+			net_copy_ip(&net_server_ip, (u32 *)(popt + 2));
+			break;
+#endif
 		default:
 #if defined(CONFIG_BOOTP_VENDOREX)
 			if (dhcp_vendorex_proc(popt))
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 373094e59e..93a7edfe0f 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -1,9 +1,11 @@
 #!/usr/bin/env perl
+# SPDX-License-Identifier: GPL-2.0
+#
 # (c) 2001, Dave Jones. (the file handling bit)
 # (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)
 # (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)
 # (c) 2008-2010 Andy Whitcroft <apw@canonical.com>
-# Licensed under the terms of the GNU GPL License version 2
+# (c) 2010-2018 Joe Perches <joe@perches.com>
 
 use strict;
 use warnings;
@@ -11,6 +13,7 @@ use POSIX;
 use File::Basename;
 use Cwd 'abs_path';
 use Term::ANSIColor qw(:constants);
+use Encode qw(decode encode);
 
 my $P = $0;
 my $D = dirname(abs_path($P));
@@ -58,7 +61,7 @@ my $codespellfile = "/usr/share/codespell/dictionary.txt";
 my $conststructsfile = "$D/const_structs.checkpatch";
 my $typedefsfile = "";
 my $color = "auto";
-my $allow_c99_comments = 1;
+my $allow_c99_comments = 1; # Can be overridden by --ignore C99_COMMENT_TOLERANCE
 
 sub help {
 	my ($exitcode) = @_;
@@ -238,11 +241,11 @@ $check_orig = $check;
 
 my $exit = 0;
 
+my $perl_version_ok = 1;
 if ($^V && $^V lt $minimum_perl_version) {
+	$perl_version_ok = 0;
 	printf "$P: requires at least perl version %vd\n", $minimum_perl_version;
-	if (!$ignore_perl_version) {
-		exit(1);
-	}
+	exit(1) if (!$ignore_perl_version);
 }
 
 #if no filenames are given, push '-' to read patch from stdin
@@ -344,9 +347,10 @@ our $Sparse	= qr{
 			__force|
 			__iomem|
 			__must_check|
-			__init_refok|
 			__kprobes|
 			__ref|
+			__refconst|
+			__refdata|
 			__rcu|
 			__private
 		}x;
@@ -376,6 +380,7 @@ our $Attribute	= qr{
 			__noclone|
 			__deprecated|
 			__read_mostly|
+			__ro_after_init|
 			__kprobes|
 			$InitAttribute|
 			____cacheline_aligned|
@@ -461,8 +466,19 @@ our $logFunctions = qr{(?x:
 	seq_vprintf|seq_printf|seq_puts
 )};
 
+our $allocFunctions = qr{(?x:
+	(?:(?:devm_)?
+		(?:kv|k|v)[czm]alloc(?:_node|_array)? |
+		kstrdup(?:_const)? |
+		kmemdup(?:_nul)?) |
+	(?:\w+)?alloc_skb(?:ip_align)? |
+				# dev_alloc_skb/netdev_alloc_skb, et al
+	dma_alloc_coherent
+)};
+
 our $signature_tags = qr{(?xi:
 	Signed-off-by:|
+	Co-developed-by:|
 	Acked-by:|
 	Tested-by:|
 	Reviewed-by:|
@@ -568,6 +584,27 @@ foreach my $entry (@mode_permission_funcs) {
 }
 $mode_perms_search = "(?:${mode_perms_search})";
 
+our %deprecated_apis = (
+	"synchronize_rcu_bh"			=> "synchronize_rcu",
+	"synchronize_rcu_bh_expedited"		=> "synchronize_rcu_expedited",
+	"call_rcu_bh"				=> "call_rcu",
+	"rcu_barrier_bh"			=> "rcu_barrier",
+	"synchronize_sched"			=> "synchronize_rcu",
+	"synchronize_sched_expedited"		=> "synchronize_rcu_expedited",
+	"call_rcu_sched"			=> "call_rcu",
+	"rcu_barrier_sched"			=> "rcu_barrier",
+	"get_state_synchronize_sched"		=> "get_state_synchronize_rcu",
+	"cond_synchronize_sched"		=> "cond_synchronize_rcu",
+);
+
+#Create a search pattern for all these strings to speed up a loop below
+our $deprecated_apis_search = "";
+foreach my $entry (keys %deprecated_apis) {
+	$deprecated_apis_search .= '|' if ($deprecated_apis_search ne "");
+	$deprecated_apis_search .= $entry;
+}
+$deprecated_apis_search = "(?:${deprecated_apis_search})";
+
 our $mode_perms_world_writable = qr{
 	S_IWUGO		|
 	S_IWOTH		|
@@ -845,6 +882,17 @@ sub is_maintained_obsolete {
 	return $status =~ /obsolete/i;
 }
 
+sub is_SPDX_License_valid {
+	my ($license) = @_;
+
+	return 1 if (!$tree || which("python") eq "" || !(-e "$root/scripts/spdxcheck.py") || !(-e "$root/.git"));
+
+	my $root_path = abs_path($root);
+	my $status = `cd "$root_path"; echo "$license" | python scripts/spdxcheck.py -`;
+	return 0 if ($status ne "");
+	return 1;
+}
+
 my $camelcase_seeded = 0;
 sub seed_camelcase_includes {
 	return if ($camelcase_seeded);
@@ -973,6 +1021,7 @@ if ($git) {
 }
 
 my $vname;
+$allow_c99_comments = !defined $ignore_type{"C99_COMMENT_TOLERANCE"};
 for my $filename (@ARGV) {
 	my $FILE;
 	if ($git) {
@@ -1024,11 +1073,11 @@ if (!$quiet) {
 	hash_show_words(\%use_type, "Used");
 	hash_show_words(\%ignore_type, "Ignored");
 
-	if ($^V lt 5.10.0) {
+	if (!$perl_version_ok) {
 		print << "EOM"
 
 NOTE: perl $^V is not modern enough to detect all possible issues.
-      An upgrade to at least perl v5.10.0 is suggested.
+      An upgrade to at least perl $minimum_perl_version is suggested.
 EOM
 	}
 	if ($exit) {
@@ -2233,10 +2282,14 @@ sub process {
 
 	our $clean = 1;
 	my $signoff = 0;
+	my $author = '';
+	my $authorsignoff = 0;
 	my $is_patch = 0;
+	my $is_binding_patch = -1;
 	my $in_header_lines = $file ? 0 : 1;
 	my $in_commit_log = 0;		#Scanning lines before patch
 	my $has_commit_log = 0;		#Encountered lines before patch
+	my $commit_log_lines = 0;	#Number of commit log lines
 	my $commit_log_possible_stack_dump = 0;
 	my $commit_log_long_line = 0;
 	my $commit_log_has_diff = 0;
@@ -2375,6 +2428,14 @@ sub process {
 
 		my $rawline = $rawlines[$linenr - 1];
 
+# check if it's a mode change, rename or start of a patch
+		if (!$in_commit_log &&
+		    ($line =~ /^ mode change [0-7]+ => [0-7]+ \S+\s*$/ ||
+		    ($line =~ /^rename (?:from|to) \S+\s*$/ ||
+		     $line =~ /^diff --git a\/[\w\/\.\_\-]+ b\/\S+\s*$/))) {
+			$is_patch = 1;
+		}
+
 #extract the line range in the file after the patch is applied
 		if (!$in_commit_log &&
 		    $line =~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@(.*)/) {
@@ -2475,6 +2536,19 @@ sub process {
 				$check = $check_orig;
 			}
 			$checklicenseline = 1;
+
+			if ($realfile !~ /^MAINTAINERS/) {
+				my $last_binding_patch = $is_binding_patch;
+
+				$is_binding_patch = () = $realfile =~ m@^(?:Documentation/devicetree/|include/dt-bindings/)@;
+
+				if (($last_binding_patch != -1) &&
+				    ($last_binding_patch ^ $is_binding_patch)) {
+					WARN("DT_SPLIT_BINDING_PATCH",
+					     "DT binding docs and includes should be a separate patch. See: Documentation/devicetree/bindings/submitting-patches.txt\n");
+				}
+			}
+
 			next;
 		}
 
@@ -2486,6 +2560,18 @@ sub process {
 
 		$cnt_lines++ if ($realcnt != 0);
 
+# Verify the existence of a commit log if appropriate
+# 2 is used because a $signature is counted in $commit_log_lines
+		if ($in_commit_log) {
+			if ($line !~ /^\s*$/) {
+				$commit_log_lines++;	#could be a $signature
+			}
+		} elsif ($has_commit_log && $commit_log_lines < 2) {
+			WARN("COMMIT_MESSAGE",
+			     "Missing commit description - Add an appropriate one\n");
+			$commit_log_lines = 2;	#warn only once
+		}
+
 # Check if the commit log has what seems like a diff which can confuse patch
 		if ($in_commit_log && !$commit_log_has_diff &&
 		    (($line =~ m@^\s+diff\b.*a/[\w/]+@ &&
@@ -2507,10 +2593,24 @@ sub process {
 			}
 		}
 
+# Check the patch for a From:
+		if (decode("MIME-Header", $line) =~ /^From:\s*(.*)/) {
+			$author = $1;
+			$author = encode("utf8", $author) if ($line =~ /=\?utf-8\?/i);
+			$author =~ s/"//g;
+		}
+
 # Check the patch for a signoff:
 		if ($line =~ /^\s*signed-off-by:/i) {
 			$signoff++;
 			$in_commit_log = 0;
+			if ($author ne '') {
+				my $l = $line;
+				$l =~ s/"//g;
+				if ($l =~ /^\s*signed-off-by:\s*\Q$author\E/i) {
+				    $authorsignoff = 1;
+				}
+			}
 		}
 
 # Check if MAINTAINERS is being updated.  If so, there's probably no need to
@@ -2587,6 +2687,24 @@ sub process {
 			} else {
 				$signatures{$sig_nospace} = 1;
 			}
+
+# Check Co-developed-by: immediately followed by Signed-off-by: with same name and email
+			if ($sign_off =~ /^co-developed-by:$/i) {
+				if ($email eq $author) {
+					WARN("BAD_SIGN_OFF",
+					      "Co-developed-by: should not be used to attribute nominal patch author '$author'\n" . "$here\n" . $rawline);
+				}
+				if (!defined $lines[$linenr]) {
+					WARN("BAD_SIGN_OFF",
+                                             "Co-developed-by: must be immediately followed by Signed-off-by:\n" . "$here\n" . $rawline);
+				} elsif ($rawlines[$linenr] !~ /^\s*signed-off-by:\s*(.*)/i) {
+					WARN("BAD_SIGN_OFF",
+					     "Co-developed-by: must be immediately followed by Signed-off-by:\n" . "$here\n" . $rawline . "\n" .$rawlines[$linenr]);
+				} elsif ($1 ne $email) {
+					WARN("BAD_SIGN_OFF",
+					     "Co-developed-by and Signed-off-by: name/email do not match \n" . "$here\n" . $rawline . "\n" .$rawlines[$linenr]);
+				}
+			}
 		}
 
 # Check email subject for common tools that don't need to be mentioned
@@ -2596,12 +2714,6 @@ sub process {
 			     "A patch subject line should describe the change not the tool that found it\n" . $herecurr);
 		}
 
-# Check for old stable address
-		if ($line =~ /^\s*cc:\s*.*<?\bstable\@kernel\.org\b>?.*$/i) {
-			ERROR("STABLE_ADDRESS",
-			      "The 'stable' address should be 'stable\@vger.kernel.org'\n" . $herecurr);
-		}
-
 # Check for unwanted Gerrit info
 		if ($in_commit_log && $line =~ /^\s*change-id:/i) {
 			ERROR("GERRIT_CHANGE_ID",
@@ -2915,7 +3027,7 @@ sub process {
 			my @compats = $rawline =~ /\"([a-zA-Z0-9\-\,\.\+_]+)\"/g;
 
 			my $dt_path = $root . "/Documentation/devicetree/bindings/";
-			my $vp_file = $dt_path . "vendor-prefixes.txt";
+			my $vp_file = $dt_path . "vendor-prefixes.yaml";
 
 			foreach my $compat (@compats) {
 				my $compat2 = $compat;
@@ -2930,7 +3042,7 @@ sub process {
 
 				next if $compat !~ /^([a-zA-Z0-9\-]+)\,/;
 				my $vendor = $1;
-				`grep -Eq "^$vendor\\b" $vp_file`;
+				`grep -Eq "\\"\\^\Q$vendor\E,\\.\\*\\":" $vp_file`;
 				if ( $? >> 8 ) {
 					WARN("UNDOCUMENTED_DT_STRING",
 					     "DT compatible string vendor \"$vendor\" appears un-documented -- check $vp_file\n" . $herecurr);
@@ -2954,10 +3066,24 @@ sub process {
 					$comment = '..';
 				}
 
+# check SPDX comment style for .[chsS] files
+				if ($realfile =~ /\.[chsS]$/ &&
+				    $rawline =~ /SPDX-License-Identifier:/ &&
+				    $rawline !~ /^\+\s*\Q$comment\E\s*/) {
+					WARN("SPDX_LICENSE_TAG",
+					     "Improper SPDX comment style for '$realfile', please use '$comment' instead\n" . $herecurr);
+				}
+
 				if ($comment !~ /^$/ &&
 				    $rawline !~ /^\+\Q$comment\E SPDX-License-Identifier: /) {
-					WARN("SPDX_LICENSE_TAG",
-					     "Missing or malformed SPDX-License-Identifier tag in line $checklicenseline\n" . $herecurr);
+					 WARN("SPDX_LICENSE_TAG",
+					      "Missing or malformed SPDX-License-Identifier tag in line $checklicenseline\n" . $herecurr);
+				} elsif ($rawline =~ /(SPDX-License-Identifier: .*)/) {
+					 my $spdx_license = $1;
+					 if (!is_SPDX_License_valid($spdx_license)) {
+						  WARN("SPDX_LICENSE_TAG",
+						       "'$spdx_license' is not supported in LICENSES/...\n" . $herecurr);
+					 }
 				}
 			}
 		}
@@ -2965,6 +3091,14 @@ sub process {
 # check we are in a valid source file if not then ignore this hunk
 		next if ($realfile !~ /\.(h|c|s|S|sh|dtsi|dts)$/);
 
+# check for using SPDX-License-Identifier on the wrong line number
+		if ($realline != $checklicenseline &&
+		    $rawline =~ /\bSPDX-License-Identifier:/ &&
+		    substr($line, @-, @+ - @-) eq "$;" x (@+ - @-)) {
+			WARN("SPDX_LICENSE_TAG",
+			     "Misplaced SPDX-License-Identifier tag - use line $checklicenseline instead\n" . $herecurr);
+		}
+
 # line length limit (with some exclusions)
 #
 # There are a few types of lines that may extend beyond $max_line_length:
@@ -3062,6 +3196,12 @@ sub process {
 			}
 		}
 
+# check for assignments on the start of a line
+		if ($sline =~ /^\+\s+($Assignment)[^=]/) {
+			CHK("ASSIGNMENT_CONTINUATIONS",
+			    "Assignment operator '$1' should be on the previous line\n" . $hereprev);
+		}
+
 # check for && or || at the start of a line
 		if ($rawline =~ /^\+\s*(&&|\|\|)/) {
 			CHK("LOGICAL_CONTINUATIONS",
@@ -3069,7 +3209,7 @@ sub process {
 		}
 
 # check indentation starts on a tab stop
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $sline =~ /^\+\t+( +)(?:$c90_Keywords\b|\{\s*$|\}\s*(?:else\b|while\b|\s*$)|$Declare\s*$Ident\s*[;=])/) {
 			my $indent = length($1);
 			if ($indent % 8) {
@@ -3082,7 +3222,7 @@ sub process {
 		}
 
 # check multi-line statement indentation matches previous line
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $prevline =~ /^\+([ \t]*)((?:$c90_Keywords(?:\s+if)\s*)|(?:$Declare\s*)?(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*|(?:\*\s*)*$Lval\s*=\s*$Ident\s*)\(.*(\&\&|\|\||,)\s*$/) {
 			$prevline =~ /^\+(\t*)(.*)$/;
 			my $oldindent = $1;
@@ -3239,7 +3379,7 @@ sub process {
 			# known declaration macros
 		      $sline =~ /^\+\s+$declaration_macros/ ||
 			# start of struct or union or enum
-		      $sline =~ /^\+\s+(?:union|struct|enum|typedef)\b/ ||
+		      $sline =~ /^\+\s+(?:static\s+)?(?:const\s+)?(?:union|struct|enum|typedef)\b/ ||
 			# start or end of block or continuation of declaration
 		      $sline =~ /^\+\s+(?:$|[\{\}\.\#\"\?\:\(\[])/ ||
 			# bitfield continuation
@@ -3771,19 +3911,48 @@ sub process {
 			     "type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\n" . $herecurr);
 		}
 
+# check for unnecessary <signed> int declarations of short/long/long long
+		while ($sline =~ m{\b($TypeMisordered(\s*\*)*|$C90_int_types)\b}g) {
+			my $type = trim($1);
+			next if ($type !~ /\bint\b/);
+			next if ($type !~ /\b(?:short|long\s+long|long)\b/);
+			my $new_type = $type;
+			$new_type =~ s/\b\s*int\s*\b/ /;
+			$new_type =~ s/\b\s*(?:un)?signed\b\s*/ /;
+			$new_type =~ s/^const\s+//;
+			$new_type = "unsigned $new_type" if ($type =~ /\bunsigned\b/);
+			$new_type = "const $new_type" if ($type =~ /^const\b/);
+			$new_type =~ s/\s+/ /g;
+			$new_type = trim($new_type);
+			if (WARN("UNNECESSARY_INT",
+				 "Prefer '$new_type' over '$type' as the int is unnecessary\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\b\Q$type\E\b/$new_type/;
+			}
+		}
+
 # check for static const char * arrays.
 		if ($line =~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*=\s*/) {
 			WARN("STATIC_CONST_CHAR_ARRAY",
 			     "static const char * array should probably be static const char * const\n" .
 				$herecurr);
-               }
+		}
+
+# check for initialized const char arrays that should be static const
+		if ($line =~ /^\+\s*const\s+(char|unsigned\s+char|_*u8|(?:[us]_)?int8_t)\s+\w+\s*\[\s*(?:\w+\s*)?\]\s*=\s*"/) {
+			if (WARN("STATIC_CONST_CHAR_ARRAY",
+				 "const array should probably be static const\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/(^.\s*)const\b/${1}static const/;
+			}
+		}
 
 # check for static char foo[] = "bar" declarations.
 		if ($line =~ /\bstatic\s+char\s+(\w+)\s*\[\s*\]\s*=\s*"/) {
 			WARN("STATIC_CONST_CHAR_ARRAY",
 			     "static char array declaration should probably be static const char\n" .
 				$herecurr);
-               }
+		}
 
 # check for const <foo> const where <foo> is not a pointer or array type
 		if ($sline =~ /\bconst\s+($BasicType)\s+const\b/) {
@@ -3957,7 +4126,7 @@ sub process {
 
 # function brace can't be on same line, except for #defines of do while,
 # or if closed on same line
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $sline =~ /$Type\s*$Ident\s*$balanced_parens\s*\{/ &&
 		    $sline !~ /\#\s*define\b.*do\s*\{/ &&
 		    $sline !~ /}/) {
@@ -4083,7 +4252,7 @@ sub process {
 			my ($where, $prefix) = ($-[1], $1);
 			if ($prefix !~ /$Type\s+$/ &&
 			    ($where != 0 || $prefix !~ /^.\s+$/) &&
-			    $prefix !~ /[{,]\s+$/) {
+			    $prefix !~ /[{,:]\s+$/) {
 				if (ERROR("BRACKET_SPACE",
 					  "space prohibited before open square bracket '['\n" . $herecurr) &&
 				    $fix) {
@@ -4473,11 +4642,11 @@ sub process {
 
 #need space before brace following if, while, etc
 		if (($line =~ /\(.*\)\{/ && $line !~ /\($Type\)\{/) ||
-		    $line =~ /do\{/) {
+		    $line =~ /\b(?:else|do)\{/) {
 			if (ERROR("SPACING",
 				  "space required before the open brace '{'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$fixlinenr] =~ s/^(\+.*(?:do|\)))\{/$1 {/;
+				$fixed[$fixlinenr] =~ s/^(\+.*(?:do|else|\)))\{/$1 {/;
 			}
 		}
 
@@ -4568,7 +4737,7 @@ sub process {
 # check for unnecessary parentheses around comparisons in if uses
 # when !drivers/staging or command-line uses --strict
 		if (($realfile !~ m@^(?:drivers/staging/)@ || $check_orig) &&
-		    $^V && $^V ge 5.10.0 && defined($stat) &&
+		    $perl_version_ok && defined($stat) &&
 		    $stat =~ /(^.\s*if\s*($balanced_parens))/) {
 			my $if_stat = $1;
 			my $test = substr($2, 1, -1);
@@ -4605,7 +4774,7 @@ sub process {
 # return is not a function
 		if (defined($stat) && $stat =~ /^.\s*return(\s*)\(/s) {
 			my $spacing = $1;
-			if ($^V && $^V ge 5.10.0 &&
+			if ($perl_version_ok &&
 			    $stat =~ /^.\s*return\s*($balanced_parens)\s*;\s*$/) {
 				my $value = $1;
 				$value = deparenthesize($value);
@@ -4632,7 +4801,7 @@ sub process {
                }
 
 # if statements using unnecessary parentheses - ie: if ((foo == bar))
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /\bif\s*((?:\(\s*){2,})/) {
 			my $openparens = $1;
 			my $count = $openparens =~ tr@\(@\(@;
@@ -4649,7 +4818,7 @@ sub process {
 #	avoid cases like "foo + BAR < baz"
 #	only fix matches surrounded by parentheses to avoid incorrect
 #	conversions like "FOO < baz() + 5" being "misfixed" to "baz() > FOO + 5"
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /^\+(.*)\b($Constant|[A-Z_][A-Z0-9_]*)\s*($Compare)\s*($LvalOrFunc)/) {
 			my $lead = $1;
 			my $const = $2;
@@ -4841,17 +5010,6 @@ sub process {
 		while ($line =~ m{($Constant|$Lval)}g) {
 			my $var = $1;
 
-#gcc binary extension
-			if ($var =~ /^$Binary$/) {
-				if (WARN("GCC_BINARY_CONSTANT",
-					 "Avoid gcc v4.3+ binary constant extension: <$var>\n" . $herecurr) &&
-				    $fix) {
-					my $hexval = sprintf("0x%x", oct($var));
-					$fixed[$fixlinenr] =~
-					    s/\b$var\b/$hexval/;
-				}
-			}
-
 #CamelCase
 			if ($var !~ /^$Constant$/ &&
 			    $var =~ /[A-Z][a-z]|[a-z][A-Z]/ &&
@@ -4939,6 +5097,7 @@ sub process {
 			if (defined $define_args && $define_args ne "") {
 				$define_args = substr($define_args, 1, length($define_args) - 2);
 				$define_args =~ s/\s*//g;
+				$define_args =~ s/\\\+?//g;
 				@def_args = split(",", $define_args);
 			}
 
@@ -5035,7 +5194,7 @@ sub process {
 				$tmp_stmt =~ s/\b(typeof|__typeof__|__builtin\w+|typecheck\s*\(\s*$Type\s*,|\#+)\s*\(*\s*$arg\s*\)*\b//g;
 				$tmp_stmt =~ s/\#+\s*$arg\b//g;
 				$tmp_stmt =~ s/\b$arg\s*\#\#//g;
-				my $use_cnt = $tmp_stmt =~ s/\b$arg\b//g;
+				my $use_cnt = () = $tmp_stmt =~ /\b$arg\b/g;
 				if ($use_cnt > 1) {
 					CHK("MACRO_ARG_REUSE",
 					    "Macro argument reuse '$arg' - possible side-effects?\n" . "$herectx");
@@ -5074,7 +5233,7 @@ sub process {
 # do {} while (0) macro tests:
 # single-statement macros do not need to be enclosed in do while (0) loop,
 # macro should not end with a semicolon
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $realfile !~ m@/vmlinux.lds.h$@ &&
 		    $line =~ /^.\s*\#\s*define\s+$Ident(\()?/) {
 			my $ln = $linenr;
@@ -5115,16 +5274,6 @@ sub process {
 			}
 		}
 
-# make sure symbols are always wrapped with VMLINUX_SYMBOL() ...
-# all assignments may have only one of the following with an assignment:
-#	.
-#	ALIGN(...)
-#	VMLINUX_SYMBOL(...)
-		if ($realfile eq 'vmlinux.lds.h' && $line =~ /(?:(?:^|\s)$Ident\s*=|=\s*$Ident(?:\s|$))/) {
-			WARN("MISSING_VMLINUX_SYMBOL",
-			     "vmlinux.lds.h needs VMLINUX_SYMBOL() around C-visible symbols\n" . $herecurr);
-		}
-
 # check for redundant bracing round if etc
 		if ($line =~ /(^.*)\bif\b/ && $1 !~ /else\s*$/) {
 			my ($level, $endln, @chunks) =
@@ -5330,15 +5479,28 @@ sub process {
 		}
 
 # concatenated string without spaces between elements
-		if ($line =~ /$String[A-Z_]/ || $line =~ /[A-Za-z0-9_]$String/) {
-			CHK("CONCATENATED_STRING",
-			    "Concatenated strings should use spaces between elements\n" . $herecurr);
+		if ($line =~ /$String[A-Za-z0-9_]/ || $line =~ /[A-Za-z0-9_]$String/) {
+			if (CHK("CONCATENATED_STRING",
+				"Concatenated strings should use spaces between elements\n" . $herecurr) &&
+			    $fix) {
+				while ($line =~ /($String)/g) {
+					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);
+					$fixed[$fixlinenr] =~ s/\Q$extracted_string\E([A-Za-z0-9_])/$extracted_string $1/;
+					$fixed[$fixlinenr] =~ s/([A-Za-z0-9_])\Q$extracted_string\E/$1 $extracted_string/;
+				}
+			}
 		}
 
 # uncoalesced string fragments
 		if ($line =~ /$String\s*"/) {
-			WARN("STRING_FRAGMENTS",
-			     "Consecutive strings are generally better as a single string\n" . $herecurr);
+			if (WARN("STRING_FRAGMENTS",
+				 "Consecutive strings are generally better as a single string\n" . $herecurr) &&
+			    $fix) {
+				while ($line =~ /($String)(?=\s*")/g) {
+					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);
+					$fixed[$fixlinenr] =~ s/\Q$extracted_string\E\s*"/substr($extracted_string, 0, -1)/e;
+				}
+			}
 		}
 
 # check for non-standard and hex prefixed decimal printf formats
@@ -5374,9 +5536,14 @@ sub process {
 
 # warn about #if 0
 		if ($line =~ /^.\s*\#\s*if\s+0\b/) {
-			CHK("REDUNDANT_CODE",
-			    "if this code is redundant consider removing it\n" .
-				$herecurr);
+			WARN("IF_0",
+			     "Consider removing the code enclosed by this #if 0 and its #endif\n" . $herecurr);
+		}
+
+# warn about #if 1
+		if ($line =~ /^.\s*\#\s*if\s+1\b/) {
+			WARN("IF_1",
+			     "Consider removing the #if 1 and its #endif\n" . $herecurr);
 		}
 
 # check for needless "if (<foo>) fn(<foo>)" uses
@@ -5423,7 +5590,8 @@ sub process {
 			my ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);
 #			print("line: <$line>\nprevline: <$prevline>\ns: <$s>\nc: <$c>\n\n\n");
 
-			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*(?:devm_)?(?:[kv][czm]alloc(?:_node|_array)?\b|kstrdup|kmemdup|(?:dev_)?alloc_skb)/) {
+			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*$allocFunctions\s*\(/ &&
+			    $s !~ /\b__GFP_NOWARN\b/ ) {
 				WARN("OOM_MESSAGE",
 				     "Possible unnecessary 'out of memory' message\n" . $hereprev);
 			}
@@ -5447,7 +5615,7 @@ sub process {
 		}
 
 # check for mask then right shift without a parentheses
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /$LvalOrFunc\s*\&\s*($LvalOrFunc)\s*>>/ &&
 		    $4 !~ /^\&/) { # $LvalOrFunc may be &foo, ignore if so
 			WARN("MASK_THEN_SHIFT",
@@ -5455,7 +5623,7 @@ sub process {
 		}
 
 # check for pointer comparisons to NULL
-		if ($^V && $^V ge 5.10.0) {
+		if ($perl_version_ok) {
 			while ($line =~ /\b$LvalOrFunc\s*(==|\!=)\s*NULL\b/g) {
 				my $val = $1;
 				my $equal = "!";
@@ -5544,7 +5712,7 @@ sub process {
 			# ignore udelay's < 10, however
 			if (! ($delay < 10) ) {
 				CHK("USLEEP_RANGE",
-				    "usleep_range is preferred over udelay; see Documentation/timers/timers-howto.txt\n" . $herecurr);
+				    "usleep_range is preferred over udelay; see Documentation/timers/timers-howto.rst\n" . $herecurr);
 			}
 			if ($delay > 2000) {
 				WARN("LONG_UDELAY",
@@ -5556,7 +5724,7 @@ sub process {
 		if ($line =~ /\bmsleep\s*\((\d+)\);/) {
 			if ($1 < 20) {
 				WARN("MSLEEP",
-				     "msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt\n" . $herecurr);
+				     "msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.rst\n" . $herecurr);
 			}
 		}
 
@@ -5698,13 +5866,6 @@ sub process {
 			     "__packed is preferred over __attribute__((packed))\n" . $herecurr);
 		}
 
-# Check for new packed members, warn to use care
-		if ($realfile !~ m@\binclude/uapi/@ &&
-		    $line =~ /\b(__attribute__\s*\(\s*\(.*\bpacked|__packed)\b/) {
-			WARN("NEW_PACKED",
-			     "Adding new packed members is to be done with care\n" . $herecurr);
-		}
-
 # Check for __attribute__ aligned, prefer __aligned
 		if ($realfile !~ m@\binclude/uapi/@ &&
 		    $line =~ /\b__attribute__\s*\(\s*\(.*aligned/) {
@@ -5734,7 +5895,7 @@ sub process {
 		}
 
 # Check for __attribute__ weak, or __weak declarations (may have link issues)
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /(?:$Declare|$DeclareMisordered)\s*$Ident\s*$balanced_parens\s*(?:$Attribute)?\s*;/ &&
 		    ($line =~ /\b__attribute__\s*\(\s*\(.*\bweak\b/ ||
 		     $line =~ /\b__weak\b/)) {
@@ -5816,25 +5977,25 @@ sub process {
 		}
 
 # check for vsprintf extension %p<foo> misuses
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?![^\{]*\{\s*).*\b(\w+)\s*\(.*$String\s*,/s &&
 		    $1 !~ /^_*volatile_*$/) {
-			my $specifier;
-			my $extension;
-			my $bad_specifier = "";
 			my $stat_real;
 
 			my $lc = $stat =~ tr@\n@@;
 			$lc = $lc + $linenr;
 		        for (my $count = $linenr; $count <= $lc; $count++) {
+				my $specifier;
+				my $extension;
+				my $bad_specifier = "";
 				my $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));
 				$fmt =~ s/%%//g;
 
 				while ($fmt =~ /(\%[\*\d\.]*p(\w))/g) {
 					$specifier = $1;
 					$extension = $2;
-					if ($extension !~ /[SsBKRraEhMmIiUDdgVCbGNOx]/) {
+					if ($extension !~ /[SsBKRraEhMmIiUDdgVCbGNOxt]/) {
 						$bad_specifier = $specifier;
 						last;
 					}
@@ -5863,7 +6024,7 @@ sub process {
 		}
 
 # Check for misused memsets
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*$FuncArg\s*\)/) {
 
@@ -5881,7 +6042,7 @@ sub process {
 		}
 
 # Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #			if (WARN("PREFER_ETHER_ADDR_COPY",
@@ -5892,7 +6053,7 @@ sub process {
 #		}
 
 # Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemcmp\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #			WARN("PREFER_ETHER_ADDR_EQUAL",
@@ -5901,7 +6062,7 @@ sub process {
 
 # check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr
 # check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #
@@ -5923,7 +6084,7 @@ sub process {
 #		}
 
 # typecasts on min/max could be min_t/max_t
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\b(min|max)\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\)/) {
 			if (defined $2 || defined $7) {
@@ -5947,23 +6108,23 @@ sub process {
 		}
 
 # check usleep_range arguments
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\busleep_range\s*\(\s*($FuncArg)\s*,\s*($FuncArg)\s*\)/) {
 			my $min = $1;
 			my $max = $7;
 			if ($min eq $max) {
 				WARN("USLEEP_RANGE",
-				     "usleep_range should not use min == max args; see Documentation/timers/timers-howto.txt\n" . "$here\n$stat\n");
+				     "usleep_range should not use min == max args; see Documentation/timers/timers-howto.rst\n" . "$here\n$stat\n");
 			} elsif ($min =~ /^\d+$/ && $max =~ /^\d+$/ &&
 				 $min > $max) {
 				WARN("USLEEP_RANGE",
-				     "usleep_range args reversed, use min then max; see Documentation/timers/timers-howto.txt\n" . "$here\n$stat\n");
+				     "usleep_range args reversed, use min then max; see Documentation/timers/timers-howto.rst\n" . "$here\n$stat\n");
 			}
 		}
 
 # check for naked sscanf
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /\bsscanf\b/ &&
 		    ($stat !~ /$Ident\s*=\s*sscanf\s*$balanced_parens/ &&
@@ -5977,7 +6138,7 @@ sub process {
 		}
 
 # check for simple sscanf that should be kstrto<foo>
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /\bsscanf\b/) {
 			my $lc = $stat =~ tr@\n@@;
@@ -6049,7 +6210,7 @@ sub process {
 		}
 
 # check for function definitions
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^.\s*(?:$Storage\s+)?$Type\s*($Ident)\s*$balanced_parens\s*{/s) {
 			$context_function = $1;
@@ -6081,22 +6242,22 @@ sub process {
 			}
 		}
 
-# check for pointless casting of kmalloc return
-		if ($line =~ /\*\s*\)\s*[kv][czm]alloc(_node){0,1}\b/) {
+# check for pointless casting of alloc functions
+		if ($line =~ /\*\s*\)\s*$allocFunctions\b/) {
 			WARN("UNNECESSARY_CASTS",
 			     "unnecessary cast may hide bugs, see http://c-faq.com/malloc/mallocnocast.html\n" . $herecurr);
 		}
 
 # alloc style
 # p = alloc(sizeof(struct foo), ...) should be p = alloc(sizeof(*p), ...)
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*([kv][mz]alloc(?:_node)?)\s*\(\s*(sizeof\s*\(\s*struct\s+$Lval\s*\))/) {
+		if ($perl_version_ok &&
+		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*((?:kv|k|v)[mz]alloc(?:_node)?)\s*\(\s*(sizeof\s*\(\s*struct\s+$Lval\s*\))/) {
 			CHK("ALLOC_SIZEOF_STRUCT",
 			    "Prefer $3(sizeof(*$1)...) over $3($4...)\n" . $herecurr);
 		}
 
 # check for k[mz]alloc with multiplies that could be kmalloc_array/kcalloc
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+\s*($Lval)\s*\=\s*(?:$balanced_parens)?\s*(k[mz]alloc)\s*\(\s*($FuncArg)\s*\*\s*($FuncArg)\s*,/) {
 			my $oldfunc = $3;
@@ -6125,8 +6286,9 @@ sub process {
 		}
 
 # check for krealloc arg reuse
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*krealloc\s*\(\s*\1\s*,/) {
+		if ($perl_version_ok &&
+		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*krealloc\s*\(\s*($Lval)\s*,/ &&
+		    $1 eq $3) {
 			WARN("KREALLOC_ARG_REUSE",
 			     "Reusing the krealloc arg is almost always a bug\n" . $herecurr);
 		}
@@ -6194,7 +6356,7 @@ sub process {
 		}
 
 # check for switch/default statements without a break;
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+[$;\s]*(?:case[$;\s]+\w+[$;\s]*:[$;\s]*|)*[$;\s]*\bdefault[$;\s]*:[$;\s]*;/g) {
 			my $cnt = statement_rawlines($stat);
@@ -6270,6 +6432,20 @@ sub process {
 			     "please use device_initcall() or more appropriate function instead of __initcall() (see include/linux/init.h)\n" . $herecurr);
 		}
 
+# check for spin_is_locked(), suggest lockdep instead
+		if ($line =~ /\bspin_is_locked\(/) {
+			WARN("USE_LOCKDEP",
+			     "Where possible, use lockdep_assert_held instead of assertions based on spin_is_locked\n" . $herecurr);
+		}
+
+# check for deprecated apis
+		if ($line =~ /\b($deprecated_apis_search)\b\s*\(/) {
+			my $deprecated_api = $1;
+			my $new_api = $deprecated_apis{$deprecated_api};
+			WARN("DEPRECATED_API",
+			     "Deprecated use of '$deprecated_api', prefer '$new_api' instead\n" . $herecurr);
+		}
+
 # check for various structs that are normally const (ops, kgdb, device_tree)
 # and avoid what seem like struct definitions 'struct foo {'
 		if ($line !~ /\bconst\b/ &&
@@ -6298,7 +6474,7 @@ sub process {
 		}
 
 # likely/unlikely comparisons similar to "(likely(foo) > 0)"
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /\b((?:un)?likely)\s*\(\s*$FuncArg\s*\)\s*$Compare/) {
 			WARN("LIKELY_MISUSE",
 			     "Using $1 should generally have parentheses around the comparison\n" . $herecurr);
@@ -6341,7 +6517,7 @@ sub process {
 # check for DEVICE_ATTR uses that could be DEVICE_ATTR_<FOO>
 # and whether or not function naming is typical and if
 # DEVICE_ATTR permissions uses are unusual too
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /\bDEVICE_ATTR\s*\(\s*(\w+)\s*,\s*\(?\s*(\s*(?:${multi_mode_perms_string_search}|0[0-7]{3,3})\s*)\s*\)?\s*,\s*(\w+)\s*,\s*(\w+)\s*\)/) {
 			my $var = $1;
@@ -6401,7 +6577,7 @@ sub process {
 #   specific definition of not visible in sysfs.
 # o Ignore proc_create*(...) uses with a decimal 0 permission as that means
 #   use the default permissions
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /$mode_perms_search/) {
 			foreach my $entry (@mode_permission_funcs) {
@@ -6463,6 +6639,12 @@ sub process {
 				     "unknown module license " . $extracted_string . "\n" . $herecurr);
 			}
 		}
+
+# check for sysctl duplicate constants
+		if ($line =~ /\.extra[12]\s*=\s*&(zero|one|int_max)\b/) {
+			WARN("DUPLICATED_SYSCTL_CONST",
+				"duplicated sysctl range checking value '$1', consider using the shared one in include/linux/sysctl.h\n" . $herecurr);
+		}
 	}
 
 	# If we have no input at all, then there is nothing to report on
@@ -6487,9 +6669,14 @@ sub process {
 		ERROR("NOT_UNIFIED_DIFF",
 		      "Does not appear to be a unified-diff format patch\n");
 	}
-	if ($is_patch && $has_commit_log && $chk_signoff && $signoff == 0) {
-		ERROR("MISSING_SIGN_OFF",
-		      "Missing Signed-off-by: line(s)\n");
+	if ($is_patch && $has_commit_log && $chk_signoff) {
+		if ($signoff == 0) {
+			ERROR("MISSING_SIGN_OFF",
+			      "Missing Signed-off-by: line(s)\n");
+		} elsif (!$authorsignoff) {
+			WARN("NO_AUTHOR_SIGN_OFF",
+			     "Missing Signed-off-by: line by nominal patch author '$author'\n");
+		}
 	}
 
 	print report_dump();
diff --git a/scripts/ci/baseline.txt b/scripts/ci/baseline.txt
new file mode 100644
index 0000000000..b84097cca3
--- /dev/null
+++ b/scripts/ci/baseline.txt
@@ -0,0 +1,7 @@
+#
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+#
+# Copyright (C) 2018 Marvell International Ltd.
+# commit id of base tag for this branch
+61ba1244b548463dbfb3c5285b6b22e7c772c5bd (tag: v2019.10) Prepare v2019.10
diff --git a/scripts/ci/compile.sh b/scripts/ci/compile.sh
new file mode 100755
index 0000000000..d9d75d8158
--- /dev/null
+++ b/scripts/ci/compile.sh
@@ -0,0 +1,244 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the compile script for u-boot                                     ##
+## This script is called by CI automated builds                              ##
+## It may also be used interactively by users to compile the same way as CI  ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -euo pipefail
+shopt -s extglob
+##==================================== USAGE ================================##
+function usage {
+	echo """
+Usage: compile [--no_configure] [--echo_only] BUILD_NAME
+ or:   compile --list
+ or:   compile --help
+
+Compiles u-boot similar to the given CI build
+
+ -N, --no_configure   Skip configuration steps (mrproper, make defconfig)
+ -e, --echo_only      Print out the compilation sequence but do not execute it
+ -l, --list           List all supported BUILD_NAME values and exit
+ -h, --help           Display this help and exit
+
+Prerequisites:       CROSS_COMPILE must point to the cross compiler
+
+"""
+	exit 0
+}
+##============================ PARSE ARGUMENTS ==============================##
+TEMP=`getopt -a -o Nelh --long no_configure,echo_only,list,help \
+             -n 'compile' -- "$@"`
+
+if [ $? != 0 ] ; then
+	echo "Error: Failed parsing command options" >&2
+	exit 1
+fi
+eval set -- "$TEMP"
+
+no_configure=
+echo_only=
+list=
+
+while true; do
+	case "$1" in
+		-N | --no_configure ) no_configure=true; shift ;;
+		-e | --echo_only )    echo_only=true; shift ;;
+		-l | --list ) 	      list=true; shift ;;
+		-h | --help )         usage; ;;
+		-- ) shift; break ;;
+		* ) break ;;
+	esac
+done
+
+if [[ $list ]] ; then
+	DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
+	echo "Supported build names:"
+	grep -v '^#' "$DIR/supported_builds.txt"
+	echo
+	echo
+	exit 0
+fi
+
+[[ $# -ne 1 ]] && usage
+build_name=$1
+
+grep ^$build_name$ ./scripts/ci/supported_builds.txt >&/dev/null ||
+	( echo "Error: Unsupported build ${build_name}"; exit -1 )
+echo "running compile.sh ${build_name}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+
+########################### U-BOOT CONFIGURATION ##############################
+case $build_name in
+	*_a70x0* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a7020* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a80x0_mcbin* ) defconfig="mvebu_mcbin-88f8040_defconfig"; ;;
+	*_a80x0_ucpe* )  defconfig="mvebu_ucpe-88f8040_defconfig"; ;;
+	*_a80x0* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a388_gp )    defconfig="db-88f6820-gp_defconfig"; ;;
+	*_a3900* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_cn9* )        defconfig="mvebu_db_cn91xx_defconfig"; ;;
+	*_a37xx_espressobin_* )
+	                 defconfig="mvebu_espressobin-88f3720_defconfig"; ;;
+	*_a37xx_* )      defconfig="mvebu_db-88f3720_defconfig"; ;;
+	* )	echo "Error: Could not configure defconfig." \
+		" Unsupported build ${build_name}"; exit -1; ;;
+esac
+
+case $build_name in
+	uboot_2018_a70x0 )   device_tree="armada-7040-db"; ;;
+	uboot_2018_a70x0_B ) device_tree="armada-7040-db-B"; ;;
+	uboot_2018_a70x0_C ) device_tree="armada-7040-db-C"; ;;
+	uboot_2018_a70x0_D ) device_tree="armada-7040-db-D"; ;;
+	uboot_2018_a70x0_E ) device_tree="armada-7040-db-E"; ;;
+	uboot_2018_a70x0_pcac ) device_tree="armada-7040-pcac"; ;;
+	uboot_2018_a7020_amc ) device_tree="armada-7020-amc"; ;;
+	uboot_2018_a7020_comexp ) device_tree="armada-7020-comexp"; ;;
+	uboot_2018_a70x0_kr ) device_tree="armada-7040-db"; ;;
+
+	uboot_2018_a80x0 )   device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_B ) device_tree="armada-8040-db-B"; ;;
+	uboot_2018_a80x0_C ) device_tree="armada-8040-db-C"; ;;
+	uboot_2018_a80x0_D ) device_tree="armada-8040-db-D"; ;;
+	uboot_2018_a80x0_E ) device_tree="armada-8040-db-E"; ;;
+	uboot_2018_a80x0_G ) device_tree="armada-8040-db-G"; ;;
+	uboot_2018_a80x0_H ) device_tree="armada-8040-db-H"; ;;
+	uboot_2018_a80x0_kr ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_pm ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_ddr32 ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_mcbin_single_shot* )
+	device_tree="armada-8040-mcbin-single-shot"; ;;
+	uboot_2018_a80x0_mcbin* ) device_tree="armada-8040-mcbin"; ;;
+	uboot_2018_a80x0_ucpe* ) device_tree="armada-8040-ucpe"; ;;
+
+	uboot_2018_a388_gp ) device_tree="armada-388-gp"; ;;
+	uboot_2018_a3900_A ) device_tree="armada-3900-vd-A"; ;;
+	uboot_2018_a3900_B ) device_tree="armada-3900-vd-B"; ;;
+	uboot_2018_cn9130_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_B ) device_tree="cn9130-db-B"; ;;
+	uboot_2018_cn9130_ddr32_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_emmc_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_crb_A ) device_tree="cn9130-crb-A"; ;;
+	uboot_2018_cn9130_crb_B ) device_tree="cn9130-crb-B"; ;;
+	uboot_2018_cn9131_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9131_B ) device_tree="cn9131-db-B"; ;;
+	uboot_2018_cn9131_ddr32_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9131_emmc_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9132_A ) device_tree="cn9132-db-A"; ;;
+	uboot_2018_cn9132_B ) device_tree="cn9132-db-B"; ;;
+	uboot_2018_cn9132_ddr32_A ) device_tree="cn9132-db-A"; ;;
+	uboot_2018_cn9132_emmc_A ) device_tree="cn9132-db-A"; ;;
+
+	uboot_2018*_a37xx_ddr3_v2_A_* )
+		device_tree="armada-3720-db"; ;;
+	uboot_2018_a37xx_ddr3_v2_B_* )
+		device_tree="armada-3720-ddr3-db-v2-B"; ;;
+	uboot_2018_a37xx_ddr3_v2_C_* )
+		device_tree="armada-3720-ddr3-db-v2-C"; ;;
+	uboot_2018_a37xx_ddr4_v1_A_* )
+		device_tree="armada-3720-ddr4-db-v1-A"; ;;
+	uboot_2018_a37xx_ddr4_v3_A_* )
+		device_tree="armada-3720-ddr4-db-v3-A"; ;;
+	uboot_2018_a37xx_ddr4_v3_B_* )
+		device_tree="armada-3720-ddr4-db-v3-B"; ;;
+	uboot_2018_a37xx_ddr4_v3_C_* )
+		device_tree="armada-3720-ddr4-db-v3-C"; ;;
+	uboot_2018_a37xx_espressobin_ddr3_* )
+		device_tree="armada-3720-espressobin"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc* )
+		device_tree="armada-3720-espressobin-emmc"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc* )
+		device_tree="armada-3720-espressobin-emmc"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_1G* )
+		device_tree="armada-3720-espressobin"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_2G* )
+		device_tree="armada-3720-espressobin"; ;;
+	* ) echo "Error: Could not configure device_tree." \
+		" Unsupported build ${build_name}"; exit -1;	;;
+esac
+
+if [ $device_tree ]; then
+	device_tree="DEVICE_TREE=${device_tree}"
+fi
+
+config_cmd=""
+if [[ $build_name == "uboot_2018_a70x0_D" ||
+	$build_name == "uboot_2018_a7020_amc" ||
+	$build_name == "uboot_2018_a7020_comexp" ||
+	$build_name == "uboot_2018_a80x0_D" ||
+	$build_name == "uboot_2018_cn9130_B" ||
+	$build_name == "uboot_2018_cn9131_B" ||
+	$build_name == "uboot_2018_cn9132_B" ]]; then
+	config_cmd="""
+	./scripts/config -d CONFIG_MVEBU_SPI_BOOT
+	./scripts/config -e CONFIG_MVEBU_NAND_BOOT
+	./scripts/config -d CONFIG_ENV_IS_IN_SPI_FLASH
+	./scripts/config -e CONFIG_ENV_IS_IN_NAND
+	"""
+elif [[ $build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc" ||
+	$build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc" ||
+	$build_name == "uboot_2018_cn9130_emmc_A" ||
+	$build_name == "uboot_2018_cn9131_emmc_A" ||
+	$build_name == "uboot_2018_cn9132_emmc_A" ]]; then
+	config_cmd="""
+	./scripts/config -d CONFIG_MVEBU_SPI_BOOT
+	./scripts/config -e CONFIG_MVEBU_MMC_BOOT
+	./scripts/config -d CONFIG_ENV_IS_IN_SPI_FLASH
+	./scripts/config -e CONFIG_ENV_IS_IN_MMC
+	./scripts/config --set-val MVEBU_BOOT_PART 1
+	"""
+	if [[ $build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc" ||
+	$build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc" ]]; then
+	config_cmd=$config_cmd"""
+		./scripts/config --set-val MVEBU_BOOT_DEVICE 1
+	"""
+	fi
+fi
+
+build_flags="" # not used in u-boot-2018
+logfile="$$.make.log"
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+cmd="""
+set -x
+pwd"""
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+
+##################################### CONFIG ##################################
+[[ $no_configure ]] || cmd=$cmd"""
+make mrproper
+make ${defconfig}
+${config_cmd}"""
+
+#################################### COMPILE ##################################
+cmd=$cmd"""
+make ${device_tree} ${build_flags} -j4"""
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+if [[ $echo_only ]]; then
+	echo "$cmd"
+	exit 0
+fi
+
+(eval "$cmd") 2>&1 | tee ${logfile}
+cat $logfile
+if grep -i "warning:" $logfile; then
+	echo "Error: Build has warnings. Aborted"
+	exit -1
+fi
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
diff --git a/scripts/ci/pack.sh b/scripts/ci/pack.sh
new file mode 100755
index 0000000000..2485dc1a3b
--- /dev/null
+++ b/scripts/ci/pack.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the pack script for u-boot                                        ##
+## This script is called by CI automated builds                              ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+## Prerequisites:       DESTDIR is the path to the destination directory
+## Usage:               pack BUILD_NAME
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -exuo pipefail
+shopt -s extglob
+
+build_name=$1
+echo "running pack.sh ${build_name}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+mkdir -p $DESTDIR/dev_images
+cp u-boot.bin $DESTDIR/dev_images/
diff --git a/scripts/ci/pack_source.sh b/scripts/ci/pack_source.sh
new file mode 100755
index 0000000000..6909ad8080
--- /dev/null
+++ b/scripts/ci/pack_source.sh
@@ -0,0 +1,42 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the source packing script for u-boot                              ##
+## This script is called by CI automated builds                              ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+## Prerequisites:       DESTDIR is the path to the destination directory
+## Usage:               pack_source RELEASE_VER END_TAG
+## Output:              packname
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -exuo pipefail
+shopt -s extglob
+
+release_ver=$1
+end_tag=$2
+echo "running pack_source.sh ${release_ver} ${end_tag}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+packname="u-boot-2018.03-${release_ver}"
+base_tag=`cat scripts/ci/baseline.txt | \
+	perl -nae 'next if /^#/; print \$F[0]; exit'`
+ref_to_ref="${base_tag}..${end_tag}"
+srcpkg="sources-${packname}"
+gitpkg="git-${packname}"
+
+mkdir -p ${DESTDIR}/$srcpkg
+cp -R ./* ${DESTDIR}/$srcpkg/ || true
+
+mkdir ${DESTDIR}/$gitpkg
+git format-patch -o ${DESTDIR}/$gitpkg $ref_to_ref
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+echo "packname:$packname"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
diff --git a/scripts/ci/supported_builds.txt b/scripts/ci/supported_builds.txt
new file mode 100644
index 0000000000..630a34c453
--- /dev/null
+++ b/scripts/ci/supported_builds.txt
@@ -0,0 +1,78 @@
+#
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+#
+# Copyright (C) 2018 Marvell International Ltd.
+#
+uboot_2018_a70x0
+uboot_2018_a70x0_B
+uboot_2018_a70x0_C
+uboot_2018_a70x0_D
+uboot_2018_a70x0_E
+uboot_2018_a70x0_pcac
+uboot_2018_a7020_amc
+uboot_2018_a7020_comexp
+uboot_2018_a70x0_kr
+
+uboot_2018_a80x0
+uboot_2018_a80x0_B
+uboot_2018_a80x0_C
+uboot_2018_a80x0_D
+uboot_2018_a80x0_E
+uboot_2018_a80x0_G
+uboot_2018_a80x0_H
+uboot_2018_a80x0_kr
+uboot_2018_a80x0_pm
+uboot_2018_a80x0_mcbin
+uboot_2018_a80x0_mcbin_cve_2018_3639
+uboot_2018_a80x0_mcbin_pm
+uboot_2018_a80x0_mcbin_single_shot
+uboot_2018_a80x0_mcbin_single_shot_cve_2018_3639
+uboot_2018_a80x0_mcbin_single_shot_pm
+uboot_2018_a80x0_ucpe
+uboot_2018_a80x0_ddr32
+
+uboot_2018_a388_gp
+uboot_2018_a3900_A
+uboot_2018_a3900_B
+uboot_2018_cn9130_A
+uboot_2018_cn9130_B
+uboot_2018_cn9130_ddr32_A
+uboot_2018_cn9130_emmc_A
+uboot_2018_cn9130_crb_A
+uboot_2018_cn9130_crb_B
+uboot_2018_cn9131_A
+uboot_2018_cn9131_B
+uboot_2018_cn9131_ddr32_A
+uboot_2018_cn9131_emmc_A
+uboot_2018_cn9132_A
+uboot_2018_cn9132_B
+uboot_2018_cn9132_ddr32_A
+uboot_2018_cn9132_emmc_A
+
+uboot_2018_a37xx_ddr3_v2_A_1000_800
+uboot_2018_a37xx_ddr3_v2_B_1000_800
+uboot_2018_a37xx_ddr3_v2_C_1000_800
+uboot_2018_a37xx_ddr3_v2_A_1200_750
+uboot_2018_a37xx_ddr3_v2_B_1200_750
+uboot_2018_a37xx_ddr3_v2_C_1200_750
+uboot_2018_a37xx_ddr3_v2_A_600_600
+uboot_2018_a37xx_ddr3_v2_B_600_600
+uboot_2018_a37xx_ddr3_v2_A_800_800
+uboot_2018_a37xx_ddr3_v2_B_800_800
+uboot_2018_a37xx_ddr3_v2_C_800_800
+uboot_2018_a37xx_ddr4_v1_A_1000_800
+uboot_2018_a37xx_ddr4_v3_A_1000_800
+uboot_2018_a37xx_ddr4_v3_B_1000_800
+uboot_2018_a37xx_ddr4_v3_C_1000_800
+uboot_2018_a37xx_ddr4_v1_A_800_800
+uboot_2018_a37xx_ddr4_v3_A_800_800
+uboot_2018_a37xx_ddr4_v3_B_800_800
+uboot_2018_a37xx_ddr4_v3_C_800_800
+uboot_2018_a37xx_espressobin_ddr3_1cs_1000_800
+uboot_2018_a37xx_espressobin_ddr3_2cs_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_1G_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_2G_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc_1000_800
+uboot_2018_freertos_a37xx_ddr3_v2_A_1000_800
diff --git a/scripts/config b/scripts/config
new file mode 100755
index 0000000000..026aeb4f32
--- /dev/null
+++ b/scripts/config
@@ -0,0 +1,225 @@
+#!/bin/bash
+# Manipulate options in a .config file from the command line
+
+myname=${0##*/}
+
+# If no prefix forced, use the default CONFIG_
+CONFIG_="${CONFIG_-CONFIG_}"
+
+usage() {
+	cat >&2 <<EOL
+Manipulate options in a .config file from the command line.
+Usage:
+$myname options command ...
+commands:
+	--enable|-e option   Enable option
+	--disable|-d option  Disable option
+	--module|-m option   Turn option into a module
+	--set-str option string
+	                     Set option to "string"
+	--set-val option value
+	                     Set option to value
+	--undefine|-u option Undefine option
+	--state|-s option    Print state of option (n,y,m,undef)
+
+	--enable-after|-E beforeopt option
+                             Enable option directly after other option
+	--disable-after|-D beforeopt option
+                             Disable option directly after other option
+	--module-after|-M beforeopt option
+                             Turn option into module directly after other option
+
+	commands can be repeated multiple times
+
+options:
+	--file config-file   .config file to change (default .config)
+	--keep-case|-k       Keep next symbols' case (dont' upper-case it)
+
+$myname doesn't check the validity of the .config file. This is done at next
+make time.
+
+By default, $myname will upper-case the given symbol. Use --keep-case to keep
+the case of all following symbols unchanged.
+
+$myname uses 'CONFIG_' as the default symbol prefix. Set the environment
+variable CONFIG_ to the prefix to use. Eg.: CONFIG_="FOO_" $myname ...
+EOL
+	exit 1
+}
+
+checkarg() {
+	ARG="$1"
+	if [ "$ARG" = "" ] ; then
+		usage
+	fi
+	case "$ARG" in
+	${CONFIG_}*)
+		ARG="${ARG/${CONFIG_}/}"
+		;;
+	esac
+	if [ "$MUNGE_CASE" = "yes" ] ; then
+		ARG="`echo $ARG | tr a-z A-Z`"
+	fi
+}
+
+txt_append() {
+	local anchor="$1"
+	local insert="$2"
+	local infile="$3"
+	local tmpfile="$infile.swp"
+
+	# sed append cmd: 'a\' + newline + text + newline
+	cmd="$(printf "a\\%b$insert" "\n")"
+
+	sed -e "/$anchor/$cmd" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+txt_subst() {
+	local before="$1"
+	local after="$2"
+	local infile="$3"
+	local tmpfile="$infile.swp"
+
+	sed -e "s:$before:$after:" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+txt_delete() {
+	local text="$1"
+	local infile="$2"
+	local tmpfile="$infile.swp"
+
+	sed -e "/$text/d" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+set_var() {
+	local name=$1 new=$2 before=$3
+
+	name_re="^($name=|# $name is not set)"
+	before_re="^($before=|# $before is not set)"
+	if test -n "$before" && grep -Eq "$before_re" "$FN"; then
+		txt_append "^$before=" "$new" "$FN"
+		txt_append "^# $before is not set" "$new" "$FN"
+	elif grep -Eq "$name_re" "$FN"; then
+		txt_subst "^$name=.*" "$new" "$FN"
+		txt_subst "^# $name is not set" "$new" "$FN"
+	else
+		echo "$new" >>"$FN"
+	fi
+}
+
+undef_var() {
+	local name=$1
+
+	txt_delete "^$name=" "$FN"
+	txt_delete "^# $name is not set" "$FN"
+}
+
+if [ "$1" = "--file" ]; then
+	FN="$2"
+	if [ "$FN" = "" ] ; then
+		usage
+	fi
+	shift 2
+else
+	FN=.config
+fi
+
+if [ "$1" = "" ] ; then
+	usage
+fi
+
+MUNGE_CASE=yes
+while [ "$1" != "" ] ; do
+	CMD="$1"
+	shift
+	case "$CMD" in
+	--keep-case|-k)
+		MUNGE_CASE=no
+		continue
+		;;
+	--refresh)
+		;;
+	--*-after|-E|-D|-M)
+		checkarg "$1"
+		A=$ARG
+		checkarg "$2"
+		B=$ARG
+		shift 2
+		;;
+	-*)
+		checkarg "$1"
+		shift
+		;;
+	esac
+	case "$CMD" in
+	--enable|-e)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=y"
+		;;
+
+	--disable|-d)
+		set_var "${CONFIG_}$ARG" "# ${CONFIG_}$ARG is not set"
+		;;
+
+	--module|-m)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=m"
+		;;
+
+	--set-str)
+		# sed swallows one level of escaping, so we need double-escaping
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=\"${1//\"/\\\\\"}\""
+		shift
+		;;
+
+	--set-val)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=$1"
+		shift
+		;;
+	--undefine|-u)
+		undef_var "${CONFIG_}$ARG"
+		;;
+
+	--state|-s)
+		if grep -q "# ${CONFIG_}$ARG is not set" $FN ; then
+			echo n
+		else
+			V="$(grep "^${CONFIG_}$ARG=" $FN)"
+			if [ $? != 0 ] ; then
+				echo undef
+			else
+				V="${V/#${CONFIG_}$ARG=/}"
+				V="${V/#\"/}"
+				V="${V/%\"/}"
+				V="${V//\\\"/\"}"
+				echo "${V}"
+			fi
+		fi
+		;;
+
+	--enable-after|-E)
+		set_var "${CONFIG_}$B" "${CONFIG_}$B=y" "${CONFIG_}$A"
+		;;
+
+	--disable-after|-D)
+		set_var "${CONFIG_}$B" "# ${CONFIG_}$B is not set" "${CONFIG_}$A"
+		;;
+
+	--module-after|-M)
+		set_var "${CONFIG_}$B" "${CONFIG_}$B=m" "${CONFIG_}$A"
+		;;
+
+	# undocumented because it ignores --file (fixme)
+	--refresh)
+		yes "" | make oldconfig
+		;;
+
+	*)
+		usage
+		;;
+	esac
+done
diff --git a/scripts/const_structs.checkpatch b/scripts/const_structs.checkpatch
index da775bca0c..ac5f126715 100644
--- a/scripts/const_structs.checkpatch
+++ b/scripts/const_structs.checkpatch
@@ -1,2 +1,64 @@
-# Put structs here that should be constant
-__dummy__
+acpi_dock_ops
+address_space_operations
+backlight_ops
+block_device_operations
+clk_ops
+comedi_lrange
+component_ops
+dentry_operations
+dev_pm_ops
+dma_map_ops
+driver_info
+drm_connector_funcs
+drm_encoder_funcs
+drm_encoder_helper_funcs
+ethtool_ops
+extent_io_ops
+file_lock_operations
+file_operations
+hv_ops
+ide_dma_ops
+ide_port_ops
+inode_operations
+intel_dvo_dev_ops
+irq_domain_ops
+item_operations
+iwl_cfg
+iwl_ops
+kgdb_arch
+kgdb_io
+kset_uevent_ops
+lock_manager_operations
+machine_desc
+microcode_ops
+mlxsw_reg_info
+mtrr_ops
+neigh_ops
+net_device_ops
+nlmsvc_binding
+nvkm_device_chip
+of_device_id
+pci_raw_ops
+pipe_buf_operations
+platform_hibernation_ops
+platform_suspend_ops
+proto_ops
+regmap_access_table
+rpc_pipe_ops
+rtc_class_ops
+sd_desc
+seq_operations
+sirfsoc_padmux
+snd_ac97_build_ops
+snd_soc_component_driver
+soc_pcmcia_socket_ops
+stacktrace_ops
+sysfs_ops
+tty_operations
+uart_ops
+usb_mon_operations
+v4l2_ctrl_ops
+v4l2_ioctl_ops
+vm_operations_struct
+wacom_features
+wd_ops
diff --git a/scripts/spelling.txt b/scripts/spelling.txt
index 9a058cff49..86b87332b9 100644
--- a/scripts/spelling.txt
+++ b/scripts/spelling.txt
@@ -10,6 +10,10 @@
 abandonning||abandoning
 abigious||ambiguous
 abitrate||arbitrate
+abnornally||abnormally
+abnrormal||abnormal
+abord||abort
+aboslute||absolute
 abov||above
 abreviated||abbreviated
 absense||absence
@@ -25,6 +29,7 @@ accessable||accessible
 accesss||access
 accidentaly||accidentally
 accidentually||accidentally
+acclerated||accelerated
 accoding||according
 accomodate||accommodate
 accomodates||accommodates
@@ -58,12 +63,15 @@ addres||address
 adddress||address
 addreses||addresses
 addresss||address
+addrress||address
 aditional||additional
 aditionally||additionally
 aditionaly||additionally
 adminstrative||administrative
 adress||address
 adresses||addresses
+adrresses||addresses
+advertisment||advertisement
 adviced||advised
 afecting||affecting
 againt||against
@@ -100,6 +108,8 @@ alue||value
 ambigious||ambiguous
 amoung||among
 amout||amount
+amplifer||amplifier
+amplifyer||amplifier
 an union||a union
 an user||a user
 an userspace||a userspace
@@ -138,6 +148,7 @@ artillary||artillery
 asign||assign
 asser||assert
 assertation||assertion
+assertting||asserting
 assiged||assigned
 assigment||assignment
 assigments||assignments
@@ -145,11 +156,15 @@ assistent||assistant
 assocation||association
 associcated||associated
 assotiated||associated
+asssert||assert
 assum||assume
 assumtpion||assumption
 asuming||assuming
 asycronous||asynchronous
 asynchnous||asynchronous
+asynchromous||asynchronous
+asymetric||asymmetric
+asymmeric||asymmetric
 atomatically||automatically
 atomicly||atomically
 atempt||attempt
@@ -157,6 +172,8 @@ attachement||attachment
 attched||attached
 attemps||attempts
 attemping||attempting
+attepmpt||attempt
+attnetion||attention
 attruibutes||attributes
 authentification||authentication
 automaticaly||automatically
@@ -172,6 +189,7 @@ avaible||available
 availabe||available
 availabled||available
 availablity||availability
+availaible||available
 availale||available
 availavility||availability
 availble||available
@@ -205,9 +223,13 @@ boardcast||broadcast
 borad||board
 boundry||boundary
 brievely||briefly
+broadcase||broadcast
 broadcat||broadcast
+bufufer||buffer
 cacluated||calculated
+caculate||calculate
 caculation||calculation
+cadidate||candidate
 calender||calendar
 calescing||coalescing
 calle||called
@@ -219,14 +241,17 @@ cancle||cancel
 capabilites||capabilities
 capabilty||capability
 capabitilies||capabilities
+capablity||capability
 capatibilities||capabilities
 capapbilities||capabilities
+caputure||capture
 carefuly||carefully
 cariage||carriage
 catagory||category
 cehck||check
 challange||challenge
 challanges||challenges
+chache||cache
 chanell||channel
 changable||changeable
 chanined||chained
@@ -240,6 +265,7 @@ charaters||characters
 charcter||character
 chcek||check
 chck||check
+checksumed||checksummed
 checksuming||checksumming
 childern||children
 childs||children
@@ -256,6 +282,7 @@ clared||cleared
 closeing||closing
 clustred||clustered
 coexistance||coexistence
+colescing||coalescing
 collapsable||collapsible
 colorfull||colorful
 comand||command
@@ -272,6 +299,7 @@ comsumer||consumer
 comsuming||consuming
 compability||compatibility
 compaibility||compatibility
+comparsion||comparison
 compatability||compatibility
 compatable||compatible
 compatibiliy||compatibility
@@ -285,6 +313,7 @@ completly||completely
 complient||compliant
 componnents||components
 compoment||component
+comppatible||compatible
 compres||compress
 compresion||compression
 comression||compression
@@ -292,8 +321,10 @@ comunication||communication
 conbination||combination
 conditionaly||conditionally
 conected||connected
+conector||connector
 connecetd||connected
 configuartion||configuration
+configuation||configuration
 configuratoin||configuration
 configuraton||configuration
 configuretion||configuration
@@ -315,6 +346,7 @@ continous||continuous
 continously||continuously
 continueing||continuing
 contraints||constraints
+contruct||construct
 contol||control
 contoller||controller
 controled||controlled
@@ -343,9 +375,12 @@ dafault||default
 deafult||default
 deamon||daemon
 decompres||decompress
+decsribed||described
 decription||description
 dectected||detected
 defailt||default
+deferal||deferral
+deffered||deferred
 defferred||deferred
 definate||definite
 definately||definitely
@@ -378,7 +413,9 @@ descritptor||descriptor
 desctiptor||descriptor
 desriptor||descriptor
 desriptors||descriptors
+desination||destination
 destionation||destination
+destoried||destroyed
 destory||destroy
 destoryed||destroyed
 destorys||destroys
@@ -400,22 +437,33 @@ didnt||didn't
 diferent||different
 differrence||difference
 diffrent||different
+differenciate||differentiate
 diffrentiate||differentiate
 difinition||definition
+dimention||dimension
 dimesions||dimensions
+dispalying||displaying
 diplay||display
+directon||direction
 direectly||directly
+diregard||disregard
 disassocation||disassociation
 disapear||disappear
 disapeared||disappeared
 disappared||disappeared
+disbale||disable
+disbaled||disabled
 disble||disable
 disbled||disabled
 disconnet||disconnect
 discontinous||discontinuous
+disharge||discharge
+disnabled||disabled
 dispertion||dispersion
 dissapears||disappears
 distiction||distinction
+divisable||divisible
+divsiors||divisors
 docuentation||documentation
 documantation||documentation
 documentaion||documentation
@@ -425,8 +473,10 @@ dorp||drop
 dosen||doesn
 downlad||download
 downlads||downloads
+droped||dropped
 druing||during
 dynmaic||dynamic
+eanable||enable
 easilly||easily
 ecspecially||especially
 edditable||editable
@@ -439,6 +489,7 @@ elementry||elementary
 eletronic||electronic
 embeded||embedded
 enabledi||enabled
+enble||enable
 enchanced||enhanced
 encorporating||incorporating
 encrupted||encrypted
@@ -447,6 +498,9 @@ encryptio||encryption
 endianess||endianness
 enhaced||enhanced
 enlightnment||enlightenment
+enqueing||enqueuing
+entires||entries
+entites||entities
 entrys||entries
 enocded||encoded
 enterily||entirely
@@ -466,6 +520,8 @@ etsbalishment||establishment
 excecutable||executable
 exceded||exceeded
 excellant||excellent
+execeeded||exceeded
+execeeds||exceeds
 exeed||exceed
 existance||existence
 existant||existent
@@ -474,6 +530,7 @@ exlcude||exclude
 exlcusive||exclusive
 exmaple||example
 expecially||especially
+experies||expires
 explicite||explicit
 explicitely||explicitly
 explict||explicit
@@ -484,9 +541,13 @@ exprimental||experimental
 extened||extended
 extensability||extensibility
 extention||extension
+extenstion||extension
 extracter||extractor
+faield||failed
 falied||failed
 faild||failed
+failded||failed
+failer||failure
 faill||fail
 failied||failed
 faillure||failure
@@ -505,6 +566,7 @@ fetaure||feature
 fetaures||features
 fileystem||filesystem
 fimware||firmware
+firmare||firmware
 firware||firmware
 finanize||finalize
 findn||find
@@ -520,6 +582,7 @@ forseeable||foreseeable
 forse||force
 fortan||fortran
 forwardig||forwarding
+frambuffer||framebuffer
 framming||framing
 framwork||framework
 frequncy||frequency
@@ -527,6 +590,7 @@ frome||from
 fucntion||function
 fuction||function
 fuctions||functions
+funcation||function
 funcion||function
 functionallity||functionality
 functionaly||functionally
@@ -537,9 +601,11 @@ funtions||functions
 furthur||further
 futhermore||furthermore
 futrue||future
+gauage||gauge
 gaurenteed||guaranteed
 generiously||generously
 genereate||generate
+genereted||generated
 genric||generic
 globel||global
 grabing||grabbing
@@ -553,6 +619,7 @@ guarentee||guarantee
 halfs||halves
 hander||handler
 handfull||handful
+hanlde||handle
 hanled||handled
 happend||happened
 harware||hardware
@@ -561,6 +628,7 @@ helpfull||helpful
 hybernate||hibernate
 hierachy||hierarchy
 hierarchie||hierarchy
+homogenous||homogeneous
 howver||however
 hsould||should
 hypervior||hypervisor
@@ -568,6 +636,8 @@ hypter||hyper
 identidier||identifier
 iligal||illegal
 illigal||illegal
+illgal||illegal
+iomaped||iomapped
 imblance||imbalance
 immeadiately||immediately
 immedaite||immediate
@@ -603,6 +673,7 @@ independed||independent
 indiate||indicate
 indicat||indicate
 inexpect||inexpected
+inferface||interface
 infomation||information
 informatiom||information
 informations||information
@@ -618,13 +689,19 @@ initation||initiation
 initators||initiators
 initialiazation||initialization
 initializiation||initialization
+initialze||initialize
 initialzed||initialized
+initialzing||initializing
 initilization||initialization
 initilize||initialize
 inofficial||unofficial
+inrerface||interface
 insititute||institute
+instace||instance
 instal||install
+instanciate||instantiate
 instanciated||instantiated
+insufficent||insufficient
 inteface||interface
 integreated||integrated
 integrety||integrity
@@ -639,6 +716,8 @@ intermittant||intermittent
 internel||internal
 interoprability||interoperability
 interuupt||interrupt
+interupt||interrupt
+interupts||interrupts
 interrface||interface
 interrrupt||interrupt
 interrup||interrupt
@@ -654,10 +733,14 @@ intialization||initialization
 intialized||initialized
 intialize||initialize
 intregral||integral
+intrerrupt||interrupt
 intrrupt||interrupt
 intterrupt||interrupt
 intuative||intuitive
+inavlid||invalid
 invaid||invalid
+invaild||invalid
+invailid||invalid
 invald||invalid
 invalde||invalid
 invalide||invalid
@@ -666,6 +749,7 @@ invalud||invalid
 invididual||individual
 invokation||invocation
 invokations||invocations
+ireelevant||irrelevant
 irrelevent||irrelevant
 isnt||isn't
 isssue||issue
@@ -683,6 +767,7 @@ langauge||language
 langugage||language
 lauch||launch
 layed||laid
+legnth||length
 leightweight||lightweight
 lengh||length
 lenght||length
@@ -696,26 +781,35 @@ licenceing||licencing
 loggging||logging
 loggin||login
 logile||logfile
+loobpack||loopback
 loosing||losing
 losted||lost
 machinary||machinery
+maibox||mailbox
 maintainance||maintenance
 maintainence||maintenance
 maintan||maintain
 makeing||making
+mailformed||malformed
 malplaced||misplaced
 malplace||misplace
 managable||manageable
 managment||management
 mangement||management
 manoeuvering||maneuvering
+manufaucturing||manufacturing
 mappping||mapping
+matchs||matches
 mathimatical||mathematical
 mathimatic||mathematic
 mathimatics||mathematics
+maximium||maximum
 maxium||maximum
 mechamism||mechanism
 meetign||meeting
+memeory||memory
+memmber||member
+memoery||memory
 ment||meant
 mergable||mergeable
 mesage||message
@@ -725,9 +819,11 @@ messsage||message
 messsages||messages
 micropone||microphone
 microprocesspr||microprocessor
+migrateable||migratable
 milliseonds||milliseconds
 minium||minimum
 minimam||minimum
+miniumum||minimum
 minumum||minimum
 misalinged||misaligned
 miscelleneous||miscellaneous
@@ -741,6 +837,7 @@ missmatch||mismatch
 miximum||maximum
 mmnemonic||mnemonic
 mnay||many
+modfiy||modify
 modulues||modules
 momery||memory
 memomry||memory
@@ -777,6 +874,7 @@ notifed||notified
 numebr||number
 numner||number
 obtaion||obtain
+obusing||abusing
 occassionally||occasionally
 occationally||occasionally
 occurance||occurrence
@@ -786,7 +884,9 @@ occurence||occurrence
 occure||occurred
 occured||occurred
 occuring||occurring
+offser||offset
 offet||offset
+offloded||offloaded
 omited||omitted
 omiting||omitting
 omitt||omit
@@ -801,6 +901,7 @@ optmizations||optimizations
 orientatied||orientated
 orientied||oriented
 orignal||original
+originial||original
 otherise||otherwise
 ouput||output
 oustanding||outstanding
@@ -820,6 +921,7 @@ packege||package
 packge||package
 packtes||packets
 pakage||package
+paket||packet
 pallette||palette
 paln||plan
 paramameters||parameters
@@ -829,23 +931,30 @@ parametes||parameters
 parametised||parametrised
 paramter||parameter
 paramters||parameters
+parmaters||parameters
 particuarly||particularly
 particularily||particularly
+partion||partition
+partions||partitions
 partiton||partition
 pased||passed
 passin||passing
 pathes||paths
 pecularities||peculiarities
 peformance||performance
+peforming||performing
 peice||piece
 pendantic||pedantic
 peprocessor||preprocessor
 perfoming||performing
+peripherial||peripheral
 permissons||permissions
 peroid||period
 persistance||persistence
 persistant||persistent
+phoneticly||phonetically
 plalform||platform
+platfoem||platform
 platfrom||platform
 plattform||platform
 pleaes||please
@@ -858,6 +967,8 @@ posible||possible
 positon||position
 possibilites||possibilities
 powerfull||powerful
+pramater||parameter
+preamle||preamble
 preample||preamble
 preapre||prepare
 preceeded||preceded
@@ -870,6 +981,7 @@ prefered||preferred
 prefferably||preferably
 premption||preemption
 prepaired||prepared
+preperation||preparation
 pressre||pressure
 primative||primitive
 princliple||principle
@@ -917,6 +1029,7 @@ psudo||pseudo
 psuedo||pseudo
 psychadelic||psychedelic
 pwoer||power
+queing||queuing
 quering||querying
 randomally||randomly
 raoming||roaming
@@ -935,6 +1048,7 @@ recommanded||recommended
 recyle||recycle
 redircet||redirect
 redirectrion||redirection
+redundacy||redundancy
 reename||rename
 refcounf||refcount
 refence||reference
@@ -944,7 +1058,9 @@ refering||referring
 refernces||references
 refernnce||reference
 refrence||reference
+registed||registered
 registerd||registered
+registeration||registration
 registeresd||registered
 registerred||registered
 registes||registers
@@ -957,6 +1073,7 @@ regulamentations||regulations
 reigstration||registration
 releated||related
 relevent||relevant
+reloade||reload
 remoote||remote
 remore||remote
 removeable||removable
@@ -973,18 +1090,25 @@ requirment||requirement
 requred||required
 requried||required
 requst||request
+reregisteration||reregistration
 reseting||resetting
+reseved||reserved
+reseverd||reserved
 resizeable||resizable
 resouce||resource
 resouces||resources
 resoures||resources
 responce||response
+resrouce||resource
 ressizes||resizes
 ressource||resource
 ressources||resources
+restesting||retesting
+resumbmitting||resubmitting
 retransmited||retransmitted
 retreived||retrieved
 retreive||retrieve
+retreiving||retrieving
 retrive||retrieve
 retuned||returned
 reudce||reduce
@@ -1006,6 +1130,7 @@ sacrifying||sacrificing
 safly||safely
 safty||safety
 savable||saveable
+scaleing||scaling
 scaned||scanned
 scaning||scanning
 scarch||search
@@ -1014,6 +1139,8 @@ searchs||searches
 secquence||sequence
 secund||second
 segement||segment
+semaphone||semaphore
+senario||scenario
 senarios||scenarios
 sentivite||sensitive
 separatly||separately
@@ -1025,9 +1152,13 @@ seperate||separate
 seperatly||separately
 seperator||separator
 sepperate||separate
+seqeunce||sequence
+seqeuncer||sequencer
+seqeuencer||sequencer
 sequece||sequence
 sequencial||sequential
 serveral||several
+servive||service
 setts||sets
 settting||setting
 shotdown||shutdown
@@ -1049,6 +1180,7 @@ sleeped||slept
 softwares||software
 speach||speech
 specfic||specific
+specfield||specified
 speciefied||specified
 specifc||specific
 specifed||specified
@@ -1071,8 +1203,12 @@ staion||station
 standardss||standards
 standartization||standardization
 standart||standard
+standy||standby
+stardard||standard
 staticly||statically
+statuss||status
 stoped||stopped
+stoping||stopping
 stoppped||stopped
 straming||streaming
 struc||struct
@@ -1085,6 +1221,7 @@ subdirectoires||subdirectories
 suble||subtle
 substract||subtract
 submition||submission
+suceed||succeed
 succesfully||successfully
 succesful||successful
 successed||succeeded
@@ -1108,6 +1245,7 @@ surpressed||suppressed
 surpresses||suppresses
 susbsystem||subsystem
 suspeneded||suspended
+suspsend||suspend
 suspicously||suspiciously
 swaping||swapping
 switchs||switches
@@ -1122,6 +1260,7 @@ swtich||switch
 symetric||symmetric
 synax||syntax
 synchonized||synchronized
+synchronuously||synchronously
 syncronize||synchronize
 syncronized||synchronized
 syncronizing||synchronizing
@@ -1130,11 +1269,14 @@ syste||system
 sytem||system
 sythesis||synthesis
 taht||that
+tansmit||transmit
 targetted||targeted
 targetting||targeting
+taskelt||tasklet
 teh||the
 temorary||temporary
 temproarily||temporarily
+thead||thread
 therfore||therefore
 thier||their
 threds||threads
@@ -1143,15 +1285,20 @@ thresold||threshold
 throught||through
 troughput||throughput
 thses||these
+tiggers||triggers
 tiggered||triggered
 tipically||typically
+timeing||timing
 timout||timeout
 tmis||this
+toogle||toggle
 torerable||tolerable
+traking||tracking
 tramsmitted||transmitted
 tramsmit||transmit
 tranasction||transaction
 tranfer||transfer
+transcevier||transceiver
 transciever||transceiver
 transferd||transferred
 transfered||transferred
@@ -1162,6 +1309,7 @@ transormed||transformed
 trasfer||transfer
 trasmission||transmission
 treshold||threshold
+trigerred||triggered
 trigerring||triggering
 trun||turn
 tunning||tuning
@@ -1169,6 +1317,8 @@ ture||true
 tyep||type
 udpate||update
 uesd||used
+uknown||unknown
+usupported||unsupported
 uncommited||uncommitted
 unconditionaly||unconditionally
 underun||underrun
@@ -1181,11 +1331,15 @@ unexpeted||unexpected
 unexpexted||unexpected
 unfortunatelly||unfortunately
 unifiy||unify
+uniterrupted||uninterrupted
 unintialized||uninitialized
+unitialized||uninitialized
 unkmown||unknown
 unknonw||unknown
 unknow||unknown
 unkown||unknown
+unamed||unnamed
+uneeded||unneeded
 unneded||unneeded
 unneccecary||unnecessary
 unneccesary||unnecessary
@@ -1204,12 +1358,15 @@ unsuccessfull||unsuccessful
 unsuported||unsupported
 untill||until
 unuseful||useless
+unvalid||invalid
 upate||update
+upsupported||unsupported
 usefule||useful
 usefull||useful
 usege||usage
 usera||users
 usualy||usually
+usupported||unsupported
 utilites||utilities
 utillities||utilities
 utilties||utilities
@@ -1233,7 +1390,9 @@ virtaul||virtual
 virtiual||virtual
 visiters||visitors
 vitual||virtual
+vunerable||vulnerable
 wakeus||wakeups
+wathdog||watchdog
 wating||waiting
 wiat||wait
 wether||whether
diff --git a/tools/mrvl_uart.sh b/tools/mrvl_uart.sh
index a46411fc99..044942c86e 100755
--- a/tools/mrvl_uart.sh
+++ b/tools/mrvl_uart.sh
@@ -8,7 +8,7 @@
 #
 # Author: Konstantin Porotchkin kostap@marvell.com
 #
-# Version 0.3
+# Version 0.4
 #
 # UART recovery downloader for Armada SoCs
 #
@@ -16,44 +16,21 @@
 
 port=$1
 file=$2
-speed=$3
 
 pattern_repeat=1500
 default_baudrate=115200
 tmpfile=/tmp/xmodem.pattern
 tools=( dd stty sx minicom )
 
-case "$3" in
-    2)
-        fast_baudrate=230400
-        prefix="\xF2"
-        ;;
-    4)
-        fast_baudrate=460800
-        prefix="\xF4"
-        ;;
-    8)
-    	fast_baudrate=921600
-        prefix="\xF8"
-        ;;
-    *)
-    	fast_baudrate=$default_baudrate
-        prefix="\xBB"
-esac
-
 if [[ -z "$port" || -z "$file" ]]
 then
     echo -e "\nMarvell recovery image downloader for Armada SoC family."
     echo -e "Command syntax:"
-    echo -e "\t$(basename $0) <port> <file> [2|4|8]"
+    echo -e "\t$(basename $0) <port> <file>"
     echo -e "\tport  - serial port the target board is connected to"
     echo -e "\tfile  - recovery boot image for target download"
-    echo -e "\t2|4|8 - times to increase the default serial port speed by"
-    echo -e "For example - load the image over ttyUSB0 @ 460800 baud:"
-    echo -e "$(basename $0) /dev/ttyUSB0 /tmp/flash-image.bin 4\n"
-    echo -e "=====WARNING====="
-    echo -e "- The speed-up option is not available in SoC families prior to A8K+"
-    echo -e "- This utility is not compatible with Armada 37xx SoC family\n"
+    echo -e "For example - load the image over ttyUSB0:"
+    echo -e "$(basename $0) /dev/ttyUSB0 /tmp/flash-image.bin\n"
 fi
 
 # Sanity checks
@@ -84,10 +61,6 @@ do
     fi
 done
 
-
-echo -e "Recovery will run at $fast_baudrate baud"
-echo -e "========================================"
-
 if [ -f "$tmpfile" ]
 then
     rm -f $tmpfile
@@ -97,7 +70,7 @@ fi
 stty -F $port raw ignbrk time 5 $default_baudrate
 counter=0
 while [ $counter -lt $pattern_repeat ]; do
-    echo -n -e "$prefix\x11\x22\x33\x44\x55\x66\x77" >> $tmpfile
+    echo -n -e "\xBB\x11\x22\x33\x44\x55\x66\x77" >> $tmpfile
     let counter=counter+1
 done
 
@@ -107,13 +80,10 @@ read
 dd if=$tmpfile of=$port &>/dev/null
 
 # Speed up the binary image transfer
-stty -F $port raw ignbrk time 5 $fast_baudrate
+stty -F $port raw ignbrk time 5 $default_baudrate
 sx -vv $file > $port < $port
 #sx-at91 $port $file
 
-# Return the port to the default speed
-stty -F $port raw ignbrk time 5 $default_baudrate
-
 # Optional - fire up Minicom
 minicom -D $port -b $default_baudrate
 
-- 
2.34.1

