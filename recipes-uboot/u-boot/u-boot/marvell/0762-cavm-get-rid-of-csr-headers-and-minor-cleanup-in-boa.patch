From b40ec166c3a4cef7a40ff771dae9ae7437572c60 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <sgarapati@caviumnetworks.com>
Date: Thu, 1 Mar 2018 11:31:30 -0800
Subject: [PATCH 0762/1239] cavm: get rid of csr headers and minor cleanup in
 board files

Signed-off-by: Suneel Garapati <sgarapati@caviumnetworks.com>
---
 arch/arm/cpu/armv8/cache_v8.c                 |   2 +-
 arch/arm/include/asm/arch-thunderx/clock.h    | 206 ++++++++++++++
 arch/arm/include/asm/arch-thunderx/thunderx.h |  39 ++-
 .../include/asm/arch-thunderx/thunderx_svc.h  |  48 +---
 .../include/asm/arch-thunderx/thunderx_xcv.h  | 254 ++++++++++++++++++
 arch/arm/mach-thunderx/clock.c                | 206 --------------
 board/cavium/thunderx/Makefile                |   4 +-
 board/cavium/thunderx/fdt.c                   | 143 +++-------
 board/cavium/thunderx/thunderx.c              | 115 +-------
 configs/t83_defconfig                         |   1 -
 csr                                           |   1 -
 drivers/ata/ahci.c                            |   9 +-
 drivers/net/cavium/Makefile                   |   1 -
 drivers/net/cavium/thunder_bgx.c              |  33 ++-
 drivers/net/cavium/thunder_xcv.c              |  51 ++--
 drivers/pci/pci_auto.c                        |   1 +
 include/configs/thunderx_93xx.h               |   2 -
 17 files changed, 595 insertions(+), 521 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-thunderx/thunderx_xcv.h
 delete mode 120000 csr

diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index 7e3b3974b6..d4fc59eded 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -449,7 +449,7 @@ void invalidate_dcache_all(void)
  */
 inline void flush_dcache_all(void)
 {
-	int ret;
+	int __maybe_unused ret;
 
 	__asm_flush_dcache_all();
 	ret = __asm_flush_l3_dcache();
diff --git a/arch/arm/include/asm/arch-thunderx/clock.h b/arch/arm/include/asm/arch-thunderx/clock.h
index b4a890ac3a..f93a564bec 100644
--- a/arch/arm/include/asm/arch-thunderx/clock.h
+++ b/arch/arm/include/asm/arch-thunderx/clock.h
@@ -10,6 +10,212 @@
 #define PLL_REF_CLK                     50000000        /* 50 MHz */
 #define NS_PER_REF_CLK_TICK             (1000000000/PLL_REF_CLK)
 
+/** Address of RST_BOOT register */
+#define RST_BOOT	0x87e006001600ll
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register
+ */
+union cavm_rst_boot {
+	u64 u;
+	struct cavm_rst_boot_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} s;
+	struct cavm_rst_boot_cn81xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn81xx;
+	struct cavm_rst_boot_cn88xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 reserved_24_25:2;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 reserved_24_25:2;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn88xx;
+	struct cavm_rst_boot_cn83xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn83xx;
+};
+
 /**
  * Returns the I/O clock speed in Hz
  */
diff --git a/arch/arm/include/asm/arch-thunderx/thunderx.h b/arch/arm/include/asm/arch-thunderx/thunderx.h
index 2fb02af075..1c5c5d7b5a 100644
--- a/arch/arm/include/asm/arch-thunderx/thunderx.h
+++ b/arch/arm/include/asm/arch-thunderx/thunderx.h
@@ -6,8 +6,43 @@
 #ifndef __THUNDERX_H__
 #define __THUNDERX_H__
 
-#define CSR_PA(node, csr) ((csr) | ((uint64_t)(node) << 44))
+#define CN81XX	0xA2
+#define CN83XX	0xA3
+#define CN93XX	0xB2
+#define CAVIUM_IS_MODEL(model)	(p_cavm_bdt->prod_id == model)
 
-#define RST_BOOT 0x87E006001600ULL
+#define MAX_LMAC_PER_BGX 4
+
+/** Reg offsets */
+#define CAVM_RST_BOOT		0x87E006001600ULL
+#define CAVM_RST_SOFT_RST	0x87E006001680ULL
+#define CAVM_MIO_FUS_DAT2	0x87E003001410ULL
+
+#if CONFIG_TARGET_THUNDERX_81XX
+#define CAVM_GTI_CWD_POKEX	0x844000050000ULL
+#define CAVM_GTI_CWD_WDOGX	0x844000040000ULL
+#elif CONFIG_TARGET_THUNDERX_83XX
+#define CAVM_GTI_CWD_POKEX	0x802000050000ULL
+#define CAVM_GTI_CWD_WDOGX	0x802000040000ULL
+#endif
+
+/** Structure definitions */
+
+
+
+
+/** Function definitions */
+void thunderx_parse_board_info(void);
+void thunderx_parse_phy_info(void);
+void thunderx_parse_mac_addr(void);
+
+/** Board data definitions */
+struct cavm_bdt {
+	u8 resv[6];
+	u8 prod_id;
+	u8 alt_pkg;
+	char type[16];
+};
+extern struct cavm_bdt *p_cavm_bdt;
 
 #endif
diff --git a/arch/arm/include/asm/arch-thunderx/thunderx_svc.h b/arch/arm/include/asm/arch-thunderx/thunderx_svc.h
index 2e3e632858..eb9ab8cf82 100644
--- a/arch/arm/include/asm/arch-thunderx/thunderx_svc.h
+++ b/arch/arm/include/asm/arch-thunderx/thunderx_svc.h
@@ -14,57 +14,13 @@
 
 #define THUNDERX_SVC_VERSION		0x4300ff03
 
-#define ARM_STD_SVC_VERSION		0x8400ff03
-
 /* ThunderX Service Calls version numbers */
 #define THUNDERX_VERSION_MAJOR	0x0
-#define THUNDERX_VERSION_MINOR	0x1
+#define THUNDERX_VERSION_MINOR	0x2
 
-#define THUNDERX_MMC_READ		0x43000101
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_MMC_WRITE		0x43000102
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-
-#define THUNDERX_NOR_READ		0x43000111
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_NOR_WRITE		0x43000112
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_NOR_ERASE		0x43000113
-/* x1 - block address
- */
-
-#define THUNDERX_PART_COUNT		0x43000201
-#define THUNDERX_GET_PART		0x43000202
-/* x1 - pointer to the buffer
- * x2 - index
- */
-
-#define THUNDERX_DRAM_SIZE		0x43000301
 /* x1 - node number
  */
-
-#define THUNDERX_GTI_SYNC		0x43000401
-
-#define THUNDERX_ENV_COUNT		0x43000501
-#define THUNDERX_ENV_STRING		0x43000502
-/* x1 - index
- */
-
+#define THUNDERX_DRAM_SIZE		0x43000301
 #define THUNDERX_NODE_COUNT		0x43000601
 
-/* x1 - user buffer, x2 - buffer size */
-#define THUNDERX_FDT_GET                0x43000701
-
 #endif /* __THUNDERX_SVC_H__ */
diff --git a/arch/arm/include/asm/arch-thunderx/thunderx_xcv.h b/arch/arm/include/asm/arch-thunderx/thunderx_xcv.h
new file mode 100644
index 0000000000..a365c7cdc8
--- /dev/null
+++ b/arch/arm/include/asm/arch-thunderx/thunderx_xcv.h
@@ -0,0 +1,254 @@
+/**
+ * (C) Copyright 2018, Cavium Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+**/
+
+#ifndef THUNDERX_XCV_H_
+#define THUNDERX_XCV_H_
+
+#define CAVM_XCVX_RESET		0x87E0DB000000ULL
+#define CAVM_XCVX_DLL_CTL	0x87E0DB000010ULL
+#define CAVM_XCVX_CTL		0x87E0DB000030ULL
+#define CAVM_XCVX_BATCH_CRD_RET	0x87E0DB000100ULL
+
+/**
+ * Register (RSL) xcv#_dll_ctl
+ *
+ * XCV DLL Controller Register
+ * The RGMII timing specification requires that devices transmit clock and
+ * data synchronously. The specification requires external sources (namely
+ * the PC board trace routes) to introduce the appropriate 1.5 to 2.0 ns of
+ * delay.
+ *
+ * To eliminate the need for the PC board delays, the RGMII interface has optional
+ * on-board DLLs for both transmit and receive. For correct operation, at most one
+ * of the transmitter, board, or receiver involved in an RGMII link should
+ * introduce delay. By default/reset, the RGMII receivers delay the received clock,
+ * and the RGMII transmitters do not delay the transmitted clock. Whether this
+ * default works as-is with a given link partner depends on the behavior of the
+ * link partner and the PC board.
+ *
+ * These are the possible modes of RGMII receive operation:
+ *
+ * * XCV()_DLL_CTL[CLKRX_BYP] = 0 (reset value) - The RGMII
+ * receive interface introduces clock delay using its internal DLL.
+ * This mode is appropriate if neither the remote
+ * transmitter nor the PC board delays the clock.
+ *
+ * * XCV()_DLL_CTL[CLKRX_BYP] = 1, [CLKRX_SET] = 0x0 - The
+ * RGMII receive interface introduces no clock delay. This mode
+ * is appropriate if either the remote transmitter or the PC board
+ * delays the clock.
+ *
+ * These are the possible modes of RGMII transmit operation:
+ *
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 1, [CLKTX_SET] = 0x0 (reset value) -
+ * The RGMII transmit interface introduces no clock
+ * delay. This mode is appropriate is either the remote receiver
+ * or the PC board delays the clock.
+ *
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 0 - The RGMII transmit
+ * interface introduces clock delay using its internal DLL.
+ * This mode is appropriate if neither the remote receiver
+ * nor the PC board delays the clock.
+ */
+union cavm_xcvx_dll_ctl
+{
+    uint64_t u;
+    struct cavm_xcvx_dll_ctl_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_32_63        : 32;
+        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
+        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
+        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
+                                                                 Skews RXC from RXD, RXCTL.
+                                                                 By default, hardware internally shifts the RXC clock
+                                                                 to sample RXD,RXCTL assuming clock and data and
+                                                                 sourced synchronously from the link partner. */
+        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
+                                                                 Skews RXC from RXD. */
+        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
+                                                                 Skews TXC from TXD, TXCTL.
+                                                                 By default, clock and data and sourced
+                                                                 synchronously. */
+        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
+                                                                 Skews TXC from TXD. */
+        uint64_t reserved_2_7          : 6;
+        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
+                                                                 oscillator.
+                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
+                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
+                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
+                                                                 mode only.
+                                                                 0x0 = RGMII REFCLK.
+                                                                 0x1 = RGMII RXC (1000Mbs only).
+                                                                 0x2 = Divided coprocessor clock.
+                                                                 0x3 = Reserved.
+
+                                                                 Internal:
+                                                                 Some programming magic could allow for 10/100 operation if
+                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
+#else /* Word 0 - Little Endian */
+        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
+                                                                 oscillator.
+                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
+                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
+                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
+                                                                 mode only.
+                                                                 0x0 = RGMII REFCLK.
+                                                                 0x1 = RGMII RXC (1000Mbs only).
+                                                                 0x2 = Divided coprocessor clock.
+                                                                 0x3 = Reserved.
+
+                                                                 Internal:
+                                                                 Some programming magic could allow for 10/100 operation if
+                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
+        uint64_t reserved_2_7          : 6;
+        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
+                                                                 Skews TXC from TXD. */
+        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
+                                                                 Skews TXC from TXD, TXCTL.
+                                                                 By default, clock and data and sourced
+                                                                 synchronously. */
+        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
+                                                                 Skews RXC from RXD. */
+        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
+                                                                 Skews RXC from RXD, RXCTL.
+                                                                 By default, hardware internally shifts the RXC clock
+                                                                 to sample RXD,RXCTL assuming clock and data and
+                                                                 sourced synchronously from the link partner. */
+        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
+        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
+        uint64_t reserved_32_63        : 32;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_dll_ctl_s cn; */
+};
+
+
+/**
+ * Register (RSL) xcv#_reset
+ *
+ * XCV Reset Registers
+ * This register controls reset.
+ */
+union cavm_xcvx_reset
+{
+    uint64_t u;
+    struct cavm_xcvx_reset_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
+        uint64_t reserved_16_62        : 47;
+        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
+                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
+        uint64_t reserved_12_14        : 3;
+        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
+        uint64_t reserved_8_10         : 3;
+        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
+        uint64_t reserved_4_6          : 3;
+        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
+        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
+        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
+        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
+#else /* Word 0 - Little Endian */
+        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
+        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
+        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
+        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
+        uint64_t reserved_4_6          : 3;
+        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
+        uint64_t reserved_8_10         : 3;
+        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
+        uint64_t reserved_12_14        : 3;
+        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
+                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
+        uint64_t reserved_16_62        : 47;
+        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_reset_s cn; */
+};
+
+/**
+ * Register (RSL) xcv#_ctl
+ *
+ * XCV Control Register
+ * This register contains the status control bits.
+ */
+union cavm_xcvx_ctl
+{
+    uint64_t u;
+    struct cavm_xcvx_ctl_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_4_63         : 60;
+        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
+                                                                 * XCV_RESET[CLKRST]       = 1. */
+        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
+                                                                 * XCV_RESET[CLKRST]       = 0. */
+        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
+                                                                   0x0 = 10 Mbps.
+                                                                   0x1 = 100 Mbps.
+                                                                   0x2 = 1 Gbps.
+                                                                   0x3 = Reserved. */
+#else /* Word 0 - Little Endian */
+        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
+                                                                   0x0 = 10 Mbps.
+                                                                   0x1 = 100 Mbps.
+                                                                   0x2 = 1 Gbps.
+                                                                   0x3 = Reserved. */
+        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
+                                                                 * XCV_RESET[CLKRST]       = 0. */
+        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
+                                                                 * XCV_RESET[CLKRST]       = 1. */
+        uint64_t reserved_4_63         : 60;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_ctl_s cn; */
+};
+
+
+/**
+ * Register (RSL) xcv#_batch_crd_ret
+ *
+ * XCV Batch Credit Return Register
+ */
+union cavm_xcvx_batch_crd_ret
+{
+    uint64_t u;
+    struct cavm_xcvx_batch_crd_ret_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_1_63         : 63;
+        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
+                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
+                                                                 take effect when XCV_RESET[ENABLE] is set. */
+#else /* Word 0 - Little Endian */
+        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
+                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
+                                                                 take effect when XCV_RESET[ENABLE] is set. */
+        uint64_t reserved_1_63         : 63;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_batch_crd_ret_s cn; */
+};
+
+
+
+
+#endif /* THUNDERX_XCV_H_ */
diff --git a/arch/arm/mach-thunderx/clock.c b/arch/arm/mach-thunderx/clock.c
index 66aec82589..c80cecaf8a 100644
--- a/arch/arm/mach-thunderx/clock.c
+++ b/arch/arm/mach-thunderx/clock.c
@@ -9,212 +9,6 @@
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 
-/** Address of RST_BOOT register */
-#define RST_BOOT	0x87e006001600ll
-
-/**
- * Register (RSL) rst_boot
- *
- * RST Boot Register
- */
-union cavm_rst_boot {
-	u64 u;
-	struct cavm_rst_boot_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-#endif /* Word 0 - End */
-	} s;
-	struct cavm_rst_boot_cn81xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-#endif /* Word 0 - End */
-	} cn81xx;
-	struct cavm_rst_boot_cn88xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 reserved_24_25:2;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 reserved_24_25:2;
-		u64 reserved_26_29:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-#endif /* Word 0 - End */
-	} cn88xx;
-	struct cavm_rst_boot_cn83xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
-		u64 rboot_pin:1;
-		u64 rboot:1;
-		u64 lboot:10;
-		u64 lboot_ext23:6;
-		u64 lboot_ext45:6;
-		u64 lboot_jtg:1;
-		u64 lboot_ckill:1;
-		u64 lboot_pf_flr:4;
-		u64 lboot_oci:3;
-		u64 pnr_mul:6;
-		u64 reserved_39:1;
-		u64 c_mul:7;
-		u64 reserved_47_54:8;
-		u64 dis_scan:1;
-		u64 dis_huk:1;
-		u64 vrm_err:1;
-		u64 jt_tstmode:1;
-		u64 ckill_ppdis:1;
-		u64 trusted_mode:1;
-		u64 ejtagdis:1;
-		u64 jtcsrdis:1;
-		u64 chipkill:1;
-#endif /* Word 0 - End */
-	} cn83xx;
-};
-
 /**
  * Returns the I/O clock speed in Hz
  */
diff --git a/board/cavium/thunderx/Makefile b/board/cavium/thunderx/Makefile
index 374f254c94..828dcf6793 100644
--- a/board/cavium/thunderx/Makefile
+++ b/board/cavium/thunderx/Makefile
@@ -4,6 +4,4 @@
 #
 
 obj-y	:= thunderx.o atf.o
-obj-$(CONFIG_OF_LIBFDT) += fdt.o psci.o powerburn_dp.o
-
-ccflags-y += -Icsr/include
+obj-$(CONFIG_OF_LIBFDT) += fdt.o
diff --git a/board/cavium/thunderx/fdt.c b/board/cavium/thunderx/fdt.c
index e9aec435cc..6635bd524d 100644
--- a/board/cavium/thunderx/fdt.c
+++ b/board/cavium/thunderx/fdt.c
@@ -8,32 +8,56 @@
 #include <malloc.h>
 #include <errno.h>
 #include <environment.h>
+#include <asm/io.h>
 #include <linux/compiler.h>
-
 #include <libfdt.h>
 #include <fdtdec.h>
 #include <fdt_support.h>
 #include <asm/arch/atf.h>
+#include <asm/arch/thunderx.h>
 
 #ifdef CONFIG_THUNDERX_VNIC
 # include <asm/arch/thunderx_vnic.h>
 #endif
 
-#define MAX_LMAC_PER_BGX 4
-
 DECLARE_GLOBAL_DATA_PTR;
 
+struct cavm_bdt g_cavm_bdt;
+struct cavm_bdt *p_cavm_bdt;
+
 extern unsigned long fdt_base_addr;
 
-void thunderx_parse_bdk_config(void)
+static inline uint64_t cavm_get_model(void) __attribute__ ((pure, always_inline));
+static inline uint64_t cavm_get_model(void)
+{
+#ifdef CAVM_BUILD_HOST
+    extern uint32_t thunder_remote_get_model(void) __attribute__ ((pure));
+    return thunder_remote_get_model();
+#else
+    uint64_t result;
+    asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (result));
+    return result;
+#endif
+}
+
+void thunderx_parse_board_info(void)
 {
-	char boardname[32];
 	const char *str;
 	int node;
-	int ret = 0, len = sizeof(boardname);
-	int bgx_id;
+	int ret = 0, len = 16;
+	u64 midr, val;
 
 	debug("%s: ENTER\n", __func__);
+
+	midr = cavm_get_model();
+	g_cavm_bdt.prod_id = (midr >> 4) & 0xff;
+
+	val = readq(CAVM_MIO_FUS_DAT2);
+	g_cavm_bdt.alt_pkg = (val >> 22) & 0x3;
+	if ((g_cavm_bdt.prod_id == CN81XX) &&
+		(g_cavm_bdt.alt_pkg || ((val >> 30) & 0x1)))
+		g_cavm_bdt.alt_pkg = 2;
+
 	if (!gd->fdt_blob) {
 		printf("ERROR: %s: no valid device tree found\n", __func__);
 		return;
@@ -57,13 +81,15 @@ void thunderx_parse_bdk_config(void)
 	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
 	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
 	if (str) {
-		strncpy(boardname, str, sizeof(boardname));
-		env_set("board", boardname);
+		strncpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
+		debug("fdt: BOARD-MODEL bdt.type %s \n", g_cavm_bdt.type);
 	} else {
 		printf("Error: cannot retrieve board type from fdt\n");
 	}
+	p_cavm_bdt = &g_cavm_bdt;
 }
 
+#ifdef CONFIG_THUNDERX_BGX
 static int thunderx_get_mdio_bus(const void *fdt, int phy_offset)
 {
 	int node, bus = -1;
@@ -94,6 +120,7 @@ static int thunderx_get_phy_addr(const void *fdt, int phy_offset)
 	addr = fdt32_to_cpu(*reg);
 	return addr;
 }
+#endif
 
 void thunderx_parse_phy_info(void)
 {
@@ -368,104 +395,6 @@ int ft_board_setup(void *blob, bd_t *bd)
 	return 0;
 }
 
-
-#define NODENAME_BUFLEN 32
-
-int ft_getcore(void *blob, char *id)
-{
-	int nodeoffset;
-	char nodename[NODENAME_BUFLEN];
-
-	snprintf(nodename, sizeof(nodename), "/cpus/cpu@%s", id);
-
-	nodeoffset = fdt_path_offset(blob, nodename);
-
-	if (nodeoffset < 0) {
-		printf("WARNING: could not find %s: %s.\n", nodename,
-		       fdt_strerror(nodeoffset));
-	}
-
-	return nodeoffset;
-}
-
-void ft_coreenable(bd_t *bd, char *id, int enable)
-{
-	int err;
-	void *blob = working_fdt;
-
-	int nodeoffset = ft_getcore(blob, id);
-
-	if (nodeoffset < 0)
-		return;
-
-	err = fdt_setprop_u32(blob, nodeoffset, "enabled", enable);
-
-	if (err < 0) {
-		printf("WARNING: could not set %s: %s.\n", "enabled",
-		       fdt_strerror(err));
-		return;
-	}
-}
-
-int ft_corestatus(bd_t *bd, char *id)
-{
-	const u32 *enabled;
-	void *blob = working_fdt;
-
-	int nodeoffset = ft_getcore(blob, id);
-
-	if (nodeoffset < 0)
-		return -1;
-
-	enabled = fdt_getprop(blob, nodeoffset, "enabled", NULL);
-
-	if (enabled == NULL)
-		return 1;
-	else
-		return *enabled;
-}
-
-static int parse_argv(const char *s)
-{
-	if (strncmp(s, "en", 2) == 0)
-		return 1;
-	else if (strncmp(s, "di", 2) == 0)
-		return 0;
-
-	return -1;
-}
-
-int do_cpucore(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	int enable;
-
-	switch (argc) {
-	case 3:			/* enable / disable	*/
-		enable = parse_argv(argv[2]);
-
-		if (enable < 0)
-			return CMD_RET_USAGE;
-		else
-			ft_coreenable(NULL, argv[1], enable);
-
-		break;
-	case 2:			/* get status */
-		printf("CPU Core %s is %s\n", argv[1],
-		       ft_corestatus(NULL, argv[1]) ? "ENABLED" : "DISABLED");
-		return 0;
-	default:
-		return CMD_RET_USAGE;
-	}
-	return 0;
-}
-
-U_BOOT_CMD(
-	cpucore,   3,   1,     do_cpucore,
-	"enable or disable a CPU core",
-	"id [enable, disable]\n"
-	"    - enable or disable a CPU core"
-);
-
 /**
  * Return the FDT base address that was passed by ATF
  *
diff --git a/board/cavium/thunderx/thunderx.c b/board/cavium/thunderx/thunderx.c
index 0016a2bc7c..c6d82e5f71 100644
--- a/board/cavium/thunderx/thunderx.c
+++ b/board/cavium/thunderx/thunderx.c
@@ -9,53 +9,14 @@
 #include <errno.h>
 #include <netdev.h>
 #include <asm/io.h>
-
 #include <linux/compiler.h>
-
-#include <asm/arch/atf.h>
-
 #include <libfdt.h>
 #include <fdt_support.h>
-#include <cavium/thunderx_fdt.h>
-#include <cavium/atf.h>
-#include <asm/armv8/mmu.h>
-
-#if !CONFIG_IS_ENABLED(OF_CONTROL)
-#include <dm/platform_data/serial_pl01x.h>
-
-static const struct pl01x_serial_platdata serial0 = {
-	.base = CONFIG_SYS_SERIAL0,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial0) = {
-	.name = "serial_pl01x",
-	.platdata = &serial0,
-};
-
-static const struct pl01x_serial_platdata serial1 = {
-	.base = CONFIG_SYS_SERIAL1,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial1) = {
-	.name = "serial_pl01x",
-	.platdata = &serial1,
-};
-#endif
-#include <asm/arch/thunderx_fdt.h>
+#include <asm/arch/thunderx.h>
 #include <asm/arch/atf.h>
 #include <dm/util.h>
 
-#include "cavm-arch.h"
-
 DECLARE_GLOBAL_DATA_PTR;
-
-char boardtype[32];
 extern unsigned long fdt_base_addr;
 
 #ifdef CONFIG_BOARD_EARLY_INIT_R
@@ -70,17 +31,9 @@ int board_early_init_r(void)
 
 int board_init(void)
 {
-	const char *str;
-	int len, node;
-	ulong fdt_addr = (ulong)fdt_base_addr;
-
-	set_working_fdt_addr(fdt_addr);
+	thunderx_parse_board_info();
 	thunderx_parse_phy_info();
-	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-	strncpy(boardtype, str, len);
-
-	printf("Board type: %s\n", boardtype);
+	printf("Board: %s\n", p_cavm_bdt->type);
 	return 0;
 }
 
@@ -120,64 +73,24 @@ void reset_cpu(ulong addr)
 	writeq(val, CAVM_RST_SOFT_RST);
 }
 
-/*
- * Return board alternative package
- */
-bool alternate_pkg(void)
-{
-	u64 val = readq(CAVM_MIO_FUS_DAT2);
-	int altpkg;
-
-	altpkg = (val >> 22) & 0x3;
-
-	/* Figure out alternative pkg by reading chip_id
-	   or lmc_mode32 on 81xx */
-	if (CAVIUM_IS_MODEL(CAVIUM_CN81XX)
-	    && (altpkg || ((val >> 30) & 0x1)))
-		return 2;
-	return altpkg;
-}
-
 /**
  * Board late initialization routine.
  */
 int board_late_init(void)
 {
-	char boardname[32];
-	const char *board, *str;
-	int len, node;
+	char boardname[20];
 
 	debug("%s()\n", __func__);
-
 	/*
 	 * Now that pci_init initializes env device.
-	 * Try to set environment variables
+	 * Try to validate ethaddr env variables
 	 */
-	thunderx_parse_bdk_config();
 	thunderx_parse_mac_addr();
 
-	board = env_get("board");
-
-	/* some times simulator fails to load environment
-	 * from flash, try to read it from devicetree
-	 * until it is fixed
-	 */
-	if (board == NULL) {
-		node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
-		str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
-		debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-		if (str) {
-			strncpy(boardname, str, len);
-			env_set("board", boardname);
-		}
-		board = env_get("board");
-	}
-	snprintf(boardname, sizeof(boardname), "%s> ", board);
+	debug("bdt.type %s\n", p_cavm_bdt->type);
+	snprintf(boardname, sizeof(boardname), "%s> ", p_cavm_bdt->type);
 	env_set("prompt", boardname);
-#ifdef DEBUG
-	dm_dump_all();
-#endif
-
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
 	return 0;
 }
 
@@ -204,19 +117,11 @@ int board_eth_init(bd_t *bis)
 #ifdef CONFIG_HW_WATCHDOG
 void hw_watchdog_reset(void)
 {
-	ssize_t node, core;
-
-	for (node = 0; node < atf_node_count(); node++)
-		for (core = 0; core < 1; core++)
-			writeq(~0ULL, CSR_PA(node, CAVM_GTI_CWD_POKEX(core)));
+	writeq(~0ULL, CAVM_GTI_CWD_POKEX);
 }
 
 void hw_watchdog_disable(void)
 {
-	ssize_t node, core;
-
-	for (node = 0; node < atf_node_count(); node++)
-		for (core = 0; core < 1; core++)
-			writeq(0ULL, CSR_PA(node, CAVM_GTI_CWD_WDOGX(core)));
+	writeq(0ULL, CAVM_GTI_CWD_WDOGX);
 }
 #endif
diff --git a/configs/t83_defconfig b/configs/t83_defconfig
index c56ee7b141..7e3b5f38b2 100644
--- a/configs/t83_defconfig
+++ b/configs/t83_defconfig
@@ -86,7 +86,6 @@ CONFIG_RTL8169=y
 CONFIG_CAVIUM_NET=y
 CONFIG_THUNDERX_VNIC=y
 CONFIG_THUNDERX_BGX=y
-CONFIG_THUNDERX_XCV=y
 CONFIG_THUNDERX_SMI=y
 CONFIG_NVME=y
 CONFIG_PCI=y
diff --git a/csr b/csr
deleted file mode 120000
index 5702a41e9a..0000000000
--- a/csr
+++ /dev/null
@@ -1 +0,0 @@
-../../csr
\ No newline at end of file
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 60ab841382..a8263a3127 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -25,6 +25,9 @@
 #include <ahci.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#if CONFIG_ARCH_THUNDERX
+#include <asm/arch/thunderx.h>
+#endif
 
 static int ata_io_flush(struct ahci_uc_priv *uc_priv, u8 port);
 
@@ -589,7 +592,7 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	 * and its scatter-gather table
 	 */
 	pp->cmd_tbl = virt_to_phys((void *)mem);
-	debug("cmd_tbl_dma = %lx\n", pp->cmd_tbl);
+	debug("cmd_tbl_dma = %llx\n", pp->cmd_tbl);
 
 	mem += AHCI_CMD_TBL_HDR;
 	pp->cmd_tbl_sg =
@@ -616,8 +619,8 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	 * have port multiplier and device is always present
 	 * U-boot lacks port multiplier support hence this ugly hack.
 	 */
-	if ((strcasecmp(boardtype, "sff8104") == 0) ||
-		(strcasecmp(boardtype, "nas8104") == 0))
+	if ((strcasecmp(p_cavm_bdt->type, "sff8104") == 0) ||
+		(strcasecmp(p_cavm_bdt->type, "nas8104") == 0))
 		return 0;
 	/*
 	 * Make sure interface is not busy based on error and status
diff --git a/drivers/net/cavium/Makefile b/drivers/net/cavium/Makefile
index f042ca3d29..42c96283ba 100644
--- a/drivers/net/cavium/Makefile
+++ b/drivers/net/cavium/Makefile
@@ -8,4 +8,3 @@ obj-$(CONFIG_THUNDERX_VNIC) += nic_main.o nicvf_queues.o nicvf_main.o
 obj-$(CONFIG_THUNDERX_SMI) += thunderx_smi.o
 obj-$(CONFIG_THUNDERX_XCV) += thunder_xcv.o
 
-ccflags-y += -Icsr/include
diff --git a/drivers/net/cavium/thunder_bgx.c b/drivers/net/cavium/thunder_bgx.c
index cfee57507a..0f46a24f08 100644
--- a/drivers/net/cavium/thunder_bgx.c
+++ b/drivers/net/cavium/thunder_bgx.c
@@ -24,13 +24,12 @@
  #include <fdt_support.h>
 #endif
 
-#include <asm/arch/thunderx_smi.h>
+#include <asm/arch/thunderx.h>
 #include <asm/arch/thunderx_vnic.h>
 
 #include "nic_reg.h"
 #include "nic.h"
 #include "thunder_bgx.h"
-#include "cavm-arch.h"
 
 static const phy_interface_t if_mode[] = {
 	[QLM_MODE_SGMII]  = PHY_INTERFACE_MODE_SGMII,
@@ -272,10 +271,10 @@ static int get_qlm_for_bgx(int node, int bgx_id, int index)
 	int qlm = 0;
 	uint64_t cfg;
 
-	if (CAVIUM_IS_MODEL(CAVIUM_CN81XX)) {
+	if (CAVIUM_IS_MODEL(CN81XX)) {
 		qlm = (bgx_id) ? 2 : 0;
 		qlm += (index >= 2) ? 1 : 0;
-	} else if (CAVIUM_IS_MODEL(CAVIUM_CN83XX)) {
+	} else if (CAVIUM_IS_MODEL(CN83XX)) {
 		switch (bgx_id) {
 		case 0:
 			qlm = 2;
@@ -561,9 +560,9 @@ static int bgx_lmac_xaui_init(struct bgx *bgx, int lmacid, int lmac_type)
 /* Get max number of lanes present in a given QLM/DLM */
 static int get_qlm_lanes(int qlm)
 {
-	if (CAVIUM_IS_MODEL(CAVIUM_CN81XX))
+	if (CAVIUM_IS_MODEL(CN81XX))
 		return 2;
-	else if (CAVIUM_IS_MODEL(CAVIUM_CN83XX))
+	else if (CAVIUM_IS_MODEL(CN83XX))
 		return (qlm >= 5) ? 2 : 4;
 	else
 		return -1;
@@ -678,8 +677,8 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 	if (!lmac->use_training) {
 		int qlm;
 		bool use_dlm = 0;
-		if (CAVIUM_IS_MODEL(CAVIUM_CN81XX)
-		    || (CAVIUM_IS_MODEL(CAVIUM_CN83XX) && (bgx->bgx_id == 2)))
+		if (CAVIUM_IS_MODEL(CN81XX)
+		    || (CAVIUM_IS_MODEL(CN83XX) && (bgx->bgx_id == 2)))
 			use_dlm = 1;
 		switch (lmac->lmac_type) {
 		default:
@@ -1008,7 +1007,7 @@ static void bgx_init_hw(struct bgx *bgx)
 	struct lmac *lmac;
 	int i, lmacid, count = 0, inc = 0;
 	char buf[40];
-	static qsgmii_configured = 0;
+	static int qsgmii_configured = 0;
 
 	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
 		struct lmac *tlmac;
@@ -1207,8 +1206,8 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		int train_en;
 		int index = 0;
 
-		if (CAVIUM_IS_MODEL(CAVIUM_CN81XX)
-		    || (CAVIUM_IS_MODEL(CAVIUM_CN83XX) && (bgx->bgx_id == 2)))
+		if (CAVIUM_IS_MODEL(CN81XX)
+		    || (CAVIUM_IS_MODEL(CN83XX) && (bgx->bgx_id == 2)))
 			index = (lmacid < 2) ? 0 : 2;
 
 		lmac = &bgx->lmac[lmacid];
@@ -1296,7 +1295,7 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		break;
 		case BGX_MODE_QSGMII:
 			/* If QLM is configured as QSGMII, use lmac0 */
-			if (CAVIUM_IS_MODEL(CAVIUM_CN83XX)
+			if (CAVIUM_IS_MODEL(CN83XX)
 			    && (lmacid == 2)
 			    && (bgx->bgx_id != 3)) {
 				//lmac->qlm_mode = QLM_MODE_DISABLED;
@@ -1387,7 +1386,7 @@ int thunderx_bgx_probe(struct udevice *dev)
 		debug("No PCI region found\n");
 		return 0;
 	}
-	is_altpkg = alternate_pkg();
+	is_altpkg = p_cavm_bdt->alt_pkg;
 
 #ifdef CONFIG_THUNDERX_XCV
 	/* Use FAKE BGX2 for RGX interface */
@@ -1411,14 +1410,14 @@ int thunderx_bgx_probe(struct udevice *dev)
 	bgx_idx = ((uintptr_t)bgx->reg_base >> 24) & 3;
 	bgx->bgx_id = (node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx;
 
-	if (CAVIUM_IS_MODEL(CAVIUM_CN81XX))
+	if (CAVIUM_IS_MODEL(CN81XX))
 		inc = 2;
-	else if (CAVIUM_IS_MODEL(CAVIUM_CN83XX) && (bgx_idx == 2))
+	else if (CAVIUM_IS_MODEL(CN83XX) && (bgx_idx == 2))
 		inc = 2;
 
 	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac += inc) {
 		/* BGX3 (DLM4), has only 2 lanes */
-		if (CAVIUM_IS_MODEL(CAVIUM_CN83XX) && (bgx_idx == 3) && lmac >= 2)
+		if (CAVIUM_IS_MODEL(CN83XX) && (bgx_idx == 3) && lmac >= 2)
 			continue;
 		qlm[lmac + 0] = get_qlm_for_bgx(node, bgx_idx, lmac);
 		/* Each DLM has 2 lanes, configure both lanes with
@@ -1430,7 +1429,7 @@ int thunderx_bgx_probe(struct udevice *dev)
 
 	/* A BGX can take 1 or 2 DLMs, if both the DLMs are not configured
 	   as BGX, then return, nothing to initialize */
-	if (CAVIUM_IS_MODEL(CAVIUM_CN81XX))
+	if (CAVIUM_IS_MODEL(CN81XX))
 		if ((qlm[0] == -1) && (qlm[2] == -1))
 			return -ENODEV;
 
diff --git a/drivers/net/cavium/thunder_xcv.c b/drivers/net/cavium/thunder_xcv.c
index aa5aca1a83..d458ed8a8e 100644
--- a/drivers/net/cavium/thunder_xcv.c
+++ b/drivers/net/cavium/thunder_xcv.c
@@ -24,11 +24,10 @@
  #include <fdt_support.h>
 #endif
 
+#include <asm/arch/thunderx_xcv.h>
 #include <asm/arch/thunderx_smi.h>
 #include <asm/arch/thunderx_vnic.h>
 
-#include "cavm-arch.h"
-
 struct lxcv {
 	void __iomem		*reg_base;
 	struct pci_dev		*pdev;
@@ -45,45 +44,45 @@ void xcv_init_hw(void)
 	//union cavm_xcvx_comp_ctl xcv_comp_ctl;
 
 	/* Take the DLL out of reset */
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	reset.u = readq(CAVM_XCVX_RESET);
 	reset.s.dllrst = 0;
-	writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+	writeq(reset.u, CAVM_XCVX_RESET);
 
 	/* Take the clock tree out of reset */
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	reset.u = readq(CAVM_XCVX_RESET);
 	reset.s.clkrst = 0;
-	writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+	writeq(reset.u, CAVM_XCVX_RESET);
 
 	/* Once the 125MHz ref clock is stable, wait 10us for DLL to lock *.
  */
 	udelay(10);
 
 	/* Optionally, bypass the DLL setting */
-	xcv_dll_ctl.u = readq(CSR_PA(0, CAVM_XCVX_DLL_CTL(0)));
+	xcv_dll_ctl.u = readq(CAVM_XCVX_DLL_CTL);
 	xcv_dll_ctl.s.clkrx_set = 0;
 	xcv_dll_ctl.s.clkrx_byp = 1;
 	xcv_dll_ctl.s.clktx_byp = 0;
-	writeq(xcv_dll_ctl.u, CSR_PA(0, CAVM_XCVX_DLL_CTL(0)));
+	writeq(xcv_dll_ctl.u, CAVM_XCVX_DLL_CTL);
 
 	/* Enable the compensation controller */
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	reset.u = readq(CAVM_XCVX_RESET);
 	reset.s.comp = 1;
-	writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	writeq(reset.u, CAVM_XCVX_RESET);
+	reset.u = readq(CAVM_XCVX_RESET);
 
 	/* Wait for 1040 reference clock cycles for the compensation state 
 	   machine lock. */
 	udelay(100); 
 
 	/* Enable the XCV block */
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	reset.u = readq(CAVM_XCVX_RESET);
 	reset.s.enable = 1;
-	writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+	writeq(reset.u, CAVM_XCVX_RESET);
 
 	/* set XCV(0)_RESET[CLKRST] to 1 */
-	reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+	reset.u = readq(CAVM_XCVX_RESET);
 	reset.s.clkrst = 1;
-	writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+	writeq(reset.u, CAVM_XCVX_RESET);
 }
 
 /* 
@@ -107,36 +106,36 @@ void xcv_setup_link(bool link_up, int link_speed)
 
 	if (link_up) {
 		/* Set operating speed */
-		xcv_ctl.u = readq(CSR_PA(0, CAVM_XCVX_CTL(0)));
+		xcv_ctl.u = readq(CAVM_XCVX_CTL);
 		xcv_ctl.s.speed = speed;
-		writeq(xcv_ctl.u, CSR_PA(0, CAVM_XCVX_CTL(0)));
+		writeq(xcv_ctl.u, CAVM_XCVX_CTL);
 
 		/* Datapaths come out of reset
 		   - The datapath resets will disengage BGX from the
 		     RGMII interface
 		   - XCV will continue to return TX credits for each tick
 		     that is sent on the TX data path */
-		reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+		reset.u = readq(CAVM_XCVX_RESET);
 		reset.s.tx_dat_rst_n = 1;
 		reset.s.rx_dat_rst_n = 1;
-		writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+		writeq(reset.u, CAVM_XCVX_RESET);
 
 		/* Enable packet flow */
-		reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+		reset.u = readq(CAVM_XCVX_RESET);
 		reset.s.tx_pkt_rst_n = 1;
 		reset.s.rx_pkt_rst_n = 1;
-		writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
+		writeq(reset.u, CAVM_XCVX_RESET);
 
-		xcv_crd_ret.u = readq(CSR_PA(0, CAVM_XCVX_BATCH_CRD_RET(0)));
+		xcv_crd_ret.u = readq(CAVM_XCVX_BATCH_CRD_RET);
 		xcv_crd_ret.s.crd_ret = 1;
-		writeq(xcv_crd_ret.u, CSR_PA(0, CAVM_XCVX_BATCH_CRD_RET(0)));
+		writeq(xcv_crd_ret.u, CAVM_XCVX_BATCH_CRD_RET);
 	} else {
 		/* Enable packet flow */
-		reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+		reset.u = readq(CAVM_XCVX_RESET);
 		reset.s.tx_pkt_rst_n = 0;
 		reset.s.rx_pkt_rst_n = 0;
-		writeq(reset.u, CSR_PA(0, CAVM_XCVX_RESET(0)));
-		reset.u = readq(CSR_PA(0, CAVM_XCVX_RESET(0)));
+		writeq(reset.u, CAVM_XCVX_RESET);
+		reset.u = readq(CAVM_XCVX_RESET);
 	}
 }
 
diff --git a/drivers/pci/pci_auto.c b/drivers/pci/pci_auto.c
index 43c3c6357d..0adae0ec17 100644
--- a/drivers/pci/pci_auto.c
+++ b/drivers/pci/pci_auto.c
@@ -11,6 +11,7 @@
 #include <dm.h>
 #include <errno.h>
 #include <pci.h>
+#include <dm/device-internal.h>
 
 /* the user can define CONFIG_SYS_PCI_CACHE_LINE_SIZE to avoid problems */
 #ifndef CONFIG_SYS_PCI_CACHE_LINE_SIZE
diff --git a/include/configs/thunderx_93xx.h b/include/configs/thunderx_93xx.h
index 8bbfe3f8fc..1831aa420f 100644
--- a/include/configs/thunderx_93xx.h
+++ b/include/configs/thunderx_93xx.h
@@ -102,6 +102,4 @@
 #undef CONFIG_SYS_PROMPT
 #define CONFIG_SYS_PROMPT		env_get("prompt")
 
-#define CONFIG_HW_WATCHDOG
-
 #endif /* __THUNDERX_93XX_H__ */
-- 
2.29.0

