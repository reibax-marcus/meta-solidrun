From a464f455a35c3f0d8a6ce34f9b0b249bd5553a11 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <sgarapati@caviumnetworks.com>
Date: Thu, 12 Sep 2019 19:39:53 -0700
Subject: [PATCH 0961/1239] octeontx: octeontx2: cleanup code for upstream

- clean checkpatch errors across all driver and board files
- remove redundant files
- cleanup and sync csr headers
- validate across all platforms

Change-Id: I03c163353448ae64d710c796994814c1b3cb174b
Signed-off-by: Suneel Garapati <sgarapati@caviumnetworks.com>
Reviewed-on: https://sj1git1.cavium.com/16215
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
---
 arch/arm/include/asm/arch-octeontx/atf.h      |    6 +-
 arch/arm/include/asm/arch-octeontx/atf_part.h |   27 -
 arch/arm/include/asm/arch-octeontx/clock.h    |  105 +-
 .../csrs-mio_emm.h}                           |  526 +-
 .../include/asm/arch-octeontx/csrs/csrs-xcv.h |  428 ++
 .../include/asm/arch-octeontx/fdt-helper.h    |   37 -
 arch/arm/include/asm/arch-octeontx/gpio.h     |    6 +
 arch/arm/include/asm/arch-octeontx/octeontx.h |    5 +-
 .../include/asm/arch-octeontx/octeontx_fdt.h  |   12 -
 .../include/asm/arch-octeontx/octeontx_mmc.h  |  211 -
 .../include/asm/arch-octeontx/octeontx_smi.h  |   14 -
 .../include/asm/arch-octeontx/octeontx_svc.h  |    5 +-
 .../include/asm/arch-octeontx/octeontx_vnic.h |    5 +-
 .../include/asm/arch-octeontx/octeontx_xcv.h  |  249 +-
 arch/arm/include/asm/arch-octeontx2/atf.h     |    5 +-
 .../include/asm/arch-octeontx2/cavium_mmc.h   | 1815 ------
 .../asm/arch-octeontx2/cavm-csrs-mio_emm.h    |    1 -
 arch/arm/include/asm/arch-octeontx2/clock.h   |  106 +-
 .../include/asm/arch-octeontx2/csrs-mio_emm.h | 1199 ++++
 .../asm/arch-octeontx2/csrs/csrs-cgx.h        | 3014 +++++-----
 .../asm/arch-octeontx2/csrs/csrs-lmt.h        |   60 +
 .../asm/arch-octeontx2/csrs/csrs-mio_emm.h    | 1199 ++++
 .../asm/arch-octeontx2/csrs/csrs-nix.h        | 4864 ++++++++++-------
 .../asm/arch-octeontx2/csrs/csrs-npa.h        |  972 ++--
 .../asm/arch-octeontx2/csrs/csrs-npc.h        |  964 ++--
 .../asm/arch-octeontx2/csrs/csrs-rvu.h        | 1329 +++--
 .../include/asm/arch-octeontx2/fdt-helper.h   |   38 -
 arch/arm/include/asm/arch-octeontx2/gpio.h    |    6 +
 .../include/asm/arch-octeontx2/octeontx_mmc.h |    1 -
 arch/arm/mach-octeontx/Makefile               |    4 +-
 arch/arm/mach-octeontx/clock.c                |    2 +-
 arch/arm/mach-octeontx/cpu.c                  |    4 +-
 arch/arm/mach-octeontx/fdt-helper.c           |   72 -
 arch/arm/mach-octeontx/lowlevel_init.S        |    4 +-
 arch/arm/mach-octeontx2/clock.c               |    2 +-
 arch/arm/mach-octeontx2/cpu.c                 |    4 +-
 arch/arm/mach-octeontx2/fdt-helper.c          |   72 -
 arch/arm/mach-octeontx2/lowlevel_init.S       |    4 +-
 board/Marvell/octeontx/atf.c                  |   15 +-
 board/Marvell/octeontx/fdt.c                  |   26 +-
 board/Marvell/octeontx/octeontx.c             |   46 +-
 board/Marvell/octeontx2/atf.c                 |   22 +-
 board/Marvell/octeontx2/fdt.c                 |    9 +-
 board/Marvell/octeontx2/octeontx2.c           |   28 +-
 cmd/bootimgup.c                               |    3 +-
 drivers/gpio/octeontx_gpio.c                  |   20 +-
 drivers/i2c/octeontx_i2c.c                    |   56 +-
 drivers/mmc/octeontx_hsmmc.c                  |  531 +-
 drivers/mmc/octeontx_hsmmc.h                  |   22 +-
 drivers/net/octeontx/Makefile                 |    5 +-
 drivers/net/octeontx/nic.h                    |  108 +-
 drivers/net/octeontx/nic_main.c               |   61 +-
 drivers/net/octeontx/nic_reg.h                |   15 +-
 drivers/net/octeontx/nicvf_main.c             |   98 +-
 drivers/net/octeontx/nicvf_queues.c           |   65 +-
 drivers/net/octeontx/nicvf_queues.h           |  117 +-
 drivers/net/octeontx/octeontx_bgx.c           |  410 +-
 drivers/net/octeontx/octeontx_bgx.h           |  125 +-
 drivers/net/octeontx/octeontx_smi.c           |   73 +-
 drivers/net/octeontx/octeontx_xcv.c           |  104 +-
 drivers/net/octeontx/q_struct.h               |  747 ++-
 drivers/net/octeontx2/cavm-csrs-lmt.h         |   61 -
 drivers/net/octeontx2/cgx.c                   |  116 +-
 drivers/net/octeontx2/cgx.h                   |    7 +-
 drivers/net/octeontx2/cgx_intf.c              |   14 +-
 drivers/net/octeontx2/cgx_intf.h              |  160 +-
 drivers/net/octeontx2/lmt.h                   |   13 +-
 drivers/net/octeontx2/nix.c                   |  219 +-
 drivers/net/octeontx2/nix.h                   |   77 +-
 drivers/net/octeontx2/nix_af.c                |  598 +-
 drivers/net/octeontx2/npc.c                   |  400 --
 drivers/net/octeontx2/npc.h                   |    5 +-
 drivers/net/octeontx2/npc_profile.h           | 3354 ------------
 drivers/net/octeontx2/npc_reg.h               |  639 ---
 drivers/net/octeontx2/rvu.h                   |   23 +-
 drivers/net/octeontx2/rvu_af.c                |   70 +-
 drivers/net/octeontx2/rvu_common.c            |   10 +-
 drivers/net/octeontx2/rvu_pf.c                |   30 +-
 drivers/pci/pci_octeontx_ecam.c               |   90 +-
 drivers/spi/octeontx_spi.c                    |   45 +-
 80 files changed, 11646 insertions(+), 14368 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-octeontx/atf_part.h
 rename arch/arm/include/asm/arch-octeontx/{cavm-csrs-mio_emm.h => csrs/csrs-mio_emm.h} (69%)
 create mode 100644 arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/fdt-helper.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/gpio.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_smi.h
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
 delete mode 120000 arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
 rename drivers/net/octeontx2/cavm-csrs-cgx.h => arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h (72%)
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
 rename drivers/net/octeontx2/cavm-csrs-nix.h => arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h (64%)
 rename drivers/net/octeontx2/cavm-csrs-npa.h => arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h (69%)
 rename drivers/net/octeontx2/cavm-csrs-npc.h => arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h (63%)
 rename drivers/net/octeontx2/cavm-csrs-rvu.h => arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h (56%)
 delete mode 100644 arch/arm/include/asm/arch-octeontx2/fdt-helper.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/gpio.h
 delete mode 120000 arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
 delete mode 100644 arch/arm/mach-octeontx/fdt-helper.c
 delete mode 100644 arch/arm/mach-octeontx2/fdt-helper.c
 delete mode 100644 drivers/net/octeontx2/cavm-csrs-lmt.h
 delete mode 100644 drivers/net/octeontx2/npc.c
 delete mode 100644 drivers/net/octeontx2/npc_profile.h
 delete mode 100644 drivers/net/octeontx2/npc_reg.h

diff --git a/arch/arm/include/asm/arch-octeontx/atf.h b/arch/arm/include/asm/arch-octeontx/atf.h
index f52b0c877e..1d5d581c7f 100644
--- a/arch/arm/include/asm/arch-octeontx/atf.h
+++ b/arch/arm/include/asm/arch-octeontx/atf.h
@@ -1,14 +1,12 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
 #ifndef __ATF_H__
 #define __ATF_H__
-#include <asm/arch/atf_part.h>
 
 ssize_t atf_dram_size(unsigned int node);
-ssize_t atf_node_count(void);
 #endif
diff --git a/arch/arm/include/asm/arch-octeontx/atf_part.h b/arch/arm/include/asm/arch-octeontx/atf_part.h
deleted file mode 100644
index 88b9eaf7a8..0000000000
--- a/arch/arm/include/asm/arch-octeontx/atf_part.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-#ifndef __ATF_PART_H__
-#define __ATF_PART_H__
-
-struct storage_partition {
-	unsigned int type;
-	unsigned int size;
-	unsigned long offset;
-};
-
-enum {
-	PARTITION_NBL1FW_REST = 0,
-	PARTITION_BL2_BL31 = 1,
-	PARTITION_UBOOT = 2,
-	PARTITION_UEFI = 2,
-	PARTITION_KERNEL = 3,
-	PARTITION_DEVICE_TREE = 4,
-	PARTITION_LAST,
-};
-
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx/clock.h b/arch/arm/include/asm/arch-octeontx/clock.h
index 3b7214d3d4..f94f755e48 100644
--- a/arch/arm/include/asm/arch-octeontx/clock.h
+++ b/arch/arm/include/asm/arch-octeontx/clock.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -9,7 +9,7 @@
 
 /** System PLL reference clock */
 #define PLL_REF_CLK                     50000000        /* 50 MHz */
-#define NS_PER_REF_CLK_TICK             (1000000000/PLL_REF_CLK)
+#define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
 
 /** Address of RST_BOOT register */
 #define RST_BOOT	0x87e006001600ll
@@ -22,30 +22,6 @@
 union cavm_rst_boot {
 	u64 u;
 	struct cavm_rst_boot_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -68,33 +44,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} s;
 	struct cavm_rst_boot_cn81xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -117,32 +68,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn81xx;
 	struct cavm_rst_boot_cn88xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 reserved_24_25:2;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -164,33 +91,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn88xx;
 	struct cavm_rst_boot_cn83xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -213,7 +115,6 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn83xx;
 };
 
diff --git a/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
similarity index 69%
rename from arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
rename to arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
index f2f026fce2..4dd8958d2f 100644
--- a/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
+++ b/arch/arm/include/asm/arch-octeontx/csrs/csrs-mio_emm.h
@@ -1,21 +1,19 @@
-#ifndef __CAVM_CSRS_MIO_EMM_H__
-#define __CAVM_CSRS_MIO_EMM_H__
-/* This file is auto-generated. Do not edit */
-
-/*
- * Copyright (C) 2018 Marvell International Ltd.
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
+#ifndef __CSRS_MIO_EMM_H__
+#define __CSRS_MIO_EMM_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium MIO_EMM.
+ * MIO_EMM.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
@@ -25,47 +23,47 @@
  * eMMC Base Address Register Enumeration Enumerates the base address
  * registers.
  */
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
-#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
 
 /**
  * Enumeration mio_emm_int_vec_e
  *
  * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
  */
-#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
-#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
-#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
-#define CAVM_MIO_EMM_INT_VEC_E_NCB_FLT (9)
-#define CAVM_MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
 
 /**
  * Register (RSL) mio_emm_access_wdog
  *
  * eMMC Access Watchdog Register
  */
-union cavm_mio_emm_access_wdog {
+union mio_emm_access_wdog {
 	u64 u;
-	struct cavm_mio_emm_access_wdog_s {
+	struct mio_emm_access_wdog_s {
 		u64 clk_cnt                          : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_mio_emm_access_wdog_s cn; */
+	/* struct mio_emm_access_wdog_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
 {
 	return 0x20f0;
 }
@@ -75,17 +73,17 @@ static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
  *
  * eMMC Data Buffer Access Register
  */
-union cavm_mio_emm_buf_dat {
+union mio_emm_buf_dat {
 	u64 u;
-	struct cavm_mio_emm_buf_dat_s {
+	struct mio_emm_buf_dat_s {
 		u64 dat                              : 64;
 	} s;
-	/* struct cavm_mio_emm_buf_dat_s cn; */
+	/* struct mio_emm_buf_dat_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+static inline u64 MIO_EMM_BUF_DAT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+static inline u64 MIO_EMM_BUF_DAT(void)
 {
 	return 0x20e8;
 }
@@ -95,21 +93,21 @@ static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
  *
  * eMMC Data Buffer Address Register
  */
-union cavm_mio_emm_buf_idx {
+union mio_emm_buf_idx {
 	u64 u;
-	struct cavm_mio_emm_buf_idx_s {
+	struct mio_emm_buf_idx_s {
 		u64 offset                           : 6;
 		u64 buf_num                          : 1;
 		u64 reserved_7_15                    : 9;
 		u64 inc                              : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_mio_emm_buf_idx_s cn; */
+	/* struct mio_emm_buf_idx_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+static inline u64 MIO_EMM_BUF_IDX(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+static inline u64 MIO_EMM_BUF_IDX(void)
 {
 	return 0x20e0;
 }
@@ -120,18 +118,18 @@ static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
  * eMMC Calbration Register This register initiates delay line
  * characterization.
  */
-union cavm_mio_emm_calb {
+union mio_emm_calb {
 	u64 u;
-	struct cavm_mio_emm_calb_s {
+	struct mio_emm_calb_s {
 		u64 start                            : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_mio_emm_calb_s cn; */
+	/* struct mio_emm_calb_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_CALB(void)
+static inline u64 MIO_EMM_CALB(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_CALB(void)
+static inline u64 MIO_EMM_CALB(void)
 {
 	return 0x20c0;
 }
@@ -141,18 +139,18 @@ static inline u64 CAVM_MIO_EMM_CALB(void)
  *
  * eMMC Configuration Register
  */
-union cavm_mio_emm_cfg {
+union mio_emm_cfg {
 	u64 u;
-	struct cavm_mio_emm_cfg_s {
+	struct mio_emm_cfg_s {
 		u64 bus_ena                          : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_mio_emm_cfg_s cn; */
+	/* struct mio_emm_cfg_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_CFG(void)
+static inline u64 MIO_EMM_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_CFG(void)
+static inline u64 MIO_EMM_CFG(void)
 {
 	return 0x2000;
 }
@@ -162,9 +160,9 @@ static inline u64 CAVM_MIO_EMM_CFG(void)
  *
  * eMMC Command Register
  */
-union cavm_mio_emm_cmd {
+union mio_emm_cmd {
 	u64 u;
-	struct cavm_mio_emm_cmd_s {
+	struct mio_emm_cmd_s {
 		u64 arg                              : 32;
 		u64 cmd_idx                          : 6;
 		u64 rtype_xor                        : 3;
@@ -178,12 +176,12 @@ union cavm_mio_emm_cmd {
 		u64 skip_busy                        : 1;
 		u64 reserved_63                      : 1;
 	} s;
-	/* struct cavm_mio_emm_cmd_s cn; */
+	/* struct mio_emm_cmd_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_CMD(void)
+static inline u64 MIO_EMM_CMD(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_CMD(void)
+static inline u64 MIO_EMM_CMD(void)
 {
 	return 0x2058;
 }
@@ -193,20 +191,20 @@ static inline u64 CAVM_MIO_EMM_CMD(void)
  *
  * eMMC Compensation Register
  */
-union cavm_mio_emm_comp {
+union mio_emm_comp {
 	u64 u;
-	struct cavm_mio_emm_comp_s {
+	struct mio_emm_comp_s {
 		u64 nctl                             : 3;
 		u64 reserved_3_7                     : 5;
 		u64 pctl                             : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_mio_emm_comp_s cn; */
+	/* struct mio_emm_comp_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_COMP(void)
+static inline u64 MIO_EMM_COMP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_COMP(void)
+static inline u64 MIO_EMM_COMP(void)
 {
 	return 0x2040;
 }
@@ -216,22 +214,35 @@ static inline u64 CAVM_MIO_EMM_COMP(void)
  *
  * eMMC Debug Register
  */
-union cavm_mio_emm_debug {
+union mio_emm_debug {
 	u64 u;
-	struct cavm_mio_emm_debug_s {
+	struct mio_emm_debug_s {
 		u64 clk_on                           : 1;
 		u64 reserved_1_7                     : 7;
 		u64 cmd_sm                           : 4;
 		u64 data_sm                          : 4;
 		u64 dma_sm                           : 4;
-		u64 reserved_20_63                   : 44;
+		u64 emmc_clk_disable                 : 1;
+		u64 rdsync_rst                       : 1;
+		u64 reserved_22_63                   : 42;
 	} s;
-	/* struct cavm_mio_emm_debug_s cn; */
+	struct mio_emm_debug_cn96xxp1 {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} cn96xxp1;
+	/* struct mio_emm_debug_s cn96xxp3; */
+	/* struct mio_emm_debug_s cn98xx; */
+	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
+	/* struct mio_emm_debug_s loki; */
 };
 
-static inline u64 CAVM_MIO_EMM_DEBUG(void)
+static inline u64 MIO_EMM_DEBUG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DEBUG(void)
+static inline u64 MIO_EMM_DEBUG(void)
 {
 	return 0x20f8;
 }
@@ -241,9 +252,9 @@ static inline u64 CAVM_MIO_EMM_DEBUG(void)
  *
  * eMMC External DMA Configuration Register
  */
-union cavm_mio_emm_dma {
+union mio_emm_dma {
 	u64 u;
-	struct cavm_mio_emm_dma_s {
+	struct mio_emm_dma_s {
 		u64 card_addr                        : 32;
 		u64 block_cnt                        : 16;
 		u64 multi                            : 1;
@@ -257,7 +268,7 @@ union cavm_mio_emm_dma {
 		u64 skip_busy                        : 1;
 		u64 extra_args                       : 1;
 	} s;
-	struct cavm_mio_emm_dma_cn8 {
+	struct mio_emm_dma_cn8 {
 		u64 card_addr                        : 32;
 		u64 block_cnt                        : 16;
 		u64 multi                            : 1;
@@ -271,7 +282,7 @@ union cavm_mio_emm_dma {
 		u64 skip_busy                        : 1;
 		u64 reserved_63                      : 1;
 	} cn8;
-	struct cavm_mio_emm_dma_cn9 {
+	struct mio_emm_dma_cn9 {
 		u64 card_addr                        : 32;
 		u64 block_cnt                        : 16;
 		u64 multi                            : 1;
@@ -287,9 +298,9 @@ union cavm_mio_emm_dma {
 	} cn9;
 };
 
-static inline u64 CAVM_MIO_EMM_DMA(void)
+static inline u64 MIO_EMM_DMA(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA(void)
+static inline u64 MIO_EMM_DMA(void)
 {
 	return 0x2050;
 }
@@ -302,22 +313,22 @@ static inline u64 CAVM_MIO_EMM_DMA(void)
  * to access this register. This register is updated by the DMA hardware
  * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
  */
-union cavm_mio_emm_dma_adr {
+union mio_emm_dma_adr {
 	u64 u;
-	struct cavm_mio_emm_dma_adr_s {
+	struct mio_emm_dma_adr_s {
 		u64 adr                              : 53;
 		u64 reserved_53_63                   : 11;
 	} s;
-	struct cavm_mio_emm_dma_adr_cn8 {
+	struct mio_emm_dma_adr_cn8 {
 		u64 adr                              : 49;
 		u64 reserved_49_63                   : 15;
 	} cn8;
-	/* struct cavm_mio_emm_dma_adr_s cn9; */
+	/* struct mio_emm_dma_adr_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+static inline u64 MIO_EMM_DMA_ADR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+static inline u64 MIO_EMM_DMA_ADR(void)
 {
 	return 0x188;
 }
@@ -327,9 +338,9 @@ static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
  *
  * eMMC External DMA Extra Arguments Register
  */
-union cavm_mio_emm_dma_arg {
+union mio_emm_dma_arg {
 	u64 u;
-	struct cavm_mio_emm_dma_arg_s {
+	struct mio_emm_dma_arg_s {
 		u64 cmd23_args                       : 8;
 		u64 force_pgm                        : 1;
 		u64 context_id                       : 4;
@@ -341,12 +352,12 @@ union cavm_mio_emm_dma_arg {
 		u64 reserved_23_31                   : 9;
 		u64 alt_cmd_arg                      : 32;
 	} s;
-	/* struct cavm_mio_emm_dma_arg_s cn; */
+	/* struct mio_emm_dma_arg_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+static inline u64 MIO_EMM_DMA_ARG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+static inline u64 MIO_EMM_DMA_ARG(void)
 {
 	return 0x2090;
 }
@@ -360,9 +371,9 @@ static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
  * updated by the hardware DMA engine and can also be reloaded by writes
  * to the MIO_EMM_DMA_FIFO_CMD register.
  */
-union cavm_mio_emm_dma_cfg {
+union mio_emm_dma_cfg {
 	u64 u;
-	struct cavm_mio_emm_dma_cfg_s {
+	struct mio_emm_dma_cfg_s {
 		u64 reserved_0_35                    : 36;
 		u64 size                             : 20;
 		u64 endian                           : 1;
@@ -374,12 +385,12 @@ union cavm_mio_emm_dma_cfg {
 		u64 rw                               : 1;
 		u64 en                               : 1;
 	} s;
-	/* struct cavm_mio_emm_dma_cfg_s cn; */
+	/* struct mio_emm_dma_cfg_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+static inline u64 MIO_EMM_DMA_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+static inline u64 MIO_EMM_DMA_CFG(void)
 {
 	return 0x180;
 }
@@ -392,24 +403,24 @@ static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
  * FIFO is used to queue up operations for the
  * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
  */
-union cavm_mio_emm_dma_fifo_adr {
+union mio_emm_dma_fifo_adr {
 	u64 u;
-	struct cavm_mio_emm_dma_fifo_adr_s {
+	struct mio_emm_dma_fifo_adr_s {
 		u64 reserved_0_2                     : 3;
 		u64 adr                              : 50;
 		u64 reserved_53_63                   : 11;
 	} s;
-	struct cavm_mio_emm_dma_fifo_adr_cn8 {
+	struct mio_emm_dma_fifo_adr_cn8 {
 		u64 reserved_0_2                     : 3;
 		u64 adr                              : 46;
 		u64 reserved_49_63                   : 15;
 	} cn8;
-	/* struct cavm_mio_emm_dma_fifo_adr_s cn9; */
+	/* struct mio_emm_dma_fifo_adr_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
 {
 	return 0x170;
 }
@@ -420,9 +431,9 @@ static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
  * eMMC Internal DMA FIFO Configuration Register This register controls
  * DMA FIFO operations.
  */
-union cavm_mio_emm_dma_fifo_cfg {
+union mio_emm_dma_fifo_cfg {
 	u64 u;
-	struct cavm_mio_emm_dma_fifo_cfg_s {
+	struct mio_emm_dma_fifo_cfg_s {
 		u64 count                            : 5;
 		u64 reserved_5_7                     : 3;
 		u64 int_lvl                          : 5;
@@ -430,12 +441,12 @@ union cavm_mio_emm_dma_fifo_cfg {
 		u64 clr                              : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_mio_emm_dma_fifo_cfg_s cn; */
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
 {
 	return 0x160;
 }
@@ -453,9 +464,9 @@ static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
  * exception that the EN and CLR fields are absent. These are supported
  * in MIO_EMM_DMA_FIFO_CFG.
  */
-union cavm_mio_emm_dma_fifo_cmd {
+union mio_emm_dma_fifo_cmd {
 	u64 u;
-	struct cavm_mio_emm_dma_fifo_cmd_s {
+	struct mio_emm_dma_fifo_cmd_s {
 		u64 reserved_0_35                    : 36;
 		u64 size                             : 20;
 		u64 endian                           : 1;
@@ -467,27 +478,12 @@ union cavm_mio_emm_dma_fifo_cmd {
 		u64 rw                               : 1;
 		u64 reserved_63                      : 1;
 	} s;
-	/* struct cavm_mio_emm_dma_fifo_cmd_s cn81xx; */
-	/* struct cavm_mio_emm_dma_fifo_cmd_s cn83xx; */
-	struct cavm_mio_emm_dma_fifo_cmd_cn88xxp1 {
-		u64 reserved_0_35                    : 36;
-		u64 size                             : 20;
-		u64 endian                           : 1;
-		u64 swap8                            : 1;
-		u64 swap16                           : 1;
-		u64 swap32                           : 1;
-		u64 reserved_60                      : 1;
-		u64 reserved_61                      : 1;
-		u64 rw                               : 1;
-		u64 reserved_63                      : 1;
-	} cn88xxp1;
-	/* struct cavm_mio_emm_dma_fifo_cmd_s cn88xxp2; */
-	/* struct cavm_mio_emm_dma_fifo_cmd_s cn9; */
+	/* struct mio_emm_dma_fifo_cmd_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
 {
 	return 0x178;
 }
@@ -498,19 +494,19 @@ static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
  * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
  * access this register.
  */
-union cavm_mio_emm_dma_int {
+union mio_emm_dma_int {
 	u64 u;
-	struct cavm_mio_emm_dma_int_s {
+	struct mio_emm_dma_int_s {
 		u64 done                             : 1;
 		u64 fifo                             : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_mio_emm_dma_int_s cn; */
+	/* struct mio_emm_dma_int_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+static inline u64 MIO_EMM_DMA_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+static inline u64 MIO_EMM_DMA_INT(void)
 {
 	return 0x190;
 }
@@ -521,19 +517,19 @@ static inline u64 CAVM_MIO_EMM_DMA_INT(void)
  * eMMC DMA Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_mio_emm_dma_int_ena_w1c {
+union mio_emm_dma_int_ena_w1c {
 	u64 u;
-	struct cavm_mio_emm_dma_int_ena_w1c_s {
+	struct mio_emm_dma_int_ena_w1c_s {
 		u64 done                             : 1;
 		u64 fifo                             : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_mio_emm_dma_int_ena_w1c_s cn; */
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
 {
 	return 0x1a8;
 }
@@ -544,19 +540,19 @@ static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
  * eMMC DMA Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_mio_emm_dma_int_ena_w1s {
+union mio_emm_dma_int_ena_w1s {
 	u64 u;
-	struct cavm_mio_emm_dma_int_ena_w1s_s {
+	struct mio_emm_dma_int_ena_w1s_s {
 		u64 done                             : 1;
 		u64 fifo                             : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_mio_emm_dma_int_ena_w1s_s cn; */
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
 {
 	return 0x1a0;
 }
@@ -566,19 +562,19 @@ static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
  *
  * eMMC DMA Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_mio_emm_dma_int_w1s {
+union mio_emm_dma_int_w1s {
 	u64 u;
-	struct cavm_mio_emm_dma_int_w1s_s {
+	struct mio_emm_dma_int_w1s_s {
 		u64 done                             : 1;
 		u64 fifo                             : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_mio_emm_dma_int_w1s_s cn; */
+	/* struct mio_emm_dma_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
 {
 	return 0x198;
 }
@@ -588,9 +584,9 @@ static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
  *
  * eMMC Interrupt Register
  */
-union cavm_mio_emm_int {
+union mio_emm_int {
 	u64 u;
-	struct cavm_mio_emm_int_s {
+	struct mio_emm_int_s {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -602,7 +598,7 @@ union cavm_mio_emm_int {
 		u64 ncb_ras                          : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	struct cavm_mio_emm_int_cn8 {
+	struct mio_emm_int_cn8 {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -612,12 +608,12 @@ union cavm_mio_emm_int {
 		u64 switch_err                       : 1;
 		u64 reserved_7_63                    : 57;
 	} cn8;
-	/* struct cavm_mio_emm_int_s cn9; */
+	/* struct mio_emm_int_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_INT(void)
+static inline u64 MIO_EMM_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_INT(void)
+static inline u64 MIO_EMM_INT(void)
 {
 	return 0x2078;
 }
@@ -628,9 +624,9 @@ static inline u64 CAVM_MIO_EMM_INT(void)
  * eMMC Interrupt Enable Clear Register This register clears interrupt
  * enable bits.
  */
-union cavm_mio_emm_int_ena_w1c {
+union mio_emm_int_ena_w1c {
 	u64 u;
-	struct cavm_mio_emm_int_ena_w1c_s {
+	struct mio_emm_int_ena_w1c_s {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -642,7 +638,7 @@ union cavm_mio_emm_int_ena_w1c {
 		u64 ncb_ras                          : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	struct cavm_mio_emm_int_ena_w1c_cn8 {
+	struct mio_emm_int_ena_w1c_cn8 {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -652,12 +648,12 @@ union cavm_mio_emm_int_ena_w1c {
 		u64 switch_err                       : 1;
 		u64 reserved_7_63                    : 57;
 	} cn8;
-	/* struct cavm_mio_emm_int_ena_w1c_s cn9; */
+	/* struct mio_emm_int_ena_w1c_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
 {
 	return 0x20b8;
 }
@@ -668,9 +664,9 @@ static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
  * eMMC Interrupt Enable Set Register This register sets interrupt enable
  * bits.
  */
-union cavm_mio_emm_int_ena_w1s {
+union mio_emm_int_ena_w1s {
 	u64 u;
-	struct cavm_mio_emm_int_ena_w1s_s {
+	struct mio_emm_int_ena_w1s_s {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -682,7 +678,7 @@ union cavm_mio_emm_int_ena_w1s {
 		u64 ncb_ras                          : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	struct cavm_mio_emm_int_ena_w1s_cn8 {
+	struct mio_emm_int_ena_w1s_cn8 {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -692,12 +688,12 @@ union cavm_mio_emm_int_ena_w1s {
 		u64 switch_err                       : 1;
 		u64 reserved_7_63                    : 57;
 	} cn8;
-	/* struct cavm_mio_emm_int_ena_w1s_s cn9; */
+	/* struct mio_emm_int_ena_w1s_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
 {
 	return 0x20b0;
 }
@@ -707,9 +703,9 @@ static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
  *
  * eMMC Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_mio_emm_int_w1s {
+union mio_emm_int_w1s {
 	u64 u;
-	struct cavm_mio_emm_int_w1s_s {
+	struct mio_emm_int_w1s_s {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -721,7 +717,7 @@ union cavm_mio_emm_int_w1s {
 		u64 ncb_ras                          : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	struct cavm_mio_emm_int_w1s_cn8 {
+	struct mio_emm_int_w1s_cn8 {
 		u64 buf_done                         : 1;
 		u64 cmd_done                         : 1;
 		u64 dma_done                         : 1;
@@ -731,12 +727,12 @@ union cavm_mio_emm_int_w1s {
 		u64 switch_err                       : 1;
 		u64 reserved_7_63                    : 57;
 	} cn8;
-	/* struct cavm_mio_emm_int_w1s_s cn9; */
+	/* struct mio_emm_int_w1s_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+static inline u64 MIO_EMM_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+static inline u64 MIO_EMM_INT_W1S(void)
 {
 	return 0x2080;
 }
@@ -746,20 +742,20 @@ static inline u64 CAVM_MIO_EMM_INT_W1S(void)
  *
  * eMMC I/O Control Register
  */
-union cavm_mio_emm_io_ctl {
+union mio_emm_io_ctl {
 	u64 u;
-	struct cavm_mio_emm_io_ctl_s {
+	struct mio_emm_io_ctl_s {
 		u64 slew                             : 1;
 		u64 reserved_1                       : 1;
 		u64 drive                            : 2;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_mio_emm_io_ctl_s cn; */
+	/* struct mio_emm_io_ctl_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+static inline u64 MIO_EMM_IO_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+static inline u64 MIO_EMM_IO_CTL(void)
 {
 	return 0x2040;
 }
@@ -769,13 +765,14 @@ static inline u64 CAVM_MIO_EMM_IO_CTL(void)
  *
  * eMMC Operating Mode Register
  */
-union cavm_mio_emm_modex {
+union mio_emm_modex {
 	u64 u;
-	struct cavm_mio_emm_modex_s {
+	struct mio_emm_modex_s {
 		u64 clk_lo                           : 16;
 		u64 clk_hi                           : 16;
 		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
 		u64 bus_width                        : 3;
 		u64 reserved_43_47                   : 5;
 		u64 hs_timing                        : 1;
@@ -783,7 +780,7 @@ union cavm_mio_emm_modex {
 		u64 hs400_timing                     : 1;
 		u64 reserved_51_63                   : 13;
 	} s;
-	struct cavm_mio_emm_modex_cn8 {
+	struct mio_emm_modex_cn8 {
 		u64 clk_lo                           : 16;
 		u64 clk_hi                           : 16;
 		u64 power_class                      : 4;
@@ -793,12 +790,27 @@ union cavm_mio_emm_modex {
 		u64 hs_timing                        : 1;
 		u64 reserved_49_63                   : 15;
 	} cn8;
-	/* struct cavm_mio_emm_modex_s cn9; */
+	struct mio_emm_modex_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} cn96xxp1;
+	/* struct mio_emm_modex_s cn96xxp3; */
+	/* struct mio_emm_modex_s cn98xx; */
+	/* struct mio_emm_modex_s cnf95xx; */
+	/* struct mio_emm_modex_s loki; */
 };
 
-static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+static inline u64 MIO_EMM_MODEX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+static inline u64 MIO_EMM_MODEX(u64 a)
 {
 	return 0x2008 + 8 * a;
 }
@@ -809,17 +821,17 @@ static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
  * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
  * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
  */
-union cavm_mio_emm_msix_pbax {
+union mio_emm_msix_pbax {
 	u64 u;
-	struct cavm_mio_emm_msix_pbax_s {
+	struct mio_emm_msix_pbax_s {
 		u64 pend                             : 64;
 	} s;
-	/* struct cavm_mio_emm_msix_pbax_s cn; */
+	/* struct mio_emm_msix_pbax_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
 {
 	return 0xf0000 + 8 * a;
 }
@@ -830,26 +842,26 @@ static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
  * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
  * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
  */
-union cavm_mio_emm_msix_vecx_addr {
+union mio_emm_msix_vecx_addr {
 	u64 u;
-	struct cavm_mio_emm_msix_vecx_addr_s {
+	struct mio_emm_msix_vecx_addr_s {
 		u64 secvec                           : 1;
 		u64 reserved_1                       : 1;
 		u64 addr                             : 51;
 		u64 reserved_53_63                   : 11;
 	} s;
-	struct cavm_mio_emm_msix_vecx_addr_cn8 {
+	struct mio_emm_msix_vecx_addr_cn8 {
 		u64 secvec                           : 1;
 		u64 reserved_1                       : 1;
 		u64 addr                             : 47;
 		u64 reserved_49_63                   : 15;
 	} cn8;
-	/* struct cavm_mio_emm_msix_vecx_addr_s cn9; */
+	/* struct mio_emm_msix_vecx_addr_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
 {
 	return 0 + 0x10 * a;
 }
@@ -860,25 +872,25 @@ static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
  * eMMC MSI-X Vector-Table Control and Data Register This register is the
  * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
  */
-union cavm_mio_emm_msix_vecx_ctl {
+union mio_emm_msix_vecx_ctl {
 	u64 u;
-	struct cavm_mio_emm_msix_vecx_ctl_s {
+	struct mio_emm_msix_vecx_ctl_s {
 		u64 data                             : 32;
 		u64 mask                             : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	struct cavm_mio_emm_msix_vecx_ctl_cn8 {
+	struct mio_emm_msix_vecx_ctl_cn8 {
 		u64 data                             : 20;
 		u64 reserved_20_31                   : 12;
 		u64 mask                             : 1;
 		u64 reserved_33_63                   : 31;
 	} cn8;
-	/* struct cavm_mio_emm_msix_vecx_ctl_s cn9; */
+	/* struct mio_emm_msix_vecx_ctl_s cn9; */
 };
 
-static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
 {
 	return 8 + 0x10 * a;
 }
@@ -888,18 +900,18 @@ static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
  *
  * eMMC Relative Card Address Register
  */
-union cavm_mio_emm_rca {
+union mio_emm_rca {
 	u64 u;
-	struct cavm_mio_emm_rca_s {
+	struct mio_emm_rca_s {
 		u64 card_rca                         : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_mio_emm_rca_s cn; */
+	/* struct mio_emm_rca_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_RCA(void)
+static inline u64 MIO_EMM_RCA(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_RCA(void)
+static inline u64 MIO_EMM_RCA(void)
 {
 	return 0x20a0;
 }
@@ -909,17 +921,17 @@ static inline u64 CAVM_MIO_EMM_RCA(void)
  *
  * eMMC Response Data High Register
  */
-union cavm_mio_emm_rsp_hi {
+union mio_emm_rsp_hi {
 	u64 u;
-	struct cavm_mio_emm_rsp_hi_s {
+	struct mio_emm_rsp_hi_s {
 		u64 dat                              : 64;
 	} s;
-	/* struct cavm_mio_emm_rsp_hi_s cn; */
+	/* struct mio_emm_rsp_hi_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+static inline u64 MIO_EMM_RSP_HI(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+static inline u64 MIO_EMM_RSP_HI(void)
 {
 	return 0x2070;
 }
@@ -929,17 +941,17 @@ static inline u64 CAVM_MIO_EMM_RSP_HI(void)
  *
  * eMMC Response Data Low Register
  */
-union cavm_mio_emm_rsp_lo {
+union mio_emm_rsp_lo {
 	u64 u;
-	struct cavm_mio_emm_rsp_lo_s {
+	struct mio_emm_rsp_lo_s {
 		u64 dat                              : 64;
 	} s;
-	/* struct cavm_mio_emm_rsp_lo_s cn; */
+	/* struct mio_emm_rsp_lo_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+static inline u64 MIO_EMM_RSP_LO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+static inline u64 MIO_EMM_RSP_LO(void)
 {
 	return 0x2068;
 }
@@ -949,9 +961,9 @@ static inline u64 CAVM_MIO_EMM_RSP_LO(void)
  *
  * eMMC Response Status Register
  */
-union cavm_mio_emm_rsp_sts {
+union mio_emm_rsp_sts {
 	u64 u;
-	struct cavm_mio_emm_rsp_sts_s {
+	struct mio_emm_rsp_sts_s {
 		u64 cmd_done                         : 1;
 		u64 cmd_idx                          : 6;
 		u64 cmd_type                         : 2;
@@ -979,12 +991,12 @@ union cavm_mio_emm_rsp_sts {
 		u64 bus_id                           : 2;
 		u64 reserved_62_63                   : 2;
 	} s;
-	/* struct cavm_mio_emm_rsp_sts_s cn; */
+	/* struct mio_emm_rsp_sts_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+static inline u64 MIO_EMM_RSP_STS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+static inline u64 MIO_EMM_RSP_STS(void)
 {
 	return 0x2060;
 }
@@ -994,20 +1006,20 @@ static inline u64 CAVM_MIO_EMM_RSP_STS(void)
  *
  * eMMC Sampling Register
  */
-union cavm_mio_emm_sample {
+union mio_emm_sample {
 	u64 u;
-	struct cavm_mio_emm_sample_s {
+	struct mio_emm_sample_s {
 		u64 dat_cnt                          : 10;
 		u64 reserved_10_15                   : 6;
 		u64 cmd_cnt                          : 10;
 		u64 reserved_26_63                   : 38;
 	} s;
-	/* struct cavm_mio_emm_sample_s cn; */
+	/* struct mio_emm_sample_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+static inline u64 MIO_EMM_SAMPLE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+static inline u64 MIO_EMM_SAMPLE(void)
 {
 	return 0x2090;
 }
@@ -1017,18 +1029,18 @@ static inline u64 CAVM_MIO_EMM_SAMPLE(void)
  *
  * eMMC Status Mask Register
  */
-union cavm_mio_emm_sts_mask {
+union mio_emm_sts_mask {
 	u64 u;
-	struct cavm_mio_emm_sts_mask_s {
+	struct mio_emm_sts_mask_s {
 		u64 sts_msk                          : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_mio_emm_sts_mask_s cn; */
+	/* struct mio_emm_sts_mask_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+static inline u64 MIO_EMM_STS_MASK(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+static inline u64 MIO_EMM_STS_MASK(void)
 {
 	return 0x2098;
 }
@@ -1043,13 +1055,14 @@ static inline u64 CAVM_MIO_EMM_STS_MASK(void)
  * settings associated with the common EMMC_CLK.  These settings can only
  * be changed when [BUS_ID] = 0.
  */
-union cavm_mio_emm_switch {
+union mio_emm_switch {
 	u64 u;
-	struct cavm_mio_emm_switch_s {
+	struct mio_emm_switch_s {
 		u64 clk_lo                           : 16;
 		u64 clk_hi                           : 16;
 		u64 power_class                      : 4;
-		u64 reserved_36_39                   : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
 		u64 bus_width                        : 3;
 		u64 reserved_43_47                   : 5;
 		u64 hs_timing                        : 1;
@@ -1063,7 +1076,7 @@ union cavm_mio_emm_switch {
 		u64 bus_id                           : 2;
 		u64 reserved_62_63                   : 2;
 	} s;
-	struct cavm_mio_emm_switch_cn8 {
+	struct mio_emm_switch_cn8 {
 		u64 clk_lo                           : 16;
 		u64 clk_hi                           : 16;
 		u64 power_class                      : 4;
@@ -1079,12 +1092,33 @@ union cavm_mio_emm_switch {
 		u64 bus_id                           : 2;
 		u64 reserved_62_63                   : 2;
 	} cn8;
-	/* struct cavm_mio_emm_switch_s cn9; */
+	struct mio_emm_switch_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn96xxp1;
+	/* struct mio_emm_switch_s cn96xxp3; */
+	/* struct mio_emm_switch_s cn98xx; */
+	/* struct mio_emm_switch_s cnf95xx; */
+	/* struct mio_emm_switch_s loki; */
 };
 
-static inline u64 CAVM_MIO_EMM_SWITCH(void)
+static inline u64 MIO_EMM_SWITCH(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_SWITCH(void)
+static inline u64 MIO_EMM_SWITCH(void)
 {
 	return 0x2048;
 }
@@ -1095,18 +1129,18 @@ static inline u64 CAVM_MIO_EMM_SWITCH(void)
  * eMMC TAP Delay Register This register indicates the delay line
  * characteristics.
  */
-union cavm_mio_emm_tap {
+union mio_emm_tap {
 	u64 u;
-	struct cavm_mio_emm_tap_s {
+	struct mio_emm_tap_s {
 		u64 delay                            : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_mio_emm_tap_s cn; */
+	/* struct mio_emm_tap_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_TAP(void)
+static inline u64 MIO_EMM_TAP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_TAP(void)
+static inline u64 MIO_EMM_TAP(void)
 {
 	return 0x20c8;
 }
@@ -1119,9 +1153,9 @@ static inline u64 CAVM_MIO_EMM_TAP(void)
  * relation to EMM_CLK. These values should only be changed when the eMMC
  * bus is idle.
  */
-union cavm_mio_emm_timing {
+union mio_emm_timing {
 	u64 u;
-	struct cavm_mio_emm_timing_s {
+	struct mio_emm_timing_s {
 		u64 data_out_tap                     : 6;
 		u64 reserved_6_15                    : 10;
 		u64 data_in_tap                      : 6;
@@ -1131,12 +1165,12 @@ union cavm_mio_emm_timing {
 		u64 cmd_in_tap                       : 6;
 		u64 reserved_54_63                   : 10;
 	} s;
-	/* struct cavm_mio_emm_timing_s cn; */
+	/* struct mio_emm_timing_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_TIMING(void)
+static inline u64 MIO_EMM_TIMING(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_TIMING(void)
+static inline u64 MIO_EMM_TIMING(void)
 {
 	return 0x20d0;
 }
@@ -1146,20 +1180,20 @@ static inline u64 CAVM_MIO_EMM_TIMING(void)
  *
  * eMMC Watchdog Register
  */
-union cavm_mio_emm_wdog {
+union mio_emm_wdog {
 	u64 u;
-	struct cavm_mio_emm_wdog_s {
+	struct mio_emm_wdog_s {
 		u64 clk_cnt                          : 26;
 		u64 reserved_26_63                   : 38;
 	} s;
-	/* struct cavm_mio_emm_wdog_s cn; */
+	/* struct mio_emm_wdog_s cn; */
 };
 
-static inline u64 CAVM_MIO_EMM_WDOG(void)
+static inline u64 MIO_EMM_WDOG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_MIO_EMM_WDOG(void)
+static inline u64 MIO_EMM_WDOG(void)
 {
 	return 0x2088;
 }
 
-#endif /* __CAVM_CSRS_MIO_EMM_H__ */
+#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h b/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
new file mode 100644
index 0000000000..575f6dce82
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/csrs/csrs-xcv.h
@@ -0,0 +1,428 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_XCV_H__
+#define __CSRS_XCV_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * XCV.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration xcv_bar_e
+ *
+ * XCV Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define XCV_BAR_E_XCVX_PF_BAR0(a) (0x87e0db000000ll + 0ll * (a))
+#define XCV_BAR_E_XCVX_PF_BAR0_SIZE 0x100000ull
+#define XCV_BAR_E_XCVX_PF_BAR4(a) (0x87e0dbf00000ll + 0ll * (a))
+#define XCV_BAR_E_XCVX_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration xcv_int_vec_e
+ *
+ * XCV MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define XCV_INT_VEC_E_INT (0)
+
+/**
+ * Register (RSL) xcv#_batch_crd_ret
+ *
+ * XCV Batch Credit Return Register
+ */
+union xcvx_batch_crd_ret {
+	u64 u;
+	struct xcvx_batch_crd_ret_s {
+		u64 crd_ret                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct xcvx_batch_crd_ret_s cn; */
+};
+
+static inline u64 XCVX_BATCH_CRD_RET(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_BATCH_CRD_RET(u64 a)
+{
+	return 0x100 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_comp_ctl
+ *
+ * XCV Compensation Controller Register This register controls
+ * programmable compensation.
+ */
+union xcvx_comp_ctl {
+	u64 u;
+	struct xcvx_comp_ctl_s {
+		u64 nctl_sat                         : 1;
+		u64 reserved_1_26                    : 26;
+		u64 nctl_lock                        : 1;
+		u64 reserved_28                      : 1;
+		u64 pctl_sat                         : 1;
+		u64 pctl_lock                        : 1;
+		u64 reserved_31                      : 1;
+		u64 drv_nctl                         : 5;
+		u64 reserved_37_39                   : 3;
+		u64 drv_pctl                         : 5;
+		u64 reserved_45_47                   : 3;
+		u64 cmp_nctl                         : 5;
+		u64 reserved_53_55                   : 3;
+		u64 cmp_pctl                         : 5;
+		u64 reserved_61_62                   : 2;
+		u64 drv_byp                          : 1;
+	} s;
+	/* struct xcvx_comp_ctl_s cn; */
+};
+
+static inline u64 XCVX_COMP_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_COMP_CTL(u64 a)
+{
+	return 0x20 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_ctl
+ *
+ * XCV Control Register This register contains the status control bits.
+ */
+union xcvx_ctl {
+	u64 u;
+	struct xcvx_ctl_s {
+		u64 speed                            : 2;
+		u64 lpbk_int                         : 1;
+		u64 lpbk_ext                         : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct xcvx_ctl_s cn; */
+};
+
+static inline u64 XCVX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_CTL(u64 a)
+{
+	return 0x30 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_dll_ctl
+ *
+ * XCV DLL Controller Register The RGMII timing specification requires
+ * that devices transmit clock and data synchronously. The specification
+ * requires external sources (namely the PC board trace routes) to
+ * introduce the appropriate 1.5 to 2.0 ns of delay.  To eliminate the
+ * need for the PC board delays, the RGMII interface has optional on-
+ * board DLLs for both transmit and receive. For correct operation, at
+ * most one of the transmitter, board, or receiver involved in an RGMII
+ * link should introduce delay. By default/reset, the RGMII receivers
+ * delay the received clock, and the RGMII transmitters do not delay the
+ * transmitted clock. Whether this default works as-is with a given link
+ * partner depends on the behavior of the link partner and the PC board.
+ * These are the possible modes of RGMII receive operation:  *
+ * XCV()_DLL_CTL[CLKRX_BYP] = 0 (reset value) - The RGMII receive
+ * interface introduces clock delay using its internal DLL. This mode is
+ * appropriate if neither the remote transmitter nor the PC board delays
+ * the clock.  * XCV()_DLL_CTL[CLKRX_BYP] = 1, [CLKRX_SET] = 0x0 - The
+ * RGMII receive interface introduces no clock delay. This mode is
+ * appropriate if either the remote transmitter or the PC board delays
+ * the clock.  These are the possible modes of RGMII transmit operation:
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 1, [CLKTX_SET] = 0x0 (reset value) - The
+ * RGMII transmit interface introduces no clock delay. This mode is
+ * appropriate is either the remote receiver or the PC board delays the
+ * clock.  * XCV()_DLL_CTL[CLKTX_BYP] = 0 - The RGMII transmit interface
+ * introduces clock delay using its internal DLL. This mode is
+ * appropriate if neither the remote receiver nor the PC board delays the
+ * clock.
+ */
+union xcvx_dll_ctl {
+	u64 u;
+	struct xcvx_dll_ctl_s {
+		u64 refclk_sel                       : 2;
+		u64 reserved_2_7                     : 6;
+		u64 clktx_set                        : 7;
+		u64 clktx_byp                        : 1;
+		u64 clkrx_set                        : 7;
+		u64 clkrx_byp                        : 1;
+		u64 clk_set                          : 7;
+		u64 lock                             : 1;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct xcvx_dll_ctl_s cn; */
+};
+
+static inline u64 XCVX_DLL_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_DLL_CTL(u64 a)
+{
+	return 0x10 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_eco
+ *
+ * INTERNAL: XCV ECO Register
+ */
+union xcvx_eco {
+	u64 u;
+	struct xcvx_eco_s {
+		u64 eco_rw                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct xcvx_eco_s cn; */
+};
+
+static inline u64 XCVX_ECO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_ECO(u64 a)
+{
+	return 0x200 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_inbnd_status
+ *
+ * XCV Inband Status Register This register contains RGMII inband status.
+ */
+union xcvx_inbnd_status {
+	u64 u;
+	struct xcvx_inbnd_status_s {
+		u64 link                             : 1;
+		u64 speed                            : 2;
+		u64 duplex                           : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct xcvx_inbnd_status_s cn; */
+};
+
+static inline u64 XCVX_INBND_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INBND_STATUS(u64 a)
+{
+	return 0x80 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int
+ *
+ * XCV Interrupt Register This register flags error for TX FIFO overflow,
+ * TX FIFO underflow and incomplete byte for 10/100 Mode. It also flags
+ * status change for link duplex, link speed and link up/down.
+ */
+union xcvx_int {
+	u64 u;
+	struct xcvx_int_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_s cn; */
+};
+
+static inline u64 XCVX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT(u64 a)
+{
+	return 0x40 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_ena_w1c
+ *
+ * Loopback Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union xcvx_int_ena_w1c {
+	u64 u;
+	struct xcvx_int_ena_w1c_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_ena_w1c_s cn; */
+};
+
+static inline u64 XCVX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_ENA_W1C(u64 a)
+{
+	return 0x50 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_ena_w1s
+ *
+ * Loopback Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union xcvx_int_ena_w1s {
+	u64 u;
+	struct xcvx_int_ena_w1s_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_ena_w1s_s cn; */
+};
+
+static inline u64 XCVX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_ENA_W1S(u64 a)
+{
+	return 0x58 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_int_w1s
+ *
+ * Loopback Error Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union xcvx_int_w1s {
+	u64 u;
+	struct xcvx_int_w1s_s {
+		u64 link                             : 1;
+		u64 speed                            : 1;
+		u64 reserved_2                       : 1;
+		u64 duplex                           : 1;
+		u64 incomp_byte                      : 1;
+		u64 tx_undflw                        : 1;
+		u64 tx_ovrflw                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct xcvx_int_w1s_s cn; */
+};
+
+static inline u64 XCVX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_INT_W1S(u64 a)
+{
+	return 0x48 + 0 * a;
+}
+
+/**
+ * Register (RSL) xcv#_msix_pba#
+ *
+ * XCV MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_pbax {
+	u64 u;
+	struct xcvx_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct xcvx_msix_pbax_s cn; */
+};
+
+static inline u64 XCVX_MSIX_PBAX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_PBAX(u64 a, u64 b)
+{
+	return 0xf0000 + 0 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) xcv#_msix_vec#_addr
+ *
+ * XCV MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_vecx_addr {
+	u64 u;
+	struct xcvx_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} s;
+	/* struct xcvx_msix_vecx_addr_s cn; */
+};
+
+static inline u64 XCVX_MSIX_VECX_ADDR(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_VECX_ADDR(u64 a, u64 b)
+{
+	return 0 + 0 * a + 0x10 * b;
+}
+
+/**
+ * Register (RSL) xcv#_msix_vec#_ctl
+ *
+ * XCV MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the XCV_INT_VEC_E enumeration.
+ */
+union xcvx_msix_vecx_ctl {
+	u64 u;
+	struct xcvx_msix_vecx_ctl_s {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct xcvx_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 XCVX_MSIX_VECX_CTL(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_MSIX_VECX_CTL(u64 a, u64 b)
+{
+	return 8 + 0 * a + 0x10 * b;
+}
+
+/**
+ * Register (RSL) xcv#_reset
+ *
+ * XCV Reset Registers This register controls reset.
+ */
+union xcvx_reset {
+	u64 u;
+	struct xcvx_reset_s {
+		u64 rx_dat_rst_n                     : 1;
+		u64 rx_pkt_rst_n                     : 1;
+		u64 tx_dat_rst_n                     : 1;
+		u64 tx_pkt_rst_n                     : 1;
+		u64 reserved_4_6                     : 3;
+		u64 comp                             : 1;
+		u64 reserved_8_10                    : 3;
+		u64 dllrst                           : 1;
+		u64 reserved_12_14                   : 3;
+		u64 clkrst                           : 1;
+		u64 reserved_16_62                   : 47;
+		u64 enable                           : 1;
+	} s;
+	/* struct xcvx_reset_s cn; */
+};
+
+static inline u64 XCVX_RESET(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 XCVX_RESET(u64 a)
+{
+	return 0 + 0 * a;
+}
+
+#endif /* __CSRS_XCV_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/fdt-helper.h b/arch/arm/include/asm/arch-octeontx/fdt-helper.h
deleted file mode 100644
index 55ec06f428..0000000000
--- a/arch/arm/include/asm/arch-octeontx/fdt-helper.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-#ifndef __FDT_HELPER_H__
-#define __FDT_HELPER_H__
-
-/**
- * Given a FDT node, check if it is compatible with a list of devices
- *
- * @param[in]	fdt		Flat device tree pointer
- * @param	node_offset	Node offset in device tree
- * @param[in]	strlist		Array of FDT devices to check, end must be NULL
- *
- * @return	0 if at least one device is compatible, 1 if not compatible.
- */
-int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
-				     const char * const *strlist);
-
-/**
- * Given a FDT node, return the next compatible node.
- *
- * @param[in]	fdt_addr	Pointer to flat device tree
- * @param	start_offset	Starting node offset or -1 to find the first
- * @param	strlist		Array of FDT device compatibility strings, must
- *				end with NULL or empty string.
- *
- * @return	next matching node or -1 if no more matches.
- */
-int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
-					      int startoffset,
-					      const char * const *strlist);
-
-#endif /* __FDT_HELPER_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/gpio.h b/arch/arm/include/asm/arch-octeontx/gpio.h
new file mode 100644
index 0000000000..3943ffd952
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/gpio.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx.h b/arch/arm/include/asm/arch-octeontx/octeontx.h
index 93eaa14e81..7aa08afbb3 100644
--- a/arch/arm/include/asm/arch-octeontx/octeontx.h
+++ b/arch/arm/include/asm/arch-octeontx/octeontx.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -35,6 +35,7 @@ struct cavm_bdt {
 	u8 alt_pkg;
 	char type[16];
 };
+
 extern struct cavm_bdt g_cavm_bdt;
 
 #endif
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h b/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
deleted file mode 100644
index 5c7d567a30..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-#ifndef __OCTEONTX_FDT_H__
-#define __OCTEONTX_FDT_H__
-
-
-#endif
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h b/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
deleted file mode 100644
index 5d434a3418..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-#ifndef __OCTEONTX_MMC_H__
-#define __OCTEONTX_MMC_H__
-
-#include <mmc.h>
-#include <dm/device.h>
-
-/* NOTE: this file is used by both Octeon and OcteonTX */
-
-/*
- * Card Command Classes (CCC)
- */
-#define CCC_BASIC		BIT(0)	/* (0) Basic protocol functions */
-					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
-					/* (and for SPI, CMD58,59) */
-#define CCC_STREAM_READ		BIT(1)	/* (1) Stream read commands */
-					/* (CMD11) */
-#define CCC_BLOCK_READ		BIT(2)	/* (2) Block read commands */
-					/* (CMD16,17,18) */
-#define CCC_STREAM_WRITE	BIT(3)	/* (3) Stream write commands */
-					/* (CMD20) */
-#define CCC_BLOCK_WRITE		BIT(4)	/* (4) Block write commands */
-					/* (CMD16,24,25,26,27) */
-#define CCC_ERASE		BIT(5)	/* (5) Ability to erase blocks */
-					/* (CMD32,33,34,35,36,37,38,39) */
-#define CCC_WRITE_PROT		BIT(6)	/* (6) Able to write protect blocks */
-					/* (CMD28,29,30) */
-#define CCC_LOCK_CARD		BIT(7)	/* (7) Able to lock down card */
-					/* (CMD16,CMD42) */
-#define CCC_APP_SPEC		BIT(8)	/* (8) Application specific */
-					/* (CMD55,56,57,ACMD*) */
-#define CCC_IO_MODE		BIT(9)	/* (9) I/O mode */
-					/* (CMD5,39,40,52,53) */
-#define CCC_SWITCH		BIT(10)	/* (10) High speed switch */
-					/* (CMD6,34,35,36,37,50) */
-					/* (11) Reserved */
-					/* (CMD?) */
-
-/*
- * NOTE: This was copied from the Linux kernel.
- *
- * MMC status in R1, for native mode (SPI bits are different)
- * Type
- *	e:error bit
- *	s:status bit
- *	r:detected and set for the actual command response
- *	x:detected and set during command execution. the host must poll
- *	    the card by sending status command in order to read these bits.
- * Clear condition
- *	a:according to the card state
- *	b:always related to the previous command. Reception of
- *	    a valid command will clear it (with a delay of one command)
- *	c:clear by read
- */
-#define R1_OUT_OF_RANGE		BIT(31)		/* er, c */
-#define R1_ADDRESS_ERROR	BIT(30)		/* erx, c */
-#define R1_BLOCK_LEN_ERROR	BIT(29)		/* er, c */
-#define R1_ERASE_SEQ_ERROR	BIT(28)		/* er, c */
-#define R1_ERASE_PARAM          BIT(27)		/* ex, c */
-#define R1_WP_VIOLATION		BIT(26)		/* erx, c */
-#define R1_CARD_IS_LOCKED	BIT(25)		/* sx, a */
-#define R1_LOCK_UNLOCK_FAILED	BIT(24)		/* erx, c */
-#define R1_COM_CRC_ERROR	BIT(23)		/* er, b */
-/*#define R1_ILLEGAL_COMMAND	BIT(22)*/		/* er, b */
-#define R1_CARD_ECC_FAILED	BIT(21)		/* ex, c */
-#define R1_CC_ERROR		BIT(20)		/* erx, c */
-#define R1_ERROR		BIT(19)		/* erx, c */
-#define R1_UNDERRUN		BIT(18)		/* ex, c */
-#define R1_OVERRUN		BIT(17)		/* ex, c */
-#define R1_CID_CSD_OVERWRITE	BIT(16)		/* erx, c, CID/CSD overwrite */
-#define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
-#define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
-#define R1_ERASE_RESET		BIT(13)		/* sr, c */
-#define R1_STATUS(x)		(x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
-#define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
-#define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
-/*#define R1_APP_CMD		BIT(5)*/		/* sr, c */
-
-#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR
-#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_WP_VIOLATION |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR |		\
-				R1_UNDERRUN |		\
-				R1_OVERRUN
-
-/**
- * Flag indicates that CMD23 is supported.  This is required for multi-block
- * hardware transfers to work.
- */
-#define OCTEON_MMC_FLAG_SD_CMD23	1
-
-#ifdef __mips
-# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
-#endif
-
-/** Maximum supported MMC slots */
-#define OCTEONTX_MAX_MMC_SLOT		3
-
-#define OCTEONTX_MMC_NAME_LEN		32
-
-struct mmc;
-struct mmc_config;
-struct octeontx_mmc_host;
-struct octeontx_mmc_slot;
-struct gpio_desc;
-
-struct octeontx_mmc_slot {
-	char		name[OCTEONTX_MMC_NAME_LEN];	/** Name of device */
-	u8		ext_csd[512];	/** Extended CSD register */
-	struct mmc	*mmc;		/** Ptr back to mmc structure */
-	struct octeontx_mmc_host *host;	/** Host controller data structure */
-#if defined(CONFIG_ARCH_OCTEONTX2)
-	u64		timing_tapps;	/** picoseconds per tap delay */
-#endif
-	struct mmc_config cfg;		/** Slot configuration */
-	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
-	struct gpio_desc cd_gpio;	/** Card detect GPIO */
-	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
-	int		power_delay;	/** Time in usec to wait for power */
-	int		bus_id;		/** BUS ID of device */
-	int		of_offset;	/** Device tree node */
-	int		clk_period;	/** Clock period */
-	int		bus_max_width;	/** Bus width 1, 4 or 8 */
-	int		power_class;	/** Power class for device */
-	int		flags;
-	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
-	int		dat_clk_skew;	/** Clock skew for data in SCLK */
-	int		power_gpio_of_offset;	/** Offset of power node */
-	/**
-	 * Register bus-width value where:
-	 * 0: 1-bit
-	 * 1: 4-bit
-	 * 2: 8-bit
-	 * 5: 4-bit DDR
-	 * 6: 8-bit DDR
-	 * All other values are reserved.
-	 */
-	u8		bus_width;
-	bool		non_removable:1;/** True if device is not removable */
-	/** True if have extended CSD register */
-	bool		have_ext_csd:1;
-	bool		sector_mode:1;	/** Sector or byte mode */
-	bool		powered:1;	/** True if powered on */
-	/** True if power GPIO is active high */
-	bool		power_active_high:1;
-	bool		ro_inverted:1;	/** True if write-protect is inverted */
-	bool		cd_inverted:1;	/** True if card-detect is inverted */
-	bool		disable_ddr:1;	/** True to disable DDR */
-#if defined(CONFIG_ARCH_OCTEONTX2)
-	bool		is_asim:1;	/** True if we're running in ASIM */
-#endif
-};
-
-struct octeontx_mmc_host {
-	void		*base_addr;	/** Base address of device */
-	pci_dev_t	pdev;		/** PCI device */
-	u64		sclock;		/** SCLK in hz */
-	int		of_offset;	/** Device tree node */
-	int		cur_slotid;	/** Current slot to use */
-	int		last_slotid;	/** last slot in use */
-	int		max_width;	/** Maximum width hardware supports */
-#ifdef __mips
-	int		node;		/** OCX node for Octeon (MIPS) */
-	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
-#endif
-	bool		initialized;	/** True if initialized */
-	struct udevice  *dev;		/** Device host is associated with */
-	/** Slots associated with host controller */
-	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT];
-};
-
-/**
- * Returns the card write protect status
- *
- * @param mmc	pointer to mmc data structure
- * @return 1 if card is write protected, 0 otherwise
- */
-int octeontx_mmc_getwp(struct udevice *dev);
-
-/**
- * Gets the card-detect status
- *
- * @param mmc	pointer to mmc data structure
- *
- * @return	1 if card is detected, false if not detected.
- */
-int octeontx_mmc_getcd(struct udevice *dev);
-
-#endif /* __OCTEONTX_MMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_smi.h b/arch/arm/include/asm/arch-octeontx/octeontx_smi.h
deleted file mode 100644
index a721011f13..0000000000
--- a/arch/arm/include/asm/arch-octeontx/octeontx_smi.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef OCTEONTX_SMI_H_
-#define OCTEONTX_SMI_H_
-
-int octeontx_smi_initialize(bd_t *bis, unsigned int index);
-
-#endif /* OCTEONTX_SMI_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_svc.h b/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
index 5827b63310..fe2f45ab70 100644
--- a/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -22,6 +22,5 @@
 /* x1 - node number
  */
 #define OCTEONTX_DRAM_SIZE		0xc2000301
-#define OCTEONTX_NODE_COUNT		0xc2000601
 
 #endif /* __OCTEONTX_SVC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h b/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
index 898765ac20..68237bb288 100644
--- a/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef VNIC_H_
 #define VNIC_H_
 
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h b/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
index d8a61a07c6..67a89396d6 100644
--- a/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
@@ -1,256 +1,15 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef OCTEONTX_XCV_H_
 #define OCTEONTX_XCV_H_
 
-#define CAVM_XCVX_RESET		0x87E0DB000000ULL
-#define CAVM_XCVX_DLL_CTL	0x87E0DB000010ULL
-#define CAVM_XCVX_CTL		0x87E0DB000030ULL
-#define CAVM_XCVX_BATCH_CRD_RET	0x87E0DB000100ULL
-
-/**
- * Register (RSL) xcv#_dll_ctl
- *
- * XCV DLL Controller Register
- * The RGMII timing specification requires that devices transmit clock and
- * data synchronously. The specification requires external sources (namely
- * the PC board trace routes) to introduce the appropriate 1.5 to 2.0 ns of
- * delay.
- *
- * To eliminate the need for the PC board delays, the RGMII interface has optional
- * on-board DLLs for both transmit and receive. For correct operation, at most one
- * of the transmitter, board, or receiver involved in an RGMII link should
- * introduce delay. By default/reset, the RGMII receivers delay the received clock,
- * and the RGMII transmitters do not delay the transmitted clock. Whether this
- * default works as-is with a given link partner depends on the behavior of the
- * link partner and the PC board.
- *
- * These are the possible modes of RGMII receive operation:
- *
- * * XCV()_DLL_CTL[CLKRX_BYP] = 0 (reset value) - The RGMII
- * receive interface introduces clock delay using its internal DLL.
- * This mode is appropriate if neither the remote
- * transmitter nor the PC board delays the clock.
- *
- * * XCV()_DLL_CTL[CLKRX_BYP] = 1, [CLKRX_SET] = 0x0 - The
- * RGMII receive interface introduces no clock delay. This mode
- * is appropriate if either the remote transmitter or the PC board
- * delays the clock.
- *
- * These are the possible modes of RGMII transmit operation:
- *
- * * XCV()_DLL_CTL[CLKTX_BYP] = 1, [CLKTX_SET] = 0x0 (reset value) -
- * The RGMII transmit interface introduces no clock
- * delay. This mode is appropriate is either the remote receiver
- * or the PC board delays the clock.
- *
- * * XCV()_DLL_CTL[CLKTX_BYP] = 0 - The RGMII transmit
- * interface introduces clock delay using its internal DLL.
- * This mode is appropriate if neither the remote receiver
- * nor the PC board delays the clock.
- */
-union cavm_xcvx_dll_ctl
-{
-    uint64_t u;
-    struct cavm_xcvx_dll_ctl_s
-    {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-        uint64_t reserved_32_63        : 32;
-        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
-        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
-        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
-                                                                 Skews RXC from RXD, RXCTL.
-                                                                 By default, hardware internally shifts the RXC clock
-                                                                 to sample RXD,RXCTL assuming clock and data and
-                                                                 sourced synchronously from the link partner. */
-        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
-                                                                 Skews RXC from RXD. */
-        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
-                                                                 Skews TXC from TXD, TXCTL.
-                                                                 By default, clock and data and sourced
-                                                                 synchronously. */
-        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
-                                                                 Skews TXC from TXD. */
-        uint64_t reserved_2_7          : 6;
-        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
-                                                                 oscillator.
-                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
-                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
-                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
-                                                                 mode only.
-                                                                 0x0 = RGMII REFCLK.
-                                                                 0x1 = RGMII RXC (1000Mbs only).
-                                                                 0x2 = Divided coprocessor clock.
-                                                                 0x3 = Reserved.
-
-                                                                 Internal:
-                                                                 Some programming magic could allow for 10/100 operation if
-                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
-#else /* Word 0 - Little Endian */
-        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
-                                                                 oscillator.
-                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
-                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
-                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
-                                                                 mode only.
-                                                                 0x0 = RGMII REFCLK.
-                                                                 0x1 = RGMII RXC (1000Mbs only).
-                                                                 0x2 = Divided coprocessor clock.
-                                                                 0x3 = Reserved.
-
-                                                                 Internal:
-                                                                 Some programming magic could allow for 10/100 operation if
-                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
-        uint64_t reserved_2_7          : 6;
-        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
-                                                                 Skews TXC from TXD. */
-        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
-                                                                 Skews TXC from TXD, TXCTL.
-                                                                 By default, clock and data and sourced
-                                                                 synchronously. */
-        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
-                                                                 Skews RXC from RXD. */
-        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
-                                                                 Skews RXC from RXD, RXCTL.
-                                                                 By default, hardware internally shifts the RXC clock
-                                                                 to sample RXD,RXCTL assuming clock and data and
-                                                                 sourced synchronously from the link partner. */
-        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
-        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
-        uint64_t reserved_32_63        : 32;
-#endif /* Word 0 - End */
-    } s;
-    /* struct cavm_xcvx_dll_ctl_s cn; */
-};
-
-
-/**
- * Register (RSL) xcv#_reset
- *
- * XCV Reset Registers
- * This register controls reset.
- */
-union cavm_xcvx_reset
-{
-    uint64_t u;
-    struct cavm_xcvx_reset_s
-    {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
-        uint64_t reserved_16_62        : 47;
-        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
-                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
-        uint64_t reserved_12_14        : 3;
-        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
-        uint64_t reserved_8_10         : 3;
-        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
-        uint64_t reserved_4_6          : 3;
-        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
-        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
-        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
-        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
-#else /* Word 0 - Little Endian */
-        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
-        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
-        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
-        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
-        uint64_t reserved_4_6          : 3;
-        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
-        uint64_t reserved_8_10         : 3;
-        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
-        uint64_t reserved_12_14        : 3;
-        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
-                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
-        uint64_t reserved_16_62        : 47;
-        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
-#endif /* Word 0 - End */
-    } s;
-    /* struct cavm_xcvx_reset_s cn; */
-};
-
-/**
- * Register (RSL) xcv#_ctl
- *
- * XCV Control Register
- * This register contains the status control bits.
- */
-union cavm_xcvx_ctl
-{
-    uint64_t u;
-    struct cavm_xcvx_ctl_s
-    {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-        uint64_t reserved_4_63         : 60;
-        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
-                                                                 datapath. For correct operation, the following CSRs must be configured:
-                                                                 * XCV_CTL[SPEED]          = 0x2.
-                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
-                                                                 * XCV_RESET[CLKRST]       = 1. */
-        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
-                                                                 datapath. For correct operation, the following CSRs must be configured:
-                                                                 * XCV_CTL[SPEED]          = 0x2.
-                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
-                                                                 * XCV_RESET[CLKRST]       = 0. */
-        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
-                                                                   0x0 = 10 Mbps.
-                                                                   0x1 = 100 Mbps.
-                                                                   0x2 = 1 Gbps.
-                                                                   0x3 = Reserved. */
-#else /* Word 0 - Little Endian */
-        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
-                                                                   0x0 = 10 Mbps.
-                                                                   0x1 = 100 Mbps.
-                                                                   0x2 = 1 Gbps.
-                                                                   0x3 = Reserved. */
-        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
-                                                                 datapath. For correct operation, the following CSRs must be configured:
-                                                                 * XCV_CTL[SPEED]          = 0x2.
-                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
-                                                                 * XCV_RESET[CLKRST]       = 0. */
-        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
-                                                                 datapath. For correct operation, the following CSRs must be configured:
-                                                                 * XCV_CTL[SPEED]          = 0x2.
-                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
-                                                                 * XCV_RESET[CLKRST]       = 1. */
-        uint64_t reserved_4_63         : 60;
-#endif /* Word 0 - End */
-    } s;
-    /* struct cavm_xcvx_ctl_s cn; */
-};
-
-
-/**
- * Register (RSL) xcv#_batch_crd_ret
- *
- * XCV Batch Credit Return Register
- */
-union cavm_xcvx_batch_crd_ret
-{
-    uint64_t u;
-    struct cavm_xcvx_batch_crd_ret_s
-    {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-        uint64_t reserved_1_63         : 63;
-        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
-                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
-                                                                 take effect when XCV_RESET[ENABLE] is set. */
-#else /* Word 0 - Little Endian */
-        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
-                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
-                                                                 take effect when XCV_RESET[ENABLE] is set. */
-        uint64_t reserved_1_63         : 63;
-#endif /* Word 0 - End */
-    } s;
-    /* struct cavm_xcvx_batch_crd_ret_s cn; */
-};
-
-
+#define XCVX_BASE		0x87E0DB000000ULL
 
+#include <asm/arch/csrs/csrs-xcv.h>
 
 #endif /* OCTEONTX_XCV_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx2/atf.h b/arch/arm/include/asm/arch-octeontx2/atf.h
index ae463d995e..8a21846118 100644
--- a/arch/arm/include/asm/arch-octeontx2/atf.h
+++ b/arch/arm/include/asm/arch-octeontx2/atf.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -9,7 +9,6 @@
 #define __ATF_H__
 
 ssize_t atf_dram_size(unsigned int node);
-ssize_t atf_node_count(void);
 ssize_t atf_disable_rvu_lfs(unsigned int node);
 ssize_t atf_flsf_fw_booted(void);
 ssize_t atf_flsf_clr_force_2ndry(void);
diff --git a/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h b/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
deleted file mode 100644
index 209544363d..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
+++ /dev/null
@@ -1,1815 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef __OCTEON_MMC_H__
-#define __OCTEON_MMC_H__
-
-#include <mmc.h>
-#include <dm/device.h>
-
-/* NOTE: this file is used by both Octeon and OcteonTX */
-
-/*
- * Card Command Classes (CCC)
- */
-#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
-					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
-					/* (and for SPI, CMD58,59) */
-#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
-					/* (CMD11) */
-#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
-					/* (CMD16,17,18) */
-#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
-					/* (CMD20) */
-#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
-					/* (CMD16,24,25,26,27) */
-#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
-					/* (CMD32,33,34,35,36,37,38,39) */
-#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
-					/* (CMD28,29,30) */
-#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
-					/* (CMD16,CMD42) */
-#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
-					/* (CMD55,56,57,ACMD*) */
-#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
-					/* (CMD5,39,40,52,53) */
-#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
-					/* (CMD6,34,35,36,37,50) */
-					/* (11) Reserved */
-					/* (CMD?) */
-
-/*
- * NOTE: This was copied from the Linux kernel.
- *
- * MMC status in R1, for native mode (SPI bits are different)
- * Type
- *	e:error bit
- *	s:status bit
- *	r:detected and set for the actual command response
- *	x:detected and set during command execution. the host must poll
- *	    the card by sending status command in order to read these bits.
- * Clear condition
- *	a:according to the card state
- *	b:always related to the previous command. Reception of
- *	    a valid command will clear it (with a delay of one command)
- *	c:clear by read
- */
-#define R1_OUT_OF_RANGE         (1 << 31)       /* er, c */
-#define R1_ADDRESS_ERROR        (1 << 30)       /* erx, c */
-#define R1_BLOCK_LEN_ERROR      (1 << 29)       /* er, c */
-#define R1_ERASE_SEQ_ERROR      (1 << 28)       /* er, c */
-#define R1_ERASE_PARAM          (1 << 27)       /* ex, c */
-#define R1_WP_VIOLATION         (1 << 26)       /* erx, c */
-#define R1_CARD_IS_LOCKED       (1 << 25)       /* sx, a */
-#define R1_LOCK_UNLOCK_FAILED   (1 << 24)       /* erx, c */
-#define R1_COM_CRC_ERROR        (1 << 23)       /* er, b */
-#define R1_ILLEGAL_COMMAND      (1 << 22)       /* er, b */
-#define R1_CARD_ECC_FAILED      (1 << 21)       /* ex, c */
-#define R1_CC_ERROR             (1 << 20)       /* erx, c */
-#define R1_ERROR                (1 << 19)       /* erx, c */
-#define R1_UNDERRUN             (1 << 18)       /* ex, c */
-#define R1_OVERRUN              (1 << 17)       /* ex, c */
-#define R1_CID_CSD_OVERWRITE    (1 << 16)       /* erx, c, CID/CSD overwrite */
-#define R1_WP_ERASE_SKIP        (1 << 15)       /* sx, c */
-#define R1_CARD_ECC_DISABLED    (1 << 14)       /* sx, a */
-#define R1_ERASE_RESET          (1 << 13)       /* sr, c */
-#define R1_STATUS(x)            (x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
-#define R1_READY_FOR_DATA       (1 << 8)        /* sx, a */
-#define R1_SWITCH_ERROR         (1 << 7)        /* sx, c */
-#define R1_APP_CMD              (1 << 5)        /* sr, c */
-
-#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR;
-#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_WP_VIOLATION |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR |		\
-				R1_UNDERRUN |		\
-				R1_OVERRUN
-
-/**
- * Flag indicates that CMD23 is supported.  This is required for multi-block
- * hardware transfers to work.
- */
-#define OCTEON_MMC_FLAG_SD_CMD23	1
-
-#ifdef __mips
-# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
-#endif
-
-/* Offsets of various registers */
-#define MIO_EMM_DMA_FIFO_CFG		0x0160
-#define MIO_EMM_DMA_FIFO_ADR		0x0170
-#define MIO_EMM_DMA_FIFO_CMD		0x0178
-#define MIO_EMM_DMA_CFG			0x0180
-#define MIO_EMM_DMA_ADR			0x0188
-#define MIO_EMM_DMA_INT			0x0190
-#define NDF_DMA_INT			(-1)	/** Not supported yet */
-#define MIO_EMM_DMA_INT_W1S		0x0198
-#ifdef __arm
-# define MIO_EMM_DMA_INT_ENA_W1S	0x01A0
-# define MIO_EMM_DMA_INT_ENA_W1C	0x01A8
-#endif
-#define MIO_EMM_CFG			0x2000
-#define MIO_EMM_MODEX(X)		(0x2008 + ((X) * 0x8))
-#ifdef __arm
-# define MIO_EMM_COMP			0x2040
-#endif
-#define MIO_EMM_SWITCH			0x2048
-#define MIO_EMM_DMA			0x2050
-#define MIO_EMM_CMD			0x2058
-#define MIO_EMM_RSP_STS			0x2060
-#define MIO_EMM_RSP_LO			0x2068
-#define MIO_EMM_RSP_HI			0x2070
-#define MIO_EMM_INT			0x2078
-#ifdef __arm
-# define MIO_EMM_INT_W1S		0x2080
-#endif
-#define MIO_EMM_WDOG			0x2088
-#define MIO_EMM_SAMPLE			0x2090
-#define MIO_EMM_STS_MASK		0x2098
-#define MIO_EMM_RCA			0x20A0
-#ifdef __arm
-# define MIO_EMM_INT_ENA_W1S		0x20B0
-# define MIO_EMM_INT_ENA_W1C		0x20B8
-#endif
-#define MIO_EMM_BUF_IDX			0x20E0
-#define MIO_EMM_BUF_DAT			0x20E8
-#define MIO_EMM_ACCESS_WDOG		0x20F0
-
-/** Maximum supported MMC slots */
-#define CAVIUM_MAX_MMC_SLOT		2
-
-#define CAVIUM_MMC_NAME_LEN		32
-
-struct mmc;
-struct mmc_config;
-struct cavium_mmc_host;
-struct cavium_mmc_slot;
-struct gpio_desc;
-
-struct cavium_mmc_slot {
-	char		name[CAVIUM_MMC_NAME_LEN];	/** Name of device */
-	uint8_t		ext_csd[512];	/** Extended CSD register */
-	struct mmc	*mmc;		/** Ptr back to mmc structure */
-	struct cavium_mmc_host *host;	/** Host controller data structure */
-	struct mmc_config cfg;		/** Slot configuration */
-	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
-	struct gpio_desc cd_gpio;	/** Card detect GPIO */
-	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
-	int		power_delay;	/** Time in usec to wait for power */
-	int		bus_id;		/** BUS ID of device */
-	int		of_offset;	/** Device tree node */
-	int		clk_period;	/** Clock period */
-	int		bus_max_width;	/** Bus width 1, 4 or 8 */
-	int		power_class;	/** Power class for device */
-	int		flags;
-	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
-	int		dat_clk_skew;	/** Clock skew for data in SCLK */
-	int		power_gpio_of_offset;	/** Offset of power node */
-	/**
-	 * Register bus-width value where:
-	 * 0: 1-bit
-	 * 1: 4-bit
-	 * 2: 8-bit
-	 * 5: 4-bit DDR
-	 * 6: 8-bit DDR
-	 * All other values are reserved.
-	 */
-	uint8_t		bus_width;
-	bool		non_removable:1;/** True if device is not removable */
-	bool		have_ext_csd:1;	/** True if have extended CSD register */
-	bool		sector_mode:1;	/** Sector or byte mode */
-	bool		powered:1;	/** True if powered on */
-	/** True if power GPIO is active high */
-	bool		power_active_high:1;
-	bool		ro_inverted:1;	/** True if write-protect is inverted */
-	bool		cd_inverted:1;	/** True if card-detect is inverted */
-};
-
-struct cavium_mmc_host {
-	void		*base_addr;	/** Base address of device */
-	pci_dev_t	pdev;		/** PCI device */
-	uint64_t	sclock;		/** SCLK in hz */
-	int		of_offset;	/** Device tree node */
-	int		cur_slotid;	/** Current slot to use */
-	int		last_slotid;	/** last slot in use */
-	int		max_width;	/** Maximum width hardware supports */
-#ifdef __mips
-	int		node;		/** OCX node for Octeon (MIPS) */
-	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
-#endif
-	bool		initialized;
-	struct udevice  *dev;		/** Device host is associated with */
-	/** Slots associated with host controller */
-	struct cavium_mmc_slot slots[CAVIUM_MAX_MMC_SLOT];
-};
-
-
-/* Register definitions */
-
-/**
- * Register (RSL) mio_emm_buf_dat
- *
- * eMMC Data Buffer Access Register
- */
-union mio_emm_buf_dat {
-	uint64_t u;
-	struct mio_emm_buf_dat_s {
-		/**
-		 * [ 63:  0](R/W/H) Direct access to the 1 KB data
-		 * buffer memory. Address specified by MIO_EMM_BUF_IDX.
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_buf_dat_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_buf_idx
- *
- * eMMC Data Buffer Address Register
- */
-union mio_emm_buf_idx {
-	uint64_t u;
-	struct mio_emm_buf_idx_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_17_63:47;
-		/**
-		 * [ 16: 16](R/W) Automatically advance [BUF_NUM]/[OFFSET]
-		 * after each access to MIO_EMM_BUF_DAT.  Wraps after the
-		 * last offset of the last data buffer.
-		 */
-		uint64_t inc:1;
-		uint64_t reserved_7_15:9;
-		/**
-		 * [ 6:  6](R/W/H) Specify the data buffer for the next
-		 * access to MIO_EMM_BUF_DAT.
-		 */
-		uint64_t buf_num:1;
-		/**
-		 * [  5:  0](R/W/H) Specify the 8B data buffer offset for
-		 * the next access to MIO_EMM_BUF_DAT.
-		 */
-		uint64_t offset:6;
-#else /* Word 0 - Little Endian */
-		uint64_t offset:6;
-		uint64_t buf_num:1;
-		uint64_t reserved_7_15:9;
-		uint64_t inc:1;
-		uint64_t reserved_17_63:47;
-#endif /* Word 0 - End */
-	} s;
-};
-
-/**
- * Register (RSL) mio_emm_cfg
- *
- * eMMC Configuration Register
- */
-union mio_emm_cfg {
-	uint64_t u;
-	struct mio_emm_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_4_63:60;
-		/**
-		 * [  3:  0](R/W) eMMC bus enable mask.
-		 *
-		 * Setting bit0 of [BUS_ENA] causes EMMC_CMD[0] to become
-		 * dedicated eMMC bus 0 command (i.e. disabling any NOR use).
-		 *
-		 * Setting bit1 of [BUS_ENA] causes EMMC_CMD[1] to become
-		 * dedicated eMMC bus 1 command (i.e. disabling any NOR use).
-		 *
-		 * Setting bit2 of [BUS_ENA] causes EMMC_CMD[2] to become
-		 * dedicated eMMC bus 2 command (i.e. disabling any NOR use).
-		 *
-		 * Bit3 of [BUS_ENA] is reserved.
-		 *
-		 * Clearing all bits of this field will reset the other
-		 * MIO_EMM_* registers.
-		 * To ensure a proper reset the BUS_ENA bits should be
-		 * cleared for a minimum of 2 EMMC_CLK periods.  This
-		 * period be determined by waiting twice the number of
-		 * coprocessor clocks specified in MIO_EMM_MODE0[CLK_HI]
-		 * and MIO_EMM_MODE0[CLK_LO].
-		 *
-		 * Setting one or more bits will enable EMMC_CLK operation.
-		 */
-		uint64_t bus_ena:4;
-#else /* Word 0 - Little Endian */
-		uint64_t bus_ena:4;
-		uint64_t reserved_4_63:60;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_cmd
- *
- * eMMC Command Register
- */
-union  mio_emm_cmd {
-	uint64_t u;
-	struct mio_emm_cmd_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/**
-		 * [ 62: 62](R/W) Controls when command is completed.
-		 * 0 = Command doesn't complete until card has dropped
-		 *     the BUSY signal.
-		 * 1 = Complete command regardless of the BUSY signal.
-		 *     Status of signal can be read in
-		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
-		 */
-		uint64_t skip_busy:1;
-		/** [ 61: 60](R/W) Specify the eMMC bus */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) Request valid. Software writes this bit
-		 * to a 1.  Hardware clears it when the operation completes.
-		 */
-		uint64_t cmd_val:1;
-		uint64_t reserved_56_58:3;
-		/**
-		 * [ 55: 55](R/W) Specify the data buffer to be used for a
-		 * block transfer.
-		 */
-		uint64_t dbuf:1;
-		/**
-		 * [ 54: 49](R/W/H) Debug only.  Specify the number of
-		 * 8-byte transfers used in the command.  Value is 64-OFFSET.
-		 * The block transfer still starts at the first byte in
-		 * the 512 B data buffer.
-		 * Software must ensure CMD16 has updated the card block
-		 * length.
-		 */
-		uint64_t offset:6;
-		uint64_t reserved_43_48:6;
-		/**
-		 * [ 42: 41](R/W) Command type override; typically zero.
-		 * Value is XOR'd with the default command type.  See
-		 * Command and Response Types for command types per command
-		 * index. Types are:
-		 * 0x0 = No data.
-		 * 0x1 = Read data into Dbuf.
-		 * 0x2 = Write data from Dbuf.
-		 * 0x3 = Reserved.
-		 */
-		uint64_t ctype_xor:2;
-		/**
-		 * [ 40: 38](R/W) Response type override; typically zero.
-		 * Value is XOR'd with default response type.  See
-		 * Command and Response Types for response types per command
-		 * index.
-		 * Types are:
-		 * 0x0 = No Response.
-		 * 0x1 = R1, 48 bits.
-		 * 0x2 = R2, 136 bits.
-		 * 0x3 = R3, 48 bits.
-		 * 0x4 = R4, 48 bits.
-		 * 0x5 = R5, 48 bits.
-		 * 0x6, 0x7 = Reserved.
-		 */
-		uint64_t rtype_xor:3;
-		/** [ 37: 32](R/W/H) eMMC command */
-		uint64_t cmd_idx:6;
-		/** [ 31:  0](R/W/H) eMMC command argument */
-		uint64_t arg:32;
-#else /* Word 0 - Little Endian */
-		uint64_t arg:32;
-		uint64_t cmd_idx:6;
-		uint64_t rtype_xor:3;
-		uint64_t ctype_xor:2;
-		uint64_t reserved_43_48:6;
-		uint64_t offset:6;
-		uint64_t dbuf:1;
-		uint64_t reserved_56_58:3;
-		uint64_t cmd_val:1;
-		uint64_t bus_id:2;
-		uint64_t skip_busy:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_cmd_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_comp
- *
- * eMMC Compensation Register
- */
-union mio_emm_comp {
-	uint64_t u;
-	struct mio_emm_comp_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_11_63:53;
-		/**
-		 * [ 10:  8](R/W) eMMC bus driver PCTL. Typical values:
-		 * 0x4 = 60 ohm.
-		 * 0x6 = 40 ohm.
-		 * 0x7 = 30 ohm.
-		 */
-		uint64_t pctl:3;
-
-		uint64_t reserved_3_7:5;
-		/**
-		 * [  2:  0](R/W) eMMC bus driver NCTL. Typical values:
-		 * 0x4 = 60 ohm.
-		 * 0x6 = 40 ohm.
-		 * 0x7 = 30 ohm.
-		 */
-		uint64_t nctl:3;
-#else /* Word 0 - Little Endian */
-		uint64_t nctl:3;
-		uint64_t reserved_3_7:5;
-		uint64_t pctl:3;
-		uint64_t reserved_11_63:53;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_comp_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma
- *
- * eMMC External DMA Configuration Register
- */
-union mio_emm_dma {
-	uint64_t u;
-	struct mio_emm_dma_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/**
-		 * [ 62: 62](R/W) Controls when DMA is completed.
-		 * 0 = DMA doesn't complete until card has dropped the BUSY
-		 *     signal.
-		 * 1 = Complete DMA after last transfer regardless of the BUSY
-		 *     signal.  Status of signal can be read in
-		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
-		 */
-		uint64_t skip_busy:1;
-		/** [ 61: 60](R/W) Specify the eMMC bus */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) Software writes this bit to a 1 to
-		 * indicate that hardware should perform the DMA
-		 * transfer.
-		 * Hardware clears this bit when the DMA operation
-		 * completes or is terminated.
-		 */
-		uint64_t dma_val:1;
-		/**
-		 * [ 58: 58](R/W/H) Specify CARD_ADDR and eMMC are using
-		 * sector (512 B) addressing.
-		 */
-		uint64_t sector:1;
-		/**
-		 * [ 57: 57](R/W) Do not perform any eMMC commands.  A DMA
-		 * read returns all 0s.  A DMA write tosses the data.
-		 * In the case of a failure, this can be used to unwind the
-		 * DMA engine.
-		 */
-		uint64_t dat_null:1;
-		/**
-		 * [ 56: 51](R/W) Number of 8-byte blocks of data that
-		 * must exist in the DBUF before starting the 512-byte
-		 * block transfer.  Zero indicates to wait for the
-		 * entire block.
-		 */
-		uint64_t thres:6;
-		/**
-		 * [ 50: 50](R/W) Set the reliable write parameter when
-		 * performing CMD23 (SET_BLOCK_COUNT) for a multiple block.
-		 */
-		uint64_t rel_wr:1;
-		/** [ 49: 49](R/W) Read/write bit (0 = read, 1 = write). */
-		uint64_t rw:1;
-		/**
-		 * [ 48: 48](R/W) Perform operation using a multiple block
-		 * command instead of a series of single block commands.
-		 */
-		uint64_t multi:1;
-		/**
-		 * [ 47: 32](R/W/H) Number of blocks to read/write.  Hardware
-		 * decrements the block count after each successful
-		 * block transfer.
-		 */
-		uint64_t block_cnt:16;
-		/**
-		 * [ 31:  0](R/W/H) Data address for media <= 2 GB is a 32-bit
-		 * byte address, and data address for media > 2 GB is a 32-bit
-		 * sector (512 B) address.  Hardware advances the card address
-		 * after each successful block transfer by 512 for byte
-		 * addressing and by 1 for sector addressing.
-		 */
-		uint64_t card_addr:32;
-#else /* Word 0 - Little Endian */
-		uint64_t card_addr:32;
-		uint64_t block_cnt:16;
-		uint64_t multi:1;
-		uint64_t rw:1;
-		uint64_t rel_wr:1;
-		uint64_t thres:6;
-		uint64_t dat_null:1;
-		uint64_t sector:1;
-		uint64_t dma_val:1;
-		uint64_t bus_id:2;
-		uint64_t skip_busy:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_adr
- *
- * eMMC DMA Address Register
- * This register sets the address for eMMC/SD flash transfers to/from memory.
- * Sixty-four-bit operations must be used to access this register.  This
- * register is updated by the DMA hardware and can be reloaded by the values
- * placed in the MIO_EMM_DMA_FIFO_ADR.
- */
-union mio_emm_dma_adr {
-	uint64_t u;
-	struct mio_emm_dma_adr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/** [ 48:  0](R/W/H) DMA engine IOVA. Must be 64-bit aligned. */
-		uint64_t adr:49;
-#else /* Word 0 - Little Endian */
-		uint64_t adr:49;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_adr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_cfg
- *
- * eMMC DMA Configuration Register
- * This register controls the internal DMA engine used with the eMMC/SD flash
- * controller. Sixty-four-bit operations must be used to access this register.
- * This register is updated by the hardware DMA engine and can also be reloaded
- * by writes to the MIO_EMM_DMA_FIFO_CMD register.
- */
-union mio_emm_dma_cfg {
-	uint64_t u;
-	struct mio_emm_dma_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		/** [ 63: 63](R/W/H) DMA engine enable. */
-		uint64_t en:1;
-		/** [ 62: 62](R/W/H) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		/**
-		 * [ 61: 61](R/W/H) DMA engine abort.  When set to 1, DMA is
-		 * aborted and EN is cleared on completion.
-		 */
-		uint64_t clr:1;
-		uint64_t reserved_60:1;
-		/** [ 59: 59](R/W/H) DMA engine 32-bit swap. */
-		uint64_t swap32:1;
-		/** [ 58: 58](R/W/H) DMA engine enable 16-bit swap. */
-		uint64_t swap16:1;
-		/** [ 57: 57](R/W/H) DMA engine enable 8-bit swap. */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W/H) DMA engine endian mode: 0 = big-endian,
-		 * 1 = little-endian.
-		 */
-		uint64_t endian:1;
-		/**
-		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
-		 * 64-bit transfers (encoded in -1 notation).  For example, to
-		 * transfer 512 bytes, SIZE = 64 - 1 = 63.
-		 */
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t reserved_60:1;
-		uint64_t clr:1;
-		uint64_t rw:1;
-		uint64_t en:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_adr
- *
- * eMMC Internal DMA FIFO Address Register
- * This register specifies the internal address that is loaded into the eMMC
- * internal DMA FIFO.  The FIFO is used to queue up operations for the
- * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
- */
-union mio_emm_dma_fifo_adr {
-	uint64_t u;
-	struct mio_emm_dma_fifo_adr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/** [ 48:  3](R/W) DMA engine IOVA. Must be 64-bit aligned. */
-		uint64_t adr:46;
-		uint64_t reserved_0_2:3;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_2:3;
-		uint64_t adr:46;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_fifo_adr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cfg
- *
- * eMMC Internal DMA FIFO Configuration Register
- * This register controls DMA FIFO Operations.
- */
-union mio_emm_dma_fifo_cfg {
-	uint64_t u;
-	struct mio_emm_dma_fifo_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_17_63:47;
-		/**
-		 * [ 16: 16](R/W) DMA FIFO Clear. When set erases all commands
-		 * in the DMA FIFO. Must be zero for normal operation.
-		 */
-		uint64_t clr:1;
-		uint64_t reserved_13_15:3;
-		/**
-		 * [ 12:  8](R/W) Interrupt threshold indicating the number of
-		 * entries remaining in the DMA FIFO.  An interrupt occurs if
-		 * the FIFO is read at the level specified.
-		 * A value of 0 disables the interrupt.  A value of 17 or
-		 * greater will cause an interrupt only if the FIFO is
-		 * overflowed.
-		 * See MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t int_lvl:5;
-		uint64_t reserved_5_7:3;
-		/**
-		 * [  4:  0](RO/H) Number of entries in the DMA FIFO.  This
-		 * count is incremented by writes to the MIO_EMM_DMA_FIFO_CMD
-		 * register and decremented each time the internal DMA engine
-		 * completes the previous command successfully.
-		 *
-		 * Up to 16 entries can be placed in the FIFO.  Entries written
-		 * to a full FIFO will potentially corrupt existing entries.
-		 * Care must be taken by software to insure that this condition
-		 * does not occur.
-		 */
-		uint64_t count:5;
-#else /* Word 0 - Little Endian */
-		uint64_t count:5;
-		uint64_t reserved_5_7:3;
-		uint64_t int_lvl:5;
-		uint64_t reserved_13_15:3;
-		uint64_t clr:1;
-		uint64_t reserved_17_63:47;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_fifo_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cmd
- *
- * eMMC Internal DMA FIFO Command Register
- * This register specifies a command that is loaded into the eMMC internal DMA
- * FIFO.  The FIFO is used to queue up operations for the
- * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.  Writes
- * to this register store both the MIO_EMM_DMA_FIFO_CMD and the
- * MIO_EMM_DMA_FIFO_ADR contents into the FIFO and increment the
- * MIO_EMM_DMA_FIFO_CFG[COUNT] field.
- *
- * Note: This register has a similar format to the MIO_EMM_DMA_CFG register with
- * the exception that the EN and CLR fields are absent.  These are supported in
- * the MIO_EMM_DMA_FIFO_CFG.
- */
-union mio_emm_dma_fifo_cmd {
-	uint64_t u;
-	struct mio_emm_dma_fifo_cmd_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		uint64_t reserved_61:1;
-		/**
-		 * [ 60: 60](R/W) DMA command interrupt disable.  When set, the
-		 * DMA command being submitted will not generate a
-		 * MIO_EMM_DMA_INT[DONE] interrupt when it completes.  When
-		 * cleared the command will generate the interrupt.
-		 *
-		 * For example, this field can be set for all the DMA commands
-		 * submitted to the DMA FIFO in the case of a write to the eMMC
-		 * device because the MIO_EMM_INT[DMA_DONE] interrupt would
-		 * signify the end of the operation.  It could be cleared on the
-		 * last DMA command being submitted to the DMA FIFO and the
-		 * MIO_EMM_DMA_INT[DONE] would occur when the read data from the
-		 * eMMC device was available in local memory.
-		 */
-		uint64_t intdis:1;
-		/**
-		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
-		 *  See [ENDIAN].
-		 */
-		uint64_t swap32:1;
-		/**
-		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap16:1;
-		/**
-		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W) DMA engine endian mode:
-		 *  0 = little-endian
-		 *  1 = big-endian
-		 * Using 0..7 to identify bytes.
-		 *
-		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
-		 * 0        0        0      0       7 6 5 4 3 2 1 0
-		 * 0        0        1      0       6 7 4 5 2 3 0 1
-		 * 0        1        0      0       5 4 7 6 1 0 3 2
-		 * 1        0        0      0       3 2 1 0 7 6 5 4
-		 * 0        0        0      1       0 1 2 3 4 5 6 7
-		 * 0        0        1      1       1 0 3 2 5 4 7 6
-		 * 0        1        0      1       2 3 0 1 6 7 4 5
-		 * 1        0        0      1       4 5 6 7 0 1 2 3
-		 */
-		uint64_t endian:1;
-		/**
-		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
-		 * 64-bit transfers (encoded in -1 notation).  For
-		 * example, to transfer 512 bytes, SIZE = 64 - 1 = 63.
-		 */
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t intdis:1;
-		uint64_t reserved_61:1;
-		uint64_t rw:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	struct mio_emm_dma_fifo_cmd_cn88xxp1 {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		uint64_t reserved_61:1;
-		uint64_t reserved_60:1;
-		/**
-		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap32:1;
-		/**
-		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap16:1;
-		/**
-		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W) DMA engine endian mode:
-		 *  0 = little-endian
-		 *  1 = big-endian
-		 * Using 0..7 to identify bytes.
-		 *
-		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
-		 * 0        0        0      0       7 6 5 4 3 2 1 0
-		 * 0        0        1      0       6 7 4 5 2 3 0 1
-		 * 0        1        0      0       5 4 7 6 1 0 3 2
-		 * 1        0        0      0       3 2 1 0 7 6 5 4
-		 * 0        0        0      1       0 1 2 3 4 5 6 7
-		 * 0        0        1      1       1 0 3 2 5 4 7 6
-		 * 0        1        0      1       2 3 0 1 6 7 4 5
-		 * 1        0        0      1       4 5 6 7 0 1 2 3
-		 */
-		uint64_t endian:1;
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t reserved_60:1;
-		uint64_t reserved_61:1;
-		uint64_t rw:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} cn88xxp1;
-	/* struct mio_emm_dma_fifo_cmd_s cn9; */
-	/* struct mio_emm_dma_fifo_cmd_s cn81xx; */
-	/* struct mio_emm_dma_fifo_cmd_s cn83xx; */
-	/* struct mio_emm_dma_fifo_cmd_s cn88xxp2; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int
- *
- * eMMC DMA Interrupt Register
- * Sixty-four-bit operations must be used to access this register.
- */
-union mio_emm_dma_int {
-	uint64_t u;
-	struct mio_emm_dma_int_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1C/H) Internal DMA FIFO has dropped to level
-		 * specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1C/H) Internal DMA engine request completion
-		 * interrupt.
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1c
- *
- * eMMC DMA Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
- */
-union mio_emm_dma_int_ena_w1c {
-	uint64_t u;
-	struct mio_emm_dma_int_ena_w1c_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_DMA_INT[DONE].
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_ena_w1c_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1s
- *
- * eMMC DMA Interrupt Enable Set Register
- * This register sets interrupt enable bits.
- */
-union mio_emm_dma_int_ena_w1s {
-	uint64_t u;
-	struct mio_emm_dma_int_ena_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_DMA_INT[DONE].
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_ena_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_w1s
- *
- * eMMC DMA Interrupt Set Register
- * This register sets interrupt bits.
- */
-union mio_emm_dma_int_w1s {
-	uint64_t u;
-	struct mio_emm_dma_int_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[FIFO]. */
-		uint64_t fifo:1;
-		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[DONE]. */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int
- *
- * eMMC Interrupt Register
- */
-union mio_emm_int {
-	uint64_t u;
-	struct mio_emm_int_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/** [  6:  6](R/W1C/H) Switch operation encountered an error. */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1C/H) Switch operation completed successfully.
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1C/H) External DMA transfer encountered an
-		 * error. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1C/H) Operation specified by MIO_EMM_CMD
-		 * encountered an error. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t cmd_err:1;
-		/**
-		 * [  2:  2](R/W1C/H) External DMA transfer completed
-		 * successfully.
-		 */
-		uint64_t dma_done:1;
-		/** [  1:  1](R/W1C/H) Operation specified by MIO_EMM_CMD
-		 * completed successfully.
-		 */
-		uint64_t cmd_done:1;
-		/**
-		 * [  0:  0](R/W1C/H) The next 512B block transfer of a
-		 * multiblock transfer has completed.
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_ena_w1c
- *
- * eMMC Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
- */
-union mio_emm_int_ena_w1c {
-	uint64_t u;
-	struct mio_emm_int_ena_w1c_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/**
-		 * [  6:  6](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[SWITCH_ERR].
-		 */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[DMA_ERR].
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[CMD_ERR].
-		 */
-		uint64_t cmd_err:1;
-		/**
-		 * [  2:  2](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[DMA_DONE].
-		 */
-		uint64_t dma_done:1;
-		/**
-		 * [  1:  1](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[CMD_DONE].
-		 */
-		uint64_t cmd_done:1;
-		/** [  0:  0](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[BUF_DONE].
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_ena_w1c_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_ena_w1s
- *
- * eMMC Interrupt Enable Set Register
- * This register sets interrupt enable bits.
- */
-union mio_emm_int_ena_w1s {
-	uint64_t u;
-	struct mio_emm_int_ena_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/**
-		 * [  6:  6](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[SWITCH_ERR].
-		 */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[DMA_ERR].
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[CMD_ERR].
-		 */
-		uint64_t cmd_err:1;
-		/** [  2:  2](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[DMA_DONE].
-		 */
-		uint64_t dma_done:1;
-		/**
-		 * [  1:  1](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[CMD_DONE].
-		 */
-		uint64_t cmd_done:1;
-		/**
-		 * [  0:  0](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[BUF_DONE].
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_ena_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_w1s
- *
- * eMMC Interrupt Set Register
- * This register sets interrupt bits.
- */
-union mio_emm_int_w1s {
-	uint64_t u;
-	struct mio_emm_int_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/** [  6:  6](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_ERR]. */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/** [  4:  4](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_ERR]. */
-		uint64_t dma_err:1;
-		/** [  3:  3](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_ERR]. */
-		uint64_t cmd_err:1;
-		/** [  2:  2](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_DONE]. */
-		uint64_t dma_done:1;
-		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_DONE]. */
-		uint64_t cmd_done:1;
-		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_INT[BUF_DONE]. */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_mode#
- *
- * eMMC Operating Mode Register
- */
-union mio_emm_modex {
-	uint64_t u;
-	struct mio_emm_modex_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/**
-		 * [ 48: 48](RO/H) Current high-speed timing mode.  Required
-		 * when CLK frequency is higher than 20 MHz.
-		 */
-		uint64_t hs_timing:1;
-		uint64_t reserved_43_47:5;
-		/**
-		 * [ 42: 40](RO/H) Current card bus mode. Out of reset, the
-		 * card is in 1-bit data bus mode. Select bus width.
-		 * 0x0 = 1-bit data b*us (power on).
-		 * 0x1 = 4-bit data bus.
-		 * 0x2 = 8-bit data bus.
-		 * 0x3 = Reserved.
-		 * 0x4 = Reserved.
-		 * 0x5 = 4-bit data bus (dual data rate).
-		 * 0x6 = 8-bit data bus (dual data rate).
-		 * 0x7 = Reserved.
-		 * 0x8 = Reserved.
-		 */
-		uint64_t bus_width:3;
-		uint64_t reserved_36_39:4;
-		/**
-		 * [ 35: 32](RO/H) Out of reset, the card power class is 0,
-		 * which is the minimum current consumption class for the card.
-		 * EXT_CSD bytes [203:200] and [239:238] contain the power class
-		 * for different BUS_WITDH and CLK frequencies.  Software should
-		 * write this field with the 4-bit field from the EXT_CSD bytes
-		 * corresponding to the selected operating mode.
-		 */
-		uint64_t power_class:4;
-		/**
-		 * [ 31: 16](RO/H) Current number of coprocessor-clocks to hold
-		 * the eMMC CLK pin high.
-		 */
-		uint64_t clk_hi:16;
-		/**
-		 * [ 15:  0](RO/H) Current number of coprocessor-clocks to
-		 * hold the eMMC CLK pin low.
-		 */
-		uint64_t clk_lo:16;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_lo:16;
-		uint64_t clk_hi:16;
-		uint64_t power_class:4;
-		uint64_t reserved_36_39:4;
-		uint64_t bus_width:3;
-		uint64_t reserved_43_47:5;
-		uint64_t hs_timing:1;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_modex_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_pba#
- *
- * eMMC MSI-X Pending Bit Array Registers
- * This register is the MSI-X PBA table; the bit number is indexed by the
- * MIO_EMM_INT_VEC_E enumeration.
- */
-union mio_emm_msix_pbax {
-	uint64_t u;
-	struct mio_emm_msix_pbax_s {
-		/**
-		 * [ 63:  0](RO/H) Pending message for the associated
-		 * MIO_EMM_MSIX_VEC()_CTL, enumerated by MIO_EMM_INT_VEC_E.
-		 * Bits that have no associated MIO_EMM_INT_VEC_E are 0.
-		 */
-		uint64_t pend:64;
-	} s;
-	/* struct mio_emm_msix_pbax_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_vec#_addr
- *
- * eMMC MSI-X Vector-Table Address Register
- * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
- * enumeration.
- */
-union mio_emm_msix_vecx_addr {
-	uint64_t u;
-	struct mio_emm_msix_vecx_addr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/**
-		 * [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector.
-		 */
-		uint64_t addr:47;
-		uint64_t reserved_1:1;
-		/**
-		 * [  0:  0](SR/W) Secure vector.
-		 * 0 = This vector may be read or written by either secure or
-		 *     nonsecure states.
-		 * 1 = This vector's MIO_EMM_MSIX_VEC()_ADDR,
-		 *     MIO_EMM_MSIX_VEC()_CTL, and corresponding bit of
-		 *     MIO_EMM_MSIX_PBA() are RAZ/WI and does not cause a fault
-		 *     when accessed by the nonsecure world.
-		 *
-		 * If PCCPF_MIO_EMM_VSEC_SCTL[MSIX_SEC] (for documentation, see
-		 * PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is set, all vectors are secure
-		 * and function as if [SECVEC] was set.
-		 */
-		uint64_t secvec:1;
-#else /* Word 0 - Little Endian */
-		uint64_t secvec:1;
-		uint64_t reserved_1:1;
-		uint64_t addr:47;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_msix_vecx_addr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_vec#_ctl
- *
- * eMMC MSI-X Vector-Table Control and Data Register
- * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
- * enumeration.
- */
-union mio_emm_msix_vecx_ctl {
-	uint64_t u;
-	struct mio_emm_msix_vecx_ctl_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_33_63:31;
-		/**
-		 * [ 32: 32](R/W) When set, no MSI-X interrupts are sent to this
-		 * vector.
-		 */
-		uint64_t mask:1;
-		uint64_t reserved_20_31:12;
-		/**
-		 * [ 19:  0](R/W) Data to use for MSI-X delivery of this vector.
-		 */
-		uint64_t data:20;
-#else /* Word 0 - Little Endian */
-		uint64_t data:20;
-		uint64_t reserved_20_31:12;
-		uint64_t mask:1;
-		uint64_t reserved_33_63:31;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_msix_vecx_ctl_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rca
- *
- * eMMC Relative Card Address Register
- */
-union mio_emm_rca {
-	uint64_t u;
-	struct mio_emm_rca_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_16_63:48;
-		/**
-		 * [ 15:  0](R/W/H) Whenever software performs CMD7, hardware
-		 * updates [CARD_RCA] with the relative card address from the
-		 * MIO_EMM_CMD[ARG], unless the operation encounters an error.
-		 */
-		uint64_t card_rca:16;
-#else /* Word 0 - Little Endian */
-		uint64_t card_rca:16;
-		uint64_t reserved_16_63:48;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_rca_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_hi
- *
- * eMMC Response Data High Register
- */
-union mio_emm_rsp_hi {
-	uint64_t u;
-	struct mio_emm_rsp_hi_s {
-		/**
-		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
-		 * SD Specifications):
-		 * _ RSP_TYPE = 1: DAT[63:0] = 0x0.   *
-		 * _ RSP_TYPE = 2: DAT[63:0] = CID[127:64] or CSD[127:64].
-		 * _ RSP_TYPE = 3: DAT[63:0] = 0x0.
-		 * _ RSP_TYPE = 4: DAT[63:0] = 0x0.
-		 * _ RSP_TYPE = 5: DAT[63:0] = 0x0.
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_rsp_hi_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_lo
- *
- * eMMC Response Data Low Register
- */
-union mio_emm_rsp_lo {
-	uint64_t u;
-	struct mio_emm_rsp_lo_s {
-		/**
-		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
-		 * SD Specifications).
-		 *
-		 *
-		 * RSP_TYPE = 1:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = Command index
-		 * DAT[39: 8] = Card status
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 2:
-		 * DAT[63: 1] = CID[63:1] or CSD[63:1] including CRC
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 3:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = Check bits (0x3F)
-		 * DAT[39: 8] = OCR register
-		 * DAT[ 7: 1] = Check bits (0x7F)
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 4:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = CMD39 ('10111')
-		 * DAT[39:24] = RCA[31:16]
-		 * DAT[   23] = Status
-		 * DAT[22:16] = Register address
-		 * DAT[15: 8] = Register contents
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 5:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = CMD40 ('10100')
-		 * DAT[39:24] = RCA[31:16]
-		 * DAT[   23] = Status
-		 * DAT[22:16] = Register address
-		 * DAT[15: 8] = Not defined. May be used for IRQ data
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_rsp_lo_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_sts
- *
- * eMMC Response Status Register
- */
-union mio_emm_rsp_sts {
-	uint64_t u;
-	struct mio_emm_rsp_sts_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_62_63:2;
-		/**
-		 * [ 61: 60](RO/H) eMMC bus ID to which the response status
-		 * corresponds.
-		 */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](RO/H) Read-only copy of MIO_EMM_CMD[CMD_VAL].
-		 * [CMD_VAL] = 1 indicates that a direct operation is in
-		 * progress.
-		 */
-		uint64_t cmd_val:1;
-		/**
-		 * [ 58: 58](RO/H) Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE].
-		 * [SWITCH_VAL] = 1 indicates that a switch operation is in
-		 * progress.
-		 */
-		uint64_t switch_val:1;
-		/**
-		 * [ 57: 57](RO/H) Read-only copy of MIO_EMM_DMA[DMA_VAL].
-		 * [DMA_VAL] = 1 indicates that a DMA operation is in progress.
-		 */
-		uint64_t dma_val:1;
-		/**
-		 * [ 56: 56](RO/H) The DMA engine has a pending transfer
-		 * resulting from an error. Software can resume the transfer by
-		 * writing MIO_EMM_DMA[DMA_VAL] = 1.
-		 *
-		 * Software can terminate the transfer by writing
-		 * MIO_EMM_DMA[DMA_VAL] = 1 and MIO_EMM_DMA[DAT_NULL] = 1.
-		 * Hardware will then clear [DMA_PEND] and perform the DMA
-		 * operation.
-		 */
-		uint64_t dma_pend:1;
-		/**
-		 * [ 55: 55](RO/H) The store operation to the device took longer
-		 * than MIO_EMM_ACCESS_WDOG[CLK_CNT] coprocessor-clocks to
-		 * complete.
-		 * Valid when [DMA_PEND] is set.
-		 */
-		uint64_t acc_timeout:1;
-		uint64_t reserved_29_54:26;
-		/**
-		 * [ 28: 28](RO/H) For [CMD_TYPE] = 1, indicates that a DMA read
-		 * data arrived from the card without a free DBUF.  For
-		 * [CMD_TYPE] = 2, indicates a DBUF underflow occurred during a
-		 * DMA write. See MIO_EMM_DMA[THRES].
-		 */
-		uint64_t dbuf_err:1;
-		uint64_t reserved_24_27:4;
-		/**
-		 * [ 23: 23](RO/H) DBUF corresponding to the most recently
-		 * attempted block transfer.
-		 */
-		uint64_t dbuf:1;
-		/**
-		 * [ 22: 22](RO/H) Timeout waiting for read data or 3-bit CRC
-		 * token.
-		 */
-		uint64_t blk_timeout:1;
-		/**
-		 * [ 21: 21](RO/H) For [CMD_TYPE] = 1, indicates a card read
-		 * data CRC mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the
-		 * failing data buffer.
-		 *
-		 * For [CMD_TYPE] = 2, indicates card returned 3-bit CRC status
-		 * token indicating that the card encountered a write data CRC
-		 * check mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the failing
-		 * data buffer.
-		 */
-		uint64_t blk_crc_err:1;
-		/**
-		 * [ 20: 20](RO/H) Debug only. eMMC protocol utilizes DAT0 as a
-		 * busy signal during block writes and R1b responses.  This bit
-		 * should read zero before any DMA or Command with data is
-		 * executed.
-		 */
-		uint64_t rsp_busybit:1;
-		/** [ 19: 19](RO/H) Stop transmission response timeout. */
-		uint64_t stp_timeout:1;
-		/**
-		 * [ 18: 18](RO/H) Stop transmission response had a CRC error.
-		 */
-		uint64_t stp_crc_err:1;
-		/**
-		 * [ 17: 17](RO/H) Stop transmission response had bad status.
-		 */
-		uint64_t stp_bad_sts:1;
-		/** [ 16: 16](RO/H) Stop transmission response valid. */
-		uint64_t stp_val:1;
-		/** [ 15: 15](RO/H) Response timeout. */
-		uint64_t rsp_timeout:1;
-		/** [ 14: 14](RO/H) Response CRC error. */
-		uint64_t rsp_crc_err:1;
-		/** [ 13: 13](RO/H) Response bad status. */
-		uint64_t rsp_bad_sts:1;
-		/**
-		 * [ 12: 12](RO/H) Response ID.  See
-		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
-		 */
-		uint64_t rsp_val:1;
-		/**
-		 * [ 11:  9](RO/H) Indicates the response type.  See
-		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
-		 */
-		uint64_t rsp_type:3;
-		/**
-		 * [  8:  7](RO/H) eMMC command type.
-		 * 0x0 = No data.
-		 * 0x1 = Read.
-		 * 0x2 = Write.
-		 */
-		uint64_t cmd_type:2;
-		/**
-		 * [  6:  1](RO/H) eMMC command index most recently attempted.
-		 */
-		uint64_t cmd_idx:6;
-		/**
-		 * [  0:  0](RO/H) eMMC command completed.  Once the command has
-		 * completed, the status is final and can be examined by
-		 * software.
-		 */
-		uint64_t cmd_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t cmd_done:1;
-		uint64_t cmd_idx:6;
-		uint64_t cmd_type:2;
-		uint64_t rsp_type:3;
-		uint64_t rsp_val:1;
-		uint64_t rsp_bad_sts:1;
-		uint64_t rsp_crc_err:1;
-		uint64_t rsp_timeout:1;
-		uint64_t stp_val:1;
-		uint64_t stp_bad_sts:1;
-		uint64_t stp_crc_err:1;
-		uint64_t stp_timeout:1;
-		uint64_t rsp_busybit:1;
-		uint64_t blk_crc_err:1;
-		uint64_t blk_timeout:1;
-		uint64_t dbuf:1;
-		uint64_t reserved_24_27:4;
-		uint64_t dbuf_err:1;
-		uint64_t reserved_29_54:26;
-		uint64_t acc_timeout:1;
-		uint64_t dma_pend:1;
-		uint64_t dma_val:1;
-		uint64_t switch_val:1;
-		uint64_t cmd_val:1;
-		uint64_t bus_id:2;
-		uint64_t reserved_62_63:2;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_rsp_sts_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_sample
- *
- * eMMC Sampling Register
- */
-union mio_emm_sample {
-	uint64_t u;
-	struct mio_emm_sample_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_26_63:38;
-		/**
-		 * [ 25: 16](R/W) Number of coprocessor-clocks before the eMMC
-		 * clock rising edge to sample the command pin.
-		 */
-		uint64_t cmd_cnt:10;
-		uint64_t reserved_10_15:6;
-		/**
-		 * [  9:  0](R/W) Number of coprocessor-clocks before the eMMC
-		 * clock edge to sample the data pin.
-		 */
-		uint64_t dat_cnt:10;
-#else /* Word 0 - Little Endian */
-		uint64_t dat_cnt:10;
-		uint64_t reserved_10_15:6;
-		uint64_t cmd_cnt:10;
-		uint64_t reserved_26_63:38;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_sample_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_sts_mask
- *
- * eMMC Status Mask Register
- */
-union mio_emm_sts_mask {
-	uint64_t u;
-	struct mio_emm_sts_mask_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_32_63:32;
-		/**
-		 * [ 31:  0](R/W) Any bit set in [STS_MSK] causes the
-		 * corresponding bit in the card status to be considered when
-		 * computing response bad status.
-		 */
-		uint64_t sts_msk:32;
-#else /* Word 0 - Little Endian */
-		uint64_t sts_msk:32;
-		uint64_t reserved_32_63:32;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_sts_mask_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_switch
- *
- * eMMC Operating Mode Switch Register
- */
-union mio_emm_switch {
-	uint64_t u;
-	struct mio_emm_switch_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_62_63:2;
-		/** [ 61: 60](R/W/H) Specifies the eMMC bus id. */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) When clear, the operating modes are updated
-		 * directly without performing any SWITCH operations.  This
-		 * allows software to perform the SWITCH operations manually,
-		 * then update the hardware.
-		 *
-		 * Software writes this bit to a 1 to indicate that hardware
-		 * should perform the necessary SWITCH operations.
-		 *
-		 * First, the POWER_CLASS switch is performed.  If it fails,
-		 * [SWITCH_ERR0] is set and the remaining SWITCH operations are
-		 * not performed.  If it succeeds, [POWER_CLASS] is updated and
-		 * the HS_TIMING switch is performed.
-		 *
-		 * If the HS_TIMING switch fails, [SWITCH_ERR1] is set and the
-		 * remaining SWITCH operations are not performed.  If it
-		 * succeeds, [HS_TIMING] is updated and the BUS_WIDTH switch
-		 * operation is performed.
-		 *
-		 * If the BUS_WIDTH switch operation fails, [SWITCH_ERR2] is
-		 * set.  If it succeeds, the BUS_WITDH is updated.
-		 *
-		 * Changes to CLK_HI and CLK_LO are discarded if any SWITCH_ERR
-		 * occurs.
-		 */
-		uint64_t switch_exe:1;
-		/**
-		 * [ 58: 58](RO/H) Error encountered while performing
-		 * POWER_CLASS switch. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err0:1;
-		/**
-		 * [ 57: 57](RO/H) Error encountered while performing HS_TIMING
-		 * switch.  See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err1:1;
-		/**
-		 * [ 56: 56](RO/H) Error encountered while performing BUS_WIDTH
-		 * switch. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err2:1;
-		uint64_t reserved_49_55:7;
-		/** [ 48: 48](R/W) Requested update to HS_TIMING. */
-		uint64_t hs_timing:1;
-		uint64_t reserved_43_47:5;
-		/** [ 42: 40](R/W) Requested update to BUS_WIDTH. */
-		uint64_t bus_width:3;
-		uint64_t reserved_36_39:4;
-		/** [ 35: 32](R/W) Requested update to POWER_CLASS. */
-		uint64_t power_class:4;
-		/** [ 31: 16](R/W) Requested update to CLK_HI. */
-		uint64_t clk_hi:16;
-		/** [ 15:  0](R/W) Requested update to CLK_LO. */
-		uint64_t clk_lo:16;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_lo:16;
-		uint64_t clk_hi:16;
-		uint64_t power_class:4;
-		uint64_t reserved_36_39:4;
-		uint64_t bus_width:3;
-		uint64_t reserved_43_47:5;
-		uint64_t hs_timing:1;
-		uint64_t reserved_49_55:7;
-		uint64_t switch_err2:1;
-		uint64_t switch_err1:1;
-		uint64_t switch_err0:1;
-		uint64_t switch_exe:1;
-		uint64_t bus_id:2;
-		uint64_t reserved_62_63:2;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_switch_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_wdog
- *
- * eMMC Watchdog Register
- */
-union mio_emm_wdog {
-	uint64_t u;
-	struct mio_emm_wdog_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_26_63:38;
-		/**
-		 * [ 25:  0](R/W) Maximum number of CLK_CNT cycles to wait for
-		 * the card to return a response, read data, or the 3-bit CRC
-		 * status token following write data.  The following timeouts
-		 * are detected:
-		 *
-		 * Expected response to a command doesn't occur causing
-		 * MIO_EMM_RSP_STS[RSP_TIMEOUT].
-		 *
-		 * On a read command, expected data isn't returned causing
-		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * On a multi read command, expected data isn't returned causing
-		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * On a write command, expected token to a write block isn't
-		 * received causing MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * If a stop command is issued by the hardware and no response
-		 * is returned causing MIO_EMM_RSP_STS[STP_TIMEOUT].
-		 *
-		 * Issues this timeout doesn't cover are stalls induced by the
-		 * card which are not limited by the specifications.
-		 * For example, when a write multi command is issued to the card
-		 * and a block (not the last) is transferred the card can
-		 * "stall" CNXXXX by forcing emmc_data<0> low for as long as
-		 * it wants to free up buffer space.
-		 *
-		 * The second case is when the last block of a write or multi
-		 * write is being transferred and the card elects to perform
-		 * some background tasks. The same stall mechanism with
-		 * emmc_data<0> is used but this can last for an extend time
-		 * period.
-		 */
-		uint64_t clk_cnt:26;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_cnt:26;
-		uint64_t reserved_26_63:38;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_wdog_s cn; */
-};
-
-/**
- * Returns the card write protect status
- *
- * @param mmc	pointer to mmc data structure
- * @return 1 if card is write protected, 0 otherwise
- */
-int cavium_mmc_getwp(struct udevice *dev);
-
-/**
- * Gets the card-detect status
- *
- * @param mmc	pointer to mmc data structure
- *
- * @return	1 if card is detected, false if not detected.
- */
-int cavium_mmc_getcd(struct udevice *dev);
-
-
-#endif /* __OCTEON_MMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
deleted file mode 120000
index 303a622b5b..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
+++ /dev/null
@@ -1 +0,0 @@
-../arch-octeontx/cavm-csrs-mio_emm.h
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-octeontx2/clock.h b/arch/arm/include/asm/arch-octeontx2/clock.h
index d4364954ed..1ce4535fd6 100644
--- a/arch/arm/include/asm/arch-octeontx2/clock.h
+++ b/arch/arm/include/asm/arch-octeontx2/clock.h
@@ -1,16 +1,15 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef __OCTEONTX2_CLOCK_H__
 
 /** System PLL reference clock */
 #define PLL_REF_CLK                     50000000        /* 50 MHz */
-#define NS_PER_REF_CLK_TICK             (1000000000/PLL_REF_CLK)
+#define NS_PER_REF_CLK_TICK             (1000000000 / PLL_REF_CLK)
 
 /** Address of RST_BOOT register */
 #define RST_BOOT	0x87e006001600ll
@@ -23,30 +22,6 @@
 union cavm_rst_boot {
 	u64 u;
 	struct cavm_rst_boot_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -69,33 +44,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} s;
 	struct cavm_rst_boot_cn81xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -118,32 +68,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn81xx;
 	struct cavm_rst_boot_cn88xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 reserved_26_29:4;
-		u64 reserved_24_25:2;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -165,33 +91,8 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn88xx;
 	struct cavm_rst_boot_cn83xx {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		u64 chipkill:1;
-		u64 jtcsrdis:1;
-		u64 ejtagdis:1;
-		u64 trusted_mode:1;
-		u64 ckill_ppdis:1;
-		u64 jt_tstmode:1;
-		u64 vrm_err:1;
-		u64 dis_huk:1;
-		u64 dis_scan:1;
-		u64 reserved_47_54:8;
-		u64 c_mul:7;
-		u64 reserved_39:1;
-		u64 pnr_mul:6;
-		u64 lboot_oci:3;
-		u64 lboot_pf_flr:4;
-		u64 lboot_ckill:1;
-		u64 lboot_jtg:1;
-		u64 lboot_ext45:6;
-		u64 lboot_ext23:6;
-		u64 lboot:10;
-		u64 rboot:1;
-		u64 rboot_pin:1;
-#else /* Word 0 - Little Endian */
 		u64 rboot_pin:1;
 		u64 rboot:1;
 		u64 lboot:10;
@@ -214,7 +115,6 @@ union cavm_rst_boot {
 		u64 ejtagdis:1;
 		u64 jtcsrdis:1;
 		u64 chipkill:1;
-#endif /* Word 0 - End */
 	} cn83xx;
 };
 
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
new file mode 100644
index 0000000000..4dd8958d2f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs-mio_emm.h
@@ -0,0 +1,1199 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_MIO_EMM_H__
+#define __CSRS_MIO_EMM_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * MIO_EMM.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union mio_emm_access_wdog {
+	u64 u;
+	struct mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union mio_emm_buf_dat {
+	u64 u;
+	struct mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union mio_emm_buf_idx {
+	u64 u;
+	struct mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union mio_emm_calb {
+	u64 u;
+	struct mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct mio_emm_calb_s cn; */
+};
+
+static inline u64 MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union mio_emm_cfg {
+	u64 u;
+	struct mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union mio_emm_cmd {
+	u64 u;
+	struct mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union mio_emm_comp {
+	u64 u;
+	struct mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct mio_emm_comp_s cn; */
+};
+
+static inline u64 MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union mio_emm_debug {
+	u64 u;
+	struct mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 emmc_clk_disable                 : 1;
+		u64 rdsync_rst                       : 1;
+		u64 reserved_22_63                   : 42;
+	} s;
+	struct mio_emm_debug_cn96xxp1 {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} cn96xxp1;
+	/* struct mio_emm_debug_s cn96xxp3; */
+	/* struct mio_emm_debug_s cn98xx; */
+	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
+	/* struct mio_emm_debug_s loki; */
+};
+
+static inline u64 MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union mio_emm_dma {
+	u64 u;
+	struct mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union mio_emm_dma_adr {
+	u64 u;
+	struct mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union mio_emm_dma_arg {
+	u64 u;
+	struct mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union mio_emm_dma_cfg {
+	u64 u;
+	struct mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union mio_emm_dma_fifo_adr {
+	u64 u;
+	struct mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_dma_fifo_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union mio_emm_dma_int {
+	u64 u;
+	struct mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_dma_int_w1s {
+	u64 u;
+	struct mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union mio_emm_int {
+	u64 u;
+	struct mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union mio_emm_int_ena_w1c {
+	u64 u;
+	struct mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union mio_emm_int_ena_w1s {
+	u64 u;
+	struct mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_int_w1s {
+	u64 u;
+	struct mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union mio_emm_io_ctl {
+	u64 u;
+	struct mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union mio_emm_modex {
+	u64 u;
+	struct mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	struct mio_emm_modex_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} cn96xxp1;
+	/* struct mio_emm_modex_s cn96xxp3; */
+	/* struct mio_emm_modex_s cn98xx; */
+	/* struct mio_emm_modex_s cnf95xx; */
+	/* struct mio_emm_modex_s loki; */
+};
+
+static inline u64 MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_pbax {
+	u64 u;
+	struct mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_addr {
+	u64 u;
+	struct mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union mio_emm_rca {
+	u64 u;
+	struct mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct mio_emm_rca_s cn; */
+};
+
+static inline u64 MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union mio_emm_rsp_hi {
+	u64 u;
+	struct mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union mio_emm_rsp_lo {
+	u64 u;
+	struct mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union mio_emm_rsp_sts {
+	u64 u;
+	struct mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union mio_emm_sample {
+	u64 u;
+	struct mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_sample_s cn; */
+};
+
+static inline u64 MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union mio_emm_sts_mask {
+	u64 u;
+	struct mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union mio_emm_switch {
+	u64 u;
+	struct mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	struct mio_emm_switch_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn96xxp1;
+	/* struct mio_emm_switch_s cn96xxp3; */
+	/* struct mio_emm_switch_s cn98xx; */
+	/* struct mio_emm_switch_s cnf95xx; */
+	/* struct mio_emm_switch_s loki; */
+};
+
+static inline u64 MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union mio_emm_tap {
+	u64 u;
+	struct mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct mio_emm_tap_s cn; */
+};
+
+static inline u64 MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union mio_emm_timing {
+	u64 u;
+	struct mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct mio_emm_timing_s cn; */
+};
+
+static inline u64 MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union mio_emm_wdog {
+	u64 u;
+	struct mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-cgx.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
similarity index 72%
rename from drivers/net/octeontx2/cavm-csrs-cgx.h
rename to arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
index 13743276d3..281008365c 100644
--- a/drivers/net/octeontx2/cavm-csrs-cgx.h
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-cgx.h
@@ -1,18 +1,17 @@
-#ifndef __CAVM_CSRS_CGX_H__
-#define __CAVM_CSRS_CGX_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_CGX_H__
+#define __CSRS_CGX_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium CGX.
+ * CGX.
  *
  * This file is auto generated.  Do not edit.
  *
@@ -24,44 +23,45 @@
  * CGX Base Address Register Enumeration Enumerates the base address
  * registers.
  */
-#define CAVM_CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
-#define CAVM_CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
-#define CAVM_CGX_BAR_E_CGXX_PF_BAR4(a) (0x87e0e0400000ll + 0x1000000ll * (a))
-#define CAVM_CGX_BAR_E_CGXX_PF_BAR4_SIZE 0x100000ull
+#define CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
+#define CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
+#define CGX_BAR_E_CGXX_PF_BAR4(a) (0x87e0e0400000ll + 0x1000000ll * (a))
+#define CGX_BAR_E_CGXX_PF_BAR4_SIZE 0x100000ull
 
 /**
  * Enumeration cgx_int_vec_e
  *
  * CGX MSI-X Vector Enumeration Enumeration the MSI-X interrupt vectors.
  */
-#define CAVM_CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_CMR_MEM_INT (0x24)
-#define CAVM_CGX_INT_VEC_E_GMPX_GMI_RX_INT(a) (5 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_GMPX_GMI_TX_INT(a) (6 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_GMPX_GMI_WOL_INT(a) (7 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_GMPX_PCS_INT(a) (4 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_SMUX_RX_INT(a) (2 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_SMUX_RX_WOL_INT(a) (8 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_SMUX_TX_INT(a) (3 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_SPUX_INT(a) (1 + 9 * (a))
-#define CAVM_CGX_INT_VEC_E_SW (0x25)
+#define CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
+#define CGX_INT_VEC_E_CMRX_SW(a) (0x26 + (a))
+#define CGX_INT_VEC_E_CMR_MEM_INT (0x24)
+#define CGX_INT_VEC_E_GMPX_GMI_RX_INT(a) (5 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_GMI_TX_INT(a) (6 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_GMI_WOL_INT(a) (7 + 9 * (a))
+#define CGX_INT_VEC_E_GMPX_PCS_INT(a) (4 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_RX_INT(a) (2 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_RX_WOL_INT(a) (8 + 9 * (a))
+#define CGX_INT_VEC_E_SMUX_TX_INT(a) (3 + 9 * (a))
+#define CGX_INT_VEC_E_SPUX_INT(a) (1 + 9 * (a))
+#define CGX_INT_VEC_E_SW (0x25)
 
 /**
  * Enumeration cgx_lmac_types_e
  *
  * CGX LMAC Type Enumeration Enumerates the LMAC Types that CGX supports.
  */
-#define CAVM_CGX_LMAC_TYPES_E_FIFTYG_R (8)
-#define CAVM_CGX_LMAC_TYPES_E_FORTYG_R (4)
-#define CAVM_CGX_LMAC_TYPES_E_HUNDREDG_R (9)
-#define CAVM_CGX_LMAC_TYPES_E_QSGMII (6)
-#define CAVM_CGX_LMAC_TYPES_E_RGMII (5)
-#define CAVM_CGX_LMAC_TYPES_E_RXAUI (2)
-#define CAVM_CGX_LMAC_TYPES_E_SGMII (0)
-#define CAVM_CGX_LMAC_TYPES_E_TENG_R (3)
-#define CAVM_CGX_LMAC_TYPES_E_TWENTYFIVEG_R (7)
-#define CAVM_CGX_LMAC_TYPES_E_USXGMII (0xa)
-#define CAVM_CGX_LMAC_TYPES_E_XAUI (1)
+#define CGX_LMAC_TYPES_E_FIFTYG_R (8)
+#define CGX_LMAC_TYPES_E_FORTYG_R (4)
+#define CGX_LMAC_TYPES_E_HUNDREDG_R (9)
+#define CGX_LMAC_TYPES_E_QSGMII (6)
+#define CGX_LMAC_TYPES_E_RGMII (5)
+#define CGX_LMAC_TYPES_E_RXAUI (2)
+#define CGX_LMAC_TYPES_E_SGMII (0)
+#define CGX_LMAC_TYPES_E_TENG_R (3)
+#define CGX_LMAC_TYPES_E_TWENTYFIVEG_R (7)
+#define CGX_LMAC_TYPES_E_USXGMII (0xa)
+#define CGX_LMAC_TYPES_E_XAUI (1)
 
 /**
  * Enumeration cgx_opcode_e
@@ -69,14 +69,14 @@
  * INTERNAL: CGX Error Opcode Enumeration  Enumerates the error opcodes
  * created by CGX and presented to NCSI/NIX.
  */
-#define CAVM_CGX_OPCODE_E_RE_FCS (7)
-#define CAVM_CGX_OPCODE_E_RE_FCS_RCV (8)
-#define CAVM_CGX_OPCODE_E_RE_JABBER (2)
-#define CAVM_CGX_OPCODE_E_RE_NONE (0)
-#define CAVM_CGX_OPCODE_E_RE_PARTIAL (1)
-#define CAVM_CGX_OPCODE_E_RE_RX_CTL (0xb)
-#define CAVM_CGX_OPCODE_E_RE_SKIP (0xc)
-#define CAVM_CGX_OPCODE_E_RE_TERMINATE (9)
+#define CGX_OPCODE_E_RE_FCS (7)
+#define CGX_OPCODE_E_RE_FCS_RCV (8)
+#define CGX_OPCODE_E_RE_JABBER (2)
+#define CGX_OPCODE_E_RE_NONE (0)
+#define CGX_OPCODE_E_RE_PARTIAL (1)
+#define CGX_OPCODE_E_RE_RX_CTL (0xb)
+#define CGX_OPCODE_E_RE_SKIP (0xc)
+#define CGX_OPCODE_E_RE_TERMINATE (9)
 
 /**
  * Enumeration cgx_spu_br_train_cst_e
@@ -84,10 +84,10 @@
  * CGX Training Coefficient Status Enumeration 2-bit status for each
  * coefficient as defined in IEEE 802.3, Table 72-5.
  */
-#define CAVM_CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
-#define CAVM_CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
-#define CAVM_CGX_SPU_BR_TRAIN_CST_E_NOT_UPDATED (0)
-#define CAVM_CGX_SPU_BR_TRAIN_CST_E_UPDATED (1)
+#define CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
+#define CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
+#define CGX_SPU_BR_TRAIN_CST_E_NOT_UPDATED (0)
+#define CGX_SPU_BR_TRAIN_CST_E_UPDATED (1)
 
 /**
  * Enumeration cgx_spu_br_train_cup_e
@@ -95,10 +95,10 @@
  * CGX Training Coefficient Enumeration 2-bit command for each
  * coefficient as defined in IEEE 802.3, Table 72-4.
  */
-#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
-#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
-#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_INCREMENT (2)
-#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_RSV_CMD (3)
+#define CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
+#define CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
+#define CGX_SPU_BR_TRAIN_CUP_E_INCREMENT (2)
+#define CGX_SPU_BR_TRAIN_CUP_E_RSV_CMD (3)
 
 /**
  * Enumeration cgx_usxgmii_rate_e
@@ -111,14 +111,14 @@
  * behavior. USXGMII hardware-based autonegotiation may change this
  * setting.
  */
-#define CAVM_CGX_USXGMII_RATE_E_RATE_100M (1)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_10G (5)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_10M (0)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_1G (2)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_20G (6)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_2HG (3)
-#define CAVM_CGX_USXGMII_RATE_E_RATE_5G (4)
-#define CAVM_CGX_USXGMII_RATE_E_RSV_RATE (7)
+#define CGX_USXGMII_RATE_E_RATE_100M (1)
+#define CGX_USXGMII_RATE_E_RATE_10G (5)
+#define CGX_USXGMII_RATE_E_RATE_10M (0)
+#define CGX_USXGMII_RATE_E_RATE_1G (2)
+#define CGX_USXGMII_RATE_E_RATE_20G (6)
+#define CGX_USXGMII_RATE_E_RATE_2HG (3)
+#define CGX_USXGMII_RATE_E_RATE_5G (4)
+#define CGX_USXGMII_RATE_E_RSV_RATE (7)
 
 /**
  * Enumeration cgx_usxgmii_type_e
@@ -134,14 +134,14 @@
  * more LMACs than the maximum allowed for a given port sub-type will
  * cause unpredictable behavior.
  */
-#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_10G (3)
-#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_20G (5)
-#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_5G (4)
-#define CAVM_CGX_USXGMII_TYPE_E_QXGMII_10G (7)
-#define CAVM_CGX_USXGMII_TYPE_E_QXGMII_20G (6)
-#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_10G (0)
-#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_2G (2)
-#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_5G (1)
+#define CGX_USXGMII_TYPE_E_DXGMII_10G (3)
+#define CGX_USXGMII_TYPE_E_DXGMII_20G (5)
+#define CGX_USXGMII_TYPE_E_DXGMII_5G (4)
+#define CGX_USXGMII_TYPE_E_QXGMII_10G (7)
+#define CGX_USXGMII_TYPE_E_QXGMII_20G (6)
+#define CGX_USXGMII_TYPE_E_SXGMII_10G (0)
+#define CGX_USXGMII_TYPE_E_SXGMII_2G (2)
+#define CGX_USXGMII_TYPE_E_SXGMII_5G (1)
 
 /**
  * Structure cgx_spu_br_lane_train_status_s
@@ -150,28 +150,28 @@
  * bits for a single lane in the BASE-R PMD status register (MDIO address
  * 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
  */
-union cavm_cgx_spu_br_lane_train_status_s {
+union cgx_spu_br_lane_train_status_s {
 	u32 u;
-	struct cavm_cgx_spu_br_lane_train_status_s_s {
+	struct cgx_spu_br_lane_train_status_s_s {
 		u32 rx_trained                       : 1;
 		u32 frame_lock                       : 1;
 		u32 training                         : 1;
 		u32 training_failure                 : 1;
 		u32 reserved_4_31                    : 28;
 	} s;
-	/* struct cavm_cgx_spu_br_lane_train_status_s_s cn; */
+	/* struct cgx_spu_br_lane_train_status_s_s cn; */
 };
 
 /**
  * Structure cgx_spu_br_train_cup_s
  *
- * CGX Lane Training Coeffiecient Structure This is the coefficient
- * update field of the BASE-R link training packet as defined in IEEE
- * 802.3, Table 72-4.
+ * CGX Lane Training Coefficient Structure This is the coefficient update
+ * field of the BASE-R link training packet as defined in IEEE 802.3,
+ * Table 72-4.
  */
-union cavm_cgx_spu_br_train_cup_s {
+union cgx_spu_br_train_cup_s {
 	u32 u;
-	struct cavm_cgx_spu_br_train_cup_s_s {
+	struct cgx_spu_br_train_cup_s_s {
 		u32 pre_cup                          : 2;
 		u32 main_cup                         : 2;
 		u32 post_cup                         : 2;
@@ -180,7 +180,7 @@ union cavm_cgx_spu_br_train_cup_s {
 		u32 preset                           : 1;
 		u32 reserved_14_31                   : 18;
 	} s;
-	struct cavm_cgx_spu_br_train_cup_s_cn {
+	struct cgx_spu_br_train_cup_s_cn {
 		u32 pre_cup                          : 2;
 		u32 main_cup                         : 2;
 		u32 post_cup                         : 2;
@@ -198,9 +198,9 @@ union cavm_cgx_spu_br_train_cup_s {
  * CGX Training Report Structure This is the status report field of the
  * BASE-R link training packet as defined in IEEE 802.3, Table 72-5.
  */
-union cavm_cgx_spu_br_train_rep_s {
+union cgx_spu_br_train_rep_s {
 	u32 u;
-	struct cavm_cgx_spu_br_train_rep_s_s {
+	struct cgx_spu_br_train_rep_s_s {
 		u32 pre_cst                          : 2;
 		u32 main_cst                         : 2;
 		u32 post_cst                         : 2;
@@ -208,7 +208,7 @@ union cavm_cgx_spu_br_train_rep_s {
 		u32 rx_ready                         : 1;
 		u32 reserved_16_31                   : 16;
 	} s;
-	/* struct cavm_cgx_spu_br_train_rep_s_s cn; */
+	/* struct cgx_spu_br_train_rep_s_s cn; */
 };
 
 /**
@@ -218,9 +218,9 @@ union cavm_cgx_spu_br_train_rep_s {
  * similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields
  * removed and [RCVR_READY] field added.
  */
-union cavm_cgx_spu_sds_cu_s {
+union cgx_spu_sds_cu_s {
 	u32 u;
-	struct cavm_cgx_spu_sds_cu_s_s {
+	struct cgx_spu_sds_cu_s_s {
 		u32 pre_cu                           : 2;
 		u32 main_cu                          : 2;
 		u32 post_cu                          : 2;
@@ -229,7 +229,7 @@ union cavm_cgx_spu_sds_cu_s {
 		u32 rcvr_ready                       : 1;
 		u32 reserved_9_31                    : 23;
 	} s;
-	/* struct cavm_cgx_spu_sds_cu_s_s cn; */
+	/* struct cgx_spu_sds_cu_s_s cn; */
 };
 
 /**
@@ -240,9 +240,9 @@ union cavm_cgx_spu_sds_cu_s {
  * LMAC/LPCS. Contents are valid when RX deskew is done for the
  * associated LMAC/LPCS.
  */
-union cavm_cgx_spu_sds_skew_status_s {
+union cgx_spu_sds_skew_status_s {
 	u32 u;
-	struct cavm_cgx_spu_sds_skew_status_s_s {
+	struct cgx_spu_sds_skew_status_s_s {
 		u32 am_timestamp                     : 12;
 		u32 reserved_12_15                   : 4;
 		u32 am_lane_id                       : 5;
@@ -250,7 +250,7 @@ union cavm_cgx_spu_sds_skew_status_s {
 		u32 lane_skew                        : 7;
 		u32 reserved_30_31                   : 2;
 	} s;
-	/* struct cavm_cgx_spu_sds_skew_status_s_s cn; */
+	/* struct cgx_spu_sds_skew_status_s_s cn; */
 };
 
 /**
@@ -260,15 +260,15 @@ union cavm_cgx_spu_sds_skew_status_s {
  * CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields
  * removed.
  */
-union cavm_cgx_spu_sds_sr_s {
+union cgx_spu_sds_sr_s {
 	u32 u;
-	struct cavm_cgx_spu_sds_sr_s_s {
+	struct cgx_spu_sds_sr_s_s {
 		u32 pre_status                       : 2;
 		u32 main_status                      : 2;
 		u32 post_status                      : 2;
 		u32 reserved_6_31                    : 26;
 	} s;
-	/* struct cavm_cgx_spu_sds_sr_s_s cn; */
+	/* struct cgx_spu_sds_sr_s_s cn; */
 };
 
 /**
@@ -277,17 +277,17 @@ union cavm_cgx_spu_sds_sr_s {
  * CGX ACTIVE PC Register This register counts the conditional clocks for
  * power management.
  */
-union cavm_cgxx_active_pc {
+union cgxx_active_pc {
 	u64 u;
-	struct cavm_cgxx_active_pc_s {
+	struct cgxx_active_pc_s {
 		u64 cnt                              : 64;
 	} s;
-	/* struct cavm_cgxx_active_pc_s cn; */
+	/* struct cgxx_active_pc_s cn; */
 };
 
-static inline u64 CAVM_CGXX_ACTIVE_PC(void)
+static inline u64 CGXX_ACTIVE_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_ACTIVE_PC(void)
+static inline u64 CGXX_ACTIVE_PC(void)
 {
 	return 0x2010;
 }
@@ -297,9 +297,9 @@ static inline u64 CAVM_CGXX_ACTIVE_PC(void)
  *
  * CGX CMR Activity Registers
  */
-union cavm_cgxx_cmrx_activity {
+union cgxx_cmrx_activity {
 	u64 u;
-	struct cavm_cgxx_cmrx_activity_s {
+	struct cgxx_cmrx_activity_s {
 		u64 act_tx_lo                        : 1;
 		u64 act_tx_hi                        : 1;
 		u64 pause_tx                         : 1;
@@ -308,12 +308,12 @@ union cavm_cgxx_cmrx_activity {
 		u64 pause_rx                         : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_cmrx_activity_s cn; */
+	/* struct cgxx_cmrx_activity_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
+static inline u64 CGXX_CMRX_ACTIVITY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
+static inline u64 CGXX_CMRX_ACTIVITY(u64 a)
 {
 	return 0x5f8 + 0x40000 * a;
 }
@@ -385,9 +385,9 @@ static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
  * CGXn_CMR3_CONFIG     1           0   ---------------------------------
  * ------------------------------------------ \</pre\>
  */
-union cavm_cgxx_cmrx_config {
+union cgxx_cmrx_config {
 	u64 u;
-	struct cavm_cgxx_cmrx_config_s {
+	struct cgxx_cmrx_config_s {
 		u64 lane_to_sds                      : 8;
 		u64 reserved_8_39                    : 32;
 		u64 lmac_type                        : 4;
@@ -400,12 +400,12 @@ union cavm_cgxx_cmrx_config {
 		u64 p2x_select                       : 3;
 		u64 reserved_62_63                   : 2;
 	} s;
-	/* struct cavm_cgxx_cmrx_config_s cn; */
+	/* struct cgxx_cmrx_config_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_CONFIG(u64 a)
+static inline u64 CGXX_CMRX_CONFIG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_CONFIG(u64 a)
+static inline u64 CGXX_CMRX_CONFIG(u64 a)
 {
 	return 0 + 0x40000 * a;
 }
@@ -415,9 +415,9 @@ static inline u64 CAVM_CGXX_CMRX_CONFIG(u64 a)
  *
  * CGX CMR Interrupt Register
  */
-union cavm_cgxx_cmrx_int {
+union cgxx_cmrx_int {
 	u64 u;
-	struct cavm_cgxx_cmrx_int_s {
+	struct cgxx_cmrx_int_s {
 		u64 pause_drp                        : 1;
 		u64 overflw                          : 1;
 		u64 nic_nxc                          : 1;
@@ -427,12 +427,12 @@ union cavm_cgxx_cmrx_int {
 		u64 nix1_e_nxc                       : 1;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_int_s cn; */
+	/* struct cgxx_cmrx_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
+static inline u64 CGXX_CMRX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
+static inline u64 CGXX_CMRX_INT(u64 a)
 {
 	return 0x40 + 0x40000 * a;
 }
@@ -443,9 +443,9 @@ static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
  * CGX CMR Interrupt Enable Clear Register This register clears interrupt
  * enable bits.
  */
-union cavm_cgxx_cmrx_int_ena_w1c {
+union cgxx_cmrx_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_cmrx_int_ena_w1c_s {
+	struct cgxx_cmrx_int_ena_w1c_s {
 		u64 pause_drp                        : 1;
 		u64 overflw                          : 1;
 		u64 nic_nxc                          : 1;
@@ -455,12 +455,12 @@ union cavm_cgxx_cmrx_int_ena_w1c {
 		u64 nix1_e_nxc                       : 1;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_int_ena_w1c_s cn; */
+	/* struct cgxx_cmrx_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_CMRX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_CMRX_INT_ENA_W1C(u64 a)
 {
 	return 0x50 + 0x40000 * a;
 }
@@ -471,9 +471,9 @@ static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
  * CGX CMR Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_cgxx_cmrx_int_ena_w1s {
+union cgxx_cmrx_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_cmrx_int_ena_w1s_s {
+	struct cgxx_cmrx_int_ena_w1s_s {
 		u64 pause_drp                        : 1;
 		u64 overflw                          : 1;
 		u64 nic_nxc                          : 1;
@@ -483,12 +483,12 @@ union cavm_cgxx_cmrx_int_ena_w1s {
 		u64 nix1_e_nxc                       : 1;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_int_ena_w1s_s cn; */
+	/* struct cgxx_cmrx_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_CMRX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_CMRX_INT_ENA_W1S(u64 a)
 {
 	return 0x58 + 0x40000 * a;
 }
@@ -498,9 +498,9 @@ static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
  *
  * CGX CMR Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_cgxx_cmrx_int_w1s {
+union cgxx_cmrx_int_w1s {
 	u64 u;
-	struct cavm_cgxx_cmrx_int_w1s_s {
+	struct cgxx_cmrx_int_w1s_s {
 		u64 pause_drp                        : 1;
 		u64 overflw                          : 1;
 		u64 nic_nxc                          : 1;
@@ -510,12 +510,12 @@ union cavm_cgxx_cmrx_int_w1s {
 		u64 nix1_e_nxc                       : 1;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_int_w1s_s cn; */
+	/* struct cgxx_cmrx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_INT_W1S(u64 a)
+static inline u64 CGXX_CMRX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_INT_W1S(u64 a)
+static inline u64 CGXX_CMRX_INT_W1S(u64 a)
 {
 	return 0x48 + 0x40000 * a;
 }
@@ -525,18 +525,18 @@ static inline u64 CAVM_CGXX_CMRX_INT_W1S(u64 a)
  *
  * CGX MAC LED Activity Timing Registers
  */
-union cavm_cgxx_cmrx_led_timing {
+union cgxx_cmrx_led_timing {
 	u64 u;
-	struct cavm_cgxx_cmrx_led_timing_s {
+	struct cgxx_cmrx_led_timing_s {
 		u64 extension                        : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_cgxx_cmrx_led_timing_s cn; */
+	/* struct cgxx_cmrx_led_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
+static inline u64 CGXX_CMRX_LED_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
+static inline u64 CGXX_CMRX_LED_TIMING(u64 a)
 {
 	return 0x5f0 + 0x40000 * a;
 }
@@ -546,19 +546,19 @@ static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
  *
  * CGX CMR LMAC PFC Control Registers See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
  */
-union cavm_cgxx_cmrx_prt_cbfc_ctl {
+union cgxx_cmrx_prt_cbfc_ctl {
 	u64 u;
-	struct cavm_cgxx_cmrx_prt_cbfc_ctl_s {
+	struct cgxx_cmrx_prt_cbfc_ctl_s {
 		u64 reserved_0_15                    : 16;
 		u64 phys_bp                          : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_cmrx_prt_cbfc_ctl_s cn; */
+	/* struct cgxx_cmrx_prt_cbfc_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+static inline u64 CGXX_CMRX_PRT_CBFC_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+static inline u64 CGXX_CMRX_PRT_CBFC_CTL(u64 a)
 {
 	return 0x608 + 0x40000 * a;
 }
@@ -568,18 +568,18 @@ static inline u64 CAVM_CGXX_CMRX_PRT_CBFC_CTL(u64 a)
  *
  * CGX Receive Backpressure Drop Register
  */
-union cavm_cgxx_cmrx_rx_bp_drop {
+union cgxx_cmrx_rx_bp_drop {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_bp_drop_s {
+	struct cgxx_cmrx_rx_bp_drop_s {
 		u64 mark                             : 7;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_bp_drop_s cn; */
+	/* struct cgxx_cmrx_rx_bp_drop_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_BP_DROP(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_DROP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_BP_DROP(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_DROP(u64 a)
 {
 	return 0xd8 + 0x40000 * a;
 }
@@ -589,18 +589,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_BP_DROP(u64 a)
  *
  * CGX Receive Backpressure Off Register
  */
-union cavm_cgxx_cmrx_rx_bp_off {
+union cgxx_cmrx_rx_bp_off {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_bp_off_s {
+	struct cgxx_cmrx_rx_bp_off_s {
 		u64 mark                             : 7;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_bp_off_s cn; */
+	/* struct cgxx_cmrx_rx_bp_off_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_BP_OFF(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_OFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_BP_OFF(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_OFF(u64 a)
 {
 	return 0xe8 + 0x40000 * a;
 }
@@ -610,18 +610,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_BP_OFF(u64 a)
  *
  * CGX Receive Backpressure On Register
  */
-union cavm_cgxx_cmrx_rx_bp_on {
+union cgxx_cmrx_rx_bp_on {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_bp_on_s {
+	struct cgxx_cmrx_rx_bp_on_s {
 		u64 mark                             : 13;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_bp_on_s cn; */
+	/* struct cgxx_cmrx_rx_bp_on_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_BP_ON(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_ON(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_BP_ON(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_ON(u64 a)
 {
 	return 0xe0 + 0x40000 * a;
 }
@@ -631,18 +631,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_BP_ON(u64 a)
  *
  * CGX CMR Receive Backpressure Status Registers
  */
-union cavm_cgxx_cmrx_rx_bp_status {
+union cgxx_cmrx_rx_bp_status {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_bp_status_s {
+	struct cgxx_cmrx_rx_bp_status_s {
 		u64 bp                               : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_bp_status_s cn; */
+	/* struct cgxx_cmrx_rx_bp_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
+static inline u64 CGXX_CMRX_RX_BP_STATUS(u64 a)
 {
 	return 0xf0 + 0x40000 * a;
 }
@@ -671,20 +671,20 @@ static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
  * return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
  * } } \</pre\>"
  */
-union cavm_cgxx_cmrx_rx_dmac_ctl0 {
+union cgxx_cmrx_rx_dmac_ctl0 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_dmac_ctl0_s {
+	struct cgxx_cmrx_rx_dmac_ctl0_s {
 		u64 bcst_accept                      : 1;
 		u64 mcst_mode                        : 2;
 		u64 cam_accept                       : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_dmac_ctl0_s cn; */
+	/* struct cgxx_cmrx_rx_dmac_ctl0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+static inline u64 CGXX_CMRX_RX_DMAC_CTL0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+static inline u64 CGXX_CMRX_RX_DMAC_CTL0(u64 a)
 {
 	return 0x1f8 + 0x40000 * a;
 }
@@ -700,20 +700,20 @@ static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
  * see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
  * CGX()_CMR()_RX_DMAC_CTL0.
  */
-union cavm_cgxx_cmrx_rx_dmac_ctl1 {
+union cgxx_cmrx_rx_dmac_ctl1 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_dmac_ctl1_s {
+	struct cgxx_cmrx_rx_dmac_ctl1_s {
 		u64 bcst_accept                      : 1;
 		u64 mcst_mode                        : 2;
 		u64 cam_accept                       : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_dmac_ctl1_s cn; */
+	/* struct cgxx_cmrx_rx_dmac_ctl1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+static inline u64 CGXX_CMRX_RX_DMAC_CTL1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+static inline u64 CGXX_CMRX_RX_DMAC_CTL1(u64 a)
 {
 	return 0x3f8 + 0x40000 * a;
 }
@@ -723,21 +723,21 @@ static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL1(u64 a)
  *
  * CGX CMR Receive Fifo Length Registers
  */
-union cavm_cgxx_cmrx_rx_fifo_len {
+union cgxx_cmrx_rx_fifo_len {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_fifo_len_s {
+	struct cgxx_cmrx_rx_fifo_len_s {
 		u64 fifo_len                         : 14;
 		u64 busy                             : 1;
 		u64 fifo_len_e                       : 14;
 		u64 busy_e                           : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_fifo_len_s cn; */
+	/* struct cgxx_cmrx_rx_fifo_len_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
+static inline u64 CGXX_CMRX_RX_FIFO_LEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
+static inline u64 CGXX_CMRX_RX_FIFO_LEN(u64 a)
 {
 	return 0x108 + 0x40000 * a;
 }
@@ -748,20 +748,20 @@ static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
  * CGX CMR Receive ID Map Register These registers set the RX LMAC ID
  * mapping for X2P/NIX.
  */
-union cavm_cgxx_cmrx_rx_id_map {
+union cgxx_cmrx_rx_id_map {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_id_map_s {
+	struct cgxx_cmrx_rx_id_map_s {
 		u64 pknd                             : 6;
 		u64 unused                           : 2;
 		u64 rid                              : 7;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_id_map_s cn; */
+	/* struct cgxx_cmrx_rx_id_map_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_ID_MAP(u64 a)
+static inline u64 CGXX_CMRX_RX_ID_MAP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_ID_MAP(u64 a)
+static inline u64 CGXX_CMRX_RX_ID_MAP(u64 a)
 {
 	return 0x60 + 0x40000 * a;
 }
@@ -771,18 +771,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_ID_MAP(u64 a)
  *
  * CGX CMR Receive Logical XOFF Registers
  */
-union cavm_cgxx_cmrx_rx_logl_xoff {
+union cgxx_cmrx_rx_logl_xoff {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_logl_xoff_s {
+	struct cgxx_cmrx_rx_logl_xoff_s {
 		u64 xoff                             : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_logl_xoff_s cn; */
+	/* struct cgxx_cmrx_rx_logl_xoff_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+static inline u64 CGXX_CMRX_RX_LOGL_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+static inline u64 CGXX_CMRX_RX_LOGL_XOFF(u64 a)
 {
 	return 0xf8 + 0x40000 * a;
 }
@@ -792,18 +792,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XOFF(u64 a)
  *
  * CGX CMR Receive Logical XON Registers
  */
-union cavm_cgxx_cmrx_rx_logl_xon {
+union cgxx_cmrx_rx_logl_xon {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_logl_xon_s {
+	struct cgxx_cmrx_rx_logl_xon_s {
 		u64 xon                              : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_logl_xon_s cn; */
+	/* struct cgxx_cmrx_rx_logl_xon_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XON(u64 a)
+static inline u64 CGXX_CMRX_RX_LOGL_XON(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XON(u64 a)
+static inline u64 CGXX_CMRX_RX_LOGL_XON(u64 a)
 {
 	return 0x100 + 0x40000 * a;
 }
@@ -813,18 +813,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XON(u64 a)
  *
  * CGX RX Preemption Status Register 0
  */
-union cavm_cgxx_cmrx_rx_merge_stat0 {
+union cgxx_cmrx_rx_merge_stat0 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_merge_stat0_s {
+	struct cgxx_cmrx_rx_merge_stat0_s {
 		u64 fa_err_cnt                       : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_merge_stat0_s cn; */
+	/* struct cgxx_cmrx_rx_merge_stat0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT0(u64 a)
 {
 	return 0x138 + 0x40000 * a;
 }
@@ -834,18 +834,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT0(u64 a)
  *
  * CGX RX Preemption Status Register 1
  */
-union cavm_cgxx_cmrx_rx_merge_stat1 {
+union cgxx_cmrx_rx_merge_stat1 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_merge_stat1_s {
+	struct cgxx_cmrx_rx_merge_stat1_s {
 		u64 fs_err_cnt                       : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_merge_stat1_s cn; */
+	/* struct cgxx_cmrx_rx_merge_stat1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT1(u64 a)
 {
 	return 0x140 + 0x40000 * a;
 }
@@ -855,18 +855,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT1(u64 a)
  *
  * CGX RX Preemption Status Register 2
  */
-union cavm_cgxx_cmrx_rx_merge_stat2 {
+union cgxx_cmrx_rx_merge_stat2 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_merge_stat2_s {
+	struct cgxx_cmrx_rx_merge_stat2_s {
 		u64 fa_ok_cnt                        : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_merge_stat2_s cn; */
+	/* struct cgxx_cmrx_rx_merge_stat2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT2(u64 a)
 {
 	return 0x148 + 0x40000 * a;
 }
@@ -876,18 +876,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT2(u64 a)
  *
  * CGX RX Preemption Status Register 3
  */
-union cavm_cgxx_cmrx_rx_merge_stat3 {
+union cgxx_cmrx_rx_merge_stat3 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_merge_stat3_s {
+	struct cgxx_cmrx_rx_merge_stat3_s {
 		u64 ff_cnt                           : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_merge_stat3_s cn; */
+	/* struct cgxx_cmrx_rx_merge_stat3_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT3(u64 a)
 {
 	return 0x150 + 0x40000 * a;
 }
@@ -897,18 +897,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT3(u64 a)
  *
  * CGX RX Preemption Status Register 4
  */
-union cavm_cgxx_cmrx_rx_merge_stat4 {
+union cgxx_cmrx_rx_merge_stat4 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_merge_stat4_s {
+	struct cgxx_cmrx_rx_merge_stat4_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_merge_stat4_s cn; */
+	/* struct cgxx_cmrx_rx_merge_stat4_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT4(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+static inline u64 CGXX_CMRX_RX_MERGE_STAT4(u64 a)
 {
 	return 0x158 + 0x40000 * a;
 }
@@ -918,19 +918,19 @@ static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT4(u64 a)
  *
  * CGX CMR Receive Pause Drop-Time Register
  */
-union cavm_cgxx_cmrx_rx_pause_drop_time {
+union cgxx_cmrx_rx_pause_drop_time {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_pause_drop_time_s {
+	struct cgxx_cmrx_rx_pause_drop_time_s {
 		u64 pause_time                       : 16;
 		u64 pause_time_e                     : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_pause_drop_time_s cn; */
+	/* struct cgxx_cmrx_rx_pause_drop_time_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+static inline u64 CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+static inline u64 CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
 {
 	return 0x68 + 0x40000 * a;
 }
@@ -949,18 +949,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
  * drop)   incr RX_STAT4,5 if not a filter+decision else   incr
  * RX_STAT0,1 end \</pre\>"
  */
-union cavm_cgxx_cmrx_rx_stat0 {
+union cgxx_cmrx_rx_stat0 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat0_s {
+	struct cgxx_cmrx_rx_stat0_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat0_s cn; */
+	/* struct cgxx_cmrx_rx_stat0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT0(u64 a)
 {
 	return 0x70 + 0x40000 * a;
 }
@@ -971,18 +971,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
  * CGX Receive Status Register 1 These registers provide a count of
  * octets of received packets.
  */
-union cavm_cgxx_cmrx_rx_stat1 {
+union cgxx_cmrx_rx_stat1 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat1_s {
+	struct cgxx_cmrx_rx_stat1_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat1_s cn; */
+	/* struct cgxx_cmrx_rx_stat1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT1(u64 a)
 {
 	return 0x78 + 0x40000 * a;
 }
@@ -998,18 +998,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
  * CGX()_SMU()_RX_FRM_CTL[CTL_DRP]/CGX()_GMP_GMI_RX()_FRM_CTL[CTL_DRP].
  * This count increments regardless of whether the packet is dropped.
  */
-union cavm_cgxx_cmrx_rx_stat2 {
+union cgxx_cmrx_rx_stat2 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat2_s {
+	struct cgxx_cmrx_rx_stat2_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat2_s cn; */
+	/* struct cgxx_cmrx_rx_stat2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT2(u64 a)
 {
 	return 0x80 + 0x40000 * a;
 }
@@ -1020,18 +1020,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
  * CGX Receive Status Register 3 These registers provide a count of
  * octets of received PAUSE and control packets.
  */
-union cavm_cgxx_cmrx_rx_stat3 {
+union cgxx_cmrx_rx_stat3 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat3_s {
+	struct cgxx_cmrx_rx_stat3_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat3_s cn; */
+	/* struct cgxx_cmrx_rx_stat3_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT3(u64 a)
 {
 	return 0x88 + 0x40000 * a;
 }
@@ -1050,18 +1050,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
  * be filtered upon decision before the end of packet, then STAT4 and
  * STAT5 will not be updated.
  */
-union cavm_cgxx_cmrx_rx_stat4 {
+union cgxx_cmrx_rx_stat4 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat4_s {
+	struct cgxx_cmrx_rx_stat4_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat4_s cn; */
+	/* struct cgxx_cmrx_rx_stat4_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT4(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT4(u64 a)
 {
 	return 0x90 + 0x40000 * a;
 }
@@ -1072,18 +1072,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
  * CGX Receive Status Register 5 These registers provide a count of
  * octets of filtered DMAC0 or VLAN STEERING0 packets.
  */
-union cavm_cgxx_cmrx_rx_stat5 {
+union cgxx_cmrx_rx_stat5 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat5_s {
+	struct cgxx_cmrx_rx_stat5_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat5_s cn; */
+	/* struct cgxx_cmrx_rx_stat5_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT5(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT5(u64 a)
 {
 	return 0x98 + 0x40000 * a;
 }
@@ -1100,18 +1100,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
  * STAT8. These registers count all entire packets dropped by the FIFO
  * for a given LMAC.
  */
-union cavm_cgxx_cmrx_rx_stat6 {
+union cgxx_cmrx_rx_stat6 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat6_s {
+	struct cgxx_cmrx_rx_stat6_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat6_s cn; */
+	/* struct cgxx_cmrx_rx_stat6_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT6(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT6(u64 a)
 {
 	return 0xa0 + 0x40000 * a;
 }
@@ -1123,18 +1123,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
  * octets of received packets that were dropped due to a full receive
  * FIFO.
  */
-union cavm_cgxx_cmrx_rx_stat7 {
+union cgxx_cmrx_rx_stat7 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat7_s {
+	struct cgxx_cmrx_rx_stat7_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat7_s cn; */
+	/* struct cgxx_cmrx_rx_stat7_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT7(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT7(u64 a)
 {
 	return 0xa8 + 0x40000 * a;
 }
@@ -1146,18 +1146,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
  * received packets that meet the following conditions:  * are recognized
  * as ERROR packets(any OPCODE).
  */
-union cavm_cgxx_cmrx_rx_stat8 {
+union cgxx_cmrx_rx_stat8 {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat8_s {
+	struct cgxx_cmrx_rx_stat8_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat8_s cn; */
+	/* struct cgxx_cmrx_rx_stat8_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT8(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT8(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT8(u64 a)
+static inline u64 CGXX_CMRX_RX_STAT8(u64 a)
 {
 	return 0xb0 + 0x40000 * a;
 }
@@ -1167,18 +1167,18 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT8(u64 a)
  *
  * CGX CMR RX XON to XOFF transition Registers
  */
-union cavm_cgxx_cmrx_rx_stat_prix_xoff {
+union cgxx_cmrx_rx_stat_prix_xoff {
 	u64 u;
-	struct cavm_cgxx_cmrx_rx_stat_prix_xoff_s {
+	struct cgxx_cmrx_rx_stat_prix_xoff_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_rx_stat_prix_xoff_s cn; */
+	/* struct cgxx_cmrx_rx_stat_prix_xoff_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+static inline u64 CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+static inline u64 CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
 {
 	return 0x7c0 + 0x40000 * a + 8 * b;
 }
@@ -1188,38 +1188,124 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
  *
  * CGX CMR Scratch Registers
  */
-union cavm_cgxx_cmrx_scratchx {
+union cgxx_cmrx_scratchx {
 	u64 u;
-	struct cavm_cgxx_cmrx_scratchx_s {
+	struct cgxx_cmrx_scratchx_s {
 		u64 scratch                          : 64;
 	} s;
-	/* struct cavm_cgxx_cmrx_scratchx_s cn; */
+	/* struct cgxx_cmrx_scratchx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+static inline u64 CGXX_CMRX_SCRATCHX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+static inline u64 CGXX_CMRX_SCRATCHX(u64 a, u64 b)
 {
 	return 0x1050 + 0x40000 * a + 8 * b;
 }
 
+/**
+ * Register (RSL) cgx#_cmr#_sw_int
+ *
+ * CGX CMR Interrupt Register
+ */
+union cgxx_cmrx_sw_int {
+	u64 u;
+	struct cgxx_cmrx_sw_int_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT(u64 a)
+{
+	return 0x180 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_ena_w1c
+ *
+ * CGX CMR Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_sw_int_ena_w1c {
+	u64 u;
+	struct cgxx_cmrx_sw_int_ena_w1c_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_ena_w1c_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1C(u64 a)
+{
+	return 0x190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_ena_w1s
+ *
+ * CGX CMR Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cgxx_cmrx_sw_int_ena_w1s {
+	u64 u;
+	struct cgxx_cmrx_sw_int_ena_w1s_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_ena_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_ENA_W1S(u64 a)
+{
+	return 0x198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_sw_int_w1s
+ *
+ * CGX CMR Interrupt Set Register This register sets interrupt bits.
+ */
+union cgxx_cmrx_sw_int_w1s {
+	u64 u;
+	struct cgxx_cmrx_sw_int_w1s_s {
+		u64 sw_set                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cgxx_cmrx_sw_int_w1s_s cn; */
+};
+
+static inline u64 CGXX_CMRX_SW_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CGXX_CMRX_SW_INT_W1S(u64 a)
+{
+	return 0x188 + 0x40000 * a;
+}
+
 /**
  * Register (RSL) cgx#_cmr#_tx_channel
  *
  * CGX CMR Transmit-Channels Registers
  */
-union cavm_cgxx_cmrx_tx_channel {
+union cgxx_cmrx_tx_channel {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_channel_s {
+	struct cgxx_cmrx_tx_channel_s {
 		u64 msk                              : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_channel_s cn; */
+	/* struct cgxx_cmrx_tx_channel_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_CHANNEL(u64 a)
+static inline u64 CGXX_CMRX_TX_CHANNEL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_CHANNEL(u64 a)
+static inline u64 CGXX_CMRX_TX_CHANNEL(u64 a)
 {
 	return 0x600 + 0x40000 * a;
 }
@@ -1229,21 +1315,21 @@ static inline u64 CAVM_CGXX_CMRX_TX_CHANNEL(u64 a)
  *
  * CGX CMR Transmit Fifo Length Registers
  */
-union cavm_cgxx_cmrx_tx_fifo_len {
+union cgxx_cmrx_tx_fifo_len {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_fifo_len_s {
+	struct cgxx_cmrx_tx_fifo_len_s {
 		u64 fifo_len                         : 14;
 		u64 lmac_idle                        : 1;
 		u64 fifo_e_len                       : 14;
 		u64 lmac_e_idle                      : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_fifo_len_s cn; */
+	/* struct cgxx_cmrx_tx_fifo_len_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_FIFO_LEN(u64 a)
+static inline u64 CGXX_CMRX_TX_FIFO_LEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_FIFO_LEN(u64 a)
+static inline u64 CGXX_CMRX_TX_FIFO_LEN(u64 a)
 {
 	return 0x618 + 0x40000 * a;
 }
@@ -1253,19 +1339,19 @@ static inline u64 CAVM_CGXX_CMRX_TX_FIFO_LEN(u64 a)
  *
  * CGX CMR Transmit HiGig2 Status Registers
  */
-union cavm_cgxx_cmrx_tx_hg2_status {
+union cgxx_cmrx_tx_hg2_status {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_hg2_status_s {
+	struct cgxx_cmrx_tx_hg2_status_s {
 		u64 lgtim2go                         : 16;
 		u64 xof                              : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_hg2_status_s cn; */
+	/* struct cgxx_cmrx_tx_hg2_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_HG2_STATUS(u64 a)
+static inline u64 CGXX_CMRX_TX_HG2_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_HG2_STATUS(u64 a)
+static inline u64 CGXX_CMRX_TX_HG2_STATUS(u64 a)
 {
 	return 0x610 + 0x40000 * a;
 }
@@ -1275,18 +1361,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_HG2_STATUS(u64 a)
  *
  * CGX TX Preemption Status Register 0
  */
-union cavm_cgxx_cmrx_tx_merge_stat0 {
+union cgxx_cmrx_tx_merge_stat0 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_merge_stat0_s {
+	struct cgxx_cmrx_tx_merge_stat0_s {
 		u64 ff_cnt                           : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_merge_stat0_s cn; */
+	/* struct cgxx_cmrx_tx_merge_stat0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+static inline u64 CGXX_CMRX_TX_MERGE_STAT0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+static inline u64 CGXX_CMRX_TX_MERGE_STAT0(u64 a)
 {
 	return 0x160 + 0x40000 * a;
 }
@@ -1296,18 +1382,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_MERGE_STAT0(u64 a)
  *
  * CGX CMR Transmit-Channels Backpressure Override Registers
  */
-union cavm_cgxx_cmrx_tx_ovr_bp {
+union cgxx_cmrx_tx_ovr_bp {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_ovr_bp_s {
+	struct cgxx_cmrx_tx_ovr_bp_s {
 		u64 tx_chan_bp                       : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_ovr_bp_s cn; */
+	/* struct cgxx_cmrx_tx_ovr_bp_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_OVR_BP(u64 a)
+static inline u64 CGXX_CMRX_TX_OVR_BP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_OVR_BP(u64 a)
+static inline u64 CGXX_CMRX_TX_OVR_BP(u64 a)
 {
 	return 0x620 + 0x40000 * a;
 }
@@ -1317,18 +1403,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_OVR_BP(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 0
  */
-union cavm_cgxx_cmrx_tx_stat0 {
+union cgxx_cmrx_tx_stat0 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat0_s {
+	struct cgxx_cmrx_tx_stat0_s {
 		u64 xscol                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat0_s cn; */
+	/* struct cgxx_cmrx_tx_stat0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT0(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT0(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT0(u64 a)
 {
 	return 0x700 + 0x40000 * a;
 }
@@ -1338,18 +1424,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT0(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 1
  */
-union cavm_cgxx_cmrx_tx_stat1 {
+union cgxx_cmrx_tx_stat1 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat1_s {
+	struct cgxx_cmrx_tx_stat1_s {
 		u64 xsdef                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat1_s cn; */
+	/* struct cgxx_cmrx_tx_stat1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT1(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT1(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT1(u64 a)
 {
 	return 0x708 + 0x40000 * a;
 }
@@ -1359,18 +1445,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT1(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 10
  */
-union cavm_cgxx_cmrx_tx_stat10 {
+union cgxx_cmrx_tx_stat10 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat10_s {
+	struct cgxx_cmrx_tx_stat10_s {
 		u64 hist4                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat10_s cn; */
+	/* struct cgxx_cmrx_tx_stat10_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT10(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT10(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT10(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT10(u64 a)
 {
 	return 0x750 + 0x40000 * a;
 }
@@ -1380,18 +1466,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT10(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 11
  */
-union cavm_cgxx_cmrx_tx_stat11 {
+union cgxx_cmrx_tx_stat11 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat11_s {
+	struct cgxx_cmrx_tx_stat11_s {
 		u64 hist5                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat11_s cn; */
+	/* struct cgxx_cmrx_tx_stat11_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT11(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT11(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT11(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT11(u64 a)
 {
 	return 0x758 + 0x40000 * a;
 }
@@ -1401,18 +1487,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT11(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 12
  */
-union cavm_cgxx_cmrx_tx_stat12 {
+union cgxx_cmrx_tx_stat12 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat12_s {
+	struct cgxx_cmrx_tx_stat12_s {
 		u64 hist6                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat12_s cn; */
+	/* struct cgxx_cmrx_tx_stat12_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT12(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT12(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT12(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT12(u64 a)
 {
 	return 0x760 + 0x40000 * a;
 }
@@ -1422,18 +1508,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT12(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 13
  */
-union cavm_cgxx_cmrx_tx_stat13 {
+union cgxx_cmrx_tx_stat13 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat13_s {
+	struct cgxx_cmrx_tx_stat13_s {
 		u64 hist7                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat13_s cn; */
+	/* struct cgxx_cmrx_tx_stat13_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT13(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT13(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT13(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT13(u64 a)
 {
 	return 0x768 + 0x40000 * a;
 }
@@ -1443,18 +1529,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT13(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 14
  */
-union cavm_cgxx_cmrx_tx_stat14 {
+union cgxx_cmrx_tx_stat14 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat14_s {
+	struct cgxx_cmrx_tx_stat14_s {
 		u64 bcst                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat14_s cn; */
+	/* struct cgxx_cmrx_tx_stat14_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT14(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT14(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT14(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT14(u64 a)
 {
 	return 0x770 + 0x40000 * a;
 }
@@ -1464,18 +1550,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT14(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 15
  */
-union cavm_cgxx_cmrx_tx_stat15 {
+union cgxx_cmrx_tx_stat15 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat15_s {
+	struct cgxx_cmrx_tx_stat15_s {
 		u64 mcst                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat15_s cn; */
+	/* struct cgxx_cmrx_tx_stat15_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT15(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT15(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT15(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT15(u64 a)
 {
 	return 0x778 + 0x40000 * a;
 }
@@ -1485,18 +1571,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT15(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 16
  */
-union cavm_cgxx_cmrx_tx_stat16 {
+union cgxx_cmrx_tx_stat16 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat16_s {
+	struct cgxx_cmrx_tx_stat16_s {
 		u64 undflw                           : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat16_s cn; */
+	/* struct cgxx_cmrx_tx_stat16_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT16(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT16(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT16(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT16(u64 a)
 {
 	return 0x780 + 0x40000 * a;
 }
@@ -1506,18 +1592,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT16(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 17
  */
-union cavm_cgxx_cmrx_tx_stat17 {
+union cgxx_cmrx_tx_stat17 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat17_s {
+	struct cgxx_cmrx_tx_stat17_s {
 		u64 ctl                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat17_s cn; */
+	/* struct cgxx_cmrx_tx_stat17_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT17(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT17(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT17(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT17(u64 a)
 {
 	return 0x788 + 0x40000 * a;
 }
@@ -1527,18 +1613,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT17(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 2
  */
-union cavm_cgxx_cmrx_tx_stat2 {
+union cgxx_cmrx_tx_stat2 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat2_s {
+	struct cgxx_cmrx_tx_stat2_s {
 		u64 mcol                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat2_s cn; */
+	/* struct cgxx_cmrx_tx_stat2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT2(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT2(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT2(u64 a)
 {
 	return 0x710 + 0x40000 * a;
 }
@@ -1548,18 +1634,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT2(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 3
  */
-union cavm_cgxx_cmrx_tx_stat3 {
+union cgxx_cmrx_tx_stat3 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat3_s {
+	struct cgxx_cmrx_tx_stat3_s {
 		u64 scol                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat3_s cn; */
+	/* struct cgxx_cmrx_tx_stat3_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT3(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT3(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT3(u64 a)
 {
 	return 0x718 + 0x40000 * a;
 }
@@ -1569,18 +1655,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT3(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 4
  */
-union cavm_cgxx_cmrx_tx_stat4 {
+union cgxx_cmrx_tx_stat4 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat4_s {
+	struct cgxx_cmrx_tx_stat4_s {
 		u64 octs                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat4_s cn; */
+	/* struct cgxx_cmrx_tx_stat4_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT4(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT4(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT4(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT4(u64 a)
 {
 	return 0x720 + 0x40000 * a;
 }
@@ -1590,18 +1676,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT4(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 5
  */
-union cavm_cgxx_cmrx_tx_stat5 {
+union cgxx_cmrx_tx_stat5 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat5_s {
+	struct cgxx_cmrx_tx_stat5_s {
 		u64 pkts                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat5_s cn; */
+	/* struct cgxx_cmrx_tx_stat5_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT5(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT5(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT5(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT5(u64 a)
 {
 	return 0x728 + 0x40000 * a;
 }
@@ -1611,18 +1697,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT5(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 6
  */
-union cavm_cgxx_cmrx_tx_stat6 {
+union cgxx_cmrx_tx_stat6 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat6_s {
+	struct cgxx_cmrx_tx_stat6_s {
 		u64 hist0                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat6_s cn; */
+	/* struct cgxx_cmrx_tx_stat6_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT6(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT6(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT6(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT6(u64 a)
 {
 	return 0x730 + 0x40000 * a;
 }
@@ -1632,18 +1718,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT6(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 7
  */
-union cavm_cgxx_cmrx_tx_stat7 {
+union cgxx_cmrx_tx_stat7 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat7_s {
+	struct cgxx_cmrx_tx_stat7_s {
 		u64 hist1                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat7_s cn; */
+	/* struct cgxx_cmrx_tx_stat7_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT7(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT7(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT7(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT7(u64 a)
 {
 	return 0x738 + 0x40000 * a;
 }
@@ -1653,18 +1739,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT7(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 8
  */
-union cavm_cgxx_cmrx_tx_stat8 {
+union cgxx_cmrx_tx_stat8 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat8_s {
+	struct cgxx_cmrx_tx_stat8_s {
 		u64 hist2                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat8_s cn; */
+	/* struct cgxx_cmrx_tx_stat8_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT8(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT8(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT8(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT8(u64 a)
 {
 	return 0x740 + 0x40000 * a;
 }
@@ -1674,18 +1760,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT8(u64 a)
  *
  * CGX CMR Transmit Statistics Registers 9
  */
-union cavm_cgxx_cmrx_tx_stat9 {
+union cgxx_cmrx_tx_stat9 {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat9_s {
+	struct cgxx_cmrx_tx_stat9_s {
 		u64 hist3                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat9_s cn; */
+	/* struct cgxx_cmrx_tx_stat9_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT9(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT9(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT9(u64 a)
+static inline u64 CGXX_CMRX_TX_STAT9(u64 a)
 {
 	return 0x748 + 0x40000 * a;
 }
@@ -1695,18 +1781,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT9(u64 a)
  *
  * CGX CMR TX XON to XOFF transition Registers
  */
-union cavm_cgxx_cmrx_tx_stat_prix_xoff {
+union cgxx_cmrx_tx_stat_prix_xoff {
 	u64 u;
-	struct cavm_cgxx_cmrx_tx_stat_prix_xoff_s {
+	struct cgxx_cmrx_tx_stat_prix_xoff_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmrx_tx_stat_prix_xoff_s cn; */
+	/* struct cgxx_cmrx_tx_stat_prix_xoff_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+static inline u64 CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+static inline u64 CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
 {
 	return 0x800 + 0x40000 * a + 8 * b;
 }
@@ -1716,18 +1802,18 @@ static inline u64 CAVM_CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
  *
  * CGX CMR Bad Registers
  */
-union cavm_cgxx_cmr_bad {
+union cgxx_cmr_bad {
 	u64 u;
-	struct cavm_cgxx_cmr_bad_s {
+	struct cgxx_cmr_bad_s {
 		u64 rxb_nxl                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_cmr_bad_s cn; */
+	/* struct cgxx_cmr_bad_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_BAD(void)
+static inline u64 CGXX_CMR_BAD(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_BAD(void)
+static inline u64 CGXX_CMR_BAD(void)
 {
 	return 0x1020;
 }
@@ -1737,17 +1823,17 @@ static inline u64 CAVM_CGXX_CMR_BAD(void)
  *
  * CGX CMR Backpressure Channel Mask AND Registers
  */
-union cavm_cgxx_cmr_chan_msk_and {
+union cgxx_cmr_chan_msk_and {
 	u64 u;
-	struct cavm_cgxx_cmr_chan_msk_and_s {
+	struct cgxx_cmr_chan_msk_and_s {
 		u64 msk_and                          : 64;
 	} s;
-	/* struct cavm_cgxx_cmr_chan_msk_and_s cn; */
+	/* struct cgxx_cmr_chan_msk_and_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_CHAN_MSK_AND(void)
+static inline u64 CGXX_CMR_CHAN_MSK_AND(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_CHAN_MSK_AND(void)
+static inline u64 CGXX_CMR_CHAN_MSK_AND(void)
 {
 	return 0x110;
 }
@@ -1757,17 +1843,17 @@ static inline u64 CAVM_CGXX_CMR_CHAN_MSK_AND(void)
  *
  * CGX Backpressure Channel Mask OR Registers
  */
-union cavm_cgxx_cmr_chan_msk_or {
+union cgxx_cmr_chan_msk_or {
 	u64 u;
-	struct cavm_cgxx_cmr_chan_msk_or_s {
+	struct cgxx_cmr_chan_msk_or_s {
 		u64 msk_or                           : 64;
 	} s;
-	/* struct cavm_cgxx_cmr_chan_msk_or_s cn; */
+	/* struct cgxx_cmr_chan_msk_or_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_CHAN_MSK_OR(void)
+static inline u64 CGXX_CMR_CHAN_MSK_OR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_CHAN_MSK_OR(void)
+static inline u64 CGXX_CMR_CHAN_MSK_OR(void)
 {
 	return 0x118;
 }
@@ -1777,18 +1863,18 @@ static inline u64 CAVM_CGXX_CMR_CHAN_MSK_OR(void)
  *
  * INTERNAL: CGX ECO Registers
  */
-union cavm_cgxx_cmr_eco {
+union cgxx_cmr_eco {
 	u64 u;
-	struct cavm_cgxx_cmr_eco_s {
+	struct cgxx_cmr_eco_s {
 		u64 eco_rw                           : 32;
 		u64 eco_ro                           : 32;
 	} s;
-	/* struct cavm_cgxx_cmr_eco_s cn; */
+	/* struct cgxx_cmr_eco_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_ECO(void)
+static inline u64 CGXX_CMR_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_ECO(void)
+static inline u64 CGXX_CMR_ECO(void)
 {
 	return 0x1028;
 }
@@ -1799,9 +1885,9 @@ static inline u64 CAVM_CGXX_CMR_ECO(void)
  * CGX CMR Global Configuration Register These registers configure the
  * global CMR, PCS, and MAC.
  */
-union cavm_cgxx_cmr_global_config {
+union cgxx_cmr_global_config {
 	u64 u;
-	struct cavm_cgxx_cmr_global_config_s {
+	struct cgxx_cmr_global_config_s {
 		u64 pmux_sds_sel                     : 1;
 		u64 cgx_clk_enable                   : 1;
 		u64 cmr_x2p_reset                    : 3;
@@ -1814,12 +1900,12 @@ union cavm_cgxx_cmr_global_config {
 		u64 cmr_clken_ovrd                   : 1;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_cgxx_cmr_global_config_s cn; */
+	/* struct cgxx_cmr_global_config_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_GLOBAL_CONFIG(void)
+static inline u64 CGXX_CMR_GLOBAL_CONFIG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_GLOBAL_CONFIG(void)
+static inline u64 CGXX_CMR_GLOBAL_CONFIG(void)
 {
 	return 8;
 }
@@ -1829,19 +1915,19 @@ static inline u64 CAVM_CGXX_CMR_GLOBAL_CONFIG(void)
  *
  * CGX CMR Memory Interrupt Register
  */
-union cavm_cgxx_cmr_mem_int {
+union cgxx_cmr_mem_int {
 	u64 u;
-	struct cavm_cgxx_cmr_mem_int_s {
+	struct cgxx_cmr_mem_int_s {
 		u64 gmp_in_overfl                    : 1;
 		u64 smu_in_overfl                    : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_cmr_mem_int_s cn; */
+	/* struct cgxx_cmr_mem_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
+static inline u64 CGXX_CMR_MEM_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
+static inline u64 CGXX_CMR_MEM_INT(void)
 {
 	return 0x10;
 }
@@ -1852,19 +1938,19 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
  * CGX CMR Memory Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_cmr_mem_int_ena_w1c {
+union cgxx_cmr_mem_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_cmr_mem_int_ena_w1c_s {
+	struct cgxx_cmr_mem_int_ena_w1c_s {
 		u64 gmp_in_overfl                    : 1;
 		u64 smu_in_overfl                    : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_cmr_mem_int_ena_w1c_s cn; */
+	/* struct cgxx_cmr_mem_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1C(void)
 {
 	return 0x20;
 }
@@ -1875,19 +1961,19 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
  * CGX CMR Memory Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_cmr_mem_int_ena_w1s {
+union cgxx_cmr_mem_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_cmr_mem_int_ena_w1s_s {
+	struct cgxx_cmr_mem_int_ena_w1s_s {
 		u64 gmp_in_overfl                    : 1;
 		u64 smu_in_overfl                    : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_cmr_mem_int_ena_w1s_s cn; */
+	/* struct cgxx_cmr_mem_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
+static inline u64 CGXX_CMR_MEM_INT_ENA_W1S(void)
 {
 	return 0x28;
 }
@@ -1898,19 +1984,19 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
  * CGX CMR Memory Interrupt Set Register This register sets interrupt
  * bits.
  */
-union cavm_cgxx_cmr_mem_int_w1s {
+union cgxx_cmr_mem_int_w1s {
 	u64 u;
-	struct cavm_cgxx_cmr_mem_int_w1s_s {
+	struct cgxx_cmr_mem_int_w1s_s {
 		u64 gmp_in_overfl                    : 1;
 		u64 smu_in_overfl                    : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_cmr_mem_int_w1s_s cn; */
+	/* struct cgxx_cmr_mem_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_MEM_INT_W1S(void)
+static inline u64 CGXX_CMR_MEM_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_MEM_INT_W1S(void)
+static inline u64 CGXX_CMR_MEM_INT_W1S(void)
 {
 	return 0x18;
 }
@@ -1920,19 +2006,19 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT_W1S(void)
  *
  * CGX CMR NIC NXC Exception Registers
  */
-union cavm_cgxx_cmr_nic_nxc_adr {
+union cgxx_cmr_nic_nxc_adr {
 	u64 u;
-	struct cavm_cgxx_cmr_nic_nxc_adr_s {
+	struct cgxx_cmr_nic_nxc_adr_s {
 		u64 channel                          : 12;
 		u64 lmac_id                          : 4;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_cmr_nic_nxc_adr_s cn; */
+	/* struct cgxx_cmr_nic_nxc_adr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_NIC_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIC_NXC_ADR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_NIC_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIC_NXC_ADR(void)
 {
 	return 0x1030;
 }
@@ -1942,21 +2028,21 @@ static inline u64 CAVM_CGXX_CMR_NIC_NXC_ADR(void)
  *
  * CGX CMR NIX0 NXC Exception Registers
  */
-union cavm_cgxx_cmr_nix0_nxc_adr {
+union cgxx_cmr_nix0_nxc_adr {
 	u64 u;
-	struct cavm_cgxx_cmr_nix0_nxc_adr_s {
+	struct cgxx_cmr_nix0_nxc_adr_s {
 		u64 channel                          : 12;
 		u64 lmac_id                          : 4;
 		u64 channel_e                        : 12;
 		u64 lmac_e_id                        : 4;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_cmr_nix0_nxc_adr_s cn; */
+	/* struct cgxx_cmr_nix0_nxc_adr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_NIX0_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIX0_NXC_ADR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_NIX0_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIX0_NXC_ADR(void)
 {
 	return 0x1038;
 }
@@ -1966,21 +2052,21 @@ static inline u64 CAVM_CGXX_CMR_NIX0_NXC_ADR(void)
  *
  * CGX CMR NIX1 NXC Exception Registers
  */
-union cavm_cgxx_cmr_nix1_nxc_adr {
+union cgxx_cmr_nix1_nxc_adr {
 	u64 u;
-	struct cavm_cgxx_cmr_nix1_nxc_adr_s {
+	struct cgxx_cmr_nix1_nxc_adr_s {
 		u64 channel                          : 12;
 		u64 lmac_id                          : 4;
 		u64 channel_e                        : 12;
 		u64 lmac_e_id                        : 4;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_cmr_nix1_nxc_adr_s cn; */
+	/* struct cgxx_cmr_nix1_nxc_adr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_NIX1_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIX1_NXC_ADR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_NIX1_NXC_ADR(void)
+static inline u64 CGXX_CMR_NIX1_NXC_ADR(void)
 {
 	return 0x1040;
 }
@@ -1990,17 +2076,17 @@ static inline u64 CAVM_CGXX_CMR_NIX1_NXC_ADR(void)
  *
  * CGX P2X Activity Register
  */
-union cavm_cgxx_cmr_p2xx_count {
+union cgxx_cmr_p2xx_count {
 	u64 u;
-	struct cavm_cgxx_cmr_p2xx_count_s {
+	struct cgxx_cmr_p2xx_count_s {
 		u64 p2x_cnt                          : 64;
 	} s;
-	/* struct cavm_cgxx_cmr_p2xx_count_s cn; */
+	/* struct cgxx_cmr_p2xx_count_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
+static inline u64 CGXX_CMR_P2XX_COUNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
+static inline u64 CGXX_CMR_P2XX_COUNT(u64 a)
 {
 	return 0x168 + 0x1000 * a;
 }
@@ -2011,20 +2097,20 @@ static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
  * CGX CMR Receive CAM Registers These registers provide access to the 32
  * DMAC CAM0 entries in CGX, for use by X2P/NIX bound traffic.
  */
-union cavm_cgxx_cmr_rx_dmacx_cam0 {
+union cgxx_cmr_rx_dmacx_cam0 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_dmacx_cam0_s {
+	struct cgxx_cmr_rx_dmacx_cam0_s {
 		u64 adr                              : 48;
 		u64 en                               : 1;
 		u64 id                               : 2;
 		u64 reserved_51_63                   : 13;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_dmacx_cam0_s cn; */
+	/* struct cgxx_cmr_rx_dmacx_cam0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
+static inline u64 CGXX_CMR_RX_DMACX_CAM0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
+static inline u64 CGXX_CMR_RX_DMACX_CAM0(u64 a)
 {
 	return 0x200 + 8 * a;
 }
@@ -2037,20 +2123,20 @@ static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
  * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and CGX()_CMR_RX_STEERING1()
  * registers.
  */
-union cavm_cgxx_cmr_rx_dmacx_cam1 {
+union cgxx_cmr_rx_dmacx_cam1 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_dmacx_cam1_s {
+	struct cgxx_cmr_rx_dmacx_cam1_s {
 		u64 adr                              : 48;
 		u64 en                               : 1;
 		u64 id                               : 2;
 		u64 reserved_51_63                   : 13;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_dmacx_cam1_s cn; */
+	/* struct cgxx_cmr_rx_dmacx_cam1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM1(u64 a)
+static inline u64 CGXX_CMR_RX_DMACX_CAM1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM1(u64 a)
+static inline u64 CGXX_CMR_RX_DMACX_CAM1(u64 a)
 {
 	return 0x400 + 8 * a;
 }
@@ -2060,18 +2146,18 @@ static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM1(u64 a)
  *
  * CGX CMR Receive Logical MACs Registers
  */
-union cavm_cgxx_cmr_rx_lmacs {
+union cgxx_cmr_rx_lmacs {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_lmacs_s {
+	struct cgxx_cmr_rx_lmacs_s {
 		u64 lmacs                            : 3;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_lmacs_s cn; */
+	/* struct cgxx_cmr_rx_lmacs_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
+static inline u64 CGXX_CMR_RX_LMACS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
+static inline u64 CGXX_CMR_RX_LMACS(void)
 {
 	return 0x128;
 }
@@ -2090,20 +2176,20 @@ static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
  * (optionally, when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2
  * protocol.
  */
-union cavm_cgxx_cmr_rx_ovr_bp {
+union cgxx_cmr_rx_ovr_bp {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_ovr_bp_s {
+	struct cgxx_cmr_rx_ovr_bp_s {
 		u64 ign_fifo_bp                      : 4;
 		u64 bp                               : 4;
 		u64 en                               : 4;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_ovr_bp_s cn; */
+	/* struct cgxx_cmr_rx_ovr_bp_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
+static inline u64 CGXX_CMR_RX_OVR_BP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
+static inline u64 CGXX_CMR_RX_OVR_BP(void)
 {
 	return 0x130;
 }
@@ -2114,18 +2200,18 @@ static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
  * CGX Receive Status Register 10 These registers provide a count of
  * octets of filtered DMAC1 or VLAN STEERING1 packets.
  */
-union cavm_cgxx_cmr_rx_stat10 {
+union cgxx_cmr_rx_stat10 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_stat10_s {
+	struct cgxx_cmr_rx_stat10_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_stat10_s cn; */
+	/* struct cgxx_cmr_rx_stat10_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
+static inline u64 CGXX_CMR_RX_STAT10(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
+static inline u64 CGXX_CMR_RX_STAT10(void)
 {
 	return 0xc0;
 }
@@ -2139,18 +2225,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
  * dropped NCSI packets is not accounted for in any other stats
  * registers.
  */
-union cavm_cgxx_cmr_rx_stat11 {
+union cgxx_cmr_rx_stat11 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_stat11_s {
+	struct cgxx_cmr_rx_stat11_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_stat11_s cn; */
+	/* struct cgxx_cmr_rx_stat11_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
+static inline u64 CGXX_CMR_RX_STAT11(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
+static inline u64 CGXX_CMR_RX_STAT11(void)
 {
 	return 0xc8;
 }
@@ -2161,18 +2247,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
  * CGX Receive Status Register 12 This register provide a count of octets
  * of dropped at the NCSI interface.
  */
-union cavm_cgxx_cmr_rx_stat12 {
+union cgxx_cmr_rx_stat12 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_stat12_s {
+	struct cgxx_cmr_rx_stat12_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_stat12_s cn; */
+	/* struct cgxx_cmr_rx_stat12_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
+static inline u64 CGXX_CMR_RX_STAT12(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
+static inline u64 CGXX_CMR_RX_STAT12(void)
 {
 	return 0xd0;
 }
@@ -2191,18 +2277,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
  * the MAC signal to the CMR that the packet be filtered upon decision
  * before the end of packet, then STAT9 and STAT10 will not be updated.
  */
-union cavm_cgxx_cmr_rx_stat9 {
+union cgxx_cmr_rx_stat9 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_stat9_s {
+	struct cgxx_cmr_rx_stat9_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_stat9_s cn; */
+	/* struct cgxx_cmr_rx_stat9_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
+static inline u64 CGXX_CMR_RX_STAT9(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
+static inline u64 CGXX_CMR_RX_STAT9(void)
 {
 	return 0xb8;
 }
@@ -2229,21 +2315,21 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
  * }       }    }    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No
  * match } \</pre\>"
  */
-union cavm_cgxx_cmr_rx_steering0x {
+union cgxx_cmr_rx_steering0x {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering0x_s {
+	struct cgxx_cmr_rx_steering0x_s {
 		u64 dmac                             : 48;
 		u64 dmac_en                          : 1;
 		u64 mcst_en                          : 1;
 		u64 pass                             : 1;
 		u64 reserved_51_63                   : 13;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering0x_s cn; */
+	/* struct cgxx_cmr_rx_steering0x_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING0X(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING0X(u64 a)
 {
 	return 0x300 + 8 * a;
 }
@@ -2260,21 +2346,21 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
  * See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
  * CGX()_CMR_RX_STEERING0().
  */
-union cavm_cgxx_cmr_rx_steering1x {
+union cgxx_cmr_rx_steering1x {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering1x_s {
+	struct cgxx_cmr_rx_steering1x_s {
 		u64 dmac                             : 48;
 		u64 dmac_en                          : 1;
 		u64 mcst_en                          : 1;
 		u64 pass                             : 1;
 		u64 reserved_51_63                   : 13;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering1x_s cn; */
+	/* struct cgxx_cmr_rx_steering1x_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING1X(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING1X(u64 a)
 {
 	return 0x500 + 8 * a;
 }
@@ -2289,18 +2375,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
  * case of FCS strip) as the result of truncation will steer to default
  * destination
  */
-union cavm_cgxx_cmr_rx_steering_default0 {
+union cgxx_cmr_rx_steering_default0 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering_default0_s {
+	struct cgxx_cmr_rx_steering_default0_s {
 		u64 pass                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering_default0_s cn; */
+	/* struct cgxx_cmr_rx_steering_default0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT0(void)
 {
 	return 0x3f0;
 }
@@ -2316,18 +2402,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
  * packets or smaller (20B in case of FCS strip) as the result of
  * truncation will steer to default destination
  */
-union cavm_cgxx_cmr_rx_steering_default1 {
+union cgxx_cmr_rx_steering_default1 {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering_default1_s {
+	struct cgxx_cmr_rx_steering_default1_s {
 		u64 pass                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering_default1_s cn; */
+	/* struct cgxx_cmr_rx_steering_default1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
+static inline u64 CGXX_CMR_RX_STEERING_DEFAULT1(void)
 {
 	return 0x5e0;
 }
@@ -2339,21 +2425,21 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
  * CGX()_CMR_RX_STEERING0(), provide eight filters for identifying and
  * steering X2P/NIX receive traffic.
  */
-union cavm_cgxx_cmr_rx_steering_vetype0x {
+union cgxx_cmr_rx_steering_vetype0x {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering_vetype0x_s {
+	struct cgxx_cmr_rx_steering_vetype0x_s {
 		u64 vlan_etype                       : 16;
 		u64 vlan_tag_en                      : 1;
 		u64 vlan_id                          : 12;
 		u64 vlan_en                          : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering_vetype0x_s cn; */
+	/* struct cgxx_cmr_rx_steering_vetype0x_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
 {
 	return 0x380 + 8 * a;
 }
@@ -2366,21 +2452,21 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
  * registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters
  * for identifying and steering NCSI receive traffic.
  */
-union cavm_cgxx_cmr_rx_steering_vetype1x {
+union cgxx_cmr_rx_steering_vetype1x {
 	u64 u;
-	struct cavm_cgxx_cmr_rx_steering_vetype1x_s {
+	struct cgxx_cmr_rx_steering_vetype1x_s {
 		u64 vlan_etype                       : 16;
 		u64 vlan_tag_en                      : 1;
 		u64 vlan_id                          : 12;
 		u64 vlan_en                          : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_cgxx_cmr_rx_steering_vetype1x_s cn; */
+	/* struct cgxx_cmr_rx_steering_vetype1x_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+static inline u64 CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
 {
 	return 0x580 + 8 * a;
 }
@@ -2392,18 +2478,18 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
  * of LMACs allowed on the TX interface. The value is important for
  * defining the partitioning of the transmit FIFO.
  */
-union cavm_cgxx_cmr_tx_lmacs {
+union cgxx_cmr_tx_lmacs {
 	u64 u;
-	struct cavm_cgxx_cmr_tx_lmacs_s {
+	struct cgxx_cmr_tx_lmacs_s {
 		u64 lmacs                            : 3;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_cgxx_cmr_tx_lmacs_s cn; */
+	/* struct cgxx_cmr_tx_lmacs_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_TX_LMACS(void)
+static inline u64 CGXX_CMR_TX_LMACS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_TX_LMACS(void)
+static inline u64 CGXX_CMR_TX_LMACS(void)
 {
 	return 0x1000;
 }
@@ -2413,17 +2499,17 @@ static inline u64 CAVM_CGXX_CMR_TX_LMACS(void)
  *
  * CGX X2P Activity Register
  */
-union cavm_cgxx_cmr_x2px_count {
+union cgxx_cmr_x2px_count {
 	u64 u;
-	struct cavm_cgxx_cmr_x2px_count_s {
+	struct cgxx_cmr_x2px_count_s {
 		u64 x2p_cnt                          : 64;
 	} s;
-	/* struct cavm_cgxx_cmr_x2px_count_s cn; */
+	/* struct cgxx_cmr_x2px_count_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
+static inline u64 CGXX_CMR_X2PX_COUNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
+static inline u64 CGXX_CMR_X2PX_COUNT(u64 a)
 {
 	return 0x170 + 0x1000 * a;
 }
@@ -2434,20 +2520,20 @@ static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
  * CGX CONST Registers This register contains constants for software
  * discovery.
  */
-union cavm_cgxx_const {
+union cgxx_const {
 	u64 u;
-	struct cavm_cgxx_const_s {
+	struct cgxx_const_s {
 		u64 tx_fifosz                        : 24;
 		u64 lmacs                            : 8;
 		u64 rx_fifosz                        : 24;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_cgxx_const_s cn; */
+	/* struct cgxx_const_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CONST(void)
+static inline u64 CGXX_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CONST(void)
+static inline u64 CGXX_CONST(void)
 {
 	return 0x2000;
 }
@@ -2458,19 +2544,19 @@ static inline u64 CAVM_CGXX_CONST(void)
  * CGX CONST1 Registers This register contains constants for software
  * discovery.
  */
-union cavm_cgxx_const1 {
+union cgxx_const1 {
 	u64 u;
-	struct cavm_cgxx_const1_s {
+	struct cgxx_const1_s {
 		u64 types                            : 11;
 		u64 res_types                        : 21;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_const1_s cn; */
+	/* struct cgxx_const1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_CONST1(void)
+static inline u64 CGXX_CONST1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_CONST1(void)
+static inline u64 CGXX_CONST1(void)
 {
 	return 0x2008;
 }
@@ -2480,19 +2566,19 @@ static inline u64 CAVM_CGXX_CONST1(void)
  *
  * CGX GMP GMI RX Wake-on-LAN Control 0 Registers
  */
-union cavm_cgxx_gmp_gmix_rx_wol_ctrl0 {
+union cgxx_gmp_gmix_rx_wol_ctrl0 {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_rx_wol_ctrl0_s {
+	struct cgxx_gmp_gmix_rx_wol_ctrl0_s {
 		u64 dmac                             : 48;
 		u64 pswd_len                         : 4;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_rx_wol_ctrl0_s cn; */
+	/* struct cgxx_gmp_gmix_rx_wol_ctrl0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
 {
 	return 0x38a00 + 0x40000 * a;
 }
@@ -2502,17 +2588,17 @@ static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
  *
  * CGX GMP GMI RX Wake-on-LAN Control 1 Registers
  */
-union cavm_cgxx_gmp_gmix_rx_wol_ctrl1 {
+union cgxx_gmp_gmix_rx_wol_ctrl1 {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_rx_wol_ctrl1_s {
+	struct cgxx_gmp_gmix_rx_wol_ctrl1_s {
 		u64 pswd                             : 64;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_rx_wol_ctrl1_s cn; */
+	/* struct cgxx_gmp_gmix_rx_wol_ctrl1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+static inline u64 CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
 {
 	return 0x38a08 + 0x40000 * a;
 }
@@ -2525,9 +2611,9 @@ static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
  * LPI. Those registers take effect only when EEE is supported and
  * enabled for a given LMAC.
  */
-union cavm_cgxx_gmp_gmix_tx_eee {
+union cgxx_gmp_gmix_tx_eee {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_tx_eee_s {
+	struct cgxx_gmp_gmix_tx_eee_s {
 		u64 idle_thresh                      : 28;
 		u64 reserved_28                      : 1;
 		u64 force_lpi                        : 1;
@@ -2539,12 +2625,12 @@ union cavm_cgxx_gmp_gmix_tx_eee {
 		u64 sync_status_lpi_enable           : 1;
 		u64 reserved_63                      : 1;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_tx_eee_s cn; */
+	/* struct cgxx_gmp_gmix_tx_eee_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
+static inline u64 CGXX_GMP_GMIX_TX_EEE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
+static inline u64 CGXX_GMP_GMIX_TX_EEE(u64 a)
 {
 	return 0x38800 + 0x40000 * a;
 }
@@ -2556,9 +2642,9 @@ static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
  * Reserved. Internal: Controls the GMP exiting of LPI and starting to
  * send data.
  */
-union cavm_cgxx_gmp_gmix_tx_eee_cfg1 {
+union cgxx_gmp_gmix_tx_eee_cfg1 {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_tx_eee_cfg1_s {
+	struct cgxx_gmp_gmix_tx_eee_cfg1_s {
 		u64 wake2data_time                   : 24;
 		u64 reserved_24_35                   : 12;
 		u64 tx_eee_enable                    : 1;
@@ -2566,7 +2652,7 @@ union cavm_cgxx_gmp_gmix_tx_eee_cfg1 {
 		u64 sync2lpi_time                    : 21;
 		u64 reserved_61_63                   : 3;
 	} s;
-	struct cavm_cgxx_gmp_gmix_tx_eee_cfg1_cn {
+	struct cgxx_gmp_gmix_tx_eee_cfg1_cn {
 		u64 wake2data_time                   : 24;
 		u64 reserved_24_31                   : 8;
 		u64 reserved_32_35                   : 4;
@@ -2577,9 +2663,9 @@ union cavm_cgxx_gmp_gmix_tx_eee_cfg1 {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+static inline u64 CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+static inline u64 CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
 {
 	return 0x38808 + 0x40000 * a;
 }
@@ -2590,18 +2676,18 @@ static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
  * CGX GMP GMI RX WOL Interrupt Registers These registers allow WOL
  * interrupts to be sent to the control processor.
  */
-union cavm_cgxx_gmp_gmix_wol_int {
+union cgxx_gmp_gmix_wol_int {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_wol_int_s {
+	struct cgxx_gmp_gmix_wol_int_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_wol_int_s cn; */
+	/* struct cgxx_gmp_gmix_wol_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT(u64 a)
 {
 	return 0x38a80 + 0x40000 * a;
 }
@@ -2612,18 +2698,18 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
  * CGX GMP GMI RX WOL Interrupt Enable Clear Registers This register
  * clears interrupt enable bits.
  */
-union cavm_cgxx_gmp_gmix_wol_int_ena_w1c {
+union cgxx_gmp_gmix_wol_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_wol_int_ena_w1c_s {
+	struct cgxx_gmp_gmix_wol_int_ena_w1c_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_wol_int_ena_w1c_s cn; */
+	/* struct cgxx_gmp_gmix_wol_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
 {
 	return 0x38a90 + 0x40000 * a;
 }
@@ -2634,18 +2720,18 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
  * CGX GMP GMI RX WOL Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_gmix_wol_int_ena_w1s {
+union cgxx_gmp_gmix_wol_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_wol_int_ena_w1s_s {
+	struct cgxx_gmp_gmix_wol_int_ena_w1s_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_wol_int_ena_w1s_s cn; */
+	/* struct cgxx_gmp_gmix_wol_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
 {
 	return 0x38a98 + 0x40000 * a;
 }
@@ -2656,18 +2742,18 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
  * CGX GMP GMI RX WOL Interrupt Set Registers This register sets
  * interrupt bits.
  */
-union cavm_cgxx_gmp_gmix_wol_int_w1s {
+union cgxx_gmp_gmix_wol_int_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmix_wol_int_w1s_s {
+	struct cgxx_gmp_gmix_wol_int_w1s_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmix_wol_int_w1s_s cn; */
+	/* struct cgxx_gmp_gmix_wol_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
 {
 	return 0x38a88 + 0x40000 * a;
 }
@@ -2678,9 +2764,9 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
  * CGX GMP GMI LMAC Configuration Registers This register controls the
  * configuration of the LMAC.
  */
-union cavm_cgxx_gmp_gmi_prtx_cfg {
+union cgxx_gmp_gmi_prtx_cfg {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_prtx_cfg_s {
+	struct cgxx_gmp_gmi_prtx_cfg_s {
 		u64 reserved_0                       : 1;
 		u64 speed                            : 1;
 		u64 duplex                           : 1;
@@ -2692,12 +2778,12 @@ union cavm_cgxx_gmp_gmi_prtx_cfg {
 		u64 tx_idle                          : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_prtx_cfg_s cn; */
+	/* struct cgxx_gmp_gmi_prtx_cfg_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
+static inline u64 CGXX_GMP_GMI_PRTX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
+static inline u64 CGXX_GMP_GMI_PRTX_CFG(u64 a)
 {
 	return 0x38020 + 0x40000 * a;
 }
@@ -2727,18 +2813,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
  * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
  * ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
  */
-union cavm_cgxx_gmp_gmi_rxx_decision {
+union cgxx_gmp_gmi_rxx_decision {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_decision_s {
+	struct cgxx_gmp_gmi_rxx_decision_s {
 		u64 cnt                              : 5;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_rxx_decision_s cn; */
+	/* struct cgxx_gmp_gmi_rxx_decision_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_DECISION(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_DECISION(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_DECISION(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_DECISION(u64 a)
 {
 	return 0x38040 + 0x40000 * a;
 }
@@ -2748,9 +2834,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_DECISION(u64 a)
  *
  * CGX GMP Frame Check Registers
  */
-union cavm_cgxx_gmp_gmi_rxx_frm_chk {
+union cgxx_gmp_gmi_rxx_frm_chk {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_frm_chk_s {
+	struct cgxx_gmp_gmi_rxx_frm_chk_s {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 reserved_2                       : 1;
@@ -2761,12 +2847,12 @@ union cavm_cgxx_gmp_gmi_rxx_frm_chk {
 		u64 skperr                           : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_rxx_frm_chk_s cn; */
+	/* struct cgxx_gmp_gmi_rxx_frm_chk_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
 {
 	return 0x38030 + 0x40000 * a;
 }
@@ -2792,9 +2878,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
  * Furthermore, the bytes are skipped when locating the start of the L2
  * header for DMAC and Control frame recognition.
  */
-union cavm_cgxx_gmp_gmi_rxx_frm_ctl {
+union cgxx_gmp_gmi_rxx_frm_ctl {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_frm_ctl_s {
+	struct cgxx_gmp_gmi_rxx_frm_ctl_s {
 		u64 pre_chk                          : 1;
 		u64 pre_strp                         : 1;
 		u64 ctl_drp                          : 1;
@@ -2810,7 +2896,7 @@ union cavm_cgxx_gmp_gmi_rxx_frm_ctl {
 		u64 rx_fc_type                       : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	struct cavm_cgxx_gmp_gmi_rxx_frm_ctl_cn {
+	struct cgxx_gmp_gmi_rxx_frm_ctl_cn {
 		u64 pre_chk                          : 1;
 		u64 pre_strp                         : 1;
 		u64 ctl_drp                          : 1;
@@ -2829,9 +2915,9 @@ union cavm_cgxx_gmp_gmi_rxx_frm_ctl {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
 {
 	return 0x38028 + 0x40000 * a;
 }
@@ -2843,18 +2929,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
  * specifies the minimum number of interframe-gap (IFG) cycles between
  * packets.
  */
-union cavm_cgxx_gmp_gmi_rxx_ifg {
+union cgxx_gmp_gmi_rxx_ifg {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_ifg_s {
+	struct cgxx_gmp_gmi_rxx_ifg_s {
 		u64 ifg                              : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_rxx_ifg_s cn; */
+	/* struct cgxx_gmp_gmi_rxx_ifg_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_IFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_IFG(u64 a)
 {
 	return 0x38058 + 0x40000 * a;
 }
@@ -2907,9 +2993,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
  * the tick before another is produced.  If that doesn't happen that's
  * when OVRERR will assert."
  */
-union cavm_cgxx_gmp_gmi_rxx_int {
+union cgxx_gmp_gmi_rxx_int {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_int_s {
+	struct cgxx_gmp_gmi_rxx_int_s {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -2924,7 +3010,7 @@ union cavm_cgxx_gmp_gmi_rxx_int {
 		u64 ifgerr                           : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	struct cavm_cgxx_gmp_gmi_rxx_int_cn {
+	struct cgxx_gmp_gmi_rxx_int_cn {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -2942,9 +3028,9 @@ union cavm_cgxx_gmp_gmi_rxx_int {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT(u64 a)
 {
 	return 0x38000 + 0x40000 * a;
 }
@@ -2955,9 +3041,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
  * CGX GMP GMI RX Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_gmi_rxx_int_ena_w1c {
+union cgxx_gmp_gmi_rxx_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1c_s {
+	struct cgxx_gmp_gmi_rxx_int_ena_w1c_s {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -2972,7 +3058,7 @@ union cavm_cgxx_gmp_gmi_rxx_int_ena_w1c {
 		u64 ifgerr                           : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1c_cn {
+	struct cgxx_gmp_gmi_rxx_int_ena_w1c_cn {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -2990,9 +3076,9 @@ union cavm_cgxx_gmp_gmi_rxx_int_ena_w1c {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
 {
 	return 0x38010 + 0x40000 * a;
 }
@@ -3003,9 +3089,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
  * CGX GMP GMI RX Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_gmi_rxx_int_ena_w1s {
+union cgxx_gmp_gmi_rxx_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1s_s {
+	struct cgxx_gmp_gmi_rxx_int_ena_w1s_s {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -3020,7 +3106,7 @@ union cavm_cgxx_gmp_gmi_rxx_int_ena_w1s {
 		u64 ifgerr                           : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1s_cn {
+	struct cgxx_gmp_gmi_rxx_int_ena_w1s_cn {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -3038,9 +3124,9 @@ union cavm_cgxx_gmp_gmi_rxx_int_ena_w1s {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
 {
 	return 0x38018 + 0x40000 * a;
 }
@@ -3051,9 +3137,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
  * CGX GMP GMI RX Interrupt Set Registers This register sets interrupt
  * bits.
  */
-union cavm_cgxx_gmp_gmi_rxx_int_w1s {
+union cgxx_gmp_gmi_rxx_int_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_int_w1s_s {
+	struct cgxx_gmp_gmi_rxx_int_w1s_s {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -3068,7 +3154,7 @@ union cavm_cgxx_gmp_gmi_rxx_int_w1s {
 		u64 ifgerr                           : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	struct cavm_cgxx_gmp_gmi_rxx_int_w1s_cn {
+	struct cgxx_gmp_gmi_rxx_int_w1s_cn {
 		u64 minerr                           : 1;
 		u64 carext                           : 1;
 		u64 jabber                           : 1;
@@ -3086,9 +3172,9 @@ union cavm_cgxx_gmp_gmi_rxx_int_w1s {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
 {
 	return 0x38008 + 0x40000 * a;
 }
@@ -3099,18 +3185,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
  * CGX GMP Maximum Packet-Size Registers This register specifies the
  * maximum size for packets, beyond which the GMI truncates.
  */
-union cavm_cgxx_gmp_gmi_rxx_jabber {
+union cgxx_gmp_gmi_rxx_jabber {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_jabber_s {
+	struct cgxx_gmp_gmi_rxx_jabber_s {
 		u64 cnt                              : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_rxx_jabber_s cn; */
+	/* struct cgxx_gmp_gmi_rxx_jabber_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_JABBER(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_JABBER(u64 a)
 {
 	return 0x38038 + 0x40000 * a;
 }
@@ -3136,20 +3222,20 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
  * the UDD bytes will be sent down the packet interface as part of the
  * packet.  The UDD bytes are never stripped from the actual packet.
  */
-union cavm_cgxx_gmp_gmi_rxx_udd_skp {
+union cgxx_gmp_gmi_rxx_udd_skp {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_rxx_udd_skp_s {
+	struct cgxx_gmp_gmi_rxx_udd_skp_s {
 		u64 len                              : 7;
 		u64 reserved_7                       : 1;
 		u64 fcssel                           : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_rxx_udd_skp_s cn; */
+	/* struct cgxx_gmp_gmi_rxx_udd_skp_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+static inline u64 CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
 {
 	return 0x38048 + 0x40000 * a;
 }
@@ -3159,18 +3245,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
  *
  * CGX GMI SMAC Registers
  */
-union cavm_cgxx_gmp_gmi_smacx {
+union cgxx_gmp_gmi_smacx {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_smacx_s {
+	struct cgxx_gmp_gmi_smacx_s {
 		u64 smac                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_smacx_s cn; */
+	/* struct cgxx_gmp_gmi_smacx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_SMACX(u64 a)
+static inline u64 CGXX_GMP_GMI_SMACX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_SMACX(u64 a)
+static inline u64 CGXX_GMP_GMI_SMACX(u64 a)
 {
 	return 0x38230 + 0x40000 * a;
 }
@@ -3180,21 +3266,21 @@ static inline u64 CAVM_CGXX_GMP_GMI_SMACX(u64 a)
  *
  * CGX GMI TX Append Control Registers
  */
-union cavm_cgxx_gmp_gmi_txx_append {
+union cgxx_gmp_gmi_txx_append {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_append_s {
+	struct cgxx_gmp_gmi_txx_append_s {
 		u64 preamble                         : 1;
 		u64 pad                              : 1;
 		u64 fcs                              : 1;
 		u64 force_fcs                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_append_s cn; */
+	/* struct cgxx_gmp_gmi_txx_append_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_APPEND(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_APPEND(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_APPEND(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_APPEND(u64 a)
 {
 	return 0x38218 + 0x40000 * a;
 }
@@ -3204,18 +3290,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_APPEND(u64 a)
  *
  * CGX GMI TX Burst-Counter Registers
  */
-union cavm_cgxx_gmp_gmi_txx_burst {
+union cgxx_gmp_gmi_txx_burst {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_burst_s {
+	struct cgxx_gmp_gmi_txx_burst_s {
 		u64 burst                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_burst_s cn; */
+	/* struct cgxx_gmp_gmi_txx_burst_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_BURST(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_BURST(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_BURST(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_BURST(u64 a)
 {
 	return 0x38228 + 0x40000 * a;
 }
@@ -3225,21 +3311,21 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_BURST(u64 a)
  *
  * CGX GMI Transmit Control Registers
  */
-union cavm_cgxx_gmp_gmi_txx_ctl {
+union cgxx_gmp_gmi_txx_ctl {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_ctl_s {
+	struct cgxx_gmp_gmi_txx_ctl_s {
 		u64 xscol_en                         : 1;
 		u64 xsdef_en                         : 1;
 		u64 tx_fc_type                       : 1;
 		u64 link_drain                       : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_ctl_s cn; */
+	/* struct cgxx_gmp_gmi_txx_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_CTL(u64 a)
 {
 	return 0x38270 + 0x40000 * a;
 }
@@ -3249,9 +3335,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_CTL(u64 a)
  *
  * CGX GMI TX Interrupt Registers
  */
-union cavm_cgxx_gmp_gmi_txx_int {
+union cgxx_gmp_gmi_txx_int {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_int_s {
+	struct cgxx_gmp_gmi_txx_int_s {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3259,7 +3345,7 @@ union cavm_cgxx_gmp_gmi_txx_int {
 		u64 ptp_lost                         : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	struct cavm_cgxx_gmp_gmi_txx_int_cn {
+	struct cgxx_gmp_gmi_txx_int_cn {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3271,9 +3357,9 @@ union cavm_cgxx_gmp_gmi_txx_int {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT(u64 a)
 {
 	return 0x38500 + 0x40000 * a;
 }
@@ -3284,9 +3370,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
  * CGX GMI TX Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_gmi_txx_int_ena_w1c {
+union cgxx_gmp_gmi_txx_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1c_s {
+	struct cgxx_gmp_gmi_txx_int_ena_w1c_s {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3294,7 +3380,7 @@ union cavm_cgxx_gmp_gmi_txx_int_ena_w1c {
 		u64 ptp_lost                         : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1c_cn {
+	struct cgxx_gmp_gmi_txx_int_ena_w1c_cn {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3306,9 +3392,9 @@ union cavm_cgxx_gmp_gmi_txx_int_ena_w1c {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
 {
 	return 0x38510 + 0x40000 * a;
 }
@@ -3319,9 +3405,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
  * CGX GMI TX Interrupt Enable Set Registers This register sets interrupt
  * enable bits.
  */
-union cavm_cgxx_gmp_gmi_txx_int_ena_w1s {
+union cgxx_gmp_gmi_txx_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1s_s {
+	struct cgxx_gmp_gmi_txx_int_ena_w1s_s {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3329,7 +3415,7 @@ union cavm_cgxx_gmp_gmi_txx_int_ena_w1s {
 		u64 ptp_lost                         : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1s_cn {
+	struct cgxx_gmp_gmi_txx_int_ena_w1s_cn {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3341,9 +3427,9 @@ union cavm_cgxx_gmp_gmi_txx_int_ena_w1s {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
 {
 	return 0x38518 + 0x40000 * a;
 }
@@ -3353,9 +3439,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
  *
  * CGX GMI TX Interrupt Set Registers This register sets interrupt bits.
  */
-union cavm_cgxx_gmp_gmi_txx_int_w1s {
+union cgxx_gmp_gmi_txx_int_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_int_w1s_s {
+	struct cgxx_gmp_gmi_txx_int_w1s_s {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3363,7 +3449,7 @@ union cavm_cgxx_gmp_gmi_txx_int_w1s {
 		u64 ptp_lost                         : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	struct cavm_cgxx_gmp_gmi_txx_int_w1s_cn {
+	struct cgxx_gmp_gmi_txx_int_w1s_cn {
 		u64 undflw                           : 1;
 		u64 xscol                            : 1;
 		u64 xsdef                            : 1;
@@ -3375,9 +3461,9 @@ union cavm_cgxx_gmp_gmi_txx_int_w1s {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
 {
 	return 0x38508 + 0x40000 * a;
 }
@@ -3387,18 +3473,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
  *
  * CGX GMI TX Minimum-Size-Packet Registers
  */
-union cavm_cgxx_gmp_gmi_txx_min_pkt {
+union cgxx_gmp_gmi_txx_min_pkt {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_min_pkt_s {
+	struct cgxx_gmp_gmi_txx_min_pkt_s {
 		u64 min_size                         : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_min_pkt_s cn; */
+	/* struct cgxx_gmp_gmi_txx_min_pkt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
 {
 	return 0x38240 + 0x40000 * a;
 }
@@ -3422,18 +3508,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
  * that the system can send (normally 1518B), IFG is the interframe gap
  * and pause_pkt_size is the size of the PAUSE packet (normally 64B).
  */
-union cavm_cgxx_gmp_gmi_txx_pause_pkt_interval {
+union cgxx_gmp_gmi_txx_pause_pkt_interval {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_pause_pkt_interval_s {
+	struct cgxx_gmp_gmi_txx_pause_pkt_interval_s {
 		u64 interval                         : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_pause_pkt_interval_s cn; */
+	/* struct cgxx_gmp_gmi_txx_pause_pkt_interval_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
 {
 	return 0x38248 + 0x40000 * a;
 }
@@ -3443,18 +3529,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
  *
  * CGX GMI TX PAUSE Packet PAUSE-Time Registers
  */
-union cavm_cgxx_gmp_gmi_txx_pause_pkt_time {
+union cgxx_gmp_gmi_txx_pause_pkt_time {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_pause_pkt_time_s {
+	struct cgxx_gmp_gmi_txx_pause_pkt_time_s {
 		u64 ptime                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_pause_pkt_time_s cn; */
+	/* struct cgxx_gmp_gmi_txx_pause_pkt_time_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
 {
 	return 0x38238 + 0x40000 * a;
 }
@@ -3464,18 +3550,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
  *
  * CGX GMI TX Time-to-Backpressure Registers
  */
-union cavm_cgxx_gmp_gmi_txx_pause_togo {
+union cgxx_gmp_gmi_txx_pause_togo {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_pause_togo_s {
+	struct cgxx_gmp_gmi_txx_pause_togo_s {
 		u64 ptime                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_pause_togo_s cn; */
+	/* struct cgxx_gmp_gmi_txx_pause_togo_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
 {
 	return 0x38258 + 0x40000 * a;
 }
@@ -3485,18 +3571,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
  *
  * CGX GMI TX PAUSE-Zero-Enable Registers
  */
-union cavm_cgxx_gmp_gmi_txx_pause_zero {
+union cgxx_gmp_gmi_txx_pause_zero {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_pause_zero_s {
+	struct cgxx_gmp_gmi_txx_pause_zero_s {
 		u64 send                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_pause_zero_s cn; */
+	/* struct cgxx_gmp_gmi_txx_pause_zero_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
 {
 	return 0x38260 + 0x40000 * a;
 }
@@ -3506,18 +3592,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
  *
  * CGX SGMII Control Registers
  */
-union cavm_cgxx_gmp_gmi_txx_sgmii_ctl {
+union cgxx_gmp_gmi_txx_sgmii_ctl {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_sgmii_ctl_s {
+	struct cgxx_gmp_gmi_txx_sgmii_ctl_s {
 		u64 align                            : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_sgmii_ctl_s cn; */
+	/* struct cgxx_gmp_gmi_txx_sgmii_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
 {
 	return 0x38300 + 0x40000 * a;
 }
@@ -3527,18 +3613,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
  *
  * CGX GMI TX Slottime Counter Registers
  */
-union cavm_cgxx_gmp_gmi_txx_slot {
+union cgxx_gmp_gmi_txx_slot {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_slot_s {
+	struct cgxx_gmp_gmi_txx_slot_s {
 		u64 slot                             : 10;
 		u64 reserved_10_63                   : 54;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_slot_s cn; */
+	/* struct cgxx_gmp_gmi_txx_slot_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SLOT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SLOT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SLOT(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SLOT(u64 a)
 {
 	return 0x38220 + 0x40000 * a;
 }
@@ -3548,18 +3634,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_SLOT(u64 a)
  *
  * CGX GMI TX Software PAUSE Registers
  */
-union cavm_cgxx_gmp_gmi_txx_soft_pause {
+union cgxx_gmp_gmi_txx_soft_pause {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_soft_pause_s {
+	struct cgxx_gmp_gmi_txx_soft_pause_s {
 		u64 ptime                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_soft_pause_s cn; */
+	/* struct cgxx_gmp_gmi_txx_soft_pause_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
 {
 	return 0x38250 + 0x40000 * a;
 }
@@ -3569,18 +3655,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
  *
  * CGX GMI TX Threshold Registers
  */
-union cavm_cgxx_gmp_gmi_txx_thresh {
+union cgxx_gmp_gmi_txx_thresh {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_txx_thresh_s {
+	struct cgxx_gmp_gmi_txx_thresh_s {
 		u64 cnt                              : 11;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_txx_thresh_s cn; */
+	/* struct cgxx_gmp_gmi_txx_thresh_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_THRESH(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_THRESH(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TXX_THRESH(u64 a)
+static inline u64 CGXX_GMP_GMI_TXX_THRESH(u64 a)
 {
 	return 0x38210 + 0x40000 * a;
 }
@@ -3590,18 +3676,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_THRESH(u64 a)
  *
  * CGX TX Collision Attempts Before Dropping Frame Registers
  */
-union cavm_cgxx_gmp_gmi_tx_col_attempt {
+union cgxx_gmp_gmi_tx_col_attempt {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_col_attempt_s {
+	struct cgxx_gmp_gmi_tx_col_attempt_s {
 		u64 limit                            : 5;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_col_attempt_s cn; */
+	/* struct cgxx_gmp_gmi_tx_col_attempt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+static inline u64 CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+static inline u64 CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
 {
 	return 0x39010;
 }
@@ -3619,19 +3705,19 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
  * For all other systems, IFG1 and IFG2 can be any value in the range of
  * 1-15, allowing for a total possible IFG sum of 2-30.
  */
-union cavm_cgxx_gmp_gmi_tx_ifg {
+union cgxx_gmp_gmi_tx_ifg {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_ifg_s {
+	struct cgxx_gmp_gmi_tx_ifg_s {
 		u64 ifg1                             : 4;
 		u64 ifg2                             : 4;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_ifg_s cn; */
+	/* struct cgxx_gmp_gmi_tx_ifg_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
+static inline u64 CGXX_GMP_GMI_TX_IFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
+static inline u64 CGXX_GMP_GMI_TX_IFG(void)
 {
 	return 0x39000;
 }
@@ -3642,18 +3728,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
  * CGX GMI TX JAM Pattern Registers This register provides the pattern
  * used in JAM bytes.
  */
-union cavm_cgxx_gmp_gmi_tx_jam {
+union cgxx_gmp_gmi_tx_jam {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_jam_s {
+	struct cgxx_gmp_gmi_tx_jam_s {
 		u64 jam                              : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_jam_s cn; */
+	/* struct cgxx_gmp_gmi_tx_jam_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
+static inline u64 CGXX_GMP_GMI_TX_JAM(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
+static inline u64 CGXX_GMP_GMI_TX_JAM(void)
 {
 	return 0x39008;
 }
@@ -3665,18 +3751,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
  * linear feedback shift register (LFSR), which is used to implement
  * truncated binary exponential backoff.
  */
-union cavm_cgxx_gmp_gmi_tx_lfsr {
+union cgxx_gmp_gmi_tx_lfsr {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_lfsr_s {
+	struct cgxx_gmp_gmi_tx_lfsr_s {
 		u64 lfsr                             : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_lfsr_s cn; */
+	/* struct cgxx_gmp_gmi_tx_lfsr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_LFSR(void)
+static inline u64 CGXX_GMP_GMI_TX_LFSR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_LFSR(void)
+static inline u64 CGXX_GMP_GMI_TX_LFSR(void)
 {
 	return 0x39028;
 }
@@ -3686,18 +3772,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_LFSR(void)
  *
  * CGX TX PAUSE-Packet DMAC-Field Registers
  */
-union cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac {
+union cgxx_gmp_gmi_tx_pause_pkt_dmac {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac_s {
+	struct cgxx_gmp_gmi_tx_pause_pkt_dmac_s {
 		u64 dmac                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac_s cn; */
+	/* struct cgxx_gmp_gmi_tx_pause_pkt_dmac_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
 {
 	return 0x39018;
 }
@@ -3708,18 +3794,18 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
  * CGX GMI TX PAUSE-Packet-PTYPE Field Registers This register provides
  * the PTYPE field that is placed in outbound PAUSE packets.
  */
-union cavm_cgxx_gmp_gmi_tx_pause_pkt_type {
+union cgxx_gmp_gmi_tx_pause_pkt_type {
 	u64 u;
-	struct cavm_cgxx_gmp_gmi_tx_pause_pkt_type_s {
+	struct cgxx_gmp_gmi_tx_pause_pkt_type_s {
 		u64 ptype                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_gmi_tx_pause_pkt_type_s cn; */
+	/* struct cgxx_gmp_gmi_tx_pause_pkt_type_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+static inline u64 CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
 {
 	return 0x39020;
 }
@@ -3731,9 +3817,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
  * general configuration that should not need to be changed from reset
  * settings.  Internal: Per lmac diagnostic and chicken bits.
  */
-union cavm_cgxx_gmp_miscx_cfg {
+union cgxx_gmp_miscx_cfg {
 	u64 u;
-	struct cavm_cgxx_gmp_miscx_cfg_s {
+	struct cgxx_gmp_miscx_cfg_s {
 		u64 tx_eee_quiet_credit_mode         : 1;
 		u64 tx_eee_wait_gmi_fast_idle        : 1;
 		u64 tx_qsgmii_port0_init             : 1;
@@ -3752,12 +3838,12 @@ union cavm_cgxx_gmp_miscx_cfg {
 		u64 rx_cgp_edet_qlm_val              : 1;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_cgxx_gmp_miscx_cfg_s cn; */
+	/* struct cgxx_gmp_miscx_cfg_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
+static inline u64 CGXX_GMP_MISCX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
+static inline u64 CGXX_GMP_MISCX_CFG(u64 a)
 {
 	return 0x34000 + 0x40000 * a;
 }
@@ -3767,20 +3853,20 @@ static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
  *
  * CGX GMP PCS AN Expansion register Register 6 AN status
  */
-union cavm_cgxx_gmp_pcsx_an_expansion {
+union cgxx_gmp_pcsx_an_expansion {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_an_expansion_s {
+	struct cgxx_gmp_pcsx_an_expansion_s {
 		u64 reserved_0                       : 1;
 		u64 page_received                    : 1;
 		u64 next_page_able                   : 1;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_an_expansion_s cn; */
+	/* struct cgxx_gmp_pcsx_an_expansion_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
 {
 	return 0x30a60 + 0x40000 * a;
 }
@@ -3793,9 +3879,9 @@ static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
  * definition for this register is provided in 32.5.4.2 for changes to
  * 28.2.4.1.4.
  */
-union cavm_cgxx_gmp_pcsx_an_lp_abil_np {
+union cgxx_gmp_pcsx_an_lp_abil_np {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_an_lp_abil_np_s {
+	struct cgxx_gmp_pcsx_an_lp_abil_np_s {
 		u64 m_u                              : 11;
 		u64 toggle                           : 1;
 		u64 ack2                             : 1;
@@ -3804,12 +3890,12 @@ union cavm_cgxx_gmp_pcsx_an_lp_abil_np {
 		u64 np                               : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_an_lp_abil_np_s cn; */
+	/* struct cgxx_gmp_pcsx_an_lp_abil_np_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
 {
 	return 0x30a80 + 0x40000 * a;
 }
@@ -3826,9 +3912,9 @@ static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
  * next page exchange continues until both ends of the link segment set
  * their NP bits to 0. Both sides must be NP capable to use NP exchanges.
  */
-union cavm_cgxx_gmp_pcsx_an_np_tx {
+union cgxx_gmp_pcsx_an_np_tx {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_an_np_tx_s {
+	struct cgxx_gmp_pcsx_an_np_tx_s {
 		u64 m_u                              : 11;
 		u64 toggle                           : 1;
 		u64 ack2                             : 1;
@@ -3837,12 +3923,12 @@ union cavm_cgxx_gmp_pcsx_an_np_tx {
 		u64 np                               : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_an_np_tx_s cn; */
+	/* struct cgxx_gmp_pcsx_an_np_tx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_NP_TX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+static inline u64 CGXX_GMP_PCSX_AN_NP_TX(u64 a)
 {
 	return 0x30a70 + 0x40000 * a;
 }
@@ -3852,18 +3938,18 @@ static inline u64 CAVM_CGXX_GMP_PCSX_AN_NP_TX(u64 a)
  *
  * CGX PCS Debug Control Registers
  */
-union cavm_cgxx_gmp_pcsx_dbg_control {
+union cgxx_gmp_pcsx_dbg_control {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_dbg_control_s {
+	struct cgxx_gmp_pcsx_dbg_control_s {
 		u64 us_clk_period                    : 7;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_dbg_control_s cn; */
+	/* struct cgxx_gmp_pcsx_dbg_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+static inline u64 CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+static inline u64 CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
 {
 	return 0x31000 + 0x40000 * a;
 }
@@ -3881,18 +3967,18 @@ static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
  * PCS reset. This counter shall be held at all ones in the case of
  * overflow.
  */
-union cavm_cgxx_gmp_pcsx_rx_eee_wake {
+union cgxx_gmp_pcsx_rx_eee_wake {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_rx_eee_wake_s {
+	struct cgxx_gmp_pcsx_rx_eee_wake_s {
 		u64 error_counter                    : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_rx_eee_wake_s cn; */
+	/* struct cgxx_gmp_pcsx_rx_eee_wake_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+static inline u64 CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+static inline u64 CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
 {
 	return 0x30910 + 0x40000 * a;
 }
@@ -3903,21 +3989,21 @@ static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
  * INTERNAL: CGX GMP PCS  RX EEE LPI Timing Parameters Registers
  * Reserved. Internal: Receiver LPI timing parameters Tqr, Twr and Twtf.
  */
-union cavm_cgxx_gmp_pcsx_rx_lpi_timing {
+union cgxx_gmp_pcsx_rx_lpi_timing {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_rx_lpi_timing_s {
+	struct cgxx_gmp_pcsx_rx_lpi_timing_s {
 		u64 twtf                             : 18;
 		u64 reserved_18_19                   : 2;
 		u64 twr                              : 12;
 		u64 tqr                              : 20;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_rx_lpi_timing_s cn; */
+	/* struct cgxx_gmp_pcsx_rx_lpi_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+static inline u64 CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+static inline u64 CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
 {
 	return 0x30900 + 0x40000 * a;
 }
@@ -3927,9 +4013,9 @@ static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
  *
  * CGX GMP PCS Status 1 Register PCS LPI Status, Link OK.  Register 3.1
  */
-union cavm_cgxx_gmp_pcsx_status1 {
+union cgxx_gmp_pcsx_status1 {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_status1_s {
+	struct cgxx_gmp_pcsx_status1_s {
 		u64 reserved_0_1                     : 2;
 		u64 receive_link_status              : 1;
 		u64 reserved_3_7                     : 5;
@@ -3939,12 +4025,12 @@ union cavm_cgxx_gmp_pcsx_status1 {
 		u64 tx_lpi_received                  : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_status1_s cn; */
+	/* struct cgxx_gmp_pcsx_status1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
+static inline u64 CGXX_GMP_PCSX_STATUS1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
+static inline u64 CGXX_GMP_PCSX_STATUS1(u64 a)
 {
 	return 0x30880 + 0x40000 * a;
 }
@@ -3956,9 +4042,9 @@ static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
  * Reserved. Internal: Transmitter LPI timing parameters Tsl, Tql and
  * Tul.
  */
-union cavm_cgxx_gmp_pcsx_tx_lpi_timing {
+union cgxx_gmp_pcsx_tx_lpi_timing {
 	u64 u;
-	struct cavm_cgxx_gmp_pcsx_tx_lpi_timing_s {
+	struct cgxx_gmp_pcsx_tx_lpi_timing_s {
 		u64 tql                              : 19;
 		u64 reserved_19_31                   : 13;
 		u64 tul                              : 12;
@@ -3966,12 +4052,12 @@ union cavm_cgxx_gmp_pcsx_tx_lpi_timing {
 		u64 tsl                              : 12;
 		u64 reserved_60_63                   : 4;
 	} s;
-	/* struct cavm_cgxx_gmp_pcsx_tx_lpi_timing_s cn; */
+	/* struct cgxx_gmp_pcsx_tx_lpi_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+static inline u64 CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+static inline u64 CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
 {
 	return 0x30800 + 0x40000 * a;
 }
@@ -3981,9 +4067,9 @@ static inline u64 CAVM_CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
  *
  * CGX GMP PCS Autonegotiation Advertisement Registers
  */
-union cavm_cgxx_gmp_pcs_anx_adv {
+union cgxx_gmp_pcs_anx_adv {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_anx_adv_s {
+	struct cgxx_gmp_pcs_anx_adv_s {
 		u64 reserved_0_4                     : 5;
 		u64 fd                               : 1;
 		u64 hfd                              : 1;
@@ -3994,12 +4080,12 @@ union cavm_cgxx_gmp_pcs_anx_adv {
 		u64 np                               : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_anx_adv_s cn; */
+	/* struct cgxx_gmp_pcs_anx_adv_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_ADV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_ADV(u64 a)
 {
 	return 0x30010 + 0x40000 * a;
 }
@@ -4009,9 +4095,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_ADV(u64 a)
  *
  * CGX GMO PCS Autonegotiation Extended Status Registers
  */
-union cavm_cgxx_gmp_pcs_anx_ext_st {
+union cgxx_gmp_pcs_anx_ext_st {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_anx_ext_st_s {
+	struct cgxx_gmp_pcs_anx_ext_st_s {
 		u64 reserved_0_11                    : 12;
 		u64 thou_thd                         : 1;
 		u64 thou_tfd                         : 1;
@@ -4019,12 +4105,12 @@ union cavm_cgxx_gmp_pcs_anx_ext_st {
 		u64 thou_xfd                         : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_anx_ext_st_s cn; */
+	/* struct cgxx_gmp_pcs_anx_ext_st_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
 {
 	return 0x30028 + 0x40000 * a;
 }
@@ -4036,9 +4122,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
  * autonegotiation link partner ability register 5 as per IEEE 802.3,
  * Clause 37.
  */
-union cavm_cgxx_gmp_pcs_anx_lp_abil {
+union cgxx_gmp_pcs_anx_lp_abil {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_anx_lp_abil_s {
+	struct cgxx_gmp_pcs_anx_lp_abil_s {
 		u64 reserved_0_4                     : 5;
 		u64 fd                               : 1;
 		u64 hfd                              : 1;
@@ -4049,12 +4135,12 @@ union cavm_cgxx_gmp_pcs_anx_lp_abil {
 		u64 np                               : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_anx_lp_abil_s cn; */
+	/* struct cgxx_gmp_pcs_anx_lp_abil_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
 {
 	return 0x30018 + 0x40000 * a;
 }
@@ -4068,9 +4154,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
  * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is
  * valid.
  */
-union cavm_cgxx_gmp_pcs_anx_results {
+union cgxx_gmp_pcs_anx_results {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_anx_results_s {
+	struct cgxx_gmp_pcs_anx_results_s {
 		u64 link_ok                          : 1;
 		u64 dup                              : 1;
 		u64 an_cpt                           : 1;
@@ -4078,12 +4164,12 @@ union cavm_cgxx_gmp_pcs_anx_results {
 		u64 pause                            : 2;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_anx_results_s cn; */
+	/* struct cgxx_gmp_pcs_anx_results_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_RESULTS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+static inline u64 CGXX_GMP_PCS_ANX_RESULTS(u64 a)
 {
 	return 0x30020 + 0x40000 * a;
 }
@@ -4093,9 +4179,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_RESULTS(u64 a)
  *
  * CGX GMP PCS Interrupt Registers
  */
-union cavm_cgxx_gmp_pcs_intx {
+union cgxx_gmp_pcs_intx {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_intx_s {
+	struct cgxx_gmp_pcs_intx_s {
 		u64 lnkspd                           : 1;
 		u64 xmit                             : 1;
 		u64 an_err                           : 1;
@@ -4118,12 +4204,12 @@ union cavm_cgxx_gmp_pcs_intx {
 		u64 eee_rx_link_fail                 : 1;
 		u64 reserved_23_63                   : 41;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_intx_s cn; */
+	/* struct cgxx_gmp_pcs_intx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX(u64 a)
 {
 	return 0x30080 + 0x40000 * a;
 }
@@ -4134,9 +4220,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
  * CGX GMP PCS Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_pcs_intx_ena_w1c {
+union cgxx_gmp_pcs_intx_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_intx_ena_w1c_s {
+	struct cgxx_gmp_pcs_intx_ena_w1c_s {
 		u64 lnkspd                           : 1;
 		u64 xmit                             : 1;
 		u64 an_err                           : 1;
@@ -4159,12 +4245,12 @@ union cavm_cgxx_gmp_pcs_intx_ena_w1c {
 		u64 eee_rx_link_fail                 : 1;
 		u64 reserved_23_63                   : 41;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_intx_ena_w1c_s cn; */
+	/* struct cgxx_gmp_pcs_intx_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
 {
 	return 0x30090 + 0x40000 * a;
 }
@@ -4175,9 +4261,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
  * CGX GMP PCS Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_gmp_pcs_intx_ena_w1s {
+union cgxx_gmp_pcs_intx_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_intx_ena_w1s_s {
+	struct cgxx_gmp_pcs_intx_ena_w1s_s {
 		u64 lnkspd                           : 1;
 		u64 xmit                             : 1;
 		u64 an_err                           : 1;
@@ -4200,12 +4286,12 @@ union cavm_cgxx_gmp_pcs_intx_ena_w1s {
 		u64 eee_rx_link_fail                 : 1;
 		u64 reserved_23_63                   : 41;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_intx_ena_w1s_s cn; */
+	/* struct cgxx_gmp_pcs_intx_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
 {
 	return 0x30098 + 0x40000 * a;
 }
@@ -4215,9 +4301,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
  *
  * CGX GMP PCS Interrupt Set Registers This register sets interrupt bits.
  */
-union cavm_cgxx_gmp_pcs_intx_w1s {
+union cgxx_gmp_pcs_intx_w1s {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_intx_w1s_s {
+	struct cgxx_gmp_pcs_intx_w1s_s {
 		u64 lnkspd                           : 1;
 		u64 xmit                             : 1;
 		u64 an_err                           : 1;
@@ -4240,12 +4326,12 @@ union cavm_cgxx_gmp_pcs_intx_w1s {
 		u64 eee_rx_link_fail                 : 1;
 		u64 reserved_23_63                   : 41;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_intx_w1s_s cn; */
+	/* struct cgxx_gmp_pcs_intx_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
+static inline u64 CGXX_GMP_PCS_INTX_W1S(u64 a)
 {
 	return 0x30088 + 0x40000 * a;
 }
@@ -4256,18 +4342,18 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
  * CGX GMP PCS Link Timer Registers This is the 1.6 ms nominal link timer
  * register.
  */
-union cavm_cgxx_gmp_pcs_linkx_timer {
+union cgxx_gmp_pcs_linkx_timer {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_linkx_timer_s {
+	struct cgxx_gmp_pcs_linkx_timer_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_linkx_timer_s cn; */
+	/* struct cgxx_gmp_pcs_linkx_timer_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+static inline u64 CGXX_GMP_PCS_LINKX_TIMER(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+static inline u64 CGXX_GMP_PCS_LINKX_TIMER(u64 a)
 {
 	return 0x30040 + 0x40000 * a;
 }
@@ -4284,9 +4370,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
  * tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation
  * results.
  */
-union cavm_cgxx_gmp_pcs_miscx_ctl {
+union cgxx_gmp_pcs_miscx_ctl {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_miscx_ctl_s {
+	struct cgxx_gmp_pcs_miscx_ctl_s {
 		u64 samp_pt                          : 7;
 		u64 an_ovrd                          : 1;
 		u64 mode                             : 1;
@@ -4300,7 +4386,7 @@ union cavm_cgxx_gmp_pcs_miscx_ctl {
 		u64 qsgmii_comma_wd_en               : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	struct cavm_cgxx_gmp_pcs_miscx_ctl_cn {
+	struct cgxx_gmp_pcs_miscx_ctl_cn {
 		u64 samp_pt                          : 7;
 		u64 an_ovrd                          : 1;
 		u64 mode                             : 1;
@@ -4317,9 +4403,9 @@ union cavm_cgxx_gmp_pcs_miscx_ctl {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_MISCX_CTL(u64 a)
+static inline u64 CGXX_GMP_PCS_MISCX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_MISCX_CTL(u64 a)
+static inline u64 CGXX_GMP_PCS_MISCX_CTL(u64 a)
 {
 	return 0x30078 + 0x40000 * a;
 }
@@ -4329,9 +4415,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_MISCX_CTL(u64 a)
  *
  * CGX GMP PCS Control Registers
  */
-union cavm_cgxx_gmp_pcs_mrx_control {
+union cgxx_gmp_pcs_mrx_control {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_mrx_control_s {
+	struct cgxx_gmp_pcs_mrx_control_s {
 		u64 reserved_0_4                     : 5;
 		u64 uni                              : 1;
 		u64 spdmsb                           : 1;
@@ -4346,12 +4432,12 @@ union cavm_cgxx_gmp_pcs_mrx_control {
 		u64 reset                            : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_mrx_control_s cn; */
+	/* struct cgxx_gmp_pcs_mrx_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+static inline u64 CGXX_GMP_PCS_MRX_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+static inline u64 CGXX_GMP_PCS_MRX_CONTROL(u64 a)
 {
 	return 0x30000 + 0x40000 * a;
 }
@@ -4365,9 +4451,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
  * chip cannot operate in the corresponding modes. The field [RM_FLT] is
  * a 'don't care' when the selected mode is SGMII/QSGMII.
  */
-union cavm_cgxx_gmp_pcs_mrx_status {
+union cgxx_gmp_pcs_mrx_status {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_mrx_status_s {
+	struct cgxx_gmp_pcs_mrx_status_s {
 		u64 extnd                            : 1;
 		u64 reserved_1                       : 1;
 		u64 lnk_st                           : 1;
@@ -4386,12 +4472,12 @@ union cavm_cgxx_gmp_pcs_mrx_status {
 		u64 hun_t4                           : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_mrx_status_s cn; */
+	/* struct cgxx_gmp_pcs_mrx_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_MRX_STATUS(u64 a)
+static inline u64 CGXX_GMP_PCS_MRX_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_MRX_STATUS(u64 a)
+static inline u64 CGXX_GMP_PCS_MRX_STATUS(u64 a)
 {
 	return 0x30008 + 0x40000 * a;
 }
@@ -4401,9 +4487,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_MRX_STATUS(u64 a)
  *
  * CGX GMP PCS RX State-Machines States Registers
  */
-union cavm_cgxx_gmp_pcs_rxx_states {
+union cgxx_gmp_pcs_rxx_states {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_rxx_states_s {
+	struct cgxx_gmp_pcs_rxx_states_s {
 		u64 an_st                            : 4;
 		u64 an_bad                           : 1;
 		u64 sync                             : 4;
@@ -4412,12 +4498,12 @@ union cavm_cgxx_gmp_pcs_rxx_states {
 		u64 rx_bad                           : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_rxx_states_s cn; */
+	/* struct cgxx_gmp_pcs_rxx_states_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_RXX_STATES(u64 a)
+static inline u64 CGXX_GMP_PCS_RXX_STATES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_RXX_STATES(u64 a)
+static inline u64 CGXX_GMP_PCS_RXX_STATES(u64 a)
 {
 	return 0x30058 + 0x40000 * a;
 }
@@ -4427,19 +4513,19 @@ static inline u64 CAVM_CGXX_GMP_PCS_RXX_STATES(u64 a)
  *
  * CGX GMP PCS Code Group Synchronization Registers
  */
-union cavm_cgxx_gmp_pcs_rxx_sync {
+union cgxx_gmp_pcs_rxx_sync {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_rxx_sync_s {
+	struct cgxx_gmp_pcs_rxx_sync_s {
 		u64 bit_lock                         : 1;
 		u64 sync                             : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_rxx_sync_s cn; */
+	/* struct cgxx_gmp_pcs_rxx_sync_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
+static inline u64 CGXX_GMP_PCS_RXX_SYNC(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
+static inline u64 CGXX_GMP_PCS_RXX_SYNC(u64 a)
 {
 	return 0x30050 + 0x40000 * a;
 }
@@ -4456,9 +4542,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
  * tx_Config_Reg\<0\> is always 1. All other bits in tx_Config_Reg sent
  * will be 0. The PHY dictates the autonegotiation results.
  */
-union cavm_cgxx_gmp_pcs_sgmx_an_adv {
+union cgxx_gmp_pcs_sgmx_an_adv {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_sgmx_an_adv_s {
+	struct cgxx_gmp_pcs_sgmx_an_adv_s {
 		u64 one                              : 1;
 		u64 reserved_1_9                     : 9;
 		u64 speed                            : 2;
@@ -4468,12 +4554,12 @@ union cavm_cgxx_gmp_pcs_sgmx_an_adv {
 		u64 link                             : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_sgmx_an_adv_s cn; */
+	/* struct cgxx_gmp_pcs_sgmx_an_adv_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
 {
 	return 0x30068 + 0x40000 * a;
 }
@@ -4485,9 +4571,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
  * SGMII link partner advertisement register (received as
  * rx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37).
  */
-union cavm_cgxx_gmp_pcs_sgmx_lp_adv {
+union cgxx_gmp_pcs_sgmx_lp_adv {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_sgmx_lp_adv_s {
+	struct cgxx_gmp_pcs_sgmx_lp_adv_s {
 		u64 one                              : 1;
 		u64 reserved_1_9                     : 9;
 		u64 speed                            : 2;
@@ -4496,7 +4582,7 @@ union cavm_cgxx_gmp_pcs_sgmx_lp_adv {
 		u64 link                             : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	struct cavm_cgxx_gmp_pcs_sgmx_lp_adv_cn {
+	struct cgxx_gmp_pcs_sgmx_lp_adv_cn {
 		u64 one                              : 1;
 		u64 reserved_1_9                     : 9;
 		u64 speed                            : 2;
@@ -4508,9 +4594,9 @@ union cavm_cgxx_gmp_pcs_sgmx_lp_adv {
 	} cn;
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+static inline u64 CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
 {
 	return 0x30070 + 0x40000 * a;
 }
@@ -4520,20 +4606,20 @@ static inline u64 CAVM_CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
  *
  * CGX GMP PCS TX State-Machines States Registers
  */
-union cavm_cgxx_gmp_pcs_txx_states {
+union cgxx_gmp_pcs_txx_states {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_txx_states_s {
+	struct cgxx_gmp_pcs_txx_states_s {
 		u64 ord_st                           : 4;
 		u64 tx_bad                           : 1;
 		u64 xmit                             : 2;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_txx_states_s cn; */
+	/* struct cgxx_gmp_pcs_txx_states_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
+static inline u64 CGXX_GMP_PCS_TXX_STATES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
+static inline u64 CGXX_GMP_PCS_TXX_STATES(u64 a)
 {
 	return 0x30060 + 0x40000 * a;
 }
@@ -4547,21 +4633,21 @@ static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
  * When LMAC_TYPE=QSGMII, only lane 0 polarity data and settings are
  * relevant and settings for lanes 1, 2 and 3 are unused.
  */
-union cavm_cgxx_gmp_pcs_tx_rxx_polarity {
+union cgxx_gmp_pcs_tx_rxx_polarity {
 	u64 u;
-	struct cavm_cgxx_gmp_pcs_tx_rxx_polarity_s {
+	struct cgxx_gmp_pcs_tx_rxx_polarity_s {
 		u64 txplrt                           : 1;
 		u64 rxplrt                           : 1;
 		u64 autorxpl                         : 1;
 		u64 rxovrd                           : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_gmp_pcs_tx_rxx_polarity_s cn; */
+	/* struct cgxx_gmp_pcs_tx_rxx_polarity_s cn; */
 };
 
-static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+static inline u64 CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+static inline u64 CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
 {
 	return 0x30048 + 0x40000 * a;
 }
@@ -4572,17 +4658,17 @@ static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
  * CGX MSI-X Pending Bit Array Registers This register is the MSI-X PBA
  * table, the bit number is indexed by the CGX_INT_VEC_E enumeration.
  */
-union cavm_cgxx_msix_pbax {
+union cgxx_msix_pbax {
 	u64 u;
-	struct cavm_cgxx_msix_pbax_s {
+	struct cgxx_msix_pbax_s {
 		u64 pend                             : 64;
 	} s;
-	/* struct cavm_cgxx_msix_pbax_s cn; */
+	/* struct cgxx_msix_pbax_s cn; */
 };
 
-static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
+static inline u64 CGXX_MSIX_PBAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
+static inline u64 CGXX_MSIX_PBAX(u64 a)
 {
 	return 0xf0000 + 8 * a;
 }
@@ -4593,20 +4679,20 @@ static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
  * CGX MSI-X Vector Table Address Registers This register is the MSI-X
  * vector table, indexed by the CGX_INT_VEC_E enumeration.
  */
-union cavm_cgxx_msix_vecx_addr {
+union cgxx_msix_vecx_addr {
 	u64 u;
-	struct cavm_cgxx_msix_vecx_addr_s {
+	struct cgxx_msix_vecx_addr_s {
 		u64 secvec                           : 1;
 		u64 reserved_1                       : 1;
 		u64 addr                             : 51;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_cgxx_msix_vecx_addr_s cn; */
+	/* struct cgxx_msix_vecx_addr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
+static inline u64 CGXX_MSIX_VECX_ADDR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
+static inline u64 CGXX_MSIX_VECX_ADDR(u64 a)
 {
 	return 0 + 0x10 * a;
 }
@@ -4617,19 +4703,19 @@ static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
  * CGX MSI-X Vector Table Control and Data Registers This register is the
  * MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
  */
-union cavm_cgxx_msix_vecx_ctl {
+union cgxx_msix_vecx_ctl {
 	u64 u;
-	struct cavm_cgxx_msix_vecx_ctl_s {
+	struct cgxx_msix_vecx_ctl_s {
 		u64 data                             : 32;
 		u64 mask                             : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_cgxx_msix_vecx_ctl_s cn; */
+	/* struct cgxx_msix_vecx_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_MSIX_VECX_CTL(u64 a)
+static inline u64 CGXX_MSIX_VECX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_MSIX_VECX_CTL(u64 a)
+static inline u64 CGXX_MSIX_VECX_CTL(u64 a)
 {
 	return 8 + 0x10 * a;
 }
@@ -4639,9 +4725,9 @@ static inline u64 CAVM_CGXX_MSIX_VECX_CTL(u64 a)
  *
  * INTERNAL: CGX SMU TX Backpressure Test Registers
  */
-union cavm_cgxx_smux_bp_test {
+union cgxx_smux_bp_test {
 	u64 u;
-	struct cavm_cgxx_smux_bp_test_s {
+	struct cgxx_smux_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
@@ -4649,12 +4735,12 @@ union cavm_cgxx_smux_bp_test {
 		u64 enable                           : 4;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_cgxx_smux_bp_test_s cn; */
+	/* struct cgxx_smux_bp_test_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
+static inline u64 CGXX_SMUX_BP_TEST(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
+static inline u64 CGXX_SMUX_BP_TEST(u64 a)
 {
 	return 0x20230 + 0x40000 * a;
 }
@@ -4666,9 +4752,9 @@ static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
  * class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
  * ([LOGL_EN]\<i\> & cmr_rx_logl_xoff\<i\>).
  */
-union cavm_cgxx_smux_cbfc_ctl {
+union cgxx_smux_cbfc_ctl {
 	u64 u;
-	struct cavm_cgxx_smux_cbfc_ctl_s {
+	struct cgxx_smux_cbfc_ctl_s {
 		u64 rx_en                            : 1;
 		u64 tx_en                            : 1;
 		u64 drp_en                           : 1;
@@ -4677,12 +4763,12 @@ union cavm_cgxx_smux_cbfc_ctl {
 		u64 logl_en                          : 16;
 		u64 phys_en                          : 16;
 	} s;
-	/* struct cavm_cgxx_smux_cbfc_ctl_s cn; */
+	/* struct cgxx_smux_cbfc_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_CBFC_CTL(u64 a)
+static inline u64 CGXX_SMUX_CBFC_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_CBFC_CTL(u64 a)
+static inline u64 CGXX_SMUX_CBFC_CTL(u64 a)
 {
 	return 0x20218 + 0x40000 * a;
 }
@@ -4692,19 +4778,19 @@ static inline u64 CAVM_CGXX_SMUX_CBFC_CTL(u64 a)
  *
  * CGX SMU Control Registers
  */
-union cavm_cgxx_smux_ctrl {
+union cgxx_smux_ctrl {
 	u64 u;
-	struct cavm_cgxx_smux_ctrl_s {
+	struct cgxx_smux_ctrl_s {
 		u64 rx_idle                          : 1;
 		u64 tx_idle                          : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_smux_ctrl_s cn; */
+	/* struct cgxx_smux_ctrl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
+static inline u64 CGXX_SMUX_CTRL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
+static inline u64 CGXX_SMUX_CTRL(u64 a)
 {
 	return 0x20200 + 0x40000 * a;
 }
@@ -4716,9 +4802,9 @@ static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
  * local and remote parties must match exactly; otherwise loopback FIFO
  * will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
  */
-union cavm_cgxx_smux_ext_loopback {
+union cgxx_smux_ext_loopback {
 	u64 u;
-	struct cavm_cgxx_smux_ext_loopback_s {
+	struct cgxx_smux_ext_loopback_s {
 		u64 thresh                           : 6;
 		u64 reserved_6_7                     : 2;
 		u64 depth                            : 6;
@@ -4726,12 +4812,12 @@ union cavm_cgxx_smux_ext_loopback {
 		u64 en                               : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_cgxx_smux_ext_loopback_s cn; */
+	/* struct cgxx_smux_ext_loopback_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
+static inline u64 CGXX_SMUX_EXT_LOOPBACK(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
+static inline u64 CGXX_SMUX_EXT_LOOPBACK(u64 a)
 {
 	return 0x20208 + 0x40000 * a;
 }
@@ -4757,21 +4843,21 @@ static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
  * Hardware can only autogenerate backpressure via HiGig2 messages
  * (optionally, when [HG2TX_EN] = 1) with the HiGig2 protocol.
  */
-union cavm_cgxx_smux_hg2_control {
+union cgxx_smux_hg2_control {
 	u64 u;
-	struct cavm_cgxx_smux_hg2_control_s {
+	struct cgxx_smux_hg2_control_s {
 		u64 logl_en                          : 16;
 		u64 phys_en                          : 1;
 		u64 hg2rx_en                         : 1;
 		u64 hg2tx_en                         : 1;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_cgxx_smux_hg2_control_s cn; */
+	/* struct cgxx_smux_hg2_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
+static inline u64 CGXX_SMUX_HG2_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
+static inline u64 CGXX_SMUX_HG2_CONTROL(u64 a)
 {
 	return 0x20210 + 0x40000 * a;
 }
@@ -4783,9 +4869,9 @@ static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
  * MMSI control and status registers for frame preemption mode. Refer to
  * IEEE 802.3br, Clause 99.
  */
-union cavm_cgxx_smux_mmsi_ctl_sta {
+union cgxx_smux_mmsi_ctl_sta {
 	u64 u;
-	struct cavm_cgxx_smux_mmsi_ctl_sta_s {
+	struct cgxx_smux_mmsi_ctl_sta_s {
 		u64 p_en                             : 1;
 		u64 dis_v                            : 1;
 		u64 afs                              : 2;
@@ -4795,12 +4881,12 @@ union cavm_cgxx_smux_mmsi_ctl_sta {
 		u64 v_time                           : 24;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_cgxx_smux_mmsi_ctl_sta_s cn; */
+	/* struct cgxx_smux_mmsi_ctl_sta_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_MMSI_CTL_STA(u64 a)
+static inline u64 CGXX_SMUX_MMSI_CTL_STA(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_MMSI_CTL_STA(u64 a)
+static inline u64 CGXX_SMUX_MMSI_CTL_STA(u64 a)
 {
 	return 0x20220 + 0x40000 * a;
 }
@@ -4810,20 +4896,20 @@ static inline u64 CAVM_CGXX_SMUX_MMSI_CTL_STA(u64 a)
  *
  * CGX SMU RX Bad Column High Registers
  */
-union cavm_cgxx_smux_rx_bad_col_ctrl {
+union cgxx_smux_rx_bad_col_ctrl {
 	u64 u;
-	struct cavm_cgxx_smux_rx_bad_col_ctrl_s {
+	struct cgxx_smux_rx_bad_col_ctrl_s {
 		u64 lane_rxc                         : 16;
 		u64 state                            : 3;
 		u64 val                              : 1;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_cgxx_smux_rx_bad_col_ctrl_s cn; */
+	/* struct cgxx_smux_rx_bad_col_ctrl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
 {
 	return 0x20060 + 0x40000 * a;
 }
@@ -4833,17 +4919,17 @@ static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
  *
  * CGX SMU RX Bad Column Low Registers
  */
-union cavm_cgxx_smux_rx_bad_col_data_hi {
+union cgxx_smux_rx_bad_col_data_hi {
 	u64 u;
-	struct cavm_cgxx_smux_rx_bad_col_data_hi_s {
+	struct cgxx_smux_rx_bad_col_data_hi_s {
 		u64 lane_rxd                         : 64;
 	} s;
-	/* struct cavm_cgxx_smux_rx_bad_col_data_hi_s cn; */
+	/* struct cgxx_smux_rx_bad_col_data_hi_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
 {
 	return 0x20058 + 0x40000 * a;
 }
@@ -4853,17 +4939,17 @@ static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
  *
  * CGX SMU RX Bad Column Low Registers
  */
-union cavm_cgxx_smux_rx_bad_col_data_lo {
+union cgxx_smux_rx_bad_col_data_lo {
 	u64 u;
-	struct cavm_cgxx_smux_rx_bad_col_data_lo_s {
+	struct cgxx_smux_rx_bad_col_data_lo_s {
 		u64 lane_rxd                         : 64;
 	} s;
-	/* struct cavm_cgxx_smux_rx_bad_col_data_lo_s cn; */
+	/* struct cgxx_smux_rx_bad_col_data_lo_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+static inline u64 CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
 {
 	return 0x20050 + 0x40000 * a;
 }
@@ -4873,18 +4959,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
  *
  * CGX SMU RX Control Registers
  */
-union cavm_cgxx_smux_rx_ctl {
+union cgxx_smux_rx_ctl {
 	u64 u;
-	struct cavm_cgxx_smux_rx_ctl_s {
+	struct cgxx_smux_rx_ctl_s {
 		u64 status                           : 2;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_smux_rx_ctl_s cn; */
+	/* struct cgxx_smux_rx_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
+static inline u64 CGXX_SMUX_RX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
+static inline u64 CGXX_SMUX_RX_CTL(u64 a)
 {
 	return 0x20048 + 0x40000 * a;
 }
@@ -4900,18 +4986,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
  * the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
  * optional UDD skip data (CGX()_SMU()_RX_UDD_SKP[LEN]).
  */
-union cavm_cgxx_smux_rx_decision {
+union cgxx_smux_rx_decision {
 	u64 u;
-	struct cavm_cgxx_smux_rx_decision_s {
+	struct cgxx_smux_rx_decision_s {
 		u64 cnt                              : 5;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_cgxx_smux_rx_decision_s cn; */
+	/* struct cgxx_smux_rx_decision_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
+static inline u64 CGXX_SMUX_RX_DECISION(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
+static inline u64 CGXX_SMUX_RX_DECISION(u64 a)
 {
 	return 0x20038 + 0x40000 * a;
 }
@@ -4922,9 +5008,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
  * CGX SMU RX Frame Check Registers The CSRs provide the enable bits for
  * a subset of errors passed to CMR encoded.
  */
-union cavm_cgxx_smux_rx_frm_chk {
+union cgxx_smux_rx_frm_chk {
 	u64 u;
-	struct cavm_cgxx_smux_rx_frm_chk_s {
+	struct cgxx_smux_rx_frm_chk_s {
 		u64 reserved_0_2                     : 3;
 		u64 jabber                           : 1;
 		u64 fcserr_d                         : 1;
@@ -4934,12 +5020,12 @@ union cavm_cgxx_smux_rx_frm_chk {
 		u64 skperr                           : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_cgxx_smux_rx_frm_chk_s cn; */
+	/* struct cgxx_smux_rx_frm_chk_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
+static inline u64 CGXX_SMUX_RX_FRM_CHK(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
+static inline u64 CGXX_SMUX_RX_FRM_CHK(u64 a)
 {
 	return 0x20028 + 0x40000 * a;
 }
@@ -4959,9 +5045,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
  * be handled by the processing cores. PAUSE packets should not be
  * forwarded.
  */
-union cavm_cgxx_smux_rx_frm_ctl {
+union cgxx_smux_rx_frm_ctl {
 	u64 u;
-	struct cavm_cgxx_smux_rx_frm_ctl_s {
+	struct cgxx_smux_rx_frm_ctl_s {
 		u64 pre_chk                          : 1;
 		u64 pre_strp                         : 1;
 		u64 ctl_drp                          : 1;
@@ -4972,12 +5058,12 @@ union cavm_cgxx_smux_rx_frm_ctl {
 		u64 ptp_mode                         : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_cgxx_smux_rx_frm_ctl_s cn; */
+	/* struct cgxx_smux_rx_frm_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
+static inline u64 CGXX_SMUX_RX_FRM_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
+static inline u64 CGXX_SMUX_RX_FRM_CTL(u64 a)
 {
 	return 0x20020 + 0x40000 * a;
 }
@@ -4990,9 +5076,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
  * the received packet's work queue entry. CGX()_SMU()_RX_FRM_CHK
  * provides a bit mask for configuring which conditions set the error.
  */
-union cavm_cgxx_smux_rx_int {
+union cgxx_smux_rx_int {
 	u64 u;
-	struct cavm_cgxx_smux_rx_int_s {
+	struct cgxx_smux_rx_int_s {
 		u64 jabber                           : 1;
 		u64 fcserr                           : 1;
 		u64 rcverr                           : 1;
@@ -5009,12 +5095,12 @@ union cavm_cgxx_smux_rx_int {
 		u64 badrsp                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_smux_rx_int_s cn; */
+	/* struct cgxx_smux_rx_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
+static inline u64 CGXX_SMUX_RX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
+static inline u64 CGXX_SMUX_RX_INT(u64 a)
 {
 	return 0x20000 + 0x40000 * a;
 }
@@ -5025,9 +5111,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
  * CGX SMU Receive Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_smux_rx_int_ena_w1c {
+union cgxx_smux_rx_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_smux_rx_int_ena_w1c_s {
+	struct cgxx_smux_rx_int_ena_w1c_s {
 		u64 jabber                           : 1;
 		u64 fcserr                           : 1;
 		u64 rcverr                           : 1;
@@ -5044,12 +5130,12 @@ union cavm_cgxx_smux_rx_int_ena_w1c {
 		u64 badrsp                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_smux_rx_int_ena_w1c_s cn; */
+	/* struct cgxx_smux_rx_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
 {
 	return 0x20010 + 0x40000 * a;
 }
@@ -5060,9 +5146,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
  * CGX SMU Receive Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_smux_rx_int_ena_w1s {
+union cgxx_smux_rx_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_rx_int_ena_w1s_s {
+	struct cgxx_smux_rx_int_ena_w1s_s {
 		u64 jabber                           : 1;
 		u64 fcserr                           : 1;
 		u64 rcverr                           : 1;
@@ -5079,12 +5165,12 @@ union cavm_cgxx_smux_rx_int_ena_w1s {
 		u64 badrsp                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_smux_rx_int_ena_w1s_s cn; */
+	/* struct cgxx_smux_rx_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
 {
 	return 0x20018 + 0x40000 * a;
 }
@@ -5095,9 +5181,9 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
  * CGX SMU Receive Interrupt Set Registers This register sets interrupt
  * bits.
  */
-union cavm_cgxx_smux_rx_int_w1s {
+union cgxx_smux_rx_int_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_rx_int_w1s_s {
+	struct cgxx_smux_rx_int_w1s_s {
 		u64 jabber                           : 1;
 		u64 fcserr                           : 1;
 		u64 rcverr                           : 1;
@@ -5114,12 +5200,12 @@ union cavm_cgxx_smux_rx_int_w1s {
 		u64 badrsp                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_smux_rx_int_w1s_s cn; */
+	/* struct cgxx_smux_rx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_INT_W1S(u64 a)
 {
 	return 0x20008 + 0x40000 * a;
 }
@@ -5133,18 +5219,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
  * checking is performed before preamble is stripped or PTP is inserted.
  * If present, preamble is counted as eight bytes of the incoming packet.
  */
-union cavm_cgxx_smux_rx_jabber {
+union cgxx_smux_rx_jabber {
 	u64 u;
-	struct cavm_cgxx_smux_rx_jabber_s {
+	struct cgxx_smux_rx_jabber_s {
 		u64 cnt                              : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_rx_jabber_s cn; */
+	/* struct cgxx_smux_rx_jabber_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
+static inline u64 CGXX_SMUX_RX_JABBER(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
+static inline u64 CGXX_SMUX_RX_JABBER(u64 a)
 {
 	return 0x20030 + 0x40000 * a;
 }
@@ -5165,20 +5251,20 @@ static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
  * UDD bytes will be sent down the packet interface as part of the
  * packet.  The UDD bytes are never stripped from the actual packet.
  */
-union cavm_cgxx_smux_rx_udd_skp {
+union cgxx_smux_rx_udd_skp {
 	u64 u;
-	struct cavm_cgxx_smux_rx_udd_skp_s {
+	struct cgxx_smux_rx_udd_skp_s {
 		u64 len                              : 7;
 		u64 reserved_7                       : 1;
 		u64 fcssel                           : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_cgxx_smux_rx_udd_skp_s cn; */
+	/* struct cgxx_smux_rx_udd_skp_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_UDD_SKP(u64 a)
+static inline u64 CGXX_SMUX_RX_UDD_SKP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_UDD_SKP(u64 a)
+static inline u64 CGXX_SMUX_RX_UDD_SKP(u64 a)
 {
 	return 0x20040 + 0x40000 * a;
 }
@@ -5188,19 +5274,19 @@ static inline u64 CAVM_CGXX_SMUX_RX_UDD_SKP(u64 a)
  *
  * CGX SMU RX Wake-on-LAN Control 0 Registers
  */
-union cavm_cgxx_smux_rx_wol_ctrl0 {
+union cgxx_smux_rx_wol_ctrl0 {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_ctrl0_s {
+	struct cgxx_smux_rx_wol_ctrl0_s {
 		u64 dmac                             : 48;
 		u64 pswd_len                         : 4;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_ctrl0_s cn; */
+	/* struct cgxx_smux_rx_wol_ctrl0_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_CTRL0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_CTRL0(u64 a)
 {
 	return 0x20068 + 0x40000 * a;
 }
@@ -5210,17 +5296,17 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL0(u64 a)
  *
  * CGX SMU RX Wake-on-LAN Control 1 Registers
  */
-union cavm_cgxx_smux_rx_wol_ctrl1 {
+union cgxx_smux_rx_wol_ctrl1 {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_ctrl1_s {
+	struct cgxx_smux_rx_wol_ctrl1_s {
 		u64 pswd                             : 64;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_ctrl1_s cn; */
+	/* struct cgxx_smux_rx_wol_ctrl1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_CTRL1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_CTRL1(u64 a)
 {
 	return 0x20070 + 0x40000 * a;
 }
@@ -5231,18 +5317,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
  * CGX SMU RX WOL Interrupt Registers These registers allow WOL
  * interrupts to be sent to the control processor.
  */
-union cavm_cgxx_smux_rx_wol_int {
+union cgxx_smux_rx_wol_int {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_int_s {
+	struct cgxx_smux_rx_wol_int_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_int_s cn; */
+	/* struct cgxx_smux_rx_wol_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT(u64 a)
 {
 	return 0x20078 + 0x40000 * a;
 }
@@ -5253,18 +5339,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
  * CGX SMU RX WOL Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_smux_rx_wol_int_ena_w1c {
+union cgxx_smux_rx_wol_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_int_ena_w1c_s {
+	struct cgxx_smux_rx_wol_int_ena_w1c_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_int_ena_w1c_s cn; */
+	/* struct cgxx_smux_rx_wol_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
 {
 	return 0x20088 + 0x40000 * a;
 }
@@ -5275,18 +5361,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
  * CGX SMU RX WOL Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_cgxx_smux_rx_wol_int_ena_w1s {
+union cgxx_smux_rx_wol_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_int_ena_w1s_s {
+	struct cgxx_smux_rx_wol_int_ena_w1s_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_int_ena_w1s_s cn; */
+	/* struct cgxx_smux_rx_wol_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
 {
 	return 0x20090 + 0x40000 * a;
 }
@@ -5297,18 +5383,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
  * CGX SMU RX WOL Interrupt Set Registers This register sets interrupt
  * bits.
  */
-union cavm_cgxx_smux_rx_wol_int_w1s {
+union cgxx_smux_rx_wol_int_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_rx_wol_int_w1s_s {
+	struct cgxx_smux_rx_wol_int_w1s_s {
 		u64 wol_rcvd                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_smux_rx_wol_int_w1s_s cn; */
+	/* struct cgxx_smux_rx_wol_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
 {
 	return 0x20080 + 0x40000 * a;
 }
@@ -5318,18 +5404,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
  *
  * CGX SMU SMAC Registers
  */
-union cavm_cgxx_smux_smac {
+union cgxx_smux_smac {
 	u64 u;
-	struct cavm_cgxx_smux_smac_s {
+	struct cgxx_smux_smac_s {
 		u64 smac                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_smux_smac_s cn; */
+	/* struct cgxx_smux_smac_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
+static inline u64 CGXX_SMUX_SMAC(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
+static inline u64 CGXX_SMUX_SMAC(u64 a)
 {
 	return 0x20108 + 0x40000 * a;
 }
@@ -5341,21 +5427,21 @@ static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
  * interactions between FCS and PAD, see also the description of
  * CGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
  */
-union cavm_cgxx_smux_tx_append {
+union cgxx_smux_tx_append {
 	u64 u;
-	struct cavm_cgxx_smux_tx_append_s {
+	struct cgxx_smux_tx_append_s {
 		u64 preamble                         : 1;
 		u64 pad                              : 1;
 		u64 fcs_d                            : 1;
 		u64 fcs_c                            : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_smux_tx_append_s cn; */
+	/* struct cgxx_smux_tx_append_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_APPEND(u64 a)
+static inline u64 CGXX_SMUX_TX_APPEND(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_APPEND(u64 a)
+static inline u64 CGXX_SMUX_TX_APPEND(u64 a)
 {
 	return 0x20100 + 0x40000 * a;
 }
@@ -5365,9 +5451,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_APPEND(u64 a)
  *
  * CGX SMU Transmit Control Registers
  */
-union cavm_cgxx_smux_tx_ctl {
+union cgxx_smux_tx_ctl {
 	u64 u;
-	struct cavm_cgxx_smux_tx_ctl_s {
+	struct cgxx_smux_tx_ctl_s {
 		u64 dic_en                           : 1;
 		u64 uni_en                           : 1;
 		u64 x4a_dis                          : 1;
@@ -5379,12 +5465,12 @@ union cavm_cgxx_smux_tx_ctl {
 		u64 hg_pause_hgi                     : 2;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_cgxx_smux_tx_ctl_s cn; */
+	/* struct cgxx_smux_tx_ctl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_CTL(u64 a)
+static inline u64 CGXX_SMUX_TX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_CTL(u64 a)
+static inline u64 CGXX_SMUX_TX_CTL(u64 a)
 {
 	return 0x20178 + 0x40000 * a;
 }
@@ -5394,18 +5480,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_CTL(u64 a)
  *
  * CGX SMU TX Drop Counters Registers
  */
-union cavm_cgxx_smux_tx_dack {
+union cgxx_smux_tx_dack {
 	u64 u;
-	struct cavm_cgxx_smux_tx_dack_s {
+	struct cgxx_smux_tx_dack_s {
 		u64 dpi_sdrop_ack                    : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_tx_dack_s cn; */
+	/* struct cgxx_smux_tx_dack_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_DACK(u64 a)
+static inline u64 CGXX_SMUX_TX_DACK(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_DACK(u64 a)
+static inline u64 CGXX_SMUX_TX_DACK(u64 a)
 {
 	return 0x201b0 + 0x40000 * a;
 }
@@ -5415,18 +5501,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_DACK(u64 a)
  *
  * CGX SMU TX Drop Counters Registers
  */
-union cavm_cgxx_smux_tx_dcnt {
+union cgxx_smux_tx_dcnt {
 	u64 u;
-	struct cavm_cgxx_smux_tx_dcnt_s {
+	struct cgxx_smux_tx_dcnt_s {
 		u64 dpi_sdrop_cnt                    : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_tx_dcnt_s cn; */
+	/* struct cgxx_smux_tx_dcnt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
+static inline u64 CGXX_SMUX_TX_DCNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
+static inline u64 CGXX_SMUX_TX_DCNT(u64 a)
 {
 	return 0x201a8 + 0x40000 * a;
 }
@@ -5439,9 +5525,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
  * Those registers take effect only when EEE is supported and enabled for
  * a given LMAC.
  */
-union cavm_cgxx_smux_tx_eee {
+union cgxx_smux_tx_eee {
 	u64 u;
-	struct cavm_cgxx_smux_tx_eee_s {
+	struct cgxx_smux_tx_eee_s {
 		u64 idle_thresh                      : 28;
 		u64 reserved_28                      : 1;
 		u64 force_lpi                        : 1;
@@ -5452,12 +5538,12 @@ union cavm_cgxx_smux_tx_eee {
 		u64 tx_lpi_wake                      : 1;
 		u64 tx_lpi                           : 1;
 	} s;
-	/* struct cavm_cgxx_smux_tx_eee_s cn; */
+	/* struct cgxx_smux_tx_eee_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE(u64 a)
 {
 	return 0x20190 + 0x40000 * a;
 }
@@ -5468,9 +5554,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
  * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers  Reserved. Internal:
  * These registers configure SMU TX EEE timing parameters.
  */
-union cavm_cgxx_smux_tx_eee_timer_status {
+union cgxx_smux_tx_eee_timer_status {
 	u64 u;
-	struct cavm_cgxx_smux_tx_eee_timer_status_s {
+	struct cgxx_smux_tx_eee_timer_status_s {
 		u64 lpi_wake_cnt                     : 16;
 		u64 reserved_16_30                   : 15;
 		u64 wake_timer_done                  : 1;
@@ -5478,12 +5564,12 @@ union cavm_cgxx_smux_tx_eee_timer_status {
 		u64 reserved_62                      : 1;
 		u64 link_timer_done                  : 1;
 	} s;
-	/* struct cavm_cgxx_smux_tx_eee_timer_status_s cn; */
+	/* struct cgxx_smux_tx_eee_timer_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
 {
 	return 0x201a0 + 0x40000 * a;
 }
@@ -5494,20 +5580,20 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
  * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers  Reserved.
  * Internal: These registers configure SMU TX EEE timing parameters.
  */
-union cavm_cgxx_smux_tx_eee_timing {
+union cgxx_smux_tx_eee_timing {
 	u64 u;
-	struct cavm_cgxx_smux_tx_eee_timing_s {
+	struct cgxx_smux_tx_eee_timing_s {
 		u64 w_sys_tx_min                     : 16;
 		u64 reserved_16_31                   : 16;
 		u64 link_ok_min                      : 30;
 		u64 reserved_62_63                   : 2;
 	} s;
-	/* struct cavm_cgxx_smux_tx_eee_timing_s cn; */
+	/* struct cgxx_smux_tx_eee_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
+static inline u64 CGXX_SMUX_TX_EEE_TIMING(u64 a)
 {
 	return 0x20198 + 0x40000 * a;
 }
@@ -5530,9 +5616,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
  * 8 as 8 for other MACs. When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU
  * TX can work correctly with any IFG1 and IFG2.
  */
-union cavm_cgxx_smux_tx_ifg {
+union cgxx_smux_tx_ifg {
 	u64 u;
-	struct cavm_cgxx_smux_tx_ifg_s {
+	struct cgxx_smux_tx_ifg_s {
 		u64 ifg1                             : 4;
 		u64 ifg2                             : 4;
 		u64 mia_amt                          : 2;
@@ -5540,12 +5626,12 @@ union cavm_cgxx_smux_tx_ifg {
 		u64 mia_cnt                          : 8;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_cgxx_smux_tx_ifg_s cn; */
+	/* struct cgxx_smux_tx_ifg_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_IFG(u64 a)
+static inline u64 CGXX_SMUX_TX_IFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_IFG(u64 a)
+static inline u64 CGXX_SMUX_TX_IFG(u64 a)
 {
 	return 0x20160 + 0x40000 * a;
 }
@@ -5555,9 +5641,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_IFG(u64 a)
  *
  * CGX SMU TX Interrupt Registers
  */
-union cavm_cgxx_smux_tx_int {
+union cgxx_smux_tx_int {
 	u64 u;
-	struct cavm_cgxx_smux_tx_int_s {
+	struct cgxx_smux_tx_int_s {
 		u64 undflw                           : 1;
 		u64 xchange                          : 1;
 		u64 fake_commit                      : 1;
@@ -5566,12 +5652,12 @@ union cavm_cgxx_smux_tx_int {
 		u64 dpi_sdrop                        : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_smux_tx_int_s cn; */
+	/* struct cgxx_smux_tx_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
+static inline u64 CGXX_SMUX_TX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
+static inline u64 CGXX_SMUX_TX_INT(u64 a)
 {
 	return 0x20140 + 0x40000 * a;
 }
@@ -5582,9 +5668,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
  * CGX SMU TX Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_smux_tx_int_ena_w1c {
+union cgxx_smux_tx_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_smux_tx_int_ena_w1c_s {
+	struct cgxx_smux_tx_int_ena_w1c_s {
 		u64 undflw                           : 1;
 		u64 xchange                          : 1;
 		u64 fake_commit                      : 1;
@@ -5593,12 +5679,12 @@ union cavm_cgxx_smux_tx_int_ena_w1c {
 		u64 dpi_sdrop                        : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_smux_tx_int_ena_w1c_s cn; */
+	/* struct cgxx_smux_tx_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
 {
 	return 0x20150 + 0x40000 * a;
 }
@@ -5609,9 +5695,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
  * CGX SMU TX Interrupt Enable Set Registers This register sets interrupt
  * enable bits.
  */
-union cavm_cgxx_smux_tx_int_ena_w1s {
+union cgxx_smux_tx_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_tx_int_ena_w1s_s {
+	struct cgxx_smux_tx_int_ena_w1s_s {
 		u64 undflw                           : 1;
 		u64 xchange                          : 1;
 		u64 fake_commit                      : 1;
@@ -5620,12 +5706,12 @@ union cavm_cgxx_smux_tx_int_ena_w1s {
 		u64 dpi_sdrop                        : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_smux_tx_int_ena_w1s_s cn; */
+	/* struct cgxx_smux_tx_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
 {
 	return 0x20158 + 0x40000 * a;
 }
@@ -5635,9 +5721,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
  *
  * CGX SMU TX Interrupt Set Registers This register sets interrupt bits.
  */
-union cavm_cgxx_smux_tx_int_w1s {
+union cgxx_smux_tx_int_w1s {
 	u64 u;
-	struct cavm_cgxx_smux_tx_int_w1s_s {
+	struct cgxx_smux_tx_int_w1s_s {
 		u64 undflw                           : 1;
 		u64 xchange                          : 1;
 		u64 fake_commit                      : 1;
@@ -5646,12 +5732,12 @@ union cavm_cgxx_smux_tx_int_w1s {
 		u64 dpi_sdrop                        : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_smux_tx_int_w1s_s cn; */
+	/* struct cgxx_smux_tx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
+static inline u64 CGXX_SMUX_TX_INT_W1S(u64 a)
 {
 	return 0x20148 + 0x40000 * a;
 }
@@ -5662,18 +5748,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
  * CGX SMU TX Minimum-Size-Packet Registers Internal: [MIN_SIZE] less
  * than 16 will be ignored by hardware which will use 16 instead.
  */
-union cavm_cgxx_smux_tx_min_pkt {
+union cgxx_smux_tx_min_pkt {
 	u64 u;
-	struct cavm_cgxx_smux_tx_min_pkt_s {
+	struct cgxx_smux_tx_min_pkt_s {
 		u64 min_size                         : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_cgxx_smux_tx_min_pkt_s cn; */
+	/* struct cgxx_smux_tx_min_pkt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
+static inline u64 CGXX_SMUX_TX_MIN_PKT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
+static inline u64 CGXX_SMUX_TX_MIN_PKT(u64 a)
 {
 	return 0x20118 + 0x40000 * a;
 }
@@ -5684,18 +5770,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
  * CGX SMU TX PAUSE-Packet DMAC-Field Registers This register provides
  * the DMAC value that is placed in outbound PAUSE packets.
  */
-union cavm_cgxx_smux_tx_pause_pkt_dmac {
+union cgxx_smux_tx_pause_pkt_dmac {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_pkt_dmac_s {
+	struct cgxx_smux_tx_pause_pkt_dmac_s {
 		u64 dmac                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_pkt_dmac_s cn; */
+	/* struct cgxx_smux_tx_pause_pkt_dmac_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
 {
 	return 0x20168 + 0x40000 * a;
 }
@@ -5706,20 +5792,20 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
  * CGX SMU TX PAUSE-Packet Transmission-Interval Registers This register
  * specifies how often PAUSE packets are sent.
  */
-union cavm_cgxx_smux_tx_pause_pkt_interval {
+union cgxx_smux_tx_pause_pkt_interval {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_pkt_interval_s {
+	struct cgxx_smux_tx_pause_pkt_interval_s {
 		u64 interval                         : 16;
 		u64 hg2_intra_interval               : 16;
 		u64 hg2_intra_en                     : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_pkt_interval_s cn; */
+	/* struct cgxx_smux_tx_pause_pkt_interval_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
 {
 	return 0x20120 + 0x40000 * a;
 }
@@ -5729,18 +5815,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
  *
  * CGX SMU TX PAUSE Packet Time Registers
  */
-union cavm_cgxx_smux_tx_pause_pkt_time {
+union cgxx_smux_tx_pause_pkt_time {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_pkt_time_s {
+	struct cgxx_smux_tx_pause_pkt_time_s {
 		u64 p_time                           : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_pkt_time_s cn; */
+	/* struct cgxx_smux_tx_pause_pkt_time_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
 {
 	return 0x20110 + 0x40000 * a;
 }
@@ -5751,18 +5837,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
  * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers This register provides
  * the P_TYPE field that is placed in outbound PAUSE packets.
  */
-union cavm_cgxx_smux_tx_pause_pkt_type {
+union cgxx_smux_tx_pause_pkt_type {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_pkt_type_s {
+	struct cgxx_smux_tx_pause_pkt_type_s {
 		u64 p_type                           : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_pkt_type_s cn; */
+	/* struct cgxx_smux_tx_pause_pkt_type_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
 {
 	return 0x20170 + 0x40000 * a;
 }
@@ -5772,19 +5858,19 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
  *
  * CGX SMU TX Time-to-Backpressure Registers
  */
-union cavm_cgxx_smux_tx_pause_togo {
+union cgxx_smux_tx_pause_togo {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_togo_s {
+	struct cgxx_smux_tx_pause_togo_s {
 		u64 p_time                           : 16;
 		u64 msg_time                         : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_togo_s cn; */
+	/* struct cgxx_smux_tx_pause_togo_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
 {
 	return 0x20130 + 0x40000 * a;
 }
@@ -5794,18 +5880,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
  *
  * CGX SMU TX PAUSE Zero Registers
  */
-union cavm_cgxx_smux_tx_pause_zero {
+union cgxx_smux_tx_pause_zero {
 	u64 u;
-	struct cavm_cgxx_smux_tx_pause_zero_s {
+	struct cgxx_smux_tx_pause_zero_s {
 		u64 send                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_smux_tx_pause_zero_s cn; */
+	/* struct cgxx_smux_tx_pause_zero_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+static inline u64 CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
 {
 	return 0x20138 + 0x40000 * a;
 }
@@ -5815,18 +5901,18 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
  *
  * CGX SMU TX Soft PAUSE Registers
  */
-union cavm_cgxx_smux_tx_soft_pause {
+union cgxx_smux_tx_soft_pause {
 	u64 u;
-	struct cavm_cgxx_smux_tx_soft_pause_s {
+	struct cgxx_smux_tx_soft_pause_s {
 		u64 p_time                           : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_smux_tx_soft_pause_s cn; */
+	/* struct cgxx_smux_tx_soft_pause_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+static inline u64 CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+static inline u64 CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
 {
 	return 0x20128 + 0x40000 * a;
 }
@@ -5836,9 +5922,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
  *
  * CGX SMU TX Threshold Registers
  */
-union cavm_cgxx_smux_tx_thresh {
+union cgxx_smux_tx_thresh {
 	u64 u;
-	struct cavm_cgxx_smux_tx_thresh_s {
+	struct cgxx_smux_tx_thresh_s {
 		u64 cnt                              : 12;
 		u64 reserved_12_15                   : 4;
 		u64 dpi_thresh                       : 5;
@@ -5848,12 +5934,12 @@ union cavm_cgxx_smux_tx_thresh {
 		u64 ecnt                             : 12;
 		u64 reserved_44_63                   : 20;
 	} s;
-	/* struct cavm_cgxx_smux_tx_thresh_s cn; */
+	/* struct cgxx_smux_tx_thresh_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
+static inline u64 CGXX_SMUX_TX_THRESH(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
+static inline u64 CGXX_SMUX_TX_THRESH(u64 a)
 {
 	return 0x20180 + 0x40000 * a;
 }
@@ -5873,9 +5959,9 @@ static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
  * CGX()_SPU()_AN_LP_BASE to determine the highest common denominator
  * technology.
  */
-union cavm_cgxx_spux_an_adv {
+union cgxx_spux_an_adv {
 	u64 u;
-	struct cavm_cgxx_spux_an_adv_s {
+	struct cgxx_spux_an_adv_s {
 		u64 s                                : 5;
 		u64 e                                : 5;
 		u64 pause                            : 1;
@@ -5903,12 +5989,12 @@ union cavm_cgxx_spux_an_adv {
 		u64 fec_req                          : 1;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_spux_an_adv_s cn; */
+	/* struct cgxx_spux_an_adv_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
+static inline u64 CGXX_SPUX_AN_ADV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
+static inline u64 CGXX_SPUX_AN_ADV(u64 a)
 {
 	return 0x10198 + 0x40000 * a;
 }
@@ -5925,9 +6011,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
  * [RS_FEC] will be set to indicate whether/which FEC operation has been
  * negotiated and will be clear otherwise.
  */
-union cavm_cgxx_spux_an_bp_status {
+union cgxx_spux_an_bp_status {
 	u64 u;
-	struct cavm_cgxx_spux_an_bp_status_s {
+	struct cgxx_spux_an_bp_status_s {
 		u64 bp_an_able                       : 1;
 		u64 n1g_kx                           : 1;
 		u64 n10g_kx4                         : 1;
@@ -5948,12 +6034,12 @@ union cavm_cgxx_spux_an_bp_status {
 		u64 rs_fec                           : 1;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_cgxx_spux_an_bp_status_s cn; */
+	/* struct cgxx_spux_an_bp_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_BP_STATUS(u64 a)
+static inline u64 CGXX_SPUX_AN_BP_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_BP_STATUS(u64 a)
+static inline u64 CGXX_SPUX_AN_BP_STATUS(u64 a)
 {
 	return 0x101b8 + 0x40000 * a;
 }
@@ -5963,9 +6049,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_BP_STATUS(u64 a)
  *
  * CGX SPU Autonegotiation Control Registers
  */
-union cavm_cgxx_spux_an_control {
+union cgxx_spux_an_control {
 	u64 u;
-	struct cavm_cgxx_spux_an_control_s {
+	struct cgxx_spux_an_control_s {
 		u64 reserved_0_8                     : 9;
 		u64 an_restart                       : 1;
 		u64 reserved_10_11                   : 2;
@@ -5977,12 +6063,12 @@ union cavm_cgxx_spux_an_control {
 		u64 usx_an_arb_link_chk_en           : 1;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_cgxx_spux_an_control_s cn; */
+	/* struct cgxx_spux_an_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_AN_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_AN_CONTROL(u64 a)
 {
 	return 0x10188 + 0x40000 * a;
 }
@@ -5996,9 +6082,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
  * 802.3 section 73.6 for details.) CGX()_SPU()_AN_STATUS[PAGE_RX] is set
  * when this register is updated by hardware.
  */
-union cavm_cgxx_spux_an_lp_base {
+union cgxx_spux_an_lp_base {
 	u64 u;
-	struct cavm_cgxx_spux_an_lp_base_s {
+	struct cgxx_spux_an_lp_base_s {
 		u64 s                                : 5;
 		u64 e                                : 5;
 		u64 pause                            : 1;
@@ -6026,12 +6112,12 @@ union cavm_cgxx_spux_an_lp_base {
 		u64 fec_req                          : 1;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_spux_an_lp_base_s cn; */
+	/* struct cgxx_spux_an_lp_base_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
+static inline u64 CGXX_SPUX_AN_LP_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
+static inline u64 CGXX_SPUX_AN_LP_BASE(u64 a)
 {
 	return 0x101a0 + 0x40000 * a;
 }
@@ -6044,9 +6130,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
  * code word received from the link partner during autonegotiation, if
  * any. See IEEE 802.3 section 73.7.7 for details.
  */
-union cavm_cgxx_spux_an_lp_xnp {
+union cgxx_spux_an_lp_xnp {
 	u64 u;
-	struct cavm_cgxx_spux_an_lp_xnp_s {
+	struct cgxx_spux_an_lp_xnp_s {
 		u64 m_u                              : 11;
 		u64 toggle                           : 1;
 		u64 ack2                             : 1;
@@ -6056,12 +6142,12 @@ union cavm_cgxx_spux_an_lp_xnp {
 		u64 u                                : 32;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_spux_an_lp_xnp_s cn; */
+	/* struct cgxx_spux_an_lp_xnp_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_LP_XNP(u64 a)
+static inline u64 CGXX_SPUX_AN_LP_XNP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_LP_XNP(u64 a)
+static inline u64 CGXX_SPUX_AN_LP_XNP(u64 a)
 {
 	return 0x101b0 + 0x40000 * a;
 }
@@ -6071,9 +6157,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_LP_XNP(u64 a)
  *
  * CGX SPU Autonegotiation Status Registers
  */
-union cavm_cgxx_spux_an_status {
+union cgxx_spux_an_status {
 	u64 u;
-	struct cavm_cgxx_spux_an_status_s {
+	struct cgxx_spux_an_status_s {
 		u64 lp_an_able                       : 1;
 		u64 reserved_1                       : 1;
 		u64 link_status                      : 1;
@@ -6086,12 +6172,12 @@ union cavm_cgxx_spux_an_status {
 		u64 prl_flt                          : 1;
 		u64 reserved_10_63                   : 54;
 	} s;
-	/* struct cavm_cgxx_spux_an_status_s cn; */
+	/* struct cgxx_spux_an_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_AN_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_AN_STATUS(u64 a)
 {
 	return 0x10190 + 0x40000 * a;
 }
@@ -6109,9 +6195,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
  * link segment set their NP bits to 0. See IEEE 802.3 section 73.7.7 for
  * details.
  */
-union cavm_cgxx_spux_an_xnp_tx {
+union cgxx_spux_an_xnp_tx {
 	u64 u;
-	struct cavm_cgxx_spux_an_xnp_tx_s {
+	struct cgxx_spux_an_xnp_tx_s {
 		u64 m_u                              : 11;
 		u64 toggle                           : 1;
 		u64 ack2                             : 1;
@@ -6121,12 +6207,12 @@ union cavm_cgxx_spux_an_xnp_tx {
 		u64 u                                : 32;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_cgxx_spux_an_xnp_tx_s cn; */
+	/* struct cgxx_spux_an_xnp_tx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
+static inline u64 CGXX_SPUX_AN_XNP_TX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
+static inline u64 CGXX_SPUX_AN_XNP_TX(u64 a)
 {
 	return 0x101a8 + 0x40000 * a;
 }
@@ -6147,9 +6233,9 @@ static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
  * service interfaces are identical. Logical interfaces (lanes) map to
  * SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
  */
-union cavm_cgxx_spux_br_algn_status {
+union cgxx_spux_br_algn_status {
 	u64 u;
-	struct cavm_cgxx_spux_br_algn_status_s {
+	struct cgxx_spux_br_algn_status_s {
 		u64 block_lock                       : 20;
 		u64 reserved_20_29                   : 10;
 		u64 alignd                           : 1;
@@ -6157,12 +6243,12 @@ union cavm_cgxx_spux_br_algn_status {
 		u64 marker_lock                      : 20;
 		u64 reserved_61_63                   : 3;
 	} s;
-	/* struct cavm_cgxx_spux_br_algn_status_s cn; */
+	/* struct cgxx_spux_br_algn_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BR_ALGN_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BR_ALGN_STATUS(u64 a)
 {
 	return 0x10050 + 0x40000 * a;
 }
@@ -6183,7 +6269,7 @@ static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
  * received on that service interface.  In RS-FEC mode the LNx_MAPPING
  * field is valid when that lane has achieved alignment marker lock on
  * the receive side (i.e. the associated
- * CGX(0..2)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid
+ * CGX(0..3)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid
  * otherwise. When valid, it returns the actual detected receive FEC lane
  * number based on the received alignment marker contents received on
  * that logical lane therefore expect for RS-FEC that LNx_MAPPING = x.
@@ -6195,18 +6281,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
  * SerDes lane mapping, and this register specifies the service interface
  * (or lane) to PCS lane mapping.
  */
-union cavm_cgxx_spux_br_lane_mapx {
+union cgxx_spux_br_lane_mapx {
 	u64 u;
-	struct cavm_cgxx_spux_br_lane_mapx_s {
+	struct cgxx_spux_br_lane_mapx_s {
 		u64 ln_mapping                       : 6;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_spux_br_lane_mapx_s cn; */
+	/* struct cgxx_spux_br_lane_mapx_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+static inline u64 CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+static inline u64 CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
 {
 	return 0x10600 + 0x40000 * a + 8 * b;
 }
@@ -6216,27 +6302,30 @@ static inline u64 CAVM_CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
  *
  * CGX SPU BASE-R PMD Control Registers
  */
-union cavm_cgxx_spux_br_pmd_control {
+union cgxx_spux_br_pmd_control {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_control_s {
+	struct cgxx_spux_br_pmd_control_s {
 		u64 train_restart                    : 1;
 		u64 train_en                         : 1;
 		u64 use_lane_poly                    : 1;
 		u64 max_wait_disable                 : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	struct cavm_cgxx_spux_br_pmd_control_cn96xx {
+	struct cgxx_spux_br_pmd_control_cn96xx {
 		u64 train_restart                    : 1;
 		u64 train_en                         : 1;
 		u64 use_lane_poly                    : 1;
 		u64 reserved_3_63                    : 61;
 	} cn96xx;
-	/* struct cavm_cgxx_spux_br_pmd_control_s cnf95xx; */
+	/* struct cgxx_spux_br_pmd_control_cn96xx cn98xx; */
+	/* struct cgxx_spux_br_pmd_control_s cnf95xxp1; */
+	/* struct cgxx_spux_br_pmd_control_cn96xx cnf95xxp2; */
+	/* struct cgxx_spux_br_pmd_control_cn96xx loki; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_CONTROL(u64 a)
 {
 	return 0x100a8 + 0x40000 * a;
 }
@@ -6262,20 +6351,20 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
  * be written by software. The lane fields in this register are indexed
  * by logical PCS lane ID.
  */
-union cavm_cgxx_spux_br_pmd_ld_cup {
+union cgxx_spux_br_pmd_ld_cup {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_ld_cup_s {
+	struct cgxx_spux_br_pmd_ld_cup_s {
 		u64 ln0_cup                          : 16;
 		u64 ln1_cup                          : 16;
 		u64 ln2_cup                          : 16;
 		u64 ln3_cup                          : 16;
 	} s;
-	/* struct cavm_cgxx_spux_br_pmd_ld_cup_s cn; */
+	/* struct cgxx_spux_br_pmd_ld_cup_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
 {
 	return 0x100c8 + 0x40000 * a;
 }
@@ -6300,20 +6389,20 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
  * be written by software. The lane fields in this register are indexed
  * by logical PCS lane ID.
  */
-union cavm_cgxx_spux_br_pmd_ld_rep {
+union cgxx_spux_br_pmd_ld_rep {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_ld_rep_s {
+	struct cgxx_spux_br_pmd_ld_rep_s {
 		u64 ln0_rep                          : 16;
 		u64 ln1_rep                          : 16;
 		u64 ln2_rep                          : 16;
 		u64 ln3_rep                          : 16;
 	} s;
-	/* struct cavm_cgxx_spux_br_pmd_ld_rep_s cn; */
+	/* struct cgxx_spux_br_pmd_ld_rep_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LD_REP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LD_REP(u64 a)
 {
 	return 0x100d0 + 0x40000 * a;
 }
@@ -6334,20 +6423,20 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
  * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
  * register are indexed by logical PCS lane ID.
  */
-union cavm_cgxx_spux_br_pmd_lp_cup {
+union cgxx_spux_br_pmd_lp_cup {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_lp_cup_s {
+	struct cgxx_spux_br_pmd_lp_cup_s {
 		u64 ln0_cup                          : 16;
 		u64 ln1_cup                          : 16;
 		u64 ln2_cup                          : 16;
 		u64 ln3_cup                          : 16;
 	} s;
-	/* struct cavm_cgxx_spux_br_pmd_lp_cup_s cn; */
+	/* struct cgxx_spux_br_pmd_lp_cup_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
 {
 	return 0x100b8 + 0x40000 * a;
 }
@@ -6368,20 +6457,20 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
  * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
  * register are indexed by logical PCS lane ID.
  */
-union cavm_cgxx_spux_br_pmd_lp_rep {
+union cgxx_spux_br_pmd_lp_rep {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_lp_rep_s {
+	struct cgxx_spux_br_pmd_lp_rep_s {
 		u64 ln0_rep                          : 16;
 		u64 ln1_rep                          : 16;
 		u64 ln2_rep                          : 16;
 		u64 ln3_rep                          : 16;
 	} s;
-	/* struct cavm_cgxx_spux_br_pmd_lp_rep_s cn; */
+	/* struct cgxx_spux_br_pmd_lp_rep_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LP_REP(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_LP_REP(u64 a)
 {
 	return 0x100c0 + 0x40000 * a;
 }
@@ -6396,21 +6485,21 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
  * The remaining fields (LN2_*, LN3_*) are only valid for 40GBASE-R and
  * 100GBASE-R.
  */
-union cavm_cgxx_spux_br_pmd_status {
+union cgxx_spux_br_pmd_status {
 	u64 u;
-	struct cavm_cgxx_spux_br_pmd_status_s {
+	struct cgxx_spux_br_pmd_status_s {
 		u64 ln0_train_status                 : 4;
 		u64 ln1_train_status                 : 4;
 		u64 ln2_train_status                 : 4;
 		u64 ln3_train_status                 : 4;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_br_pmd_status_s cn; */
+	/* struct cgxx_spux_br_pmd_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_PMD_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BR_PMD_STATUS(u64 a)
 {
 	return 0x100b0 + 0x40000 * a;
 }
@@ -6420,9 +6509,9 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_STATUS(u64 a)
  *
  * CGX SPU BASE-R Status 1 Registers
  */
-union cavm_cgxx_spux_br_status1 {
+union cgxx_spux_br_status1 {
 	u64 u;
-	struct cavm_cgxx_spux_br_status1_s {
+	struct cgxx_spux_br_status1_s {
 		u64 blk_lock                         : 1;
 		u64 hi_ber                           : 1;
 		u64 prbs31                           : 1;
@@ -6431,12 +6520,12 @@ union cavm_cgxx_spux_br_status1 {
 		u64 rcv_lnk                          : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_cgxx_spux_br_status1_s cn; */
+	/* struct cgxx_spux_br_status1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
+static inline u64 CGXX_SPUX_BR_STATUS1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
+static inline u64 CGXX_SPUX_BR_STATUS1(u64 a)
 {
 	return 0x10030 + 0x40000 * a;
 }
@@ -6456,9 +6545,9 @@ static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
  * from section 3.45 have been combined into the contiguous, 22-bit
  * [ERR_BLKS] field.
  */
-union cavm_cgxx_spux_br_status2 {
+union cgxx_spux_br_status2 {
 	u64 u;
-	struct cavm_cgxx_spux_br_status2_s {
+	struct cgxx_spux_br_status2_s {
 		u64 reserved_0_13                    : 14;
 		u64 latched_ber                      : 1;
 		u64 latched_lock                     : 1;
@@ -6467,12 +6556,12 @@ union cavm_cgxx_spux_br_status2 {
 		u64 err_blks                         : 22;
 		u64 reserved_62_63                   : 2;
 	} s;
-	/* struct cavm_cgxx_spux_br_status2_s cn; */
+	/* struct cgxx_spux_br_status2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
+static inline u64 CGXX_SPUX_BR_STATUS2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
+static inline u64 CGXX_SPUX_BR_STATUS2(u64 a)
 {
 	return 0x10038 + 0x40000 * a;
 }
@@ -6483,9 +6572,9 @@ static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
  * CGX SPU BASE-R Test-Pattern Control Registers Refer to the test
  * pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
-union cavm_cgxx_spux_br_tp_control {
+union cgxx_spux_br_tp_control {
 	u64 u;
-	struct cavm_cgxx_spux_br_tp_control_s {
+	struct cgxx_spux_br_tp_control_s {
 		u64 dp_sel                           : 1;
 		u64 tp_sel                           : 1;
 		u64 rx_tp_en                         : 1;
@@ -6497,12 +6586,12 @@ union cavm_cgxx_spux_br_tp_control {
 		u64 pr_tp_data_type                  : 1;
 		u64 reserved_10_63                   : 54;
 	} s;
-	/* struct cavm_cgxx_spux_br_tp_control_s cn; */
+	/* struct cgxx_spux_br_tp_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_CONTROL(u64 a)
 {
 	return 0x10040 + 0x40000 * a;
 }
@@ -6513,18 +6602,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
  * CGX SPU BASE-R Test-Pattern Error-Count Registers This register
  * provides the BASE-R PCS test-pattern error counter.
  */
-union cavm_cgxx_spux_br_tp_err_cnt {
+union cgxx_spux_br_tp_err_cnt {
 	u64 u;
-	struct cavm_cgxx_spux_br_tp_err_cnt_s {
+	struct cgxx_spux_br_tp_err_cnt_s {
 		u64 err_cnt                          : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_br_tp_err_cnt_s cn; */
+	/* struct cgxx_spux_br_tp_err_cnt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
 {
 	return 0x10048 + 0x40000 * a;
 }
@@ -6535,18 +6624,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
  * CGX SPU BASE-R Test-Pattern Seed A Registers Refer to the test pattern
  * methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
-union cavm_cgxx_spux_br_tp_seed_a {
+union cgxx_spux_br_tp_seed_a {
 	u64 u;
-	struct cavm_cgxx_spux_br_tp_seed_a_s {
+	struct cgxx_spux_br_tp_seed_a_s {
 		u64 tp_seed_a                        : 58;
 		u64 reserved_58_63                   : 6;
 	} s;
-	/* struct cavm_cgxx_spux_br_tp_seed_a_s cn; */
+	/* struct cgxx_spux_br_tp_seed_a_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_SEED_A(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_SEED_A(u64 a)
 {
 	return 0x10060 + 0x40000 * a;
 }
@@ -6557,18 +6646,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
  * CGX SPU BASE-R Test-Pattern Seed B Registers Refer to the test pattern
  * methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
-union cavm_cgxx_spux_br_tp_seed_b {
+union cgxx_spux_br_tp_seed_b {
 	u64 u;
-	struct cavm_cgxx_spux_br_tp_seed_b_s {
+	struct cgxx_spux_br_tp_seed_b_s {
 		u64 tp_seed_b                        : 58;
 		u64 reserved_58_63                   : 6;
 	} s;
-	/* struct cavm_cgxx_spux_br_tp_seed_b_s cn; */
+	/* struct cgxx_spux_br_tp_seed_b_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_B(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_SEED_B(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_B(u64 a)
+static inline u64 CGXX_SPUX_BR_TP_SEED_B(u64 a)
 {
 	return 0x10068 + 0x40000 * a;
 }
@@ -6578,21 +6667,21 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_B(u64 a)
  *
  * CGX SPU BASE-X Status Registers
  */
-union cavm_cgxx_spux_bx_status {
+union cgxx_spux_bx_status {
 	u64 u;
-	struct cavm_cgxx_spux_bx_status_s {
+	struct cgxx_spux_bx_status_s {
 		u64 lsync                            : 4;
 		u64 reserved_4_10                    : 7;
 		u64 pattst                           : 1;
 		u64 alignd                           : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_cgxx_spux_bx_status_s cn; */
+	/* struct cgxx_spux_bx_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_BX_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BX_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_BX_STATUS(u64 a)
+static inline u64 CGXX_SPUX_BX_STATUS(u64 a)
 {
 	return 0x10028 + 0x40000 * a;
 }
@@ -6602,9 +6691,9 @@ static inline u64 CAVM_CGXX_SPUX_BX_STATUS(u64 a)
  *
  * CGX SPU Control 1 Registers
  */
-union cavm_cgxx_spux_control1 {
+union cgxx_spux_control1 {
 	u64 u;
-	struct cavm_cgxx_spux_control1_s {
+	struct cgxx_spux_control1_s {
 		u64 reserved_0_1                     : 2;
 		u64 spd                              : 4;
 		u64 spdsel0                          : 1;
@@ -6616,14 +6705,32 @@ union cavm_cgxx_spux_control1 {
 		u64 reset                            : 1;
 		u64 usxgmii_type                     : 3;
 		u64 usxgmii_rate                     : 3;
-		u64 reserved_22_63                   : 42;
+		u64 disable_am                       : 1;
+		u64 reserved_23_63                   : 41;
 	} s;
-	/* struct cavm_cgxx_spux_control1_s cn; */
+	struct cgxx_spux_control1_cn96xxp1 {
+		u64 reserved_0_1                     : 2;
+		u64 spd                              : 4;
+		u64 spdsel0                          : 1;
+		u64 reserved_7_10                    : 4;
+		u64 lo_pwr                           : 1;
+		u64 reserved_12                      : 1;
+		u64 spdsel1                          : 1;
+		u64 loopbck                          : 1;
+		u64 reset                            : 1;
+		u64 usxgmii_type                     : 3;
+		u64 usxgmii_rate                     : 3;
+		u64 reserved_22_63                   : 42;
+	} cn96xxp1;
+	/* struct cgxx_spux_control1_s cn96xxp3; */
+	/* struct cgxx_spux_control1_cn96xxp1 cn98xx; */
+	/* struct cgxx_spux_control1_cn96xxp1 cnf95xx; */
+	/* struct cgxx_spux_control1_cn96xxp1 loki; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_CONTROL1(u64 a)
+static inline u64 CGXX_SPUX_CONTROL1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_CONTROL1(u64 a)
+static inline u64 CGXX_SPUX_CONTROL1(u64 a)
 {
 	return 0x10000 + 0x40000 * a;
 }
@@ -6633,18 +6740,18 @@ static inline u64 CAVM_CGXX_SPUX_CONTROL1(u64 a)
  *
  * CGX SPU Control 2 Registers
  */
-union cavm_cgxx_spux_control2 {
+union cgxx_spux_control2 {
 	u64 u;
-	struct cavm_cgxx_spux_control2_s {
+	struct cgxx_spux_control2_s {
 		u64 pcs_type                         : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_cgxx_spux_control2_s cn; */
+	/* struct cgxx_spux_control2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_CONTROL2(u64 a)
+static inline u64 CGXX_SPUX_CONTROL2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_CONTROL2(u64 a)
+static inline u64 CGXX_SPUX_CONTROL2(u64 a)
 {
 	return 0x10018 + 0x40000 * a;
 }
@@ -6654,19 +6761,19 @@ static inline u64 CAVM_CGXX_SPUX_CONTROL2(u64 a)
  *
  * CGX SPU Forward Error Correction Ability Registers
  */
-union cavm_cgxx_spux_fec_abil {
+union cgxx_spux_fec_abil {
 	u64 u;
-	struct cavm_cgxx_spux_fec_abil_s {
+	struct cgxx_spux_fec_abil_s {
 		u64 fec_abil                         : 1;
 		u64 err_abil                         : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_cgxx_spux_fec_abil_s cn; */
+	/* struct cgxx_spux_fec_abil_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_FEC_ABIL(u64 a)
+static inline u64 CGXX_SPUX_FEC_ABIL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_FEC_ABIL(u64 a)
+static inline u64 CGXX_SPUX_FEC_ABIL(u64 a)
 {
 	return 0x100d8 + 0x40000 * a;
 }
@@ -6676,21 +6783,21 @@ static inline u64 CAVM_CGXX_SPUX_FEC_ABIL(u64 a)
  *
  * CGX SPU Forward Error Correction Control Registers
  */
-union cavm_cgxx_spux_fec_control {
+union cgxx_spux_fec_control {
 	u64 u;
-	struct cavm_cgxx_spux_fec_control_s {
+	struct cgxx_spux_fec_control_s {
 		u64 fec_en                           : 2;
 		u64 err_en                           : 1;
 		u64 fec_byp_ind_en                   : 1;
 		u64 fec_byp_cor_en                   : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_cgxx_spux_fec_control_s cn; */
+	/* struct cgxx_spux_fec_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_FEC_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_FEC_CONTROL(u64 a)
 {
 	return 0x100e0 + 0x40000 * a;
 }
@@ -6710,18 +6817,18 @@ static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
  * increment operation is lost. The counters are writable for test
  * purposes, rather than read-only as specified in IEEE 802.3.
  */
-union cavm_cgxx_spux_fec_lnx_rsfec_err {
+union cgxx_spux_fec_lnx_rsfec_err {
 	u64 u;
-	struct cavm_cgxx_spux_fec_lnx_rsfec_err_s {
+	struct cgxx_spux_fec_lnx_rsfec_err_s {
 		u64 symb_err_cnt                     : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spux_fec_lnx_rsfec_err_s cn; */
+	/* struct cgxx_spux_fec_lnx_rsfec_err_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+static inline u64 CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+static inline u64 CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
 {
 	return 0x10900 + 0x40000 * a + 8 * b;
 }
@@ -6731,9 +6838,9 @@ static inline u64 CAVM_CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
  *
  * CGX SPU Interrupt Registers
  */
-union cavm_cgxx_spux_int {
+union cgxx_spux_int {
 	u64 u;
-	struct cavm_cgxx_spux_int_s {
+	struct cgxx_spux_int_s {
 		u64 rx_link_up                       : 1;
 		u64 rx_link_down                     : 1;
 		u64 err_blk                          : 1;
@@ -6757,12 +6864,12 @@ union cavm_cgxx_spux_int {
 		u64 usx_an_cpt                       : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_cgxx_spux_int_s cn; */
+	/* struct cgxx_spux_int_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
+static inline u64 CGXX_SPUX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
+static inline u64 CGXX_SPUX_INT(u64 a)
 {
 	return 0x10220 + 0x40000 * a;
 }
@@ -6773,9 +6880,9 @@ static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
  * CGX SPU Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_cgxx_spux_int_ena_w1c {
+union cgxx_spux_int_ena_w1c {
 	u64 u;
-	struct cavm_cgxx_spux_int_ena_w1c_s {
+	struct cgxx_spux_int_ena_w1c_s {
 		u64 rx_link_up                       : 1;
 		u64 rx_link_down                     : 1;
 		u64 err_blk                          : 1;
@@ -6799,12 +6906,12 @@ union cavm_cgxx_spux_int_ena_w1c {
 		u64 usx_an_cpt                       : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_cgxx_spux_int_ena_w1c_s cn; */
+	/* struct cgxx_spux_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SPUX_INT_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
+static inline u64 CGXX_SPUX_INT_ENA_W1C(u64 a)
 {
 	return 0x10230 + 0x40000 * a;
 }
@@ -6815,9 +6922,9 @@ static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
  * CGX SPU Interrupt Enable Set Registers This register sets interrupt
  * enable bits.
  */
-union cavm_cgxx_spux_int_ena_w1s {
+union cgxx_spux_int_ena_w1s {
 	u64 u;
-	struct cavm_cgxx_spux_int_ena_w1s_s {
+	struct cgxx_spux_int_ena_w1s_s {
 		u64 rx_link_up                       : 1;
 		u64 rx_link_down                     : 1;
 		u64 err_blk                          : 1;
@@ -6841,12 +6948,12 @@ union cavm_cgxx_spux_int_ena_w1s {
 		u64 usx_an_cpt                       : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_cgxx_spux_int_ena_w1s_s cn; */
+	/* struct cgxx_spux_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SPUX_INT_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
+static inline u64 CGXX_SPUX_INT_ENA_W1S(u64 a)
 {
 	return 0x10238 + 0x40000 * a;
 }
@@ -6856,9 +6963,9 @@ static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
  *
  * CGX SPU Interrupt Set Registers This register sets interrupt bits.
  */
-union cavm_cgxx_spux_int_w1s {
+union cgxx_spux_int_w1s {
 	u64 u;
-	struct cavm_cgxx_spux_int_w1s_s {
+	struct cgxx_spux_int_w1s_s {
 		u64 rx_link_up                       : 1;
 		u64 rx_link_down                     : 1;
 		u64 err_blk                          : 1;
@@ -6882,12 +6989,12 @@ union cavm_cgxx_spux_int_w1s {
 		u64 usx_an_cpt                       : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_cgxx_spux_int_w1s_s cn; */
+	/* struct cgxx_spux_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
+static inline u64 CGXX_SPUX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
+static inline u64 CGXX_SPUX_INT_W1S(u64 a)
 {
 	return 0x10228 + 0x40000 * a;
 }
@@ -6910,18 +7017,18 @@ static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
  * increment operation is lost. The counters are writable for test
  * purposes, rather than read-only as specified in IEEE 802.3.
  */
-union cavm_cgxx_spux_lnx_br_bip_err_cnt {
+union cgxx_spux_lnx_br_bip_err_cnt {
 	u64 u;
-	struct cavm_cgxx_spux_lnx_br_bip_err_cnt_s {
+	struct cgxx_spux_lnx_br_bip_err_cnt_s {
 		u64 bip_err_cnt                      : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_lnx_br_bip_err_cnt_s cn; */
+	/* struct cgxx_spux_lnx_br_bip_err_cnt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
 {
 	return 0x10500 + 0x40000 * a + 8 * b;
 }
@@ -6944,18 +7051,18 @@ static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
  * zeros and the increment operation is lost. The counters are writable
  * for test purposes, rather than read-only as specified in IEEE 802.3.
  */
-union cavm_cgxx_spux_lnx_fec_corr_blks {
+union cgxx_spux_lnx_fec_corr_blks {
 	u64 u;
-	struct cavm_cgxx_spux_lnx_fec_corr_blks_s {
+	struct cgxx_spux_lnx_fec_corr_blks_s {
 		u64 ln_corr_blks                     : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spux_lnx_fec_corr_blks_s cn; */
+	/* struct cgxx_spux_lnx_fec_corr_blks_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
 {
 	return 0x10700 + 0x40000 * a + 8 * b;
 }
@@ -6978,18 +7085,18 @@ static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
  * zeros and the increment operation is lost. The counters are writable
  * for test purposes, rather than read-only as specified in IEEE 802.3.
  */
-union cavm_cgxx_spux_lnx_fec_uncorr_blks {
+union cgxx_spux_lnx_fec_uncorr_blks {
 	u64 u;
-	struct cavm_cgxx_spux_lnx_fec_uncorr_blks_s {
+	struct cgxx_spux_lnx_fec_uncorr_blks_s {
 		u64 ln_uncorr_blks                   : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spux_lnx_fec_uncorr_blks_s cn; */
+	/* struct cgxx_spux_lnx_fec_uncorr_blks_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+static inline u64 CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
 {
 	return 0x10800 + 0x40000 * a + 8 * b;
 }
@@ -6999,9 +7106,9 @@ static inline u64 CAVM_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
  *
  * CGX SPU BASE-X Transmit/Receive States Registers
  */
-union cavm_cgxx_spux_lpcs_states {
+union cgxx_spux_lpcs_states {
 	u64 u;
-	struct cavm_cgxx_spux_lpcs_states_s {
+	struct cgxx_spux_lpcs_states_s {
 		u64 deskew_sm                        : 3;
 		u64 reserved_3                       : 1;
 		u64 deskew_am_found                  : 20;
@@ -7010,12 +7117,12 @@ union cavm_cgxx_spux_lpcs_states {
 		u64 br_rx_sm                         : 3;
 		u64 reserved_31_63                   : 33;
 	} s;
-	/* struct cavm_cgxx_spux_lpcs_states_s cn; */
+	/* struct cgxx_spux_lpcs_states_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
+static inline u64 CGXX_SPUX_LPCS_STATES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
+static inline u64 CGXX_SPUX_LPCS_STATES(u64 a)
 {
 	return 0x10208 + 0x40000 * a;
 }
@@ -7031,9 +7138,9 @@ static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
  * logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only
  * bits 1:0 of vector are used for RXAUI."
  */
-union cavm_cgxx_spux_misc_control {
+union cgxx_spux_misc_control {
 	u64 u;
-	struct cavm_cgxx_spux_misc_control_s {
+	struct cgxx_spux_misc_control_s {
 		u64 txplrt                           : 1;
 		u64 rxplrt                           : 1;
 		u64 xor_txplrt                       : 4;
@@ -7044,12 +7151,12 @@ union cavm_cgxx_spux_misc_control {
 		u64 rx_edet_signal_ok                : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_cgxx_spux_misc_control_s cn; */
+	/* struct cgxx_spux_misc_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_MISC_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_MISC_CONTROL(u64 a)
 {
 	return 0x10218 + 0x40000 * a;
 }
@@ -7062,18 +7169,18 @@ static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
  * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and
  * 802.3by-2016 section 108.6.7 (for 25G and extended to USXGMII).
  */
-union cavm_cgxx_spux_rsfec_corr {
+union cgxx_spux_rsfec_corr {
 	u64 u;
-	struct cavm_cgxx_spux_rsfec_corr_s {
+	struct cgxx_spux_rsfec_corr_s {
 		u64 cw_cnt                           : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spux_rsfec_corr_s cn; */
+	/* struct cgxx_spux_rsfec_corr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_CORR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_CORR(u64 a)
 {
 	return 0x10088 + 0x40000 * a;
 }
@@ -7086,9 +7193,9 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
  * 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
  * section 108-6 (for 25G and extended to USXGMII).
  */
-union cavm_cgxx_spux_rsfec_status {
+union cgxx_spux_rsfec_status {
 	u64 u;
-	struct cavm_cgxx_spux_rsfec_status_s {
+	struct cgxx_spux_rsfec_status_s {
 		u64 fec_lane_mapping                 : 8;
 		u64 fec_align_status                 : 1;
 		u64 amps_lock                        : 4;
@@ -7097,12 +7204,12 @@ union cavm_cgxx_spux_rsfec_status {
 		u64 fec_byp_cor_abil                 : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_rsfec_status_s cn; */
+	/* struct cgxx_spux_rsfec_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_STATUS(u64 a)
 {
 	return 0x10080 + 0x40000 * a;
 }
@@ -7116,18 +7223,18 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
  * 50G) and 802.3by-2016 section 108.6.8 (for 25G and extended to
  * USXGMII).
  */
-union cavm_cgxx_spux_rsfec_uncorr {
+union cgxx_spux_rsfec_uncorr {
 	u64 u;
-	struct cavm_cgxx_spux_rsfec_uncorr_s {
+	struct cgxx_spux_rsfec_uncorr_s {
 		u64 cw_cnt                           : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spux_rsfec_uncorr_s cn; */
+	/* struct cgxx_spux_rsfec_uncorr_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_UNCORR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
+static inline u64 CGXX_SPUX_RSFEC_UNCORR(u64 a)
 {
 	return 0x10090 + 0x40000 * a;
 }
@@ -7140,18 +7247,18 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
  * state diagram enters the RX_WTF state indicating that a wake time
  * fault has been detected.
  */
-union cavm_cgxx_spux_rx_eee_wake {
+union cgxx_spux_rx_eee_wake {
 	u64 u;
-	struct cavm_cgxx_spux_rx_eee_wake_s {
+	struct cgxx_spux_rx_eee_wake_s {
 		u64 wtf_error_counter                : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_rx_eee_wake_s cn; */
+	/* struct cgxx_spux_rx_eee_wake_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
+static inline u64 CGXX_SPUX_RX_EEE_WAKE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
+static inline u64 CGXX_SPUX_RX_EEE_WAKE(u64 a)
 {
 	return 0x103e0 + 8 * a;
 }
@@ -7163,9 +7270,9 @@ static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
  * Internal: This register specifies receiver LPI timing parameters Tqr,
  * Twr and Twtf.
  */
-union cavm_cgxx_spux_rx_lpi_timing {
+union cgxx_spux_rx_lpi_timing {
 	u64 u;
-	struct cavm_cgxx_spux_rx_lpi_timing_s {
+	struct cgxx_spux_rx_lpi_timing_s {
 		u64 twtf                             : 20;
 		u64 twr                              : 20;
 		u64 tqr                              : 20;
@@ -7173,12 +7280,12 @@ union cavm_cgxx_spux_rx_lpi_timing {
 		u64 rx_lpi_fw                        : 1;
 		u64 rx_lpi_en                        : 1;
 	} s;
-	/* struct cavm_cgxx_spux_rx_lpi_timing_s cn; */
+	/* struct cgxx_spux_rx_lpi_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
+static inline u64 CGXX_SPUX_RX_LPI_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
+static inline u64 CGXX_SPUX_RX_LPI_TIMING(u64 a)
 {
 	return 0x103c0 + 8 * a;
 }
@@ -7190,18 +7297,18 @@ static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
  * Internal: This register specifies receiver LPI timing parameters
  * hold_off_timer.
  */
-union cavm_cgxx_spux_rx_lpi_timing2 {
+union cgxx_spux_rx_lpi_timing2 {
 	u64 u;
-	struct cavm_cgxx_spux_rx_lpi_timing2_s {
+	struct cgxx_spux_rx_lpi_timing2_s {
 		u64 hold_off_timer                   : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_cgxx_spux_rx_lpi_timing2_s cn; */
+	/* struct cgxx_spux_rx_lpi_timing2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+static inline u64 CGXX_SPUX_RX_LPI_TIMING2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+static inline u64 CGXX_SPUX_RX_LPI_TIMING2(u64 a)
 {
 	return 0x10420 + 8 * a;
 }
@@ -7211,9 +7318,9 @@ static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING2(u64 a)
  *
  * CGX SPU Receiver Marker Interval Count Control Registers
  */
-union cavm_cgxx_spux_rx_mrk_cnt {
+union cgxx_spux_rx_mrk_cnt {
 	u64 u;
-	struct cavm_cgxx_spux_rx_mrk_cnt_s {
+	struct cgxx_spux_rx_mrk_cnt_s {
 		u64 mrk_cnt                          : 20;
 		u64 reserved_20_43                   : 24;
 		u64 by_mrk_100g                      : 1;
@@ -7221,12 +7328,12 @@ union cavm_cgxx_spux_rx_mrk_cnt {
 		u64 ram_mrk_cnt                      : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_cgxx_spux_rx_mrk_cnt_s cn; */
+	/* struct cgxx_spux_rx_mrk_cnt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_RX_MRK_CNT(u64 a)
+static inline u64 CGXX_SPUX_RX_MRK_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_RX_MRK_CNT(u64 a)
+static inline u64 CGXX_SPUX_RX_MRK_CNT(u64 a)
 {
 	return 0x103a0 + 8 * a;
 }
@@ -7236,9 +7343,9 @@ static inline u64 CAVM_CGXX_SPUX_RX_MRK_CNT(u64 a)
  *
  * CGX SPU PCS Speed Ability Registers
  */
-union cavm_cgxx_spux_spd_abil {
+union cgxx_spux_spd_abil {
 	u64 u;
-	struct cavm_cgxx_spux_spd_abil_s {
+	struct cgxx_spux_spd_abil_s {
 		u64 tengb                            : 1;
 		u64 tenpasst                         : 1;
 		u64 usxgmii                          : 1;
@@ -7248,12 +7355,12 @@ union cavm_cgxx_spux_spd_abil {
 		u64 hundredgb                        : 1;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_cgxx_spux_spd_abil_s cn; */
+	/* struct cgxx_spux_spd_abil_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_SPD_ABIL(u64 a)
+static inline u64 CGXX_SPUX_SPD_ABIL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_SPD_ABIL(u64 a)
+static inline u64 CGXX_SPUX_SPD_ABIL(u64 a)
 {
 	return 0x10010 + 0x40000 * a;
 }
@@ -7263,9 +7370,9 @@ static inline u64 CAVM_CGXX_SPUX_SPD_ABIL(u64 a)
  *
  * CGX SPU Status 1 Registers
  */
-union cavm_cgxx_spux_status1 {
+union cgxx_spux_status1 {
 	u64 u;
-	struct cavm_cgxx_spux_status1_s {
+	struct cgxx_spux_status1_s {
 		u64 reserved_0                       : 1;
 		u64 lpable                           : 1;
 		u64 rcv_lnk                          : 1;
@@ -7277,12 +7384,12 @@ union cavm_cgxx_spux_status1 {
 		u64 tx_lpi_received                  : 1;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_cgxx_spux_status1_s cn; */
+	/* struct cgxx_spux_status1_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_STATUS1(u64 a)
+static inline u64 CGXX_SPUX_STATUS1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_STATUS1(u64 a)
+static inline u64 CGXX_SPUX_STATUS1(u64 a)
 {
 	return 0x10008 + 0x40000 * a;
 }
@@ -7292,9 +7399,9 @@ static inline u64 CAVM_CGXX_SPUX_STATUS1(u64 a)
  *
  * CGX SPU Status 2 Registers
  */
-union cavm_cgxx_spux_status2 {
+union cgxx_spux_status2 {
 	u64 u;
-	struct cavm_cgxx_spux_status2_s {
+	struct cgxx_spux_status2_s {
 		u64 tengb_r                          : 1;
 		u64 tengb_x                          : 1;
 		u64 tengb_w                          : 1;
@@ -7311,12 +7418,12 @@ union cavm_cgxx_spux_status2 {
 		u64 dev                              : 2;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_status2_s cn; */
+	/* struct cgxx_spux_status2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
+static inline u64 CGXX_SPUX_STATUS2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
+static inline u64 CGXX_SPUX_STATUS2(u64 a)
 {
 	return 0x10020 + 0x40000 * a;
 }
@@ -7327,9 +7434,9 @@ static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
  * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers  Reserved.
  * Internal: Transmit LPI timing parameters Tsl, Tql and Tul
  */
-union cavm_cgxx_spux_tx_lpi_timing {
+union cgxx_spux_tx_lpi_timing {
 	u64 u;
-	struct cavm_cgxx_spux_tx_lpi_timing_s {
+	struct cgxx_spux_tx_lpi_timing_s {
 		u64 tql                              : 19;
 		u64 reserved_19_31                   : 13;
 		u64 tul                              : 12;
@@ -7340,12 +7447,12 @@ union cavm_cgxx_spux_tx_lpi_timing {
 		u64 tx_lpi_fw                        : 1;
 		u64 tx_lpi_en                        : 1;
 	} s;
-	/* struct cavm_cgxx_spux_tx_lpi_timing_s cn; */
+	/* struct cgxx_spux_tx_lpi_timing_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
+static inline u64 CGXX_SPUX_TX_LPI_TIMING(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
+static inline u64 CGXX_SPUX_TX_LPI_TIMING(u64 a)
 {
 	return 0x10400 + 8 * a;
 }
@@ -7356,9 +7463,9 @@ static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
  * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers  Reserved.
  * Internal: This register specifies transmit LPI timer parameters.
  */
-union cavm_cgxx_spux_tx_lpi_timing2 {
+union cgxx_spux_tx_lpi_timing2 {
 	u64 u;
-	struct cavm_cgxx_spux_tx_lpi_timing2_s {
+	struct cgxx_spux_tx_lpi_timing2_s {
 		u64 t1u                              : 8;
 		u64 reserved_8_11                    : 4;
 		u64 twl                              : 12;
@@ -7368,12 +7475,12 @@ union cavm_cgxx_spux_tx_lpi_timing2 {
 		u64 tbyp                             : 12;
 		u64 reserved_60_63                   : 4;
 	} s;
-	/* struct cavm_cgxx_spux_tx_lpi_timing2_s cn; */
+	/* struct cgxx_spux_tx_lpi_timing2_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+static inline u64 CGXX_SPUX_TX_LPI_TIMING2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+static inline u64 CGXX_SPUX_TX_LPI_TIMING2(u64 a)
 {
 	return 0x10440 + 8 * a;
 }
@@ -7383,9 +7490,9 @@ static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING2(u64 a)
  *
  * CGX SPU Transmitter Marker Interval Count Control Registers
  */
-union cavm_cgxx_spux_tx_mrk_cnt {
+union cgxx_spux_tx_mrk_cnt {
 	u64 u;
-	struct cavm_cgxx_spux_tx_mrk_cnt_s {
+	struct cgxx_spux_tx_mrk_cnt_s {
 		u64 mrk_cnt                          : 20;
 		u64 reserved_20_43                   : 24;
 		u64 by_mrk_100g                      : 1;
@@ -7393,12 +7500,12 @@ union cavm_cgxx_spux_tx_mrk_cnt {
 		u64 ram_mrk_cnt                      : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_cgxx_spux_tx_mrk_cnt_s cn; */
+	/* struct cgxx_spux_tx_mrk_cnt_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
+static inline u64 CGXX_SPUX_TX_MRK_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
+static inline u64 CGXX_SPUX_TX_MRK_CNT(u64 a)
 {
 	return 0x10380 + 8 * a;
 }
@@ -7416,9 +7523,9 @@ static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
  * common denominator technology. The format for this register is from
  * USXGMII Multiport specification section 1.1.2 Table 2.
  */
-union cavm_cgxx_spux_usx_an_adv {
+union cgxx_spux_usx_an_adv {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_adv_s {
+	struct cgxx_spux_usx_an_adv_s {
 		u64 set                              : 1;
 		u64 reserved_1_6                     : 6;
 		u64 eee_clk_stop_abil                : 1;
@@ -7429,12 +7536,12 @@ union cavm_cgxx_spux_usx_an_adv {
 		u64 lnk_st                           : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_adv_s cn; */
+	/* struct cgxx_spux_usx_an_adv_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_ADV(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_ADV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_ADV(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_ADV(u64 a)
 {
 	return 0x101d0 + 0x40000 * a;
 }
@@ -7444,9 +7551,9 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_ADV(u64 a)
  *
  * CGX SPU USXGMII Autonegotiation Control Register
  */
-union cavm_cgxx_spux_usx_an_control {
+union cgxx_spux_usx_an_control {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_control_s {
+	struct cgxx_spux_usx_an_control_s {
 		u64 reserved_0_8                     : 9;
 		u64 rst_an                           : 1;
 		u64 reserved_10_11                   : 2;
@@ -7455,12 +7562,12 @@ union cavm_cgxx_spux_usx_an_control {
 		u64 an_reset                         : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_control_s cn; */
+	/* struct cgxx_spux_usx_an_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_CONTROL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_CONTROL(u64 a)
 {
 	return 0x101c0 + 0x40000 * a;
 }
@@ -7471,20 +7578,20 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
  * CGX SPU USXGMII Autonegotiation Expansion Register This register is
  * only used to signal page reception.
  */
-union cavm_cgxx_spux_usx_an_expansion {
+union cgxx_spux_usx_an_expansion {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_expansion_s {
+	struct cgxx_spux_usx_an_expansion_s {
 		u64 reserved_0                       : 1;
 		u64 an_page_received                 : 1;
 		u64 next_page_able                   : 1;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_expansion_s cn; */
+	/* struct cgxx_spux_usx_an_expansion_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_EXPANSION(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_EXPANSION(u64 a)
 {
 	return 0x101e0 + 0x40000 * a;
 }
@@ -7495,18 +7602,18 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
  * CGX SPU USXGMII Flow Control Registers This register is used by
  * software to affect USXGMII AN hardware behavior.
  */
-union cavm_cgxx_spux_usx_an_flow_ctrl {
+union cgxx_spux_usx_an_flow_ctrl {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_flow_ctrl_s {
+	struct cgxx_spux_usx_an_flow_ctrl_s {
 		u64 start_idle_detect                : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_flow_ctrl_s cn; */
+	/* struct cgxx_spux_usx_an_flow_ctrl_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
 {
 	return 0x101e8 + 0x40000 * a;
 }
@@ -7516,18 +7623,18 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
  *
  * CGX SPU USXGMII Link Timer Registers This is the link timer register.
  */
-union cavm_cgxx_spux_usx_an_link_timer {
+union cgxx_spux_usx_an_link_timer {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_link_timer_s {
+	struct cgxx_spux_usx_an_link_timer_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_link_timer_s cn; */
+	/* struct cgxx_spux_usx_an_link_timer_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
 {
 	return 0x101f0 + 0x40000 * a;
 }
@@ -7542,9 +7649,9 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
  * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this
  * register is updated by hardware.
  */
-union cavm_cgxx_spux_usx_an_lp_abil {
+union cgxx_spux_usx_an_lp_abil {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_lp_abil_s {
+	struct cgxx_spux_usx_an_lp_abil_s {
 		u64 set                              : 1;
 		u64 reserved_1_6                     : 6;
 		u64 eee_clk_stop_abil                : 1;
@@ -7555,12 +7662,12 @@ union cavm_cgxx_spux_usx_an_lp_abil {
 		u64 lnk_st                           : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_lp_abil_s cn; */
+	/* struct cgxx_spux_usx_an_lp_abil_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
 {
 	return 0x101d8 + 0x40000 * a;
 }
@@ -7570,9 +7677,9 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
  *
  * CGX SPU USXGMII Autonegotiation Status Register
  */
-union cavm_cgxx_spux_usx_an_status {
+union cgxx_spux_usx_an_status {
 	u64 u;
-	struct cavm_cgxx_spux_usx_an_status_s {
+	struct cgxx_spux_usx_an_status_s {
 		u64 extnd                            : 1;
 		u64 reserved_1                       : 1;
 		u64 lnk_st                           : 1;
@@ -7581,12 +7688,12 @@ union cavm_cgxx_spux_usx_an_status {
 		u64 an_cpt                           : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_spux_usx_an_status_s cn; */
+	/* struct cgxx_spux_usx_an_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPUX_USX_AN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPUX_USX_AN_STATUS(u64 a)
+static inline u64 CGXX_SPUX_USX_AN_STATUS(u64 a)
 {
 	return 0x101c8 + 0x40000 * a;
 }
@@ -7596,9 +7703,9 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_STATUS(u64 a)
  *
  * CGX SPU Debug Control Registers
  */
-union cavm_cgxx_spu_dbg_control {
+union cgxx_spu_dbg_control {
 	u64 u;
-	struct cavm_cgxx_spu_dbg_control_s {
+	struct cgxx_spu_dbg_control_s {
 		u64 marker_rxp                       : 15;
 		u64 reserved_15                      : 1;
 		u64 scramble_dis                     : 1;
@@ -7608,17 +7715,36 @@ union cavm_cgxx_spu_dbg_control {
 		u64 timestamp_norm_dis               : 1;
 		u64 an_nonce_match_dis               : 1;
 		u64 br_ber_mon_dis                   : 1;
-		u64 reserved_31                      : 1;
+		u64 rf_cw_mon_erly_restart_dis       : 1;
 		u64 us_clk_period                    : 12;
 		u64 ms_clk_period                    : 12;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_cgxx_spu_dbg_control_s cn; */
+	struct cgxx_spu_dbg_control_cn96xxp1 {
+		u64 marker_rxp                       : 15;
+		u64 reserved_15                      : 1;
+		u64 scramble_dis                     : 1;
+		u64 reserved_17_18                   : 2;
+		u64 br_pmd_train_soft_en             : 1;
+		u64 reserved_20_27                   : 8;
+		u64 timestamp_norm_dis               : 1;
+		u64 an_nonce_match_dis               : 1;
+		u64 br_ber_mon_dis                   : 1;
+		u64 reserved_31                      : 1;
+		u64 us_clk_period                    : 12;
+		u64 ms_clk_period                    : 12;
+		u64 reserved_56_63                   : 8;
+	} cn96xxp1;
+	/* struct cgxx_spu_dbg_control_s cn96xxp3; */
+	/* struct cgxx_spu_dbg_control_s cn98xx; */
+	/* struct cgxx_spu_dbg_control_cn96xxp1 cnf95xxp1; */
+	/* struct cgxx_spu_dbg_control_s cnf95xxp2; */
+	/* struct cgxx_spu_dbg_control_s loki; */
 };
 
-static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
+static inline u64 CGXX_SPU_DBG_CONTROL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
+static inline u64 CGXX_SPU_DBG_CONTROL(void)
 {
 	return 0x10300;
 }
@@ -7629,18 +7755,18 @@ static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
  * CGX SPU SerDes Lane Skew Status Registers This register provides
  * SerDes lane skew status. One register per physical SerDes lane.
  */
-union cavm_cgxx_spu_sdsx_skew_status {
+union cgxx_spu_sdsx_skew_status {
 	u64 u;
-	struct cavm_cgxx_spu_sdsx_skew_status_s {
+	struct cgxx_spu_sdsx_skew_status_s {
 		u64 skew_status                      : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_cgxx_spu_sdsx_skew_status_s cn; */
+	/* struct cgxx_spu_sdsx_skew_status_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+static inline u64 CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+static inline u64 CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
 {
 	return 0x10340 + 8 * a;
 }
@@ -7651,9 +7777,9 @@ static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
  * CGX SPU SerDes States Registers This register provides SerDes lane
  * states. One register per physical SerDes lane.
  */
-union cavm_cgxx_spu_sdsx_states {
+union cgxx_spu_sdsx_states {
 	u64 u;
-	struct cavm_cgxx_spu_sdsx_states_s {
+	struct cgxx_spu_sdsx_states_s {
 		u64 bx_sync_sm                       : 4;
 		u64 br_sh_cnt                        : 11;
 		u64 br_block_lock                    : 1;
@@ -7675,12 +7801,12 @@ union cavm_cgxx_spu_sdsx_states {
 		u64 am_lock_invld_cnt                : 2;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_cgxx_spu_sdsx_states_s cn; */
+	/* struct cgxx_spu_sdsx_states_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
+static inline u64 CGXX_SPU_SDSX_STATES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
+static inline u64 CGXX_SPU_SDSX_STATES(u64 a)
 {
 	return 0x10360 + 8 * a;
 }
@@ -7694,22 +7820,22 @@ static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
  * soft- reset state in USXGMII mode, the CGX will transmit Remote Fault
  * BASE-R blocks.
  */
-union cavm_cgxx_spu_usxgmii_control {
+union cgxx_spu_usxgmii_control {
 	u64 u;
-	struct cavm_cgxx_spu_usxgmii_control_s {
+	struct cgxx_spu_usxgmii_control_s {
 		u64 enable                           : 1;
 		u64 usxgmii_type                     : 3;
 		u64 sds_id                           : 2;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_cgxx_spu_usxgmii_control_s cn; */
+	/* struct cgxx_spu_usxgmii_control_s cn; */
 };
 
-static inline u64 CAVM_CGXX_SPU_USXGMII_CONTROL(void)
+static inline u64 CGXX_SPU_USXGMII_CONTROL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_CGXX_SPU_USXGMII_CONTROL(void)
+static inline u64 CGXX_SPU_USXGMII_CONTROL(void)
 {
 	return 0x10920;
 }
 
-#endif /* __CAVM_CSRS_CGX_H__ */
+#endif /* __CSRS_CGX_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
new file mode 100644
index 0000000000..72a5956c60
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-lmt.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_LMT_H__
+#define __CSRS_LMT_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * LMT.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtcancel
+ *
+ * RVU VF LMT Cancel Register
+ */
+union lmt_lf_lmtcancel {
+	u64 u;
+	struct lmt_lf_lmtcancel_s {
+		u64 data                             : 64;
+	} s;
+	/* struct lmt_lf_lmtcancel_s cn; */
+};
+
+static inline u64 LMT_LF_LMTCANCEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 LMT_LF_LMTCANCEL(void)
+{
+	return 0x400;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtline#
+ *
+ * RVU VF LMT Line Registers
+ */
+union lmt_lf_lmtlinex {
+	u64 u;
+	struct lmt_lf_lmtlinex_s {
+		u64 data                             : 64;
+	} s;
+	/* struct lmt_lf_lmtlinex_s cn; */
+};
+
+static inline u64 LMT_LF_LMTLINEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 LMT_LF_LMTLINEX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+#endif /* __CSRS_LMT_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
new file mode 100644
index 0000000000..4dd8958d2f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-mio_emm.h
@@ -0,0 +1,1199 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_MIO_EMM_H__
+#define __CSRS_MIO_EMM_H__
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * MIO_EMM.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union mio_emm_access_wdog {
+	u64 u;
+	struct mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union mio_emm_buf_dat {
+	u64 u;
+	struct mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union mio_emm_buf_idx {
+	u64 u;
+	struct mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union mio_emm_calb {
+	u64 u;
+	struct mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct mio_emm_calb_s cn; */
+};
+
+static inline u64 MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union mio_emm_cfg {
+	u64 u;
+	struct mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union mio_emm_cmd {
+	u64 u;
+	struct mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union mio_emm_comp {
+	u64 u;
+	struct mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct mio_emm_comp_s cn; */
+};
+
+static inline u64 MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union mio_emm_debug {
+	u64 u;
+	struct mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 emmc_clk_disable                 : 1;
+		u64 rdsync_rst                       : 1;
+		u64 reserved_22_63                   : 42;
+	} s;
+	struct mio_emm_debug_cn96xxp1 {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} cn96xxp1;
+	/* struct mio_emm_debug_s cn96xxp3; */
+	/* struct mio_emm_debug_s cn98xx; */
+	/* struct mio_emm_debug_cn96xxp1 cnf95xx; */
+	/* struct mio_emm_debug_s loki; */
+};
+
+static inline u64 MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union mio_emm_dma {
+	u64 u;
+	struct mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union mio_emm_dma_adr {
+	u64 u;
+	struct mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union mio_emm_dma_arg {
+	u64 u;
+	struct mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union mio_emm_dma_cfg {
+	u64 u;
+	struct mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union mio_emm_dma_fifo_adr {
+	u64 u;
+	struct mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct mio_emm_dma_fifo_cmd_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union mio_emm_dma_int {
+	u64 u;
+	struct mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_dma_int_w1s {
+	u64 u;
+	struct mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union mio_emm_int {
+	u64 u;
+	struct mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union mio_emm_int_ena_w1c {
+	u64 u;
+	struct mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union mio_emm_int_ena_w1s {
+	u64 u;
+	struct mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union mio_emm_int_w1s {
+	u64 u;
+	struct mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union mio_emm_io_ctl {
+	u64 u;
+	struct mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union mio_emm_modex {
+	u64 u;
+	struct mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	struct mio_emm_modex_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} cn96xxp1;
+	/* struct mio_emm_modex_s cn96xxp3; */
+	/* struct mio_emm_modex_s cn98xx; */
+	/* struct mio_emm_modex_s cnf95xx; */
+	/* struct mio_emm_modex_s loki; */
+};
+
+static inline u64 MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_pbax {
+	u64 u;
+	struct mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_addr {
+	u64 u;
+	struct mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union mio_emm_rca {
+	u64 u;
+	struct mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct mio_emm_rca_s cn; */
+};
+
+static inline u64 MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union mio_emm_rsp_hi {
+	u64 u;
+	struct mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union mio_emm_rsp_lo {
+	u64 u;
+	struct mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union mio_emm_rsp_sts {
+	u64 u;
+	struct mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union mio_emm_sample {
+	u64 u;
+	struct mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_sample_s cn; */
+};
+
+static inline u64 MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union mio_emm_sts_mask {
+	u64 u;
+	struct mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union mio_emm_switch {
+	u64 u;
+	struct mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 clk_swap                         : 1;
+		u64 reserved_37_39                   : 3;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	struct mio_emm_switch_cn96xxp1 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn96xxp1;
+	/* struct mio_emm_switch_s cn96xxp3; */
+	/* struct mio_emm_switch_s cn98xx; */
+	/* struct mio_emm_switch_s cnf95xx; */
+	/* struct mio_emm_switch_s loki; */
+};
+
+static inline u64 MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union mio_emm_tap {
+	u64 u;
+	struct mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct mio_emm_tap_s cn; */
+};
+
+static inline u64 MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union mio_emm_timing {
+	u64 u;
+	struct mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct mio_emm_timing_s cn; */
+};
+
+static inline u64 MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union mio_emm_wdog {
+	u64 u;
+	struct mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct mio_emm_wdog_s cn; */
+};
+
+static inline u64 MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CSRS_MIO_EMM_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-nix.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
similarity index 64%
rename from drivers/net/octeontx2/cavm-csrs-nix.h
rename to arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
index a4618fe133..81b9235365 100644
--- a/drivers/net/octeontx2/cavm-csrs-nix.h
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-nix.h
@@ -1,18 +1,17 @@
-#ifndef __CAVM_CSRS_NIX_H__
-#define __CAVM_CSRS_NIX_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NIX_H__
+#define __CSRS_NIX_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium NIX.
+ * NIX.
  *
  * This file is auto generated.  Do not edit.
  *
@@ -24,11 +23,11 @@
  * NIX Admin Function Interrupt Vector Enumeration Enumerates the NIX AF
  * MSI-X interrupt vectors.
  */
-#define CAVM_NIX_AF_INT_VEC_E_AF_ERR (3)
-#define CAVM_NIX_AF_INT_VEC_E_AQ_DONE (2)
-#define CAVM_NIX_AF_INT_VEC_E_GEN (1)
-#define CAVM_NIX_AF_INT_VEC_E_POISON (4)
-#define CAVM_NIX_AF_INT_VEC_E_RVU (0)
+#define NIX_AF_INT_VEC_E_AF_ERR (3)
+#define NIX_AF_INT_VEC_E_AQ_DONE (2)
+#define NIX_AF_INT_VEC_E_GEN (1)
+#define NIX_AF_INT_VEC_E_POISON (4)
+#define NIX_AF_INT_VEC_E_RVU (0)
 
 /**
  * Enumeration nix_aq_comp_e
@@ -36,25 +35,25 @@
  * NIX Completion Enumeration Enumerates the values of
  * NIX_AQ_RES_S[COMPCODE].
  */
-#define CAVM_NIX_AQ_COMP_E_CTX_FAULT (4)
-#define CAVM_NIX_AQ_COMP_E_CTX_POISON (3)
-#define CAVM_NIX_AQ_COMP_E_GOOD (1)
-#define CAVM_NIX_AQ_COMP_E_LOCKERR (5)
-#define CAVM_NIX_AQ_COMP_E_NOTDONE (0)
-#define CAVM_NIX_AQ_COMP_E_SQB_ALLOC_FAIL (6)
-#define CAVM_NIX_AQ_COMP_E_SWERR (2)
+#define NIX_AQ_COMP_E_CTX_FAULT (4)
+#define NIX_AQ_COMP_E_CTX_POISON (3)
+#define NIX_AQ_COMP_E_GOOD (1)
+#define NIX_AQ_COMP_E_LOCKERR (5)
+#define NIX_AQ_COMP_E_NOTDONE (0)
+#define NIX_AQ_COMP_E_SQB_ALLOC_FAIL (6)
+#define NIX_AQ_COMP_E_SWERR (2)
 
 /**
  * Enumeration nix_aq_ctype_e
  *
  * NIX Context Type Enumeration Enumerates NIX_AQ_INST_S[CTYPE] values.
  */
-#define CAVM_NIX_AQ_CTYPE_E_CQ (2)
-#define CAVM_NIX_AQ_CTYPE_E_DYNO (5)
-#define CAVM_NIX_AQ_CTYPE_E_MCE (3)
-#define CAVM_NIX_AQ_CTYPE_E_RQ (0)
-#define CAVM_NIX_AQ_CTYPE_E_RSS (4)
-#define CAVM_NIX_AQ_CTYPE_E_SQ (1)
+#define NIX_AQ_CTYPE_E_CQ (2)
+#define NIX_AQ_CTYPE_E_DYNO (5)
+#define NIX_AQ_CTYPE_E_MCE (3)
+#define NIX_AQ_CTYPE_E_RQ (0)
+#define NIX_AQ_CTYPE_E_RSS (4)
+#define NIX_AQ_CTYPE_E_SQ (1)
 
 /**
  * Enumeration nix_aq_instop_e
@@ -62,12 +61,12 @@
  * NIX Admin Queue Opcode Enumeration Enumerates NIX_AQ_INST_S[OP]
  * values.
  */
-#define CAVM_NIX_AQ_INSTOP_E_INIT (1)
-#define CAVM_NIX_AQ_INSTOP_E_LOCK (4)
-#define CAVM_NIX_AQ_INSTOP_E_NOP (0)
-#define CAVM_NIX_AQ_INSTOP_E_READ (3)
-#define CAVM_NIX_AQ_INSTOP_E_UNLOCK (5)
-#define CAVM_NIX_AQ_INSTOP_E_WRITE (2)
+#define NIX_AQ_INSTOP_E_INIT (1)
+#define NIX_AQ_INSTOP_E_LOCK (4)
+#define NIX_AQ_INSTOP_E_NOP (0)
+#define NIX_AQ_INSTOP_E_READ (3)
+#define NIX_AQ_INSTOP_E_UNLOCK (5)
+#define NIX_AQ_INSTOP_E_WRITE (2)
 
 /**
  * Enumeration nix_chan_e
@@ -79,11 +78,11 @@
  * NIX_LINK_E are implemented.  Internal: P2X/X2P channel enumeration for
  * t9x.
  */
-#define CAVM_NIX_CHAN_E_CGXX_LMACX_CHX(a, b, c)	\
+#define NIX_CHAN_E_CGXX_LMACX_CHX(a, b, c)	\
 	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
-#define CAVM_NIX_CHAN_E_LBKX_CHX(a, b) (0 + 0x100 * (a) + (b))
-#define CAVM_NIX_CHAN_E_RX(a) (0 + 0x100 * (a))
-#define CAVM_NIX_CHAN_E_SDP_CHX(a) (0x700 + (a))
+#define NIX_CHAN_E_LBKX_CHX(a, b) (0 + 0x100 * (a) + (b))
+#define NIX_CHAN_E_RX(a) (0 + 0x100 * (a))
+#define NIX_CHAN_E_SDP_CHX(a) (0x700 + (a))
 
 /**
  * Enumeration nix_colorresult_e
@@ -92,10 +91,10 @@
  * NIX_MEM_RESULT_S[COLOR], NIX_AF_TL1()_MD_DEBUG1[COLOR] and
  * NIX_AF_TL1()_MD_DEBUG1[COLOR].
  */
-#define CAVM_NIX_COLORRESULT_E_GREEN (0)
-#define CAVM_NIX_COLORRESULT_E_RED_DROP (3)
-#define CAVM_NIX_COLORRESULT_E_RED_SEND (2)
-#define CAVM_NIX_COLORRESULT_E_YELLOW (1)
+#define NIX_COLORRESULT_E_GREEN (0)
+#define NIX_COLORRESULT_E_RED_DROP (3)
+#define NIX_COLORRESULT_E_RED_SEND (2)
+#define NIX_COLORRESULT_E_YELLOW (1)
 
 /**
  * Enumeration nix_cqerrint_e
@@ -103,9 +102,9 @@
  * NIX Completion Queue Interrupt Enumeration Enumerates the bit index of
  * NIX_CQ_CTX_S[CQ_ERR_INT,CQ_ERR_INT_ENA].
  */
-#define CAVM_NIX_CQERRINT_E_CQE_FAULT (2)
-#define CAVM_NIX_CQERRINT_E_DOOR_ERR (0)
-#define CAVM_NIX_CQERRINT_E_WR_FULL (1)
+#define NIX_CQERRINT_E_CQE_FAULT (2)
+#define NIX_CQERRINT_E_DOOR_ERR (0)
+#define NIX_CQERRINT_E_WR_FULL (1)
 
 /**
  * Enumeration nix_intf_e
@@ -113,9 +112,15 @@
  * NIX Interface Number Enumeration Enumerates the bit index of
  * NIX_AF_STATUS[CALIBRATE_STATUS].
  */
-#define CAVM_NIX_INTF_E_CGXX(a) (0 + (a))
-#define CAVM_NIX_INTF_E_LBKX(a) (3 + (a))
-#define CAVM_NIX_INTF_E_SDP (4)
+#define NIX_INTF_E_CGXX(a) (0 + (a))
+#define NIX_INTF_E_LBKX_CN96XX(a) (3 + (a))
+#define NIX_INTF_E_LBKX_CN98XX(a) (5 + (a))
+#define NIX_INTF_E_LBKX_CNF95XX(a) (3 + (a))
+#define NIX_INTF_E_LBKX_LOKI(a) (3 + (a))
+#define NIX_INTF_E_SDP_CN96XX (4)
+#define NIX_INTF_E_SDP_CN98XX (7)
+#define NIX_INTF_E_SDP_CNF95XX (4)
+#define NIX_INTF_E_SDP_LOKI (4)
 
 /**
  * Enumeration nix_lf_int_vec_e
@@ -123,25 +128,33 @@
  * NIX Local Function Interrupt Vector Enumeration Enumerates the NIX
  * MSI-X interrupt vectors per LF.
  */
-#define CAVM_NIX_LF_INT_VEC_E_CINTX(a) (0x40 + (a))
-#define CAVM_NIX_LF_INT_VEC_E_ERR_INT (0x81)
-#define CAVM_NIX_LF_INT_VEC_E_GINT (0x80)
-#define CAVM_NIX_LF_INT_VEC_E_POISON (0x82)
-#define CAVM_NIX_LF_INT_VEC_E_QINTX(a) (0 + (a))
+#define NIX_LF_INT_VEC_E_CINTX(a) (0x40 + (a))
+#define NIX_LF_INT_VEC_E_ERR_INT (0x81)
+#define NIX_LF_INT_VEC_E_GINT (0x80)
+#define NIX_LF_INT_VEC_E_POISON (0x82)
+#define NIX_LF_INT_VEC_E_QINTX(a) (0 + (a))
 
 /**
  * Enumeration nix_link_e
  *
  * NIX Link Number Enumeration Enumerates the receive and transmit links,
  * and LINK index of NIX_AF_RX_LINK()_CFG, NIX_AF_RX_LINK()_WRR_CFG,
- * NIX_AF_TX_LINK()_NORM_CREDIT, NIX_AF_TX_LINK()_EXPR_CREDIT,
- * NIX_AF_TX_LINK()_HW_XOFF and NIX_AF_TX_LINK()_SW_XOFF,
+ * NIX_AF_TX_LINK()_NORM_CREDIT, NIX_AF_TX_LINK()_HW_XOFF and
  * NIX_AF_TL3_TL2()_LINK()_CFG.
  */
-#define CAVM_NIX_LINK_E_CGXX_LMACX(a, b) (0 + 4 * (a) + (b))
-#define CAVM_NIX_LINK_E_LBKX(a) (0xc + (a))
-#define CAVM_NIX_LINK_E_MC (0xe)
-#define CAVM_NIX_LINK_E_SDP (0xd)
+#define NIX_LINK_E_CGXX_LMACX(a, b) (0 + 4 * (a) + (b))
+#define NIX_LINK_E_LBKX_CN96XX(a) (0xc + (a))
+#define NIX_LINK_E_LBKX_CN98XX(a) (0x14 + (a))
+#define NIX_LINK_E_LBKX_CNF95XX(a) (0xc + (a))
+#define NIX_LINK_E_LBKX_LOKI(a) (0xc + (a))
+#define NIX_LINK_E_MC_CN96XX (0xe)
+#define NIX_LINK_E_MC_CN98XX (0x17)
+#define NIX_LINK_E_MC_CNF95XX (0xe)
+#define NIX_LINK_E_MC_LOKI (0xe)
+#define NIX_LINK_E_SDP_CN96XX (0xd)
+#define NIX_LINK_E_SDP_CN98XX (0x16)
+#define NIX_LINK_E_SDP_CNF95XX (0xd)
+#define NIX_LINK_E_SDP_LOKI (0xd)
 
 /**
  * Enumeration nix_lsoalg_e
@@ -150,11 +163,11 @@
  * NIX_AF_LSO_FORMAT()_FIELD()[ALG] values. Specifies algorithm for
  * modifying the associated LSO packet field.
  */
-#define CAVM_NIX_LSOALG_E_ADD_OFFSET (3)
-#define CAVM_NIX_LSOALG_E_ADD_PAYLEN (2)
-#define CAVM_NIX_LSOALG_E_ADD_SEGNUM (1)
-#define CAVM_NIX_LSOALG_E_NOP (0)
-#define CAVM_NIX_LSOALG_E_TCP_FLAGS (4)
+#define NIX_LSOALG_E_ADD_OFFSET (3)
+#define NIX_LSOALG_E_ADD_PAYLEN (2)
+#define NIX_LSOALG_E_ADD_SEGNUM (1)
+#define NIX_LSOALG_E_NOP (0)
+#define NIX_LSOALG_E_TCP_FLAGS (4)
 
 /**
  * Enumeration nix_maxsqesz_e
@@ -162,8 +175,8 @@
  * NIX Maximum SQE Size Enumeration Enumerates the values of
  * NIX_SQ_CTX_S[MAX_SQE_SIZE].
  */
-#define CAVM_NIX_MAXSQESZ_E_W16 (0)
-#define CAVM_NIX_MAXSQESZ_E_W8 (1)
+#define NIX_MAXSQESZ_E_W16 (0)
+#define NIX_MAXSQESZ_E_W8 (1)
 
 /**
  * Enumeration nix_mdtype_e
@@ -171,9 +184,9 @@
  * NIX Meta Descriptor Type Enumeration Enumerates values of
  * NIX_AF_MDQ()_MD_DEBUG[MD_TYPE].
  */
-#define CAVM_NIX_MDTYPE_E_FLUSH (1)
-#define CAVM_NIX_MDTYPE_E_PMD (2)
-#define CAVM_NIX_MDTYPE_E_RSVD (0)
+#define NIX_MDTYPE_E_FLUSH (1)
+#define NIX_MDTYPE_E_PMD (2)
+#define NIX_MDTYPE_E_RSVD (0)
 
 /**
  * Enumeration nix_mnqerr_e
@@ -181,16 +194,16 @@
  * NIX Meta-Descriptor Enqueue Error Enumeration Enumerates
  * NIX_LF_MNQ_ERR_DBG[ERRCODE] values.
  */
-#define CAVM_NIX_MNQERR_E_CQ_QUERY_ERR (6)
-#define CAVM_NIX_MNQERR_E_LSO_ERR (5)
-#define CAVM_NIX_MNQERR_E_MAXLEN_ERR (8)
-#define CAVM_NIX_MNQERR_E_MAX_SQE_SIZE_ERR (7)
-#define CAVM_NIX_MNQERR_E_SQB_FAULT (2)
-#define CAVM_NIX_MNQERR_E_SQB_POISON (3)
-#define CAVM_NIX_MNQERR_E_SQE_SIZEM1_ZERO (9)
-#define CAVM_NIX_MNQERR_E_SQ_CTX_FAULT (0)
-#define CAVM_NIX_MNQERR_E_SQ_CTX_POISON (1)
-#define CAVM_NIX_MNQERR_E_TOTAL_ERR (4)
+#define NIX_MNQERR_E_CQ_QUERY_ERR (6)
+#define NIX_MNQERR_E_LSO_ERR (5)
+#define NIX_MNQERR_E_MAXLEN_ERR (8)
+#define NIX_MNQERR_E_MAX_SQE_SIZE_ERR (7)
+#define NIX_MNQERR_E_SQB_FAULT (2)
+#define NIX_MNQERR_E_SQB_POISON (3)
+#define NIX_MNQERR_E_SQE_SIZEM1_ZERO (9)
+#define NIX_MNQERR_E_SQ_CTX_FAULT (0)
+#define NIX_MNQERR_E_SQ_CTX_POISON (1)
+#define NIX_MNQERR_E_TOTAL_ERR (4)
 
 /**
  * Enumeration nix_ndc_rx_port_e
@@ -199,12 +212,12 @@
  * (NDC_IDX_E::NIX()_RX) ports and the PORT index of
  * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
-#define CAVM_NIX_NDC_RX_PORT_E_AQ (0)
-#define CAVM_NIX_NDC_RX_PORT_E_CINT (2)
-#define CAVM_NIX_NDC_RX_PORT_E_CQ (1)
-#define CAVM_NIX_NDC_RX_PORT_E_MC (3)
-#define CAVM_NIX_NDC_RX_PORT_E_PKT (4)
-#define CAVM_NIX_NDC_RX_PORT_E_RQ (5)
+#define NIX_NDC_RX_PORT_E_AQ (0)
+#define NIX_NDC_RX_PORT_E_CINT (2)
+#define NIX_NDC_RX_PORT_E_CQ (1)
+#define NIX_NDC_RX_PORT_E_MC (3)
+#define NIX_NDC_RX_PORT_E_PKT (4)
+#define NIX_NDC_RX_PORT_E_RQ (5)
 
 /**
  * Enumeration nix_ndc_tx_port_e
@@ -213,12 +226,12 @@
  * (NDC_IDX_E::NIX()_TX) ports and the PORT index of
  * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
-#define CAVM_NIX_NDC_TX_PORT_E_DEQ (3)
-#define CAVM_NIX_NDC_TX_PORT_E_DMA (4)
-#define CAVM_NIX_NDC_TX_PORT_E_ENQ (1)
-#define CAVM_NIX_NDC_TX_PORT_E_LMT (0)
-#define CAVM_NIX_NDC_TX_PORT_E_MNQ (2)
-#define CAVM_NIX_NDC_TX_PORT_E_XQE (5)
+#define NIX_NDC_TX_PORT_E_DEQ (3)
+#define NIX_NDC_TX_PORT_E_DMA (4)
+#define NIX_NDC_TX_PORT_E_ENQ (1)
+#define NIX_NDC_TX_PORT_E_LMT (0)
+#define NIX_NDC_TX_PORT_E_MNQ (2)
+#define NIX_NDC_TX_PORT_E_XQE (5)
 
 /**
  * Enumeration nix_re_opcode_e
@@ -227,18 +240,18 @@
  * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
  * NPC_ERRLEV_E::RE.
  */
-#define CAVM_NIX_RE_OPCODE_E_OL2_LENMISM (0x12)
-#define CAVM_NIX_RE_OPCODE_E_OVERSIZE (0x11)
-#define CAVM_NIX_RE_OPCODE_E_RE_DMAPKT (0xf)
-#define CAVM_NIX_RE_OPCODE_E_RE_FCS (7)
-#define CAVM_NIX_RE_OPCODE_E_RE_FCS_RCV (8)
-#define CAVM_NIX_RE_OPCODE_E_RE_JABBER (2)
-#define CAVM_NIX_RE_OPCODE_E_RE_NONE (0)
-#define CAVM_NIX_RE_OPCODE_E_RE_PARTIAL (1)
-#define CAVM_NIX_RE_OPCODE_E_RE_RX_CTL (0xb)
-#define CAVM_NIX_RE_OPCODE_E_RE_SKIP (0xc)
-#define CAVM_NIX_RE_OPCODE_E_RE_TERMINATE (9)
-#define CAVM_NIX_RE_OPCODE_E_UNDERSIZE (0x10)
+#define NIX_RE_OPCODE_E_OL2_LENMISM (0x12)
+#define NIX_RE_OPCODE_E_OVERSIZE (0x11)
+#define NIX_RE_OPCODE_E_RE_DMAPKT (0xf)
+#define NIX_RE_OPCODE_E_RE_FCS (7)
+#define NIX_RE_OPCODE_E_RE_FCS_RCV (8)
+#define NIX_RE_OPCODE_E_RE_JABBER (2)
+#define NIX_RE_OPCODE_E_RE_NONE (0)
+#define NIX_RE_OPCODE_E_RE_PARTIAL (1)
+#define NIX_RE_OPCODE_E_RE_RX_CTL (0xb)
+#define NIX_RE_OPCODE_E_RE_SKIP (0xc)
+#define NIX_RE_OPCODE_E_RE_TERMINATE (9)
+#define NIX_RE_OPCODE_E_UNDERSIZE (0x10)
 
 /**
  * Enumeration nix_redalg_e
@@ -246,10 +259,10 @@
  * NIX Red Algorithm Enumeration Enumerates the different algorithms of
  * NIX_SEND_EXT_S[SHP_RA].
  */
-#define CAVM_NIX_REDALG_E_DISCARD (3)
-#define CAVM_NIX_REDALG_E_SEND (1)
-#define CAVM_NIX_REDALG_E_STALL (2)
-#define CAVM_NIX_REDALG_E_STD (0)
+#define NIX_REDALG_E_DISCARD (3)
+#define NIX_REDALG_E_SEND (1)
+#define NIX_REDALG_E_STALL (2)
+#define NIX_REDALG_E_STD (0)
 
 /**
  * Enumeration nix_rqint_e
@@ -257,9 +270,9 @@
  * NIX Receive Queue Interrupt Enumeration Enumerates the bit index of
  * NIX_RQ_CTX_S[RQ_INT,RQ_INT_ENA].
  */
-#define CAVM_NIX_RQINT_E_DROP (0)
-#define CAVM_NIX_RQINT_E_RX(a) (0 + (a))
-#define CAVM_NIX_RQINT_E_RED (1)
+#define NIX_RQINT_E_DROP (0)
+#define NIX_RQINT_E_RX(a) (0 + (a))
+#define NIX_RQINT_E_RED (1)
 
 /**
  * Enumeration nix_rx_actionop_e
@@ -267,13 +280,13 @@
  * NIX Receive Action Opcode Enumeration Enumerates the values of
  * NIX_RX_ACTION_S[OP].
  */
-#define CAVM_NIX_RX_ACTIONOP_E_DROP (0)
-#define CAVM_NIX_RX_ACTIONOP_E_MCAST (3)
-#define CAVM_NIX_RX_ACTIONOP_E_MIRROR (6)
-#define CAVM_NIX_RX_ACTIONOP_E_PF_FUNC_DROP (5)
-#define CAVM_NIX_RX_ACTIONOP_E_RSS (4)
-#define CAVM_NIX_RX_ACTIONOP_E_UCAST (1)
-#define CAVM_NIX_RX_ACTIONOP_E_UCAST_IPSEC (2)
+#define NIX_RX_ACTIONOP_E_DROP (0)
+#define NIX_RX_ACTIONOP_E_MCAST (3)
+#define NIX_RX_ACTIONOP_E_MIRROR (6)
+#define NIX_RX_ACTIONOP_E_PF_FUNC_DROP (5)
+#define NIX_RX_ACTIONOP_E_RSS (4)
+#define NIX_RX_ACTIONOP_E_UCAST (1)
+#define NIX_RX_ACTIONOP_E_UCAST_IPSEC (2)
 
 /**
  * Enumeration nix_rx_mcop_e
@@ -281,8 +294,8 @@
  * NIX Receive Multicast/Mirror Opcode Enumeration Enumerates the values
  * of NIX_RX_MCE_S[OP].
  */
-#define CAVM_NIX_RX_MCOP_E_RQ (0)
-#define CAVM_NIX_RX_MCOP_E_RSS (1)
+#define NIX_RX_MCOP_E_RQ (0)
+#define NIX_RX_MCOP_E_RSS (1)
 
 /**
  * Enumeration nix_rx_perrcode_e
@@ -291,22 +304,22 @@
  * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
  * NPC_ERRLEV_E::NIX.
  */
-#define CAVM_NIX_RX_PERRCODE_E_BUFS_OFLOW (0xa)
-#define CAVM_NIX_RX_PERRCODE_E_DATA_FAULT (8)
-#define CAVM_NIX_RX_PERRCODE_E_IL3_LEN (0x20)
-#define CAVM_NIX_RX_PERRCODE_E_IL4_CHK (0x22)
-#define CAVM_NIX_RX_PERRCODE_E_IL4_LEN (0x21)
-#define CAVM_NIX_RX_PERRCODE_E_IL4_PORT (0x23)
-#define CAVM_NIX_RX_PERRCODE_E_MCAST_FAULT (4)
-#define CAVM_NIX_RX_PERRCODE_E_MCAST_POISON (6)
-#define CAVM_NIX_RX_PERRCODE_E_MEMOUT (9)
-#define CAVM_NIX_RX_PERRCODE_E_MIRROR_FAULT (5)
-#define CAVM_NIX_RX_PERRCODE_E_MIRROR_POISON (7)
-#define CAVM_NIX_RX_PERRCODE_E_NPC_RESULT_ERR (2)
-#define CAVM_NIX_RX_PERRCODE_E_OL3_LEN (0x10)
-#define CAVM_NIX_RX_PERRCODE_E_OL4_CHK (0x12)
-#define CAVM_NIX_RX_PERRCODE_E_OL4_LEN (0x11)
-#define CAVM_NIX_RX_PERRCODE_E_OL4_PORT (0x13)
+#define NIX_RX_PERRCODE_E_BUFS_OFLOW (0xa)
+#define NIX_RX_PERRCODE_E_DATA_FAULT (8)
+#define NIX_RX_PERRCODE_E_IL3_LEN (0x20)
+#define NIX_RX_PERRCODE_E_IL4_CHK (0x22)
+#define NIX_RX_PERRCODE_E_IL4_LEN (0x21)
+#define NIX_RX_PERRCODE_E_IL4_PORT (0x23)
+#define NIX_RX_PERRCODE_E_MCAST_FAULT (4)
+#define NIX_RX_PERRCODE_E_MCAST_POISON (6)
+#define NIX_RX_PERRCODE_E_MEMOUT (9)
+#define NIX_RX_PERRCODE_E_MIRROR_FAULT (5)
+#define NIX_RX_PERRCODE_E_MIRROR_POISON (7)
+#define NIX_RX_PERRCODE_E_NPC_RESULT_ERR (2)
+#define NIX_RX_PERRCODE_E_OL3_LEN (0x10)
+#define NIX_RX_PERRCODE_E_OL4_CHK (0x12)
+#define NIX_RX_PERRCODE_E_OL4_LEN (0x11)
+#define NIX_RX_PERRCODE_E_OL4_PORT (0x13)
 
 /**
  * Enumeration nix_send_status_e
@@ -314,31 +327,31 @@
  * NIX Send Completion Status Enumeration Enumerates values of
  * NIX_SEND_COMP_S[STATUS] and NIX_LF_SEND_ERR_DBG[ERRCODE].
  */
-#define CAVM_NIX_SEND_STATUS_E_DATA_FAULT (0x16)
-#define CAVM_NIX_SEND_STATUS_E_DATA_POISON (0x17)
-#define CAVM_NIX_SEND_STATUS_E_GOOD (0)
-#define CAVM_NIX_SEND_STATUS_E_INVALID_SUBDC (0x14)
-#define CAVM_NIX_SEND_STATUS_E_JUMP_FAULT (7)
-#define CAVM_NIX_SEND_STATUS_E_JUMP_POISON (8)
-#define CAVM_NIX_SEND_STATUS_E_LOCK_VIOL (0x21)
-#define CAVM_NIX_SEND_STATUS_E_NPC_DROP_ACTION (0x20)
-#define CAVM_NIX_SEND_STATUS_E_NPC_MCAST_ABORT (0x24)
-#define CAVM_NIX_SEND_STATUS_E_NPC_MCAST_CHAN_ERR (0x23)
-#define CAVM_NIX_SEND_STATUS_E_NPC_UCAST_CHAN_ERR (0x22)
-#define CAVM_NIX_SEND_STATUS_E_NPC_VTAG_PTR_ERR (0x25)
-#define CAVM_NIX_SEND_STATUS_E_NPC_VTAG_SIZE_ERR (0x26)
-#define CAVM_NIX_SEND_STATUS_E_SEND_CRC_ERR (0x10)
-#define CAVM_NIX_SEND_STATUS_E_SEND_EXT_ERR (6)
-#define CAVM_NIX_SEND_STATUS_E_SEND_HDR_ERR (5)
-#define CAVM_NIX_SEND_STATUS_E_SEND_IMM_ERR (0x11)
-#define CAVM_NIX_SEND_STATUS_E_SEND_MEM_ERR (0x13)
-#define CAVM_NIX_SEND_STATUS_E_SEND_MEM_FAULT (0x27)
-#define CAVM_NIX_SEND_STATUS_E_SEND_SG_ERR (0x12)
-#define CAVM_NIX_SEND_STATUS_E_SQB_FAULT (3)
-#define CAVM_NIX_SEND_STATUS_E_SQB_POISON (4)
-#define CAVM_NIX_SEND_STATUS_E_SQ_CTX_FAULT (1)
-#define CAVM_NIX_SEND_STATUS_E_SQ_CTX_POISON (2)
-#define CAVM_NIX_SEND_STATUS_E_SUBDC_ORDER_ERR (0x15)
+#define NIX_SEND_STATUS_E_DATA_FAULT (0x16)
+#define NIX_SEND_STATUS_E_DATA_POISON (0x17)
+#define NIX_SEND_STATUS_E_GOOD (0)
+#define NIX_SEND_STATUS_E_INVALID_SUBDC (0x14)
+#define NIX_SEND_STATUS_E_JUMP_FAULT (7)
+#define NIX_SEND_STATUS_E_JUMP_POISON (8)
+#define NIX_SEND_STATUS_E_LOCK_VIOL (0x21)
+#define NIX_SEND_STATUS_E_NPC_DROP_ACTION (0x20)
+#define NIX_SEND_STATUS_E_NPC_MCAST_ABORT (0x24)
+#define NIX_SEND_STATUS_E_NPC_MCAST_CHAN_ERR (0x23)
+#define NIX_SEND_STATUS_E_NPC_UCAST_CHAN_ERR (0x22)
+#define NIX_SEND_STATUS_E_NPC_VTAG_PTR_ERR (0x25)
+#define NIX_SEND_STATUS_E_NPC_VTAG_SIZE_ERR (0x26)
+#define NIX_SEND_STATUS_E_SEND_CRC_ERR (0x10)
+#define NIX_SEND_STATUS_E_SEND_EXT_ERR (6)
+#define NIX_SEND_STATUS_E_SEND_HDR_ERR (5)
+#define NIX_SEND_STATUS_E_SEND_IMM_ERR (0x11)
+#define NIX_SEND_STATUS_E_SEND_MEM_ERR (0x13)
+#define NIX_SEND_STATUS_E_SEND_MEM_FAULT (0x27)
+#define NIX_SEND_STATUS_E_SEND_SG_ERR (0x12)
+#define NIX_SEND_STATUS_E_SQB_FAULT (3)
+#define NIX_SEND_STATUS_E_SQB_POISON (4)
+#define NIX_SEND_STATUS_E_SQ_CTX_FAULT (1)
+#define NIX_SEND_STATUS_E_SQ_CTX_POISON (2)
+#define NIX_SEND_STATUS_E_SUBDC_ORDER_ERR (0x15)
 
 /**
  * Enumeration nix_sendcrcalg_e
@@ -346,9 +359,9 @@
  * NIX Send CRC Algorithm Enumeration Enumerates the CRC algorithm used,
  * see NIX_SEND_CRC_S[ALG].
  */
-#define CAVM_NIX_SENDCRCALG_E_CRC32 (0)
-#define CAVM_NIX_SENDCRCALG_E_CRC32C (1)
-#define CAVM_NIX_SENDCRCALG_E_ONES16 (2)
+#define NIX_SENDCRCALG_E_CRC32 (0)
+#define NIX_SENDCRCALG_E_CRC32C (1)
+#define NIX_SENDCRCALG_E_ONES16 (2)
 
 /**
  * Enumeration nix_sendl3type_e
@@ -360,10 +373,10 @@
  * 56)  PKT_TX_OUTER_IP_CKSUM(1ULL \<\< 58) PKT_TX_OUTER_IPV4    (1ULL
  * \<\< 59) PKT_TX_OUTER_IPV6    (1ULL \<\< 60) \</pre\>
  */
-#define CAVM_NIX_SENDL3TYPE_E_IP4 (2)
-#define CAVM_NIX_SENDL3TYPE_E_IP4_CKSUM (3)
-#define CAVM_NIX_SENDL3TYPE_E_IP6 (4)
-#define CAVM_NIX_SENDL3TYPE_E_NONE (0)
+#define NIX_SENDL3TYPE_E_IP4 (2)
+#define NIX_SENDL3TYPE_E_IP4_CKSUM (3)
+#define NIX_SENDL3TYPE_E_IP6 (4)
+#define NIX_SENDL3TYPE_E_NONE (0)
 
 /**
  * Enumeration nix_sendl4type_e
@@ -376,10 +389,10 @@
  * 52)  // SCTP cksum of TX pkt. computed by nic. PKT_TX_UDP_CKSUM
  * (3ULL \<\< 52)  // UDP cksum of TX pkt. computed by nic. \</pre\>
  */
-#define CAVM_NIX_SENDL4TYPE_E_NONE (0)
-#define CAVM_NIX_SENDL4TYPE_E_SCTP_CKSUM (2)
-#define CAVM_NIX_SENDL4TYPE_E_TCP_CKSUM (1)
-#define CAVM_NIX_SENDL4TYPE_E_UDP_CKSUM (3)
+#define NIX_SENDL4TYPE_E_NONE (0)
+#define NIX_SENDL4TYPE_E_SCTP_CKSUM (2)
+#define NIX_SENDL4TYPE_E_TCP_CKSUM (1)
+#define NIX_SENDL4TYPE_E_UDP_CKSUM (3)
 
 /**
  * Enumeration nix_sendldtype_e
@@ -389,9 +402,9 @@
  * NIX_SEND_JUMP_S[LD_TYPE].  Internal: The hardware implementation
  * treats undefined encodings as LDD load type.
  */
-#define CAVM_NIX_SENDLDTYPE_E_LDD (0)
-#define CAVM_NIX_SENDLDTYPE_E_LDT (1)
-#define CAVM_NIX_SENDLDTYPE_E_LDWB (2)
+#define NIX_SENDLDTYPE_E_LDD (0)
+#define NIX_SENDLDTYPE_E_LDT (1)
+#define NIX_SENDLDTYPE_E_LDWB (2)
 
 /**
  * Enumeration nix_sendmemalg_e
@@ -401,15 +414,15 @@
  * is the number of gather buffers freed to NPA for the send descriptor.
  * See NIX_SEND_HDR_S[DF] and NIX_SEND_SG_S[I*].
  */
-#define CAVM_NIX_SENDMEMALG_E_ADD (8)
-#define CAVM_NIX_SENDMEMALG_E_ADDLEN (0xa)
-#define CAVM_NIX_SENDMEMALG_E_ADDMBUF (0xc)
-#define CAVM_NIX_SENDMEMALG_E_SET (0)
-#define CAVM_NIX_SENDMEMALG_E_SETRSLT (2)
-#define CAVM_NIX_SENDMEMALG_E_SETTSTMP (1)
-#define CAVM_NIX_SENDMEMALG_E_SUB (9)
-#define CAVM_NIX_SENDMEMALG_E_SUBLEN (0xb)
-#define CAVM_NIX_SENDMEMALG_E_SUBMBUF (0xd)
+#define NIX_SENDMEMALG_E_ADD (8)
+#define NIX_SENDMEMALG_E_ADDLEN (0xa)
+#define NIX_SENDMEMALG_E_ADDMBUF (0xc)
+#define NIX_SENDMEMALG_E_SET (0)
+#define NIX_SENDMEMALG_E_SETRSLT (2)
+#define NIX_SENDMEMALG_E_SETTSTMP (1)
+#define NIX_SENDMEMALG_E_SUB (9)
+#define NIX_SENDMEMALG_E_SUBLEN (0xb)
+#define NIX_SENDMEMALG_E_SUBMBUF (0xd)
 
 /**
  * Enumeration nix_sendmemdsz_e
@@ -417,10 +430,10 @@
  * NIX Memory Data Size Enumeration Enumerates the datum size for
  * modifying memory; see NIX_SEND_MEM_S[DSZ].
  */
-#define CAVM_NIX_SENDMEMDSZ_E_B16 (2)
-#define CAVM_NIX_SENDMEMDSZ_E_B32 (1)
-#define CAVM_NIX_SENDMEMDSZ_E_B64 (0)
-#define CAVM_NIX_SENDMEMDSZ_E_B8 (3)
+#define NIX_SENDMEMDSZ_E_B16 (2)
+#define NIX_SENDMEMDSZ_E_B32 (1)
+#define NIX_SENDMEMDSZ_E_B64 (0)
+#define NIX_SENDMEMDSZ_E_B8 (3)
 
 /**
  * Enumeration nix_sqint_e
@@ -428,10 +441,10 @@
  * NIX Send Queue Interrupt Enumeration Enumerates the bit index of
  * NIX_SQ_CTX_S[SQ_INT,SQ_INT_ENA].
  */
-#define CAVM_NIX_SQINT_E_LMT_ERR (0)
-#define CAVM_NIX_SQINT_E_MNQ_ERR (1)
-#define CAVM_NIX_SQINT_E_SEND_ERR (2)
-#define CAVM_NIX_SQINT_E_SQB_ALLOC_FAIL (3)
+#define NIX_SQINT_E_LMT_ERR (0)
+#define NIX_SQINT_E_MNQ_ERR (1)
+#define NIX_SQINT_E_SEND_ERR (2)
+#define NIX_SQINT_E_SQB_ALLOC_FAIL (3)
 
 /**
  * Enumeration nix_sqoperr_e
@@ -439,15 +452,15 @@
  * NIX SQ Operation Error Enumeration Enumerates
  * NIX_LF_SQ_OP_ERR_DBG[ERRCODE] values.
  */
-#define CAVM_NIX_SQOPERR_E_MAX_SQE_SIZE_ERR (4)
-#define CAVM_NIX_SQOPERR_E_SQB_FAULT (7)
-#define CAVM_NIX_SQOPERR_E_SQB_NULL (6)
-#define CAVM_NIX_SQOPERR_E_SQE_OFLOW (5)
-#define CAVM_NIX_SQOPERR_E_SQE_SIZEM1_ZERO (8)
-#define CAVM_NIX_SQOPERR_E_SQ_CTX_FAULT (1)
-#define CAVM_NIX_SQOPERR_E_SQ_CTX_POISON (2)
-#define CAVM_NIX_SQOPERR_E_SQ_DISABLED (3)
-#define CAVM_NIX_SQOPERR_E_SQ_OOR (0)
+#define NIX_SQOPERR_E_MAX_SQE_SIZE_ERR (4)
+#define NIX_SQOPERR_E_SQB_FAULT (7)
+#define NIX_SQOPERR_E_SQB_NULL (6)
+#define NIX_SQOPERR_E_SQE_OFLOW (5)
+#define NIX_SQOPERR_E_SQE_SIZEM1_ZERO (8)
+#define NIX_SQOPERR_E_SQ_CTX_FAULT (1)
+#define NIX_SQOPERR_E_SQ_CTX_POISON (2)
+#define NIX_SQOPERR_E_SQ_DISABLED (3)
+#define NIX_SQOPERR_E_SQ_OOR (0)
 
 /**
  * Enumeration nix_stat_lf_rx_e
@@ -455,18 +468,18 @@
  * NIX Local Function Receive Statistics Enumeration Enumerates the last
  * index of NIX_AF_LF()_RX_STAT() and NIX_LF_RX_STAT().
  */
-#define CAVM_NIX_STAT_LF_RX_E_RX_BCAST (2)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DROP (4)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DROP_OCTS (5)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_BCAST (8)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_L3BCAST (0xa)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_L3MCAST (0xb)
-#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_MCAST (9)
-#define CAVM_NIX_STAT_LF_RX_E_RX_ERR (7)
-#define CAVM_NIX_STAT_LF_RX_E_RX_FCS (6)
-#define CAVM_NIX_STAT_LF_RX_E_RX_MCAST (3)
-#define CAVM_NIX_STAT_LF_RX_E_RX_OCTS (0)
-#define CAVM_NIX_STAT_LF_RX_E_RX_UCAST (1)
+#define NIX_STAT_LF_RX_E_RX_BCAST (2)
+#define NIX_STAT_LF_RX_E_RX_DROP (4)
+#define NIX_STAT_LF_RX_E_RX_DROP_OCTS (5)
+#define NIX_STAT_LF_RX_E_RX_DRP_BCAST (8)
+#define NIX_STAT_LF_RX_E_RX_DRP_L3BCAST (0xa)
+#define NIX_STAT_LF_RX_E_RX_DRP_L3MCAST (0xb)
+#define NIX_STAT_LF_RX_E_RX_DRP_MCAST (9)
+#define NIX_STAT_LF_RX_E_RX_ERR (7)
+#define NIX_STAT_LF_RX_E_RX_FCS (6)
+#define NIX_STAT_LF_RX_E_RX_MCAST (3)
+#define NIX_STAT_LF_RX_E_RX_OCTS (0)
+#define NIX_STAT_LF_RX_E_RX_UCAST (1)
 
 /**
  * Enumeration nix_stat_lf_tx_e
@@ -476,11 +489,11 @@
  * do not account for packet replication due to NIX_TX_ACTION_S[OP] =
  * NIX_TX_ACTIONOP_E::MCAST.
  */
-#define CAVM_NIX_STAT_LF_TX_E_TX_BCAST (1)
-#define CAVM_NIX_STAT_LF_TX_E_TX_DROP (3)
-#define CAVM_NIX_STAT_LF_TX_E_TX_MCAST (2)
-#define CAVM_NIX_STAT_LF_TX_E_TX_OCTS (4)
-#define CAVM_NIX_STAT_LF_TX_E_TX_UCAST (0)
+#define NIX_STAT_LF_TX_E_TX_BCAST (1)
+#define NIX_STAT_LF_TX_E_TX_DROP (3)
+#define NIX_STAT_LF_TX_E_TX_MCAST (2)
+#define NIX_STAT_LF_TX_E_TX_OCTS (4)
+#define NIX_STAT_LF_TX_E_TX_UCAST (0)
 
 /**
  * Enumeration nix_stype_e
@@ -488,9 +501,9 @@
  * NIX SQB Caching Type Enumeration Enumerates the values of
  * NIX_SQ_CTX_S[SQE_STYPE].
  */
-#define CAVM_NIX_STYPE_E_STF (0)
-#define CAVM_NIX_STYPE_E_STP (2)
-#define CAVM_NIX_STYPE_E_STT (1)
+#define NIX_STYPE_E_STF (0)
+#define NIX_STYPE_E_STP (2)
+#define NIX_STYPE_E_STT (1)
 
 /**
  * Enumeration nix_subdc_e
@@ -502,15 +515,15 @@
  * position as the first subdescriptor, and NIX_RX_PARSE_S, which is
  * determined by its position as the second subdescriptor.
  */
-#define CAVM_NIX_SUBDC_E_CRC (2)
-#define CAVM_NIX_SUBDC_E_EXT (1)
-#define CAVM_NIX_SUBDC_E_IMM (3)
-#define CAVM_NIX_SUBDC_E_JUMP (6)
-#define CAVM_NIX_SUBDC_E_MEM (5)
-#define CAVM_NIX_SUBDC_E_NOP (0)
-#define CAVM_NIX_SUBDC_E_SG (4)
-#define CAVM_NIX_SUBDC_E_SOD (0xf)
-#define CAVM_NIX_SUBDC_E_WORK (7)
+#define NIX_SUBDC_E_CRC (2)
+#define NIX_SUBDC_E_EXT (1)
+#define NIX_SUBDC_E_IMM (3)
+#define NIX_SUBDC_E_JUMP (6)
+#define NIX_SUBDC_E_MEM (5)
+#define NIX_SUBDC_E_NOP (0)
+#define NIX_SUBDC_E_SG (4)
+#define NIX_SUBDC_E_SOD (0xf)
+#define NIX_SUBDC_E_WORK (7)
 
 /**
  * Enumeration nix_tx_actionop_e
@@ -518,11 +531,11 @@
  * NIX Transmit Action Opcode Enumeration Enumerates the values of
  * NIX_TX_ACTION_S[OP].
  */
-#define CAVM_NIX_TX_ACTIONOP_E_DROP (0)
-#define CAVM_NIX_TX_ACTIONOP_E_DROP_VIOL (5)
-#define CAVM_NIX_TX_ACTIONOP_E_MCAST (3)
-#define CAVM_NIX_TX_ACTIONOP_E_UCAST_CHAN (2)
-#define CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT (1)
+#define NIX_TX_ACTIONOP_E_DROP (0)
+#define NIX_TX_ACTIONOP_E_DROP_VIOL (5)
+#define NIX_TX_ACTIONOP_E_MCAST (3)
+#define NIX_TX_ACTIONOP_E_UCAST_CHAN (2)
+#define NIX_TX_ACTIONOP_E_UCAST_DEFAULT (1)
 
 /**
  * Enumeration nix_tx_vtagop_e
@@ -530,9 +543,9 @@
  * NIX Transmit Vtag Opcode Enumeration Enumerates the values of
  * NIX_TX_VTAG_ACTION_S[VTAG0_OP,VTAG1_OP].
  */
-#define CAVM_NIX_TX_VTAGOP_E_INSERT (1)
-#define CAVM_NIX_TX_VTAGOP_E_NOP (0)
-#define CAVM_NIX_TX_VTAGOP_E_REPLACE (2)
+#define NIX_TX_VTAGOP_E_INSERT (1)
+#define NIX_TX_VTAGOP_E_NOP (0)
+#define NIX_TX_VTAGOP_E_REPLACE (2)
 
 /**
  * Enumeration nix_txlayer_e
@@ -540,10 +553,10 @@
  * NIX Transmit Layer Enumeration Enumerates the values of
  * NIX_AF_LSO_FORMAT()_FIELD()[LAYER].
  */
-#define CAVM_NIX_TXLAYER_E_IL3 (2)
-#define CAVM_NIX_TXLAYER_E_IL4 (3)
-#define CAVM_NIX_TXLAYER_E_OL3 (0)
-#define CAVM_NIX_TXLAYER_E_OL4 (1)
+#define NIX_TXLAYER_E_IL3 (2)
+#define NIX_TXLAYER_E_IL4 (3)
+#define NIX_TXLAYER_E_OL3 (0)
+#define NIX_TXLAYER_E_OL4 (1)
 
 /**
  * Enumeration nix_vtagsize_e
@@ -551,8 +564,8 @@
  * NIX Vtag Size Enumeration Enumerates the values of
  * NIX_AF_TX_VTAG_DEF()_CTL[SIZE] and NIX_AF_LF()_RX_VTAG_TYPE()[SIZE].
  */
-#define CAVM_NIX_VTAGSIZE_E_T4 (0)
-#define CAVM_NIX_VTAGSIZE_E_T8 (1)
+#define NIX_VTAGSIZE_E_T4 (0)
+#define NIX_VTAGSIZE_E_T8 (1)
 
 /**
  * Enumeration nix_xqe_type_e
@@ -560,12 +573,12 @@
  * NIX WQE/CQE Type Enumeration Enumerates the values of
  * NIX_WQE_HDR_S[WQE_TYPE], NIX_CQE_HDR_S[CQE_TYPE].
  */
-#define CAVM_NIX_XQE_TYPE_E_INVALID (0)
-#define CAVM_NIX_XQE_TYPE_E_RX (1)
-#define CAVM_NIX_XQE_TYPE_E_RX_IPSECD (4)
-#define CAVM_NIX_XQE_TYPE_E_RX_IPSECH (3)
-#define CAVM_NIX_XQE_TYPE_E_RX_IPSECS (2)
-#define CAVM_NIX_XQE_TYPE_E_SEND (8)
+#define NIX_XQE_TYPE_E_INVALID (0)
+#define NIX_XQE_TYPE_E_RX (1)
+#define NIX_XQE_TYPE_E_RX_IPSECD (4)
+#define NIX_XQE_TYPE_E_RX_IPSECH (3)
+#define NIX_XQE_TYPE_E_RX_IPSECS (2)
+#define NIX_XQE_TYPE_E_SEND (8)
 
 /**
  * Enumeration nix_xqesz_e
@@ -573,8 +586,8 @@
  * NIX WQE/CQE Size Enumeration Enumerates the values of
  * NIX_AF_LF()_CFG[XQE_SIZE].
  */
-#define CAVM_NIX_XQESZ_E_W16 (1)
-#define CAVM_NIX_XQESZ_E_W64 (0)
+#define NIX_XQESZ_E_W16 (1)
+#define NIX_XQESZ_E_W64 (0)
 
 /**
  * Structure nix_aq_inst_s
@@ -590,9 +603,9 @@
  * [CTYPE] = NIX_AQ_CTYPE_E::MCE: use NIX_AF_RX_MCAST_CFG[CACHING] and
  * NIX_AF_RX_MCAST_CFG[WAY_MASK].
  */
-union cavm_nix_aq_inst_s {
+union nix_aq_inst_s {
 	u64 u[2];
-	struct cavm_nix_aq_inst_s_s {
+	struct nix_aq_inst_s_s {
 		u64 op                               : 4;
 		u64 ctype                            : 4;
 		u64 lf                               : 7;
@@ -602,7 +615,7 @@ union cavm_nix_aq_inst_s {
 		u64 doneint                          : 1;
 		u64 res_addr                         : 64;
 	} s;
-	/* struct cavm_nix_aq_inst_s_s cn; */
+	/* struct nix_aq_inst_s_s cn; */
 };
 
 /**
@@ -619,9 +632,9 @@ union cavm_nix_aq_inst_s {
  * always allocate into LLC. Hardware reads of context data do not
  * allocate into LLC.
  */
-union cavm_nix_aq_res_s {
+union nix_aq_res_s {
 	u64 u[2];
-	struct cavm_nix_aq_res_s_s {
+	struct nix_aq_res_s_s {
 		u64 op                               : 4;
 		u64 ctype                            : 4;
 		u64 compcode                         : 8;
@@ -629,7 +642,7 @@ union cavm_nix_aq_res_s {
 		u64 reserved_17_63                   : 47;
 		u64 reserved_64_127                  : 64;
 	} s;
-	/* struct cavm_nix_aq_res_s_s cn; */
+	/* struct nix_aq_res_s_s cn; */
 };
 
 /**
@@ -643,9 +656,9 @@ union cavm_nix_aq_res_s {
  * starting at AF IOVA NIX_AF_LF()_CINTS_BASE. Always stored in byte
  * invariant little-endian format (LE8).
  */
-union cavm_nix_cint_hw_s {
+union nix_cint_hw_s {
 	u64 u[2];
-	struct cavm_nix_cint_hw_s_s {
+	struct nix_cint_hw_s_s {
 		u64 ecount                           : 32;
 		u64 qcount                           : 16;
 		u64 intr                             : 1;
@@ -657,7 +670,7 @@ union cavm_nix_cint_hw_s {
 		u64 time_wait                        : 8;
 		u64 reserved_120_127                 : 8;
 	} s;
-	/* struct cavm_nix_cint_hw_s_s cn; */
+	/* struct nix_cint_hw_s_s cn; */
 };
 
 /**
@@ -668,9 +681,9 @@ union cavm_nix_cint_hw_s {
  * uses the same structure format to read and write an CQ context with
  * the NIX admin queue.
  */
-union cavm_nix_cq_ctx_s {
+union nix_cq_ctx_s {
 	u64 u[4];
-	struct cavm_nix_cq_ctx_s_s {
+	struct nix_cq_ctx_s_s {
 		u64 base                             : 64;
 		u64 reserved_64_67                   : 4;
 		u64 bp_ena                           : 1;
@@ -698,7 +711,7 @@ union cavm_nix_cq_ctx_s {
 		u64 cq_err_int                       : 8;
 		u64 cq_err_int_ena                   : 8;
 	} s;
-	/* struct cavm_nix_cq_ctx_s_s cn; */
+	/* struct nix_cq_ctx_s_s cn; */
 };
 
 /**
@@ -710,16 +723,16 @@ union cavm_nix_cq_ctx_s {
  * completion CQE. Stored in memory as little-endian unless
  * NIX_AF_LF()_CFG[BE] is set.
  */
-union cavm_nix_cqe_hdr_s {
+union nix_cqe_hdr_s {
 	u64 u;
-	struct cavm_nix_cqe_hdr_s_s {
+	struct nix_cqe_hdr_s_s {
 		u64 tag                              : 32;
 		u64 q                                : 20;
 		u64 reserved_52_57                   : 6;
 		u64 node                             : 2;
 		u64 cqe_type                         : 4;
 	} s;
-	/* struct cavm_nix_cqe_hdr_s_s cn; */
+	/* struct nix_cqe_hdr_s_s cn; */
 };
 
 /**
@@ -729,14 +742,14 @@ union cavm_nix_cqe_hdr_s {
  * instruction header that precedes the packet header supplied to NPC for
  * packets to be transmitted by NIX.
  */
-union cavm_nix_inst_hdr_s {
+union nix_inst_hdr_s {
 	u64 u;
-	struct cavm_nix_inst_hdr_s_s {
+	struct nix_inst_hdr_s_s {
 		u64 pf_func                          : 16;
 		u64 sq                               : 20;
 		u64 reserved_36_63                   : 28;
 	} s;
-	/* struct cavm_nix_inst_hdr_s_s cn; */
+	/* struct nix_inst_hdr_s_s cn; */
 };
 
 /**
@@ -744,12 +757,12 @@ union cavm_nix_inst_hdr_s {
  *
  * NIX I/O Virtual Address Structure
  */
-union cavm_nix_iova_s {
+union nix_iova_s {
 	u64 u;
-	struct cavm_nix_iova_s_s {
+	struct nix_iova_s_s {
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_nix_iova_s_s cn; */
+	/* struct nix_iova_s_s cn; */
 };
 
 /**
@@ -758,12 +771,12 @@ union cavm_nix_iova_s {
  * INTERNAL: NIX IPSEC Dynamic Ordering Counter Structure  Internal: Not
  * used; no IPSEC fast-path.
  */
-union cavm_nix_ipsec_dyno_s {
+union nix_ipsec_dyno_s {
 	u32 u;
-	struct cavm_nix_ipsec_dyno_s_s {
+	struct nix_ipsec_dyno_s_s {
 		u32 count                            : 32;
 	} s;
-	/* struct cavm_nix_ipsec_dyno_s_s cn; */
+	/* struct nix_ipsec_dyno_s_s cn; */
 };
 
 /**
@@ -773,14 +786,14 @@ union cavm_nix_ipsec_dyno_s {
  * NIX_SEND_MEM_S[ALG]=NIX_SENDMEMALG_E::SETRSLT, the value written to
  * memory is formed with this structure.
  */
-union cavm_nix_mem_result_s {
+union nix_mem_result_s {
 	u64 u;
-	struct cavm_nix_mem_result_s_s {
+	struct nix_mem_result_s_s {
 		u64 v                                : 1;
 		u64 color                            : 2;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_nix_mem_result_s_s cn; */
+	/* struct nix_mem_result_s_s cn; */
 };
 
 /**
@@ -790,14 +803,14 @@ union cavm_nix_mem_result_s {
  * the write data format of an atomic 64-bit load-and-add of some
  * NIX_LF_RQ_OP_*, NIX_LF_SQ_OP* and NIX_LF_CQ_OP* registers.
  */
-union cavm_nix_op_q_wdata_s {
+union nix_op_q_wdata_s {
 	u64 u;
-	struct cavm_nix_op_q_wdata_s_s {
+	struct nix_op_q_wdata_s_s {
 		u64 reserved_0_31                    : 32;
 		u64 q                                : 20;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_nix_op_q_wdata_s_s cn; */
+	/* struct nix_op_q_wdata_s_s cn; */
 };
 
 /**
@@ -811,14 +824,14 @@ union cavm_nix_op_q_wdata_s {
  * starting at IOVA NIX_AF_LF()_QINTS_BASE. Always stored in byte
  * invariant little-endian format (LE8).
  */
-union cavm_nix_qint_hw_s {
+union nix_qint_hw_s {
 	u32 u;
-	struct cavm_nix_qint_hw_s_s {
+	struct nix_qint_hw_s_s {
 		u32 count                            : 22;
 		u32 reserved_22_30                   : 9;
 		u32 ena                              : 1;
 	} s;
-	/* struct cavm_nix_qint_hw_s_s cn; */
+	/* struct nix_qint_hw_s_s cn; */
 };
 
 /**
@@ -830,9 +843,9 @@ union cavm_nix_qint_hw_s {
  * RQ context with the NIX admin queue. Always stored in byte invariant
  * little-endian format (LE8).
  */
-union cavm_nix_rq_ctx_hw_s {
+union nix_rq_ctx_hw_s {
 	u64 u[16];
-	struct cavm_nix_rq_ctx_hw_s_s {
+	struct nix_rq_ctx_hw_s_s {
 		u64 ena                              : 1;
 		u64 sso_ena                          : 1;
 		u64 ipsech_ena                       : 1;
@@ -902,7 +915,7 @@ union cavm_nix_rq_ctx_hw_s {
 		u64 reserved_896_959                 : 64;
 		u64 reserved_960_1023                : 64;
 	} s;
-	/* struct cavm_nix_rq_ctx_hw_s_s cn; */
+	/* struct nix_rq_ctx_hw_s_s cn; */
 };
 
 /**
@@ -912,9 +925,9 @@ union cavm_nix_rq_ctx_hw_s {
  * format used by software to read and write an RQ context with the NIX
  * admin queue.
  */
-union cavm_nix_rq_ctx_s {
+union nix_rq_ctx_s {
 	u64 u[16];
-	struct cavm_nix_rq_ctx_s_s {
+	struct nix_rq_ctx_s_s {
 		u64 ena                              : 1;
 		u64 sso_ena                          : 1;
 		u64 ipsech_ena                       : 1;
@@ -983,7 +996,7 @@ union cavm_nix_rq_ctx_s {
 		u64 reserved_896_959                 : 64;
 		u64 reserved_960_1023                : 64;
 	} s;
-	/* struct cavm_nix_rq_ctx_s_s cn; */
+	/* struct nix_rq_ctx_s_s cn; */
 };
 
 /**
@@ -995,13 +1008,13 @@ union cavm_nix_rq_ctx_s {
  * same structure format to read and write an RSS table entry with the
  * NIX admin queue.
  */
-union cavm_nix_rsse_s {
+union nix_rsse_s {
 	u32 u;
-	struct cavm_nix_rsse_s_s {
+	struct nix_rsse_s_s {
 		u32 rq                               : 20;
 		u32 reserved_20_31                   : 12;
 	} s;
-	/* struct cavm_nix_rsse_s_s cn; */
+	/* struct nix_rsse_s_s cn; */
 };
 
 /**
@@ -1010,9 +1023,9 @@ union cavm_nix_rsse_s {
  * NIX Receive Action Structure This structure defines the format of
  * NPC_RESULT_S[ACTION] for a receive packet.
  */
-union cavm_nix_rx_action_s {
+union nix_rx_action_s {
 	u64 u;
-	struct cavm_nix_rx_action_s_s {
+	struct nix_rx_action_s_s {
 		u64 op                               : 4;
 		u64 pf_func                          : 16;
 		u64 index                            : 20;
@@ -1020,7 +1033,7 @@ union cavm_nix_rx_action_s {
 		u64 flow_key_alg                     : 5;
 		u64 reserved_61_63                   : 3;
 	} s;
-	/* struct cavm_nix_rx_action_s_s cn; */
+	/* struct nix_rx_action_s_s cn; */
 };
 
 /**
@@ -1033,15 +1046,15 @@ union cavm_nix_rx_action_s {
  * (when one exists) will follow the immediate bytes, after rounding up
  * the address to a multiple of 16 bytes.
  */
-union cavm_nix_rx_imm_s {
+union nix_rx_imm_s {
 	u64 u;
-	struct cavm_nix_rx_imm_s_s {
+	struct nix_rx_imm_s_s {
 		u64 size                             : 16;
 		u64 apad                             : 3;
 		u64 reserved_19_59                   : 41;
 		u64 subdc                            : 4;
 	} s;
-	/* struct cavm_nix_rx_imm_s_s cn; */
+	/* struct nix_rx_imm_s_s cn; */
 };
 
 /**
@@ -1055,9 +1068,9 @@ union cavm_nix_rx_imm_s {
  * read and write a multicast/mirror table entry with the NIX admin
  * queue.
  */
-union cavm_nix_rx_mce_s {
+union nix_rx_mce_s {
 	u64 u;
-	struct cavm_nix_rx_mce_s_s {
+	struct nix_rx_mce_s_s {
 		u64 op                               : 2;
 		u64 reserved_2                       : 1;
 		u64 eol                              : 1;
@@ -1066,7 +1079,7 @@ union cavm_nix_rx_mce_s {
 		u64 pf_func                          : 16;
 		u64 next                             : 16;
 	} s;
-	/* struct cavm_nix_rx_mce_s_s cn; */
+	/* struct nix_rx_mce_s_s cn; */
 };
 
 /**
@@ -1079,9 +1092,9 @@ union cavm_nix_rx_mce_s {
  * aligned, so all header pointers in this structure ([EOH_PTR], [LAPTR]
  * through [LHPTR], [VTAG*_PTR]) are even.
  */
-union cavm_nix_rx_parse_s {
+union nix_rx_parse_s {
 	u64 u[7];
-	struct cavm_nix_rx_parse_s_s {
+	struct nix_rx_parse_s_s {
 		u64 chan                             : 12;
 		u64 desc_sizem1                      : 5;
 		u64 imm_copy                         : 1;
@@ -1107,7 +1120,7 @@ union cavm_nix_rx_parse_s {
 		u64 vtag1_valid                      : 1;
 		u64 vtag1_gone                       : 1;
 		u64 pkind                            : 6;
-		u64 reserved_94_95                   : 2;
+		u64 nix_idx                          : 2;
 		u64 vtag0_tci                        : 16;
 		u64 vtag1_tci                        : 16;
 		u64 laflags                          : 8;
@@ -1136,7 +1149,64 @@ union cavm_nix_rx_parse_s {
 		u64 reserved_341_383                 : 43;
 		u64 reserved_384_447                 : 64;
 	} s;
-	/* struct cavm_nix_rx_parse_s_s cn; */
+	struct nix_rx_parse_s_cn96xx {
+		u64 chan                             : 12;
+		u64 desc_sizem1                      : 5;
+		u64 imm_copy                         : 1;
+		u64 express                          : 1;
+		u64 wqwd                             : 1;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 latype                           : 4;
+		u64 lbtype                           : 4;
+		u64 lctype                           : 4;
+		u64 ldtype                           : 4;
+		u64 letype                           : 4;
+		u64 lftype                           : 4;
+		u64 lgtype                           : 4;
+		u64 lhtype                           : 4;
+		u64 pkt_lenm1                        : 16;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 vtag0_valid                      : 1;
+		u64 vtag0_gone                       : 1;
+		u64 vtag1_valid                      : 1;
+		u64 vtag1_gone                       : 1;
+		u64 pkind                            : 6;
+		u64 reserved_94_95                   : 2;
+		u64 vtag0_tci                        : 16;
+		u64 vtag1_tci                        : 16;
+		u64 laflags                          : 8;
+		u64 lbflags                          : 8;
+		u64 lcflags                          : 8;
+		u64 ldflags                          : 8;
+		u64 leflags                          : 8;
+		u64 lfflags                          : 8;
+		u64 lgflags                          : 8;
+		u64 lhflags                          : 8;
+		u64 eoh_ptr                          : 8;
+		u64 wqe_aura                         : 20;
+		u64 pb_aura                          : 20;
+		u64 match_id                         : 16;
+		u64 laptr                            : 8;
+		u64 lbptr                            : 8;
+		u64 lcptr                            : 8;
+		u64 ldptr                            : 8;
+		u64 leptr                            : 8;
+		u64 lfptr                            : 8;
+		u64 lgptr                            : 8;
+		u64 lhptr                            : 8;
+		u64 vtag0_ptr                        : 8;
+		u64 vtag1_ptr                        : 8;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_341_383                 : 43;
+		u64 reserved_384_447                 : 64;
+	} cn96xx;
+	/* struct nix_rx_parse_s_s cn98xx; */
+	/* struct nix_rx_parse_s_cn96xx cnf95xx; */
+	/* struct nix_rx_parse_s_cn96xx loki; */
 };
 
 /**
@@ -1152,9 +1222,9 @@ union cavm_nix_rx_parse_s {
  * word for segment 2, third word for segment 3. Note the third word is
  * present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
  */
-union cavm_nix_rx_sg_s {
+union nix_rx_sg_s {
 	u64 u;
-	struct cavm_nix_rx_sg_s_s {
+	struct nix_rx_sg_s_s {
 		u64 seg1_size                        : 16;
 		u64 seg2_size                        : 16;
 		u64 seg3_size                        : 16;
@@ -1162,7 +1232,7 @@ union cavm_nix_rx_sg_s {
 		u64 reserved_50_59                   : 10;
 		u64 subdc                            : 4;
 	} s;
-	/* struct cavm_nix_rx_sg_s_s cn; */
+	/* struct nix_rx_sg_s_s cn; */
 };
 
 /**
@@ -1173,9 +1243,9 @@ union cavm_nix_rx_sg_s {
  * Vtags (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG) for optional capture
  * and/or stripping.
  */
-union cavm_nix_rx_vtag_action_s {
+union nix_rx_vtag_action_s {
 	u64 u;
-	struct cavm_nix_rx_vtag_action_s_s {
+	struct nix_rx_vtag_action_s_s {
 		u64 vtag0_relptr                     : 8;
 		u64 vtag0_lid                        : 3;
 		u64 reserved_11                      : 1;
@@ -1189,7 +1259,7 @@ union cavm_nix_rx_vtag_action_s {
 		u64 vtag1_valid                      : 1;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nix_rx_vtag_action_s_s cn; */
+	/* struct nix_rx_vtag_action_s_s cn; */
 };
 
 /**
@@ -1198,14 +1268,14 @@ union cavm_nix_rx_vtag_action_s {
  * NIX Send Completion Structure This structure immediately follows
  * NIX_CQE_HDR_S in a send completion CQE.
  */
-union cavm_nix_send_comp_s {
+union nix_send_comp_s {
 	u64 u;
-	struct cavm_nix_send_comp_s_s {
+	struct nix_send_comp_s_s {
 		u64 status                           : 8;
 		u64 sqe_id                           : 16;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nix_send_comp_s_s cn; */
+	/* struct nix_send_comp_s_s cn; */
 };
 
 /**
@@ -1235,9 +1305,9 @@ union cavm_nix_send_comp_s {
  * [SIZE] and [INSERT] as needed to account for any VLAN inserted by
  * NIX_SEND_EXT_S[VLAN*] or Vtag inserted by NIX_TX_VTAG_ACTION_S.
  */
-union cavm_nix_send_crc_s {
+union nix_send_crc_s {
 	u64 u[2];
-	struct cavm_nix_send_crc_s_s {
+	struct nix_send_crc_s_s {
 		u64 size                             : 16;
 		u64 start                            : 16;
 		u64 insert                           : 16;
@@ -1247,7 +1317,7 @@ union cavm_nix_send_crc_s {
 		u64 iv                               : 32;
 		u64 reserved_96_127                  : 32;
 	} s;
-	/* struct cavm_nix_send_crc_s_s cn; */
+	/* struct nix_send_crc_s_s cn; */
 };
 
 /**
@@ -1259,9 +1329,9 @@ union cavm_nix_send_crc_s {
  * NIX_SEND_HDR_S. All fields are assumed to be zero when this
  * subdescriptor is not present.
  */
-union cavm_nix_send_ext_s {
+union nix_send_ext_s {
 	u64 u[2];
-	struct cavm_nix_send_ext_s_s {
+	struct nix_send_ext_s_s {
 		u64 lso_mps                          : 14;
 		u64 lso                              : 1;
 		u64 tstmp                            : 1;
@@ -1283,7 +1353,7 @@ union cavm_nix_send_ext_s {
 		u64 vlan1_ins_ena                    : 1;
 		u64 reserved_114_127                 : 14;
 	} s;
-	/* struct cavm_nix_send_ext_s_s cn; */
+	/* struct nix_send_ext_s_s cn; */
 };
 
 /**
@@ -1292,9 +1362,9 @@ union cavm_nix_send_ext_s {
  * NIX Send Header Subdescriptor Structure The send header is the first
  * subdescriptor of every send descriptor.
  */
-union cavm_nix_send_hdr_s {
+union nix_send_hdr_s {
 	u64 u[2];
-	struct cavm_nix_send_hdr_s_s {
+	struct nix_send_hdr_s_s {
 		u64 total                            : 18;
 		u64 reserved_18                      : 1;
 		u64 df                               : 1;
@@ -1312,7 +1382,7 @@ union cavm_nix_send_hdr_s {
 		u64 il4type                          : 4;
 		u64 sqe_id                           : 16;
 	} s;
-	/* struct cavm_nix_send_hdr_s_s cn; */
+	/* struct nix_send_hdr_s_s cn; */
 };
 
 /**
@@ -1331,15 +1401,15 @@ union cavm_nix_send_hdr_s {
  * descriptor, all NIX_SEND_IMM_S bytes must be included in the first
  * NIX_SEND_EXT_S[LSO_SB] bytes of the source packet.
  */
-union cavm_nix_send_imm_s {
+union nix_send_imm_s {
 	u64 u;
-	struct cavm_nix_send_imm_s_s {
+	struct nix_send_imm_s_s {
 		u64 size                             : 16;
 		u64 apad                             : 3;
 		u64 reserved_19_59                   : 41;
 		u64 subdc                            : 4;
 	} s;
-	/* struct cavm_nix_send_imm_s_s cn; */
+	/* struct nix_send_imm_s_s cn; */
 };
 
 /**
@@ -1354,9 +1424,9 @@ union cavm_nix_send_imm_s {
  * is not present, else it must immediately follow NIX_SEND_EXT_S. In
  * either case, it must terminate the SQE enqueued by software.
  */
-union cavm_nix_send_jump_s {
+union nix_send_jump_s {
 	u64 u[2];
-	struct cavm_nix_send_jump_s_s {
+	struct nix_send_jump_s_s {
 		u64 sizem1                           : 7;
 		u64 reserved_7_13                    : 7;
 		u64 ld_type                          : 2;
@@ -1366,7 +1436,7 @@ union cavm_nix_send_jump_s {
 		u64 subdc                            : 4;
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_nix_send_jump_s_s cn; */
+	/* struct nix_send_jump_s_s cn; */
 };
 
 /**
@@ -1386,9 +1456,9 @@ union cavm_nix_send_jump_s {
  * set in the descriptor, NIX executes the memory update only while
  * processing the last LSO segment, after processing prior segments.
  */
-union cavm_nix_send_mem_s {
+union nix_send_mem_s {
 	u64 u[2];
-	struct cavm_nix_send_mem_s_s {
+	struct nix_send_mem_s_s {
 		u64 offset                           : 16;
 		u64 reserved_16_52                   : 37;
 		u64 wmem                             : 1;
@@ -1397,7 +1467,7 @@ union cavm_nix_send_mem_s {
 		u64 subdc                            : 4;
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_nix_send_mem_s_s cn; */
+	/* struct nix_send_mem_s_s cn; */
 };
 
 /**
@@ -1417,9 +1487,9 @@ union cavm_nix_send_mem_s {
  * subdescriptor will not contribute any packet data but may free buffers
  * to NPA (see [I1]).
  */
-union cavm_nix_send_sg_s {
+union nix_send_sg_s {
 	u64 u;
-	struct cavm_nix_send_sg_s_s {
+	struct nix_send_sg_s_s {
 		u64 seg1_size                        : 16;
 		u64 seg2_size                        : 16;
 		u64 seg3_size                        : 16;
@@ -1431,7 +1501,7 @@ union cavm_nix_send_sg_s {
 		u64 ld_type                          : 2;
 		u64 subdc                            : 4;
 	} s;
-	/* struct cavm_nix_send_sg_s_s cn; */
+	/* struct nix_send_sg_s_s cn; */
 };
 
 /**
@@ -1458,9 +1528,9 @@ union cavm_nix_send_sg_s {
  * after processing prior segments.  Hardware ignores NIX_SEND_WORK_S
  * when NIX_SQ_CTX_S[SSO_ENA] is clear.
  */
-union cavm_nix_send_work_s {
+union nix_send_work_s {
 	u64 u[2];
-	struct cavm_nix_send_work_s_s {
+	struct nix_send_work_s_s {
 		u64 tag                              : 32;
 		u64 tt                               : 2;
 		u64 grp                              : 10;
@@ -1468,7 +1538,7 @@ union cavm_nix_send_work_s {
 		u64 subdc                            : 4;
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_nix_send_work_s_s cn; */
+	/* struct nix_send_work_s_s cn; */
 };
 
 /**
@@ -1480,9 +1550,9 @@ union cavm_nix_send_work_s {
  * SQ context with the NIX admin queue. Always stored in byte invariant
  * little-endian format (LE8).
  */
-union cavm_nix_sq_ctx_hw_s {
+union nix_sq_ctx_hw_s {
 	u64 u[16];
-	struct cavm_nix_sq_ctx_hw_s_s {
+	struct nix_sq_ctx_hw_s_s {
 		u64 ena                              : 1;
 		u64 substream                        : 20;
 		u64 max_sqe_size                     : 2;
@@ -1543,7 +1613,7 @@ union cavm_nix_sq_ctx_hw_s {
 		u64 pkts_msw                         : 16;
 		u64 octs                             : 48;
 	} s;
-	/* struct cavm_nix_sq_ctx_hw_s_s cn; */
+	/* struct nix_sq_ctx_hw_s_s cn; */
 };
 
 /**
@@ -1556,9 +1626,9 @@ union cavm_nix_sq_ctx_hw_s {
  * [DROP_PKTS]) do not account for packet replication due to
  * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
  */
-union cavm_nix_sq_ctx_s {
+union nix_sq_ctx_s {
 	u64 u[16];
-	struct cavm_nix_sq_ctx_s_s {
+	struct nix_sq_ctx_s_s {
 		u64 ena                              : 1;
 		u64 qint_idx                         : 6;
 		u64 substream                        : 20;
@@ -1617,7 +1687,7 @@ union cavm_nix_sq_ctx_s {
 		u64 drop_pkts                        : 48;
 		u64 reserved_1008_1023               : 16;
 	} s;
-	/* struct cavm_nix_sq_ctx_s_s cn; */
+	/* struct nix_sq_ctx_s_s cn; */
 };
 
 /**
@@ -1626,16 +1696,16 @@ union cavm_nix_sq_ctx_s {
  * NIX Transmit Action Structure This structure defines the format of
  * NPC_RESULT_S[ACTION] for a transmit packet.
  */
-union cavm_nix_tx_action_s {
+union nix_tx_action_s {
 	u64 u;
-	struct cavm_nix_tx_action_s_s {
+	struct nix_tx_action_s_s {
 		u64 op                               : 4;
 		u64 reserved_4_11                    : 8;
 		u64 index                            : 20;
 		u64 match_id                         : 16;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nix_tx_action_s_s cn; */
+	/* struct nix_tx_action_s_s cn; */
 };
 
 /**
@@ -1654,9 +1724,9 @@ union cavm_nix_tx_action_s {
  * or replaced within an outer or inner L3/L4 header, but may be inserted
  * or replaced within an outer L4 payload.
  */
-union cavm_nix_tx_vtag_action_s {
+union nix_tx_vtag_action_s {
 	u64 u;
-	struct cavm_nix_tx_vtag_action_s_s {
+	struct nix_tx_vtag_action_s_s {
 		u64 vtag0_relptr                     : 8;
 		u64 vtag0_lid                        : 3;
 		u64 reserved_11                      : 1;
@@ -1672,7 +1742,7 @@ union cavm_nix_tx_vtag_action_s {
 		u64 vtag1_def                        : 10;
 		u64 reserved_58_63                   : 6;
 	} s;
-	/* struct cavm_nix_tx_vtag_action_s_s cn; */
+	/* struct nix_tx_vtag_action_s_s cn; */
 };
 
 /**
@@ -1683,9 +1753,9 @@ union cavm_nix_tx_vtag_action_s {
  * immediately followed by NIX_RX_PARSE_S. Stored in memory as little-
  * endian unless NIX_AF_LF()_CFG[BE] is set.
  */
-union cavm_nix_wqe_hdr_s {
+union nix_wqe_hdr_s {
 	u64 u;
-	struct cavm_nix_wqe_hdr_s_s {
+	struct nix_wqe_hdr_s_s {
 		u64 tag                              : 32;
 		u64 tt                               : 2;
 		u64 grp                              : 10;
@@ -1693,7 +1763,7 @@ union cavm_nix_wqe_hdr_s {
 		u64 q                                : 14;
 		u64 wqe_type                         : 4;
 	} s;
-	/* struct cavm_nix_wqe_hdr_s_s cn; */
+	/* struct nix_wqe_hdr_s_s cn; */
 };
 
 /**
@@ -1701,19 +1771,19 @@ union cavm_nix_wqe_hdr_s {
  *
  * NIX AF Admin Queue Base Address Register
  */
-union cavm_nixx_af_aq_base {
+union nixx_af_aq_base {
 	u64 u;
-	struct cavm_nixx_af_aq_base_s {
+	struct nixx_af_aq_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 base_addr                        : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_aq_base_s cn; */
+	/* struct nixx_af_aq_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_BASE(void)
+static inline u64 NIXX_AF_AQ_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_BASE(void)
+static inline u64 NIXX_AF_AQ_BASE(void)
 {
 	return 0x410;
 }
@@ -1723,18 +1793,18 @@ static inline u64 CAVM_NIXX_AF_AQ_BASE(void)
  *
  * NIX AF Admin Queue Configuration Register
  */
-union cavm_nixx_af_aq_cfg {
+union nixx_af_aq_cfg {
 	u64 u;
-	struct cavm_nixx_af_aq_cfg_s {
+	struct nixx_af_aq_cfg_s {
 		u64 qsize                            : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_aq_cfg_s cn; */
+	/* struct nixx_af_aq_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_CFG(void)
+static inline u64 NIXX_AF_AQ_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_CFG(void)
+static inline u64 NIXX_AF_AQ_CFG(void)
 {
 	return 0x400;
 }
@@ -1744,18 +1814,18 @@ static inline u64 CAVM_NIXX_AF_AQ_CFG(void)
  *
  * NIX AF Admin Queue Done Count Register
  */
-union cavm_nixx_af_aq_done {
+union nixx_af_aq_done {
 	u64 u;
-	struct cavm_nixx_af_aq_done_s {
+	struct nixx_af_aq_done_s {
 		u64 done                             : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_nixx_af_aq_done_s cn; */
+	/* struct nixx_af_aq_done_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
+static inline u64 NIXX_AF_AQ_DONE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
+static inline u64 NIXX_AF_AQ_DONE(void)
 {
 	return 0x450;
 }
@@ -1766,18 +1836,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
  * NIX AF Admin Queue Done Count Ack Register This register is written by
  * software to acknowledge interrupts.
  */
-union cavm_nixx_af_aq_done_ack {
+union nixx_af_aq_done_ack {
 	u64 u;
-	struct cavm_nixx_af_aq_done_ack_s {
+	struct nixx_af_aq_done_ack_s {
 		u64 done_ack                         : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_nixx_af_aq_done_ack_s cn; */
+	/* struct nixx_af_aq_done_ack_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ACK(void)
+static inline u64 NIXX_AF_AQ_DONE_ACK(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ACK(void)
+static inline u64 NIXX_AF_AQ_DONE_ACK(void)
 {
 	return 0x460;
 }
@@ -1787,18 +1857,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_ACK(void)
  *
  * NIX AF Admin Queue Done Interrupt Enable Clear Register
  */
-union cavm_nixx_af_aq_done_ena_w1c {
+union nixx_af_aq_done_ena_w1c {
 	u64 u;
-	struct cavm_nixx_af_aq_done_ena_w1c_s {
+	struct nixx_af_aq_done_ena_w1c_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_aq_done_ena_w1c_s cn; */
+	/* struct nixx_af_aq_done_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1C(void)
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1C(void)
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1C(void)
 {
 	return 0x498;
 }
@@ -1808,18 +1878,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1C(void)
  *
  * NIX AF Admin Queue Done Interrupt Enable Set Register
  */
-union cavm_nixx_af_aq_done_ena_w1s {
+union nixx_af_aq_done_ena_w1s {
 	u64 u;
-	struct cavm_nixx_af_aq_done_ena_w1s_s {
+	struct nixx_af_aq_done_ena_w1s_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_aq_done_ena_w1s_s cn; */
+	/* struct nixx_af_aq_done_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1S(void)
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1S(void)
+static inline u64 NIXX_AF_AQ_DONE_ENA_W1S(void)
 {
 	return 0x490;
 }
@@ -1829,18 +1899,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1S(void)
  *
  * INTERNAL: NIX AF Admin Queue Done Interrupt Register
  */
-union cavm_nixx_af_aq_done_int {
+union nixx_af_aq_done_int {
 	u64 u;
-	struct cavm_nixx_af_aq_done_int_s {
+	struct nixx_af_aq_done_int_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_aq_done_int_s cn; */
+	/* struct nixx_af_aq_done_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_INT(void)
+static inline u64 NIXX_AF_AQ_DONE_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_INT(void)
+static inline u64 NIXX_AF_AQ_DONE_INT(void)
 {
 	return 0x480;
 }
@@ -1850,18 +1920,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_INT(void)
  *
  * INTERNAL: NIX AF Admin Queue Done Interrupt Set Register
  */
-union cavm_nixx_af_aq_done_int_w1s {
+union nixx_af_aq_done_int_w1s {
 	u64 u;
-	struct cavm_nixx_af_aq_done_int_w1s_s {
+	struct nixx_af_aq_done_int_w1s_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_aq_done_int_w1s_s cn; */
+	/* struct nixx_af_aq_done_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_INT_W1S(void)
+static inline u64 NIXX_AF_AQ_DONE_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_INT_W1S(void)
+static inline u64 NIXX_AF_AQ_DONE_INT_W1S(void)
 {
 	return 0x488;
 }
@@ -1871,18 +1941,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_INT_W1S(void)
  *
  * NIX AF Admin Queue Done Interrupt Timer Register
  */
-union cavm_nixx_af_aq_done_timer {
+union nixx_af_aq_done_timer {
 	u64 u;
-	struct cavm_nixx_af_aq_done_timer_s {
+	struct nixx_af_aq_done_timer_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_aq_done_timer_s cn; */
+	/* struct nixx_af_aq_done_timer_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
+static inline u64 NIXX_AF_AQ_DONE_TIMER(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
+static inline u64 NIXX_AF_AQ_DONE_TIMER(void)
 {
 	return 0x470;
 }
@@ -1893,20 +1963,20 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
  * NIX AF Admin Queue Done Interrupt Coalescing Wait Register Specifies
  * the queue interrupt coalescing settings.
  */
-union cavm_nixx_af_aq_done_wait {
+union nixx_af_aq_done_wait {
 	u64 u;
-	struct cavm_nixx_af_aq_done_wait_s {
+	struct nixx_af_aq_done_wait_s {
 		u64 num_wait                         : 20;
 		u64 reserved_20_31                   : 12;
 		u64 time_wait                        : 16;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_aq_done_wait_s cn; */
+	/* struct nixx_af_aq_done_wait_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
+static inline u64 NIXX_AF_AQ_DONE_WAIT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
+static inline u64 NIXX_AF_AQ_DONE_WAIT(void)
 {
 	return 0x440;
 }
@@ -1917,18 +1987,18 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
  * NIX AF Admin Queue Doorbell Register Software writes to this register
  * to enqueue entries to AQ.
  */
-union cavm_nixx_af_aq_door {
+union nixx_af_aq_door {
 	u64 u;
-	struct cavm_nixx_af_aq_door_s {
+	struct nixx_af_aq_door_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_aq_door_s cn; */
+	/* struct nixx_af_aq_door_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_DOOR(void)
+static inline u64 NIXX_AF_AQ_DOOR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_DOOR(void)
+static inline u64 NIXX_AF_AQ_DOOR(void)
 {
 	return 0x430;
 }
@@ -1938,9 +2008,9 @@ static inline u64 CAVM_NIXX_AF_AQ_DOOR(void)
  *
  * NIX AF Admin Queue Status Register
  */
-union cavm_nixx_af_aq_status {
+union nixx_af_aq_status {
 	u64 u;
-	struct cavm_nixx_af_aq_status_s {
+	struct nixx_af_aq_status_s {
 		u64 reserved_0_3                     : 4;
 		u64 head_ptr                         : 20;
 		u64 reserved_24_35                   : 12;
@@ -1949,7 +2019,7 @@ union cavm_nixx_af_aq_status {
 		u64 aq_busy                          : 1;
 		u64 aq_err                           : 1;
 	} s;
-	struct cavm_nixx_af_aq_status_cn {
+	struct nixx_af_aq_status_cn {
 		u64 reserved_0_3                     : 4;
 		u64 head_ptr                         : 20;
 		u64 reserved_24_31                   : 8;
@@ -1961,9 +2031,9 @@ union cavm_nixx_af_aq_status {
 	} cn;
 };
 
-static inline u64 CAVM_NIXX_AF_AQ_STATUS(void)
+static inline u64 NIXX_AF_AQ_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AQ_STATUS(void)
+static inline u64 NIXX_AF_AQ_STATUS(void)
 {
 	return 0x420;
 }
@@ -1973,20 +2043,20 @@ static inline u64 CAVM_NIXX_AF_AQ_STATUS(void)
  *
  * NIX AF Queue Average Delay Register
  */
-union cavm_nixx_af_avg_delay {
+union nixx_af_avg_delay {
 	u64 u;
-	struct cavm_nixx_af_avg_delay_s {
+	struct nixx_af_avg_delay_s {
 		u64 avg_dly                          : 19;
 		u64 reserved_19_23                   : 5;
 		u64 avg_timer                        : 16;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_avg_delay_s cn; */
+	/* struct nixx_af_avg_delay_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
+static inline u64 NIXX_AF_AVG_DELAY(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
+static inline u64 NIXX_AF_AVG_DELAY(void)
 {
 	return 0xe0;
 }
@@ -1994,22 +2064,22 @@ static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_bar2_alias#
  *
- * INTERNAL: NIX Admin Function  BAR2 Alias Registers  These registers
- * alias to the NIX BAR2 registers for the PF and function selected by
+ * NIX Admin Function  BAR2 Alias Registers These registers alias to the
+ * NIX BAR2 registers for the PF and function selected by
  * NIX_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
  * bug33464.
  */
-union cavm_nixx_af_bar2_aliasx {
+union nixx_af_bar2_aliasx {
 	u64 u;
-	struct cavm_nixx_af_bar2_aliasx_s {
+	struct nixx_af_bar2_aliasx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_nixx_af_bar2_aliasx_s cn; */
+	/* struct nixx_af_bar2_aliasx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
+static inline u64 NIXX_AF_BAR2_ALIASX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
+static inline u64 NIXX_AF_BAR2_ALIASX(u64 a)
 {
 	return 0x9100000 + 8 * a;
 }
@@ -2017,23 +2087,23 @@ static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_bar2_sel
  *
- * INTERNAL: NIX Admin Function BAR2 Select Register  This register
- * configures BAR2 accesses from the NIX_AF_BAR2_ALIAS() registers in
- * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ * NIX Admin Function BAR2 Select Register This register configures BAR2
+ * accesses from the NIX_AF_BAR2_ALIAS() registers in BAR0. Internal: Not
+ * implemented. Placeholder for bug33464.
  */
-union cavm_nixx_af_bar2_sel {
+union nixx_af_bar2_sel {
 	u64 u;
-	struct cavm_nixx_af_bar2_sel_s {
+	struct nixx_af_bar2_sel_s {
 		u64 alias_pf_func                    : 16;
 		u64 alias_ena                        : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_nixx_af_bar2_sel_s cn; */
+	/* struct nixx_af_bar2_sel_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_BAR2_SEL(void)
+static inline u64 NIXX_AF_BAR2_SEL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_BAR2_SEL(void)
+static inline u64 NIXX_AF_BAR2_SEL(void)
 {
 	return 0x9000000;
 }
@@ -2043,19 +2113,19 @@ static inline u64 CAVM_NIXX_AF_BAR2_SEL(void)
  *
  * NIX AF Block Reset Register
  */
-union cavm_nixx_af_blk_rst {
+union nixx_af_blk_rst {
 	u64 u;
-	struct cavm_nixx_af_blk_rst_s {
+	struct nixx_af_blk_rst_s {
 		u64 rst                              : 1;
 		u64 reserved_1_62                    : 62;
 		u64 busy                             : 1;
 	} s;
-	/* struct cavm_nixx_af_blk_rst_s cn; */
+	/* struct nixx_af_blk_rst_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_BLK_RST(void)
+static inline u64 NIXX_AF_BLK_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_BLK_RST(void)
+static inline u64 NIXX_AF_BLK_RST(void)
 {
 	return 0xb0;
 }
@@ -2065,9 +2135,9 @@ static inline u64 CAVM_NIXX_AF_BLK_RST(void)
  *
  * NIX AF General Configuration Register
  */
-union cavm_nixx_af_cfg {
+union nixx_af_cfg {
 	u64 u;
-	struct cavm_nixx_af_cfg_s {
+	struct nixx_af_cfg_s {
 		u64 force_cond_clk_en                : 1;
 		u64 force_rx_gbl_clk_en              : 1;
 		u64 force_rx_strm_clk_en             : 1;
@@ -2081,12 +2151,12 @@ union cavm_nixx_af_cfg {
 		u64 force_intf_clk_en                : 1;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_cfg_s cn; */
+	/* struct nixx_af_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CFG(void)
+static inline u64 NIXX_AF_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CFG(void)
+static inline u64 NIXX_AF_CFG(void)
 {
 	return 0;
 }
@@ -2096,20 +2166,20 @@ static inline u64 CAVM_NIXX_AF_CFG(void)
  *
  * NIX AF Completion Interrupt Delay Register
  */
-union cavm_nixx_af_cint_delay {
+union nixx_af_cint_delay {
 	u64 u;
-	struct cavm_nixx_af_cint_delay_s {
+	struct nixx_af_cint_delay_s {
 		u64 cint_dly                         : 10;
 		u64 reserved_10_15                   : 6;
 		u64 cint_timer                       : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_cint_delay_s cn; */
+	/* struct nixx_af_cint_delay_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CINT_DELAY(void)
+static inline u64 NIXX_AF_CINT_DELAY(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CINT_DELAY(void)
+static inline u64 NIXX_AF_CINT_DELAY(void)
 {
 	return 0xf0;
 }
@@ -2119,9 +2189,9 @@ static inline u64 CAVM_NIXX_AF_CINT_DELAY(void)
  *
  * NIX AF Completion Interrupt Timer Registers
  */
-union cavm_nixx_af_cint_timerx {
+union nixx_af_cint_timerx {
 	u64 u;
-	struct cavm_nixx_af_cint_timerx_s {
+	struct nixx_af_cint_timerx_s {
 		u64 expir_time                       : 16;
 		u64 cint                             : 7;
 		u64 reserved_23                      : 1;
@@ -2129,12 +2199,12 @@ union cavm_nixx_af_cint_timerx {
 		u64 active                           : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_nixx_af_cint_timerx_s cn; */
+	/* struct nixx_af_cint_timerx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
+static inline u64 NIXX_AF_CINT_TIMERX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
+static inline u64 NIXX_AF_CINT_TIMERX(u64 a)
 {
 	return 0x1a40 + 0x40000 * a;
 }
@@ -2145,9 +2215,9 @@ static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
  * NIX AF Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_const {
+union nixx_af_const {
 	u64 u;
-	struct cavm_nixx_af_const_s {
+	struct nixx_af_const_s {
 		u64 cgx_lmac_channels                : 8;
 		u64 cgx_lmacs                        : 4;
 		u64 num_cgx                          : 4;
@@ -2159,12 +2229,12 @@ union cavm_nixx_af_const {
 		u64 intfs                            : 4;
 		u64 reserved_60_63                   : 4;
 	} s;
-	/* struct cavm_nixx_af_const_s cn; */
+	/* struct nixx_af_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CONST(void)
+static inline u64 NIXX_AF_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CONST(void)
+static inline u64 NIXX_AF_CONST(void)
 {
 	return 0x20;
 }
@@ -2175,9 +2245,9 @@ static inline u64 CAVM_NIXX_AF_CONST(void)
  * NIX AF Constants 1 Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_const1 {
+union nixx_af_const1 {
 	u64 u;
-	struct cavm_nixx_af_const1_s {
+	struct nixx_af_const1_s {
 		u64 sdp_channels                     : 12;
 		u64 rx_bpids                         : 12;
 		u64 lf_tx_stats                      : 8;
@@ -2186,12 +2256,12 @@ union cavm_nixx_af_const1 {
 		u64 lso_formats                      : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_nixx_af_const1_s cn; */
+	/* struct nixx_af_const1_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CONST1(void)
+static inline u64 NIXX_AF_CONST1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CONST1(void)
+static inline u64 NIXX_AF_CONST1(void)
 {
 	return 0x28;
 }
@@ -2202,20 +2272,20 @@ static inline u64 CAVM_NIXX_AF_CONST1(void)
  * NIX AF Constants 2 Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_const2 {
+union nixx_af_const2 {
 	u64 u;
-	struct cavm_nixx_af_const2_s {
+	struct nixx_af_const2_s {
 		u64 lfs                              : 12;
 		u64 qints                            : 12;
 		u64 cints                            : 12;
 		u64 reserved_36_63                   : 28;
 	} s;
-	/* struct cavm_nixx_af_const2_s cn; */
+	/* struct nixx_af_const2_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CONST2(void)
+static inline u64 NIXX_AF_CONST2(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CONST2(void)
+static inline u64 NIXX_AF_CONST2(void)
 {
 	return 0x30;
 }
@@ -2226,9 +2296,9 @@ static inline u64 CAVM_NIXX_AF_CONST2(void)
  * NIX AF Constants 2 Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_const3 {
+union nixx_af_const3 {
 	u64 u;
-	struct cavm_nixx_af_const3_s {
+	struct nixx_af_const3_s {
 		u64 sq_ctx_log2bytes                 : 4;
 		u64 rq_ctx_log2bytes                 : 4;
 		u64 cq_ctx_log2bytes                 : 4;
@@ -2239,12 +2309,12 @@ union cavm_nixx_af_const3 {
 		u64 dyno_log2bytes                   : 4;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_const3_s cn; */
+	/* struct nixx_af_const3_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CONST3(void)
+static inline u64 NIXX_AF_CONST3(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CONST3(void)
+static inline u64 NIXX_AF_CONST3(void)
 {
 	return 0x38;
 }
@@ -2255,18 +2325,18 @@ static inline u64 CAVM_NIXX_AF_CONST3(void)
  * NIX AF CQ Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_cq_const {
+union nixx_af_cq_const {
 	u64 u;
-	struct cavm_nixx_af_cq_const_s {
+	struct nixx_af_cq_const_s {
 		u64 queues_per_lf                    : 24;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_cq_const_s cn; */
+	/* struct nixx_af_cq_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CQ_CONST(void)
+static inline u64 NIXX_AF_CQ_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CQ_CONST(void)
+static inline u64 NIXX_AF_CQ_CONST(void)
 {
 	return 0x48;
 }
@@ -2276,21 +2346,21 @@ static inline u64 CAVM_NIXX_AF_CQ_CONST(void)
  *
  * INTERNAL: NIX AF CQM Backpressure Test Registers
  */
-union cavm_nixx_af_cqm_bp_test {
+union nixx_af_cqm_bp_test {
 	u64 u;
-	struct cavm_nixx_af_cqm_bp_test_s {
+	struct nixx_af_cqm_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 24;
 		u64 enable                           : 12;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_nixx_af_cqm_bp_test_s cn; */
+	/* struct nixx_af_cqm_bp_test_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CQM_BP_TEST(void)
+static inline u64 NIXX_AF_CQM_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CQM_BP_TEST(void)
+static inline u64 NIXX_AF_CQM_BP_TEST(void)
 {
 	return 0x48c0;
 }
@@ -2300,17 +2370,17 @@ static inline u64 CAVM_NIXX_AF_CQM_BP_TEST(void)
  *
  * INTERNAL: AF CQM ECO Register
  */
-union cavm_nixx_af_cqm_eco {
+union nixx_af_cqm_eco {
 	u64 u;
-	struct cavm_nixx_af_cqm_eco_s {
+	struct nixx_af_cqm_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_cqm_eco_s cn; */
+	/* struct nixx_af_cqm_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CQM_ECO(void)
+static inline u64 NIXX_AF_CQM_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CQM_ECO(void)
+static inline u64 NIXX_AF_CQM_ECO(void)
 {
 	return 0x590;
 }
@@ -2320,17 +2390,17 @@ static inline u64 CAVM_NIXX_AF_CQM_ECO(void)
  *
  * INTERNAL: AF CSI ECO Register
  */
-union cavm_nixx_af_csi_eco {
+union nixx_af_csi_eco {
 	u64 u;
-	struct cavm_nixx_af_csi_eco_s {
+	struct nixx_af_csi_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_csi_eco_s cn; */
+	/* struct nixx_af_csi_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_CSI_ECO(void)
+static inline u64 NIXX_AF_CSI_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_CSI_ECO(void)
+static inline u64 NIXX_AF_CSI_ECO(void)
 {
 	return 0x580;
 }
@@ -2340,9 +2410,9 @@ static inline u64 CAVM_NIXX_AF_CSI_ECO(void)
  *
  * NIX Admin Function Error Interrupt Register
  */
-union cavm_nixx_af_err_int {
+union nixx_af_err_int {
 	u64 u;
-	struct cavm_nixx_af_err_int_s {
+	struct nixx_af_err_int_s {
 		u64 rx_mcast_data_fault              : 1;
 		u64 rx_mirror_data_fault             : 1;
 		u64 rx_mcast_wqe_fault               : 1;
@@ -2356,12 +2426,12 @@ union cavm_nixx_af_err_int {
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_nixx_af_err_int_s cn; */
+	/* struct nixx_af_err_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_ERR_INT(void)
+static inline u64 NIXX_AF_ERR_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_ERR_INT(void)
+static inline u64 NIXX_AF_ERR_INT(void)
 {
 	return 0x180;
 }
@@ -2372,9 +2442,9 @@ static inline u64 CAVM_NIXX_AF_ERR_INT(void)
  * NIX Admin Function Error Interrupt Enable Clear Register This register
  * clears interrupt enable bits.
  */
-union cavm_nixx_af_err_int_ena_w1c {
+union nixx_af_err_int_ena_w1c {
 	u64 u;
-	struct cavm_nixx_af_err_int_ena_w1c_s {
+	struct nixx_af_err_int_ena_w1c_s {
 		u64 rx_mcast_data_fault              : 1;
 		u64 rx_mirror_data_fault             : 1;
 		u64 rx_mcast_wqe_fault               : 1;
@@ -2388,12 +2458,12 @@ union cavm_nixx_af_err_int_ena_w1c {
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_nixx_af_err_int_ena_w1c_s cn; */
+	/* struct nixx_af_err_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_ERR_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_ERR_INT_ENA_W1C(void)
 {
 	return 0x198;
 }
@@ -2404,9 +2474,9 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
  * NIX Admin Function Error Interrupt Enable Set Register This register
  * sets interrupt enable bits.
  */
-union cavm_nixx_af_err_int_ena_w1s {
+union nixx_af_err_int_ena_w1s {
 	u64 u;
-	struct cavm_nixx_af_err_int_ena_w1s_s {
+	struct nixx_af_err_int_ena_w1s_s {
 		u64 rx_mcast_data_fault              : 1;
 		u64 rx_mirror_data_fault             : 1;
 		u64 rx_mcast_wqe_fault               : 1;
@@ -2420,12 +2490,12 @@ union cavm_nixx_af_err_int_ena_w1s {
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_nixx_af_err_int_ena_w1s_s cn; */
+	/* struct nixx_af_err_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_ERR_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_ERR_INT_ENA_W1S(void)
 {
 	return 0x190;
 }
@@ -2436,9 +2506,9 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
  * NIX Admin Function Error Interrupt Set Register This register sets
  * interrupt bits.
  */
-union cavm_nixx_af_err_int_w1s {
+union nixx_af_err_int_w1s {
 	u64 u;
-	struct cavm_nixx_af_err_int_w1s_s {
+	struct nixx_af_err_int_w1s_s {
 		u64 rx_mcast_data_fault              : 1;
 		u64 rx_mirror_data_fault             : 1;
 		u64 rx_mcast_wqe_fault               : 1;
@@ -2452,12 +2522,12 @@ union cavm_nixx_af_err_int_w1s {
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_nixx_af_err_int_w1s_s cn; */
+	/* struct nixx_af_err_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
+static inline u64 NIXX_AF_ERR_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
+static inline u64 NIXX_AF_ERR_INT_W1S(void)
 {
 	return 0x188;
 }
@@ -2465,21 +2535,22 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_expr_tx_fifo_status
  *
- * NIX AF Express Transmit FIFO Status Register Status of FIFO which
- * transmits express packets to CGX and LBK.
+ * INTERNAL: NIX AF Express Transmit FIFO Status Register  Internal:
+ * 802.3br frame preemption/express path is defeatured. Old definition:
+ * Status of FIFO which transmits express packets to CGX and LBK.
  */
-union cavm_nixx_af_expr_tx_fifo_status {
+union nixx_af_expr_tx_fifo_status {
 	u64 u;
-	struct cavm_nixx_af_expr_tx_fifo_status_s {
+	struct nixx_af_expr_tx_fifo_status_s {
 		u64 count                            : 12;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_nixx_af_expr_tx_fifo_status_s cn; */
+	/* struct nixx_af_expr_tx_fifo_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_EXPR_TX_FIFO_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_EXPR_TX_FIFO_STATUS(void)
 {
 	return 0x640;
 }
@@ -2489,9 +2560,9 @@ static inline u64 CAVM_NIXX_AF_EXPR_TX_FIFO_STATUS(void)
  *
  * NIX AF General Interrupt Register
  */
-union cavm_nixx_af_gen_int {
+union nixx_af_gen_int {
 	u64 u;
-	struct cavm_nixx_af_gen_int_s {
+	struct nixx_af_gen_int_s {
 		u64 rx_mcast_drop                    : 1;
 		u64 rx_mirror_drop                   : 1;
 		u64 reserved_2                       : 1;
@@ -2499,12 +2570,12 @@ union cavm_nixx_af_gen_int {
 		u64 smq_flush_done                   : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_nixx_af_gen_int_s cn; */
+	/* struct nixx_af_gen_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_GEN_INT(void)
+static inline u64 NIXX_AF_GEN_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_GEN_INT(void)
+static inline u64 NIXX_AF_GEN_INT(void)
 {
 	return 0x160;
 }
@@ -2515,9 +2586,9 @@ static inline u64 CAVM_NIXX_AF_GEN_INT(void)
  * NIX AF General Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_af_gen_int_ena_w1c {
+union nixx_af_gen_int_ena_w1c {
 	u64 u;
-	struct cavm_nixx_af_gen_int_ena_w1c_s {
+	struct nixx_af_gen_int_ena_w1c_s {
 		u64 rx_mcast_drop                    : 1;
 		u64 rx_mirror_drop                   : 1;
 		u64 reserved_2                       : 1;
@@ -2525,12 +2596,12 @@ union cavm_nixx_af_gen_int_ena_w1c {
 		u64 smq_flush_done                   : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_nixx_af_gen_int_ena_w1c_s cn; */
+	/* struct nixx_af_gen_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_GEN_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_GEN_INT_ENA_W1C(void)
 {
 	return 0x178;
 }
@@ -2541,9 +2612,9 @@ static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
  * NIX AF General Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_nixx_af_gen_int_ena_w1s {
+union nixx_af_gen_int_ena_w1s {
 	u64 u;
-	struct cavm_nixx_af_gen_int_ena_w1s_s {
+	struct nixx_af_gen_int_ena_w1s_s {
 		u64 rx_mcast_drop                    : 1;
 		u64 rx_mirror_drop                   : 1;
 		u64 reserved_2                       : 1;
@@ -2551,12 +2622,12 @@ union cavm_nixx_af_gen_int_ena_w1s {
 		u64 smq_flush_done                   : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_nixx_af_gen_int_ena_w1s_s cn; */
+	/* struct nixx_af_gen_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_GEN_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_GEN_INT_ENA_W1S(void)
 {
 	return 0x170;
 }
@@ -2567,9 +2638,9 @@ static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
  * NIX AF General Interrupt Set Register This register sets interrupt
  * bits.
  */
-union cavm_nixx_af_gen_int_w1s {
+union nixx_af_gen_int_w1s {
 	u64 u;
-	struct cavm_nixx_af_gen_int_w1s_s {
+	struct nixx_af_gen_int_w1s_s {
 		u64 rx_mcast_drop                    : 1;
 		u64 rx_mirror_drop                   : 1;
 		u64 reserved_2                       : 1;
@@ -2577,12 +2648,12 @@ union cavm_nixx_af_gen_int_w1s {
 		u64 smq_flush_done                   : 1;
 		u64 reserved_5_63                    : 59;
 	} s;
-	/* struct cavm_nixx_af_gen_int_w1s_s cn; */
+	/* struct nixx_af_gen_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_GEN_INT_W1S(void)
+static inline u64 NIXX_AF_GEN_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_GEN_INT_W1S(void)
+static inline u64 NIXX_AF_GEN_INT_W1S(void)
 {
 	return 0x168;
 }
@@ -2592,21 +2663,21 @@ static inline u64 CAVM_NIXX_AF_GEN_INT_W1S(void)
  *
  * NIX AF Local Function Configuration Registers
  */
-union cavm_nixx_af_lfx_cfg {
+union nixx_af_lfx_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_cfg_s {
+	struct nixx_af_lfx_cfg_s {
 		u64 npa_pf_func                      : 16;
 		u64 sso_pf_func                      : 16;
 		u64 be                               : 1;
 		u64 xqe_size                         : 2;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_lfx_cfg_s cn; */
+	/* struct nixx_af_lfx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CFG(u64 a)
 {
 	return 0x4000 + 0x20000 * a;
 }
@@ -2619,19 +2690,19 @@ static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
  * context table in NDC/LLC/DRAM. The table consists of
  * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures.
  */
-union cavm_nixx_af_lfx_cints_base {
+union nixx_af_lfx_cints_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_cints_base_s {
+	struct nixx_af_lfx_cints_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_cints_base_s cn; */
+	/* struct nixx_af_lfx_cints_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_CINTS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_CINTS_BASE(u64 a)
 {
 	return 0x4130 + 0x20000 * a;
 }
@@ -2645,20 +2716,20 @@ static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
  * contiguous NIX_CINT_HW_S structures. The size of each structure is 1
  * \<\< NIX_AF_CONST3[CINT_LOG2BYTES].
  */
-union cavm_nixx_af_lfx_cints_cfg {
+union nixx_af_lfx_cints_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_cints_cfg_s {
+	struct nixx_af_lfx_cints_cfg_s {
 		u64 reserved_0_19                    : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_cints_cfg_s cn; */
+	/* struct nixx_af_lfx_cints_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CINTS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CINTS_CFG(u64 a)
 {
 	return 0x4120 + 0x20000 * a;
 }
@@ -2671,19 +2742,19 @@ static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
  * table consists of NIX_AF_LF()_CQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_CQ_CTX_S structures.
  */
-union cavm_nixx_af_lfx_cqs_base {
+union nixx_af_lfx_cqs_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_cqs_base_s {
+	struct nixx_af_lfx_cqs_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_cqs_base_s cn; */
+	/* struct nixx_af_lfx_cqs_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_CQS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_CQS_BASE(u64 a)
 {
 	return 0x4070 + 0x20000 * a;
 }
@@ -2694,20 +2765,20 @@ static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
  * NIX AF Local Function Completion Queues Configuration Register This
  * register configures completion queues in the LF.
  */
-union cavm_nixx_af_lfx_cqs_cfg {
+union nixx_af_lfx_cqs_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_cqs_cfg_s {
+	struct nixx_af_lfx_cqs_cfg_s {
 		u64 max_queuesm1                     : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_cqs_cfg_s cn; */
+	/* struct nixx_af_lfx_cqs_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CQS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_CQS_CFG(u64 a)
 {
 	return 0x4060 + 0x20000 * a;
 }
@@ -2721,18 +2792,18 @@ static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
  * skip bytes). NPC's MCAM can be used for deeper protocol-aware
  * lockdown.
  */
-union cavm_nixx_af_lfx_lockx {
+union nixx_af_lfx_lockx {
 	u64 u;
-	struct cavm_nixx_af_lfx_lockx_s {
+	struct nixx_af_lfx_lockx_s {
 		u64 data                             : 32;
 		u64 bit_ena                          : 32;
 	} s;
-	/* struct cavm_nixx_af_lfx_lockx_s cn; */
+	/* struct nixx_af_lfx_lockx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_LOCKX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_LOCKX(u64 a, u64 b)
 {
 	return 0x4300 + 0x20000 * a + 8 * b;
 }
@@ -2745,19 +2816,19 @@ static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
  * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS]
  * contiguous NIX_QINT_HW_S structures.
  */
-union cavm_nixx_af_lfx_qints_base {
+union nixx_af_lfx_qints_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_qints_base_s {
+	struct nixx_af_lfx_qints_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_qints_base_s cn; */
+	/* struct nixx_af_lfx_qints_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_QINTS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_QINTS_BASE(u64 a)
 {
 	return 0x4110 + 0x20000 * a;
 }
@@ -2771,20 +2842,20 @@ static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
  * NIX_QINT_HW_S structures. The size of each structure is 1 \<\<
  * NIX_AF_CONST3[QINT_LOG2BYTES].
  */
-union cavm_nixx_af_lfx_qints_cfg {
+union nixx_af_lfx_qints_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_qints_cfg_s {
+	struct nixx_af_lfx_qints_cfg_s {
 		u64 reserved_0_19                    : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_qints_cfg_s cn; */
+	/* struct nixx_af_lfx_qints_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_QINTS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_QINTS_CFG(u64 a)
 {
 	return 0x4100 + 0x20000 * a;
 }
@@ -2797,19 +2868,19 @@ static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
  * table consists of NIX_AF_LF()_RQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_RQ_CTX_S structures.
  */
-union cavm_nixx_af_lfx_rqs_base {
+union nixx_af_lfx_rqs_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_rqs_base_s {
+	struct nixx_af_lfx_rqs_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_rqs_base_s cn; */
+	/* struct nixx_af_lfx_rqs_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RQS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RQS_BASE(u64 a)
 {
 	return 0x4050 + 0x20000 * a;
 }
@@ -2820,20 +2891,20 @@ static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
  * NIX AF Local Function Receive Queues Configuration Register This
  * register configures receive queues in the LF.
  */
-union cavm_nixx_af_lfx_rqs_cfg {
+union nixx_af_lfx_rqs_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_rqs_cfg_s {
+	struct nixx_af_lfx_rqs_cfg_s {
 		u64 max_queuesm1                     : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_rqs_cfg_s cn; */
+	/* struct nixx_af_lfx_rqs_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RQS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RQS_CFG(u64 a)
 {
 	return 0x4040 + 0x20000 * a;
 }
@@ -2848,19 +2919,19 @@ static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
  * structures, where the size of each structure is 1 \<\<
  * NIX_AF_CONST3[RSSE_LOG2BYTES]. See NIX_AF_LF()_RSS_GRP().
  */
-union cavm_nixx_af_lfx_rss_base {
+union nixx_af_lfx_rss_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_rss_base_s {
+	struct nixx_af_lfx_rss_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_rss_base_s cn; */
+	/* struct nixx_af_lfx_rss_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RSS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RSS_BASE(u64 a)
 {
 	return 0x40d0 + 0x20000 * a;
 }
@@ -2871,22 +2942,34 @@ static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
  * NIX AF Local Function Receive Size Scaling Table Configuration
  * Register See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
  */
-union cavm_nixx_af_lfx_rss_cfg {
+union nixx_af_lfx_rss_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_rss_cfg_s {
+	struct nixx_af_lfx_rss_cfg_s {
 		u64 size                             : 4;
 		u64 ena                              : 1;
-		u64 reserved_5_19                    : 15;
+		u64 adder_is_tag_lsb                 : 1;
+		u64 reserved_6_19                    : 14;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_rss_cfg_s cn; */
+	struct nixx_af_lfx_rss_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 ena                              : 1;
+		u64 reserved_5_19                    : 15;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} cn96xxp1;
+	/* struct nixx_af_lfx_rss_cfg_s cn96xxp3; */
+	/* struct nixx_af_lfx_rss_cfg_s cn98xx; */
+	/* struct nixx_af_lfx_rss_cfg_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_lfx_rss_cfg_s loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RSS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RSS_CFG(u64 a)
 {
 	return 0x40c0 + 0x20000 * a;
 }
@@ -2904,20 +2987,20 @@ static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
  * select a NIX_RSSE_S entry in the LF's RSS table (see [SIZEM1]). *
  * NIX_RSSE_S selects the packet's destination RQ.
  */
-union cavm_nixx_af_lfx_rss_grpx {
+union nixx_af_lfx_rss_grpx {
 	u64 u;
-	struct cavm_nixx_af_lfx_rss_grpx_s {
+	struct nixx_af_lfx_rss_grpx_s {
 		u64 offset                           : 11;
 		u64 reserved_11_15                   : 5;
 		u64 sizem1                           : 3;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_lfx_rss_grpx_s cn; */
+	/* struct nixx_af_lfx_rss_grpx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
 {
 	return 0x4600 + 0x20000 * a + 8 * b;
 }
@@ -2927,9 +3010,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
  *
  * NIX AF Local Function Receive Configuration Register
  */
-union cavm_nixx_af_lfx_rx_cfg {
+union nixx_af_lfx_rx_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_cfg_s {
+	struct nixx_af_lfx_rx_cfg_s {
 		u64 reserved_0_31                    : 32;
 		u64 drop_re                          : 1;
 		u64 lenerr_en                        : 1;
@@ -2943,7 +3026,7 @@ union cavm_nixx_af_lfx_rx_cfg {
 		u64 len_ol3                          : 1;
 		u64 reserved_42_63                   : 22;
 	} s;
-	struct cavm_nixx_af_lfx_rx_cfg_cn96xx {
+	struct nixx_af_lfx_rx_cfg_cn96xxp1 {
 		u64 reserved_0_31                    : 32;
 		u64 reserved_32                      : 1;
 		u64 lenerr_en                        : 1;
@@ -2956,13 +3039,16 @@ union cavm_nixx_af_lfx_rx_cfg {
 		u64 len_ol4                          : 1;
 		u64 len_ol3                          : 1;
 		u64 reserved_42_63                   : 22;
-	} cn96xx;
-	/* struct cavm_nixx_af_lfx_rx_cfg_s cnf95xx; */
+	} cn96xxp1;
+	/* struct nixx_af_lfx_rx_cfg_s cn96xxp3; */
+	/* struct nixx_af_lfx_rx_cfg_s cn98xx; */
+	/* struct nixx_af_lfx_rx_cfg_s cnf95xx; */
+	/* struct nixx_af_lfx_rx_cfg_s loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RX_CFG(u64 a)
 {
 	return 0x40a0 + 0x20000 * a;
 }
@@ -2973,9 +3059,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_CFG(u64 a)
  * INTERNAL: NIX AF LF Receive IPSEC Configuration Registers  Internal:
  * Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_lfx_rx_ipsec_cfg0 {
+union nixx_af_lfx_rx_ipsec_cfg0 {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_ipsec_cfg0_s {
+	struct nixx_af_lfx_rx_ipsec_cfg0_s {
 		u64 lenm1_max                        : 14;
 		u64 reserved_14_15                   : 2;
 		u64 sa_pow2_size                     : 4;
@@ -2985,12 +3071,12 @@ union cavm_nixx_af_lfx_rx_ipsec_cfg0 {
 		u64 hshcpt                           : 1;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_ipsec_cfg0_s cn; */
+	/* struct nixx_af_lfx_rx_ipsec_cfg0_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
 {
 	return 0x4140 + 0x20000 * a;
 }
@@ -3001,19 +3087,19 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
  * INTERNAL: NIX AF LF Receive IPSEC Security Association Configuration
  * Register  Internal: Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_lfx_rx_ipsec_cfg1 {
+union nixx_af_lfx_rx_ipsec_cfg1 {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_ipsec_cfg1_s {
+	struct nixx_af_lfx_rx_ipsec_cfg1_s {
 		u64 sa_idx_max                       : 32;
 		u64 sa_idx_w                         : 5;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_ipsec_cfg1_s cn; */
+	/* struct nixx_af_lfx_rx_ipsec_cfg1_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
 {
 	return 0x4148 + 0x20000 * a;
 }
@@ -3024,19 +3110,19 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
  * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
  * Registers  Internal: Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_lfx_rx_ipsec_dyno_base {
+union nixx_af_lfx_rx_ipsec_dyno_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_ipsec_dyno_base_s {
+	struct nixx_af_lfx_rx_ipsec_dyno_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_ipsec_dyno_base_s cn; */
+	/* struct nixx_af_lfx_rx_ipsec_dyno_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
 {
 	return 0x4158 + 0x20000 * a;
 }
@@ -3047,9 +3133,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
  * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
  * Registers  Internal: Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_lfx_rx_ipsec_dyno_cfg {
+union nixx_af_lfx_rx_ipsec_dyno_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_ipsec_dyno_cfg_s {
+	struct nixx_af_lfx_rx_ipsec_dyno_cfg_s {
 		u64 dyno_idx_w                       : 4;
 		u64 dyno_ena                         : 1;
 		u64 reserved_5_19                    : 15;
@@ -3057,12 +3143,12 @@ union cavm_nixx_af_lfx_rx_ipsec_dyno_cfg {
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_ipsec_dyno_cfg_s cn; */
+	/* struct nixx_af_lfx_rx_ipsec_dyno_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
 {
 	return 0x4150 + 0x20000 * a;
 }
@@ -3073,19 +3159,19 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
  * INTERNAL: NIX AF LF Receive IPSEC Security Association Base Address
  * Register  Internal: Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_lfx_rx_ipsec_sa_base {
+union nixx_af_lfx_rx_ipsec_sa_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_ipsec_sa_base_s {
+	struct nixx_af_lfx_rx_ipsec_sa_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_ipsec_sa_base_s cn; */
+	/* struct nixx_af_lfx_rx_ipsec_sa_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
 {
 	return 0x4170 + 0x20000 * a;
 }
@@ -3096,18 +3182,18 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
  * NIX AF Local Function Receive Statistics Registers The last dimension
  * indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
  */
-union cavm_nixx_af_lfx_rx_statx {
+union nixx_af_lfx_rx_statx {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_statx_s {
+	struct nixx_af_lfx_rx_statx_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_statx_s cn; */
+	/* struct nixx_af_lfx_rx_statx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
 {
 	return 0x4500 + 0x20000 * a + 8 * b;
 }
@@ -3119,21 +3205,21 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
  * specify optional Vtag (e.g. VLAN, E-TAG) actions for received packets.
  * Indexed by NIX_RX_VTAG_ACTION_S[VTAG*_TYPE].
  */
-union cavm_nixx_af_lfx_rx_vtag_typex {
+union nixx_af_lfx_rx_vtag_typex {
 	u64 u;
-	struct cavm_nixx_af_lfx_rx_vtag_typex_s {
+	struct nixx_af_lfx_rx_vtag_typex_s {
 		u64 size                             : 1;
 		u64 reserved_1_3                     : 3;
 		u64 strip                            : 1;
 		u64 capture                          : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_nixx_af_lfx_rx_vtag_typex_s cn; */
+	/* struct nixx_af_lfx_rx_vtag_typex_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
 {
 	return 0x4200 + 0x20000 * a + 8 * b;
 }
@@ -3146,19 +3232,19 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
  * consists of NIX_AF_LF()_SQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_SQ_CTX_HW_S structures.
  */
-union cavm_nixx_af_lfx_sqs_base {
+union nixx_af_lfx_sqs_base {
 	u64 u;
-	struct cavm_nixx_af_lfx_sqs_base_s {
+	struct nixx_af_lfx_sqs_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_lfx_sqs_base_s cn; */
+	/* struct nixx_af_lfx_sqs_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_SQS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
+static inline u64 NIXX_AF_LFX_SQS_BASE(u64 a)
 {
 	return 0x4030 + 0x20000 * a;
 }
@@ -3169,20 +3255,20 @@ static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
  * NIX AF Local Function Send Queues Configuration Register This register
  * configures send queues in the LF.
  */
-union cavm_nixx_af_lfx_sqs_cfg {
+union nixx_af_lfx_sqs_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_sqs_cfg_s {
+	struct nixx_af_lfx_sqs_cfg_s {
 		u64 max_queuesm1                     : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_lfx_sqs_cfg_s cn; */
+	/* struct nixx_af_lfx_sqs_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_SQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_SQS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_SQS_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_SQS_CFG(u64 a)
 {
 	return 0x4020 + 0x20000 * a;
 }
@@ -3192,9 +3278,9 @@ static inline u64 CAVM_NIXX_AF_LFX_SQS_CFG(u64 a)
  *
  * NIX AF Local Function Transmit Configuration Register
  */
-union cavm_nixx_af_lfx_tx_cfg {
+union nixx_af_lfx_tx_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_tx_cfg_s {
+	struct nixx_af_lfx_tx_cfg_s {
 		u64 vlan0_ins_etype                  : 16;
 		u64 vlan1_ins_etype                  : 16;
 		u64 send_tstmp_ena                   : 1;
@@ -3202,12 +3288,12 @@ union cavm_nixx_af_lfx_tx_cfg {
 		u64 lock_ena                         : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_lfx_tx_cfg_s cn; */
+	/* struct nixx_af_lfx_tx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_TX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_TX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_TX_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_TX_CFG(u64 a)
 {
 	return 0x4080 + 0x20000 * a;
 }
@@ -3217,18 +3303,18 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_CFG(u64 a)
  *
  * NIX AF Local Function Transmit Configuration Register
  */
-union cavm_nixx_af_lfx_tx_cfg2 {
+union nixx_af_lfx_tx_cfg2 {
 	u64 u;
-	struct cavm_nixx_af_lfx_tx_cfg2_s {
+	struct nixx_af_lfx_tx_cfg2_s {
 		u64 lmt_ena                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_lfx_tx_cfg2_s cn; */
+	/* struct nixx_af_lfx_tx_cfg2_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_TX_CFG2(u64 a)
+static inline u64 NIXX_AF_LFX_TX_CFG2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_TX_CFG2(u64 a)
+static inline u64 NIXX_AF_LFX_TX_CFG2(u64 a)
 {
 	return 0x4028 + 0x20000 * a;
 }
@@ -3238,18 +3324,18 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_CFG2(u64 a)
  *
  * NIX AF Local Function Transmit Parse Configuration Register
  */
-union cavm_nixx_af_lfx_tx_parse_cfg {
+union nixx_af_lfx_tx_parse_cfg {
 	u64 u;
-	struct cavm_nixx_af_lfx_tx_parse_cfg_s {
+	struct nixx_af_lfx_tx_parse_cfg_s {
 		u64 pkind                            : 6;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_nixx_af_lfx_tx_parse_cfg_s cn; */
+	/* struct nixx_af_lfx_tx_parse_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+static inline u64 NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
 {
 	return 0x4090 + 0x20000 * a;
 }
@@ -3260,18 +3346,18 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
  * NIX AF Local Function Transmit Statistics Registers The last dimension
  * indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
  */
-union cavm_nixx_af_lfx_tx_statx {
+union nixx_af_lfx_tx_statx {
 	u64 u;
-	struct cavm_nixx_af_lfx_tx_statx_s {
+	struct nixx_af_lfx_tx_statx_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_lfx_tx_statx_s cn; */
+	/* struct nixx_af_lfx_tx_statx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+static inline u64 NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
 {
 	return 0x4400 + 0x20000 * a + 8 * b;
 }
@@ -3281,18 +3367,18 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
  *
  * NIX AF LF Transmit Status Register
  */
-union cavm_nixx_af_lfx_tx_status {
+union nixx_af_lfx_tx_status {
 	u64 u;
-	struct cavm_nixx_af_lfx_tx_status_s {
+	struct nixx_af_lfx_tx_status_s {
 		u64 sq_ctx_err                       : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_lfx_tx_status_s cn; */
+	/* struct nixx_af_lfx_tx_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LFX_TX_STATUS(u64 a)
+static inline u64 NIXX_AF_LFX_TX_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LFX_TX_STATUS(u64 a)
+static inline u64 NIXX_AF_LFX_TX_STATUS(u64 a)
 {
 	return 0x4180 + 0x20000 * a;
 }
@@ -3302,20 +3388,20 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_STATUS(u64 a)
  *
  * NIX Admin Function LF Reset Register
  */
-union cavm_nixx_af_lf_rst {
+union nixx_af_lf_rst {
 	u64 u;
-	struct cavm_nixx_af_lf_rst_s {
+	struct nixx_af_lf_rst_s {
 		u64 lf                               : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_nixx_af_lf_rst_s cn; */
+	/* struct nixx_af_lf_rst_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LF_RST(void)
+static inline u64 NIXX_AF_LF_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LF_RST(void)
+static inline u64 NIXX_AF_LF_RST(void)
 {
 	return 0x150;
 }
@@ -3325,21 +3411,21 @@ static inline u64 CAVM_NIXX_AF_LF_RST(void)
  *
  * NIX AF Large Send Offload Configuration Register
  */
-union cavm_nixx_af_lso_cfg {
+union nixx_af_lso_cfg {
 	u64 u;
-	struct cavm_nixx_af_lso_cfg_s {
+	struct nixx_af_lso_cfg_s {
 		u64 tcp_lsf                          : 16;
 		u64 tcp_msf                          : 16;
 		u64 tcp_fsf                          : 16;
 		u64 reserved_48_62                   : 15;
 		u64 enable                           : 1;
 	} s;
-	/* struct cavm_nixx_af_lso_cfg_s cn; */
+	/* struct nixx_af_lso_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
+static inline u64 NIXX_AF_LSO_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
+static inline u64 NIXX_AF_LSO_CFG(void)
 {
 	return 0xa8;
 }
@@ -3357,9 +3443,9 @@ static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
  * [LAYER] value must be specified in ascending [OFFSET] order. * Fields
  * in different layers must be specified in ascending [LAYER] order.
  */
-union cavm_nixx_af_lso_formatx_fieldx {
+union nixx_af_lso_formatx_fieldx {
 	u64 u;
-	struct cavm_nixx_af_lso_formatx_fieldx_s {
+	struct nixx_af_lso_formatx_fieldx_s {
 		u64 offset                           : 8;
 		u64 layer                            : 2;
 		u64 reserved_10_11                   : 2;
@@ -3368,12 +3454,12 @@ union cavm_nixx_af_lso_formatx_fieldx {
 		u64 alg                              : 3;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_lso_formatx_fieldx_s cn; */
+	/* struct nixx_af_lso_formatx_fieldx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+static inline u64 NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+static inline u64 NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
 {
 	return 0x1b00 + 0x10000 * a + 8 * b;
 }
@@ -3395,9 +3481,9 @@ static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
  * NIX_COLORRESULT_E::RED_SEND,  _   byte[3]\<7:4\> |=   [R_VAL]\<3:0\> _
  * byte[3]\<7:4\> &= ~[R_MASK]\<3:0\>
  */
-union cavm_nixx_af_mark_formatx_ctl {
+union nixx_af_mark_formatx_ctl {
 	u64 u;
-	struct cavm_nixx_af_mark_formatx_ctl_s {
+	struct nixx_af_mark_formatx_ctl_s {
 		u64 r_val                            : 4;
 		u64 r_mask                           : 4;
 		u64 y_val                            : 4;
@@ -3405,12 +3491,12 @@ union cavm_nixx_af_mark_formatx_ctl {
 		u64 offset                           : 3;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_mark_formatx_ctl_s cn; */
+	/* struct nixx_af_mark_formatx_ctl_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
+static inline u64 NIXX_AF_MARK_FORMATX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
+static inline u64 NIXX_AF_MARK_FORMATX_CTL(u64 a)
 {
 	return 0x900 + 0x40000 * a;
 }
@@ -3421,18 +3507,18 @@ static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
  * NIX AF Multicast/Mirror Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_mc_mirror_const {
+union nixx_af_mc_mirror_const {
 	u64 u;
-	struct cavm_nixx_af_mc_mirror_const_s {
+	struct nixx_af_mc_mirror_const_s {
 		u64 buf_size                         : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_mc_mirror_const_s cn; */
+	/* struct nixx_af_mc_mirror_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
+static inline u64 NIXX_AF_MC_MIRROR_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
+static inline u64 NIXX_AF_MC_MIRROR_CONST(void)
 {
 	return 0x98;
 }
@@ -3443,9 +3529,9 @@ static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
  * NIX AF Meta Descriptor Queue Committed Information Rate Registers This
  * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_mdqx_cir {
+union nixx_af_mdqx_cir {
 	u64 u;
-	struct cavm_nixx_af_mdqx_cir_s {
+	struct nixx_af_mdqx_cir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -3455,12 +3541,12 @@ union cavm_nixx_af_mdqx_cir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_mdqx_cir_s cn; */
+	/* struct nixx_af_mdqx_cir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
+static inline u64 NIXX_AF_MDQX_CIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
+static inline u64 NIXX_AF_MDQX_CIR(u64 a)
 {
 	return 0x1420 + 0x10000 * a;
 }
@@ -3473,9 +3559,9 @@ static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
  * the MDQ. An MDQ can hold up to 8 packet meta descriptors (PMD) and one
  * flush meta descriptor (FMD).
  */
-union cavm_nixx_af_mdqx_md_debug {
+union nixx_af_mdqx_md_debug {
 	u64 u;
-	struct cavm_nixx_af_mdqx_md_debug_s {
+	struct nixx_af_mdqx_md_debug_s {
 		u64 pkt_len                          : 16;
 		u64 red_algo_override                : 2;
 		u64 shp_dis                          : 1;
@@ -3487,12 +3573,12 @@ union cavm_nixx_af_mdqx_md_debug {
 		u64 md_type                          : 2;
 		u64 reserved_63                      : 1;
 	} s;
-	/* struct cavm_nixx_af_mdqx_md_debug_s cn; */
+	/* struct nixx_af_mdqx_md_debug_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_MD_DEBUG(u64 a)
+static inline u64 NIXX_AF_MDQX_MD_DEBUG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_MD_DEBUG(u64 a)
+static inline u64 NIXX_AF_MDQX_MD_DEBUG(u64 a)
 {
 	return 0x14c0 + 0x10000 * a;
 }
@@ -3502,19 +3588,19 @@ static inline u64 CAVM_NIXX_AF_MDQX_MD_DEBUG(u64 a)
  *
  * NIX AF Meta Descriptor Queue Topology Registers
  */
-union cavm_nixx_af_mdqx_parent {
+union nixx_af_mdqx_parent {
 	u64 u;
-	struct cavm_nixx_af_mdqx_parent_s {
+	struct nixx_af_mdqx_parent_s {
 		u64 reserved_0_15                    : 16;
 		u64 parent                           : 9;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_mdqx_parent_s cn; */
+	/* struct nixx_af_mdqx_parent_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
+static inline u64 NIXX_AF_MDQX_PARENT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
+static inline u64 NIXX_AF_MDQX_PARENT(u64 a)
 {
 	return 0x1480 + 0x10000 * a;
 }
@@ -3525,9 +3611,9 @@ static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
  * NIX AF Meta Descriptor Queue Peak Information Rate Registers This
  * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_mdqx_pir {
+union nixx_af_mdqx_pir {
 	u64 u;
-	struct cavm_nixx_af_mdqx_pir_s {
+	struct nixx_af_mdqx_pir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -3537,12 +3623,12 @@ union cavm_nixx_af_mdqx_pir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_mdqx_pir_s cn; */
+	/* struct nixx_af_mdqx_pir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
+static inline u64 NIXX_AF_MDQX_PIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
+static inline u64 NIXX_AF_MDQX_PIR(u64 a)
 {
 	return 0x1430 + 0x10000 * a;
 }
@@ -3553,20 +3639,20 @@ static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
  * INTERNAL: NIX AF Meta Descriptor 4 Linked List Pointers Debug Register
  * This register has the same bit fields as NIX_AF_TL4()_POINTERS.
  */
-union cavm_nixx_af_mdqx_pointers {
+union nixx_af_mdqx_pointers {
 	u64 u;
-	struct cavm_nixx_af_mdqx_pointers_s {
+	struct nixx_af_mdqx_pointers_s {
 		u64 next                             : 9;
 		u64 reserved_9_15                    : 7;
 		u64 prev                             : 9;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_mdqx_pointers_s cn; */
+	/* struct nixx_af_mdqx_pointers_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_POINTERS(u64 a)
+static inline u64 NIXX_AF_MDQX_POINTERS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_POINTERS(u64 a)
+static inline u64 NIXX_AF_MDQX_POINTERS(u64 a)
 {
 	return 0x1460 + 0x10000 * a;
 }
@@ -3576,20 +3662,20 @@ static inline u64 CAVM_NIXX_AF_MDQX_POINTERS(u64 a)
  *
  * INTERNAL: NIX Meta Descriptor Queue Pointer FIFO State Debug Registers
  */
-union cavm_nixx_af_mdqx_ptr_fifo {
+union nixx_af_mdqx_ptr_fifo {
 	u64 u;
-	struct cavm_nixx_af_mdqx_ptr_fifo_s {
+	struct nixx_af_mdqx_ptr_fifo_s {
 		u64 tail                             : 4;
 		u64 head                             : 4;
 		u64 p_con                            : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_nixx_af_mdqx_ptr_fifo_s cn; */
+	/* struct nixx_af_mdqx_ptr_fifo_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
+static inline u64 NIXX_AF_MDQX_PTR_FIFO(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
+static inline u64 NIXX_AF_MDQX_PTR_FIFO(u64 a)
 {
 	return 0x14d0 + 0x10000 * a;
 }
@@ -3600,18 +3686,18 @@ static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
  * NIX AF Meta Descriptor Queue Scheduling Control State Registers This
  * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
-union cavm_nixx_af_mdqx_sched_state {
+union nixx_af_mdqx_sched_state {
 	u64 u;
-	struct cavm_nixx_af_mdqx_sched_state_s {
+	struct nixx_af_mdqx_sched_state_s {
 		u64 rr_count                         : 25;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_mdqx_sched_state_s cn; */
+	/* struct nixx_af_mdqx_sched_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_MDQX_SCHED_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_MDQX_SCHED_STATE(u64 a)
 {
 	return 0x1440 + 0x10000 * a;
 }
@@ -3622,19 +3708,19 @@ static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
  * NIX AF Meta Descriptor Queue Scheduling Control Registers This
  * register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
-union cavm_nixx_af_mdqx_schedule {
+union nixx_af_mdqx_schedule {
 	u64 u;
-	struct cavm_nixx_af_mdqx_schedule_s {
+	struct nixx_af_mdqx_schedule_s {
 		u64 rr_quantum                       : 24;
 		u64 prio                             : 4;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_nixx_af_mdqx_schedule_s cn; */
+	/* struct nixx_af_mdqx_schedule_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_MDQX_SCHEDULE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_MDQX_SCHEDULE(u64 a)
 {
 	return 0x1400 + 0x10000 * a;
 }
@@ -3645,9 +3731,9 @@ static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
  * NIX AF Meta Descriptor Queue Shaping Control Registers This register
  * has the same bit fields as NIX_AF_TL3()_SHAPE.
  */
-union cavm_nixx_af_mdqx_shape {
+union nixx_af_mdqx_shape {
 	u64 u;
-	struct cavm_nixx_af_mdqx_shape_s {
+	struct nixx_af_mdqx_shape_s {
 		u64 adjust                           : 9;
 		u64 red_algo                         : 2;
 		u64 red_disable                      : 1;
@@ -3657,12 +3743,12 @@ union cavm_nixx_af_mdqx_shape {
 		u64 schedule_list                    : 2;
 		u64 reserved_27_63                   : 37;
 	} s;
-	/* struct cavm_nixx_af_mdqx_shape_s cn; */
+	/* struct nixx_af_mdqx_shape_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
+static inline u64 NIXX_AF_MDQX_SHAPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
+static inline u64 NIXX_AF_MDQX_SHAPE(u64 a)
 {
 	return 0x1410 + 0x10000 * a;
 }
@@ -3674,20 +3760,20 @@ static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
  * the same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must
  * not be written during normal operation.
  */
-union cavm_nixx_af_mdqx_shape_state {
+union nixx_af_mdqx_shape_state {
 	u64 u;
-	struct cavm_nixx_af_mdqx_shape_state_s {
+	struct nixx_af_mdqx_shape_state_s {
 		u64 cir_accum                        : 26;
 		u64 pir_accum                        : 26;
 		u64 color                            : 2;
 		u64 reserved_54_63                   : 10;
 	} s;
-	/* struct cavm_nixx_af_mdqx_shape_state_s cn; */
+	/* struct nixx_af_mdqx_shape_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_MDQX_SHAPE_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_MDQX_SHAPE_STATE(u64 a)
 {
 	return 0x1450 + 0x10000 * a;
 }
@@ -3698,21 +3784,21 @@ static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
  * NIX AF Meta Descriptor Controlled XOFF Registers This register has the
  * same bit fields as NIX_AF_TL1()_SW_XOFF
  */
-union cavm_nixx_af_mdqx_sw_xoff {
+union nixx_af_mdqx_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_mdqx_sw_xoff_s {
+	struct nixx_af_mdqx_sw_xoff_s {
 		u64 xoff                             : 1;
 		u64 drain                            : 1;
 		u64 reserved_2                       : 1;
 		u64 drain_irq                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_mdqx_sw_xoff_s cn; */
+	/* struct nixx_af_mdqx_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_MDQX_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_MDQX_SW_XOFF(u64 a)
 {
 	return 0x1470 + 0x10000 * a;
 }
@@ -3723,30 +3809,50 @@ static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
  * NIX AF Meta Descriptor Queue Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_mdq_const {
+union nixx_af_mdq_const {
 	u64 u;
-	struct cavm_nixx_af_mdq_const_s {
+	struct nixx_af_mdq_const_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_mdq_const_s cn; */
+	/* struct nixx_af_mdq_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_MDQ_CONST(void)
+static inline u64 NIXX_AF_MDQ_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_MDQ_CONST(void)
+static inline u64 NIXX_AF_MDQ_CONST(void)
 {
 	return 0x90;
 }
 
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq_md_count
+ *
+ * NIX AF MDQ MD COUNT Registers
+ */
+union nixx_af_mdq_md_count {
+	u64 u;
+	struct nixx_af_mdq_md_count_s {
+		u64 count                            : 64;
+	} s;
+	/* struct nixx_af_mdq_md_count_s cn; */
+};
+
+static inline u64 NIXX_AF_MDQ_MD_COUNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_MDQ_MD_COUNT(void)
+{
+	return 0xda0;
+}
+
 /**
  * Register (RVU_PF_BAR0) nix#_af_ndc_cfg
  *
  * NIX AF General Configuration Register
  */
-union cavm_nixx_af_ndc_cfg {
+union nixx_af_ndc_cfg {
 	u64 u;
-	struct cavm_nixx_af_ndc_cfg_s {
+	struct nixx_af_ndc_cfg_s {
 		u64 ndc_ign_pois                     : 1;
 		u64 byp_sq                           : 1;
 		u64 byp_sqb                          : 1;
@@ -3763,12 +3869,12 @@ union cavm_nixx_af_ndc_cfg {
 		u64 byp_qints                        : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_nixx_af_ndc_cfg_s cn; */
+	/* struct nixx_af_ndc_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
+static inline u64 NIXX_AF_NDC_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
+static inline u64 NIXX_AF_NDC_CFG(void)
 {
 	return 0x18;
 }
@@ -3779,20 +3885,20 @@ static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
  * NIX AF Receive NDC Sync Register Used to synchronize the NIX receive
  * NDC (NDC_IDX_E::NIX()_RX).
  */
-union cavm_nixx_af_ndc_rx_sync {
+union nixx_af_ndc_rx_sync {
 	u64 u;
-	struct cavm_nixx_af_ndc_rx_sync_s {
+	struct nixx_af_ndc_rx_sync_s {
 		u64 lf                               : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_nixx_af_ndc_rx_sync_s cn; */
+	/* struct nixx_af_ndc_rx_sync_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
+static inline u64 NIXX_AF_NDC_RX_SYNC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
+static inline u64 NIXX_AF_NDC_RX_SYNC(void)
 {
 	return 0x3e0;
 }
@@ -3803,20 +3909,20 @@ static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
  * NIX AF NDC_TX Sync Register Used to synchronize the NIX transmit NDC
  * (NDC_IDX_E::NIX()_TX).
  */
-union cavm_nixx_af_ndc_tx_sync {
+union nixx_af_ndc_tx_sync {
 	u64 u;
-	struct cavm_nixx_af_ndc_tx_sync_s {
+	struct nixx_af_ndc_tx_sync_s {
 		u64 lf                               : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_nixx_af_ndc_tx_sync_s cn; */
+	/* struct nixx_af_ndc_tx_sync_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
+static inline u64 NIXX_AF_NDC_TX_SYNC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
+static inline u64 NIXX_AF_NDC_TX_SYNC(void)
 {
 	return 0x3f0;
 }
@@ -3825,41 +3931,265 @@ static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
  * Register (RVU_PF_BAR0) nix#_af_norm_tx_fifo_status
  *
  * NIX AF Normal Transmit FIFO Status Register Status of FIFO which
- * transmits normal (potentially preemptable) packets to CGX and LBK.
+ * transmits normal packets to CGX and LBK.
  */
-union cavm_nixx_af_norm_tx_fifo_status {
+union nixx_af_norm_tx_fifo_status {
 	u64 u;
-	struct cavm_nixx_af_norm_tx_fifo_status_s {
+	struct nixx_af_norm_tx_fifo_status_s {
 		u64 count                            : 12;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_nixx_af_norm_tx_fifo_status_s cn; */
+	/* struct nixx_af_norm_tx_fifo_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_NORM_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_NORM_TX_FIFO_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_NORM_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_NORM_TX_FIFO_STATUS(void)
 {
 	return 0x648;
 }
 
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_exp
+ *
+ * INTERNAL: NIX AF PQ Arb Link EXPRESS Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_exp {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_exp_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_exp_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_EXP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_EXP(u64 a)
+{
+	return 0xce8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_nrm
+ *
+ * INTERNAL: NIX AF PQ Arb Link NORMAL Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_nrm {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_nrm_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_nrm_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_NRM(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_NRM(u64 a)
+{
+	return 0xce0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq#_dbg_arb_link_sdp
+ *
+ * INTERNAL: NIX AF PQ Arb Link SDP Debug Register
+ */
+union nixx_af_pqx_dbg_arb_link_sdp {
+	u64 u;
+	struct nixx_af_pqx_dbg_arb_link_sdp_s {
+		u64 req                              : 1;
+		u64 act_c_con                        : 1;
+		u64 cnt                              : 2;
+		u64 reserved_4_5                     : 2;
+		u64 rr_mask                          : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct nixx_af_pqx_dbg_arb_link_sdp_s cn; */
+};
+
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_SDP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQX_DBG_ARB_LINK_SDP(u64 a)
+{
+	return 0xcf0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_crd_rdy_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Credit Ready Registers  NIX AF PQ ARB
+ * Credit ready register
+ */
+union nixx_af_pq_arb_crd_rdy_debug {
+	u64 u;
+	struct nixx_af_pq_arb_crd_rdy_debug_s {
+		u64 node_crd_rdy                     : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_crd_rdy_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_CRD_RDY_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_CRD_RDY_DEBUG(void)
+{
+	return 0xf10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_dwrr_msk_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB DWRR mask set read only debug Registers
+ */
+union nixx_af_pq_arb_dwrr_msk_debug {
+	u64 u;
+	struct nixx_af_pq_arb_dwrr_msk_debug_s {
+		u64 node_dwrr_mask_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_dwrr_msk_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_DWRR_MSK_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_DWRR_MSK_DEBUG(void)
+{
+	return 0xf30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_node_gnt_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Grant vector Registers
+ */
+union nixx_af_pq_arb_node_gnt_debug {
+	u64 u;
+	struct nixx_af_pq_arb_node_gnt_debug_s {
+		u64 node_grant_vec                   : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_node_gnt_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_NODE_GNT_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_NODE_GNT_DEBUG(void)
+{
+	return 0xf20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_node_req_debug
+ *
+ * INTERNAL: NIX AF PQ_ARB Node Request Debug Registers  NIX AF PQ ARB
+ * Node Request Debug register
+ */
+union nixx_af_pq_arb_node_req_debug {
+	u64 u;
+	struct nixx_af_pq_arb_node_req_debug_s {
+		u64 node_req                         : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_node_req_debug_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_NODE_REQ_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_NODE_REQ_DEBUG(void)
+{
+	return 0xf00;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_arb_shape_vld_dbg
+ *
+ * INTERNAL: NIX AF PQ_ARB shape valid set Register
+ */
+union nixx_af_pq_arb_shape_vld_dbg {
+	u64 u;
+	struct nixx_af_pq_arb_shape_vld_dbg_s {
+		u64 node_shape_vld_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_arb_shape_vld_dbg_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_ARB_SHAPE_VLD_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_ARB_SHAPE_VLD_DBG(void)
+{
+	return 0xf40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_dbg_arb_0
+ *
+ * INTERNAL: NIX AF PQ Arb Debug 0 Register
+ */
+union nixx_af_pq_dbg_arb_0 {
+	u64 u;
+	struct nixx_af_pq_dbg_arb_0_s {
+		u64 rr_mask_clr                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_pq_dbg_arb_0_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_DBG_ARB_0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_DBG_ARB_0(void)
+{
+	return 0xcf8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pq_lnk_#_dwrr_msk_dbg
+ *
+ * INTERNAL: NIX AF PQ_ARB Physical Link DWRR MASK Registers
+ */
+union nixx_af_pq_lnk_x_dwrr_msk_dbg {
+	u64 u;
+	struct nixx_af_pq_lnk_x_dwrr_msk_dbg_s {
+		u64 link_dwrr_mask_set               : 28;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct nixx_af_pq_lnk_x_dwrr_msk_dbg_s cn; */
+};
+
+static inline u64 NIXX_AF_PQ_LNK_X_DWRR_MSK_DBG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_PQ_LNK_X_DWRR_MSK_DBG(u64 a)
+{
+	return 0x1100 + 0x10000 * a;
+}
+
 /**
  * Register (RVU_PF_BAR0) nix#_af_pse_400_rate_divider
  *
  * INTERNAL: NIX AF PSE 400 Rate Divider Register
  */
-union cavm_nixx_af_pse_400_rate_divider {
+union nixx_af_pse_400_rate_divider {
 	u64 u;
-	struct cavm_nixx_af_pse_400_rate_divider_s {
+	struct nixx_af_pse_400_rate_divider_s {
 		u64 rate_div_cfg                     : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_nixx_af_pse_400_rate_divider_s cn; */
+	/* struct nixx_af_pse_400_rate_divider_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
+static inline u64 NIXX_AF_PSE_400_RATE_DIVIDER(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
+static inline u64 NIXX_AF_PSE_400_RATE_DIVIDER(void)
 {
 	return 0x830;
 }
@@ -3870,17 +4200,17 @@ static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
  * NIX AF Active Cycles Register These registers are indexed by the
  * conditional clock domain number.
  */
-union cavm_nixx_af_pse_active_cycles_pc {
+union nixx_af_pse_active_cycles_pc {
 	u64 u;
-	struct cavm_nixx_af_pse_active_cycles_pc_s {
+	struct nixx_af_pse_active_cycles_pc_s {
 		u64 act_cyc                          : 64;
 	} s;
-	/* struct cavm_nixx_af_pse_active_cycles_pc_s cn; */
+	/* struct nixx_af_pse_active_cycles_pc_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+static inline u64 NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+static inline u64 NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
 {
 	return 0x8c0;
 }
@@ -3890,21 +4220,45 @@ static inline u64 CAVM_NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
  *
  * INTERNAL: NIX AF PSE Backpressure Test 0 Register
  */
-union cavm_nixx_af_pse_bp_test0 {
+union nixx_af_pse_bp_test0 {
 	u64 u;
-	struct cavm_nixx_af_pse_bp_test0_s {
+	struct nixx_af_pse_bp_test0_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct nixx_af_pse_bp_test0_cn96xxp1 {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
 		u64 reserved_24_59                   : 36;
 		u64 enable                           : 4;
-	} s;
-	/* struct cavm_nixx_af_pse_bp_test0_s cn; */
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test0_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_19                   : 4;
+		u64 bp_cfg                           : 12;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_57                   : 2;
+		u64 enable                           : 6;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test0_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test0_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test0_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST0(void)
+static inline u64 NIXX_AF_PSE_BP_TEST0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST0(void)
+static inline u64 NIXX_AF_PSE_BP_TEST0(void)
 {
 	return 0x840;
 }
@@ -3914,21 +4268,47 @@ static inline u64 CAVM_NIXX_AF_PSE_BP_TEST0(void)
  *
  * INTERNAL: NIX AF PSE Backpressure Test 1 Register
  */
-union cavm_nixx_af_pse_bp_test1 {
+union nixx_af_pse_bp_test1 {
 	u64 u;
-	struct cavm_nixx_af_pse_bp_test1_s {
+	struct nixx_af_pse_bp_test1_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test1_cn96xxp1 {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
 		u64 reserved_24_59                   : 36;
 		u64 enable                           : 4;
-	} s;
-	/* struct cavm_nixx_af_pse_bp_test1_s cn; */
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test1_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test1_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test1_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test1_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST1(void)
+static inline u64 NIXX_AF_PSE_BP_TEST1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST1(void)
+static inline u64 NIXX_AF_PSE_BP_TEST1(void)
 {
 	return 0x850;
 }
@@ -3938,21 +4318,47 @@ static inline u64 CAVM_NIXX_AF_PSE_BP_TEST1(void)
  *
  * INTERNAL: NIX AF PSE Backpressure Test 2 Register
  */
-union cavm_nixx_af_pse_bp_test2 {
+union nixx_af_pse_bp_test2 {
 	u64 u;
-	struct cavm_nixx_af_pse_bp_test2_s {
+	struct nixx_af_pse_bp_test2_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test2_cn96xxp1 {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
 		u64 reserved_24_59                   : 36;
 		u64 enable                           : 4;
-	} s;
-	/* struct cavm_nixx_af_pse_bp_test2_s cn; */
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test2_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test2_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test2_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test2_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST2(void)
+static inline u64 NIXX_AF_PSE_BP_TEST2(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST2(void)
+static inline u64 NIXX_AF_PSE_BP_TEST2(void)
 {
 	return 0x860;
 }
@@ -3962,21 +4368,47 @@ static inline u64 CAVM_NIXX_AF_PSE_BP_TEST2(void)
  *
  * INTERNAL: NIX AF PSE Backpressure Test 3 Register
  */
-union cavm_nixx_af_pse_bp_test3 {
+union nixx_af_pse_bp_test3 {
 	u64 u;
-	struct cavm_nixx_af_pse_bp_test3_s {
+	struct nixx_af_pse_bp_test3_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	struct nixx_af_pse_bp_test3_cn96xxp1 {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
 		u64 reserved_24_59                   : 36;
 		u64 enable                           : 4;
-	} s;
-	/* struct cavm_nixx_af_pse_bp_test3_s cn; */
+	} cn96xxp1;
+	struct nixx_af_pse_bp_test3_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 10;
+		u64 reserved_26_31                   : 6;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_58                   : 3;
+		u64 enable                           : 5;
+	} cn96xxp3;
+	/* struct nixx_af_pse_bp_test3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_bp_test3_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_pse_bp_test3_cnf95xxp2 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_55                   : 24;
+		u64 reserved_56_59                   : 4;
+		u64 enable                           : 4;
+	} cnf95xxp2;
+	/* struct nixx_af_pse_bp_test3_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST3(void)
+static inline u64 NIXX_AF_PSE_BP_TEST3(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_BP_TEST3(void)
+static inline u64 NIXX_AF_PSE_BP_TEST3(void)
 {
 	return 0x870;
 }
@@ -3986,18 +4418,18 @@ static inline u64 CAVM_NIXX_AF_PSE_BP_TEST3(void)
  *
  * NIX AF PSE Channel Level Register
  */
-union cavm_nixx_af_pse_channel_level {
+union nixx_af_pse_channel_level {
 	u64 u;
-	struct cavm_nixx_af_pse_channel_level_s {
+	struct nixx_af_pse_channel_level_s {
 		u64 bp_level                         : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_pse_channel_level_s cn; */
+	/* struct nixx_af_pse_channel_level_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
+static inline u64 NIXX_AF_PSE_CHANNEL_LEVEL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
+static inline u64 NIXX_AF_PSE_CHANNEL_LEVEL(void)
 {
 	return 0x800;
 }
@@ -4008,20 +4440,20 @@ static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
  * NIX AF PSE Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_pse_const {
+union nixx_af_pse_const {
 	u64 u;
-	struct cavm_nixx_af_pse_const_s {
+	struct nixx_af_pse_const_s {
 		u64 levels                           : 4;
 		u64 reserved_4_7                     : 4;
 		u64 mark_formats                     : 8;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_pse_const_s cn; */
+	/* struct nixx_af_pse_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_CONST(void)
+static inline u64 NIXX_AF_PSE_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_CONST(void)
+static inline u64 NIXX_AF_PSE_CONST(void)
 {
 	return 0x60;
 }
@@ -4031,17 +4463,17 @@ static inline u64 CAVM_NIXX_AF_PSE_CONST(void)
  *
  * INTERNAL: AF PSE ECO Register
  */
-union cavm_nixx_af_pse_eco {
+union nixx_af_pse_eco {
 	u64 u;
-	struct cavm_nixx_af_pse_eco_s {
+	struct nixx_af_pse_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_pse_eco_s cn; */
+	/* struct nixx_af_pse_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_ECO(void)
+static inline u64 NIXX_AF_PSE_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_ECO(void)
+static inline u64 NIXX_AF_PSE_ECO(void)
 {
 	return 0x5d0;
 }
@@ -4049,22 +4481,23 @@ static inline u64 CAVM_NIXX_AF_PSE_ECO(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_pse_expr_bp_test
  *
- * INTERNAL: NIX AF PSE Express Backpressure Test Register
+ * INTERNAL: NIX AF PSE Express Backpressure Test Register  Internal:
+ * 802.3br frame preemption/express path is defeatured.
  */
-union cavm_nixx_af_pse_expr_bp_test {
+union nixx_af_pse_expr_bp_test {
 	u64 u;
-	struct cavm_nixx_af_pse_expr_bp_test_s {
+	struct nixx_af_pse_expr_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 32;
 		u64 enable                           : 16;
 	} s;
-	/* struct cavm_nixx_af_pse_expr_bp_test_s cn; */
+	/* struct nixx_af_pse_expr_bp_test_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_EXPR_BP_TEST(void)
+static inline u64 NIXX_AF_PSE_EXPR_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_EXPR_BP_TEST(void)
+static inline u64 NIXX_AF_PSE_EXPR_BP_TEST(void)
 {
 	return 0x890;
 }
@@ -4074,20 +4507,35 @@ static inline u64 CAVM_NIXX_AF_PSE_EXPR_BP_TEST(void)
  *
  * INTERNAL: NIX AF PSE Normal Backpressure Test Register
  */
-union cavm_nixx_af_pse_norm_bp_test {
+union nixx_af_pse_norm_bp_test {
 	u64 u;
-	struct cavm_nixx_af_pse_norm_bp_test_s {
+	struct nixx_af_pse_norm_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 32;
-		u64 enable                           : 16;
+		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_pse_norm_bp_test_s cn; */
+	struct nixx_af_pse_norm_bp_test_cn96xxp1 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} cn96xxp1;
+	struct nixx_af_pse_norm_bp_test_cn96xxp3 {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 12;
+		u64 reserved_28_57                   : 30;
+		u64 enable                           : 6;
+	} cn96xxp3;
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp3 cn98xx; */
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_pse_norm_bp_test_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_NORM_BP_TEST(void)
+static inline u64 NIXX_AF_PSE_NORM_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_NORM_BP_TEST(void)
+static inline u64 NIXX_AF_PSE_NORM_BP_TEST(void)
 {
 	return 0x880;
 }
@@ -4097,19 +4545,19 @@ static inline u64 CAVM_NIXX_AF_PSE_NORM_BP_TEST(void)
  *
  * NIX AF PSE Shaper Configuration Register
  */
-union cavm_nixx_af_pse_shaper_cfg {
+union nixx_af_pse_shaper_cfg {
 	u64 u;
-	struct cavm_nixx_af_pse_shaper_cfg_s {
+	struct nixx_af_pse_shaper_cfg_s {
 		u64 red_send_as_yellow               : 1;
 		u64 color_aware                      : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_nixx_af_pse_shaper_cfg_s cn; */
+	/* struct nixx_af_pse_shaper_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
+static inline u64 NIXX_AF_PSE_SHAPER_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
+static inline u64 NIXX_AF_PSE_SHAPER_CFG(void)
 {
 	return 0x810;
 }
@@ -4120,9 +4568,9 @@ static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
  * NIX AF RAS Interrupt Register This register is intended for delivery
  * of RAS events to the SCP, so should be ignored by OS drivers.
  */
-union cavm_nixx_af_ras {
+union nixx_af_ras {
 	u64 u;
-	struct cavm_nixx_af_ras_s {
+	struct nixx_af_ras_s {
 		u64 rx_mce_poison                    : 1;
 		u64 rx_mcast_wqe_poison              : 1;
 		u64 rx_mirror_wqe_poison             : 1;
@@ -4134,12 +4582,12 @@ union cavm_nixx_af_ras {
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_ras_s cn; */
+	/* struct nixx_af_ras_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RAS(void)
+static inline u64 NIXX_AF_RAS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RAS(void)
+static inline u64 NIXX_AF_RAS(void)
 {
 	return 0x1a0;
 }
@@ -4150,9 +4598,9 @@ static inline u64 CAVM_NIXX_AF_RAS(void)
  * NIX AF RAS Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_af_ras_ena_w1c {
+union nixx_af_ras_ena_w1c {
 	u64 u;
-	struct cavm_nixx_af_ras_ena_w1c_s {
+	struct nixx_af_ras_ena_w1c_s {
 		u64 rx_mce_poison                    : 1;
 		u64 rx_mcast_wqe_poison              : 1;
 		u64 rx_mirror_wqe_poison             : 1;
@@ -4164,12 +4612,12 @@ union cavm_nixx_af_ras_ena_w1c {
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_ras_ena_w1c_s cn; */
+	/* struct nixx_af_ras_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
+static inline u64 NIXX_AF_RAS_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
+static inline u64 NIXX_AF_RAS_ENA_W1C(void)
 {
 	return 0x1b8;
 }
@@ -4180,9 +4628,9 @@ static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
  * NIX AF RAS Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_nixx_af_ras_ena_w1s {
+union nixx_af_ras_ena_w1s {
 	u64 u;
-	struct cavm_nixx_af_ras_ena_w1s_s {
+	struct nixx_af_ras_ena_w1s_s {
 		u64 rx_mce_poison                    : 1;
 		u64 rx_mcast_wqe_poison              : 1;
 		u64 rx_mirror_wqe_poison             : 1;
@@ -4194,12 +4642,12 @@ union cavm_nixx_af_ras_ena_w1s {
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_ras_ena_w1s_s cn; */
+	/* struct nixx_af_ras_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
+static inline u64 NIXX_AF_RAS_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
+static inline u64 NIXX_AF_RAS_ENA_W1S(void)
 {
 	return 0x1b0;
 }
@@ -4209,9 +4657,9 @@ static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
  *
  * NIX AF RAS Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_nixx_af_ras_w1s {
+union nixx_af_ras_w1s {
 	u64 u;
-	struct cavm_nixx_af_ras_w1s_s {
+	struct nixx_af_ras_w1s_s {
 		u64 rx_mce_poison                    : 1;
 		u64 rx_mcast_wqe_poison              : 1;
 		u64 rx_mirror_wqe_poison             : 1;
@@ -4223,12 +4671,12 @@ union cavm_nixx_af_ras_w1s {
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_ras_w1s_s cn; */
+	/* struct nixx_af_ras_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RAS_W1S(void)
+static inline u64 NIXX_AF_RAS_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RAS_W1S(void)
+static inline u64 NIXX_AF_RAS_W1S(void)
 {
 	return 0x1a8;
 }
@@ -4238,9 +4686,9 @@ static inline u64 CAVM_NIXX_AF_RAS_W1S(void)
  *
  * INTERNAL: NIX AF REB Backpressure Test Registers
  */
-union cavm_nixx_af_reb_bp_testx {
+union nixx_af_reb_bp_testx {
 	u64 u;
-	struct cavm_nixx_af_reb_bp_testx_s {
+	struct nixx_af_reb_bp_testx_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
@@ -4248,12 +4696,12 @@ union cavm_nixx_af_reb_bp_testx {
 		u64 enable                           : 4;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_nixx_af_reb_bp_testx_s cn; */
+	/* struct nixx_af_reb_bp_testx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_REB_BP_TESTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_REB_BP_TESTX(u64 a)
 {
 	return 0x4840 + 0x10000 * a;
 }
@@ -4264,18 +4712,18 @@ static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
  * NIX AF RQ Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_rq_const {
+union nixx_af_rq_const {
 	u64 u;
-	struct cavm_nixx_af_rq_const_s {
+	struct nixx_af_rq_const_s {
 		u64 queues_per_lf                    : 24;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_rq_const_s cn; */
+	/* struct nixx_af_rq_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RQ_CONST(void)
+static inline u64 NIXX_AF_RQ_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RQ_CONST(void)
+static inline u64 NIXX_AF_RQ_CONST(void)
 {
 	return 0x50;
 }
@@ -4285,9 +4733,9 @@ static inline u64 CAVM_NIXX_AF_RQ_CONST(void)
  *
  * INTERNAL: NIX AF REB Backpressure Test Registers
  */
-union cavm_nixx_af_rqm_bp_test {
+union nixx_af_rqm_bp_test {
 	u64 u;
-	struct cavm_nixx_af_rqm_bp_test_s {
+	struct nixx_af_rqm_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 16;
@@ -4295,12 +4743,12 @@ union cavm_nixx_af_rqm_bp_test {
 		u64 enable                           : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_nixx_af_rqm_bp_test_s cn; */
+	/* struct nixx_af_rqm_bp_test_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RQM_BP_TEST(void)
+static inline u64 NIXX_AF_RQM_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RQM_BP_TEST(void)
+static inline u64 NIXX_AF_RQM_BP_TEST(void)
 {
 	return 0x4880;
 }
@@ -4310,17 +4758,17 @@ static inline u64 CAVM_NIXX_AF_RQM_BP_TEST(void)
  *
  * INTERNAL: AF RQM ECO Register
  */
-union cavm_nixx_af_rqm_eco {
+union nixx_af_rqm_eco {
 	u64 u;
-	struct cavm_nixx_af_rqm_eco_s {
+	struct nixx_af_rqm_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_rqm_eco_s cn; */
+	/* struct nixx_af_rqm_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
+static inline u64 NIXX_AF_RQM_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
+static inline u64 NIXX_AF_RQM_ECO(void)
 {
 	return 0x5a0;
 }
@@ -4331,18 +4779,18 @@ static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
  * NIX AF RVU Interrupt Register This register contains RVU error
  * interrupt summary bits.
  */
-union cavm_nixx_af_rvu_int {
+union nixx_af_rvu_int {
 	u64 u;
-	struct cavm_nixx_af_rvu_int_s {
+	struct nixx_af_rvu_int_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rvu_int_s cn; */
+	/* struct nixx_af_rvu_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RVU_INT(void)
+static inline u64 NIXX_AF_RVU_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RVU_INT(void)
+static inline u64 NIXX_AF_RVU_INT(void)
 {
 	return 0x1c0;
 }
@@ -4353,18 +4801,18 @@ static inline u64 CAVM_NIXX_AF_RVU_INT(void)
  * NIX AF RVU Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_af_rvu_int_ena_w1c {
+union nixx_af_rvu_int_ena_w1c {
 	u64 u;
-	struct cavm_nixx_af_rvu_int_ena_w1c_s {
+	struct nixx_af_rvu_int_ena_w1c_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rvu_int_ena_w1c_s cn; */
+	/* struct nixx_af_rvu_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_RVU_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
+static inline u64 NIXX_AF_RVU_INT_ENA_W1C(void)
 {
 	return 0x1d8;
 }
@@ -4375,18 +4823,18 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
  * NIX AF RVU Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_nixx_af_rvu_int_ena_w1s {
+union nixx_af_rvu_int_ena_w1s {
 	u64 u;
-	struct cavm_nixx_af_rvu_int_ena_w1s_s {
+	struct nixx_af_rvu_int_ena_w1s_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rvu_int_ena_w1s_s cn; */
+	/* struct nixx_af_rvu_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_RVU_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
+static inline u64 NIXX_AF_RVU_INT_ENA_W1S(void)
 {
 	return 0x1d0;
 }
@@ -4396,18 +4844,18 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
  *
  * NIX AF RVU Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_nixx_af_rvu_int_w1s {
+union nixx_af_rvu_int_w1s {
 	u64 u;
-	struct cavm_nixx_af_rvu_int_w1s_s {
+	struct nixx_af_rvu_int_w1s_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rvu_int_w1s_s cn; */
+	/* struct nixx_af_rvu_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
+static inline u64 NIXX_AF_RVU_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
+static inline u64 NIXX_AF_RVU_INT_W1S(void)
 {
 	return 0x1c8;
 }
@@ -4419,9 +4867,9 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
  * allows software to lookup the reverse mapping from VF/PF slot to LF.
  * The forward mapping is programmed with NIX_PRIV_LF()_CFG.
  */
-union cavm_nixx_af_rvu_lf_cfg_debug {
+union nixx_af_rvu_lf_cfg_debug {
 	u64 u;
-	struct cavm_nixx_af_rvu_lf_cfg_debug_s {
+	struct nixx_af_rvu_lf_cfg_debug_s {
 		u64 lf                               : 12;
 		u64 lf_valid                         : 1;
 		u64 exec                             : 1;
@@ -4430,12 +4878,12 @@ union cavm_nixx_af_rvu_lf_cfg_debug {
 		u64 pf_func                          : 16;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_rvu_lf_cfg_debug_s cn; */
+	/* struct nixx_af_rvu_lf_cfg_debug_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
+static inline u64 NIXX_AF_RVU_LF_CFG_DEBUG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
+static inline u64 NIXX_AF_RVU_LF_CFG_DEBUG(void)
 {
 	return 0x8000030;
 }
@@ -4446,17 +4894,17 @@ static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
  * NIX AF Active Cycles Register These registers are indexed by the
  * conditional clock domain number.
  */
-union cavm_nixx_af_rx_active_cycles_pcx {
+union nixx_af_rx_active_cycles_pcx {
 	u64 u;
-	struct cavm_nixx_af_rx_active_cycles_pcx_s {
+	struct nixx_af_rx_active_cycles_pcx_s {
 		u64 act_cyc                          : 64;
 	} s;
-	/* struct cavm_nixx_af_rx_active_cycles_pcx_s cn; */
+	/* struct nixx_af_rx_active_cycles_pcx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+static inline u64 NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+static inline u64 NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
 {
 	return 0x4800 + 0x10000 * a;
 }
@@ -4466,18 +4914,18 @@ static inline u64 CAVM_NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
  *
  * NIX AF Receive Backpressure ID Status Registers
  */
-union cavm_nixx_af_rx_bpidx_status {
+union nixx_af_rx_bpidx_status {
 	u64 u;
-	struct cavm_nixx_af_rx_bpidx_status_s {
+	struct nixx_af_rx_bpidx_status_s {
 		u64 aura_cnt                         : 32;
 		u64 cq_cnt                           : 32;
 	} s;
-	/* struct cavm_nixx_af_rx_bpidx_status_s cn; */
+	/* struct nixx_af_rx_bpidx_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_BPIDX_STATUS(u64 a)
+static inline u64 NIXX_AF_RX_BPIDX_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_BPIDX_STATUS(u64 a)
+static inline u64 NIXX_AF_RX_BPIDX_STATUS(u64 a)
 {
 	return 0x1a20 + 0x20000 * a;
 }
@@ -4487,18 +4935,18 @@ static inline u64 CAVM_NIXX_AF_RX_BPIDX_STATUS(u64 a)
  *
  * NIX AF Receive Configuration Register
  */
-union cavm_nixx_af_rx_cfg {
+union nixx_af_rx_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_cfg_s {
+	struct nixx_af_rx_cfg_s {
 		u64 cbp_ena                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rx_cfg_s cn; */
+	/* struct nixx_af_rx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_CFG(void)
+static inline u64 NIXX_AF_RX_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_CFG(void)
+static inline u64 NIXX_AF_RX_CFG(void)
 {
 	return 0xd0;
 }
@@ -4508,9 +4956,9 @@ static inline u64 CAVM_NIXX_AF_RX_CFG(void)
  *
  * NIX AF Receive Channel Configuration Registers
  */
-union cavm_nixx_af_rx_chanx_cfg {
+union nixx_af_rx_chanx_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_chanx_cfg_s {
+	struct nixx_af_rx_chanx_cfg_s {
 		u64 bpid                             : 9;
 		u64 reserved_9_15                    : 7;
 		u64 bp_ena                           : 1;
@@ -4518,12 +4966,12 @@ union cavm_nixx_af_rx_chanx_cfg {
 		u64 imp                              : 1;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_rx_chanx_cfg_s cn; */
+	/* struct nixx_af_rx_chanx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_CHANX_CFG(u64 a)
+static inline u64 NIXX_AF_RX_CHANX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_CHANX_CFG(u64 a)
+static inline u64 NIXX_AF_RX_CHANX_CFG(u64 a)
 {
 	return 0x1a30 + 0x8000 * a;
 }
@@ -4533,18 +4981,18 @@ static inline u64 CAVM_NIXX_AF_RX_CHANX_CFG(u64 a)
  *
  * NIX AF Receive CPT Credit Register
  */
-union cavm_nixx_af_rx_cptx_credit {
+union nixx_af_rx_cptx_credit {
 	u64 u;
-	struct cavm_nixx_af_rx_cptx_credit_s {
+	struct nixx_af_rx_cptx_credit_s {
 		u64 inst_cred_cnt                    : 22;
 		u64 reserved_22_63                   : 42;
 	} s;
-	/* struct cavm_nixx_af_rx_cptx_credit_s cn; */
+	/* struct nixx_af_rx_cptx_credit_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
+static inline u64 NIXX_AF_RX_CPTX_CREDIT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
+static inline u64 NIXX_AF_RX_CPTX_CREDIT(u64 a)
 {
 	return 0x360 + 8 * a;
 }
@@ -4563,19 +5011,19 @@ static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
  * ncbi_cmd.paddr = 1; // Physical address ncbi_cmd.addr = cpt_addr;
  * \</pre\>
  */
-union cavm_nixx_af_rx_cptx_inst_qsel {
+union nixx_af_rx_cptx_inst_qsel {
 	u64 u;
-	struct cavm_nixx_af_rx_cptx_inst_qsel_s {
+	struct nixx_af_rx_cptx_inst_qsel_s {
 		u64 slot                             : 8;
 		u64 pf_func                          : 16;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_rx_cptx_inst_qsel_s cn; */
+	/* struct nixx_af_rx_cptx_inst_qsel_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+static inline u64 NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+static inline u64 NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
 {
 	return 0x320 + 8 * a;
 }
@@ -4587,20 +5035,20 @@ static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
  * information in NPC_RESULT_S to identify an inner IPv4 header.
  * Typically the same as NPC_PCK_DEF_IIP4.
  */
-union cavm_nixx_af_rx_def_iip4 {
+union nixx_af_rx_def_iip4 {
 	u64 u;
-	struct cavm_nixx_af_rx_def_iip4_s {
+	struct nixx_af_rx_def_iip4_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_iip4_s cn; */
+	/* struct nixx_af_rx_def_iip4_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
+static inline u64 NIXX_AF_RX_DEF_IIP4(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
+static inline u64 NIXX_AF_RX_DEF_IIP4(void)
 {
 	return 0x220;
 }
@@ -4611,20 +5059,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
  * NIX AF Receive Inner IPv6 Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an inner IPv6 header.
  */
-union cavm_nixx_af_rx_def_iip6 {
+union nixx_af_rx_def_iip6 {
 	u64 u;
-	struct cavm_nixx_af_rx_def_iip6_s {
+	struct nixx_af_rx_def_iip6_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_iip6_s cn; */
+	/* struct nixx_af_rx_def_iip6_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
+static inline u64 NIXX_AF_RX_DEF_IIP6(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
+static inline u64 NIXX_AF_RX_DEF_IIP6(void)
 {
 	return 0x240;
 }
@@ -4635,9 +5083,9 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
  * INTERNAL: NIX AF Receive IPSEC Header Definition Registers  Internal:
  * Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_rx_def_ipsecx {
+union nixx_af_rx_def_ipsecx {
 	u64 u;
-	struct cavm_nixx_af_rx_def_ipsecx_s {
+	struct nixx_af_rx_def_ipsecx_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
@@ -4646,12 +5094,12 @@ union cavm_nixx_af_rx_def_ipsecx {
 		u64 spi_nz                           : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_nixx_af_rx_def_ipsecx_s cn; */
+	/* struct nixx_af_rx_def_ipsecx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
+static inline u64 NIXX_AF_RX_DEF_IPSECX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
+static inline u64 NIXX_AF_RX_DEF_IPSECX(u64 a)
 {
 	return 0x2b0 + 8 * a;
 }
@@ -4662,20 +5110,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
  * NIX AF Receive Inner SCTP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an inner SCTP header.
  */
-union cavm_nixx_af_rx_def_isctp {
+union nixx_af_rx_def_isctp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_isctp_s {
+	struct nixx_af_rx_def_isctp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_isctp_s cn; */
+	/* struct nixx_af_rx_def_isctp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
+static inline u64 NIXX_AF_RX_DEF_ISCTP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
+static inline u64 NIXX_AF_RX_DEF_ISCTP(void)
 {
 	return 0x2a0;
 }
@@ -4686,20 +5134,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
  * NIX AF Receive Inner TCP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an inner TCP header.
  */
-union cavm_nixx_af_rx_def_itcp {
+union nixx_af_rx_def_itcp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_itcp_s {
+	struct nixx_af_rx_def_itcp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_itcp_s cn; */
+	/* struct nixx_af_rx_def_itcp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
+static inline u64 NIXX_AF_RX_DEF_ITCP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
+static inline u64 NIXX_AF_RX_DEF_ITCP(void)
 {
 	return 0x260;
 }
@@ -4710,20 +5158,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
  * NIX AF Receive Inner UDP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an inner UDP header.
  */
-union cavm_nixx_af_rx_def_iudp {
+union nixx_af_rx_def_iudp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_iudp_s {
+	struct nixx_af_rx_def_iudp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_iudp_s cn; */
+	/* struct nixx_af_rx_def_iudp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
+static inline u64 NIXX_AF_RX_DEF_IUDP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
+static inline u64 NIXX_AF_RX_DEF_IUDP(void)
 {
 	return 0x280;
 }
@@ -4735,20 +5183,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
  * information in NPC_RESULT_S to identify an outer IPv4 L3 header.
  * Typically the same as NPC_PCK_DEF_OIP4.
  */
-union cavm_nixx_af_rx_def_oip4 {
+union nixx_af_rx_def_oip4 {
 	u64 u;
-	struct cavm_nixx_af_rx_def_oip4_s {
+	struct nixx_af_rx_def_oip4_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_oip4_s cn; */
+	/* struct nixx_af_rx_def_oip4_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
+static inline u64 NIXX_AF_RX_DEF_OIP4(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
+static inline u64 NIXX_AF_RX_DEF_OIP4(void)
 {
 	return 0x210;
 }
@@ -4760,20 +5208,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
  * information in NPC_RESULT_S to identify an outer IPv6 header.
  * Typically the same as NPC_PCK_DEF_OIP6.
  */
-union cavm_nixx_af_rx_def_oip6 {
+union nixx_af_rx_def_oip6 {
 	u64 u;
-	struct cavm_nixx_af_rx_def_oip6_s {
+	struct nixx_af_rx_def_oip6_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_oip6_s cn; */
+	/* struct nixx_af_rx_def_oip6_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
+static inline u64 NIXX_AF_RX_DEF_OIP6(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
+static inline u64 NIXX_AF_RX_DEF_OIP6(void)
 {
 	return 0x230;
 }
@@ -4785,20 +5233,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
  * information in NPC_RESULT_S to identify an outer L2/Ethernet header.
  * Typically the same as NPC_PCK_DEF_OL2.
  */
-union cavm_nixx_af_rx_def_ol2 {
+union nixx_af_rx_def_ol2 {
 	u64 u;
-	struct cavm_nixx_af_rx_def_ol2_s {
+	struct nixx_af_rx_def_ol2_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_ol2_s cn; */
+	/* struct nixx_af_rx_def_ol2_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
+static inline u64 NIXX_AF_RX_DEF_OL2(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
+static inline u64 NIXX_AF_RX_DEF_OL2(void)
 {
 	return 0x200;
 }
@@ -4809,20 +5257,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
  * NIX AF Receive Outer SCTP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an outer SCTP header.
  */
-union cavm_nixx_af_rx_def_osctp {
+union nixx_af_rx_def_osctp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_osctp_s {
+	struct nixx_af_rx_def_osctp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_osctp_s cn; */
+	/* struct nixx_af_rx_def_osctp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
+static inline u64 NIXX_AF_RX_DEF_OSCTP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
+static inline u64 NIXX_AF_RX_DEF_OSCTP(void)
 {
 	return 0x290;
 }
@@ -4833,20 +5281,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
  * NIX AF Receive Outer TCP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an outer TCP header.
  */
-union cavm_nixx_af_rx_def_otcp {
+union nixx_af_rx_def_otcp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_otcp_s {
+	struct nixx_af_rx_def_otcp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_otcp_s cn; */
+	/* struct nixx_af_rx_def_otcp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
+static inline u64 NIXX_AF_RX_DEF_OTCP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
+static inline u64 NIXX_AF_RX_DEF_OTCP(void)
 {
 	return 0x250;
 }
@@ -4857,20 +5305,20 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
  * NIX AF Receive Outer UDP Header Definition Register Defines layer
  * information in NPC_RESULT_S to identify an outer UDP header.
  */
-union cavm_nixx_af_rx_def_oudp {
+union nixx_af_rx_def_oudp {
 	u64 u;
-	struct cavm_nixx_af_rx_def_oudp_s {
+	struct nixx_af_rx_def_oudp_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_af_rx_def_oudp_s cn; */
+	/* struct nixx_af_rx_def_oudp_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
+static inline u64 NIXX_AF_RX_DEF_OUDP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
+static inline u64 NIXX_AF_RX_DEF_OUDP(void)
 {
 	return 0x270;
 }
@@ -4889,9 +5337,9 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
  * Dest IP: 16B. _ Source port: 2B. _ Dest port: 2B. _ Tunnel VNI/VSI:
  * 3B. _ Total: 39B.
  */
-union cavm_nixx_af_rx_flow_key_algx_fieldx {
+union nixx_af_rx_flow_key_algx_fieldx {
 	u64 u;
-	struct cavm_nixx_af_rx_flow_key_algx_fieldx_s {
+	struct nixx_af_rx_flow_key_algx_fieldx_s {
 		u64 key_offset                       : 6;
 		u64 ln_mask                          : 1;
 		u64 fn_mask                          : 1;
@@ -4905,12 +5353,12 @@ union cavm_nixx_af_rx_flow_key_algx_fieldx {
 		u64 ltype_match                      : 4;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_nixx_af_rx_flow_key_algx_fieldx_s cn; */
+	/* struct nixx_af_rx_flow_key_algx_fieldx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+static inline u64 NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+static inline u64 NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
 {
 	return 0x1800 + 0x40000 * a + 8 * b;
 }
@@ -4921,21 +5369,21 @@ static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
  * INTERNAL: NIX AF Receive IPSEC General Configuration Register
  * Internal: Not used; no IPSEC fast-path.
  */
-union cavm_nixx_af_rx_ipsec_gen_cfg {
+union nixx_af_rx_ipsec_gen_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_ipsec_gen_cfg_s {
+	struct nixx_af_rx_ipsec_gen_cfg_s {
 		u64 param2                           : 16;
 		u64 param1                           : 16;
 		u64 opcode                           : 16;
 		u64 egrp                             : 3;
 		u64 reserved_51_63                   : 13;
 	} s;
-	/* struct cavm_nixx_af_rx_ipsec_gen_cfg_s cn; */
+	/* struct nixx_af_rx_ipsec_gen_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
+static inline u64 NIXX_AF_RX_IPSEC_GEN_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
+static inline u64 NIXX_AF_RX_IPSEC_GEN_CFG(void)
 {
 	return 0x300;
 }
@@ -4946,19 +5394,19 @@ static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
  * NIX AF Receive Link Configuration Registers Index enumerated by
  * NIX_LINK_E.
  */
-union cavm_nixx_af_rx_linkx_cfg {
+union nixx_af_rx_linkx_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_linkx_cfg_s {
+	struct nixx_af_rx_linkx_cfg_s {
 		u64 minlen                           : 16;
 		u64 maxlen                           : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_rx_linkx_cfg_s cn; */
+	/* struct nixx_af_rx_linkx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
+static inline u64 NIXX_AF_RX_LINKX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
+static inline u64 NIXX_AF_RX_LINKX_CFG(u64 a)
 {
 	return 0x540 + 0x10000 * a;
 }
@@ -4968,24 +5416,28 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
  *
  * INTERNAL: NIX Receive Software Sync Link Packet Count Registers  For
  * diagnostic use only for debug of NIX_AF_RX_SW_SYNC[ENA] function. LINK
- * index is enumerated by NIX_LINK_E. SL index is zero for non-express
- * packets, one for express packets. For the internal NIX_LINK_E::MC, SL
- * index is zero for multicast replay, one for mirror replay.
+ * index is enumerated by NIX_LINK_E. For the internal multicast/mirror
+ * link (NIX_LINK_E::MC), SL index is zero for multicast replay, one for
+ * mirror replay. SL index one is reserved for all other links.
+ * Internal: 802.3br frame preemption/express path is defeatured. Old
+ * definition of SL index: SL index is zero for non-express packets, one
+ * for express packets. For the internal NIX_LINK_E::MC, SL index is zero
+ * for multicast replay, one for mirror replay.
  */
-union cavm_nixx_af_rx_linkx_slx_spkt_cnt {
+union nixx_af_rx_linkx_slx_spkt_cnt {
 	u64 u;
-	struct cavm_nixx_af_rx_linkx_slx_spkt_cnt_s {
+	struct nixx_af_rx_linkx_slx_spkt_cnt_s {
 		u64 in_cnt                           : 20;
 		u64 reserved_20_31                   : 12;
 		u64 out_cnt                          : 20;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_nixx_af_rx_linkx_slx_spkt_cnt_s cn; */
+	/* struct nixx_af_rx_linkx_slx_spkt_cnt_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+static inline u64 NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+static inline u64 NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
 {
 	return 0x500 + 0x10000 * a + 8 * b;
 }
@@ -4996,18 +5448,18 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
  * NIX AF Receive Link Weighted Round Robin Configuration Registers Index
  * enumerated by NIX_LINK_E.
  */
-union cavm_nixx_af_rx_linkx_wrr_cfg {
+union nixx_af_rx_linkx_wrr_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_linkx_wrr_cfg_s {
+	struct nixx_af_rx_linkx_wrr_cfg_s {
 		u64 weight                           : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_nixx_af_rx_linkx_wrr_cfg_s cn; */
+	/* struct nixx_af_rx_linkx_wrr_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+static inline u64 NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+static inline u64 NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
 {
 	return 0x560 + 0x10000 * a;
 }
@@ -5036,19 +5488,19 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
  * two mirror entries in that list.  Internal: A multicast list may have
  * multiple entries for the same LF (e.g. for future RoCE/IB multicast).
  */
-union cavm_nixx_af_rx_mcast_base {
+union nixx_af_rx_mcast_base {
 	u64 u;
-	struct cavm_nixx_af_rx_mcast_base_s {
+	struct nixx_af_rx_mcast_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_rx_mcast_base_s cn; */
+	/* struct nixx_af_rx_mcast_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
+static inline u64 NIXX_AF_RX_MCAST_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
+static inline u64 NIXX_AF_RX_MCAST_BASE(void)
 {
 	return 0x100;
 }
@@ -5066,19 +5518,19 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
  * packet and sets NIX_AF_GEN_INT[RX_MCAST_DROP].  Hardware prioritizes
  * the processing of RX mirror packets over RX multicast packets.
  */
-union cavm_nixx_af_rx_mcast_buf_base {
+union nixx_af_rx_mcast_buf_base {
 	u64 u;
-	struct cavm_nixx_af_rx_mcast_buf_base_s {
+	struct nixx_af_rx_mcast_buf_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_rx_mcast_buf_base_s cn; */
+	/* struct nixx_af_rx_mcast_buf_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
+static inline u64 NIXX_AF_RX_MCAST_BUF_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
+static inline u64 NIXX_AF_RX_MCAST_BUF_BASE(void)
 {
 	return 0x120;
 }
@@ -5089,9 +5541,9 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
  * NIX AF Receive Multicast Buffer Configuration Register See
  * NIX_AF_RX_MCAST_BUF_BASE.
  */
-union cavm_nixx_af_rx_mcast_buf_cfg {
+union nixx_af_rx_mcast_buf_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_mcast_buf_cfg_s {
+	struct nixx_af_rx_mcast_buf_cfg_s {
 		u64 size                             : 4;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
@@ -5099,15 +5551,42 @@ union cavm_nixx_af_rx_mcast_buf_cfg {
 		u64 npc_replay_pkind                 : 6;
 		u64 reserved_30_31                   : 2;
 		u64 free_buf_level                   : 11;
-		u64 reserved_43_62                   : 20;
+		u64 reserved_43_61                   : 19;
+		u64 busy                             : 1;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_nixx_af_rx_mcast_buf_cfg_s cn; */
+	struct nixx_af_rx_mcast_buf_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 reserved_62                      : 1;
+		u64 ena                              : 1;
+	} cn96xxp1;
+	/* struct nixx_af_rx_mcast_buf_cfg_s cn96xxp3; */
+	/* struct nixx_af_rx_mcast_buf_cfg_s cn98xx; */
+	struct nixx_af_rx_mcast_buf_cfg_cnf95xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} cnf95xxp1;
+	/* struct nixx_af_rx_mcast_buf_cfg_s cnf95xxp2; */
+	/* struct nixx_af_rx_mcast_buf_cfg_s loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
+static inline u64 NIXX_AF_RX_MCAST_BUF_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
+static inline u64 NIXX_AF_RX_MCAST_BUF_CFG(void)
 {
 	return 0x130;
 }
@@ -5118,9 +5597,9 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
  * NIX AF Receive Multicast/Mirror Table Configuration Register See
  * NIX_AF_RX_MCAST_BASE.
  */
-union cavm_nixx_af_rx_mcast_cfg {
+union nixx_af_rx_mcast_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_mcast_cfg_s {
+	struct nixx_af_rx_mcast_cfg_s {
 		u64 size                             : 4;
 		u64 max_list_lenm1                   : 8;
 		u64 reserved_12_19                   : 8;
@@ -5128,12 +5607,12 @@ union cavm_nixx_af_rx_mcast_cfg {
 		u64 caching                          : 1;
 		u64 reserved_37_63                   : 27;
 	} s;
-	/* struct cavm_nixx_af_rx_mcast_cfg_s cn; */
+	/* struct nixx_af_rx_mcast_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
+static inline u64 NIXX_AF_RX_MCAST_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
+static inline u64 NIXX_AF_RX_MCAST_CFG(void)
 {
 	return 0x110;
 }
@@ -5151,19 +5630,19 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
  * packet and sets NIX_AF_GEN_INT[RX_MIRROR_DROP].  Hardware prioritizes
  * the processing of RX mirror packets over RX multicast packets.
  */
-union cavm_nixx_af_rx_mirror_buf_base {
+union nixx_af_rx_mirror_buf_base {
 	u64 u;
-	struct cavm_nixx_af_rx_mirror_buf_base_s {
+	struct nixx_af_rx_mirror_buf_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_rx_mirror_buf_base_s cn; */
+	/* struct nixx_af_rx_mirror_buf_base_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
+static inline u64 NIXX_AF_RX_MIRROR_BUF_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
+static inline u64 NIXX_AF_RX_MIRROR_BUF_BASE(void)
 {
 	return 0x140;
 }
@@ -5174,9 +5653,9 @@ static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
  * NIX AF Receive Mirror Buffer Configuration Register See
  * NIX_AF_RX_MIRROR_BUF_BASE.
  */
-union cavm_nixx_af_rx_mirror_buf_cfg {
+union nixx_af_rx_mirror_buf_cfg {
 	u64 u;
-	struct cavm_nixx_af_rx_mirror_buf_cfg_s {
+	struct nixx_af_rx_mirror_buf_cfg_s {
 		u64 size                             : 4;
 		u64 way_mask                         : 16;
 		u64 caching                          : 1;
@@ -5184,15 +5663,42 @@ union cavm_nixx_af_rx_mirror_buf_cfg {
 		u64 npc_replay_pkind                 : 6;
 		u64 reserved_30_31                   : 2;
 		u64 free_buf_level                   : 11;
-		u64 reserved_43_62                   : 20;
+		u64 reserved_43_61                   : 19;
+		u64 busy                             : 1;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_nixx_af_rx_mirror_buf_cfg_s cn; */
+	struct nixx_af_rx_mirror_buf_cfg_cn96xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_61                   : 19;
+		u64 reserved_62                      : 1;
+		u64 ena                              : 1;
+	} cn96xxp1;
+	/* struct nixx_af_rx_mirror_buf_cfg_s cn96xxp3; */
+	/* struct nixx_af_rx_mirror_buf_cfg_s cn98xx; */
+	struct nixx_af_rx_mirror_buf_cfg_cnf95xxp1 {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} cnf95xxp1;
+	/* struct nixx_af_rx_mirror_buf_cfg_s cnf95xxp2; */
+	/* struct nixx_af_rx_mirror_buf_cfg_s loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
+static inline u64 NIXX_AF_RX_MIRROR_BUF_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
+static inline u64 NIXX_AF_RX_MIRROR_BUF_CFG(void)
 {
 	return 0x148;
 }
@@ -5203,18 +5709,18 @@ static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
  * NIX AF Multicast Drop Statistics Register The counter increments for
  * every dropped MC packet marked by the NPC.
  */
-union cavm_nixx_af_rx_npc_mc_drop {
+union nixx_af_rx_npc_mc_drop {
 	u64 u;
-	struct cavm_nixx_af_rx_npc_mc_drop_s {
+	struct nixx_af_rx_npc_mc_drop_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_rx_npc_mc_drop_s cn; */
+	/* struct nixx_af_rx_npc_mc_drop_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
+static inline u64 NIXX_AF_RX_NPC_MC_DROP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
+static inline u64 NIXX_AF_RX_NPC_MC_DROP(void)
 {
 	return 0x4710;
 }
@@ -5225,18 +5731,18 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
  * NIX AF Multicast Receive Statistics Register The counter increments
  * for every received MC packet marked by the NPC.
  */
-union cavm_nixx_af_rx_npc_mc_rcv {
+union nixx_af_rx_npc_mc_rcv {
 	u64 u;
-	struct cavm_nixx_af_rx_npc_mc_rcv_s {
+	struct nixx_af_rx_npc_mc_rcv_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_rx_npc_mc_rcv_s cn; */
+	/* struct nixx_af_rx_npc_mc_rcv_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
+static inline u64 NIXX_AF_RX_NPC_MC_RCV(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
+static inline u64 NIXX_AF_RX_NPC_MC_RCV(void)
 {
 	return 0x4700;
 }
@@ -5247,18 +5753,18 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
  * NIX AF Mirror Drop Statistics Register The counter increments for
  * every dropped MIRROR packet marked by the NPC.
  */
-union cavm_nixx_af_rx_npc_mirror_drop {
+union nixx_af_rx_npc_mirror_drop {
 	u64 u;
-	struct cavm_nixx_af_rx_npc_mirror_drop_s {
+	struct nixx_af_rx_npc_mirror_drop_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_rx_npc_mirror_drop_s cn; */
+	/* struct nixx_af_rx_npc_mirror_drop_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
+static inline u64 NIXX_AF_RX_NPC_MIRROR_DROP(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
+static inline u64 NIXX_AF_RX_NPC_MIRROR_DROP(void)
 {
 	return 0x4730;
 }
@@ -5269,18 +5775,18 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
  * NIX AF Mirror Receive Statistics Register The counter increments for
  * every received MIRROR packet marked by the NPC.
  */
-union cavm_nixx_af_rx_npc_mirror_rcv {
+union nixx_af_rx_npc_mirror_rcv {
 	u64 u;
-	struct cavm_nixx_af_rx_npc_mirror_rcv_s {
+	struct nixx_af_rx_npc_mirror_rcv_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_rx_npc_mirror_rcv_s cn; */
+	/* struct nixx_af_rx_npc_mirror_rcv_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_RCV(void)
+static inline u64 NIXX_AF_RX_NPC_MIRROR_RCV(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_RCV(void)
+static inline u64 NIXX_AF_RX_NPC_MIRROR_RCV(void)
 {
 	return 0x4720;
 }
@@ -5290,18 +5796,18 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_RCV(void)
  *
  * NIX AF Receive Software Sync Register
  */
-union cavm_nixx_af_rx_sw_sync {
+union nixx_af_rx_sw_sync {
 	u64 u;
-	struct cavm_nixx_af_rx_sw_sync_s {
+	struct nixx_af_rx_sw_sync_s {
 		u64 ena                              : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_rx_sw_sync_s cn; */
+	/* struct nixx_af_rx_sw_sync_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
+static inline u64 NIXX_AF_RX_SW_SYNC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
+static inline u64 NIXX_AF_RX_SW_SYNC(void)
 {
 	return 0x550;
 }
@@ -5311,17 +5817,17 @@ static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
  *
  * NIX AF SDP Transmit Link Hardware Controlled XOFF Registers .
  */
-union cavm_nixx_af_sdp_hw_xoffx {
+union nixx_af_sdp_hw_xoffx {
 	u64 u;
-	struct cavm_nixx_af_sdp_hw_xoffx_s {
+	struct nixx_af_sdp_hw_xoffx_s {
 		u64 chan_xoff                        : 64;
 	} s;
-	/* struct cavm_nixx_af_sdp_hw_xoffx_s cn; */
+	/* struct nixx_af_sdp_hw_xoffx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
+static inline u64 NIXX_AF_SDP_HW_XOFFX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
+static inline u64 NIXX_AF_SDP_HW_XOFFX(u64 a)
 {
 	return 0xac0 + 8 * a;
 }
@@ -5332,9 +5838,9 @@ static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
  * NIX AF Transmit Link SDP Credit Register This register tracks SDP link
  * credits.
  */
-union cavm_nixx_af_sdp_link_credit {
+union nixx_af_sdp_link_credit {
 	u64 u;
-	struct cavm_nixx_af_sdp_link_credit_s {
+	struct nixx_af_sdp_link_credit_s {
 		u64 reserved_0                       : 1;
 		u64 cc_enable                        : 1;
 		u64 cc_packet_cnt                    : 10;
@@ -5342,19 +5848,22 @@ union cavm_nixx_af_sdp_link_credit {
 		u64 reserved_32_62                   : 31;
 		u64 pse_pkt_id_lmt                   : 1;
 	} s;
-	struct cavm_nixx_af_sdp_link_credit_cn96xx {
+	struct nixx_af_sdp_link_credit_cn96xx {
 		u64 reserved_0                       : 1;
 		u64 cc_enable                        : 1;
 		u64 cc_packet_cnt                    : 10;
 		u64 cc_unit_cnt                      : 20;
-		u64 reserved_32_63                   : 32;
+		u64 reserved_32_62                   : 31;
+		u64 reserved_63                      : 1;
 	} cn96xx;
-	/* struct cavm_nixx_af_sdp_link_credit_s cnf95xx; */
+	/* struct nixx_af_sdp_link_credit_cn96xx cn98xx; */
+	/* struct nixx_af_sdp_link_credit_s cnf95xx; */
+	/* struct nixx_af_sdp_link_credit_cn96xx loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_SDP_LINK_CREDIT(void)
+static inline u64 NIXX_AF_SDP_LINK_CREDIT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SDP_LINK_CREDIT(void)
+static inline u64 NIXX_AF_SDP_LINK_CREDIT(void)
 {
 	return 0xa40;
 }
@@ -5362,19 +5871,21 @@ static inline u64 CAVM_NIXX_AF_SDP_LINK_CREDIT(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sdp_sw_xoff#
  *
- * NIX AF SDP Transmit Link Software Controlled XOFF Registers
+ * INTERNAL: NIX AF SDP Transmit Link Software Controlled XOFF Registers
+ * Internal: Defeatured registers. Software should use
+ * NIX_AF_TL4()_SW_XOFF registers instead.
  */
-union cavm_nixx_af_sdp_sw_xoffx {
+union nixx_af_sdp_sw_xoffx {
 	u64 u;
-	struct cavm_nixx_af_sdp_sw_xoffx_s {
+	struct nixx_af_sdp_sw_xoffx_s {
 		u64 chan_xoff                        : 64;
 	} s;
-	/* struct cavm_nixx_af_sdp_sw_xoffx_s cn; */
+	/* struct nixx_af_sdp_sw_xoffx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
+static inline u64 NIXX_AF_SDP_SW_XOFFX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
+static inline u64 NIXX_AF_SDP_SW_XOFFX(u64 a)
 {
 	return 0xa60 + 8 * a;
 }
@@ -5385,18 +5896,18 @@ static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
  * NIX AF SDP Transmit FIFO Status Register Status of FIFO which
  * transmits packets to SDP.
  */
-union cavm_nixx_af_sdp_tx_fifo_status {
+union nixx_af_sdp_tx_fifo_status {
 	u64 u;
-	struct cavm_nixx_af_sdp_tx_fifo_status_s {
+	struct nixx_af_sdp_tx_fifo_status_s {
 		u64 count                            : 12;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_nixx_af_sdp_tx_fifo_status_s cn; */
+	/* struct nixx_af_sdp_tx_fifo_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_SDP_TX_FIFO_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
+static inline u64 NIXX_AF_SDP_TX_FIFO_STATUS(void)
 {
 	return 0x650;
 }
@@ -5407,17 +5918,17 @@ static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
  * NIX AF Active Cycles Register These registers are indexed by the
  * conditional clock domain number.
  */
-union cavm_nixx_af_seb_active_cycles_pcx {
+union nixx_af_seb_active_cycles_pcx {
 	u64 u;
-	struct cavm_nixx_af_seb_active_cycles_pcx_s {
+	struct nixx_af_seb_active_cycles_pcx_s {
 		u64 act_cyc                          : 64;
 	} s;
-	/* struct cavm_nixx_af_seb_active_cycles_pcx_s cn; */
+	/* struct nixx_af_seb_active_cycles_pcx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+static inline u64 NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+static inline u64 NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
 {
 	return 0x6c0 + 8 * a;
 }
@@ -5427,9 +5938,9 @@ static inline u64 CAVM_NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
  *
  * INTERNAL: NIX AF SEB Backpressure Test Register
  */
-union cavm_nixx_af_seb_bp_test {
+union nixx_af_seb_bp_test {
 	u64 u;
-	struct cavm_nixx_af_seb_bp_test_s {
+	struct nixx_af_seb_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 14;
@@ -5437,32 +5948,53 @@ union cavm_nixx_af_seb_bp_test {
 		u64 enable                           : 7;
 		u64 reserved_55_63                   : 9;
 	} s;
-	/* struct cavm_nixx_af_seb_bp_test_s cn; */
+	/* struct nixx_af_seb_bp_test_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_BP_TEST(void)
+static inline u64 NIXX_AF_SEB_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_BP_TEST(void)
+static inline u64 NIXX_AF_SEB_BP_TEST(void)
 {
 	return 0x630;
 }
 
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_cfg
+ *
+ * NIX SEB Configuration Register
+ */
+union nixx_af_seb_cfg {
+	u64 u;
+	struct nixx_af_seb_cfg_s {
+		u64 sg_ndc_sel                       : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct nixx_af_seb_cfg_s cn; */
+};
+
+static inline u64 NIXX_AF_SEB_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NIXX_AF_SEB_CFG(void)
+{
+	return 0x5f0;
+}
+
 /**
  * Register (RVU_PF_BAR0) nix#_af_seb_eco
  *
  * INTERNAL: AF SEB ECO Register
  */
-union cavm_nixx_af_seb_eco {
+union nixx_af_seb_eco {
 	u64 u;
-	struct cavm_nixx_af_seb_eco_s {
+	struct nixx_af_seb_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_seb_eco_s cn; */
+	/* struct nixx_af_seb_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_ECO(void)
+static inline u64 NIXX_AF_SEB_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_ECO(void)
+static inline u64 NIXX_AF_SEB_ECO(void)
 {
 	return 0x5c0;
 }
@@ -5472,9 +6004,9 @@ static inline u64 CAVM_NIXX_AF_SEB_ECO(void)
  *
  * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
  */
-union cavm_nixx_af_seb_pipe_bp_testx {
+union nixx_af_seb_pipe_bp_testx {
 	u64 u;
-	struct cavm_nixx_af_seb_pipe_bp_testx_s {
+	struct nixx_af_seb_pipe_bp_testx_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 24;
@@ -5482,12 +6014,12 @@ union cavm_nixx_af_seb_pipe_bp_testx {
 		u64 enable                           : 12;
 		u64 reserved_60_63                   : 4;
 	} s;
-	/* struct cavm_nixx_af_seb_pipe_bp_testx_s cn; */
+	/* struct nixx_af_seb_pipe_bp_testx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
 {
 	return 0x600 + 0x10 * a;
 }
@@ -5497,9 +6029,9 @@ static inline u64 CAVM_NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
  *
  * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
  */
-union cavm_nixx_af_seb_pipeb_bp_testx {
+union nixx_af_seb_pipeb_bp_testx {
 	u64 u;
-	struct cavm_nixx_af_seb_pipeb_bp_testx_s {
+	struct nixx_af_seb_pipeb_bp_testx_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 18;
@@ -5507,12 +6039,12 @@ union cavm_nixx_af_seb_pipeb_bp_testx {
 		u64 enable                           : 9;
 		u64 reserved_57_63                   : 7;
 	} s;
-	/* struct cavm_nixx_af_seb_pipeb_bp_testx_s cn; */
+	/* struct nixx_af_seb_pipeb_bp_testx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
 {
 	return 0x608 + 0x10 * a;
 }
@@ -5522,18 +6054,18 @@ static inline u64 CAVM_NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
  *
  * INTERNAL: NIX AF SEB TSTMP Watchdog Tick Divider Register
  */
-union cavm_nixx_af_seb_wd_tick_divider {
+union nixx_af_seb_wd_tick_divider {
 	u64 u;
-	struct cavm_nixx_af_seb_wd_tick_divider_s {
+	struct nixx_af_seb_wd_tick_divider_s {
 		u64 tick_div_cfg                     : 7;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_nixx_af_seb_wd_tick_divider_s cn; */
+	/* struct nixx_af_seb_wd_tick_divider_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+static inline u64 NIXX_AF_SEB_WD_TICK_DIVIDER(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+static inline u64 NIXX_AF_SEB_WD_TICK_DIVIDER(void)
 {
 	return 0x6f0;
 }
@@ -5543,9 +6075,9 @@ static inline u64 CAVM_NIXX_AF_SEB_WD_TICK_DIVIDER(void)
  *
  * NIX AF SQM PSE Queue Configuration Registers
  */
-union cavm_nixx_af_smqx_cfg {
+union nixx_af_smqx_cfg {
 	u64 u;
-	struct cavm_nixx_af_smqx_cfg_s {
+	struct nixx_af_smqx_cfg_s {
 		u64 minlen                           : 7;
 		u64 desc_shp_ctl_dis                 : 1;
 		u64 maxlen                           : 16;
@@ -5559,12 +6091,12 @@ union cavm_nixx_af_smqx_cfg {
 		u64 pri_thr                          : 6;
 		u64 reserved_57_63                   : 7;
 	} s;
-	/* struct cavm_nixx_af_smqx_cfg_s cn; */
+	/* struct nixx_af_smqx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
+static inline u64 NIXX_AF_SMQX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
+static inline u64 NIXX_AF_SMQX_CFG(u64 a)
 {
 	return 0x700 + 0x10000 * a;
 }
@@ -5575,19 +6107,19 @@ static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
  * NIX AF SQM SMQ Head Register These registers track the head of the SMQ
  * linked list.
  */
-union cavm_nixx_af_smqx_head {
+union nixx_af_smqx_head {
 	u64 u;
-	struct cavm_nixx_af_smqx_head_s {
+	struct nixx_af_smqx_head_s {
 		u64 sq_idx                           : 20;
 		u64 valid                            : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_nixx_af_smqx_head_s cn; */
+	/* struct nixx_af_smqx_head_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
+static inline u64 NIXX_AF_SMQX_HEAD(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
+static inline u64 NIXX_AF_SMQX_HEAD(u64 a)
 {
 	return 0x710 + 0x10000 * a;
 }
@@ -5598,19 +6130,19 @@ static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
  * NIX AF SQM SMQ Next Head Register These registers track the next head
  * of the SMQ linked list.
  */
-union cavm_nixx_af_smqx_nxt_head {
+union nixx_af_smqx_nxt_head {
 	u64 u;
-	struct cavm_nixx_af_smqx_nxt_head_s {
+	struct nixx_af_smqx_nxt_head_s {
 		u64 sq_idx                           : 20;
 		u64 valid                            : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_nixx_af_smqx_nxt_head_s cn; */
+	/* struct nixx_af_smqx_nxt_head_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
+static inline u64 NIXX_AF_SMQX_NXT_HEAD(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
+static inline u64 NIXX_AF_SMQX_NXT_HEAD(u64 a)
 {
 	return 0x740 + 0x10000 * a;
 }
@@ -5621,18 +6153,18 @@ static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
  * NIX AF SQM SMQ Status Register These registers track the status of the
  * SMQ FIFO.
  */
-union cavm_nixx_af_smqx_status {
+union nixx_af_smqx_status {
 	u64 u;
-	struct cavm_nixx_af_smqx_status_s {
+	struct nixx_af_smqx_status_s {
 		u64 level                            : 7;
 		u64 reserved_7_63                    : 57;
 	} s;
-	/* struct cavm_nixx_af_smqx_status_s cn; */
+	/* struct nixx_af_smqx_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
+static inline u64 NIXX_AF_SMQX_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
+static inline u64 NIXX_AF_SMQX_STATUS(u64 a)
 {
 	return 0x730 + 0x10000 * a;
 }
@@ -5643,19 +6175,19 @@ static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
  * NIX AF SQM SMQ Head Register These registers track the tail of SMQ
  * linked list.
  */
-union cavm_nixx_af_smqx_tail {
+union nixx_af_smqx_tail {
 	u64 u;
-	struct cavm_nixx_af_smqx_tail_s {
+	struct nixx_af_smqx_tail_s {
 		u64 sq_idx                           : 20;
 		u64 valid                            : 1;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_nixx_af_smqx_tail_s cn; */
+	/* struct nixx_af_smqx_tail_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
+static inline u64 NIXX_AF_SMQX_TAIL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
+static inline u64 NIXX_AF_SMQX_TAIL(u64 a)
 {
 	return 0x720 + 0x10000 * a;
 }
@@ -5666,20 +6198,20 @@ static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
  * NIX AF SQ Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_nixx_af_sq_const {
+union nixx_af_sq_const {
 	u64 u;
-	struct cavm_nixx_af_sq_const_s {
+	struct nixx_af_sq_const_s {
 		u64 queues_per_lf                    : 24;
 		u64 smq_depth                        : 10;
 		u64 sqb_size                         : 16;
 		u64 reserved_50_63                   : 14;
 	} s;
-	/* struct cavm_nixx_af_sq_const_s cn; */
+	/* struct nixx_af_sq_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
+static inline u64 NIXX_AF_SQ_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
+static inline u64 NIXX_AF_SQ_CONST(void)
 {
 	return 0x40;
 }
@@ -5690,17 +6222,17 @@ static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
  * NIX AF SQM Active Cycles Register These registers are indexed by the
  * conditional clock domain number.
  */
-union cavm_nixx_af_sqm_active_cycles_pc {
+union nixx_af_sqm_active_cycles_pc {
 	u64 u;
-	struct cavm_nixx_af_sqm_active_cycles_pc_s {
+	struct nixx_af_sqm_active_cycles_pc_s {
 		u64 act_cyc                          : 64;
 	} s;
-	/* struct cavm_nixx_af_sqm_active_cycles_pc_s cn; */
+	/* struct nixx_af_sqm_active_cycles_pc_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+static inline u64 NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+static inline u64 NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
 {
 	return 0x770;
 }
@@ -5710,21 +6242,21 @@ static inline u64 CAVM_NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
  *
  * INTERNAL: NIX AF SQM Backpressure Test Register
  */
-union cavm_nixx_af_sqm_bp_testx {
+union nixx_af_sqm_bp_testx {
 	u64 u;
-	struct cavm_nixx_af_sqm_bp_testx_s {
+	struct nixx_af_sqm_bp_testx_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 8;
 		u64 reserved_24_59                   : 36;
 		u64 enable                           : 4;
 	} s;
-	/* struct cavm_nixx_af_sqm_bp_testx_s cn; */
+	/* struct nixx_af_sqm_bp_testx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SQM_BP_TESTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
+static inline u64 NIXX_AF_SQM_BP_TESTX(u64 a)
 {
 	return 0x760 + 0x10000 * a;
 }
@@ -5735,9 +6267,9 @@ static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
  * INTERNAL: NIX AF SQM Debug Register  This register is for SQM
  * diagnostic use only.
  */
-union cavm_nixx_af_sqm_dbg_ctl_status {
+union nixx_af_sqm_dbg_ctl_status {
 	u64 u;
-	struct cavm_nixx_af_sqm_dbg_ctl_status_s {
+	struct nixx_af_sqm_dbg_ctl_status_s {
 		u64 tm1                              : 8;
 		u64 tm2                              : 1;
 		u64 tm3                              : 4;
@@ -5747,14 +6279,49 @@ union cavm_nixx_af_sqm_dbg_ctl_status {
 		u64 tm7                              : 4;
 		u64 tm8                              : 1;
 		u64 tm9                              : 1;
-		u64 reserved_22_63                   : 42;
+		u64 tm10                             : 1;
+		u64 tm11                             : 1;
+		u64 tm12                             : 1;
+		u64 tm13                             : 1;
+		u64 reserved_26_63                   : 38;
 	} s;
-	/* struct cavm_nixx_af_sqm_dbg_ctl_status_s cn; */
+	struct nixx_af_sqm_dbg_ctl_status_cn96xxp1 {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 reserved_22_63                   : 42;
+	} cn96xxp1;
+	/* struct nixx_af_sqm_dbg_ctl_status_s cn96xxp3; */
+	/* struct nixx_af_sqm_dbg_ctl_status_s cn98xx; */
+	/* struct nixx_af_sqm_dbg_ctl_status_cn96xxp1 cnf95xxp1; */
+	struct nixx_af_sqm_dbg_ctl_status_cnf95xxp2 {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 reserved_22                      : 1;
+		u64 reserved_23                      : 1;
+		u64 reserved_24                      : 1;
+		u64 reserved_25                      : 1;
+		u64 reserved_26_63                   : 38;
+	} cnf95xxp2;
+	/* struct nixx_af_sqm_dbg_ctl_status_s loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_SQM_DBG_CTL_STATUS(void)
+static inline u64 NIXX_AF_SQM_DBG_CTL_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SQM_DBG_CTL_STATUS(void)
+static inline u64 NIXX_AF_SQM_DBG_CTL_STATUS(void)
 {
 	return 0x750;
 }
@@ -5764,17 +6331,17 @@ static inline u64 CAVM_NIXX_AF_SQM_DBG_CTL_STATUS(void)
  *
  * INTERNAL: AF SQM ECO Register
  */
-union cavm_nixx_af_sqm_eco {
+union nixx_af_sqm_eco {
 	u64 u;
-	struct cavm_nixx_af_sqm_eco_s {
+	struct nixx_af_sqm_eco_s {
 		u64 eco_rw                           : 64;
 	} s;
-	/* struct cavm_nixx_af_sqm_eco_s cn; */
+	/* struct nixx_af_sqm_eco_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_SQM_ECO(void)
+static inline u64 NIXX_AF_SQM_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_SQM_ECO(void)
+static inline u64 NIXX_AF_SQM_ECO(void)
 {
 	return 0x5b0;
 }
@@ -5784,21 +6351,21 @@ static inline u64 CAVM_NIXX_AF_SQM_ECO(void)
  *
  * NIX AF General Status Register
  */
-union cavm_nixx_af_status {
+union nixx_af_status {
 	u64 u;
-	struct cavm_nixx_af_status_s {
+	struct nixx_af_status_s {
 		u64 blk_busy                         : 10;
 		u64 calibrate_done                   : 1;
 		u64 reserved_11_15                   : 5;
 		u64 calibrate_status                 : 15;
 		u64 reserved_31_63                   : 33;
 	} s;
-	/* struct cavm_nixx_af_status_s cn; */
+	/* struct nixx_af_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_STATUS(void)
+static inline u64 NIXX_AF_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_STATUS(void)
+static inline u64 NIXX_AF_STATUS(void)
 {
 	return 0x10;
 }
@@ -5808,9 +6375,9 @@ static inline u64 CAVM_NIXX_AF_STATUS(void)
  *
  * NIX TCP Timer Register
  */
-union cavm_nixx_af_tcp_timer {
+union nixx_af_tcp_timer {
 	u64 u;
-	struct cavm_nixx_af_tcp_timer_s {
+	struct nixx_af_tcp_timer_s {
 		u64 dur_counter                      : 16;
 		u64 lf_counter                       : 8;
 		u64 reserved_24_31                   : 8;
@@ -5818,12 +6385,12 @@ union cavm_nixx_af_tcp_timer {
 		u64 reserved_48_62                   : 15;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tcp_timer_s cn; */
+	/* struct nixx_af_tcp_timer_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TCP_TIMER(void)
+static inline u64 NIXX_AF_TCP_TIMER(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TCP_TIMER(void)
+static inline u64 NIXX_AF_TCP_TIMER(void)
 {
 	return 0x1e0;
 }
@@ -5833,9 +6400,9 @@ static inline u64 CAVM_NIXX_AF_TCP_TIMER(void)
  *
  * NIX AF Transmit Level 1 Committed Information Rate Register
  */
-union cavm_nixx_af_tl1x_cir {
+union nixx_af_tl1x_cir {
 	u64 u;
-	struct cavm_nixx_af_tl1x_cir_s {
+	struct nixx_af_tl1x_cir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -5845,12 +6412,12 @@ union cavm_nixx_af_tl1x_cir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl1x_cir_s cn; */
+	/* struct nixx_af_tl1x_cir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
+static inline u64 NIXX_AF_TL1X_CIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
+static inline u64 NIXX_AF_TL1X_CIR(u64 a)
 {
 	return 0xc20 + 0x10000 * a;
 }
@@ -5861,18 +6428,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
  * NIX AF Transmit Level 1 Dropped Bytes Registers This register has the
  * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
-union cavm_nixx_af_tl1x_dropped_bytes {
+union nixx_af_tl1x_dropped_bytes {
 	u64 u;
-	struct cavm_nixx_af_tl1x_dropped_bytes_s {
+	struct nixx_af_tl1x_dropped_bytes_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_tl1x_dropped_bytes_s cn; */
+	/* struct nixx_af_tl1x_dropped_bytes_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
 {
 	return 0xd30 + 0x10000 * a;
 }
@@ -5883,18 +6450,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
  * NIX AF Transmit Level 1 Dropped Packets Registers This register has
  * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
-union cavm_nixx_af_tl1x_dropped_packets {
+union nixx_af_tl1x_dropped_packets {
 	u64 u;
-	struct cavm_nixx_af_tl1x_dropped_packets_s {
+	struct nixx_af_tl1x_dropped_packets_s {
 		u64 count                            : 40;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl1x_dropped_packets_s cn; */
+	/* struct nixx_af_tl1x_dropped_packets_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
 {
 	return 0xd20 + 0x10000 * a;
 }
@@ -5904,9 +6471,9 @@ static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
  *
  * INTERNAL: NIX Transmit Level 1 Green State Debug Register
  */
-union cavm_nixx_af_tl1x_green {
+union nixx_af_tl1x_green {
 	u64 u;
-	struct cavm_nixx_af_tl1x_green_s {
+	struct nixx_af_tl1x_green_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
@@ -5915,12 +6482,12 @@ union cavm_nixx_af_tl1x_green {
 		u64 rr_active                        : 1;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl1x_green_s cn; */
+	/* struct nixx_af_tl1x_green_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN(u64 a)
 {
 	return 0xc90 + 0x10000 * a;
 }
@@ -5930,18 +6497,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_GREEN(u64 a)
  *
  * NIX AF Transmit Level 1 Green Sent Bytes Registers
  */
-union cavm_nixx_af_tl1x_green_bytes {
+union nixx_af_tl1x_green_bytes {
 	u64 u;
-	struct cavm_nixx_af_tl1x_green_bytes_s {
+	struct nixx_af_tl1x_green_bytes_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_tl1x_green_bytes_s cn; */
+	/* struct nixx_af_tl1x_green_bytes_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN_BYTES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN_BYTES(u64 a)
 {
 	return 0xd90 + 0x10000 * a;
 }
@@ -5951,18 +6518,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_GREEN_BYTES(u64 a)
  *
  * NIX AF Transmit Level 1 Green Sent Packets Registers
  */
-union cavm_nixx_af_tl1x_green_packets {
+union nixx_af_tl1x_green_packets {
 	u64 u;
-	struct cavm_nixx_af_tl1x_green_packets_s {
+	struct nixx_af_tl1x_green_packets_s {
 		u64 count                            : 40;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl1x_green_packets_s cn; */
+	/* struct nixx_af_tl1x_green_packets_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
 {
 	return 0xd80 + 0x10000 * a;
 }
@@ -5979,9 +6546,9 @@ static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
  * accessed with [PMD1_VLD], [PMD1_LENGTH] and NIX_AF_TL1()_MD_DEBUG2. *
  * FMD is accessed with NIX_AF_TL1()_MD_DEBUG3.
  */
-union cavm_nixx_af_tl1x_md_debug0 {
+union nixx_af_tl1x_md_debug0 {
 	u64 u;
-	struct cavm_nixx_af_tl1x_md_debug0_s {
+	struct nixx_af_tl1x_md_debug0_s {
 		u64 pmd0_length                      : 16;
 		u64 pmd1_length                      : 16;
 		u64 pmd0_vld                         : 1;
@@ -5996,12 +6563,30 @@ union cavm_nixx_af_tl1x_md_debug0 {
 		u64 reserved_62                      : 1;
 		u64 pmd_count                        : 1;
 	} s;
-	/* struct cavm_nixx_af_tl1x_md_debug0_s cn; */
+	/* struct nixx_af_tl1x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl1x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug0_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG0(u64 a)
 {
 	return 0xcc0 + 0x10000 * a;
 }
@@ -6012,16 +6597,16 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
  * NIX AF Transmit Level 1 Meta Descriptor Debug 1 Registers Packet meta
  * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl1x_md_debug1 {
+union nixx_af_tl1x_md_debug1 {
 	u64 u;
-	struct cavm_nixx_af_tl1x_md_debug1_s {
+	struct nixx_af_tl1x_md_debug1_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -6032,12 +6617,50 @@ union cavm_nixx_af_tl1x_md_debug1 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl1x_md_debug1_s cn; */
+	struct nixx_af_tl1x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl1x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug1_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG1(u64 a)
 {
 	return 0xcc8 + 0x10000 * a;
 }
@@ -6048,16 +6671,16 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
  * NIX AF Transmit Level 1 Meta Descriptor Debug 2 Registers Packet meta
  * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl1x_md_debug2 {
+union nixx_af_tl1x_md_debug2 {
 	u64 u;
-	struct cavm_nixx_af_tl1x_md_debug2_s {
+	struct nixx_af_tl1x_md_debug2_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -6068,12 +6691,50 @@ union cavm_nixx_af_tl1x_md_debug2 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl1x_md_debug2_s cn; */
+	struct nixx_af_tl1x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl1x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug2_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG2(u64 a)
 {
 	return 0xcd0 + 0x10000 * a;
 }
@@ -6084,9 +6745,9 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
  * NIX AF Transmit Level 1 Meta Descriptor Debug 3 Registers Flush meta
  * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl1x_md_debug3 {
+union nixx_af_tl1x_md_debug3 {
 	u64 u;
-	struct cavm_nixx_af_tl1x_md_debug3_s {
+	struct nixx_af_tl1x_md_debug3_s {
 		u64 reserved_0_36                    : 37;
 		u64 tx_pkt_p2x                       : 2;
 		u64 sqm_pkt_id                       : 13;
@@ -6094,12 +6755,23 @@ union cavm_nixx_af_tl1x_md_debug3 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl1x_md_debug3_s cn; */
+	/* struct nixx_af_tl1x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl1x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl1x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl1x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl1x_md_debug3_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL1X_MD_DEBUG3(u64 a)
 {
 	return 0xcd8 + 0x10000 * a;
 }
@@ -6110,20 +6782,20 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
  * INTERNAL: NIX Transmit Level 1 Red State Debug Register  This register
  * has the same bit fields as NIX_AF_TL1()_YELLOW.
  */
-union cavm_nixx_af_tl1x_red {
+union nixx_af_tl1x_red {
 	u64 u;
-	struct cavm_nixx_af_tl1x_red_s {
+	struct nixx_af_tl1x_red_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_nixx_af_tl1x_red_s cn; */
+	/* struct nixx_af_tl1x_red_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
+static inline u64 NIXX_AF_TL1X_RED(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
+static inline u64 NIXX_AF_TL1X_RED(u64 a)
 {
 	return 0xcb0 + 0x10000 * a;
 }
@@ -6134,18 +6806,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
  * NIX AF Transmit Level 1 Red Sent Bytes Registers This register has the
  * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
-union cavm_nixx_af_tl1x_red_bytes {
+union nixx_af_tl1x_red_bytes {
 	u64 u;
-	struct cavm_nixx_af_tl1x_red_bytes_s {
+	struct nixx_af_tl1x_red_bytes_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_tl1x_red_bytes_s cn; */
+	/* struct nixx_af_tl1x_red_bytes_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_RED_BYTES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_RED_BYTES(u64 a)
 {
 	return 0xd50 + 0x10000 * a;
 }
@@ -6156,18 +6828,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
  * NIX AF Transmit Level 1 Red Sent Packets Registers This register has
  * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
-union cavm_nixx_af_tl1x_red_packets {
+union nixx_af_tl1x_red_packets {
 	u64 u;
-	struct cavm_nixx_af_tl1x_red_packets_s {
+	struct nixx_af_tl1x_red_packets_s {
 		u64 count                            : 40;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl1x_red_packets_s cn; */
+	/* struct nixx_af_tl1x_red_packets_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_RED_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_RED_PACKETS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_RED_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_RED_PACKETS(u64 a)
 {
 	return 0xd40 + 0x10000 * a;
 }
@@ -6177,18 +6849,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_RED_PACKETS(u64 a)
  *
  * NIX AF Transmit Level 1 Scheduling Control Register
  */
-union cavm_nixx_af_tl1x_schedule {
+union nixx_af_tl1x_schedule {
 	u64 u;
-	struct cavm_nixx_af_tl1x_schedule_s {
+	struct nixx_af_tl1x_schedule_s {
 		u64 rr_quantum                       : 24;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tl1x_schedule_s cn; */
+	/* struct nixx_af_tl1x_schedule_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL1X_SCHEDULE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL1X_SCHEDULE(u64 a)
 {
 	return 0xc00 + 0x10000 * a;
 }
@@ -6198,15 +6870,15 @@ static inline u64 CAVM_NIXX_AF_TL1X_SCHEDULE(u64 a)
  *
  * NIX AF Transmit Level 1 Shaping Control Register
  */
-union cavm_nixx_af_tl1x_shape {
+union nixx_af_tl1x_shape {
 	u64 u;
-	struct cavm_nixx_af_tl1x_shape_s {
+	struct nixx_af_tl1x_shape_s {
 		u64 adjust                           : 9;
 		u64 reserved_9_23                    : 15;
 		u64 length_disable                   : 1;
 		u64 reserved_25_63                   : 39;
 	} s;
-	struct cavm_nixx_af_tl1x_shape_cn {
+	struct nixx_af_tl1x_shape_cn {
 		u64 adjust                           : 9;
 		u64 reserved_9_17                    : 9;
 		u64 reserved_18_23                   : 6;
@@ -6215,9 +6887,9 @@ union cavm_nixx_af_tl1x_shape {
 	} cn;
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL1X_SHAPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL1X_SHAPE(u64 a)
 {
 	return 0xc10 + 0x10000 * a;
 }
@@ -6228,20 +6900,20 @@ static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
  * NIX AF Transmit Level 1 Shape State Register This register must not be
  * written during normal operation.
  */
-union cavm_nixx_af_tl1x_shape_state {
+union nixx_af_tl1x_shape_state {
 	u64 u;
-	struct cavm_nixx_af_tl1x_shape_state_s {
+	struct nixx_af_tl1x_shape_state_s {
 		u64 cir_accum                        : 26;
 		u64 reserved_26_51                   : 26;
 		u64 color                            : 1;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_nixx_af_tl1x_shape_state_s cn; */
+	/* struct nixx_af_tl1x_shape_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL1X_SHAPE_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL1X_SHAPE_STATE(u64 a)
 {
 	return 0xc50 + 0x10000 * a;
 }
@@ -6251,21 +6923,21 @@ static inline u64 CAVM_NIXX_AF_TL1X_SHAPE_STATE(u64 a)
  *
  * NIX AF Transmit Level 1 Software Controlled XOFF Registers
  */
-union cavm_nixx_af_tl1x_sw_xoff {
+union nixx_af_tl1x_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tl1x_sw_xoff_s {
+	struct nixx_af_tl1x_sw_xoff_s {
 		u64 xoff                             : 1;
 		u64 drain                            : 1;
 		u64 reserved_2                       : 1;
 		u64 drain_irq                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_tl1x_sw_xoff_s cn; */
+	/* struct nixx_af_tl1x_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL1X_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL1X_SW_XOFF(u64 a)
 {
 	return 0xc70 + 0x10000 * a;
 }
@@ -6275,21 +6947,21 @@ static inline u64 CAVM_NIXX_AF_TL1X_SW_XOFF(u64 a)
  *
  * NIX AF Transmit Level 1 Topology Registers
  */
-union cavm_nixx_af_tl1x_topology {
+union nixx_af_tl1x_topology {
 	u64 u;
-	struct cavm_nixx_af_tl1x_topology_s {
+	struct nixx_af_tl1x_topology_s {
 		u64 reserved_0                       : 1;
 		u64 rr_prio                          : 4;
 		u64 reserved_5_31                    : 27;
 		u64 prio_anchor                      : 8;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl1x_topology_s cn; */
+	/* struct nixx_af_tl1x_topology_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL1X_TOPOLOGY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL1X_TOPOLOGY(u64 a)
 {
 	return 0xc80 + 0x10000 * a;
 }
@@ -6299,20 +6971,20 @@ static inline u64 CAVM_NIXX_AF_TL1X_TOPOLOGY(u64 a)
  *
  * INTERNAL: NIX Transmit Level 1 Yellow State Debug Register
  */
-union cavm_nixx_af_tl1x_yellow {
+union nixx_af_tl1x_yellow {
 	u64 u;
-	struct cavm_nixx_af_tl1x_yellow_s {
+	struct nixx_af_tl1x_yellow_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_nixx_af_tl1x_yellow_s cn; */
+	/* struct nixx_af_tl1x_yellow_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW(u64 a)
 {
 	return 0xca0 + 0x10000 * a;
 }
@@ -6323,18 +6995,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
  * NIX AF Transmit Level 1 Yellow Sent Bytes Registers This register has
  * the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
-union cavm_nixx_af_tl1x_yellow_bytes {
+union nixx_af_tl1x_yellow_bytes {
 	u64 u;
-	struct cavm_nixx_af_tl1x_yellow_bytes_s {
+	struct nixx_af_tl1x_yellow_bytes_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_af_tl1x_yellow_bytes_s cn; */
+	/* struct nixx_af_tl1x_yellow_bytes_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
 {
 	return 0xd70 + 0x10000 * a;
 }
@@ -6345,18 +7017,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
  * NIX AF Transmit Level 1 Yellow Sent Packets Registers This register
  * has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
-union cavm_nixx_af_tl1x_yellow_packets {
+union nixx_af_tl1x_yellow_packets {
 	u64 u;
-	struct cavm_nixx_af_tl1x_yellow_packets_s {
+	struct nixx_af_tl1x_yellow_packets_s {
 		u64 count                            : 40;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl1x_yellow_packets_s cn; */
+	/* struct nixx_af_tl1x_yellow_packets_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+static inline u64 NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
 {
 	return 0xd60 + 0x10000 * a;
 }
@@ -6367,18 +7039,18 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
  * NIX AF Transmit Level 1 Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_tl1_const {
+union nixx_af_tl1_const {
 	u64 u;
-	struct cavm_nixx_af_tl1_const_s {
+	struct nixx_af_tl1_const_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_tl1_const_s cn; */
+	/* struct nixx_af_tl1_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
+static inline u64 NIXX_AF_TL1_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
+static inline u64 NIXX_AF_TL1_CONST(void)
 {
 	return 0x70;
 }
@@ -6389,9 +7061,9 @@ static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
  * NIX AF Transmit Level 2 Committed Information Rate Registers This
  * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl2x_cir {
+union nixx_af_tl2x_cir {
 	u64 u;
-	struct cavm_nixx_af_tl2x_cir_s {
+	struct nixx_af_tl2x_cir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -6401,12 +7073,12 @@ union cavm_nixx_af_tl2x_cir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl2x_cir_s cn; */
+	/* struct nixx_af_tl2x_cir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
+static inline u64 NIXX_AF_TL2X_CIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
+static inline u64 NIXX_AF_TL2X_CIR(u64 a)
 {
 	return 0xe20 + 0x10000 * a;
 }
@@ -6417,9 +7089,9 @@ static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
  * INTERNAL: NIX Transmit Level 2 Green State Debug Register  This
  * register has the same bit fields as NIX_AF_TL1()_GREEN.
  */
-union cavm_nixx_af_tl2x_green {
+union nixx_af_tl2x_green {
 	u64 u;
-	struct cavm_nixx_af_tl2x_green_s {
+	struct nixx_af_tl2x_green_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
@@ -6428,12 +7100,12 @@ union cavm_nixx_af_tl2x_green {
 		u64 rr_active                        : 1;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl2x_green_s cn; */
+	/* struct nixx_af_tl2x_green_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL2X_GREEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL2X_GREEN(u64 a)
 {
 	return 0xe90 + 0x10000 * a;
 }
@@ -6444,9 +7116,9 @@ static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
  * NIX AF Transmit Level 2 Meta Descriptor Debug 0 Registers See
  * NIX_AF_TL1()_MD_DEBUG0
  */
-union cavm_nixx_af_tl2x_md_debug0 {
+union nixx_af_tl2x_md_debug0 {
 	u64 u;
-	struct cavm_nixx_af_tl2x_md_debug0_s {
+	struct nixx_af_tl2x_md_debug0_s {
 		u64 pmd0_length                      : 16;
 		u64 pmd1_length                      : 16;
 		u64 pmd0_vld                         : 1;
@@ -6461,12 +7133,30 @@ union cavm_nixx_af_tl2x_md_debug0 {
 		u64 reserved_62                      : 1;
 		u64 pmd_count                        : 1;
 	} s;
-	/* struct cavm_nixx_af_tl2x_md_debug0_s cn; */
+	/* struct nixx_af_tl2x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl2x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug0_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG0(u64 a)
 {
 	return 0xec0 + 0x10000 * a;
 }
@@ -6477,16 +7167,16 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
  * NIX AF Transmit Level 2 Meta Descriptor Debug 1 Registers Packet meta
  * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl2x_md_debug1 {
+union nixx_af_tl2x_md_debug1 {
 	u64 u;
-	struct cavm_nixx_af_tl2x_md_debug1_s {
+	struct nixx_af_tl2x_md_debug1_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -6497,12 +7187,50 @@ union cavm_nixx_af_tl2x_md_debug1 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl2x_md_debug1_s cn; */
+	struct nixx_af_tl2x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl2x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug1_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG1(u64 a)
 {
 	return 0xec8 + 0x10000 * a;
 }
@@ -6513,16 +7241,16 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
  * NIX AF Transmit Level 2 Meta Descriptor Debug 2 Registers Packet meta
  * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl2x_md_debug2 {
+union nixx_af_tl2x_md_debug2 {
 	u64 u;
-	struct cavm_nixx_af_tl2x_md_debug2_s {
+	struct nixx_af_tl2x_md_debug2_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -6533,12 +7261,50 @@ union cavm_nixx_af_tl2x_md_debug2 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl2x_md_debug2_s cn; */
+	struct nixx_af_tl2x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl2x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug2_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG2(u64 a)
 {
 	return 0xed0 + 0x10000 * a;
 }
@@ -6549,9 +7315,9 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
  * NIX AF Transmit Level 2 Meta Descriptor Debug 3 Registers Flush meta
  * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl2x_md_debug3 {
+union nixx_af_tl2x_md_debug3 {
 	u64 u;
-	struct cavm_nixx_af_tl2x_md_debug3_s {
+	struct nixx_af_tl2x_md_debug3_s {
 		u64 reserved_0_36                    : 37;
 		u64 tx_pkt_p2x                       : 2;
 		u64 sqm_pkt_id                       : 13;
@@ -6559,12 +7325,23 @@ union cavm_nixx_af_tl2x_md_debug3 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl2x_md_debug3_s cn; */
+	/* struct nixx_af_tl2x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl2x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl2x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl2x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl2x_md_debug3_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL2X_MD_DEBUG3(u64 a)
 {
 	return 0xed8 + 0x10000 * a;
 }
@@ -6574,19 +7351,19 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG3(u64 a)
  *
  * NIX AF Transmit Level 2 Parent Registers
  */
-union cavm_nixx_af_tl2x_parent {
+union nixx_af_tl2x_parent {
 	u64 u;
-	struct cavm_nixx_af_tl2x_parent_s {
+	struct nixx_af_tl2x_parent_s {
 		u64 reserved_0_15                    : 16;
 		u64 parent                           : 5;
 		u64 reserved_21_63                   : 43;
 	} s;
-	/* struct cavm_nixx_af_tl2x_parent_s cn; */
+	/* struct nixx_af_tl2x_parent_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL2X_PARENT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL2X_PARENT(u64 a)
 {
 	return 0xe88 + 0x10000 * a;
 }
@@ -6597,9 +7374,9 @@ static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
  * NIX AF Transmit Level 2 Peak Information Rate Registers This register
  * has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl2x_pir {
+union nixx_af_tl2x_pir {
 	u64 u;
-	struct cavm_nixx_af_tl2x_pir_s {
+	struct nixx_af_tl2x_pir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -6609,12 +7386,12 @@ union cavm_nixx_af_tl2x_pir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl2x_pir_s cn; */
+	/* struct nixx_af_tl2x_pir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_PIR(u64 a)
+static inline u64 NIXX_AF_TL2X_PIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_PIR(u64 a)
+static inline u64 NIXX_AF_TL2X_PIR(u64 a)
 {
 	return 0xe30 + 0x10000 * a;
 }
@@ -6624,20 +7401,20 @@ static inline u64 CAVM_NIXX_AF_TL2X_PIR(u64 a)
  *
  * INTERNAL: NIX Transmit Level 2 Linked List Pointers Debug Register
  */
-union cavm_nixx_af_tl2x_pointers {
+union nixx_af_tl2x_pointers {
 	u64 u;
-	struct cavm_nixx_af_tl2x_pointers_s {
+	struct nixx_af_tl2x_pointers_s {
 		u64 next                             : 8;
 		u64 reserved_8_15                    : 8;
 		u64 prev                             : 8;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tl2x_pointers_s cn; */
+	/* struct nixx_af_tl2x_pointers_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL2X_POINTERS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL2X_POINTERS(u64 a)
 {
 	return 0xe60 + 0x10000 * a;
 }
@@ -6648,20 +7425,20 @@ static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
  * INTERNAL: NIX Transmit Level 2 Red State Debug Register  This register
  * has the same bit fields as NIX_AF_TL1()_RED.
  */
-union cavm_nixx_af_tl2x_red {
+union nixx_af_tl2x_red {
 	u64 u;
-	struct cavm_nixx_af_tl2x_red_s {
+	struct nixx_af_tl2x_red_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_nixx_af_tl2x_red_s cn; */
+	/* struct nixx_af_tl2x_red_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_RED(u64 a)
+static inline u64 NIXX_AF_TL2X_RED(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_RED(u64 a)
+static inline u64 NIXX_AF_TL2X_RED(u64 a)
 {
 	return 0xeb0 + 0x10000 * a;
 }
@@ -6671,18 +7448,18 @@ static inline u64 CAVM_NIXX_AF_TL2X_RED(u64 a)
  *
  * NIX AF Transmit Level 2 Scheduling Control State Registers
  */
-union cavm_nixx_af_tl2x_sched_state {
+union nixx_af_tl2x_sched_state {
 	u64 u;
-	struct cavm_nixx_af_tl2x_sched_state_s {
+	struct nixx_af_tl2x_sched_state_s {
 		u64 rr_count                         : 25;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_tl2x_sched_state_s cn; */
+	/* struct nixx_af_tl2x_sched_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL2X_SCHED_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL2X_SCHED_STATE(u64 a)
 {
 	return 0xe40 + 0x10000 * a;
 }
@@ -6692,19 +7469,19 @@ static inline u64 CAVM_NIXX_AF_TL2X_SCHED_STATE(u64 a)
  *
  * NIX AF Transmit Level 2 Scheduling Control Registers
  */
-union cavm_nixx_af_tl2x_schedule {
+union nixx_af_tl2x_schedule {
 	u64 u;
-	struct cavm_nixx_af_tl2x_schedule_s {
+	struct nixx_af_tl2x_schedule_s {
 		u64 rr_quantum                       : 24;
 		u64 prio                             : 4;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_nixx_af_tl2x_schedule_s cn; */
+	/* struct nixx_af_tl2x_schedule_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL2X_SCHEDULE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL2X_SCHEDULE(u64 a)
 {
 	return 0xe00 + 0x10000 * a;
 }
@@ -6714,9 +7491,9 @@ static inline u64 CAVM_NIXX_AF_TL2X_SCHEDULE(u64 a)
  *
  * NIX AF Transmit Level 2 Shaping Control Registers
  */
-union cavm_nixx_af_tl2x_shape {
+union nixx_af_tl2x_shape {
 	u64 u;
-	struct cavm_nixx_af_tl2x_shape_s {
+	struct nixx_af_tl2x_shape_s {
 		u64 adjust                           : 9;
 		u64 red_algo                         : 2;
 		u64 red_disable                      : 1;
@@ -6726,12 +7503,12 @@ union cavm_nixx_af_tl2x_shape {
 		u64 schedule_list                    : 2;
 		u64 reserved_27_63                   : 37;
 	} s;
-	/* struct cavm_nixx_af_tl2x_shape_s cn; */
+	/* struct nixx_af_tl2x_shape_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL2X_SHAPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL2X_SHAPE(u64 a)
 {
 	return 0xe10 + 0x10000 * a;
 }
@@ -6742,20 +7519,20 @@ static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
  * NIX AF Transmit Level 2 Shape State Registers This register must not
  * be written during normal operation.
  */
-union cavm_nixx_af_tl2x_shape_state {
+union nixx_af_tl2x_shape_state {
 	u64 u;
-	struct cavm_nixx_af_tl2x_shape_state_s {
+	struct nixx_af_tl2x_shape_state_s {
 		u64 cir_accum                        : 26;
 		u64 pir_accum                        : 26;
 		u64 color                            : 2;
 		u64 reserved_54_63                   : 10;
 	} s;
-	/* struct cavm_nixx_af_tl2x_shape_state_s cn; */
+	/* struct nixx_af_tl2x_shape_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL2X_SHAPE_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL2X_SHAPE_STATE(u64 a)
 {
 	return 0xe50 + 0x10000 * a;
 }
@@ -6766,21 +7543,21 @@ static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
  * NIX AF Transmit Level 2 Software Controlled XOFF Registers This
  * register has the same bit fields as NIX_AF_TL1()_SW_XOFF.
  */
-union cavm_nixx_af_tl2x_sw_xoff {
+union nixx_af_tl2x_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tl2x_sw_xoff_s {
+	struct nixx_af_tl2x_sw_xoff_s {
 		u64 xoff                             : 1;
 		u64 drain                            : 1;
 		u64 reserved_2                       : 1;
 		u64 drain_irq                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_tl2x_sw_xoff_s cn; */
+	/* struct nixx_af_tl2x_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL2X_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL2X_SW_XOFF(u64 a)
 {
 	return 0xe70 + 0x10000 * a;
 }
@@ -6790,21 +7567,21 @@ static inline u64 CAVM_NIXX_AF_TL2X_SW_XOFF(u64 a)
  *
  * NIX AF Transmit Level 2 Topology Registers
  */
-union cavm_nixx_af_tl2x_topology {
+union nixx_af_tl2x_topology {
 	u64 u;
-	struct cavm_nixx_af_tl2x_topology_s {
+	struct nixx_af_tl2x_topology_s {
 		u64 reserved_0                       : 1;
 		u64 rr_prio                          : 4;
 		u64 reserved_5_31                    : 27;
 		u64 prio_anchor                      : 8;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_nixx_af_tl2x_topology_s cn; */
+	/* struct nixx_af_tl2x_topology_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL2X_TOPOLOGY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL2X_TOPOLOGY(u64 a)
 {
 	return 0xe80 + 0x10000 * a;
 }
@@ -6815,20 +7592,20 @@ static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
  * INTERNAL: NIX Transmit Level 2 Yellow State Debug Register  This
  * register has the same bit fields as NIX_AF_TL1()_YELLOW.
  */
-union cavm_nixx_af_tl2x_yellow {
+union nixx_af_tl2x_yellow {
 	u64 u;
-	struct cavm_nixx_af_tl2x_yellow_s {
+	struct nixx_af_tl2x_yellow_s {
 		u64 tail                             : 8;
 		u64 reserved_8_9                     : 2;
 		u64 head                             : 8;
 		u64 reserved_18_63                   : 46;
 	} s;
-	/* struct cavm_nixx_af_tl2x_yellow_s cn; */
+	/* struct nixx_af_tl2x_yellow_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL2X_YELLOW(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL2X_YELLOW(u64 a)
 {
 	return 0xea0 + 0x10000 * a;
 }
@@ -6839,18 +7616,18 @@ static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
  * NIX AF Transmit Level 2 Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_tl2_const {
+union nixx_af_tl2_const {
 	u64 u;
-	struct cavm_nixx_af_tl2_const_s {
+	struct nixx_af_tl2_const_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_tl2_const_s cn; */
+	/* struct nixx_af_tl2_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
+static inline u64 NIXX_AF_TL2_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
+static inline u64 NIXX_AF_TL2_CONST(void)
 {
 	return 0x78;
 }
@@ -6861,9 +7638,9 @@ static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
  * NIX AF Transmit Level 3 Committed Information Rate Registers This
  * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl3x_cir {
+union nixx_af_tl3x_cir {
 	u64 u;
-	struct cavm_nixx_af_tl3x_cir_s {
+	struct nixx_af_tl3x_cir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -6873,12 +7650,12 @@ union cavm_nixx_af_tl3x_cir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl3x_cir_s cn; */
+	/* struct nixx_af_tl3x_cir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_CIR(u64 a)
+static inline u64 NIXX_AF_TL3X_CIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_CIR(u64 a)
+static inline u64 NIXX_AF_TL3X_CIR(u64 a)
 {
 	return 0x1020 + 0x10000 * a;
 }
@@ -6888,9 +7665,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_CIR(u64 a)
  *
  * INTERNAL: NIX Transmit Level 3 Green State Debug Register
  */
-union cavm_nixx_af_tl3x_green {
+union nixx_af_tl3x_green {
 	u64 u;
-	struct cavm_nixx_af_tl3x_green_s {
+	struct nixx_af_tl3x_green_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
@@ -6899,12 +7676,12 @@ union cavm_nixx_af_tl3x_green {
 		u64 rr_active                        : 1;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl3x_green_s cn; */
+	/* struct nixx_af_tl3x_green_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL3X_GREEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL3X_GREEN(u64 a)
 {
 	return 0x1090 + 0x10000 * a;
 }
@@ -6915,9 +7692,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
  * NIX AF Transmit Level 3 Meta Descriptor Debug 0 Registers See
  * NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl3x_md_debug0 {
+union nixx_af_tl3x_md_debug0 {
 	u64 u;
-	struct cavm_nixx_af_tl3x_md_debug0_s {
+	struct nixx_af_tl3x_md_debug0_s {
 		u64 pmd0_length                      : 16;
 		u64 pmd1_length                      : 16;
 		u64 pmd0_vld                         : 1;
@@ -6932,12 +7709,30 @@ union cavm_nixx_af_tl3x_md_debug0 {
 		u64 reserved_62                      : 1;
 		u64 pmd_count                        : 1;
 	} s;
-	/* struct cavm_nixx_af_tl3x_md_debug0_s cn; */
+	/* struct nixx_af_tl3x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl3x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug0_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG0(u64 a)
 {
 	return 0x10c0 + 0x10000 * a;
 }
@@ -6948,16 +7743,16 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
  * NIX AF Transmit Level 3 Meta Descriptor Debug 1 Registers Packet meta
  * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl3x_md_debug1 {
+union nixx_af_tl3x_md_debug1 {
 	u64 u;
-	struct cavm_nixx_af_tl3x_md_debug1_s {
+	struct nixx_af_tl3x_md_debug1_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -6968,12 +7763,50 @@ union cavm_nixx_af_tl3x_md_debug1 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl3x_md_debug1_s cn; */
+	struct nixx_af_tl3x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl3x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug1_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG1(u64 a)
 {
 	return 0x10c8 + 0x10000 * a;
 }
@@ -6984,16 +7817,16 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
  * NIX AF Transmit Level 3 Meta Descriptor Debug 2 Registers Packet meta
  * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl3x_md_debug2 {
+union nixx_af_tl3x_md_debug2 {
 	u64 u;
-	struct cavm_nixx_af_tl3x_md_debug2_s {
+	struct nixx_af_tl3x_md_debug2_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -7004,12 +7837,50 @@ union cavm_nixx_af_tl3x_md_debug2 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl3x_md_debug2_s cn; */
+	struct nixx_af_tl3x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl3x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug2_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG2(u64 a)
 {
 	return 0x10d0 + 0x10000 * a;
 }
@@ -7020,9 +7891,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
  * NIX AF Transmit Level 3 Meta Descriptor Debug 3 Registers Flush meta
  * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl3x_md_debug3 {
+union nixx_af_tl3x_md_debug3 {
 	u64 u;
-	struct cavm_nixx_af_tl3x_md_debug3_s {
+	struct nixx_af_tl3x_md_debug3_s {
 		u64 reserved_0_36                    : 37;
 		u64 tx_pkt_p2x                       : 2;
 		u64 sqm_pkt_id                       : 13;
@@ -7030,12 +7901,23 @@ union cavm_nixx_af_tl3x_md_debug3 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl3x_md_debug3_s cn; */
+	/* struct nixx_af_tl3x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl3x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl3x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl3x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl3x_md_debug3_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL3X_MD_DEBUG3(u64 a)
 {
 	return 0x10d8 + 0x10000 * a;
 }
@@ -7045,19 +7927,19 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG3(u64 a)
  *
  * NIX AF Transmit Level 3 Parent Registers
  */
-union cavm_nixx_af_tl3x_parent {
+union nixx_af_tl3x_parent {
 	u64 u;
-	struct cavm_nixx_af_tl3x_parent_s {
+	struct nixx_af_tl3x_parent_s {
 		u64 reserved_0_15                    : 16;
 		u64 parent                           : 8;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tl3x_parent_s cn; */
+	/* struct nixx_af_tl3x_parent_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL3X_PARENT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL3X_PARENT(u64 a)
 {
 	return 0x1088 + 0x10000 * a;
 }
@@ -7068,9 +7950,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
  * NIX AF Transmit Level 3 Peak Information Rate Registers This register
  * has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl3x_pir {
+union nixx_af_tl3x_pir {
 	u64 u;
-	struct cavm_nixx_af_tl3x_pir_s {
+	struct nixx_af_tl3x_pir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -7080,12 +7962,12 @@ union cavm_nixx_af_tl3x_pir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl3x_pir_s cn; */
+	/* struct nixx_af_tl3x_pir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
+static inline u64 NIXX_AF_TL3X_PIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
+static inline u64 NIXX_AF_TL3X_PIR(u64 a)
 {
 	return 0x1030 + 0x10000 * a;
 }
@@ -7096,20 +7978,20 @@ static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
  * INTERNAL: NIX Transmit Level 3 Linked List Pointers Debug Register
  * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
  */
-union cavm_nixx_af_tl3x_pointers {
+union nixx_af_tl3x_pointers {
 	u64 u;
-	struct cavm_nixx_af_tl3x_pointers_s {
+	struct nixx_af_tl3x_pointers_s {
 		u64 next                             : 8;
 		u64 reserved_8_15                    : 8;
 		u64 prev                             : 8;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tl3x_pointers_s cn; */
+	/* struct nixx_af_tl3x_pointers_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL3X_POINTERS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL3X_POINTERS(u64 a)
 {
 	return 0x1060 + 0x10000 * a;
 }
@@ -7120,20 +8002,20 @@ static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
  * INTERNAL: NIX Transmit Level 3 Red State Debug Register  This register
  * has the same bit fields as NIX_AF_TL3()_YELLOW.
  */
-union cavm_nixx_af_tl3x_red {
+union nixx_af_tl3x_red {
 	u64 u;
-	struct cavm_nixx_af_tl3x_red_s {
+	struct nixx_af_tl3x_red_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_tl3x_red_s cn; */
+	/* struct nixx_af_tl3x_red_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
+static inline u64 NIXX_AF_TL3X_RED(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
+static inline u64 NIXX_AF_TL3X_RED(u64 a)
 {
 	return 0x10b0 + 0x10000 * a;
 }
@@ -7144,18 +8026,18 @@ static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
  * NIX AF Transmit Level 3 Scheduling Control State Registers This
  * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
-union cavm_nixx_af_tl3x_sched_state {
+union nixx_af_tl3x_sched_state {
 	u64 u;
-	struct cavm_nixx_af_tl3x_sched_state_s {
+	struct nixx_af_tl3x_sched_state_s {
 		u64 rr_count                         : 25;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_tl3x_sched_state_s cn; */
+	/* struct nixx_af_tl3x_sched_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL3X_SCHED_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL3X_SCHED_STATE(u64 a)
 {
 	return 0x1040 + 0x10000 * a;
 }
@@ -7166,19 +8048,19 @@ static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
  * NIX AF Transmit Level 3 Scheduling Control Registers This register has
  * the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
-union cavm_nixx_af_tl3x_schedule {
+union nixx_af_tl3x_schedule {
 	u64 u;
-	struct cavm_nixx_af_tl3x_schedule_s {
+	struct nixx_af_tl3x_schedule_s {
 		u64 rr_quantum                       : 24;
 		u64 prio                             : 4;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_nixx_af_tl3x_schedule_s cn; */
+	/* struct nixx_af_tl3x_schedule_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL3X_SCHEDULE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL3X_SCHEDULE(u64 a)
 {
 	return 0x1000 + 0x10000 * a;
 }
@@ -7188,9 +8070,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_SCHEDULE(u64 a)
  *
  * NIX AF Transmit Level 3 Shaping Control Registers
  */
-union cavm_nixx_af_tl3x_shape {
+union nixx_af_tl3x_shape {
 	u64 u;
-	struct cavm_nixx_af_tl3x_shape_s {
+	struct nixx_af_tl3x_shape_s {
 		u64 adjust                           : 9;
 		u64 red_algo                         : 2;
 		u64 red_disable                      : 1;
@@ -7200,12 +8082,12 @@ union cavm_nixx_af_tl3x_shape {
 		u64 schedule_list                    : 2;
 		u64 reserved_27_63                   : 37;
 	} s;
-	/* struct cavm_nixx_af_tl3x_shape_s cn; */
+	/* struct nixx_af_tl3x_shape_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL3X_SHAPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL3X_SHAPE(u64 a)
 {
 	return 0x1010 + 0x10000 * a;
 }
@@ -7217,20 +8099,20 @@ static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
  * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
  * written during normal operation.
  */
-union cavm_nixx_af_tl3x_shape_state {
+union nixx_af_tl3x_shape_state {
 	u64 u;
-	struct cavm_nixx_af_tl3x_shape_state_s {
+	struct nixx_af_tl3x_shape_state_s {
 		u64 cir_accum                        : 26;
 		u64 pir_accum                        : 26;
 		u64 color                            : 2;
 		u64 reserved_54_63                   : 10;
 	} s;
-	/* struct cavm_nixx_af_tl3x_shape_state_s cn; */
+	/* struct nixx_af_tl3x_shape_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL3X_SHAPE_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL3X_SHAPE_STATE(u64 a)
 {
 	return 0x1050 + 0x10000 * a;
 }
@@ -7241,21 +8123,21 @@ static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
  * NIX AF Transmit Level 3 Software Controlled XOFF Registers This
  * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
  */
-union cavm_nixx_af_tl3x_sw_xoff {
+union nixx_af_tl3x_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tl3x_sw_xoff_s {
+	struct nixx_af_tl3x_sw_xoff_s {
 		u64 xoff                             : 1;
 		u64 drain                            : 1;
 		u64 reserved_2                       : 1;
 		u64 drain_irq                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_tl3x_sw_xoff_s cn; */
+	/* struct nixx_af_tl3x_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL3X_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL3X_SW_XOFF(u64 a)
 {
 	return 0x1070 + 0x10000 * a;
 }
@@ -7265,21 +8147,21 @@ static inline u64 CAVM_NIXX_AF_TL3X_SW_XOFF(u64 a)
  *
  * NIX AF Transmit Level 3 Topology Registers
  */
-union cavm_nixx_af_tl3x_topology {
+union nixx_af_tl3x_topology {
 	u64 u;
-	struct cavm_nixx_af_tl3x_topology_s {
+	struct nixx_af_tl3x_topology_s {
 		u64 reserved_0                       : 1;
 		u64 rr_prio                          : 4;
 		u64 reserved_5_31                    : 27;
 		u64 prio_anchor                      : 9;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl3x_topology_s cn; */
+	/* struct nixx_af_tl3x_topology_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL3X_TOPOLOGY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL3X_TOPOLOGY(u64 a)
 {
 	return 0x1080 + 0x10000 * a;
 }
@@ -7289,20 +8171,20 @@ static inline u64 CAVM_NIXX_AF_TL3X_TOPOLOGY(u64 a)
  *
  * INTERNAL: NIX Transmit Level 3 Yellow State Debug Register
  */
-union cavm_nixx_af_tl3x_yellow {
+union nixx_af_tl3x_yellow {
 	u64 u;
-	struct cavm_nixx_af_tl3x_yellow_s {
+	struct nixx_af_tl3x_yellow_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_tl3x_yellow_s cn; */
+	/* struct nixx_af_tl3x_yellow_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL3X_YELLOW(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL3X_YELLOW(u64 a)
 {
 	return 0x10a0 + 0x10000 * a;
 }
@@ -7313,18 +8195,18 @@ static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
  * NIX AF Transmit Level 3 Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_tl3_const {
+union nixx_af_tl3_const {
 	u64 u;
-	struct cavm_nixx_af_tl3_const_s {
+	struct nixx_af_tl3_const_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_tl3_const_s cn; */
+	/* struct nixx_af_tl3_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3_CONST(void)
+static inline u64 NIXX_AF_TL3_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3_CONST(void)
+static inline u64 NIXX_AF_TL3_CONST(void)
 {
 	return 0x80;
 }
@@ -7334,18 +8216,18 @@ static inline u64 CAVM_NIXX_AF_TL3_CONST(void)
  *
  * NIX AF Transmit Level 3/2 Backpressure Status Registers
  */
-union cavm_nixx_af_tl3_tl2x_bp_status {
+union nixx_af_tl3_tl2x_bp_status {
 	u64 u;
-	struct cavm_nixx_af_tl3_tl2x_bp_status_s {
+	struct nixx_af_tl3_tl2x_bp_status_s {
 		u64 hw_xoff                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_tl3_tl2x_bp_status_s cn; */
+	/* struct nixx_af_tl3_tl2x_bp_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+static inline u64 NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+static inline u64 NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
 {
 	return 0x1610 + 0x10000 * a;
 }
@@ -7355,18 +8237,18 @@ static inline u64 CAVM_NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
  *
  * NIX AF Transmit Level 3/2 Configuration Registers
  */
-union cavm_nixx_af_tl3_tl2x_cfg {
+union nixx_af_tl3_tl2x_cfg {
 	u64 u;
-	struct cavm_nixx_af_tl3_tl2x_cfg_s {
+	struct nixx_af_tl3_tl2x_cfg_s {
 		u64 express                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_tl3_tl2x_cfg_s cn; */
+	/* struct nixx_af_tl3_tl2x_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
+static inline u64 NIXX_AF_TL3_TL2X_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
+static inline u64 NIXX_AF_TL3_TL2X_CFG(u64 a)
 {
 	return 0x1600 + 0x10000 * a;
 }
@@ -7381,21 +8263,21 @@ static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
  * backpressured by one or more links and associated channels. The last
  * index (LINK) is enumerated by NIX_LINK_E.
  */
-union cavm_nixx_af_tl3_tl2x_linkx_cfg {
+union nixx_af_tl3_tl2x_linkx_cfg {
 	u64 u;
-	struct cavm_nixx_af_tl3_tl2x_linkx_cfg_s {
+	struct nixx_af_tl3_tl2x_linkx_cfg_s {
 		u64 relchan                          : 8;
 		u64 reserved_8_11                    : 4;
 		u64 ena                              : 1;
 		u64 bp_ena                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_nixx_af_tl3_tl2x_linkx_cfg_s cn; */
+	/* struct nixx_af_tl3_tl2x_linkx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+static inline u64 NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+static inline u64 NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
 {
 	return 0x1700 + 0x10000 * a + 8 * b;
 }
@@ -7405,18 +8287,18 @@ static inline u64 CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
  *
  * NIX AF Transmit Level 4 Backpressure Status Registers
  */
-union cavm_nixx_af_tl4x_bp_status {
+union nixx_af_tl4x_bp_status {
 	u64 u;
-	struct cavm_nixx_af_tl4x_bp_status_s {
+	struct nixx_af_tl4x_bp_status_s {
 		u64 hw_xoff                          : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_tl4x_bp_status_s cn; */
+	/* struct nixx_af_tl4x_bp_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
+static inline u64 NIXX_AF_TL4X_BP_STATUS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
+static inline u64 NIXX_AF_TL4X_BP_STATUS(u64 a)
 {
 	return 0xb00 + 0x10000 * a;
 }
@@ -7427,9 +8309,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
  * NIX AF Transmit Level 4 Committed Information Rate Registers This
  * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl4x_cir {
+union nixx_af_tl4x_cir {
 	u64 u;
-	struct cavm_nixx_af_tl4x_cir_s {
+	struct nixx_af_tl4x_cir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -7439,12 +8321,12 @@ union cavm_nixx_af_tl4x_cir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl4x_cir_s cn; */
+	/* struct nixx_af_tl4x_cir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
+static inline u64 NIXX_AF_TL4X_CIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
+static inline u64 NIXX_AF_TL4X_CIR(u64 a)
 {
 	return 0x1220 + 0x10000 * a;
 }
@@ -7455,9 +8337,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
  * INTERNAL: NIX Transmit Level 4 Green State Debug Register  This
  * register has the same bit fields as NIX_AF_TL3()_GREEN.
  */
-union cavm_nixx_af_tl4x_green {
+union nixx_af_tl4x_green {
 	u64 u;
-	struct cavm_nixx_af_tl4x_green_s {
+	struct nixx_af_tl4x_green_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
@@ -7466,12 +8348,12 @@ union cavm_nixx_af_tl4x_green {
 		u64 rr_active                        : 1;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl4x_green_s cn; */
+	/* struct nixx_af_tl4x_green_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL4X_GREEN(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
+static inline u64 NIXX_AF_TL4X_GREEN(u64 a)
 {
 	return 0x1290 + 0x10000 * a;
 }
@@ -7482,9 +8364,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
  * NIX AF Transmit Level 4 Meta Descriptor Debug 0 Registers See
  * NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl4x_md_debug0 {
+union nixx_af_tl4x_md_debug0 {
 	u64 u;
-	struct cavm_nixx_af_tl4x_md_debug0_s {
+	struct nixx_af_tl4x_md_debug0_s {
 		u64 pmd0_length                      : 16;
 		u64 pmd1_length                      : 16;
 		u64 pmd0_vld                         : 1;
@@ -7499,12 +8381,30 @@ union cavm_nixx_af_tl4x_md_debug0 {
 		u64 reserved_62                      : 1;
 		u64 pmd_count                        : 1;
 	} s;
-	/* struct cavm_nixx_af_tl4x_md_debug0_s cn; */
+	/* struct nixx_af_tl4x_md_debug0_s cn96xxp1; */
+	struct nixx_af_tl4x_md_debug0_cn96xxp3 {
+		u64 pmd0_length                      : 16;
+		u64 reserved_16_31                   : 16;
+		u64 pmd0_vld                         : 1;
+		u64 reserved_33                      : 1;
+		u64 reserved_34_45                   : 12;
+		u64 reserved_46                      : 1;
+		u64 reserved_47                      : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug0_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug0_s cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug0_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG0(u64 a)
 {
 	return 0x12c0 + 0x10000 * a;
 }
@@ -7515,16 +8415,16 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
  * NIX AF Transmit Level 4 Meta Descriptor Debug 1 Registers Packet meta
  * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl4x_md_debug1 {
+union nixx_af_tl4x_md_debug1 {
 	u64 u;
-	struct cavm_nixx_af_tl4x_md_debug1_s {
+	struct nixx_af_tl4x_md_debug1_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -7535,12 +8435,50 @@ union cavm_nixx_af_tl4x_md_debug1 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl4x_md_debug1_s cn; */
+	struct nixx_af_tl4x_md_debug1_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl4x_md_debug1_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug1_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG1(u64 a)
 {
 	return 0x12c8 + 0x10000 * a;
 }
@@ -7551,16 +8489,16 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
  * NIX AF Transmit Level 4 Meta Descriptor Debug 2 Registers Packet meta
  * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl4x_md_debug2 {
+union nixx_af_tl4x_md_debug2 {
 	u64 u;
-	struct cavm_nixx_af_tl4x_md_debug2_s {
+	struct nixx_af_tl4x_md_debug2_s {
 		u64 reserved_0_5                     : 6;
 		u64 red_algo_override                : 2;
 		u64 cir_dis                          : 1;
 		u64 pir_dis                          : 1;
 		u64 adjust                           : 9;
 		u64 uid                              : 4;
-		u64 drain                            : 1;
+		u64 reserved_23                      : 1;
 		u64 bubble                           : 1;
 		u64 color                            : 2;
 		u64 pse_pkt_id                       : 9;
@@ -7571,12 +8509,50 @@ union cavm_nixx_af_tl4x_md_debug2 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl4x_md_debug2_s cn; */
+	struct nixx_af_tl4x_md_debug2_cn96xxp1 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp1;
+	struct nixx_af_tl4x_md_debug2_cn96xxp3 {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 reserved_19_22                   : 4;
+		u64 flush                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp1 cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug2_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG2(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG2(u64 a)
 {
 	return 0x12d0 + 0x10000 * a;
 }
@@ -7587,9 +8563,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
  * NIX AF Transmit Level 4 Meta Descriptor Debug 3 Registers Flush meta
  * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
-union cavm_nixx_af_tl4x_md_debug3 {
+union nixx_af_tl4x_md_debug3 {
 	u64 u;
-	struct cavm_nixx_af_tl4x_md_debug3_s {
+	struct nixx_af_tl4x_md_debug3_s {
 		u64 reserved_0_36                    : 37;
 		u64 tx_pkt_p2x                       : 2;
 		u64 sqm_pkt_id                       : 13;
@@ -7597,12 +8573,23 @@ union cavm_nixx_af_tl4x_md_debug3 {
 		u64 reserved_62                      : 1;
 		u64 vld                              : 1;
 	} s;
-	/* struct cavm_nixx_af_tl4x_md_debug3_s cn; */
+	/* struct nixx_af_tl4x_md_debug3_s cn96xxp1; */
+	struct nixx_af_tl4x_md_debug3_cn96xxp3 {
+		u64 reserved_0_36                    : 37;
+		u64 reserved_37_38                   : 2;
+		u64 reserved_39_51                   : 13;
+		u64 reserved_52_61                   : 10;
+		u64 reserved_62                      : 1;
+		u64 reserved_63                      : 1;
+	} cn96xxp3;
+	/* struct nixx_af_tl4x_md_debug3_cn96xxp3 cn98xx; */
+	/* struct nixx_af_tl4x_md_debug3_s cnf95xx; */
+	/* struct nixx_af_tl4x_md_debug3_cn96xxp3 loki; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG3(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+static inline u64 NIXX_AF_TL4X_MD_DEBUG3(u64 a)
 {
 	return 0x12d8 + 0x10000 * a;
 }
@@ -7612,19 +8599,19 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG3(u64 a)
  *
  * NIX AF Transmit Level 4 Parent Registers
  */
-union cavm_nixx_af_tl4x_parent {
+union nixx_af_tl4x_parent {
 	u64 u;
-	struct cavm_nixx_af_tl4x_parent_s {
+	struct nixx_af_tl4x_parent_s {
 		u64 reserved_0_15                    : 16;
 		u64 parent                           : 8;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tl4x_parent_s cn; */
+	/* struct nixx_af_tl4x_parent_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL4X_PARENT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
+static inline u64 NIXX_AF_TL4X_PARENT(u64 a)
 {
 	return 0x1288 + 0x10000 * a;
 }
@@ -7635,9 +8622,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
  * NIX AF Transmit Level 4 Peak Information Rate Registers This register
  * has the same bit fields as NIX_AF_TL1()_CIR.
  */
-union cavm_nixx_af_tl4x_pir {
+union nixx_af_tl4x_pir {
 	u64 u;
-	struct cavm_nixx_af_tl4x_pir_s {
+	struct nixx_af_tl4x_pir_s {
 		u64 enable                           : 1;
 		u64 rate_mantissa                    : 8;
 		u64 rate_exponent                    : 4;
@@ -7647,12 +8634,12 @@ union cavm_nixx_af_tl4x_pir {
 		u64 burst_exponent                   : 4;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl4x_pir_s cn; */
+	/* struct nixx_af_tl4x_pir_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
+static inline u64 NIXX_AF_TL4X_PIR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
+static inline u64 NIXX_AF_TL4X_PIR(u64 a)
 {
 	return 0x1230 + 0x10000 * a;
 }
@@ -7663,20 +8650,20 @@ static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
  * INTERNAL: NIX Transmit Level 4 Linked List Pointers Debug Register
  * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
  */
-union cavm_nixx_af_tl4x_pointers {
+union nixx_af_tl4x_pointers {
 	u64 u;
-	struct cavm_nixx_af_tl4x_pointers_s {
+	struct nixx_af_tl4x_pointers_s {
 		u64 next                             : 9;
 		u64 reserved_9_15                    : 7;
 		u64 prev                             : 9;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_tl4x_pointers_s cn; */
+	/* struct nixx_af_tl4x_pointers_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL4X_POINTERS(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
+static inline u64 NIXX_AF_TL4X_POINTERS(u64 a)
 {
 	return 0x1260 + 0x10000 * a;
 }
@@ -7687,20 +8674,20 @@ static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
  * INTERNAL: NIX Transmit Level 4 Red State Debug Register  This register
  * has the same bit fields as NIX_AF_TL3()_YELLOW.
  */
-union cavm_nixx_af_tl4x_red {
+union nixx_af_tl4x_red {
 	u64 u;
-	struct cavm_nixx_af_tl4x_red_s {
+	struct nixx_af_tl4x_red_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_tl4x_red_s cn; */
+	/* struct nixx_af_tl4x_red_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
+static inline u64 NIXX_AF_TL4X_RED(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
+static inline u64 NIXX_AF_TL4X_RED(u64 a)
 {
 	return 0x12b0 + 0x10000 * a;
 }
@@ -7711,18 +8698,18 @@ static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
  * NIX AF Transmit Level 4 Scheduling Control State Registers This
  * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
-union cavm_nixx_af_tl4x_sched_state {
+union nixx_af_tl4x_sched_state {
 	u64 u;
-	struct cavm_nixx_af_tl4x_sched_state_s {
+	struct nixx_af_tl4x_sched_state_s {
 		u64 rr_count                         : 25;
 		u64 reserved_25_63                   : 39;
 	} s;
-	/* struct cavm_nixx_af_tl4x_sched_state_s cn; */
+	/* struct nixx_af_tl4x_sched_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL4X_SCHED_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
+static inline u64 NIXX_AF_TL4X_SCHED_STATE(u64 a)
 {
 	return 0x1240 + 0x10000 * a;
 }
@@ -7733,19 +8720,19 @@ static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
  * NIX AF Transmit Level 4 Scheduling Control Registers This register has
  * the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
-union cavm_nixx_af_tl4x_schedule {
+union nixx_af_tl4x_schedule {
 	u64 u;
-	struct cavm_nixx_af_tl4x_schedule_s {
+	struct nixx_af_tl4x_schedule_s {
 		u64 rr_quantum                       : 24;
 		u64 prio                             : 4;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_nixx_af_tl4x_schedule_s cn; */
+	/* struct nixx_af_tl4x_schedule_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL4X_SCHEDULE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
+static inline u64 NIXX_AF_TL4X_SCHEDULE(u64 a)
 {
 	return 0x1200 + 0x10000 * a;
 }
@@ -7757,21 +8744,21 @@ static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
  * specify which TL4 queues transmit to and are optionally backpressured
  * by SDP.
  */
-union cavm_nixx_af_tl4x_sdp_link_cfg {
+union nixx_af_tl4x_sdp_link_cfg {
 	u64 u;
-	struct cavm_nixx_af_tl4x_sdp_link_cfg_s {
+	struct nixx_af_tl4x_sdp_link_cfg_s {
 		u64 relchan                          : 8;
 		u64 reserved_8_11                    : 4;
 		u64 ena                              : 1;
 		u64 bp_ena                           : 1;
 		u64 reserved_14_63                   : 50;
 	} s;
-	/* struct cavm_nixx_af_tl4x_sdp_link_cfg_s cn; */
+	/* struct nixx_af_tl4x_sdp_link_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+static inline u64 NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+static inline u64 NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
 {
 	return 0xb10 + 0x10000 * a;
 }
@@ -7782,9 +8769,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
  * NIX AF Transmit Level 4 Shaping Control Registers This register has
  * the same bit fields as NIX_AF_TL2()_SHAPE.
  */
-union cavm_nixx_af_tl4x_shape {
+union nixx_af_tl4x_shape {
 	u64 u;
-	struct cavm_nixx_af_tl4x_shape_s {
+	struct nixx_af_tl4x_shape_s {
 		u64 adjust                           : 9;
 		u64 red_algo                         : 2;
 		u64 red_disable                      : 1;
@@ -7794,12 +8781,12 @@ union cavm_nixx_af_tl4x_shape {
 		u64 schedule_list                    : 2;
 		u64 reserved_27_63                   : 37;
 	} s;
-	/* struct cavm_nixx_af_tl4x_shape_s cn; */
+	/* struct nixx_af_tl4x_shape_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL4X_SHAPE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
+static inline u64 NIXX_AF_TL4X_SHAPE(u64 a)
 {
 	return 0x1210 + 0x10000 * a;
 }
@@ -7811,20 +8798,20 @@ static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
  * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
  * written during normal operation.
  */
-union cavm_nixx_af_tl4x_shape_state {
+union nixx_af_tl4x_shape_state {
 	u64 u;
-	struct cavm_nixx_af_tl4x_shape_state_s {
+	struct nixx_af_tl4x_shape_state_s {
 		u64 cir_accum                        : 26;
 		u64 pir_accum                        : 26;
 		u64 color                            : 2;
 		u64 reserved_54_63                   : 10;
 	} s;
-	/* struct cavm_nixx_af_tl4x_shape_state_s cn; */
+	/* struct nixx_af_tl4x_shape_state_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL4X_SHAPE_STATE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+static inline u64 NIXX_AF_TL4X_SHAPE_STATE(u64 a)
 {
 	return 0x1250 + 0x10000 * a;
 }
@@ -7835,21 +8822,21 @@ static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
  * NIX AF Transmit Level 4 Software Controlled XOFF Registers This
  * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
  */
-union cavm_nixx_af_tl4x_sw_xoff {
+union nixx_af_tl4x_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tl4x_sw_xoff_s {
+	struct nixx_af_tl4x_sw_xoff_s {
 		u64 xoff                             : 1;
 		u64 drain                            : 1;
 		u64 reserved_2                       : 1;
 		u64 drain_irq                        : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_nixx_af_tl4x_sw_xoff_s cn; */
+	/* struct nixx_af_tl4x_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL4X_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TL4X_SW_XOFF(u64 a)
 {
 	return 0x1270 + 0x10000 * a;
 }
@@ -7859,21 +8846,21 @@ static inline u64 CAVM_NIXX_AF_TL4X_SW_XOFF(u64 a)
  *
  * NIX AF Transmit Level 4 Topology Registers
  */
-union cavm_nixx_af_tl4x_topology {
+union nixx_af_tl4x_topology {
 	u64 u;
-	struct cavm_nixx_af_tl4x_topology_s {
+	struct nixx_af_tl4x_topology_s {
 		u64 reserved_0                       : 1;
 		u64 rr_prio                          : 4;
 		u64 reserved_5_31                    : 27;
 		u64 prio_anchor                      : 9;
 		u64 reserved_41_63                   : 23;
 	} s;
-	/* struct cavm_nixx_af_tl4x_topology_s cn; */
+	/* struct nixx_af_tl4x_topology_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL4X_TOPOLOGY(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
+static inline u64 NIXX_AF_TL4X_TOPOLOGY(u64 a)
 {
 	return 0x1280 + 0x10000 * a;
 }
@@ -7884,20 +8871,20 @@ static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
  * INTERNAL: NIX Transmit Level 4 Yellow State Debug Register  This
  * register has the same bit fields as NIX_AF_TL3()_YELLOW
  */
-union cavm_nixx_af_tl4x_yellow {
+union nixx_af_tl4x_yellow {
 	u64 u;
-	struct cavm_nixx_af_tl4x_yellow_s {
+	struct nixx_af_tl4x_yellow_s {
 		u64 tail                             : 9;
 		u64 reserved_9                       : 1;
 		u64 head                             : 9;
 		u64 reserved_19_63                   : 45;
 	} s;
-	/* struct cavm_nixx_af_tl4x_yellow_s cn; */
+	/* struct nixx_af_tl4x_yellow_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL4X_YELLOW(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
+static inline u64 NIXX_AF_TL4X_YELLOW(u64 a)
 {
 	return 0x12a0 + 0x10000 * a;
 }
@@ -7908,18 +8895,18 @@ static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
  * NIX AF Transmit Level 4 Constants Register This register contains
  * constants for software discovery.
  */
-union cavm_nixx_af_tl4_const {
+union nixx_af_tl4_const {
 	u64 u;
-	struct cavm_nixx_af_tl4_const_s {
+	struct nixx_af_tl4_const_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_nixx_af_tl4_const_s cn; */
+	/* struct nixx_af_tl4_const_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
+static inline u64 NIXX_AF_TL4_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
+static inline u64 NIXX_AF_TL4_CONST(void)
 {
 	return 0x88;
 }
@@ -7927,25 +8914,27 @@ static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_expr_credit
  *
- * NIX AF Transmit Link Express Credit Registers These registers track
- * credits per link for express packets that may potentially preempt
- * normal packets. Link index enumerated by NIX_LINK_E.
+ * INTERNAL: NIX AF Transmit Link Express Credit Registers  Internal:
+ * 802.3br frame preemption/express path is defeatured. Old definition:
+ * These registers track credits per link for express packets that may
+ * potentially preempt normal packets. Link index enumerated by
+ * NIX_LINK_E.
  */
-union cavm_nixx_af_tx_linkx_expr_credit {
+union nixx_af_tx_linkx_expr_credit {
 	u64 u;
-	struct cavm_nixx_af_tx_linkx_expr_credit_s {
+	struct nixx_af_tx_linkx_expr_credit_s {
 		u64 reserved_0                       : 1;
 		u64 cc_enable                        : 1;
 		u64 cc_packet_cnt                    : 10;
 		u64 cc_unit_cnt                      : 20;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_tx_linkx_expr_credit_s cn; */
+	/* struct nixx_af_tx_linkx_expr_credit_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
 {
 	return 0xa10 + 0x10000 * a;
 }
@@ -7956,17 +8945,17 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
  * NIX AF Transmit Link Hardware Controlled XOFF Registers Link index
  * enumerated by NIX_LINK_E.
  */
-union cavm_nixx_af_tx_linkx_hw_xoff {
+union nixx_af_tx_linkx_hw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tx_linkx_hw_xoff_s {
+	struct nixx_af_tx_linkx_hw_xoff_s {
 		u64 chan_xoff                        : 64;
 	} s;
-	/* struct cavm_nixx_af_tx_linkx_hw_xoff_s cn; */
+	/* struct nixx_af_tx_linkx_hw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
 {
 	return 0xa30 + 0x10000 * a;
 }
@@ -7975,24 +8964,24 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_norm_credit
  *
  * NIX AF Transmit Link Normal Credit Registers These registers track
- * credits per link for normal (potentially preemptable) packets sent to
- * CGX and LBK. Link index enumerated by NIX_LINK_E.
+ * credits per link for normal packets sent to CGX and LBK. Link index
+ * enumerated by NIX_LINK_E.
  */
-union cavm_nixx_af_tx_linkx_norm_credit {
+union nixx_af_tx_linkx_norm_credit {
 	u64 u;
-	struct cavm_nixx_af_tx_linkx_norm_credit_s {
+	struct nixx_af_tx_linkx_norm_credit_s {
 		u64 reserved_0                       : 1;
 		u64 cc_enable                        : 1;
 		u64 cc_packet_cnt                    : 10;
 		u64 cc_unit_cnt                      : 20;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_tx_linkx_norm_credit_s cn; */
+	/* struct nixx_af_tx_linkx_norm_credit_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
 {
 	return 0xa00 + 0x10000 * a;
 }
@@ -8000,20 +8989,23 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_sw_xoff
  *
- * NIX AF Transmit Link Software Controlled XOFF Registers Link index
- * enumerated by NIX_LINK_E.
+ * INTERNAL: NIX AF Transmit Link Software Controlled XOFF Registers
+ * Link index enumerated by NIX_LINK_E. Internal: Defeatured registers.
+ * Software should instead use NIX_AF_TL3()_SW_XOFF registers when
+ * NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL] is set and NIX_AF_TL2()_SW_XOFF
+ * registers when NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL] is clear.
  */
-union cavm_nixx_af_tx_linkx_sw_xoff {
+union nixx_af_tx_linkx_sw_xoff {
 	u64 u;
-	struct cavm_nixx_af_tx_linkx_sw_xoff_s {
+	struct nixx_af_tx_linkx_sw_xoff_s {
 		u64 chan_xoff                        : 64;
 	} s;
-	/* struct cavm_nixx_af_tx_linkx_sw_xoff_s cn; */
+	/* struct nixx_af_tx_linkx_sw_xoff_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+static inline u64 NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
 {
 	return 0xa20 + 0x10000 * a;
 }
@@ -8029,21 +9021,21 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
  * points to the start of the multicast replication list, and [EOL] = 1
  * indicates the end of list.
  */
-union cavm_nixx_af_tx_mcastx {
+union nixx_af_tx_mcastx {
 	u64 u;
-	struct cavm_nixx_af_tx_mcastx_s {
+	struct nixx_af_tx_mcastx_s {
 		u64 channel                          : 12;
 		u64 eol                              : 1;
 		u64 reserved_13_15                   : 3;
 		u64 next                             : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_nixx_af_tx_mcastx_s cn; */
+	/* struct nixx_af_tx_mcastx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
+static inline u64 NIXX_AF_TX_MCASTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
+static inline u64 NIXX_AF_TX_MCASTX(u64 a)
 {
 	return 0x1900 + 0x8000 * a;
 }
@@ -8056,9 +9048,9 @@ static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
  * allows NPC responses for selected packets to be captured in
  * NIX_AF_TX_NPC_CAPTURE_INFO and NIX_AF_TX_NPC_CAPTURE_RESP().
  */
-union cavm_nixx_af_tx_npc_capture_config {
+union nixx_af_tx_npc_capture_config {
 	u64 u;
-	struct cavm_nixx_af_tx_npc_capture_config_s {
+	struct nixx_af_tx_npc_capture_config_s {
 		u64 en                               : 1;
 		u64 continuous                       : 1;
 		u64 lso_segnum_en                    : 1;
@@ -8071,12 +9063,12 @@ union cavm_nixx_af_tx_npc_capture_config {
 		u64 sq_id                            : 20;
 		u64 lf_id                            : 8;
 	} s;
-	/* struct cavm_nixx_af_tx_npc_capture_config_s cn; */
+	/* struct nixx_af_tx_npc_capture_config_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
 {
 	return 0x660;
 }
@@ -8088,9 +9080,9 @@ static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
  * register contains captured NPC response information for a transmit
  * packet. See NIX_AF_TX_NPC_CAPTURE_CONFIG.
  */
-union cavm_nixx_af_tx_npc_capture_info {
+union nixx_af_tx_npc_capture_info {
 	u64 u;
-	struct cavm_nixx_af_tx_npc_capture_info_s {
+	struct nixx_af_tx_npc_capture_info_s {
 		u64 vld                              : 1;
 		u64 reserved_1_11                    : 11;
 		u64 lso_segnum                       : 8;
@@ -8098,12 +9090,12 @@ union cavm_nixx_af_tx_npc_capture_info {
 		u64 sq_id                            : 20;
 		u64 lf_id                            : 8;
 	} s;
-	/* struct cavm_nixx_af_tx_npc_capture_info_s cn; */
+	/* struct nixx_af_tx_npc_capture_info_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_INFO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_INFO(void)
 {
 	return 0x668;
 }
@@ -8116,17 +9108,17 @@ static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
  * NIX_AF_TX_NPC_CAPTURE_INFO[VLD] is set. See also
  * NIX_AF_TX_NPC_CAPTURE_CONFIG.
  */
-union cavm_nixx_af_tx_npc_capture_respx {
+union nixx_af_tx_npc_capture_respx {
 	u64 u;
-	struct cavm_nixx_af_tx_npc_capture_respx_s {
+	struct nixx_af_tx_npc_capture_respx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_nixx_af_tx_npc_capture_respx_s cn; */
+	/* struct nixx_af_tx_npc_capture_respx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+static inline u64 NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
 {
 	return 0x680 + 8 * a;
 }
@@ -8136,20 +9128,20 @@ static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
  *
  * NIX AF Transmit Timestamp Configuration Register
  */
-union cavm_nixx_af_tx_tstmp_cfg {
+union nixx_af_tx_tstmp_cfg {
 	u64 u;
-	struct cavm_nixx_af_tx_tstmp_cfg_s {
+	struct nixx_af_tx_tstmp_cfg_s {
 		u64 tstmp_wd_period                  : 4;
 		u64 reserved_4_7                     : 4;
 		u64 express                          : 16;
 		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_nixx_af_tx_tstmp_cfg_s cn; */
+	/* struct nixx_af_tx_tstmp_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
+static inline u64 NIXX_AF_TX_TSTMP_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
+static inline u64 NIXX_AF_TX_TSTMP_CFG(void)
 {
 	return 0xc0;
 }
@@ -8162,18 +9154,18 @@ static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
  * optionally insert or replace in the TX packet header. Indexed by
  * NIX_TX_VTAG_ACTION_S[VTAG*_DEF].
  */
-union cavm_nixx_af_tx_vtag_defx_ctl {
+union nixx_af_tx_vtag_defx_ctl {
 	u64 u;
-	struct cavm_nixx_af_tx_vtag_defx_ctl_s {
+	struct nixx_af_tx_vtag_defx_ctl_s {
 		u64 size                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_af_tx_vtag_defx_ctl_s cn; */
+	/* struct nixx_af_tx_vtag_defx_ctl_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+static inline u64 NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+static inline u64 NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
 {
 	return 0x1a00 + 0x10000 * a;
 }
@@ -8184,17 +9176,17 @@ static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
  * NIX AF Transmit Vtag Definition Data Registers See
  * NIX_AF_TX_VTAG_DEF()_CTL.
  */
-union cavm_nixx_af_tx_vtag_defx_data {
+union nixx_af_tx_vtag_defx_data {
 	u64 u;
-	struct cavm_nixx_af_tx_vtag_defx_data_s {
+	struct nixx_af_tx_vtag_defx_data_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_nixx_af_tx_vtag_defx_data_s cn; */
+	/* struct nixx_af_tx_vtag_defx_data_s cn; */
 };
 
-static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+static inline u64 NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+static inline u64 NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
 {
 	return 0x1a10 + 0x10000 * a;
 }
@@ -8204,18 +9196,18 @@ static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
  *
  * NIX LF Configuration Register
  */
-union cavm_nixx_lf_cfg {
+union nixx_lf_cfg {
 	u64 u;
-	struct cavm_nixx_lf_cfg_s {
+	struct nixx_lf_cfg_s {
 		u64 tcp_timer_int_ena                : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_cfg_s cn; */
+	/* struct nixx_lf_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CFG(void)
+static inline u64 NIXX_LF_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CFG(void)
+static inline u64 NIXX_LF_CFG(void)
 {
 	return 0x100;
 }
@@ -8225,19 +9217,19 @@ static inline u64 CAVM_NIXX_LF_CFG(void)
  *
  * NIX LF Completion Interrupt Count Registers
  */
-union cavm_nixx_lf_cintx_cnt {
+union nixx_lf_cintx_cnt {
 	u64 u;
-	struct cavm_nixx_lf_cintx_cnt_s {
+	struct nixx_lf_cintx_cnt_s {
 		u64 ecount                           : 32;
 		u64 qcount                           : 16;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_lf_cintx_cnt_s cn; */
+	/* struct nixx_lf_cintx_cnt_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
+static inline u64 NIXX_LF_CINTX_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
+static inline u64 NIXX_LF_CINTX_CNT(u64 a)
 {
 	return 0xd00 + 0x1000 * a;
 }
@@ -8248,18 +9240,18 @@ static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
  * NIX LF Completion Interrupt Enable Clear Registers This register
  * clears interrupt enable bits.
  */
-union cavm_nixx_lf_cintx_ena_w1c {
+union nixx_lf_cintx_ena_w1c {
 	u64 u;
-	struct cavm_nixx_lf_cintx_ena_w1c_s {
+	struct nixx_lf_cintx_ena_w1c_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_cintx_ena_w1c_s cn; */
+	/* struct nixx_lf_cintx_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
+static inline u64 NIXX_LF_CINTX_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
+static inline u64 NIXX_LF_CINTX_ENA_W1C(u64 a)
 {
 	return 0xd50 + 0x1000 * a;
 }
@@ -8270,18 +9262,18 @@ static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
  * NIX LF Completion Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_nixx_lf_cintx_ena_w1s {
+union nixx_lf_cintx_ena_w1s {
 	u64 u;
-	struct cavm_nixx_lf_cintx_ena_w1s_s {
+	struct nixx_lf_cintx_ena_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_cintx_ena_w1s_s cn; */
+	/* struct nixx_lf_cintx_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1S(u64 a)
+static inline u64 NIXX_LF_CINTX_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1S(u64 a)
+static inline u64 NIXX_LF_CINTX_ENA_W1S(u64 a)
 {
 	return 0xd40 + 0x1000 * a;
 }
@@ -8291,18 +9283,18 @@ static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1S(u64 a)
  *
  * NIX LF Completion Interrupt Registers
  */
-union cavm_nixx_lf_cintx_int {
+union nixx_lf_cintx_int {
 	u64 u;
-	struct cavm_nixx_lf_cintx_int_s {
+	struct nixx_lf_cintx_int_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_cintx_int_s cn; */
+	/* struct nixx_lf_cintx_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
+static inline u64 NIXX_LF_CINTX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
+static inline u64 NIXX_LF_CINTX_INT(u64 a)
 {
 	return 0xd20 + 0x1000 * a;
 }
@@ -8313,18 +9305,18 @@ static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
  * NIX LF Completion Interrupt Set Registers This register sets interrupt
  * bits.
  */
-union cavm_nixx_lf_cintx_int_w1s {
+union nixx_lf_cintx_int_w1s {
 	u64 u;
-	struct cavm_nixx_lf_cintx_int_w1s_s {
+	struct nixx_lf_cintx_int_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_cintx_int_w1s_s cn; */
+	/* struct nixx_lf_cintx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_INT_W1S(u64 a)
+static inline u64 NIXX_LF_CINTX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_INT_W1S(u64 a)
+static inline u64 NIXX_LF_CINTX_INT_W1S(u64 a)
 {
 	return 0xd30 + 0x1000 * a;
 }
@@ -8334,20 +9326,20 @@ static inline u64 CAVM_NIXX_LF_CINTX_INT_W1S(u64 a)
  *
  * NIX LF Completion Interrupt Count Registers
  */
-union cavm_nixx_lf_cintx_wait {
+union nixx_lf_cintx_wait {
 	u64 u;
-	struct cavm_nixx_lf_cintx_wait_s {
+	struct nixx_lf_cintx_wait_s {
 		u64 ecount_wait                      : 32;
 		u64 qcount_wait                      : 16;
 		u64 time_wait                        : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_nixx_lf_cintx_wait_s cn; */
+	/* struct nixx_lf_cintx_wait_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
+static inline u64 NIXX_LF_CINTX_WAIT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
+static inline u64 NIXX_LF_CINTX_WAIT(u64 a)
 {
 	return 0xd10 + 0x1000 * a;
 }
@@ -8359,20 +9351,20 @@ static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
  * dequeues CQEs from a CQ ring within the LF. A read is RAZ.  RSL
  * accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_cq_op_door {
+union nixx_lf_cq_op_door {
 	u64 u;
-	struct cavm_nixx_lf_cq_op_door_s {
+	struct nixx_lf_cq_op_door_s {
 		u64 count                            : 16;
 		u64 reserved_16_31                   : 16;
 		u64 cq                               : 20;
 		u64 reserved_52_63                   : 12;
 	} s;
-	/* struct cavm_nixx_lf_cq_op_door_s cn; */
+	/* struct nixx_lf_cq_op_door_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
+static inline u64 NIXX_LF_CQ_OP_DOOR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
+static inline u64 NIXX_LF_CQ_OP_DOOR(void)
 {
 	return 0xb30;
 }
@@ -8385,9 +9377,9 @@ static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
  * enables. A write optionally sets or clears interrupts and interrupt
  * enables. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_cq_op_int {
+union nixx_lf_cq_op_int {
 	u64 u;
-	struct cavm_nixx_lf_cq_op_int_s {
+	struct nixx_lf_cq_op_int_s {
 		u64 cq_err_int                       : 8;
 		u64 cq_err_int_ena                   : 8;
 		u64 reserved_16_41                   : 26;
@@ -8395,12 +9387,12 @@ union cavm_nixx_lf_cq_op_int {
 		u64 setop                            : 1;
 		u64 cq                               : 20;
 	} s;
-	/* struct cavm_nixx_lf_cq_op_int_s cn; */
+	/* struct nixx_lf_cq_op_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
+static inline u64 NIXX_LF_CQ_OP_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
+static inline u64 NIXX_LF_CQ_OP_INT(void)
 {
 	return 0xb00;
 }
@@ -8414,9 +9406,9 @@ static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_cq_op_status {
+union nixx_lf_cq_op_status {
 	u64 u;
-	struct cavm_nixx_lf_cq_op_status_s {
+	struct nixx_lf_cq_op_status_s {
 		u64 tail                             : 20;
 		u64 head                             : 20;
 		u64 reserved_40_45                   : 6;
@@ -8424,12 +9416,12 @@ union cavm_nixx_lf_cq_op_status {
 		u64 reserved_47_62                   : 16;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_cq_op_status_s cn; */
+	/* struct nixx_lf_cq_op_status_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_CQ_OP_STATUS(void)
+static inline u64 NIXX_LF_CQ_OP_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_CQ_OP_STATUS(void)
+static inline u64 NIXX_LF_CQ_OP_STATUS(void)
 {
 	return 0xb40;
 }
@@ -8439,9 +9431,9 @@ static inline u64 CAVM_NIXX_LF_CQ_OP_STATUS(void)
  *
  * NIX LF Error Interrupt Register
  */
-union cavm_nixx_lf_err_int {
+union nixx_lf_err_int {
 	u64 u;
-	struct cavm_nixx_lf_err_int_s {
+	struct nixx_lf_err_int_s {
 		u64 sqb_fault                        : 1;
 		u64 sq_ctx_fault                     : 1;
 		u64 rq_ctx_fault                     : 1;
@@ -8467,12 +9459,12 @@ union cavm_nixx_lf_err_int {
 		u64 cint_fault                       : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_nixx_lf_err_int_s cn; */
+	/* struct nixx_lf_err_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_ERR_INT(void)
+static inline u64 NIXX_LF_ERR_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_ERR_INT(void)
+static inline u64 NIXX_LF_ERR_INT(void)
 {
 	return 0x220;
 }
@@ -8483,9 +9475,9 @@ static inline u64 CAVM_NIXX_LF_ERR_INT(void)
  * NIX LF Error Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_lf_err_int_ena_w1c {
+union nixx_lf_err_int_ena_w1c {
 	u64 u;
-	struct cavm_nixx_lf_err_int_ena_w1c_s {
+	struct nixx_lf_err_int_ena_w1c_s {
 		u64 sqb_fault                        : 1;
 		u64 sq_ctx_fault                     : 1;
 		u64 rq_ctx_fault                     : 1;
@@ -8511,12 +9503,12 @@ union cavm_nixx_lf_err_int_ena_w1c {
 		u64 cint_fault                       : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_nixx_lf_err_int_ena_w1c_s cn; */
+	/* struct nixx_lf_err_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
+static inline u64 NIXX_LF_ERR_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
+static inline u64 NIXX_LF_ERR_INT_ENA_W1C(void)
 {
 	return 0x230;
 }
@@ -8527,9 +9519,9 @@ static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
  * NIX LF Error Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_nixx_lf_err_int_ena_w1s {
+union nixx_lf_err_int_ena_w1s {
 	u64 u;
-	struct cavm_nixx_lf_err_int_ena_w1s_s {
+	struct nixx_lf_err_int_ena_w1s_s {
 		u64 sqb_fault                        : 1;
 		u64 sq_ctx_fault                     : 1;
 		u64 rq_ctx_fault                     : 1;
@@ -8555,12 +9547,12 @@ union cavm_nixx_lf_err_int_ena_w1s {
 		u64 cint_fault                       : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_nixx_lf_err_int_ena_w1s_s cn; */
+	/* struct nixx_lf_err_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
+static inline u64 NIXX_LF_ERR_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
+static inline u64 NIXX_LF_ERR_INT_ENA_W1S(void)
 {
 	return 0x238;
 }
@@ -8570,9 +9562,9 @@ static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
  *
  * NIX LF Error Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_nixx_lf_err_int_w1s {
+union nixx_lf_err_int_w1s {
 	u64 u;
-	struct cavm_nixx_lf_err_int_w1s_s {
+	struct nixx_lf_err_int_w1s_s {
 		u64 sqb_fault                        : 1;
 		u64 sq_ctx_fault                     : 1;
 		u64 rq_ctx_fault                     : 1;
@@ -8598,12 +9590,12 @@ union cavm_nixx_lf_err_int_w1s {
 		u64 cint_fault                       : 1;
 		u64 reserved_30_63                   : 34;
 	} s;
-	/* struct cavm_nixx_lf_err_int_w1s_s cn; */
+	/* struct nixx_lf_err_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_ERR_INT_W1S(void)
+static inline u64 NIXX_LF_ERR_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_ERR_INT_W1S(void)
+static inline u64 NIXX_LF_ERR_INT_W1S(void)
 {
 	return 0x228;
 }
@@ -8613,19 +9605,19 @@ static inline u64 CAVM_NIXX_LF_ERR_INT_W1S(void)
  *
  * NIX LF General Interrupt Register
  */
-union cavm_nixx_lf_gint {
+union nixx_lf_gint {
 	u64 u;
-	struct cavm_nixx_lf_gint_s {
+	struct nixx_lf_gint_s {
 		u64 drop                             : 1;
 		u64 tcp_timer                        : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_nixx_lf_gint_s cn; */
+	/* struct nixx_lf_gint_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_GINT(void)
+static inline u64 NIXX_LF_GINT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_GINT(void)
+static inline u64 NIXX_LF_GINT(void)
 {
 	return 0x200;
 }
@@ -8636,19 +9628,19 @@ static inline u64 CAVM_NIXX_LF_GINT(void)
  * NIX LF General Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_lf_gint_ena_w1c {
+union nixx_lf_gint_ena_w1c {
 	u64 u;
-	struct cavm_nixx_lf_gint_ena_w1c_s {
+	struct nixx_lf_gint_ena_w1c_s {
 		u64 drop                             : 1;
 		u64 tcp_timer                        : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_nixx_lf_gint_ena_w1c_s cn; */
+	/* struct nixx_lf_gint_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
+static inline u64 NIXX_LF_GINT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
+static inline u64 NIXX_LF_GINT_ENA_W1C(void)
 {
 	return 0x210;
 }
@@ -8659,19 +9651,19 @@ static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
  * NIX LF General Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_nixx_lf_gint_ena_w1s {
+union nixx_lf_gint_ena_w1s {
 	u64 u;
-	struct cavm_nixx_lf_gint_ena_w1s_s {
+	struct nixx_lf_gint_ena_w1s_s {
 		u64 drop                             : 1;
 		u64 tcp_timer                        : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_nixx_lf_gint_ena_w1s_s cn; */
+	/* struct nixx_lf_gint_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
+static inline u64 NIXX_LF_GINT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
+static inline u64 NIXX_LF_GINT_ENA_W1S(void)
 {
 	return 0x218;
 }
@@ -8682,19 +9674,19 @@ static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
  * NIX LF General Interrupt Set Register This register sets interrupt
  * bits.
  */
-union cavm_nixx_lf_gint_w1s {
+union nixx_lf_gint_w1s {
 	u64 u;
-	struct cavm_nixx_lf_gint_w1s_s {
+	struct nixx_lf_gint_w1s_s {
 		u64 drop                             : 1;
 		u64 tcp_timer                        : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_nixx_lf_gint_w1s_s cn; */
+	/* struct nixx_lf_gint_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
+static inline u64 NIXX_LF_GINT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
+static inline u64 NIXX_LF_GINT_W1S(void)
 {
 	return 0x208;
 }
@@ -8708,21 +9700,21 @@ static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
  * info is captured, and subsequent errors are not captured until
  * software clears [VALID] by writing a one to it.
  */
-union cavm_nixx_lf_mnq_err_dbg {
+union nixx_lf_mnq_err_dbg {
 	u64 u;
-	struct cavm_nixx_lf_mnq_err_dbg_s {
+	struct nixx_lf_mnq_err_dbg_s {
 		u64 errcode                          : 8;
 		u64 sq                               : 20;
 		u64 sqe_id                           : 16;
 		u64 valid                            : 1;
 		u64 reserved_45_63                   : 19;
 	} s;
-	/* struct cavm_nixx_lf_mnq_err_dbg_s cn; */
+	/* struct nixx_lf_mnq_err_dbg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
+static inline u64 NIXX_LF_MNQ_ERR_DBG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
+static inline u64 NIXX_LF_MNQ_ERR_DBG(void)
 {
 	return 0x270;
 }
@@ -8733,21 +9725,21 @@ static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
  * INTERNAL: NIX LF IPSEC Dynamic Ordering Counter Operation Register
  * Internal: Not used; no IPSEC fast-path. All accesses are RAZ/WI.
  */
-union cavm_nixx_lf_op_ipsec_dyno_cnt {
+union nixx_lf_op_ipsec_dyno_cnt {
 	u64 u;
-	struct cavm_nixx_lf_op_ipsec_dyno_cnt_s {
+	struct nixx_lf_op_ipsec_dyno_cnt_s {
 		u64 count                            : 32;
 		u64 reserved_32_46                   : 15;
 		u64 storeop                          : 1;
 		u64 dyno_sel                         : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_op_ipsec_dyno_cnt_s cn; */
+	/* struct nixx_lf_op_ipsec_dyno_cnt_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+static inline u64 NIXX_LF_OP_IPSEC_DYNO_CNT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+static inline u64 NIXX_LF_OP_IPSEC_DYNO_CNT(void)
 {
 	return 0x980;
 }
@@ -8775,17 +9767,17 @@ static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
  * matters and more than one CPU core is simultaneously enqueueing to the
  * same SQ.
  */
-union cavm_nixx_lf_op_sendx {
+union nixx_lf_op_sendx {
 	u64 u;
-	struct cavm_nixx_lf_op_sendx_s {
+	struct nixx_lf_op_sendx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_nixx_lf_op_sendx_s cn; */
+	/* struct nixx_lf_op_sendx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_OP_SENDX(u64 a)
+static inline u64 NIXX_LF_OP_SENDX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_OP_SENDX(u64 a)
+static inline u64 NIXX_LF_OP_SENDX(u64 a)
 {
 	return 0x800 + 8 * a;
 }
@@ -8795,18 +9787,18 @@ static inline u64 CAVM_NIXX_LF_OP_SENDX(u64 a)
  *
  * NIX LF Queue Interrupt Count Registers
  */
-union cavm_nixx_lf_qintx_cnt {
+union nixx_lf_qintx_cnt {
 	u64 u;
-	struct cavm_nixx_lf_qintx_cnt_s {
+	struct nixx_lf_qintx_cnt_s {
 		u64 count                            : 22;
 		u64 reserved_22_63                   : 42;
 	} s;
-	/* struct cavm_nixx_lf_qintx_cnt_s cn; */
+	/* struct nixx_lf_qintx_cnt_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
+static inline u64 NIXX_LF_QINTX_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
+static inline u64 NIXX_LF_QINTX_CNT(u64 a)
 {
 	return 0xc00 + 0x1000 * a;
 }
@@ -8817,18 +9809,18 @@ static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
  * NIX LF Queue Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_lf_qintx_ena_w1c {
+union nixx_lf_qintx_ena_w1c {
 	u64 u;
-	struct cavm_nixx_lf_qintx_ena_w1c_s {
+	struct nixx_lf_qintx_ena_w1c_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_qintx_ena_w1c_s cn; */
+	/* struct nixx_lf_qintx_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
+static inline u64 NIXX_LF_QINTX_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
+static inline u64 NIXX_LF_QINTX_ENA_W1C(u64 a)
 {
 	return 0xc30 + 0x1000 * a;
 }
@@ -8839,18 +9831,18 @@ static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
  * NIX LF Queue Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_nixx_lf_qintx_ena_w1s {
+union nixx_lf_qintx_ena_w1s {
 	u64 u;
-	struct cavm_nixx_lf_qintx_ena_w1s_s {
+	struct nixx_lf_qintx_ena_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_qintx_ena_w1s_s cn; */
+	/* struct nixx_lf_qintx_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1S(u64 a)
+static inline u64 NIXX_LF_QINTX_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1S(u64 a)
+static inline u64 NIXX_LF_QINTX_ENA_W1S(u64 a)
 {
 	return 0xc20 + 0x1000 * a;
 }
@@ -8860,18 +9852,18 @@ static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1S(u64 a)
  *
  * NIX LF Queue Interrupt Registers
  */
-union cavm_nixx_lf_qintx_int {
+union nixx_lf_qintx_int {
 	u64 u;
-	struct cavm_nixx_lf_qintx_int_s {
+	struct nixx_lf_qintx_int_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_qintx_int_s cn; */
+	/* struct nixx_lf_qintx_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_QINTX_INT(u64 a)
+static inline u64 NIXX_LF_QINTX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_QINTX_INT(u64 a)
+static inline u64 NIXX_LF_QINTX_INT(u64 a)
 {
 	return 0xc10 + 0x1000 * a;
 }
@@ -8881,18 +9873,18 @@ static inline u64 CAVM_NIXX_LF_QINTX_INT(u64 a)
  *
  * INTERNAL: NIX LF Queue Interrupt Set Registers
  */
-union cavm_nixx_lf_qintx_int_w1s {
+union nixx_lf_qintx_int_w1s {
 	u64 u;
-	struct cavm_nixx_lf_qintx_int_w1s_s {
+	struct nixx_lf_qintx_int_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_nixx_lf_qintx_int_w1s_s cn; */
+	/* struct nixx_lf_qintx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_QINTX_INT_W1S(u64 a)
+static inline u64 NIXX_LF_QINTX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_QINTX_INT_W1S(u64 a)
+static inline u64 NIXX_LF_QINTX_INT_W1S(u64 a)
 {
 	return 0xc18 + 0x1000 * a;
 }
@@ -8902,9 +9894,9 @@ static inline u64 CAVM_NIXX_LF_QINTX_INT_W1S(u64 a)
  *
  * NIX LF RAS Interrupt Register
  */
-union cavm_nixx_lf_ras {
+union nixx_lf_ras {
 	u64 u;
-	struct cavm_nixx_lf_ras_s {
+	struct nixx_lf_ras_s {
 		u64 sqb_poison                       : 1;
 		u64 sq_ctx_poison                    : 1;
 		u64 rq_ctx_poison                    : 1;
@@ -8918,12 +9910,12 @@ union cavm_nixx_lf_ras {
 		u64 cint_poison                      : 1;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_lf_ras_s cn; */
+	/* struct nixx_lf_ras_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RAS(void)
+static inline u64 NIXX_LF_RAS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RAS(void)
+static inline u64 NIXX_LF_RAS(void)
 {
 	return 0x240;
 }
@@ -8934,9 +9926,9 @@ static inline u64 CAVM_NIXX_LF_RAS(void)
  * NIX LF RAS Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_nixx_lf_ras_ena_w1c {
+union nixx_lf_ras_ena_w1c {
 	u64 u;
-	struct cavm_nixx_lf_ras_ena_w1c_s {
+	struct nixx_lf_ras_ena_w1c_s {
 		u64 sqb_poison                       : 1;
 		u64 sq_ctx_poison                    : 1;
 		u64 rq_ctx_poison                    : 1;
@@ -8950,12 +9942,12 @@ union cavm_nixx_lf_ras_ena_w1c {
 		u64 cint_poison                      : 1;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_lf_ras_ena_w1c_s cn; */
+	/* struct nixx_lf_ras_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
+static inline u64 NIXX_LF_RAS_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
+static inline u64 NIXX_LF_RAS_ENA_W1C(void)
 {
 	return 0x250;
 }
@@ -8966,9 +9958,9 @@ static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
  * NIX LF RAS Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_nixx_lf_ras_ena_w1s {
+union nixx_lf_ras_ena_w1s {
 	u64 u;
-	struct cavm_nixx_lf_ras_ena_w1s_s {
+	struct nixx_lf_ras_ena_w1s_s {
 		u64 sqb_poison                       : 1;
 		u64 sq_ctx_poison                    : 1;
 		u64 rq_ctx_poison                    : 1;
@@ -8982,12 +9974,12 @@ union cavm_nixx_lf_ras_ena_w1s {
 		u64 cint_poison                      : 1;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_lf_ras_ena_w1s_s cn; */
+	/* struct nixx_lf_ras_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
+static inline u64 NIXX_LF_RAS_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
+static inline u64 NIXX_LF_RAS_ENA_W1S(void)
 {
 	return 0x258;
 }
@@ -8997,9 +9989,9 @@ static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
  *
  * NIX LF RAS Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_nixx_lf_ras_w1s {
+union nixx_lf_ras_w1s {
 	u64 u;
-	struct cavm_nixx_lf_ras_w1s_s {
+	struct nixx_lf_ras_w1s_s {
 		u64 sqb_poison                       : 1;
 		u64 sq_ctx_poison                    : 1;
 		u64 rq_ctx_poison                    : 1;
@@ -9013,12 +10005,12 @@ union cavm_nixx_lf_ras_w1s {
 		u64 cint_poison                      : 1;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_nixx_lf_ras_w1s_s cn; */
+	/* struct nixx_lf_ras_w1s_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
+static inline u64 NIXX_LF_RAS_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
+static inline u64 NIXX_LF_RAS_W1S(void)
 {
 	return 0x248;
 }
@@ -9032,19 +10024,19 @@ static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_drop_octs {
+union nixx_lf_rq_op_drop_octs {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_drop_octs_s {
+	struct nixx_lf_rq_op_drop_octs_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_drop_octs_s cn; */
+	/* struct nixx_lf_rq_op_drop_octs_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
+static inline u64 NIXX_LF_RQ_OP_DROP_OCTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
+static inline u64 NIXX_LF_RQ_OP_DROP_OCTS(void)
 {
 	return 0x930;
 }
@@ -9058,19 +10050,19 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_drop_pkts {
+union nixx_lf_rq_op_drop_pkts {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_drop_pkts_s {
+	struct nixx_lf_rq_op_drop_pkts_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_drop_pkts_s cn; */
+	/* struct nixx_lf_rq_op_drop_pkts_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_DROP_PKTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_DROP_PKTS(void)
 {
 	return 0x940;
 }
@@ -9085,9 +10077,9 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
  * 128-bit accesses) are RAZ/WI.  RSL accesses to this register are
  * RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_int {
+union nixx_lf_rq_op_int {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_int_s {
+	struct nixx_lf_rq_op_int_s {
 		u64 rq_int                           : 8;
 		u64 rq_int_ena                       : 8;
 		u64 reserved_16_41                   : 26;
@@ -9095,12 +10087,12 @@ union cavm_nixx_lf_rq_op_int {
 		u64 setop                            : 1;
 		u64 rq                               : 20;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_int_s cn; */
+	/* struct nixx_lf_rq_op_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
+static inline u64 NIXX_LF_RQ_OP_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
+static inline u64 NIXX_LF_RQ_OP_INT(void)
 {
 	return 0x900;
 }
@@ -9114,19 +10106,19 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
  * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_octs {
+union nixx_lf_rq_op_octs {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_octs_s {
+	struct nixx_lf_rq_op_octs_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_octs_s cn; */
+	/* struct nixx_lf_rq_op_octs_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
+static inline u64 NIXX_LF_RQ_OP_OCTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
+static inline u64 NIXX_LF_RQ_OP_OCTS(void)
 {
 	return 0x910;
 }
@@ -9140,19 +10132,19 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
  * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_pkts {
+union nixx_lf_rq_op_pkts {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_pkts_s {
+	struct nixx_lf_rq_op_pkts_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_pkts_s cn; */
+	/* struct nixx_lf_rq_op_pkts_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_PKTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_PKTS(void)
 {
 	return 0x920;
 }
@@ -9166,19 +10158,19 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_rq_op_re_pkts {
+union nixx_lf_rq_op_re_pkts {
 	u64 u;
-	struct cavm_nixx_lf_rq_op_re_pkts_s {
+	struct nixx_lf_rq_op_re_pkts_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_rq_op_re_pkts_s cn; */
+	/* struct nixx_lf_rq_op_re_pkts_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RQ_OP_RE_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_RE_PKTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RQ_OP_RE_PKTS(void)
+static inline u64 NIXX_LF_RQ_OP_RE_PKTS(void)
 {
 	return 0x950;
 }
@@ -9188,17 +10180,17 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_RE_PKTS(void)
  *
  * NIX LF Receive Secret Key Registers
  */
-union cavm_nixx_lf_rx_secretx {
+union nixx_lf_rx_secretx {
 	u64 u;
-	struct cavm_nixx_lf_rx_secretx_s {
+	struct nixx_lf_rx_secretx_s {
 		u64 key                              : 64;
 	} s;
-	/* struct cavm_nixx_lf_rx_secretx_s cn; */
+	/* struct nixx_lf_rx_secretx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
+static inline u64 NIXX_LF_RX_SECRETX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
+static inline u64 NIXX_LF_RX_SECRETX(u64 a)
 {
 	return 0 + 8 * a;
 }
@@ -9209,18 +10201,18 @@ static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
  * NIX LF Receive Statistics Registers The last dimension indicates which
  * statistic, and is enumerated by NIX_STAT_LF_RX_E.
  */
-union cavm_nixx_lf_rx_statx {
+union nixx_lf_rx_statx {
 	u64 u;
-	struct cavm_nixx_lf_rx_statx_s {
+	struct nixx_lf_rx_statx_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_lf_rx_statx_s cn; */
+	/* struct nixx_lf_rx_statx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
+static inline u64 NIXX_LF_RX_STATX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
+static inline u64 NIXX_LF_RX_STATX(u64 a)
 {
 	return 0x400 + 8 * a;
 }
@@ -9234,21 +10226,21 @@ static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
  * subsequent errors are not captured until software clears [VALID] by
  * writing a one to it.
  */
-union cavm_nixx_lf_send_err_dbg {
+union nixx_lf_send_err_dbg {
 	u64 u;
-	struct cavm_nixx_lf_send_err_dbg_s {
+	struct nixx_lf_send_err_dbg_s {
 		u64 errcode                          : 8;
 		u64 sq                               : 20;
 		u64 sqe_id                           : 16;
 		u64 valid                            : 1;
 		u64 reserved_45_63                   : 19;
 	} s;
-	/* struct cavm_nixx_lf_send_err_dbg_s cn; */
+	/* struct nixx_lf_send_err_dbg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
+static inline u64 NIXX_LF_SEND_ERR_DBG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
+static inline u64 NIXX_LF_SEND_ERR_DBG(void)
 {
 	return 0x280;
 }
@@ -9262,19 +10254,19 @@ static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_drop_octs {
+union nixx_lf_sq_op_drop_octs {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_drop_octs_s {
+	struct nixx_lf_sq_op_drop_octs_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_drop_octs_s cn; */
+	/* struct nixx_lf_sq_op_drop_octs_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
+static inline u64 NIXX_LF_SQ_OP_DROP_OCTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
+static inline u64 NIXX_LF_SQ_OP_DROP_OCTS(void)
 {
 	return 0xa40;
 }
@@ -9288,19 +10280,19 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
  * within LF.  All other accesses to this register (e.g. reads and
  * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_drop_pkts {
+union nixx_lf_sq_op_drop_pkts {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_drop_pkts_s {
+	struct nixx_lf_sq_op_drop_pkts_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_drop_pkts_s cn; */
+	/* struct nixx_lf_sq_op_drop_pkts_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
+static inline u64 NIXX_LF_SQ_OP_DROP_PKTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
+static inline u64 NIXX_LF_SQ_OP_DROP_PKTS(void)
 {
 	return 0xa50;
 }
@@ -9314,21 +10306,21 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
  * debug info is captured, and subsequent errors are not captured until
  * software clears [VALID] by writing a one to it.
  */
-union cavm_nixx_lf_sq_op_err_dbg {
+union nixx_lf_sq_op_err_dbg {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_err_dbg_s {
+	struct nixx_lf_sq_op_err_dbg_s {
 		u64 errcode                          : 8;
 		u64 sq                               : 20;
 		u64 sqe_id                           : 16;
 		u64 valid                            : 1;
 		u64 reserved_45_63                   : 19;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_err_dbg_s cn; */
+	/* struct nixx_lf_sq_op_err_dbg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
+static inline u64 NIXX_LF_SQ_OP_ERR_DBG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
+static inline u64 NIXX_LF_SQ_OP_ERR_DBG(void)
 {
 	return 0x260;
 }
@@ -9342,9 +10334,9 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
  * enables and XOFF status. A read is RAZ.  RSL accesses to this register
  * are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_int {
+union nixx_lf_sq_op_int {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_int_s {
+	struct nixx_lf_sq_op_int_s {
 		u64 sq_int                           : 8;
 		u64 sq_int_ena                       : 8;
 		u64 xoff                             : 1;
@@ -9353,12 +10345,12 @@ union cavm_nixx_lf_sq_op_int {
 		u64 setop                            : 1;
 		u64 sq                               : 20;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_int_s cn; */
+	/* struct nixx_lf_sq_op_int_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
+static inline u64 NIXX_LF_SQ_OP_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
+static inline u64 NIXX_LF_SQ_OP_INT(void)
 {
 	return 0xa00;
 }
@@ -9372,19 +10364,19 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
  * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
  * accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_octs {
+union nixx_lf_sq_op_octs {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_octs_s {
+	struct nixx_lf_sq_op_octs_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_octs_s cn; */
+	/* struct nixx_lf_sq_op_octs_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
+static inline u64 NIXX_LF_SQ_OP_OCTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
+static inline u64 NIXX_LF_SQ_OP_OCTS(void)
 {
 	return 0xa10;
 }
@@ -9398,19 +10390,19 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
  * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
  * accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_pkts {
+union nixx_lf_sq_op_pkts {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_pkts_s {
+	struct nixx_lf_sq_op_pkts_s {
 		u64 cnt                              : 48;
 		u64 reserved_48_62                   : 15;
 		u64 op_err                           : 1;
 	} s;
-	/* struct cavm_nixx_lf_sq_op_pkts_s cn; */
+	/* struct nixx_lf_sq_op_pkts_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
+static inline u64 NIXX_LF_SQ_OP_PKTS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
+static inline u64 NIXX_LF_SQ_OP_PKTS(void)
 {
 	return 0xa20;
 }
@@ -9426,9 +10418,9 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
  * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
-union cavm_nixx_lf_sq_op_status {
+union nixx_lf_sq_op_status {
 	u64 u;
-	struct cavm_nixx_lf_sq_op_status_s {
+	struct nixx_lf_sq_op_status_s {
 		u64 sqb_count                        : 16;
 		u64 reserved_16_19                   : 4;
 		u64 head_offset                      : 6;
@@ -9437,7 +10429,7 @@ union cavm_nixx_lf_sq_op_status {
 		u64 reserved_34_62                   : 29;
 		u64 op_err                           : 1;
 	} s;
-	struct cavm_nixx_lf_sq_op_status_cn {
+	struct nixx_lf_sq_op_status_cn {
 		u64 sqb_count                        : 16;
 		u64 reserved_16_19                   : 4;
 		u64 head_offset                      : 6;
@@ -9449,9 +10441,9 @@ union cavm_nixx_lf_sq_op_status {
 	} cn;
 };
 
-static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
+static inline u64 NIXX_LF_SQ_OP_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
+static inline u64 NIXX_LF_SQ_OP_STATUS(void)
 {
 	return 0xa30;
 }
@@ -9462,18 +10454,18 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
  * NIX LF Transmit Statistics Registers The last dimension indicates
  * which statistic, and is enumerated by NIX_STAT_LF_TX_E.
  */
-union cavm_nixx_lf_tx_statx {
+union nixx_lf_tx_statx {
 	u64 u;
-	struct cavm_nixx_lf_tx_statx_s {
+	struct nixx_lf_tx_statx_s {
 		u64 stat                             : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_nixx_lf_tx_statx_s cn; */
+	/* struct nixx_lf_tx_statx_s cn; */
 };
 
-static inline u64 CAVM_NIXX_LF_TX_STATX(u64 a)
+static inline u64 NIXX_LF_TX_STATX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_LF_TX_STATX(u64 a)
+static inline u64 NIXX_LF_TX_STATX(u64 a)
 {
 	return 0x300 + 8 * a;
 }
@@ -9483,20 +10475,20 @@ static inline u64 CAVM_NIXX_LF_TX_STATX(u64 a)
  *
  * NIX Privileged Admin Function Interrupt Configuration Register
  */
-union cavm_nixx_priv_af_int_cfg {
+union nixx_priv_af_int_cfg {
 	u64 u;
-	struct cavm_nixx_priv_af_int_cfg_s {
+	struct nixx_priv_af_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_nixx_priv_af_int_cfg_s cn; */
+	/* struct nixx_priv_af_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
+static inline u64 NIXX_PRIV_AF_INT_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
+static inline u64 NIXX_PRIV_AF_INT_CFG(void)
 {
 	return 0x8000000;
 }
@@ -9512,20 +10504,20 @@ static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
  * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
  * 0x0.
  */
-union cavm_nixx_priv_lfx_cfg {
+union nixx_priv_lfx_cfg {
 	u64 u;
-	struct cavm_nixx_priv_lfx_cfg_s {
+	struct nixx_priv_lfx_cfg_s {
 		u64 slot                             : 8;
 		u64 pf_func                          : 16;
 		u64 reserved_24_62                   : 39;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_nixx_priv_lfx_cfg_s cn; */
+	/* struct nixx_priv_lfx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_PRIV_LFX_CFG(u64 a)
+static inline u64 NIXX_PRIV_LFX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_PRIV_LFX_CFG(u64 a)
+static inline u64 NIXX_PRIV_LFX_CFG(u64 a)
 {
 	return 0x8000010 + 0x100 * a;
 }
@@ -9535,22 +10527,22 @@ static inline u64 CAVM_NIXX_PRIV_LFX_CFG(u64 a)
  *
  * NIX Privileged LF Interrupt Configuration Registers
  */
-union cavm_nixx_priv_lfx_int_cfg {
+union nixx_priv_lfx_int_cfg {
 	u64 u;
-	struct cavm_nixx_priv_lfx_int_cfg_s {
+	struct nixx_priv_lfx_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_nixx_priv_lfx_int_cfg_s cn; */
+	/* struct nixx_priv_lfx_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_NIXX_PRIV_LFX_INT_CFG(u64 a)
+static inline u64 NIXX_PRIV_LFX_INT_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NIXX_PRIV_LFX_INT_CFG(u64 a)
+static inline u64 NIXX_PRIV_LFX_INT_CFG(u64 a)
 {
 	return 0x8000020 + 0x100 * a;
 }
 
-#endif /* __CAVM_CSRS_NIX_H__ */
+#endif /* __CSRS_NIX_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-npa.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
similarity index 69%
rename from drivers/net/octeontx2/cavm-csrs-npa.h
rename to arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
index 312954a8c4..19bea0ccd9 100644
--- a/drivers/net/octeontx2/cavm-csrs-npa.h
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npa.h
@@ -1,18 +1,17 @@
-#ifndef __CAVM_CSRS_NPA_H__
-#define __CAVM_CSRS_NPA_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NPA_H__
+#define __CSRS_NPA_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium NPA.
+ * NPA.
  *
  * This file is auto generated.  Do not edit.
  *
@@ -24,11 +23,11 @@
  * NPA Admin Function Interrupt Vector Enumeration Enumerates the NPA AF
  * MSI-X interrupt vectors.
  */
-#define CAVM_NPA_AF_INT_VEC_E_AF_ERR (3)
-#define CAVM_NPA_AF_INT_VEC_E_AQ_DONE (2)
-#define CAVM_NPA_AF_INT_VEC_E_GEN (1)
-#define CAVM_NPA_AF_INT_VEC_E_POISON (4)
-#define CAVM_NPA_AF_INT_VEC_E_RVU (0)
+#define NPA_AF_INT_VEC_E_AF_ERR (3)
+#define NPA_AF_INT_VEC_E_AQ_DONE (2)
+#define NPA_AF_INT_VEC_E_GEN (1)
+#define NPA_AF_INT_VEC_E_POISON (4)
+#define NPA_AF_INT_VEC_E_RVU (0)
 
 /**
  * Enumeration npa_aq_comp_e
@@ -36,12 +35,12 @@
  * NPA Admin Queue Completion Enumeration Enumerates the values of
  * NPA_AQ_RES_S[COMPCODE].
  */
-#define CAVM_NPA_AQ_COMP_E_CTX_FAULT (4)
-#define CAVM_NPA_AQ_COMP_E_CTX_POISON (3)
-#define CAVM_NPA_AQ_COMP_E_GOOD (1)
-#define CAVM_NPA_AQ_COMP_E_LOCKERR (5)
-#define CAVM_NPA_AQ_COMP_E_NOTDONE (0)
-#define CAVM_NPA_AQ_COMP_E_SWERR (2)
+#define NPA_AQ_COMP_E_CTX_FAULT (4)
+#define NPA_AQ_COMP_E_CTX_POISON (3)
+#define NPA_AQ_COMP_E_GOOD (1)
+#define NPA_AQ_COMP_E_LOCKERR (5)
+#define NPA_AQ_COMP_E_NOTDONE (0)
+#define NPA_AQ_COMP_E_SWERR (2)
 
 /**
  * Enumeration npa_aq_ctype_e
@@ -49,8 +48,8 @@
  * NPA Admin Queue Context Type Enumeration Enumerates
  * NPA_AQ_INST_S[CTYPE] values.
  */
-#define CAVM_NPA_AQ_CTYPE_E_AURA (0)
-#define CAVM_NPA_AQ_CTYPE_E_POOL (1)
+#define NPA_AQ_CTYPE_E_AURA (0)
+#define NPA_AQ_CTYPE_E_POOL (1)
 
 /**
  * Enumeration npa_aq_instop_e
@@ -58,12 +57,12 @@
  * NPA Admin Queue Opcode Enumeration Enumerates NPA_AQ_INST_S[OP]
  * values.
  */
-#define CAVM_NPA_AQ_INSTOP_E_INIT (1)
-#define CAVM_NPA_AQ_INSTOP_E_LOCK (4)
-#define CAVM_NPA_AQ_INSTOP_E_NOP (0)
-#define CAVM_NPA_AQ_INSTOP_E_READ (3)
-#define CAVM_NPA_AQ_INSTOP_E_UNLOCK (5)
-#define CAVM_NPA_AQ_INSTOP_E_WRITE (2)
+#define NPA_AQ_INSTOP_E_INIT (1)
+#define NPA_AQ_INSTOP_E_LOCK (4)
+#define NPA_AQ_INSTOP_E_NOP (0)
+#define NPA_AQ_INSTOP_E_READ (3)
+#define NPA_AQ_INSTOP_E_UNLOCK (5)
+#define NPA_AQ_INSTOP_E_WRITE (2)
 
 /**
  * Enumeration npa_aura_err_int_e
@@ -71,11 +70,11 @@
  * NPA Aura Error Interrupt Enumeration Enumerates the bit index of
  * NPA_AURA_S[ERR_INT], and NPA_AURA_S[ERR_INT_ENA].
  */
-#define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_OVER (1)
-#define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_UNDER (2)
-#define CAVM_NPA_AURA_ERR_INT_E_AURA_FREE_UNDER (0)
-#define CAVM_NPA_AURA_ERR_INT_E_POOL_DIS (3)
-#define CAVM_NPA_AURA_ERR_INT_E_RX(a) (0 + (a))
+#define NPA_AURA_ERR_INT_E_AURA_ADD_OVER (1)
+#define NPA_AURA_ERR_INT_E_AURA_ADD_UNDER (2)
+#define NPA_AURA_ERR_INT_E_AURA_FREE_UNDER (0)
+#define NPA_AURA_ERR_INT_E_POOL_DIS (3)
+#define NPA_AURA_ERR_INT_E_RX(a) (0 + (a))
 
 /**
  * Enumeration npa_bpintf_e
@@ -83,7 +82,7 @@
  * NPA Backpressure Interface Enumeration Enumerates index of
  * NPA_AURA_S[BP_ENA].
  */
-#define CAVM_NPA_BPINTF_E_NIXX_RX(a) (0 + (a))
+#define NPA_BPINTF_E_NIXX_RX(a) (0 + (a))
 
 /**
  * Enumeration npa_inpq_e
@@ -91,15 +90,17 @@
  * NPA Input Queue Enumeration Enumerates ALLOC/FREE input queues from
  * coprocessors.
  */
-#define CAVM_NPA_INPQ_E_AURA_OP (0xe)
-#define CAVM_NPA_INPQ_E_BPHY (7)
-#define CAVM_NPA_INPQ_E_DPI (6)
-#define CAVM_NPA_INPQ_E_INTERNAL_RSV (0xf)
-#define CAVM_NPA_INPQ_E_NIXX_RX(a) (0 + 2 * (a))
-#define CAVM_NPA_INPQ_E_NIXX_TX(a) (1 + 2 * (a))
-#define CAVM_NPA_INPQ_E_RX(a) (0 + (a))
-#define CAVM_NPA_INPQ_E_SSO (4)
-#define CAVM_NPA_INPQ_E_TIM (5)
+#define NPA_INPQ_E_AURA_OP (0xe)
+#define NPA_INPQ_E_BPHY (7)
+#define NPA_INPQ_E_DPI (6)
+#define NPA_INPQ_E_DPI0 (6)
+#define NPA_INPQ_E_DPI1 (7)
+#define NPA_INPQ_E_INTERNAL_RSV (0xf)
+#define NPA_INPQ_E_NIXX_RX(a) (0 + 2 * (a))
+#define NPA_INPQ_E_NIXX_TX(a) (1 + 2 * (a))
+#define NPA_INPQ_E_RX(a) (0 + (a))
+#define NPA_INPQ_E_SSO (4)
+#define NPA_INPQ_E_TIM (5)
 
 /**
  * Enumeration npa_lf_int_vec_e
@@ -107,9 +108,9 @@
  * NPA Local Function Interrupt Vector Enumeration Enumerates the NPA
  * MSI-X interrupt vectors per LF.
  */
-#define CAVM_NPA_LF_INT_VEC_E_ERR_INT (0x40)
-#define CAVM_NPA_LF_INT_VEC_E_POISON (0x41)
-#define CAVM_NPA_LF_INT_VEC_E_QINTX(a) (0 + (a))
+#define NPA_LF_INT_VEC_E_ERR_INT (0x40)
+#define NPA_LF_INT_VEC_E_POISON (0x41)
+#define NPA_LF_INT_VEC_E_QINTX(a) (0 + (a))
 
 /**
  * Enumeration npa_ndc0_port_e
@@ -118,12 +119,12 @@
  * ports and the PORT index of NDC_AF_PORT()_RT()_RW()_REQ_PC and
  * NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
-#define CAVM_NPA_NDC0_PORT_E_AURA0 (0)
-#define CAVM_NPA_NDC0_PORT_E_AURA1 (1)
-#define CAVM_NPA_NDC0_PORT_E_POOL0 (2)
-#define CAVM_NPA_NDC0_PORT_E_POOL1 (3)
-#define CAVM_NPA_NDC0_PORT_E_STACK0 (4)
-#define CAVM_NPA_NDC0_PORT_E_STACK1 (5)
+#define NPA_NDC0_PORT_E_AURA0 (0)
+#define NPA_NDC0_PORT_E_AURA1 (1)
+#define NPA_NDC0_PORT_E_POOL0 (2)
+#define NPA_NDC0_PORT_E_POOL1 (3)
+#define NPA_NDC0_PORT_E_STACK0 (4)
+#define NPA_NDC0_PORT_E_STACK1 (5)
 
 /**
  * Enumeration npa_pool_err_int_e
@@ -131,10 +132,10 @@
  * NPA Pool Error Interrupt Enumeration Enumerates the bit index of
  * NPA_POOL_S[ERR_INT] and NPA_POOL_S[ERR_INT_ENA].
  */
-#define CAVM_NPA_POOL_ERR_INT_E_OVFLS (0)
-#define CAVM_NPA_POOL_ERR_INT_E_PERR (2)
-#define CAVM_NPA_POOL_ERR_INT_E_RX(a) (0 + (a))
-#define CAVM_NPA_POOL_ERR_INT_E_RANGE (1)
+#define NPA_POOL_ERR_INT_E_OVFLS (0)
+#define NPA_POOL_ERR_INT_E_PERR (2)
+#define NPA_POOL_ERR_INT_E_RX(a) (0 + (a))
+#define NPA_POOL_ERR_INT_E_RANGE (1)
 
 /**
  * Structure npa_aq_inst_s
@@ -150,9 +151,9 @@
  * NPA_POOL_HW_S reads and writes use NPA_AURA_HW_S[POOL_CACHING] and
  * NPA_AURA_HW_S[POOL_WAY_MASK].
  */
-union cavm_npa_aq_inst_s {
+union npa_aq_inst_s {
 	u64 u[2];
-	struct cavm_npa_aq_inst_s_s {
+	struct npa_aq_inst_s_s {
 		u64 op                               : 4;
 		u64 ctype                            : 4;
 		u64 lf                               : 9;
@@ -162,7 +163,7 @@ union cavm_npa_aq_inst_s {
 		u64 doneint                          : 1;
 		u64 res_addr                         : 64;
 	} s;
-	/* struct cavm_npa_aq_inst_s_s cn; */
+	/* struct npa_aq_inst_s_s cn; */
 };
 
 /**
@@ -179,9 +180,9 @@ union cavm_npa_aq_inst_s {
  * always allocate into LLC. Hardware reads of context data do not
  * allocate into LLC.
  */
-union cavm_npa_aq_res_s {
+union npa_aq_res_s {
 	u64 u[2];
-	struct cavm_npa_aq_res_s_s {
+	struct npa_aq_res_s_s {
 		u64 op                               : 4;
 		u64 ctype                            : 4;
 		u64 compcode                         : 8;
@@ -189,7 +190,7 @@ union cavm_npa_aq_res_s {
 		u64 reserved_17_63                   : 47;
 		u64 reserved_64_127                  : 64;
 	} s;
-	/* struct cavm_npa_aq_res_s_s cn; */
+	/* struct npa_aq_res_s_s cn; */
 };
 
 /**
@@ -200,14 +201,14 @@ union cavm_npa_aq_res_s {
  * NPA_LF_AURA_OP_ALLOC() and NPA_LF_POOL_OP_PC, and a 128-bit atomic
  * CASP operation to NPA_LF_AURA_OP_ALLOC().
  */
-union cavm_npa_aura_op_wdata_s {
+union npa_aura_op_wdata_s {
 	u64 u;
-	struct cavm_npa_aura_op_wdata_s_s {
+	struct npa_aura_op_wdata_s_s {
 		u64 aura                             : 20;
 		u64 reserved_20_62                   : 43;
 		u64 drop                             : 1;
 	} s;
-	/* struct cavm_npa_aura_op_wdata_s_s cn; */
+	/* struct npa_aura_op_wdata_s_s cn; */
 };
 
 /**
@@ -217,9 +218,9 @@ union cavm_npa_aura_op_wdata_s {
  * software with the NPA admin queue to read and write an aura's
  * NPA_AURA_HW_S structure maintained by hardware in LLC/DRAM.
  */
-union cavm_npa_aura_s {
+union npa_aura_s {
 	u64 u[8];
-	struct cavm_npa_aura_s_s {
+	struct npa_aura_s_s {
 		u64 pool_addr                        : 64;
 		u64 ena                              : 1;
 		u64 reserved_65_66                   : 2;
@@ -267,7 +268,7 @@ union cavm_npa_aura_s {
 		u64 reserved_420_447                 : 28;
 		u64 reserved_448_511                 : 64;
 	} s;
-	/* struct cavm_npa_aura_s_s cn; */
+	/* struct npa_aura_s_s cn; */
 };
 
 /**
@@ -277,9 +278,9 @@ union cavm_npa_aura_s {
  * software with the NPA admin queue to read and write a pool's
  * NPA_POOL_HW_S structure maintained by hardware in LLC/DRAM.
  */
-union cavm_npa_pool_s {
+union npa_pool_s {
 	u64 u[16];
-	struct cavm_npa_pool_s_s {
+	struct npa_pool_s_s {
 		u64 stack_base                       : 64;
 		u64 ena                              : 1;
 		u64 nat_align                        : 1;
@@ -331,7 +332,7 @@ union cavm_npa_pool_s {
 		u64 reserved_896_959                 : 64;
 		u64 reserved_960_1023                : 64;
 	} s;
-	/* struct cavm_npa_pool_s_s cn; */
+	/* struct npa_pool_s_s cn; */
 };
 
 /**
@@ -345,14 +346,14 @@ union cavm_npa_pool_s {
  * starting at IOVA NPA_AF_LF()_QINTS_BASE. Always stored in byte
  * invariant little-endian format (LE8).
  */
-union cavm_npa_qint_hw_s {
+union npa_qint_hw_s {
 	u32 u;
-	struct cavm_npa_qint_hw_s_s {
+	struct npa_qint_hw_s_s {
 		u32 count                            : 22;
 		u32 reserved_22_30                   : 9;
 		u32 ena                              : 1;
 	} s;
-	/* struct cavm_npa_qint_hw_s_s cn; */
+	/* struct npa_qint_hw_s_s cn; */
 };
 
 /**
@@ -360,17 +361,17 @@ union cavm_npa_qint_hw_s {
  *
  * NPA AF Active Cycles Register
  */
-union cavm_npa_af_active_cycles_pc {
+union npa_af_active_cycles_pc {
 	u64 u;
-	struct cavm_npa_af_active_cycles_pc_s {
+	struct npa_af_active_cycles_pc_s {
 		u64 act_cyc                          : 64;
 	} s;
-	/* struct cavm_npa_af_active_cycles_pc_s cn; */
+	/* struct npa_af_active_cycles_pc_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ACTIVE_CYCLES_PC(void)
+static inline u64 NPA_AF_ACTIVE_CYCLES_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ACTIVE_CYCLES_PC(void)
+static inline u64 NPA_AF_ACTIVE_CYCLES_PC(void)
 {
 	return 0xf0;
 }
@@ -380,19 +381,19 @@ static inline u64 CAVM_NPA_AF_ACTIVE_CYCLES_PC(void)
  *
  * NPA AF Admin Queue Base Address Register
  */
-union cavm_npa_af_aq_base {
+union npa_af_aq_base {
 	u64 u;
-	struct cavm_npa_af_aq_base_s {
+	struct npa_af_aq_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 base_addr                        : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_npa_af_aq_base_s cn; */
+	/* struct npa_af_aq_base_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_BASE(void)
+static inline u64 NPA_AF_AQ_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_BASE(void)
+static inline u64 NPA_AF_AQ_BASE(void)
 {
 	return 0x610;
 }
@@ -402,18 +403,18 @@ static inline u64 CAVM_NPA_AF_AQ_BASE(void)
  *
  * NPA AF Admin Queue Configuration Register
  */
-union cavm_npa_af_aq_cfg {
+union npa_af_aq_cfg {
 	u64 u;
-	struct cavm_npa_af_aq_cfg_s {
+	struct npa_af_aq_cfg_s {
 		u64 qsize                            : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npa_af_aq_cfg_s cn; */
+	/* struct npa_af_aq_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_CFG(void)
+static inline u64 NPA_AF_AQ_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_CFG(void)
+static inline u64 NPA_AF_AQ_CFG(void)
 {
 	return 0x600;
 }
@@ -423,18 +424,18 @@ static inline u64 CAVM_NPA_AF_AQ_CFG(void)
  *
  * NPA AF AQ Done Count Register
  */
-union cavm_npa_af_aq_done {
+union npa_af_aq_done {
 	u64 u;
-	struct cavm_npa_af_aq_done_s {
+	struct npa_af_aq_done_s {
 		u64 done                             : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_af_aq_done_s cn; */
+	/* struct npa_af_aq_done_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE(void)
+static inline u64 NPA_AF_AQ_DONE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE(void)
+static inline u64 NPA_AF_AQ_DONE(void)
 {
 	return 0x650;
 }
@@ -445,18 +446,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE(void)
  * NPA AF AQ Done Count Ack Register This register is written by software
  * to acknowledge interrupts.
  */
-union cavm_npa_af_aq_done_ack {
+union npa_af_aq_done_ack {
 	u64 u;
-	struct cavm_npa_af_aq_done_ack_s {
+	struct npa_af_aq_done_ack_s {
 		u64 done_ack                         : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_af_aq_done_ack_s cn; */
+	/* struct npa_af_aq_done_ack_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
+static inline u64 NPA_AF_AQ_DONE_ACK(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
+static inline u64 NPA_AF_AQ_DONE_ACK(void)
 {
 	return 0x660;
 }
@@ -467,18 +468,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
  * NPA AF AQ Done Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_af_aq_done_ena_w1c {
+union npa_af_aq_done_ena_w1c {
 	u64 u;
-	struct cavm_npa_af_aq_done_ena_w1c_s {
+	struct npa_af_aq_done_ena_w1c_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_aq_done_ena_w1c_s cn; */
+	/* struct npa_af_aq_done_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
+static inline u64 NPA_AF_AQ_DONE_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
+static inline u64 NPA_AF_AQ_DONE_ENA_W1C(void)
 {
 	return 0x698;
 }
@@ -489,18 +490,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
  * NPA AF AQ Done Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_npa_af_aq_done_ena_w1s {
+union npa_af_aq_done_ena_w1s {
 	u64 u;
-	struct cavm_npa_af_aq_done_ena_w1s_s {
+	struct npa_af_aq_done_ena_w1s_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_aq_done_ena_w1s_s cn; */
+	/* struct npa_af_aq_done_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1S(void)
+static inline u64 NPA_AF_AQ_DONE_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1S(void)
+static inline u64 NPA_AF_AQ_DONE_ENA_W1S(void)
 {
 	return 0x690;
 }
@@ -510,18 +511,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1S(void)
  *
  * NPA AF AQ Done Interrupt Register
  */
-union cavm_npa_af_aq_done_int {
+union npa_af_aq_done_int {
 	u64 u;
-	struct cavm_npa_af_aq_done_int_s {
+	struct npa_af_aq_done_int_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_aq_done_int_s cn; */
+	/* struct npa_af_aq_done_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_INT(void)
+static inline u64 NPA_AF_AQ_DONE_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_INT(void)
+static inline u64 NPA_AF_AQ_DONE_INT(void)
 {
 	return 0x680;
 }
@@ -531,18 +532,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_INT(void)
  *
  * INTERNAL: NPA AF AQ Done Interrupt Set Register
  */
-union cavm_npa_af_aq_done_int_w1s {
+union npa_af_aq_done_int_w1s {
 	u64 u;
-	struct cavm_npa_af_aq_done_int_w1s_s {
+	struct npa_af_aq_done_int_w1s_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_aq_done_int_w1s_s cn; */
+	/* struct npa_af_aq_done_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
+static inline u64 NPA_AF_AQ_DONE_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
+static inline u64 NPA_AF_AQ_DONE_INT_W1S(void)
 {
 	return 0x688;
 }
@@ -553,18 +554,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
  * NPA AF Admin Queue Done Interrupt Timer Register Used to debug the
  * queue interrupt coalescing timer.
  */
-union cavm_npa_af_aq_done_timer {
+union npa_af_aq_done_timer {
 	u64 u;
-	struct cavm_npa_af_aq_done_timer_s {
+	struct npa_af_aq_done_timer_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_af_aq_done_timer_s cn; */
+	/* struct npa_af_aq_done_timer_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
+static inline u64 NPA_AF_AQ_DONE_TIMER(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
+static inline u64 NPA_AF_AQ_DONE_TIMER(void)
 {
 	return 0x670;
 }
@@ -575,20 +576,20 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
  * NPA AF AQ Done Interrupt Coalescing Wait Register Specifies the queue
  * interrupt coalescing settings.
  */
-union cavm_npa_af_aq_done_wait {
+union npa_af_aq_done_wait {
 	u64 u;
-	struct cavm_npa_af_aq_done_wait_s {
+	struct npa_af_aq_done_wait_s {
 		u64 num_wait                         : 20;
 		u64 reserved_20_31                   : 12;
 		u64 time_wait                        : 16;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_npa_af_aq_done_wait_s cn; */
+	/* struct npa_af_aq_done_wait_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
+static inline u64 NPA_AF_AQ_DONE_WAIT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
+static inline u64 NPA_AF_AQ_DONE_WAIT(void)
 {
 	return 0x640;
 }
@@ -599,18 +600,18 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
  * NPA AF Admin Queue Doorbell Register Software writes to this register
  * to enqueue one or more entries to AQ.
  */
-union cavm_npa_af_aq_door {
+union npa_af_aq_door {
 	u64 u;
-	struct cavm_npa_af_aq_door_s {
+	struct npa_af_aq_door_s {
 		u64 count                            : 16;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_af_aq_door_s cn; */
+	/* struct npa_af_aq_door_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AQ_DOOR(void)
+static inline u64 NPA_AF_AQ_DOOR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_DOOR(void)
+static inline u64 NPA_AF_AQ_DOOR(void)
 {
 	return 0x630;
 }
@@ -620,9 +621,9 @@ static inline u64 CAVM_NPA_AF_AQ_DOOR(void)
  *
  * NPA AF Admin Queue Status Register
  */
-union cavm_npa_af_aq_status {
+union npa_af_aq_status {
 	u64 u;
-	struct cavm_npa_af_aq_status_s {
+	struct npa_af_aq_status_s {
 		u64 reserved_0_3                     : 4;
 		u64 head_ptr                         : 20;
 		u64 reserved_24_35                   : 12;
@@ -631,7 +632,7 @@ union cavm_npa_af_aq_status {
 		u64 aq_busy                          : 1;
 		u64 aq_err                           : 1;
 	} s;
-	struct cavm_npa_af_aq_status_cn {
+	struct npa_af_aq_status_cn {
 		u64 reserved_0_3                     : 4;
 		u64 head_ptr                         : 20;
 		u64 reserved_24_31                   : 8;
@@ -643,9 +644,9 @@ union cavm_npa_af_aq_status {
 	} cn;
 };
 
-static inline u64 CAVM_NPA_AF_AQ_STATUS(void)
+static inline u64 NPA_AF_AQ_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AQ_STATUS(void)
+static inline u64 NPA_AF_AQ_STATUS(void)
 {
 	return 0x620;
 }
@@ -655,21 +656,21 @@ static inline u64 CAVM_NPA_AF_AQ_STATUS(void)
  *
  * NPA AF Queue Average Delay Register
  */
-union cavm_npa_af_avg_delay {
+union npa_af_avg_delay {
 	u64 u;
-	struct cavm_npa_af_avg_delay_s {
+	struct npa_af_avg_delay_s {
 		u64 avg_dly                          : 19;
 		u64 reserved_19_23                   : 5;
 		u64 avg_timer                        : 16;
 		u64 reserved_40_62                   : 23;
 		u64 avg_timer_dis                    : 1;
 	} s;
-	/* struct cavm_npa_af_avg_delay_s cn; */
+	/* struct npa_af_avg_delay_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
+static inline u64 NPA_AF_AVG_DELAY(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
+static inline u64 NPA_AF_AVG_DELAY(void)
 {
 	return 0x100;
 }
@@ -682,17 +683,17 @@ static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
  * NPA_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
  * bug33464.
  */
-union cavm_npa_af_bar2_aliasx {
+union npa_af_bar2_aliasx {
 	u64 u;
-	struct cavm_npa_af_bar2_aliasx_s {
+	struct npa_af_bar2_aliasx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_npa_af_bar2_aliasx_s cn; */
+	/* struct npa_af_bar2_aliasx_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
+static inline u64 NPA_AF_BAR2_ALIASX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
+static inline u64 NPA_AF_BAR2_ALIASX(u64 a)
 {
 	return 0x9100000 + 8 * a;
 }
@@ -704,19 +705,19 @@ static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
  * configures BAR2 accesses from the NPA_AF_BAR2_ALIAS() registers in
  * BAR0. Internal: Not implemented. Placeholder for bug33464.
  */
-union cavm_npa_af_bar2_sel {
+union npa_af_bar2_sel {
 	u64 u;
-	struct cavm_npa_af_bar2_sel_s {
+	struct npa_af_bar2_sel_s {
 		u64 alias_pf_func                    : 16;
 		u64 alias_ena                        : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_npa_af_bar2_sel_s cn; */
+	/* struct npa_af_bar2_sel_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_BAR2_SEL(void)
+static inline u64 NPA_AF_BAR2_SEL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_BAR2_SEL(void)
+static inline u64 NPA_AF_BAR2_SEL(void)
 {
 	return 0x9000000;
 }
@@ -726,19 +727,19 @@ static inline u64 CAVM_NPA_AF_BAR2_SEL(void)
  *
  * NPA AF Block Reset Register
  */
-union cavm_npa_af_blk_rst {
+union npa_af_blk_rst {
 	u64 u;
-	struct cavm_npa_af_blk_rst_s {
+	struct npa_af_blk_rst_s {
 		u64 rst                              : 1;
 		u64 reserved_1_62                    : 62;
 		u64 busy                             : 1;
 	} s;
-	/* struct cavm_npa_af_blk_rst_s cn; */
+	/* struct npa_af_blk_rst_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_BLK_RST(void)
+static inline u64 NPA_AF_BLK_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_BLK_RST(void)
+static inline u64 NPA_AF_BLK_RST(void)
 {
 	return 0;
 }
@@ -748,20 +749,20 @@ static inline u64 CAVM_NPA_AF_BLK_RST(void)
  *
  * INTERNAL: NPA AF Backpressure Test Register
  */
-union cavm_npa_af_bp_test {
+union npa_af_bp_test {
 	u64 u;
-	struct cavm_npa_af_bp_test_s {
+	struct npa_af_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 32;
 		u64 enable                           : 16;
 	} s;
-	/* struct cavm_npa_af_bp_test_s cn; */
+	/* struct npa_af_bp_test_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_BP_TEST(void)
+static inline u64 NPA_AF_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_BP_TEST(void)
+static inline u64 NPA_AF_BP_TEST(void)
 {
 	return 0x200;
 }
@@ -772,9 +773,9 @@ static inline u64 CAVM_NPA_AF_BP_TEST(void)
  * NPA AF Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_npa_af_const {
+union npa_af_const {
 	u64 u;
-	struct cavm_npa_af_const_s {
+	struct npa_af_const_s {
 		u64 stack_page_bytes                 : 8;
 		u64 stack_page_ptrs                  : 8;
 		u64 lfs                              : 12;
@@ -782,12 +783,12 @@ union cavm_npa_af_const {
 		u64 num_ndc                          : 3;
 		u64 reserved_43_63                   : 21;
 	} s;
-	/* struct cavm_npa_af_const_s cn; */
+	/* struct npa_af_const_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_CONST(void)
+static inline u64 NPA_AF_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_CONST(void)
+static inline u64 NPA_AF_CONST(void)
 {
 	return 0x10;
 }
@@ -798,20 +799,20 @@ static inline u64 CAVM_NPA_AF_CONST(void)
  * NPA AF Constants Register 1 This register contains constants for
  * software discovery.
  */
-union cavm_npa_af_const1 {
+union npa_af_const1 {
 	u64 u;
-	struct cavm_npa_af_const1_s {
+	struct npa_af_const1_s {
 		u64 aura_log2bytes                   : 4;
 		u64 pool_log2bytes                   : 4;
 		u64 qint_log2bytes                   : 4;
 		u64 reserved_12_63                   : 52;
 	} s;
-	/* struct cavm_npa_af_const1_s cn; */
+	/* struct npa_af_const1_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_CONST1(void)
+static inline u64 NPA_AF_CONST1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_CONST1(void)
+static inline u64 NPA_AF_CONST1(void)
 {
 	return 0x18;
 }
@@ -821,20 +822,20 @@ static inline u64 CAVM_NPA_AF_CONST1(void)
  *
  * NPA AF DTX LF Filter Control Register
  */
-union cavm_npa_af_dtx_filter_ctl {
+union npa_af_dtx_filter_ctl {
 	u64 u;
-	struct cavm_npa_af_dtx_filter_ctl_s {
+	struct npa_af_dtx_filter_ctl_s {
 		u64 ena                              : 1;
 		u64 reserved_1_3                     : 3;
 		u64 lf                               : 7;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_npa_af_dtx_filter_ctl_s cn; */
+	/* struct npa_af_dtx_filter_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_DTX_FILTER_CTL(void)
+static inline u64 NPA_AF_DTX_FILTER_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_DTX_FILTER_CTL(void)
+static inline u64 NPA_AF_DTX_FILTER_CTL(void)
 {
 	return 0x10040;
 }
@@ -844,18 +845,18 @@ static inline u64 CAVM_NPA_AF_DTX_FILTER_CTL(void)
  *
  * INTERNAL: NPA AF ECO Register
  */
-union cavm_npa_af_eco {
+union npa_af_eco {
 	u64 u;
-	struct cavm_npa_af_eco_s {
+	struct npa_af_eco_s {
 		u64 eco_rw                           : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_npa_af_eco_s cn; */
+	/* struct npa_af_eco_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ECO(void)
+static inline u64 NPA_AF_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ECO(void)
+static inline u64 NPA_AF_ECO(void)
 {
 	return 0x300;
 }
@@ -865,21 +866,21 @@ static inline u64 CAVM_NPA_AF_ECO(void)
  *
  * NPA Admin Function Error Interrupt Register
  */
-union cavm_npa_af_err_int {
+union npa_af_err_int {
 	u64 u;
-	struct cavm_npa_af_err_int_s {
+	struct npa_af_err_int_s {
 		u64 reserved_0_11                    : 12;
 		u64 aq_door_err                      : 1;
 		u64 aq_res_fault                     : 1;
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npa_af_err_int_s cn; */
+	/* struct npa_af_err_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ERR_INT(void)
+static inline u64 NPA_AF_ERR_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ERR_INT(void)
+static inline u64 NPA_AF_ERR_INT(void)
 {
 	return 0x180;
 }
@@ -890,21 +891,21 @@ static inline u64 CAVM_NPA_AF_ERR_INT(void)
  * NPA Admin Function Error Interrupt Enable Clear Register This register
  * clears interrupt enable bits.
  */
-union cavm_npa_af_err_int_ena_w1c {
+union npa_af_err_int_ena_w1c {
 	u64 u;
-	struct cavm_npa_af_err_int_ena_w1c_s {
+	struct npa_af_err_int_ena_w1c_s {
 		u64 reserved_0_11                    : 12;
 		u64 aq_door_err                      : 1;
 		u64 aq_res_fault                     : 1;
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npa_af_err_int_ena_w1c_s cn; */
+	/* struct npa_af_err_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
+static inline u64 NPA_AF_ERR_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
+static inline u64 NPA_AF_ERR_INT_ENA_W1C(void)
 {
 	return 0x198;
 }
@@ -915,21 +916,21 @@ static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
  * NPA Admin Function Error Interrupt Enable Set Register This register
  * sets interrupt enable bits.
  */
-union cavm_npa_af_err_int_ena_w1s {
+union npa_af_err_int_ena_w1s {
 	u64 u;
-	struct cavm_npa_af_err_int_ena_w1s_s {
+	struct npa_af_err_int_ena_w1s_s {
 		u64 reserved_0_11                    : 12;
 		u64 aq_door_err                      : 1;
 		u64 aq_res_fault                     : 1;
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npa_af_err_int_ena_w1s_s cn; */
+	/* struct npa_af_err_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
+static inline u64 NPA_AF_ERR_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
+static inline u64 NPA_AF_ERR_INT_ENA_W1S(void)
 {
 	return 0x190;
 }
@@ -940,21 +941,21 @@ static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
  * NPA Admin Function Error Interrupt Set Register This register sets
  * interrupt bits.
  */
-union cavm_npa_af_err_int_w1s {
+union npa_af_err_int_w1s {
 	u64 u;
-	struct cavm_npa_af_err_int_w1s_s {
+	struct npa_af_err_int_w1s_s {
 		u64 reserved_0_11                    : 12;
 		u64 aq_door_err                      : 1;
 		u64 aq_res_fault                     : 1;
 		u64 aq_inst_fault                    : 1;
 		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npa_af_err_int_w1s_s cn; */
+	/* struct npa_af_err_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
+static inline u64 NPA_AF_ERR_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
+static inline u64 NPA_AF_ERR_INT_W1S(void)
 {
 	return 0x188;
 }
@@ -965,9 +966,9 @@ static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
  * NPA AF General Configuration Register This register provides NPA
  * control and status information.
  */
-union cavm_npa_af_gen_cfg {
+union npa_af_gen_cfg {
 	u64 u;
-	struct cavm_npa_af_gen_cfg_s {
+	struct npa_af_gen_cfg_s {
 		u64 reserved_0                       : 1;
 		u64 af_be                            : 1;
 		u64 reserved_2                       : 1;
@@ -979,12 +980,12 @@ union cavm_npa_af_gen_cfg {
 		u64 ratem1                           : 4;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_af_gen_cfg_s cn; */
+	/* struct npa_af_gen_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_GEN_CFG(void)
+static inline u64 NPA_AF_GEN_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_GEN_CFG(void)
+static inline u64 NPA_AF_GEN_CFG(void)
 {
 	return 0x30;
 }
@@ -995,20 +996,20 @@ static inline u64 CAVM_NPA_AF_GEN_CFG(void)
  * NPA AF General Interrupt Register This register contains general error
  * interrupt summary bits.
  */
-union cavm_npa_af_gen_int {
+union npa_af_gen_int {
 	u64 u;
-	struct cavm_npa_af_gen_int_s {
+	struct npa_af_gen_int_s {
 		u64 free_dis                         : 16;
 		u64 alloc_dis                        : 16;
 		u64 unmapped_pf_func                 : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_npa_af_gen_int_s cn; */
+	/* struct npa_af_gen_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_GEN_INT(void)
+static inline u64 NPA_AF_GEN_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_GEN_INT(void)
+static inline u64 NPA_AF_GEN_INT(void)
 {
 	return 0x140;
 }
@@ -1019,20 +1020,20 @@ static inline u64 CAVM_NPA_AF_GEN_INT(void)
  * NPA AF General Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_af_gen_int_ena_w1c {
+union npa_af_gen_int_ena_w1c {
 	u64 u;
-	struct cavm_npa_af_gen_int_ena_w1c_s {
+	struct npa_af_gen_int_ena_w1c_s {
 		u64 free_dis                         : 16;
 		u64 alloc_dis                        : 16;
 		u64 unmapped_pf_func                 : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_npa_af_gen_int_ena_w1c_s cn; */
+	/* struct npa_af_gen_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
+static inline u64 NPA_AF_GEN_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
+static inline u64 NPA_AF_GEN_INT_ENA_W1C(void)
 {
 	return 0x158;
 }
@@ -1043,20 +1044,20 @@ static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
  * NPA AF General Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_npa_af_gen_int_ena_w1s {
+union npa_af_gen_int_ena_w1s {
 	u64 u;
-	struct cavm_npa_af_gen_int_ena_w1s_s {
+	struct npa_af_gen_int_ena_w1s_s {
 		u64 free_dis                         : 16;
 		u64 alloc_dis                        : 16;
 		u64 unmapped_pf_func                 : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_npa_af_gen_int_ena_w1s_s cn; */
+	/* struct npa_af_gen_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
+static inline u64 NPA_AF_GEN_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
+static inline u64 NPA_AF_GEN_INT_ENA_W1S(void)
 {
 	return 0x150;
 }
@@ -1067,20 +1068,20 @@ static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
  * NPA AF General Interrupt Set Register This register sets interrupt
  * bits.
  */
-union cavm_npa_af_gen_int_w1s {
+union npa_af_gen_int_w1s {
 	u64 u;
-	struct cavm_npa_af_gen_int_w1s_s {
+	struct npa_af_gen_int_w1s_s {
 		u64 free_dis                         : 16;
 		u64 alloc_dis                        : 16;
 		u64 unmapped_pf_func                 : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_npa_af_gen_int_w1s_s cn; */
+	/* struct npa_af_gen_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_GEN_INT_W1S(void)
+static inline u64 NPA_AF_GEN_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_GEN_INT_W1S(void)
+static inline u64 NPA_AF_GEN_INT_W1S(void)
 {
 	return 0x148;
 }
@@ -1090,19 +1091,19 @@ static inline u64 CAVM_NPA_AF_GEN_INT_W1S(void)
  *
  * NPA AF Input Control Register
  */
-union cavm_npa_af_inp_ctl {
+union npa_af_inp_ctl {
 	u64 u;
-	struct cavm_npa_af_inp_ctl_s {
+	struct npa_af_inp_ctl_s {
 		u64 free_dis                         : 16;
 		u64 alloc_dis                        : 16;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_npa_af_inp_ctl_s cn; */
+	/* struct npa_af_inp_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_INP_CTL(void)
+static inline u64 NPA_AF_INP_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_INP_CTL(void)
+static inline u64 NPA_AF_INP_CTL(void)
 {
 	return 0xd0;
 }
@@ -1112,9 +1113,9 @@ static inline u64 CAVM_NPA_AF_INP_CTL(void)
  *
  * NPA AF Local Function Auras Configuration Registers
  */
-union cavm_npa_af_lfx_auras_cfg {
+union npa_af_lfx_auras_cfg {
 	u64 u;
-	struct cavm_npa_af_lfx_auras_cfg_s {
+	struct npa_af_lfx_auras_cfg_s {
 		u64 way_mask                         : 16;
 		u64 loc_aura_size                    : 4;
 		u64 loc_aura_offset                  : 14;
@@ -1125,7 +1126,7 @@ union cavm_npa_af_lfx_auras_cfg {
 		u64 rmt_lf                           : 7;
 		u64 reserved_61_63                   : 3;
 	} s;
-	struct cavm_npa_af_lfx_auras_cfg_cn96xx {
+	struct npa_af_lfx_auras_cfg_cn96xxp1 {
 		u64 way_mask                         : 16;
 		u64 loc_aura_size                    : 4;
 		u64 loc_aura_offset                  : 14;
@@ -1135,13 +1136,16 @@ union cavm_npa_af_lfx_auras_cfg {
 		u64 rmt_aura_offset                  : 14;
 		u64 rmt_lf                           : 7;
 		u64 reserved_61_63                   : 3;
-	} cn96xx;
-	/* struct cavm_npa_af_lfx_auras_cfg_s cnf95xx; */
+	} cn96xxp1;
+	/* struct npa_af_lfx_auras_cfg_s cn96xxp3; */
+	/* struct npa_af_lfx_auras_cfg_s cn98xx; */
+	/* struct npa_af_lfx_auras_cfg_s cnf95xx; */
+	/* struct npa_af_lfx_auras_cfg_s loki; */
 };
 
-static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
+static inline u64 NPA_AF_LFX_AURAS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
+static inline u64 NPA_AF_LFX_AURAS_CFG(u64 a)
 {
 	return 0x4000 + 0x40000 * a;
 }
@@ -1151,19 +1155,19 @@ static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
  *
  * NPA AF Local Function Auras Base Registers
  */
-union cavm_npa_af_lfx_loc_auras_base {
+union npa_af_lfx_loc_auras_base {
 	u64 u;
-	struct cavm_npa_af_lfx_loc_auras_base_s {
+	struct npa_af_lfx_loc_auras_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_npa_af_lfx_loc_auras_base_s cn; */
+	/* struct npa_af_lfx_loc_auras_base_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+static inline u64 NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+static inline u64 NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
 {
 	return 0x4010 + 0x40000 * a;
 }
@@ -1173,19 +1177,19 @@ static inline u64 CAVM_NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
  *
  * NPA AF Local Function Queue Interrupts Base Registers
  */
-union cavm_npa_af_lfx_qints_base {
+union npa_af_lfx_qints_base {
 	u64 u;
-	struct cavm_npa_af_lfx_qints_base_s {
+	struct npa_af_lfx_qints_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_npa_af_lfx_qints_base_s cn; */
+	/* struct npa_af_lfx_qints_base_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
+static inline u64 NPA_AF_LFX_QINTS_BASE(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
+static inline u64 NPA_AF_LFX_QINTS_BASE(u64 a)
 {
 	return 0x4110 + 0x40000 * a;
 }
@@ -1199,20 +1203,20 @@ static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
  * NPA_QINT_HW_S structures. The size of each structure is 1 \<\<
  * NPA_AF_CONST1[QINT_LOG2BYTES] bytes.
  */
-union cavm_npa_af_lfx_qints_cfg {
+union npa_af_lfx_qints_cfg {
 	u64 u;
-	struct cavm_npa_af_lfx_qints_cfg_s {
+	struct npa_af_lfx_qints_cfg_s {
 		u64 reserved_0_19                    : 20;
 		u64 way_mask                         : 16;
 		u64 caching                          : 2;
 		u64 reserved_38_63                   : 26;
 	} s;
-	/* struct cavm_npa_af_lfx_qints_cfg_s cn; */
+	/* struct npa_af_lfx_qints_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_LFX_QINTS_CFG(u64 a)
+static inline u64 NPA_AF_LFX_QINTS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_LFX_QINTS_CFG(u64 a)
+static inline u64 NPA_AF_LFX_QINTS_CFG(u64 a)
 {
 	return 0x4100 + 0x40000 * a;
 }
@@ -1222,20 +1226,20 @@ static inline u64 CAVM_NPA_AF_LFX_QINTS_CFG(u64 a)
  *
  * NPA Admin Function LF Reset Register
  */
-union cavm_npa_af_lf_rst {
+union npa_af_lf_rst {
 	u64 u;
-	struct cavm_npa_af_lf_rst_s {
+	struct npa_af_lf_rst_s {
 		u64 lf                               : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_npa_af_lf_rst_s cn; */
+	/* struct npa_af_lf_rst_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_LF_RST(void)
+static inline u64 NPA_AF_LF_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_LF_RST(void)
+static inline u64 NPA_AF_LF_RST(void)
 {
 	return 0x20;
 }
@@ -1246,9 +1250,9 @@ static inline u64 CAVM_NPA_AF_LF_RST(void)
  * NDC AF General Configuration Register This register provides NDC
  * control.
  */
-union cavm_npa_af_ndc_cfg {
+union npa_af_ndc_cfg {
 	u64 u;
-	struct cavm_npa_af_ndc_cfg_s {
+	struct npa_af_ndc_cfg_s {
 		u64 ndc_bypass                       : 1;
 		u64 ndc_ign_pois                     : 1;
 		u64 byp_aura                         : 1;
@@ -1257,12 +1261,12 @@ union cavm_npa_af_ndc_cfg {
 		u64 byp_qint                         : 1;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_npa_af_ndc_cfg_s cn; */
+	/* struct npa_af_ndc_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_NDC_CFG(void)
+static inline u64 NPA_AF_NDC_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_NDC_CFG(void)
+static inline u64 NPA_AF_NDC_CFG(void)
 {
 	return 0x40;
 }
@@ -1272,20 +1276,20 @@ static inline u64 CAVM_NPA_AF_NDC_CFG(void)
  *
  * NPA AF NDC Sync Register Used to synchronize the NPA NDC.
  */
-union cavm_npa_af_ndc_sync {
+union npa_af_ndc_sync {
 	u64 u;
-	struct cavm_npa_af_ndc_sync_s {
+	struct npa_af_ndc_sync_s {
 		u64 lf                               : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_npa_af_ndc_sync_s cn; */
+	/* struct npa_af_ndc_sync_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
+static inline u64 NPA_AF_NDC_SYNC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
+static inline u64 NPA_AF_NDC_SYNC(void)
 {
 	return 0x50;
 }
@@ -1296,21 +1300,21 @@ static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
  * NPA AF RAS Interrupt Register This register is intended for delivery
  * of RAS events to the SCP, so should be ignored by OS drivers.
  */
-union cavm_npa_af_ras {
+union npa_af_ras {
 	u64 u;
-	struct cavm_npa_af_ras_s {
+	struct npa_af_ras_s {
 		u64 reserved_0_31                    : 32;
 		u64 aq_ctx_poison                    : 1;
 		u64 aq_res_poison                    : 1;
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_npa_af_ras_s cn; */
+	/* struct npa_af_ras_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RAS(void)
+static inline u64 NPA_AF_RAS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RAS(void)
+static inline u64 NPA_AF_RAS(void)
 {
 	return 0x1a0;
 }
@@ -1321,21 +1325,21 @@ static inline u64 CAVM_NPA_AF_RAS(void)
  * NPA AF RAS Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_af_ras_ena_w1c {
+union npa_af_ras_ena_w1c {
 	u64 u;
-	struct cavm_npa_af_ras_ena_w1c_s {
+	struct npa_af_ras_ena_w1c_s {
 		u64 reserved_0_31                    : 32;
 		u64 aq_ctx_poison                    : 1;
 		u64 aq_res_poison                    : 1;
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_npa_af_ras_ena_w1c_s cn; */
+	/* struct npa_af_ras_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
+static inline u64 NPA_AF_RAS_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
+static inline u64 NPA_AF_RAS_ENA_W1C(void)
 {
 	return 0x1b8;
 }
@@ -1346,21 +1350,21 @@ static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
  * NPA AF RAS Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_npa_af_ras_ena_w1s {
+union npa_af_ras_ena_w1s {
 	u64 u;
-	struct cavm_npa_af_ras_ena_w1s_s {
+	struct npa_af_ras_ena_w1s_s {
 		u64 reserved_0_31                    : 32;
 		u64 aq_ctx_poison                    : 1;
 		u64 aq_res_poison                    : 1;
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_npa_af_ras_ena_w1s_s cn; */
+	/* struct npa_af_ras_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
+static inline u64 NPA_AF_RAS_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
+static inline u64 NPA_AF_RAS_ENA_W1S(void)
 {
 	return 0x1b0;
 }
@@ -1370,21 +1374,21 @@ static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
  *
  * NPA AF RAS Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_npa_af_ras_w1s {
+union npa_af_ras_w1s {
 	u64 u;
-	struct cavm_npa_af_ras_w1s_s {
+	struct npa_af_ras_w1s_s {
 		u64 reserved_0_31                    : 32;
 		u64 aq_ctx_poison                    : 1;
 		u64 aq_res_poison                    : 1;
 		u64 aq_inst_poison                   : 1;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_npa_af_ras_w1s_s cn; */
+	/* struct npa_af_ras_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RAS_W1S(void)
+static inline u64 NPA_AF_RAS_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RAS_W1S(void)
+static inline u64 NPA_AF_RAS_W1S(void)
 {
 	return 0x1a8;
 }
@@ -1395,18 +1399,18 @@ static inline u64 CAVM_NPA_AF_RAS_W1S(void)
  * NPA AF RVU Interrupt Register This register contains RVU error
  * interrupt summary bits.
  */
-union cavm_npa_af_rvu_int {
+union npa_af_rvu_int {
 	u64 u;
-	struct cavm_npa_af_rvu_int_s {
+	struct npa_af_rvu_int_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_rvu_int_s cn; */
+	/* struct npa_af_rvu_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RVU_INT(void)
+static inline u64 NPA_AF_RVU_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RVU_INT(void)
+static inline u64 NPA_AF_RVU_INT(void)
 {
 	return 0x160;
 }
@@ -1417,18 +1421,18 @@ static inline u64 CAVM_NPA_AF_RVU_INT(void)
  * NPA AF RVU Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_af_rvu_int_ena_w1c {
+union npa_af_rvu_int_ena_w1c {
 	u64 u;
-	struct cavm_npa_af_rvu_int_ena_w1c_s {
+	struct npa_af_rvu_int_ena_w1c_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_rvu_int_ena_w1c_s cn; */
+	/* struct npa_af_rvu_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
+static inline u64 NPA_AF_RVU_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
+static inline u64 NPA_AF_RVU_INT_ENA_W1C(void)
 {
 	return 0x178;
 }
@@ -1439,18 +1443,18 @@ static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
  * NPA AF RVU Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_npa_af_rvu_int_ena_w1s {
+union npa_af_rvu_int_ena_w1s {
 	u64 u;
-	struct cavm_npa_af_rvu_int_ena_w1s_s {
+	struct npa_af_rvu_int_ena_w1s_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_rvu_int_ena_w1s_s cn; */
+	/* struct npa_af_rvu_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
+static inline u64 NPA_AF_RVU_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
+static inline u64 NPA_AF_RVU_INT_ENA_W1S(void)
 {
 	return 0x170;
 }
@@ -1460,18 +1464,18 @@ static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
  *
  * NPA AF RVU Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_npa_af_rvu_int_w1s {
+union npa_af_rvu_int_w1s {
 	u64 u;
-	struct cavm_npa_af_rvu_int_w1s_s {
+	struct npa_af_rvu_int_w1s_s {
 		u64 unmapped_slot                    : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_af_rvu_int_w1s_s cn; */
+	/* struct npa_af_rvu_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
+static inline u64 NPA_AF_RVU_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
+static inline u64 NPA_AF_RVU_INT_W1S(void)
 {
 	return 0x168;
 }
@@ -1483,9 +1487,9 @@ static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
  * allows software to lookup the reverse mapping from VF/PF slot to LF.
  * The forward mapping is programmed with NPA_PRIV_LF()_CFG.
  */
-union cavm_npa_af_rvu_lf_cfg_debug {
+union npa_af_rvu_lf_cfg_debug {
 	u64 u;
-	struct cavm_npa_af_rvu_lf_cfg_debug_s {
+	struct npa_af_rvu_lf_cfg_debug_s {
 		u64 lf                               : 12;
 		u64 lf_valid                         : 1;
 		u64 exec                             : 1;
@@ -1494,12 +1498,12 @@ union cavm_npa_af_rvu_lf_cfg_debug {
 		u64 pf_func                          : 16;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_npa_af_rvu_lf_cfg_debug_s cn; */
+	/* struct npa_af_rvu_lf_cfg_debug_s cn; */
 };
 
-static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
+static inline u64 NPA_AF_RVU_LF_CFG_DEBUG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
+static inline u64 NPA_AF_RVU_LF_CFG_DEBUG(void)
 {
 	return 0x10030;
 }
@@ -1517,17 +1521,17 @@ static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
  * All other accesses to this register (e.g. reads and writes) are
  * RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_allocx {
+union npa_lf_aura_op_allocx {
 	u64 u;
-	struct cavm_npa_lf_aura_op_allocx_s {
+	struct npa_lf_aura_op_allocx_s {
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_npa_lf_aura_op_allocx_s cn; */
+	/* struct npa_lf_aura_op_allocx_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
+static inline u64 NPA_LF_AURA_OP_ALLOCX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
+static inline u64 NPA_LF_AURA_OP_ALLOCX(u64 a)
 {
 	return 0x10 + 8 * a;
 }
@@ -1539,21 +1543,21 @@ static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
  * register returns a given aura's count. A write sets or adds the aura's
  * count. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_cnt {
+union npa_lf_aura_op_cnt {
 	u64 u;
-	struct cavm_npa_lf_aura_op_cnt_s {
+	struct npa_lf_aura_op_cnt_s {
 		u64 count                            : 36;
 		u64 reserved_36_41                   : 6;
 		u64 op_err                           : 1;
 		u64 cnt_add                          : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_aura_op_cnt_s cn; */
+	/* struct npa_lf_aura_op_cnt_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
+static inline u64 NPA_LF_AURA_OP_CNT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
+static inline u64 NPA_LF_AURA_OP_CNT(void)
 {
 	return 0x30;
 }
@@ -1561,23 +1565,23 @@ static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free0
  *
- * NPA LF Aura Free Operation Register 0 A 128-bit write to
+ * NPA LF Aura Free Operation Register 0 A 128-bit write (STP) to
  * NPA_LF_AURA_OP_FREE0 and NPA_LF_AURA_OP_FREE1 frees a pointer into a
  * given aura's pool. All other accesses to these registers (e.g. reads
  * and 64-bit writes) are RAZ/WI.  RSL accesses to this register are
  * RAZ/WI.
  */
-union cavm_npa_lf_aura_op_free0 {
+union npa_lf_aura_op_free0 {
 	u64 u;
-	struct cavm_npa_lf_aura_op_free0_s {
+	struct npa_lf_aura_op_free0_s {
 		u64 addr                             : 64;
 	} s;
-	/* struct cavm_npa_lf_aura_op_free0_s cn; */
+	/* struct npa_lf_aura_op_free0_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
+static inline u64 NPA_LF_AURA_OP_FREE0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
+static inline u64 NPA_LF_AURA_OP_FREE0(void)
 {
 	return 0x20;
 }
@@ -1588,19 +1592,19 @@ static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
  * NPA LF Aura Free Operation Register 1 See NPA_LF_AURA_OP_FREE0.  RSL
  * accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_free1 {
+union npa_lf_aura_op_free1 {
 	u64 u;
-	struct cavm_npa_lf_aura_op_free1_s {
+	struct npa_lf_aura_op_free1_s {
 		u64 aura                             : 20;
 		u64 reserved_20_62                   : 43;
 		u64 fabs                             : 1;
 	} s;
-	/* struct cavm_npa_lf_aura_op_free1_s cn; */
+	/* struct npa_lf_aura_op_free1_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
+static inline u64 NPA_LF_AURA_OP_FREE1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
+static inline u64 NPA_LF_AURA_OP_FREE1(void)
 {
 	return 0x28;
 }
@@ -1614,9 +1618,9 @@ static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
  * optionally sets or clears these fields. A read is RAZ.  RSL accesses
  * to this register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_int {
+union npa_lf_aura_op_int {
 	u64 u;
-	struct cavm_npa_lf_aura_op_int_s {
+	struct npa_lf_aura_op_int_s {
 		u64 err_int                          : 8;
 		u64 err_int_ena                      : 8;
 		u64 thresh_int                       : 1;
@@ -1626,12 +1630,12 @@ union cavm_npa_lf_aura_op_int {
 		u64 setop                            : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_aura_op_int_s cn; */
+	/* struct npa_lf_aura_op_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
+static inline u64 NPA_LF_AURA_OP_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
+static inline u64 NPA_LF_AURA_OP_INT(void)
 {
 	return 0x60;
 }
@@ -1643,21 +1647,21 @@ static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
  * this register returns a given aura's limit. A write sets the aura's
  * limit. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_limit {
+union npa_lf_aura_op_limit {
 	u64 u;
-	struct cavm_npa_lf_aura_op_limit_s {
+	struct npa_lf_aura_op_limit_s {
 		u64 limit                            : 36;
 		u64 reserved_36_41                   : 6;
 		u64 op_err                           : 1;
 		u64 reserved_43                      : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_aura_op_limit_s cn; */
+	/* struct npa_lf_aura_op_limit_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
+static inline u64 NPA_LF_AURA_OP_LIMIT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
+static inline u64 NPA_LF_AURA_OP_LIMIT(void)
 {
 	return 0x50;
 }
@@ -1671,21 +1675,21 @@ static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
  * NPA_AURA_HW_S[THRESH_INT]. A read is RAZ.  RSL accesses to this
  * register are RAZ/WI.
  */
-union cavm_npa_lf_aura_op_thresh {
+union npa_lf_aura_op_thresh {
 	u64 u;
-	struct cavm_npa_lf_aura_op_thresh_s {
+	struct npa_lf_aura_op_thresh_s {
 		u64 thresh                           : 36;
 		u64 reserved_36_41                   : 6;
 		u64 op_err                           : 1;
 		u64 thresh_up                        : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_aura_op_thresh_s cn; */
+	/* struct npa_lf_aura_op_thresh_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_AURA_OP_THRESH(void)
+static inline u64 NPA_LF_AURA_OP_THRESH(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_AURA_OP_THRESH(void)
+static inline u64 NPA_LF_AURA_OP_THRESH(void)
 {
 	return 0x70;
 }
@@ -1695,9 +1699,9 @@ static inline u64 CAVM_NPA_LF_AURA_OP_THRESH(void)
  *
  * NPA LF Error Interrupt Register
  */
-union cavm_npa_lf_err_int {
+union npa_lf_err_int {
 	u64 u;
-	struct cavm_npa_lf_err_int_s {
+	struct npa_lf_err_int_s {
 		u64 aura_dis                         : 1;
 		u64 aura_oor                         : 1;
 		u64 reserved_2                       : 1;
@@ -1709,12 +1713,12 @@ union cavm_npa_lf_err_int {
 		u64 qint_fault                       : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_lf_err_int_s cn; */
+	/* struct npa_lf_err_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_ERR_INT(void)
+static inline u64 NPA_LF_ERR_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_ERR_INT(void)
+static inline u64 NPA_LF_ERR_INT(void)
 {
 	return 0x200;
 }
@@ -1725,9 +1729,9 @@ static inline u64 CAVM_NPA_LF_ERR_INT(void)
  * NPA LF Error Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_lf_err_int_ena_w1c {
+union npa_lf_err_int_ena_w1c {
 	u64 u;
-	struct cavm_npa_lf_err_int_ena_w1c_s {
+	struct npa_lf_err_int_ena_w1c_s {
 		u64 aura_dis                         : 1;
 		u64 aura_oor                         : 1;
 		u64 reserved_2                       : 1;
@@ -1739,12 +1743,12 @@ union cavm_npa_lf_err_int_ena_w1c {
 		u64 qint_fault                       : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_lf_err_int_ena_w1c_s cn; */
+	/* struct npa_lf_err_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
+static inline u64 NPA_LF_ERR_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
+static inline u64 NPA_LF_ERR_INT_ENA_W1C(void)
 {
 	return 0x210;
 }
@@ -1755,9 +1759,9 @@ static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
  * NPA LF Error Interrupt Enable Set Register This register sets
  * interrupt enable bits.
  */
-union cavm_npa_lf_err_int_ena_w1s {
+union npa_lf_err_int_ena_w1s {
 	u64 u;
-	struct cavm_npa_lf_err_int_ena_w1s_s {
+	struct npa_lf_err_int_ena_w1s_s {
 		u64 aura_dis                         : 1;
 		u64 aura_oor                         : 1;
 		u64 reserved_2                       : 1;
@@ -1769,12 +1773,12 @@ union cavm_npa_lf_err_int_ena_w1s {
 		u64 qint_fault                       : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_lf_err_int_ena_w1s_s cn; */
+	/* struct npa_lf_err_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
+static inline u64 NPA_LF_ERR_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
+static inline u64 NPA_LF_ERR_INT_ENA_W1S(void)
 {
 	return 0x218;
 }
@@ -1784,9 +1788,9 @@ static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
  *
  * NPA LF Error Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_npa_lf_err_int_w1s {
+union npa_lf_err_int_w1s {
 	u64 u;
-	struct cavm_npa_lf_err_int_w1s_s {
+	struct npa_lf_err_int_w1s_s {
 		u64 aura_dis                         : 1;
 		u64 aura_oor                         : 1;
 		u64 reserved_2                       : 1;
@@ -1798,12 +1802,12 @@ union cavm_npa_lf_err_int_w1s {
 		u64 qint_fault                       : 1;
 		u64 reserved_16_63                   : 48;
 	} s;
-	/* struct cavm_npa_lf_err_int_w1s_s cn; */
+	/* struct npa_lf_err_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
+static inline u64 NPA_LF_ERR_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
+static inline u64 NPA_LF_ERR_INT_W1S(void)
 {
 	return 0x208;
 }
@@ -1816,21 +1820,21 @@ static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
  * Reads and writes are RAZ/WI.  RSL accesses to this register are
  * RAZ/WI.
  */
-union cavm_npa_lf_pool_op_available {
+union npa_lf_pool_op_available {
 	u64 u;
-	struct cavm_npa_lf_pool_op_available_s {
+	struct npa_lf_pool_op_available_s {
 		u64 count                            : 36;
 		u64 reserved_36_41                   : 6;
 		u64 op_err                           : 1;
 		u64 reserved_43                      : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_pool_op_available_s cn; */
+	/* struct npa_lf_pool_op_available_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
+static inline u64 NPA_LF_POOL_OP_AVAILABLE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
+static inline u64 NPA_LF_POOL_OP_AVAILABLE(void)
 {
 	return 0x110;
 }
@@ -1844,9 +1848,9 @@ static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
  * optionally sets or clears these fields. A read is RAZ.  RSL accesses
  * to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_int {
+union npa_lf_pool_op_int {
 	u64 u;
-	struct cavm_npa_lf_pool_op_int_s {
+	struct npa_lf_pool_op_int_s {
 		u64 err_int                          : 8;
 		u64 err_int_ena                      : 8;
 		u64 thresh_int                       : 1;
@@ -1856,12 +1860,12 @@ union cavm_npa_lf_pool_op_int {
 		u64 setop                            : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_pool_op_int_s cn; */
+	/* struct npa_lf_pool_op_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
+static inline u64 NPA_LF_POOL_OP_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
+static inline u64 NPA_LF_POOL_OP_INT(void)
 {
 	return 0x160;
 }
@@ -1875,19 +1879,19 @@ static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
  * NPA_AURA_OP_WDATA_S. Reads and writes are RAZ/WI.  RSL accesses to
  * this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_pc {
+union npa_lf_pool_op_pc {
 	u64 u;
-	struct cavm_npa_lf_pool_op_pc_s {
+	struct npa_lf_pool_op_pc_s {
 		u64 op_pc                            : 48;
 		u64 op_err                           : 1;
 		u64 reserved_49_63                   : 15;
 	} s;
-	/* struct cavm_npa_lf_pool_op_pc_s cn; */
+	/* struct npa_lf_pool_op_pc_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
+static inline u64 NPA_LF_POOL_OP_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
+static inline u64 NPA_LF_POOL_OP_PC(void)
 {
 	return 0x100;
 }
@@ -1895,23 +1899,23 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end0
  *
- * NPA LF Pool Pointer End Operation Register 0 A 128-bit write to the
- * NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1 registers writes
- * to a given pool's pointer end value. All other accesses to these
- * registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL accesses to
- * this register are RAZ/WI.
+ * NPA LF Pool Pointer End Operation Register 0 A 128-bit write (STP) to
+ * the NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1 registers
+ * writes to a given pool's pointer end value. All other accesses to
+ * these registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_ptr_end0 {
+union npa_lf_pool_op_ptr_end0 {
 	u64 u;
-	struct cavm_npa_lf_pool_op_ptr_end0_s {
+	struct npa_lf_pool_op_ptr_end0_s {
 		u64 ptr_end                          : 64;
 	} s;
-	/* struct cavm_npa_lf_pool_op_ptr_end0_s cn; */
+	/* struct npa_lf_pool_op_ptr_end0_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
+static inline u64 NPA_LF_POOL_OP_PTR_END0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
+static inline u64 NPA_LF_POOL_OP_PTR_END0(void)
 {
 	return 0x130;
 }
@@ -1922,18 +1926,18 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
  * NPA LF Pool Pointer End Operation Register 1 See
  * NPA_LF_POOL_OP_PTR_END0.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_ptr_end1 {
+union npa_lf_pool_op_ptr_end1 {
 	u64 u;
-	struct cavm_npa_lf_pool_op_ptr_end1_s {
+	struct npa_lf_pool_op_ptr_end1_s {
 		u64 aura                             : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_lf_pool_op_ptr_end1_s cn; */
+	/* struct npa_lf_pool_op_ptr_end1_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
+static inline u64 NPA_LF_POOL_OP_PTR_END1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
+static inline u64 NPA_LF_POOL_OP_PTR_END1(void)
 {
 	return 0x138;
 }
@@ -1941,23 +1945,23 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start0
  *
- * NPA LF Pool Pointer Start Operation Register 0 A 128-bit write to the
- * NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1 registers
- * writes to a given pool's pointer start value. All other accesses to
- * these registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL
- * accesses to this register are RAZ/WI.
+ * NPA LF Pool Pointer Start Operation Register 0 A 128-bit write (STP)
+ * to the NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1
+ * registers writes to a given pool's pointer start value. All other
+ * accesses to these registers (e.g. reads and 64-bit writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_ptr_start0 {
+union npa_lf_pool_op_ptr_start0 {
 	u64 u;
-	struct cavm_npa_lf_pool_op_ptr_start0_s {
+	struct npa_lf_pool_op_ptr_start0_s {
 		u64 ptr_start                        : 64;
 	} s;
-	/* struct cavm_npa_lf_pool_op_ptr_start0_s cn; */
+	/* struct npa_lf_pool_op_ptr_start0_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
+static inline u64 NPA_LF_POOL_OP_PTR_START0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
+static inline u64 NPA_LF_POOL_OP_PTR_START0(void)
 {
 	return 0x120;
 }
@@ -1968,18 +1972,18 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
  * NPA LF Pool Pointer Start Operation Register 1 See
  * NPA_LF_POOL_OP_PTR_START0.  RSL accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_ptr_start1 {
+union npa_lf_pool_op_ptr_start1 {
 	u64 u;
-	struct cavm_npa_lf_pool_op_ptr_start1_s {
+	struct npa_lf_pool_op_ptr_start1_s {
 		u64 aura                             : 20;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_lf_pool_op_ptr_start1_s cn; */
+	/* struct npa_lf_pool_op_ptr_start1_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
+static inline u64 NPA_LF_POOL_OP_PTR_START1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
+static inline u64 NPA_LF_POOL_OP_PTR_START1(void)
 {
 	return 0x128;
 }
@@ -1992,21 +1996,21 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
  * register writes NPA_POOL_S[THRESH_UP,THRESH]. A read is RAZ.  RSL
  * accesses to this register are RAZ/WI.
  */
-union cavm_npa_lf_pool_op_thresh {
+union npa_lf_pool_op_thresh {
 	u64 u;
-	struct cavm_npa_lf_pool_op_thresh_s {
+	struct npa_lf_pool_op_thresh_s {
 		u64 thresh                           : 36;
 		u64 reserved_36_41                   : 6;
 		u64 op_err                           : 1;
 		u64 thresh_up                        : 1;
 		u64 aura                             : 20;
 	} s;
-	/* struct cavm_npa_lf_pool_op_thresh_s cn; */
+	/* struct npa_lf_pool_op_thresh_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_POOL_OP_THRESH(void)
+static inline u64 NPA_LF_POOL_OP_THRESH(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_POOL_OP_THRESH(void)
+static inline u64 NPA_LF_POOL_OP_THRESH(void)
 {
 	return 0x170;
 }
@@ -2016,18 +2020,18 @@ static inline u64 CAVM_NPA_LF_POOL_OP_THRESH(void)
  *
  * NPA LF Queue Interrupt Count Registers
  */
-union cavm_npa_lf_qintx_cnt {
+union npa_lf_qintx_cnt {
 	u64 u;
-	struct cavm_npa_lf_qintx_cnt_s {
+	struct npa_lf_qintx_cnt_s {
 		u64 count                            : 22;
 		u64 reserved_22_63                   : 42;
 	} s;
-	/* struct cavm_npa_lf_qintx_cnt_s cn; */
+	/* struct npa_lf_qintx_cnt_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
+static inline u64 NPA_LF_QINTX_CNT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
+static inline u64 NPA_LF_QINTX_CNT(u64 a)
 {
 	return 0x300 + 0x1000 * a;
 }
@@ -2038,18 +2042,18 @@ static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
  * NPA LF Queue Interrupt Enable Clear Registers This register clears
  * interrupt enable bits.
  */
-union cavm_npa_lf_qintx_ena_w1c {
+union npa_lf_qintx_ena_w1c {
 	u64 u;
-	struct cavm_npa_lf_qintx_ena_w1c_s {
+	struct npa_lf_qintx_ena_w1c_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_lf_qintx_ena_w1c_s cn; */
+	/* struct npa_lf_qintx_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
+static inline u64 NPA_LF_QINTX_ENA_W1C(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
+static inline u64 NPA_LF_QINTX_ENA_W1C(u64 a)
 {
 	return 0x330 + 0x1000 * a;
 }
@@ -2060,18 +2064,18 @@ static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
  * NPA LF Queue Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_npa_lf_qintx_ena_w1s {
+union npa_lf_qintx_ena_w1s {
 	u64 u;
-	struct cavm_npa_lf_qintx_ena_w1s_s {
+	struct npa_lf_qintx_ena_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_lf_qintx_ena_w1s_s cn; */
+	/* struct npa_lf_qintx_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_QINTX_ENA_W1S(u64 a)
+static inline u64 NPA_LF_QINTX_ENA_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_QINTX_ENA_W1S(u64 a)
+static inline u64 NPA_LF_QINTX_ENA_W1S(u64 a)
 {
 	return 0x320 + 0x1000 * a;
 }
@@ -2081,18 +2085,18 @@ static inline u64 CAVM_NPA_LF_QINTX_ENA_W1S(u64 a)
  *
  * NPA LF Queue Interrupt Registers
  */
-union cavm_npa_lf_qintx_int {
+union npa_lf_qintx_int {
 	u64 u;
-	struct cavm_npa_lf_qintx_int_s {
+	struct npa_lf_qintx_int_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_lf_qintx_int_s cn; */
+	/* struct npa_lf_qintx_int_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_QINTX_INT(u64 a)
+static inline u64 NPA_LF_QINTX_INT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_QINTX_INT(u64 a)
+static inline u64 NPA_LF_QINTX_INT(u64 a)
 {
 	return 0x310 + 0x1000 * a;
 }
@@ -2102,18 +2106,18 @@ static inline u64 CAVM_NPA_LF_QINTX_INT(u64 a)
  *
  * INTERNAL: NPA LF Queue Interrupt Set Registers
  */
-union cavm_npa_lf_qintx_int_w1s {
+union npa_lf_qintx_int_w1s {
 	u64 u;
-	struct cavm_npa_lf_qintx_int_w1s_s {
+	struct npa_lf_qintx_int_w1s_s {
 		u64 intr                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npa_lf_qintx_int_w1s_s cn; */
+	/* struct npa_lf_qintx_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_QINTX_INT_W1S(u64 a)
+static inline u64 NPA_LF_QINTX_INT_W1S(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_QINTX_INT_W1S(u64 a)
+static inline u64 NPA_LF_QINTX_INT_W1S(u64 a)
 {
 	return 0x318 + 0x1000 * a;
 }
@@ -2123,21 +2127,21 @@ static inline u64 CAVM_NPA_LF_QINTX_INT_W1S(u64 a)
  *
  * NPA LF RAS Interrupt Register
  */
-union cavm_npa_lf_ras {
+union npa_lf_ras {
 	u64 u;
-	struct cavm_npa_lf_ras_s {
+	struct npa_lf_ras_s {
 		u64 aura_poison                      : 1;
 		u64 pool_poison                      : 1;
 		u64 stack_poison                     : 1;
 		u64 qint_poison                      : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npa_lf_ras_s cn; */
+	/* struct npa_lf_ras_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_RAS(void)
+static inline u64 NPA_LF_RAS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_RAS(void)
+static inline u64 NPA_LF_RAS(void)
 {
 	return 0x220;
 }
@@ -2148,21 +2152,21 @@ static inline u64 CAVM_NPA_LF_RAS(void)
  * NPA LF RAS Interrupt Enable Clear Register This register clears
  * interrupt enable bits.
  */
-union cavm_npa_lf_ras_ena_w1c {
+union npa_lf_ras_ena_w1c {
 	u64 u;
-	struct cavm_npa_lf_ras_ena_w1c_s {
+	struct npa_lf_ras_ena_w1c_s {
 		u64 aura_poison                      : 1;
 		u64 pool_poison                      : 1;
 		u64 stack_poison                     : 1;
 		u64 qint_poison                      : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npa_lf_ras_ena_w1c_s cn; */
+	/* struct npa_lf_ras_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
+static inline u64 NPA_LF_RAS_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
+static inline u64 NPA_LF_RAS_ENA_W1C(void)
 {
 	return 0x230;
 }
@@ -2173,21 +2177,21 @@ static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
  * NPA LF RAS Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_npa_lf_ras_ena_w1s {
+union npa_lf_ras_ena_w1s {
 	u64 u;
-	struct cavm_npa_lf_ras_ena_w1s_s {
+	struct npa_lf_ras_ena_w1s_s {
 		u64 aura_poison                      : 1;
 		u64 pool_poison                      : 1;
 		u64 stack_poison                     : 1;
 		u64 qint_poison                      : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npa_lf_ras_ena_w1s_s cn; */
+	/* struct npa_lf_ras_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
+static inline u64 NPA_LF_RAS_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
+static inline u64 NPA_LF_RAS_ENA_W1S(void)
 {
 	return 0x238;
 }
@@ -2197,21 +2201,21 @@ static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
  *
  * NPA LF RAS Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_npa_lf_ras_w1s {
+union npa_lf_ras_w1s {
 	u64 u;
-	struct cavm_npa_lf_ras_w1s_s {
+	struct npa_lf_ras_w1s_s {
 		u64 aura_poison                      : 1;
 		u64 pool_poison                      : 1;
 		u64 stack_poison                     : 1;
 		u64 qint_poison                      : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npa_lf_ras_w1s_s cn; */
+	/* struct npa_lf_ras_w1s_s cn; */
 };
 
-static inline u64 CAVM_NPA_LF_RAS_W1S(void)
+static inline u64 NPA_LF_RAS_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_LF_RAS_W1S(void)
+static inline u64 NPA_LF_RAS_W1S(void)
 {
 	return 0x228;
 }
@@ -2221,20 +2225,20 @@ static inline u64 CAVM_NPA_LF_RAS_W1S(void)
  *
  * NPA Privileged AF Interrupt Configuration Register
  */
-union cavm_npa_priv_af_int_cfg {
+union npa_priv_af_int_cfg {
 	u64 u;
-	struct cavm_npa_priv_af_int_cfg_s {
+	struct npa_priv_af_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_priv_af_int_cfg_s cn; */
+	/* struct npa_priv_af_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
+static inline u64 NPA_PRIV_AF_INT_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
+static inline u64 NPA_PRIV_AF_INT_CFG(void)
 {
 	return 0x10000;
 }
@@ -2250,20 +2254,20 @@ static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
  * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
  * 0x0.
  */
-union cavm_npa_priv_lfx_cfg {
+union npa_priv_lfx_cfg {
 	u64 u;
-	struct cavm_npa_priv_lfx_cfg_s {
+	struct npa_priv_lfx_cfg_s {
 		u64 slot                             : 8;
 		u64 pf_func                          : 16;
 		u64 reserved_24_62                   : 39;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_npa_priv_lfx_cfg_s cn; */
+	/* struct npa_priv_lfx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_PRIV_LFX_CFG(u64 a)
+static inline u64 NPA_PRIV_LFX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_PRIV_LFX_CFG(u64 a)
+static inline u64 NPA_PRIV_LFX_CFG(u64 a)
 {
 	return 0x10010 + 0x100 * a;
 }
@@ -2273,22 +2277,22 @@ static inline u64 CAVM_NPA_PRIV_LFX_CFG(u64 a)
  *
  * NPA Privileged LF Interrupt Configuration Registers
  */
-union cavm_npa_priv_lfx_int_cfg {
+union npa_priv_lfx_int_cfg {
 	u64 u;
-	struct cavm_npa_priv_lfx_int_cfg_s {
+	struct npa_priv_lfx_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npa_priv_lfx_int_cfg_s cn; */
+	/* struct npa_priv_lfx_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPA_PRIV_LFX_INT_CFG(u64 a)
+static inline u64 NPA_PRIV_LFX_INT_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPA_PRIV_LFX_INT_CFG(u64 a)
+static inline u64 NPA_PRIV_LFX_INT_CFG(u64 a)
 {
 	return 0x10020 + 0x100 * a;
 }
 
-#endif /* __CAVM_CSRS_NPA_H__ */
+#endif /* __CSRS_NPA_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-npc.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
similarity index 63%
rename from drivers/net/octeontx2/cavm-csrs-npc.h
rename to arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
index 6655a101d4..6fe5bfa8b0 100644
--- a/drivers/net/octeontx2/cavm-csrs-npc.h
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-npc.h
@@ -1,18 +1,17 @@
-#ifndef __CAVM_CSRS_NPC_H__
-#define __CAVM_CSRS_NPC_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_NPC_H__
+#define __CSRS_NPC_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium NPC.
+ * NPC.
  *
  * This file is auto generated.  Do not edit.
  *
@@ -24,39 +23,39 @@
  * NPC Error Level Enumeration Enumerates the lowest protocol layer
  * containing an error.
  */
-#define CAVM_NPC_ERRLEV_E_LA (1)
-#define CAVM_NPC_ERRLEV_E_LB (2)
-#define CAVM_NPC_ERRLEV_E_LC (3)
-#define CAVM_NPC_ERRLEV_E_LD (4)
-#define CAVM_NPC_ERRLEV_E_LE (5)
-#define CAVM_NPC_ERRLEV_E_LF (6)
-#define CAVM_NPC_ERRLEV_E_LG (7)
-#define CAVM_NPC_ERRLEV_E_LH (8)
-#define CAVM_NPC_ERRLEV_E_NIX (0xf)
-#define CAVM_NPC_ERRLEV_E_RX(a) (0 + (a))
-#define CAVM_NPC_ERRLEV_E_RE (0)
+#define NPC_ERRLEV_E_LA (1)
+#define NPC_ERRLEV_E_LB (2)
+#define NPC_ERRLEV_E_LC (3)
+#define NPC_ERRLEV_E_LD (4)
+#define NPC_ERRLEV_E_LE (5)
+#define NPC_ERRLEV_E_LF (6)
+#define NPC_ERRLEV_E_LG (7)
+#define NPC_ERRLEV_E_LH (8)
+#define NPC_ERRLEV_E_NIX (0xf)
+#define NPC_ERRLEV_E_RX(a) (0 + (a))
+#define NPC_ERRLEV_E_RE (0)
 
 /**
  * Enumeration npc_intf_e
  *
  * NPC Interface Enumeration Enumerates the NPC interfaces.
  */
-#define CAVM_NPC_INTF_E_NIXX_RX(a) (0 + 2 * (a))
-#define CAVM_NPC_INTF_E_NIXX_TX(a) (1 + 2 * (a))
+#define NPC_INTF_E_NIXX_RX(a) (0 + 2 * (a))
+#define NPC_INTF_E_NIXX_TX(a) (1 + 2 * (a))
 
 /**
  * Enumeration npc_lid_e
  *
  * NPC Layer ID Enumeration Enumerates layers parsed by NPC.
  */
-#define CAVM_NPC_LID_E_LA (0)
-#define CAVM_NPC_LID_E_LB (1)
-#define CAVM_NPC_LID_E_LC (2)
-#define CAVM_NPC_LID_E_LD (3)
-#define CAVM_NPC_LID_E_LE (4)
-#define CAVM_NPC_LID_E_LF (5)
-#define CAVM_NPC_LID_E_LG (6)
-#define CAVM_NPC_LID_E_LH (7)
+#define NPC_LID_E_LA (0)
+#define NPC_LID_E_LB (1)
+#define NPC_LID_E_LC (2)
+#define NPC_LID_E_LD (3)
+#define NPC_LID_E_LE (4)
+#define NPC_LID_E_LF (5)
+#define NPC_LID_E_LG (6)
+#define NPC_LID_E_LH (7)
 
 /**
  * Enumeration npc_lkupop_e
@@ -64,17 +63,17 @@
  * NPC Lookup Operation Enumeration Enumerates the lookup operation for
  * NPC_AF_LKUP_CTL[OP].
  */
-#define CAVM_NPC_LKUPOP_E_KEY (1)
-#define CAVM_NPC_LKUPOP_E_PKT (0)
+#define NPC_LKUPOP_E_KEY (1)
+#define NPC_LKUPOP_E_PKT (0)
 
 /**
  * Enumeration npc_mcamkeyw_e
  *
  * NPC MCAM Search Key Width Enumeration
  */
-#define CAVM_NPC_MCAMKEYW_E_X1 (0)
-#define CAVM_NPC_MCAMKEYW_E_X2 (1)
-#define CAVM_NPC_MCAMKEYW_E_X4 (2)
+#define NPC_MCAMKEYW_E_X1 (0)
+#define NPC_MCAMKEYW_E_X2 (1)
+#define NPC_MCAMKEYW_E_X4 (2)
 
 /**
  * Structure npc_layer_info_s
@@ -82,15 +81,15 @@
  * NPC Layer Parse Information Structure This structure specifies the
  * format of NPC_RESULT_S[LA,LB,...,LH].
  */
-union cavm_npc_layer_info_s {
+union npc_layer_info_s {
 	u32 u;
-	struct cavm_npc_layer_info_s_s {
+	struct npc_layer_info_s_s {
 		u32 lptr                             : 8;
 		u32 flags                            : 8;
 		u32 ltype                            : 4;
 		u32 reserved_20_31                   : 12;
 	} s;
-	/* struct cavm_npc_layer_info_s_s cn; */
+	/* struct npc_layer_info_s_s cn; */
 };
 
 /**
@@ -101,14 +100,14 @@ union cavm_npc_layer_info_s {
  * contains the subset of NPC_LAYER_INFO_S fields that can be included in
  * the MCAM search key. See NPC_PARSE_KEX_S and NPC_AF_INTF()_KEX_CFG.
  */
-union cavm_npc_layer_kex_s {
+union npc_layer_kex_s {
 	u32 u;
-	struct cavm_npc_layer_kex_s_s {
+	struct npc_layer_kex_s_s {
 		u32 flags                            : 8;
 		u32 ltype                            : 4;
 		u32 reserved_12_31                   : 20;
 	} s;
-	/* struct cavm_npc_layer_kex_s_s cn; */
+	/* struct npc_layer_kex_s_s cn; */
 };
 
 /**
@@ -118,16 +117,16 @@ union cavm_npc_layer_kex_s {
  * search key format used by an interface when
  * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1.
  */
-union cavm_npc_mcam_key_x1_s {
+union npc_mcam_key_x1_s {
 	u64 u[3];
-	struct cavm_npc_mcam_key_x1_s_s {
+	struct npc_mcam_key_x1_s_s {
 		u64 intf                             : 2;
 		u64 reserved_2_63                    : 62;
 		u64 kw0                              : 64;
 		u64 kw1                              : 48;
 		u64 reserved_176_191                 : 16;
 	} s;
-	/* struct cavm_npc_mcam_key_x1_s_s cn; */
+	/* struct npc_mcam_key_x1_s_s cn; */
 };
 
 /**
@@ -137,9 +136,9 @@ union cavm_npc_mcam_key_x1_s {
  * search key format used by an interface when
  * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2.
  */
-union cavm_npc_mcam_key_x2_s {
+union npc_mcam_key_x2_s {
 	u64 u[5];
-	struct cavm_npc_mcam_key_x2_s_s {
+	struct npc_mcam_key_x2_s_s {
 		u64 intf                             : 2;
 		u64 reserved_2_63                    : 62;
 		u64 kw0                              : 64;
@@ -148,7 +147,7 @@ union cavm_npc_mcam_key_x2_s {
 		u64 kw3                              : 32;
 		u64 reserved_288_319                 : 32;
 	} s;
-	/* struct cavm_npc_mcam_key_x2_s_s cn; */
+	/* struct npc_mcam_key_x2_s_s cn; */
 };
 
 /**
@@ -158,9 +157,9 @@ union cavm_npc_mcam_key_x2_s {
  * search key format used by an interface when
  * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4.
  */
-union cavm_npc_mcam_key_x4_s {
+union npc_mcam_key_x4_s {
 	u64 u[8];
-	struct cavm_npc_mcam_key_x4_s_s {
+	struct npc_mcam_key_x4_s_s {
 		u64 intf                             : 2;
 		u64 reserved_2_63                    : 62;
 		u64 kw0                              : 64;
@@ -171,7 +170,7 @@ union cavm_npc_mcam_key_x4_s {
 		u64 kw5                              : 64;
 		u64 kw6                              : 64;
 	} s;
-	/* struct cavm_npc_mcam_key_x4_s_s cn; */
+	/* struct npc_mcam_key_x4_s_s cn; */
 };
 
 /**
@@ -181,9 +180,9 @@ union cavm_npc_mcam_key_x4_s {
  * NPC_RESULT_S fields that can be included in the MCAM search key. See
  * NPC_AF_INTF()_KEX_CFG.
  */
-union cavm_npc_parse_kex_s {
+union npc_parse_kex_s {
 	u64 u[2];
-	struct cavm_npc_parse_kex_s_s {
+	struct npc_parse_kex_s_s {
 		u64 chan                             : 12;
 		u64 errlev                           : 4;
 		u64 errcode                          : 8;
@@ -201,7 +200,7 @@ union cavm_npc_parse_kex_s {
 		u64 lh                               : 12;
 		u64 reserved_124_127                 : 4;
 	} s;
-	/* struct cavm_npc_parse_kex_s_s cn; */
+	/* struct npc_parse_kex_s_s cn; */
 };
 
 /**
@@ -210,9 +209,9 @@ union cavm_npc_parse_kex_s {
  * NPC Result Structure This structure contains a packet's parse and flow
  * identification information.
  */
-union cavm_npc_result_s {
+union npc_result_s {
 	u64 u[6];
-	struct cavm_npc_result_s_s {
+	struct npc_result_s_s {
 		u64 intf                             : 2;
 		u64 pkind                            : 6;
 		u64 chan                             : 12;
@@ -238,7 +237,7 @@ union cavm_npc_result_s {
 		u64 lh                               : 20;
 		u64 reserved_360_383                 : 24;
 	} s;
-	/* struct cavm_npc_result_s_s cn; */
+	/* struct npc_result_s_s cn; */
 };
 
 /**
@@ -246,17 +245,17 @@ union cavm_npc_result_s {
  *
  * NPC Interrupt-Timer Configuration Register
  */
-union cavm_npc_af_active_pc {
+union npc_af_active_pc {
 	u64 u;
-	struct cavm_npc_af_active_pc_s {
+	struct npc_af_active_pc_s {
 		u64 active_pc                        : 64;
 	} s;
-	/* struct cavm_npc_af_active_pc_s cn; */
+	/* struct npc_af_active_pc_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_ACTIVE_PC(void)
+static inline u64 NPC_AF_ACTIVE_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_ACTIVE_PC(void)
+static inline u64 NPC_AF_ACTIVE_PC(void)
 {
 	return 0x10;
 }
@@ -266,19 +265,19 @@ static inline u64 CAVM_NPC_AF_ACTIVE_PC(void)
  *
  * NPC AF Block Reset Register
  */
-union cavm_npc_af_blk_rst {
+union npc_af_blk_rst {
 	u64 u;
-	struct cavm_npc_af_blk_rst_s {
+	struct npc_af_blk_rst_s {
 		u64 rst                              : 1;
 		u64 reserved_1_62                    : 62;
 		u64 busy                             : 1;
 	} s;
-	/* struct cavm_npc_af_blk_rst_s cn; */
+	/* struct npc_af_blk_rst_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_BLK_RST(void)
+static inline u64 NPC_AF_BLK_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_BLK_RST(void)
+static inline u64 NPC_AF_BLK_RST(void)
 {
 	return 0x40;
 }
@@ -288,20 +287,20 @@ static inline u64 CAVM_NPC_AF_BLK_RST(void)
  *
  * NPC AF General Configuration Register
  */
-union cavm_npc_af_cfg {
+union npc_af_cfg {
 	u64 u;
-	struct cavm_npc_af_cfg_s {
+	struct npc_af_cfg_s {
 		u64 reserved_0_1                     : 2;
 		u64 cclk_force                       : 1;
 		u64 force_intf_clk_en                : 1;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npc_af_cfg_s cn; */
+	/* struct npc_af_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_CFG(void)
+static inline u64 NPC_AF_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_CFG(void)
+static inline u64 NPC_AF_CFG(void)
 {
 	return 0;
 }
@@ -312,9 +311,9 @@ static inline u64 CAVM_NPC_AF_CFG(void)
  * NPC AF Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_npc_af_const {
+union npc_af_const {
 	u64 u;
-	struct cavm_npc_af_const_s {
+	struct npc_af_const_s {
 		u64 intfs                            : 4;
 		u64 lids                             : 4;
 		u64 kpus                             : 5;
@@ -325,12 +324,12 @@ union cavm_npc_af_const {
 		u64 mcam_banks                       : 4;
 		u64 match_stats                      : 16;
 	} s;
-	/* struct cavm_npc_af_const_s cn; */
+	/* struct npc_af_const_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_CONST(void)
+static inline u64 NPC_AF_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_CONST(void)
+static inline u64 NPC_AF_CONST(void)
 {
 	return 0x20;
 }
@@ -341,41 +340,95 @@ static inline u64 CAVM_NPC_AF_CONST(void)
  * NPC AF Constants 1 Register This register contains constants for
  * software discovery.
  */
-union cavm_npc_af_const1 {
+union npc_af_const1 {
 	u64 u;
-	struct cavm_npc_af_const1_s {
+	struct npc_af_const1_s {
 		u64 kpu_entries                      : 12;
 		u64 pkinds                           : 8;
 		u64 cpi_size                         : 16;
-		u64 reserved_36_63                   : 28;
+		u64 reserved_36_62                   : 27;
+		u64 have_const2                      : 1;
 	} s;
-	/* struct cavm_npc_af_const1_s cn; */
+	struct npc_af_const1_cn96xx {
+		u64 kpu_entries                      : 12;
+		u64 pkinds                           : 8;
+		u64 cpi_size                         : 16;
+		u64 reserved_36_63                   : 28;
+	} cn96xx;
+	/* struct npc_af_const1_s cn98xx; */
+	/* struct npc_af_const1_cn96xx cnf95xx; */
+	/* struct npc_af_const1_cn96xx loki; */
 };
 
-static inline u64 CAVM_NPC_AF_CONST1(void)
+static inline u64 NPC_AF_CONST1(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_CONST1(void)
+static inline u64 NPC_AF_CONST1(void)
 {
 	return 0x30;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_const2
+ *
+ * NPC AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const2 {
+	u64 u;
+	struct npc_af_const2_s {
+		u64 mcam_bank_depth_ext              : 16;
+		u64 match_stats_ext                  : 16;
+		u64 reserved_32_62                   : 31;
+		u64 have_const3                      : 1;
+	} s;
+	/* struct npc_af_const2_s cn; */
+};
+
+static inline u64 NPC_AF_CONST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST2(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const3
+ *
+ * NPC AF Constants 3 Register This register contains constants for
+ * software discovery.
+ */
+union npc_af_const3 {
+	u64 u;
+	struct npc_af_const3_s {
+		u64 reserved_0_63                    : 64;
+	} s;
+	/* struct npc_af_const3_s cn; */
+};
+
+static inline u64 NPC_AF_CONST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_CONST3(void)
+{
+	return 0x110;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_cpi#_cfg
  *
  * NPC AF Channel Parse Index Table Registers
  */
-union cavm_npc_af_cpix_cfg {
+union npc_af_cpix_cfg {
 	u64 u;
-	struct cavm_npc_af_cpix_cfg_s {
+	struct npc_af_cpix_cfg_s {
 		u64 padd                             : 4;
 		u64 reserved_4_63                    : 60;
 	} s;
-	/* struct cavm_npc_af_cpix_cfg_s cn; */
+	/* struct npc_af_cpix_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
+static inline u64 NPC_AF_CPIX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
+static inline u64 NPC_AF_CPIX_CFG(u64 a)
 {
 	return 0x200000 + 8 * a;
 }
@@ -387,20 +440,20 @@ static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
  * debug information in NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG,
  * NPC_AF_DBG_DATA() and NPC_AF_DBG_RESULT().
  */
-union cavm_npc_af_dbg_ctl {
+union npc_af_dbg_ctl {
 	u64 u;
-	struct cavm_npc_af_dbg_ctl_s {
+	struct npc_af_dbg_ctl_s {
 		u64 continuous                       : 1;
 		u64 lkup_dbg                         : 1;
 		u64 intf_dbg                         : 4;
 		u64 reserved_6_63                    : 58;
 	} s;
-	/* struct cavm_npc_af_dbg_ctl_s cn; */
+	/* struct npc_af_dbg_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_DBG_CTL(void)
+static inline u64 NPC_AF_DBG_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_DBG_CTL(void)
+static inline u64 NPC_AF_DBG_CTL(void)
 {
 	return 0x3000000;
 }
@@ -412,17 +465,17 @@ static inline u64 CAVM_NPC_AF_DBG_CTL(void)
  * data of the last packet/lookup whose debug information is captured by
  * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
-union cavm_npc_af_dbg_datax {
+union npc_af_dbg_datax {
 	u64 u;
-	struct cavm_npc_af_dbg_datax_s {
+	struct npc_af_dbg_datax_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_npc_af_dbg_datax_s cn; */
+	/* struct npc_af_dbg_datax_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
+static inline u64 NPC_AF_DBG_DATAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
+static inline u64 NPC_AF_DBG_DATAX(u64 a)
 {
 	return 0x3001400 + 0x10 * a;
 }
@@ -434,17 +487,17 @@ static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
  * of the last packet/lookup whose debug information is captured by
  * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
-union cavm_npc_af_dbg_resultx {
+union npc_af_dbg_resultx {
 	u64 u;
-	struct cavm_npc_af_dbg_resultx_s {
+	struct npc_af_dbg_resultx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_npc_af_dbg_resultx_s cn; */
+	/* struct npc_af_dbg_resultx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_DBG_RESULTX(u64 a)
+static inline u64 NPC_AF_DBG_RESULTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_DBG_RESULTX(u64 a)
+static inline u64 NPC_AF_DBG_RESULTX(u64 a)
 {
 	return 0x3001800 + 0x10 * a;
 }
@@ -454,18 +507,18 @@ static inline u64 CAVM_NPC_AF_DBG_RESULTX(u64 a)
  *
  * NPC AF Debug Status Register
  */
-union cavm_npc_af_dbg_status {
+union npc_af_dbg_status {
 	u64 u;
-	struct cavm_npc_af_dbg_status_s {
+	struct npc_af_dbg_status_s {
 		u64 done                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npc_af_dbg_status_s cn; */
+	/* struct npc_af_dbg_status_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
+static inline u64 NPC_AF_DBG_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
+static inline u64 NPC_AF_DBG_STATUS(void)
 {
 	return 0x3000010;
 }
@@ -476,17 +529,17 @@ static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
  * INTERNAL: NPC AF Scratch Register  Internal: This register is for
  * internal DV purpose.
  */
-union cavm_npc_af_dv_fc_scratch {
+union npc_af_dv_fc_scratch {
 	u64 u;
-	struct cavm_npc_af_dv_fc_scratch_s {
+	struct npc_af_dv_fc_scratch_s {
 		u64 it                               : 64;
 	} s;
-	/* struct cavm_npc_af_dv_fc_scratch_s cn; */
+	/* struct npc_af_dv_fc_scratch_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_DV_FC_SCRATCH(void)
+static inline u64 NPC_AF_DV_FC_SCRATCH(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_DV_FC_SCRATCH(void)
+static inline u64 NPC_AF_DV_FC_SCRATCH(void)
 {
 	return 0x60;
 }
@@ -496,18 +549,18 @@ static inline u64 CAVM_NPC_AF_DV_FC_SCRATCH(void)
  *
  * INTERNAL: ECO 0 Register
  */
-union cavm_npc_af_eco0 {
+union npc_af_eco0 {
 	u64 u;
-	struct cavm_npc_af_eco0_s {
+	struct npc_af_eco0_s {
 		u64 eco_rw                           : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_npc_af_eco0_s cn; */
+	/* struct npc_af_eco0_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_ECO0(void)
+static inline u64 NPC_AF_ECO0(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_ECO0(void)
+static inline u64 NPC_AF_ECO0(void)
 {
 	return 0x200;
 }
@@ -522,21 +575,21 @@ static inline u64 CAVM_NPC_AF_ECO0(void)
  * NPC_AF_PKIND()_ACTION1. [DP_OFFSET_ERRCODE] from this register is
  * never used.
  */
-union cavm_npc_af_ikpu_err_ctl {
+union npc_af_ikpu_err_ctl {
 	u64 u;
-	struct cavm_npc_af_ikpu_err_ctl_s {
+	struct npc_af_ikpu_err_ctl_s {
 		u64 errlev                           : 4;
 		u64 dp_offset_errcode                : 8;
 		u64 ptr_advance_errcode              : 8;
 		u64 var_len_offset_errcode           : 8;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_npc_af_ikpu_err_ctl_s cn; */
+	/* struct npc_af_ikpu_err_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_IKPU_ERR_CTL(void)
+static inline u64 NPC_AF_IKPU_ERR_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_IKPU_ERR_CTL(void)
+static inline u64 NPC_AF_IKPU_ERR_CTL(void)
 {
 	return 0x3000080;
 }
@@ -546,20 +599,20 @@ static inline u64 CAVM_NPC_AF_IKPU_ERR_CTL(void)
  *
  * NPC AF Interface Key Extract Configuration Registers
  */
-union cavm_npc_af_intfx_kex_cfg {
+union npc_af_intfx_kex_cfg {
 	u64 u;
-	struct cavm_npc_af_intfx_kex_cfg_s {
+	struct npc_af_intfx_kex_cfg_s {
 		u64 parse_nibble_ena                 : 31;
 		u64 reserved_31                      : 1;
 		u64 keyw                             : 3;
 		u64 reserved_35_63                   : 29;
 	} s;
-	/* struct cavm_npc_af_intfx_kex_cfg_s cn; */
+	/* struct npc_af_intfx_kex_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
+static inline u64 NPC_AF_INTFX_KEX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
+static inline u64 NPC_AF_INTFX_KEX_CFG(u64 a)
 {
 	return 0x1010 + 0x100 * a;
 }
@@ -572,9 +625,9 @@ static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
  * search key for each interface based on the FLAGS\<3:0\> bits of two
  * layers selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
  */
-union cavm_npc_af_intfx_ldatax_flagsx_cfg {
+union npc_af_intfx_ldatax_flagsx_cfg {
 	u64 u;
-	struct cavm_npc_af_intfx_ldatax_flagsx_cfg_s {
+	struct npc_af_intfx_ldatax_flagsx_cfg_s {
 		u64 key_offset                       : 6;
 		u64 reserved_6                       : 1;
 		u64 ena                              : 1;
@@ -582,12 +635,12 @@ union cavm_npc_af_intfx_ldatax_flagsx_cfg {
 		u64 bytesm1                          : 4;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npc_af_intfx_ldatax_flagsx_cfg_s cn; */
+	/* struct npc_af_intfx_ldatax_flagsx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
 {
 	return 0x980000 + 0x10000 * a + 0x1000 * b + 8 * c;
 }
@@ -606,9 +659,9 @@ static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
  * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction
  * when LTYPE is zero.
  */
-union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
+union npc_af_intfx_lidx_ltx_ldx_cfg {
 	u64 u;
-	struct cavm_npc_af_intfx_lidx_ltx_ldx_cfg_s {
+	struct npc_af_intfx_lidx_ltx_ldx_cfg_s {
 		u64 key_offset                       : 6;
 		u64 flags_ena                        : 1;
 		u64 ena                              : 1;
@@ -616,12 +669,12 @@ union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
 		u64 bytesm1                          : 4;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npc_af_intfx_lidx_ltx_ldx_cfg_s cn; */
+	/* struct npc_af_intfx_lidx_ltx_ldx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+static inline u64 NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+static inline u64 NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
 {
 	return 0x900000 + 0x10000 * a + 0x1000 * b + 0x20 * c + 8 * d;
 }
@@ -634,17 +687,17 @@ static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
  * yields an MCAM miss for a packet, this register specifies the packet's
  * match action captured in NPC_RESULT_S[ACTION].
  */
-union cavm_npc_af_intfx_miss_act {
+union npc_af_intfx_miss_act {
 	u64 u;
-	struct cavm_npc_af_intfx_miss_act_s {
+	struct npc_af_intfx_miss_act_s {
 		u64 action                           : 64;
 	} s;
-	/* struct cavm_npc_af_intfx_miss_act_s cn; */
+	/* struct npc_af_intfx_miss_act_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_ACT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_ACT(u64 a)
 {
 	return 0x1a00000 + 0x10 * a;
 }
@@ -656,19 +709,28 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
  * optionally increment a NPC_AF_MATCH_STAT() counter when a packet
  * misses an MCAM entry.
  */
-union cavm_npc_af_intfx_miss_stat_act {
+union npc_af_intfx_miss_stat_act {
 	u64 u;
-	struct cavm_npc_af_intfx_miss_stat_act_s {
+	struct npc_af_intfx_miss_stat_act_s {
 		u64 stat_sel                         : 9;
 		u64 ena                              : 1;
-		u64 reserved_10_63                   : 54;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npc_af_intfx_miss_stat_act_s cn; */
+	struct npc_af_intfx_miss_stat_act_cn96xx {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} cn96xx;
+	/* struct npc_af_intfx_miss_stat_act_s cn98xx; */
+	/* struct npc_af_intfx_miss_stat_act_cn96xx cnf95xx; */
+	/* struct npc_af_intfx_miss_stat_act_cn96xx loki; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
 {
 	return 0x1880040 + 8 * a;
 }
@@ -682,17 +744,17 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
  * register specifies the packet's match Vtag action captured in
  * NPC_RESULT_S[VTAG_ACTION].
  */
-union cavm_npc_af_intfx_miss_tag_act {
+union npc_af_intfx_miss_tag_act {
 	u64 u;
-	struct cavm_npc_af_intfx_miss_tag_act_s {
+	struct npc_af_intfx_miss_tag_act_s {
 		u64 vtag_action                      : 64;
 	} s;
-	/* struct cavm_npc_af_intfx_miss_tag_act_s cn; */
+	/* struct npc_af_intfx_miss_tag_act_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+static inline u64 NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
 {
 	return 0x1b00008 + 0x10 * a;
 }
@@ -703,18 +765,18 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
  * NPC AF Interface Statistics Registers Statistics per interface. Index
  * enumerated by NPC_INTF_E.
  */
-union cavm_npc_af_intfx_stat {
+union npc_af_intfx_stat {
 	u64 u;
-	struct cavm_npc_af_intfx_stat_s {
+	struct npc_af_intfx_stat_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_npc_af_intfx_stat_s cn; */
+	/* struct npc_af_intfx_stat_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_INTFX_STAT(u64 a)
+static inline u64 NPC_AF_INTFX_STAT(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_INTFX_STAT(u64 a)
+static inline u64 NPC_AF_INTFX_STAT(u64 a)
 {
 	return 0x2000800 + 0x10 * a;
 }
@@ -724,9 +786,9 @@ static inline u64 CAVM_NPC_AF_INTFX_STAT(u64 a)
  *
  * NPC AF KCAM Scrub Control Register
  */
-union cavm_npc_af_kcam_scrub_ctl {
+union npc_af_kcam_scrub_ctl {
 	u64 u;
-	struct cavm_npc_af_kcam_scrub_ctl_s {
+	struct npc_af_kcam_scrub_ctl_s {
 		u64 ena                              : 1;
 		u64 reserved_1_7                     : 7;
 		u64 lp_dis                           : 1;
@@ -734,12 +796,12 @@ union cavm_npc_af_kcam_scrub_ctl {
 		u64 toth                             : 4;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npc_af_kcam_scrub_ctl_s cn; */
+	/* struct npc_af_kcam_scrub_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KCAM_SCRUB_CTL(void)
+static inline u64 NPC_AF_KCAM_SCRUB_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KCAM_SCRUB_CTL(void)
+static inline u64 NPC_AF_KCAM_SCRUB_CTL(void)
 {
 	return 0xb0;
 }
@@ -749,18 +811,18 @@ static inline u64 CAVM_NPC_AF_KCAM_SCRUB_CTL(void)
  *
  * NPC AF Key Extract Layer Data Flags Configuration Register
  */
-union cavm_npc_af_kex_ldatax_flags_cfg {
+union npc_af_kex_ldatax_flags_cfg {
 	u64 u;
-	struct cavm_npc_af_kex_ldatax_flags_cfg_s {
+	struct npc_af_kex_ldatax_flags_cfg_s {
 		u64 lid                              : 3;
 		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_npc_af_kex_ldatax_flags_cfg_s cn; */
+	/* struct npc_af_kex_ldatax_flags_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+static inline u64 NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+static inline u64 NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
 {
 	return 0x800 + 8 * a;
 }
@@ -770,18 +832,18 @@ static inline u64 CAVM_NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
  *
  * NPC AF KPU Configuration Registers
  */
-union cavm_npc_af_kpux_cfg {
+union npc_af_kpux_cfg {
 	u64 u;
-	struct cavm_npc_af_kpux_cfg_s {
+	struct npc_af_kpux_cfg_s {
 		u64 ena                              : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npc_af_kpux_cfg_s cn; */
+	/* struct npc_af_kpux_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
+static inline u64 NPC_AF_KPUX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
+static inline u64 NPC_AF_KPUX_CFG(u64 a)
 {
 	return 0x500 + 8 * a;
 }
@@ -792,22 +854,22 @@ static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
  * NPC AF KPU Debug Registers This register contains information for the
  * last packet/lookup for which debug is enabled by
  * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG]. The register contents are undefined
- * and should be ignored for a software key lookup (NPC_AF_LKUP_CTL[OP] =
- * NPC_LKUPOP_E::KEY)
+ * when debug information is captured for a software key lookup
+ * (NPC_AF_LKUP_CTL[OP] = NPC_LKUPOP_E::KEY).
  */
-union cavm_npc_af_kpux_dbg {
+union npc_af_kpux_dbg {
 	u64 u;
-	struct cavm_npc_af_kpux_dbg_s {
+	struct npc_af_kpux_dbg_s {
 		u64 hit_entry                        : 8;
 		u64 byp                              : 1;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_npc_af_kpux_dbg_s cn; */
+	/* struct npc_af_kpux_dbg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
+static inline u64 NPC_AF_KPUX_DBG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
+static inline u64 NPC_AF_KPUX_DBG(u64 a)
 {
 	return 0x3000020 + 0x100 * a;
 }
@@ -821,9 +883,9 @@ static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
  * NPC_AF_KPU()_ENTRY()_ACTION1 specifies the next state and operations
  * to perform before exiting the KPU.
  */
-union cavm_npc_af_kpux_entryx_action0 {
+union npc_af_kpux_entryx_action0 {
 	u64 u;
-	struct cavm_npc_af_kpux_entryx_action0_s {
+	struct npc_af_kpux_entryx_action0_s {
 		u64 var_len_shift                    : 3;
 		u64 var_len_right                    : 1;
 		u64 var_len_mask                     : 8;
@@ -839,12 +901,12 @@ union cavm_npc_af_kpux_entryx_action0 {
 		u64 byp_count                        : 3;
 		u64 reserved_57_63                   : 7;
 	} s;
-	/* struct cavm_npc_af_kpux_entryx_action0_s cn; */
+	/* struct npc_af_kpux_entryx_action0_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
 {
 	return 0x100020 + 0x4000 * a + 0x40 * b;
 }
@@ -855,9 +917,9 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
  * NPC AF KPU Entry Action Data 0 Registers See
  * NPC_AF_KPU()_ENTRY()_ACTION0.
  */
-union cavm_npc_af_kpux_entryx_action1 {
+union npc_af_kpux_entryx_action1 {
 	u64 u;
-	struct cavm_npc_af_kpux_entryx_action1_s {
+	struct npc_af_kpux_entryx_action1_s {
 		u64 dp0_offset                       : 8;
 		u64 dp1_offset                       : 8;
 		u64 dp2_offset                       : 8;
@@ -865,12 +927,12 @@ union cavm_npc_af_kpux_entryx_action1 {
 		u64 errlev                           : 4;
 		u64 reserved_36_63                   : 28;
 	} s;
-	/* struct cavm_npc_af_kpux_entryx_action1_s cn; */
+	/* struct npc_af_kpux_entryx_action1_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
 {
 	return 0x100028 + 0x4000 * a + 0x40 * b;
 }
@@ -893,21 +955,21 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
  * KPU's last entry {b} (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match
  * all bits.
  */
-union cavm_npc_af_kpux_entryx_camx {
+union npc_af_kpux_entryx_camx {
 	u64 u;
-	struct cavm_npc_af_kpux_entryx_camx_s {
+	struct npc_af_kpux_entryx_camx_s {
 		u64 dp0_data                         : 16;
 		u64 dp1_data                         : 16;
 		u64 dp2_data                         : 16;
 		u64 state                            : 8;
 		u64 reserved_56_63                   : 8;
 	} s;
-	/* struct cavm_npc_af_kpux_entryx_camx_s cn; */
+	/* struct npc_af_kpux_entryx_camx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
 {
 	return 0x100000 + 0x4000 * a + 0x40 * b + 8 * c;
 }
@@ -917,17 +979,17 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
  *
  * NPC AF KPU Entry Disable Registers See NPC_AF_KPU()_ENTRY()_ACTION0.
  */
-union cavm_npc_af_kpux_entry_disx {
+union npc_af_kpux_entry_disx {
 	u64 u;
-	struct cavm_npc_af_kpux_entry_disx_s {
+	struct npc_af_kpux_entry_disx_s {
 		u64 dis                              : 64;
 	} s;
-	/* struct cavm_npc_af_kpux_entry_disx_s cn; */
+	/* struct npc_af_kpux_entry_disx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+static inline u64 NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
 {
 	return 0x180000 + 0x40 * a + 8 * b;
 }
@@ -939,33 +1001,54 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
  * captured in NPC_RESULT_S[ERRLEV,ERRCODE] when errors are detected by a
  * KPU.
  */
-union cavm_npc_af_kpux_err_ctl {
+union npc_af_kpux_err_ctl {
 	u64 u;
-	struct cavm_npc_af_kpux_err_ctl_s {
+	struct npc_af_kpux_err_ctl_s {
 		u64 errlev                           : 4;
 		u64 dp_offset_errcode                : 8;
 		u64 ptr_advance_errcode              : 8;
 		u64 var_len_offset_errcode           : 8;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_npc_af_kpux_err_ctl_s cn; */
+	/* struct npc_af_kpux_err_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_KPUX_ERR_CTL(u64 a)
+static inline u64 NPC_AF_KPUX_ERR_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_KPUX_ERR_CTL(u64 a)
+static inline u64 NPC_AF_KPUX_ERR_CTL(u64 a)
 {
 	return 0x30000a0 + 0x100 * a;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu_diag
+ *
+ * INTERNAL : NPC AF Debug Result Registers
+ */
+union npc_af_kpu_diag {
+	u64 u;
+	struct npc_af_kpu_diag_s {
+		u64 skip_dis                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_kpu_diag_s cn; */
+};
+
+static inline u64 NPC_AF_KPU_DIAG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_KPU_DIAG(void)
+{
+	return 0x3002000;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_lkup_ctl
  *
  * NPC AF Software Lookup Control Registers
  */
-union cavm_npc_af_lkup_ctl {
+union npc_af_lkup_ctl {
 	u64 u;
-	struct cavm_npc_af_lkup_ctl_s {
+	struct npc_af_lkup_ctl_s {
 		u64 intf                             : 2;
 		u64 pkind                            : 6;
 		u64 chan                             : 12;
@@ -974,12 +1057,12 @@ union cavm_npc_af_lkup_ctl {
 		u64 exec                             : 1;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_npc_af_lkup_ctl_s cn; */
+	/* struct npc_af_lkup_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_LKUP_CTL(void)
+static inline u64 NPC_AF_LKUP_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_LKUP_CTL(void)
+static inline u64 NPC_AF_LKUP_CTL(void)
 {
 	return 0x2000000;
 }
@@ -989,17 +1072,17 @@ static inline u64 CAVM_NPC_AF_LKUP_CTL(void)
  *
  * NPC AF Software Lookup Data Registers
  */
-union cavm_npc_af_lkup_datax {
+union npc_af_lkup_datax {
 	u64 u;
-	struct cavm_npc_af_lkup_datax_s {
+	struct npc_af_lkup_datax_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_npc_af_lkup_datax_s cn; */
+	/* struct npc_af_lkup_datax_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_LKUP_DATAX(u64 a)
+static inline u64 NPC_AF_LKUP_DATAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_LKUP_DATAX(u64 a)
+static inline u64 NPC_AF_LKUP_DATAX(u64 a)
 {
 	return 0x2000200 + 0x10 * a;
 }
@@ -1009,17 +1092,17 @@ static inline u64 CAVM_NPC_AF_LKUP_DATAX(u64 a)
  *
  * NPC AF Software Lookup Result Registers
  */
-union cavm_npc_af_lkup_resultx {
+union npc_af_lkup_resultx {
 	u64 u;
-	struct cavm_npc_af_lkup_resultx_s {
+	struct npc_af_lkup_resultx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_npc_af_lkup_resultx_s cn; */
+	/* struct npc_af_lkup_resultx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_LKUP_RESULTX(u64 a)
+static inline u64 NPC_AF_LKUP_RESULTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_LKUP_RESULTX(u64 a)
+static inline u64 NPC_AF_LKUP_RESULTX(u64 a)
 {
 	return 0x2000400 + 0x10 * a;
 }
@@ -1029,42 +1112,83 @@ static inline u64 CAVM_NPC_AF_LKUP_RESULTX(u64 a)
  *
  * NPC AF Match Statistics Registers
  */
-union cavm_npc_af_match_statx {
+union npc_af_match_statx {
 	u64 u;
-	struct cavm_npc_af_match_statx_s {
+	struct npc_af_match_statx_s {
 		u64 count                            : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_npc_af_match_statx_s cn; */
+	/* struct npc_af_match_statx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MATCH_STATX(u64 a)
+static inline u64 NPC_AF_MATCH_STATX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MATCH_STATX(u64 a)
+static inline u64 NPC_AF_MATCH_STATX(u64 a)
 {
 	return 0x1880008 + 0x100 * a;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_match_stat#_ext
+ *
+ * NPC AF Match Statistics Registers
+ */
+union npc_af_match_statx_ext {
+	u64 u;
+	struct npc_af_match_statx_ext_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_match_statx_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MATCH_STATX_EXT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MATCH_STATX_EXT(u64 a)
+{
+	return 0x8000078 + 0x100 * a;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcam_bank#_hit#
  *
  * NPC AF MCAM Bank Hit Registers
  */
-union cavm_npc_af_mcam_bankx_hitx {
+union npc_af_mcam_bankx_hitx {
 	u64 u;
-	struct cavm_npc_af_mcam_bankx_hitx_s {
+	struct npc_af_mcam_bankx_hitx_s {
 		u64 hit                              : 64;
 	} s;
-	/* struct cavm_npc_af_mcam_bankx_hitx_s cn; */
+	/* struct npc_af_mcam_bankx_hitx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+static inline u64 NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+static inline u64 NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
 {
 	return 0x1c80000 + 0x100 * a + 0x10 * b;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_bank#_hit#_ext
+ *
+ * NPC AF MCAM Bank Hit Registers
+ */
+union npc_af_mcam_bankx_hitx_ext {
+	u64 u;
+	struct npc_af_mcam_bankx_hitx_ext_s {
+		u64 hit                              : 64;
+	} s;
+	/* struct npc_af_mcam_bankx_hitx_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAM_BANKX_HITX_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAM_BANKX_HITX_EXT(u64 a, u64 b)
+{
+	return 0x8000070 + 0x1000000 * a + 0x100 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcam_dbg
  *
@@ -1072,9 +1196,9 @@ static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
  * last packet/lookup for which debug is enabled by
  * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
-union cavm_npc_af_mcam_dbg {
+union npc_af_mcam_dbg {
 	u64 u;
-	struct cavm_npc_af_mcam_dbg_s {
+	struct npc_af_mcam_dbg_s {
 		u64 hit_entry                        : 10;
 		u64 reserved_10_11                   : 2;
 		u64 hit_bank                         : 2;
@@ -1082,12 +1206,12 @@ union cavm_npc_af_mcam_dbg {
 		u64 miss                             : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_npc_af_mcam_dbg_s cn; */
+	/* struct npc_af_mcam_dbg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAM_DBG(void)
+static inline u64 NPC_AF_MCAM_DBG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAM_DBG(void)
+static inline u64 NPC_AF_MCAM_DBG(void)
 {
 	return 0x3001000;
 }
@@ -1097,9 +1221,9 @@ static inline u64 CAVM_NPC_AF_MCAM_DBG(void)
  *
  * NPC AF MCAM Scrub Control Register
  */
-union cavm_npc_af_mcam_scrub_ctl {
+union npc_af_mcam_scrub_ctl {
 	u64 u;
-	struct cavm_npc_af_mcam_scrub_ctl_s {
+	struct npc_af_mcam_scrub_ctl_s {
 		u64 ena                              : 1;
 		u64 reserved_1_7                     : 7;
 		u64 lp_dis                           : 1;
@@ -1107,12 +1231,12 @@ union cavm_npc_af_mcam_scrub_ctl {
 		u64 toth                             : 4;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_npc_af_mcam_scrub_ctl_s cn; */
+	/* struct npc_af_mcam_scrub_ctl_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
+static inline u64 NPC_AF_MCAM_SCRUB_CTL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
+static inline u64 NPC_AF_MCAM_SCRUB_CTL(void)
 {
 	return 0xa0;
 }
@@ -1135,21 +1259,41 @@ static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
  * search key matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
  * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
  */
-union cavm_npc_af_mcamex_bankx_action {
+union npc_af_mcamex_bankx_action {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_action_s {
+	struct npc_af_mcamex_bankx_action_s {
 		u64 action                           : 64;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_action_s cn; */
+	/* struct npc_af_mcamex_bankx_action_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
 {
 	return 0x1900000 + 0x100 * a + 0x10 * b;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_action_ext
+ *
+ * NPC AF MCAM Entry Bank Action Data Registers
+ */
+union npc_af_mcamex_bankx_action_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_action_ext_s {
+		u64 action                           : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_action_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_ACTION_EXT(u64 a, u64 b)
+{
+	return 0x8000040 + 0x100 * a + 0x1000000 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf
  *
@@ -1236,86 +1380,169 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
  * each bank, the lowest numbered matching entry takes priority over any
  * higher numbered entry.
  */
-union cavm_npc_af_mcamex_bankx_camx_intf {
+union npc_af_mcamex_bankx_camx_intf {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_camx_intf_s {
+	struct npc_af_mcamex_bankx_camx_intf_s {
 		u64 intf                             : 2;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_camx_intf_s cn; */
+	/* struct npc_af_mcamex_bankx_camx_intf_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
 {
 	return 0x1000000 + 0x400 * a + 0x40 * b + 8 * c;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf_ext
+ *
+ * NPC AF Extended MCAM Entry Bank CAM Data Interface Registers
+ */
+union npc_af_mcamex_bankx_camx_intf_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_intf_ext_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_intf_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_INTF_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000000 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0
  *
  * NPC AF MCAM Entry Bank CAM Data Word 0 Registers MCAM comparison
  * ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
  */
-union cavm_npc_af_mcamex_bankx_camx_w0 {
+union npc_af_mcamex_bankx_camx_w0 {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_camx_w0_s {
+	struct npc_af_mcamex_bankx_camx_w0_s {
 		u64 md                               : 64;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_camx_w0_s cn; */
+	/* struct npc_af_mcamex_bankx_camx_w0_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
 {
 	return 0x1000010 + 0x400 * a + 0x40 * b + 8 * c;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0_ext
+ *
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers
+ */
+union npc_af_mcamex_bankx_camx_w0_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w0_ext_s {
+		u64 md                               : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w0_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W0_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000010 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1
  *
  * NPC AF MCAM Entry Bank Data Word 1 Registers MCAM comparison ternary
  * data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
  */
-union cavm_npc_af_mcamex_bankx_camx_w1 {
+union npc_af_mcamex_bankx_camx_w1 {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_camx_w1_s {
+	struct npc_af_mcamex_bankx_camx_w1_s {
 		u64 md                               : 48;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_camx_w1_s cn; */
+	/* struct npc_af_mcamex_bankx_camx_w1_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
 {
 	return 0x1000020 + 0x400 * a + 0x40 * b + 8 * c;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1_ext
+ *
+ * NPC AF MCAM Entry Bank Data Word 1 Registers
+ */
+union npc_af_mcamex_bankx_camx_w1_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w1_ext_s {
+		u64 md                               : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct npc_af_mcamex_bankx_camx_w1_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1_EXT(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CAMX_W1_EXT(u64 a, u64 b, u64 c)
+{
+	return 0x8000020 + 0x100 * a + 0x1000000 * b + 8 * c;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cfg
  *
  * NPC AF MCAM Entry Bank Configuration Registers
  */
-union cavm_npc_af_mcamex_bankx_cfg {
+union npc_af_mcamex_bankx_cfg {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_cfg_s {
+	struct npc_af_mcamex_bankx_cfg_s {
 		u64 ena                              : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_cfg_s cn; */
+	/* struct npc_af_mcamex_bankx_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
 {
 	return 0x1800000 + 0x100 * a + 0x10 * b;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cfg_ext
+ *
+ * NPC AF MCAM Entry Bank Configuration Registers
+ */
+union npc_af_mcamex_bankx_cfg_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_cfg_ext_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct npc_af_mcamex_bankx_cfg_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_CFG_EXT(u64 a, u64 b)
+{
+	return 0x8000038 + 0x100 * a + 0x1000000 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act
  *
@@ -1323,23 +1550,56 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
  * increment a NPC_AF_MATCH_STAT() counter when a packet matches an MCAM
  * entry. See also NPC_AF_MCAME()_BANK()_ACTION.
  */
-union cavm_npc_af_mcamex_bankx_stat_act {
+union npc_af_mcamex_bankx_stat_act {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_stat_act_s {
+	struct npc_af_mcamex_bankx_stat_act_s {
 		u64 stat_sel                         : 9;
 		u64 ena                              : 1;
-		u64 reserved_10_63                   : 54;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_stat_act_s cn; */
+	struct npc_af_mcamex_bankx_stat_act_cn96xx {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} cn96xx;
+	/* struct npc_af_mcamex_bankx_stat_act_s cn98xx; */
+	/* struct npc_af_mcamex_bankx_stat_act_cn96xx cnf95xx; */
+	/* struct npc_af_mcamex_bankx_stat_act_cn96xx loki; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
 {
 	return 0x1880000 + 0x100 * a + 0x10 * b;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act_ext
+ *
+ * NPC AF MCAM Entry Bank Statistics Action Registers
+ */
+union npc_af_mcamex_bankx_stat_act_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_stat_act_ext_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_11                   : 2;
+		u64 stat_sel_ext                     : 3;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct npc_af_mcamex_bankx_stat_act_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_STAT_ACT_EXT(u64 a, u64 b)
+{
+	return 0x8000050 + 0x100 * a + 0x1000000 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act
  *
@@ -1347,29 +1607,97 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
  * match Vtag action captured in NPC_RESULT_S[VTAG_ACTION]. See also
  * NPC_AF_MCAME()_BANK()_ACTION.
  */
-union cavm_npc_af_mcamex_bankx_tag_act {
+union npc_af_mcamex_bankx_tag_act {
 	u64 u;
-	struct cavm_npc_af_mcamex_bankx_tag_act_s {
+	struct npc_af_mcamex_bankx_tag_act_s {
 		u64 vtag_action                      : 64;
 	} s;
-	/* struct cavm_npc_af_mcamex_bankx_tag_act_s cn; */
+	/* struct npc_af_mcamex_bankx_tag_act_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
 {
 	return 0x1900008 + 0x100 * a + 0x10 * b;
 }
 
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act_ext
+ *
+ * NPC AF MCAM Entry Bank VTag Action Data Registers
+ */
+union npc_af_mcamex_bankx_tag_act_ext {
+	u64 u;
+	struct npc_af_mcamex_bankx_tag_act_ext_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct npc_af_mcamex_bankx_tag_act_ext_s cn; */
+};
+
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT_EXT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_MCAMEX_BANKX_TAG_ACT_EXT(u64 a, u64 b)
+{
+	return 0x8000048 + 0x100 * a + 0x1000000 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_nife_bp_test
+ *
+ * INTERNAL: NPC AF NIFE Backpressure Test Register
+ */
+union npc_af_nife_bp_test {
+	u64 u;
+	struct npc_af_nife_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct npc_af_nife_bp_test_s cn; */
+};
+
+static inline u64 NPC_AF_NIFE_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_NIFE_BP_TEST(void)
+{
+	return 0x3003008;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_nifi_bp_test
+ *
+ * INTERNAL: NPC AF NIFI Backpressure Test Register
+ */
+union npc_af_nifi_bp_test {
+	u64 u;
+	struct npc_af_nifi_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct npc_af_nifi_bp_test_s cn; */
+};
+
+static inline u64 NPC_AF_NIFI_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 NPC_AF_NIFI_BP_TEST(void)
+{
+	return 0x3003000;
+}
+
 /**
  * Register (RVU_PF_BAR0) npc_af_pck_cfg
  *
  * NPC AF Protocol Check Configuration Register
  */
-union cavm_npc_af_pck_cfg {
+union npc_af_pck_cfg {
 	u64 u;
-	struct cavm_npc_af_pck_cfg_s {
+	struct npc_af_pck_cfg_s {
 		u64 reserved_0                       : 1;
 		u64 iip4_cksum                       : 1;
 		u64 oip4_cksum                       : 1;
@@ -1383,12 +1711,12 @@ union cavm_npc_af_pck_cfg {
 		u64 oip4_cksum_errcode               : 8;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_npc_af_pck_cfg_s cn; */
+	/* struct npc_af_pck_cfg_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PCK_CFG(void)
+static inline u64 NPC_AF_PCK_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PCK_CFG(void)
+static inline u64 NPC_AF_PCK_CFG(void)
 {
 	return 0x600;
 }
@@ -1400,20 +1728,20 @@ static inline u64 CAVM_NPC_AF_PCK_CFG(void)
  * information used by the protocol checker to identify an inner IPv4
  * header.
  */
-union cavm_npc_af_pck_def_iip4 {
+union npc_af_pck_def_iip4 {
 	u64 u;
-	struct cavm_npc_af_pck_def_iip4_s {
+	struct npc_af_pck_def_iip4_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_npc_af_pck_def_iip4_s cn; */
+	/* struct npc_af_pck_def_iip4_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
+static inline u64 NPC_AF_PCK_DEF_IIP4(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
+static inline u64 NPC_AF_PCK_DEF_IIP4(void)
 {
 	return 0x640;
 }
@@ -1425,20 +1753,20 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
  * information used by the protocol checker to identify an outer IPv4
  * header.
  */
-union cavm_npc_af_pck_def_oip4 {
+union npc_af_pck_def_oip4 {
 	u64 u;
-	struct cavm_npc_af_pck_def_oip4_s {
+	struct npc_af_pck_def_oip4_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_npc_af_pck_def_oip4_s cn; */
+	/* struct npc_af_pck_def_oip4_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
+static inline u64 NPC_AF_PCK_DEF_OIP4(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
+static inline u64 NPC_AF_PCK_DEF_OIP4(void)
 {
 	return 0x620;
 }
@@ -1450,20 +1778,20 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
  * information used by the protocol checker to identify an outer IPv6
  * header. [LID] must have the same value as NPC_AF_PCK_DEF_OIP4[LID].
  */
-union cavm_npc_af_pck_def_oip6 {
+union npc_af_pck_def_oip6 {
 	u64 u;
-	struct cavm_npc_af_pck_def_oip6_s {
+	struct npc_af_pck_def_oip6_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_npc_af_pck_def_oip6_s cn; */
+	/* struct npc_af_pck_def_oip6_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
+static inline u64 NPC_AF_PCK_DEF_OIP6(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
+static inline u64 NPC_AF_PCK_DEF_OIP6(void)
 {
 	return 0x630;
 }
@@ -1475,20 +1803,20 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
  * information used by the protocol checker to identify an outer L2
  * header.
  */
-union cavm_npc_af_pck_def_ol2 {
+union npc_af_pck_def_ol2 {
 	u64 u;
-	struct cavm_npc_af_pck_def_ol2_s {
+	struct npc_af_pck_def_ol2_s {
 		u64 ltype_mask                       : 4;
 		u64 ltype_match                      : 4;
 		u64 lid                              : 3;
 		u64 reserved_11_63                   : 53;
 	} s;
-	/* struct cavm_npc_af_pck_def_ol2_s cn; */
+	/* struct npc_af_pck_def_ol2_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
+static inline u64 NPC_AF_PCK_DEF_OL2(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
+static inline u64 NPC_AF_PCK_DEF_OL2(void)
 {
 	return 0x610;
 }
@@ -1500,9 +1828,9 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
  * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
  * to perform before entering KPU 0.
  */
-union cavm_npc_af_pkindx_action0 {
+union npc_af_pkindx_action0 {
 	u64 u;
-	struct cavm_npc_af_pkindx_action0_s {
+	struct npc_af_pkindx_action0_s {
 		u64 var_len_shift                    : 3;
 		u64 var_len_right                    : 1;
 		u64 var_len_mask                     : 8;
@@ -1518,12 +1846,12 @@ union cavm_npc_af_pkindx_action0 {
 		u64 byp_count                        : 3;
 		u64 reserved_57_63                   : 7;
 	} s;
-	/* struct cavm_npc_af_pkindx_action0_s cn; */
+	/* struct npc_af_pkindx_action0_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
+static inline u64 NPC_AF_PKINDX_ACTION0(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
+static inline u64 NPC_AF_PKINDX_ACTION0(u64 a)
 {
 	return 0x80000 + 0x40 * a;
 }
@@ -1535,9 +1863,9 @@ static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
  * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
  * to perform before entering KPU 0.
  */
-union cavm_npc_af_pkindx_action1 {
+union npc_af_pkindx_action1 {
 	u64 u;
-	struct cavm_npc_af_pkindx_action1_s {
+	struct npc_af_pkindx_action1_s {
 		u64 dp0_offset                       : 8;
 		u64 dp1_offset                       : 8;
 		u64 dp2_offset                       : 8;
@@ -1545,12 +1873,12 @@ union cavm_npc_af_pkindx_action1 {
 		u64 errlev                           : 4;
 		u64 reserved_36_63                   : 28;
 	} s;
-	/* struct cavm_npc_af_pkindx_action1_s cn; */
+	/* struct npc_af_pkindx_action1_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
+static inline u64 NPC_AF_PKINDX_ACTION1(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
+static inline u64 NPC_AF_PKINDX_ACTION1(u64 a)
 {
 	return 0x80008 + 0x40 * a;
 }
@@ -1578,9 +1906,9 @@ static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
  * NPC_RESULT_S[CHAN] += NPC_AF_CPI(cpi)_CFG[PADD];       break;    } }
  * \</pre\>
  */
-union cavm_npc_af_pkindx_cpi_defx {
+union npc_af_pkindx_cpi_defx {
 	u64 u;
-	struct cavm_npc_af_pkindx_cpi_defx_s {
+	struct npc_af_pkindx_cpi_defx_s {
 		u64 cpi_base                         : 10;
 		u64 reserved_10_11                   : 2;
 		u64 add_shift                        : 3;
@@ -1595,14 +1923,14 @@ union cavm_npc_af_pkindx_cpi_defx {
 		u64 reserved_59_62                   : 4;
 		u64 ena                              : 1;
 	} s;
-	/* struct cavm_npc_af_pkindx_cpi_defx_s cn; */
+	/* struct npc_af_pkindx_cpi_defx_s cn; */
 };
 
-static inline u64 CAVM_NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+static inline u64 NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+static inline u64 NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
 {
 	return 0x80020 + 0x40 * a + 8 * b;
 }
 
-#endif /* __CAVM_CSRS_NPC_H__ */
+#endif /* __CSRS_NPC_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-rvu.h b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
similarity index 56%
rename from drivers/net/octeontx2/cavm-csrs-rvu.h
rename to arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
index 0555e9c1a3..df64199350 100644
--- a/drivers/net/octeontx2/cavm-csrs-rvu.h
+++ b/arch/arm/include/asm/arch-octeontx2/csrs/csrs-rvu.h
@@ -1,18 +1,17 @@
-#ifndef __CAVM_CSRS_RVU_H__
-#define __CAVM_CSRS_RVU_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+#ifndef __CSRS_RVU_H__
+#define __CSRS_RVU_H__
 
 /**
  * @file
  *
  * Configuration and status register (CSR) address and type definitions for
- * Cavium RVU.
+ * RVU.
  *
  * This file is auto generated.  Do not edit.
  *
@@ -26,11 +25,11 @@
  * internally, and generates GIB messages for it without accessing the
  * MSI-X table region in LLC/DRAM.
  */
-#define CAVM_RVU_AF_INT_VEC_E_GEN (3)
-#define CAVM_RVU_AF_INT_VEC_E_MBOX (4)
-#define CAVM_RVU_AF_INT_VEC_E_PFFLR (1)
-#define CAVM_RVU_AF_INT_VEC_E_PFME (2)
-#define CAVM_RVU_AF_INT_VEC_E_POISON (0)
+#define RVU_AF_INT_VEC_E_GEN (3)
+#define RVU_AF_INT_VEC_E_MBOX (4)
+#define RVU_AF_INT_VEC_E_PFFLR (1)
+#define RVU_AF_INT_VEC_E_PFME (2)
+#define RVU_AF_INT_VEC_E_POISON (0)
 
 /**
  * Enumeration rvu_bar_e
@@ -38,11 +37,14 @@
  * RVU Base Address Register Enumeration Enumerates the base address
  * registers. Internal: For documentation only.
  */
-#define CAVM_RVU_BAR_E_RVU_PFX_BAR0(a) (0x840000000000ll + 0x1000000000ll * (a))
-#define CAVM_RVU_BAR_E_RVU_PFX_BAR0_SIZE 0x10000000ull
-#define CAVM_RVU_BAR_E_RVU_PFX_FUNCX_BAR2(a, b)	\
+#define RVU_BAR_E_RVU_PFX_BAR0(a) (0x840000000000ll + 0x1000000000ll * (a))
+#define RVU_BAR_E_RVU_PFX_BAR0_SIZE 0x10000000ull
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR2(a, b)	\
 	(0x840200000000ll + 0x1000000000ll * (a) + 0x2000000ll * (b))
-#define CAVM_RVU_BAR_E_RVU_PFX_FUNCX_BAR2_SIZE 0x100000ull
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR2_SIZE 0x100000ull
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR4(a, b)	\
+	(0x840400000000ll + 0x1000000000ll * (a) + 0x2000000ll * (b))
+#define RVU_BAR_E_RVU_PFX_FUNCX_BAR4_SIZE 0x10000ull
 
 /**
  * Enumeration rvu_block_addr_e
@@ -53,18 +55,18 @@
  * Software can read RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[IMP] to discover
  * which blocks are implemented and enabled.
  */
-#define CAVM_RVU_BLOCK_ADDR_E_CPTX(a) (0xa + (a))
-#define CAVM_RVU_BLOCK_ADDR_E_LMT (1)
-#define CAVM_RVU_BLOCK_ADDR_E_NDCX(a) (0xc + (a))
-#define CAVM_RVU_BLOCK_ADDR_E_NIXX(a) (4 + (a))
-#define CAVM_RVU_BLOCK_ADDR_E_NPA (3)
-#define CAVM_RVU_BLOCK_ADDR_E_NPC (6)
-#define CAVM_RVU_BLOCK_ADDR_E_RX(a) (0 + (a))
-#define CAVM_RVU_BLOCK_ADDR_E_REEX(a) (0x14 + (a))
-#define CAVM_RVU_BLOCK_ADDR_E_RVUM (0)
-#define CAVM_RVU_BLOCK_ADDR_E_SSO (7)
-#define CAVM_RVU_BLOCK_ADDR_E_SSOW (8)
-#define CAVM_RVU_BLOCK_ADDR_E_TIM (9)
+#define RVU_BLOCK_ADDR_E_CPTX(a) (0xa + (a))
+#define RVU_BLOCK_ADDR_E_LMT (1)
+#define RVU_BLOCK_ADDR_E_NDCX(a) (0xc + (a))
+#define RVU_BLOCK_ADDR_E_NIXX(a) (4 + (a))
+#define RVU_BLOCK_ADDR_E_NPA (3)
+#define RVU_BLOCK_ADDR_E_NPC (6)
+#define RVU_BLOCK_ADDR_E_RX(a) (0 + (a))
+#define RVU_BLOCK_ADDR_E_REEX(a) (0x14 + (a))
+#define RVU_BLOCK_ADDR_E_RVUM (0)
+#define RVU_BLOCK_ADDR_E_SSO (7)
+#define RVU_BLOCK_ADDR_E_SSOW (8)
+#define RVU_BLOCK_ADDR_E_TIM (9)
 
 /**
  * Enumeration rvu_block_type_e
@@ -72,20 +74,20 @@
  * RVU Block Type Enumeration Enumerates values of
  * RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[BTYPE].
  */
-#define CAVM_RVU_BLOCK_TYPE_E_CPT (9)
-#define CAVM_RVU_BLOCK_TYPE_E_DDF (0xb)
-#define CAVM_RVU_BLOCK_TYPE_E_LMT (2)
-#define CAVM_RVU_BLOCK_TYPE_E_NDC (0xa)
-#define CAVM_RVU_BLOCK_TYPE_E_NIX (3)
-#define CAVM_RVU_BLOCK_TYPE_E_NPA (4)
-#define CAVM_RVU_BLOCK_TYPE_E_NPC (5)
-#define CAVM_RVU_BLOCK_TYPE_E_RAD (0xd)
-#define CAVM_RVU_BLOCK_TYPE_E_REE (0xe)
-#define CAVM_RVU_BLOCK_TYPE_E_RVUM (0)
-#define CAVM_RVU_BLOCK_TYPE_E_SSO (6)
-#define CAVM_RVU_BLOCK_TYPE_E_SSOW (7)
-#define CAVM_RVU_BLOCK_TYPE_E_TIM (8)
-#define CAVM_RVU_BLOCK_TYPE_E_ZIP (0xc)
+#define RVU_BLOCK_TYPE_E_CPT (9)
+#define RVU_BLOCK_TYPE_E_DDF (0xb)
+#define RVU_BLOCK_TYPE_E_LMT (2)
+#define RVU_BLOCK_TYPE_E_NDC (0xa)
+#define RVU_BLOCK_TYPE_E_NIX (3)
+#define RVU_BLOCK_TYPE_E_NPA (4)
+#define RVU_BLOCK_TYPE_E_NPC (5)
+#define RVU_BLOCK_TYPE_E_RAD (0xd)
+#define RVU_BLOCK_TYPE_E_REE (0xe)
+#define RVU_BLOCK_TYPE_E_RVUM (0)
+#define RVU_BLOCK_TYPE_E_SSO (6)
+#define RVU_BLOCK_TYPE_E_SSOW (7)
+#define RVU_BLOCK_TYPE_E_TIM (8)
+#define RVU_BLOCK_TYPE_E_ZIP (0xc)
 
 /**
  * Enumeration rvu_bus_lf_e
@@ -93,7 +95,7 @@
  * INTERNAL: RVU Bus LF Range Enumeration  Enumerates the LF range for
  * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
-#define CAVM_RVU_BUS_LF_E_RVU_BUS_LFX(a) (0 + 0x2000000 * (a))
+#define RVU_BUS_LF_E_RVU_BUS_LFX(a) (0 + 0x2000000 * (a))
 
 /**
  * Enumeration rvu_bus_lf_slot_e
@@ -102,7 +104,7 @@
  * Slot range for the RVU bus. Internal: This is an enum used in csr3
  * virtual equations.
  */
-#define CAVM_RVU_BUS_LF_SLOT_E_RVU_BUS_LFX_SLOTX(a, b)	\
+#define RVU_BUS_LF_SLOT_E_RVU_BUS_LFX_SLOTX(a, b)	\
 	(0 + 0x2000000 * (a) + 0x1000 * (b))
 
 /**
@@ -111,7 +113,7 @@
  * INTERNAL: RVU Bus PF Range Enumeration  Enumerates the PF range for
  * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
-#define CAVM_RVU_BUS_PF_E_RVU_BUS_PFX(a) (0ll + 0x1000000000ll * (a))
+#define RVU_BUS_PF_E_RVU_BUS_PFX(a) (0ll + 0x1000000000ll * (a))
 
 /**
  * Enumeration rvu_bus_pfvf_e
@@ -120,8 +122,8 @@
  * ranges for the RVU bus. Internal: This is an enum used in csr3 virtual
  * equations.
  */
-#define CAVM_RVU_BUS_PFVF_E_RVU_BUS_PFX(a) (0 + 0x2000000 * (a))
-#define CAVM_RVU_BUS_PFVF_E_RVU_BUS_VFX(a) (0 + 0x2000000 * (a))
+#define RVU_BUS_PFVF_E_RVU_BUS_PFX(a) (0 + 0x2000000 * (a))
+#define RVU_BUS_PFVF_E_RVU_BUS_VFX(a) (0 + 0x2000000 * (a))
 
 /**
  * Enumeration rvu_busbar_e
@@ -130,8 +132,8 @@
  * address region for the RVU bus. Internal: This is an enum used in csr3
  * virtual equations.
  */
-#define CAVM_RVU_BUSBAR_E_RVU_BUSBAR0 (0)
-#define CAVM_RVU_BUSBAR_E_RVU_BUSBAR2 (0x200000000ll)
+#define RVU_BUSBAR_E_RVU_BUSBAR0 (0)
+#define RVU_BUSBAR_E_RVU_BUSBAR2 (0x200000000ll)
 
 /**
  * Enumeration rvu_busdid_e
@@ -139,7 +141,7 @@
  * INTERNAL: RVU Bus DID Enumeration  Enumerates the DID offset for the
  * RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
-#define CAVM_RVU_BUSDID_E_RVU_BUSDID (0x840000000000ll)
+#define RVU_BUSDID_E_RVU_BUSDID (0x840000000000ll)
 
 /**
  * Enumeration rvu_pf_int_vec_e
@@ -147,10 +149,10 @@
  * RVU PF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
  * vectors.
  */
-#define CAVM_RVU_PF_INT_VEC_E_AFPF_MBOX (6)
-#define CAVM_RVU_PF_INT_VEC_E_VFFLRX(a) (0 + (a))
-#define CAVM_RVU_PF_INT_VEC_E_VFMEX(a) (2 + (a))
-#define CAVM_RVU_PF_INT_VEC_E_VFPF_MBOXX(a) (4 + (a))
+#define RVU_PF_INT_VEC_E_AFPF_MBOX (6)
+#define RVU_PF_INT_VEC_E_VFFLRX(a) (0 + (a))
+#define RVU_PF_INT_VEC_E_VFMEX(a) (2 + (a))
+#define RVU_PF_INT_VEC_E_VFPF_MBOXX(a) (4 + (a))
 
 /**
  * Enumeration rvu_vf_int_vec_e
@@ -158,7 +160,7 @@
  * RVU VF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
  * vectors.
  */
-#define CAVM_RVU_VF_INT_VEC_E_MBOX (0)
+#define RVU_VF_INT_VEC_E_MBOX (0)
 
 /**
  * Structure rvu_af_addr_s
@@ -168,14 +170,14 @@
  * registers may be accessed by all RVU PFs whose
  * RVU_PRIV_PF()_CFG[AF_ENA] bit is set.
  */
-union cavm_rvu_af_addr_s {
+union rvu_af_addr_s {
 	u64 u;
-	struct cavm_rvu_af_addr_s_s {
+	struct rvu_af_addr_s_s {
 		u64 addr                             : 28;
 		u64 block                            : 5;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_rvu_af_addr_s_s cn; */
+	/* struct rvu_af_addr_s_s cn; */
 };
 
 /**
@@ -184,15 +186,15 @@ union cavm_rvu_af_addr_s {
  * RVU Function-unique Address Structure Address format for accessing
  * function-unique registers in RVU PF/FUNC BAR2.
  */
-union cavm_rvu_func_addr_s {
+union rvu_func_addr_s {
 	u32 u;
-	struct cavm_rvu_func_addr_s_s {
+	struct rvu_func_addr_s_s {
 		u32 addr                             : 12;
 		u32 lf_slot                          : 8;
 		u32 block                            : 5;
 		u32 reserved_25_31                   : 7;
 	} s;
-	/* struct cavm_rvu_func_addr_s_s cn; */
+	/* struct rvu_func_addr_s_s cn; */
 };
 
 /**
@@ -201,16 +203,16 @@ union cavm_rvu_func_addr_s {
  * RVU MSI-X Vector Structure Format of entries in the RVU MSI-X table
  * region in LLC/DRAM. See RVU_PRIV_PF()_MSIX_CFG.
  */
-union cavm_rvu_msix_vec_s {
+union rvu_msix_vec_s {
 	u64 u[2];
-	struct cavm_rvu_msix_vec_s_s {
+	struct rvu_msix_vec_s_s {
 		u64 addr                             : 64;
 		u64 data                             : 32;
 		u64 mask                             : 1;
 		u64 pend                             : 1;
 		u64 reserved_98_127                  : 30;
 	} s;
-	/* struct cavm_rvu_msix_vec_s_s cn; */
+	/* struct rvu_msix_vec_s_s cn; */
 };
 
 /**
@@ -222,14 +224,14 @@ union cavm_rvu_msix_vec_s {
  * identification on inter-coprocessor hardware interfaces (NPA, SSO,
  * CPT, ...).
  */
-union cavm_rvu_pf_func_s {
+union rvu_pf_func_s {
 	u32 u;
-	struct cavm_rvu_pf_func_s_s {
+	struct rvu_pf_func_s_s {
 		u32 func                             : 10;
 		u32 pf                               : 6;
 		u32 reserved_16_31                   : 16;
 	} s;
-	/* struct cavm_rvu_pf_func_s_s cn; */
+	/* struct rvu_pf_func_s_s cn; */
 };
 
 /**
@@ -237,17 +239,17 @@ union cavm_rvu_pf_func_s {
  *
  * RVU Admin Function AF/PF Mailbox Registers
  */
-union cavm_rvu_af_afpfx_mboxx {
+union rvu_af_afpfx_mboxx {
 	u64 u;
-	struct cavm_rvu_af_afpfx_mboxx_s {
+	struct rvu_af_afpfx_mboxx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_rvu_af_afpfx_mboxx_s cn; */
+	/* struct rvu_af_afpfx_mboxx_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+static inline u64 RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+static inline u64 RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
 {
 	return 0x2000 + 0x10 * a + 8 * b;
 }
@@ -260,17 +262,17 @@ static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
  * RVU_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
  * bug33464.
  */
-union cavm_rvu_af_bar2_aliasx {
+union rvu_af_bar2_aliasx {
 	u64 u;
-	struct cavm_rvu_af_bar2_aliasx_s {
+	struct rvu_af_bar2_aliasx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_rvu_af_bar2_aliasx_s cn; */
+	/* struct rvu_af_bar2_aliasx_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
+static inline u64 RVU_AF_BAR2_ALIASX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
+static inline u64 RVU_AF_BAR2_ALIASX(u64 a)
 {
 	return 0x9100000 + 8 * a;
 }
@@ -282,19 +284,19 @@ static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
  * configures BAR2 accesses from the RVU_AF_BAR2_ALIAS() registers in
  * BAR0. Internal: Not implemented. Placeholder for bug33464.
  */
-union cavm_rvu_af_bar2_sel {
+union rvu_af_bar2_sel {
 	u64 u;
-	struct cavm_rvu_af_bar2_sel_s {
+	struct rvu_af_bar2_sel_s {
 		u64 alias_pf_func                    : 16;
 		u64 alias_ena                        : 1;
 		u64 reserved_17_63                   : 47;
 	} s;
-	/* struct cavm_rvu_af_bar2_sel_s cn; */
+	/* struct rvu_af_bar2_sel_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_BAR2_SEL(void)
+static inline u64 RVU_AF_BAR2_SEL(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_BAR2_SEL(void)
+static inline u64 RVU_AF_BAR2_SEL(void)
 {
 	return 0x9000000;
 }
@@ -304,19 +306,19 @@ static inline u64 CAVM_RVU_AF_BAR2_SEL(void)
  *
  * RVU Master Admin Function Block Reset Register
  */
-union cavm_rvu_af_blk_rst {
+union rvu_af_blk_rst {
 	u64 u;
-	struct cavm_rvu_af_blk_rst_s {
+	struct rvu_af_blk_rst_s {
 		u64 rst                              : 1;
 		u64 reserved_1_62                    : 62;
 		u64 busy                             : 1;
 	} s;
-	/* struct cavm_rvu_af_blk_rst_s cn; */
+	/* struct rvu_af_blk_rst_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_BLK_RST(void)
+static inline u64 RVU_AF_BLK_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_BLK_RST(void)
+static inline u64 RVU_AF_BLK_RST(void)
 {
 	return 0x30;
 }
@@ -326,21 +328,21 @@ static inline u64 CAVM_RVU_AF_BLK_RST(void)
  *
  * INTERNAL: RVUM Backpressure Test Registers
  */
-union cavm_rvu_af_bp_test {
+union rvu_af_bp_test {
 	u64 u;
-	struct cavm_rvu_af_bp_test_s {
+	struct rvu_af_bp_test_s {
 		u64 lfsr_freq                        : 12;
 		u64 reserved_12_15                   : 4;
 		u64 bp_cfg                           : 16;
 		u64 enable                           : 8;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_rvu_af_bp_test_s cn; */
+	/* struct rvu_af_bp_test_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_BP_TEST(void)
+static inline u64 RVU_AF_BP_TEST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_BP_TEST(void)
+static inline u64 RVU_AF_BP_TEST(void)
 {
 	return 0x4000;
 }
@@ -350,18 +352,18 @@ static inline u64 CAVM_RVU_AF_BP_TEST(void)
  *
  * INTERNAL: RVU Admin Function ECO Register
  */
-union cavm_rvu_af_eco {
+union rvu_af_eco {
 	u64 u;
-	struct cavm_rvu_af_eco_s {
+	struct rvu_af_eco_s {
 		u64 eco_rw                           : 32;
 		u64 reserved_32_63                   : 32;
 	} s;
-	/* struct cavm_rvu_af_eco_s cn; */
+	/* struct rvu_af_eco_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_ECO(void)
+static inline u64 RVU_AF_ECO(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_ECO(void)
+static inline u64 RVU_AF_ECO(void)
 {
 	return 0x20;
 }
@@ -372,19 +374,27 @@ static inline u64 CAVM_RVU_AF_ECO(void)
  * RVU Admin Function General Interrupt Register This register contains
  * General interrupt summary bits.
  */
-union cavm_rvu_af_gen_int {
+union rvu_af_gen_int {
 	u64 u;
-	struct cavm_rvu_af_gen_int_s {
+	struct rvu_af_gen_int_s {
 		u64 unmapped                         : 1;
 		u64 msix_fault                       : 1;
-		u64 reserved_2_63                    : 62;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_rvu_af_gen_int_s cn; */
+	struct rvu_af_gen_int_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_s cn98xx; */
+	/* struct rvu_af_gen_int_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_GEN_INT(void)
+static inline u64 RVU_AF_GEN_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_GEN_INT(void)
+static inline u64 RVU_AF_GEN_INT(void)
 {
 	return 0x120;
 }
@@ -395,19 +405,27 @@ static inline u64 CAVM_RVU_AF_GEN_INT(void)
  * RVU Admin Function General Interrupt Enable Clear Register This
  * register clears interrupt enable bits.
  */
-union cavm_rvu_af_gen_int_ena_w1c {
+union rvu_af_gen_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_af_gen_int_ena_w1c_s {
+	struct rvu_af_gen_int_ena_w1c_s {
 		u64 unmapped                         : 1;
 		u64 msix_fault                       : 1;
-		u64 reserved_2_63                    : 62;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_rvu_af_gen_int_ena_w1c_s cn; */
+	struct rvu_af_gen_int_ena_w1c_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_gen_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_ena_w1c_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
+static inline u64 RVU_AF_GEN_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
+static inline u64 RVU_AF_GEN_INT_ENA_W1C(void)
 {
 	return 0x138;
 }
@@ -418,19 +436,27 @@ static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
  * RVU Admin Function General Interrupt Enable Set Register This register
  * sets interrupt enable bits.
  */
-union cavm_rvu_af_gen_int_ena_w1s {
+union rvu_af_gen_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_af_gen_int_ena_w1s_s {
+	struct rvu_af_gen_int_ena_w1s_s {
 		u64 unmapped                         : 1;
 		u64 msix_fault                       : 1;
-		u64 reserved_2_63                    : 62;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_rvu_af_gen_int_ena_w1s_s cn; */
+	struct rvu_af_gen_int_ena_w1s_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_gen_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_ena_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
+static inline u64 RVU_AF_GEN_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
+static inline u64 RVU_AF_GEN_INT_ENA_W1S(void)
 {
 	return 0x130;
 }
@@ -441,19 +467,27 @@ static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
  * RVU Admin Function General Interrupt Set Register This register sets
  * interrupt bits.
  */
-union cavm_rvu_af_gen_int_w1s {
+union rvu_af_gen_int_w1s {
 	u64 u;
-	struct cavm_rvu_af_gen_int_w1s_s {
+	struct rvu_af_gen_int_w1s_s {
 		u64 unmapped                         : 1;
 		u64 msix_fault                       : 1;
-		u64 reserved_2_63                    : 62;
+		u64 bar4_mem_fault                   : 1;
+		u64 reserved_3_63                    : 61;
 	} s;
-	/* struct cavm_rvu_af_gen_int_w1s_s cn; */
+	struct rvu_af_gen_int_w1s_cn96xx {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} cn96xx;
+	/* struct rvu_af_gen_int_w1s_s cn98xx; */
+	/* struct rvu_af_gen_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_gen_int_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_GEN_INT_W1S(void)
+static inline u64 RVU_AF_GEN_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_GEN_INT_W1S(void)
+static inline u64 RVU_AF_GEN_INT_W1S(void)
 {
 	return 0x128;
 }
@@ -463,20 +497,20 @@ static inline u64 CAVM_RVU_AF_GEN_INT_W1S(void)
  *
  * RVU Admin Function Hardware VF Reset Register
  */
-union cavm_rvu_af_hwvf_rst {
+union rvu_af_hwvf_rst {
 	u64 u;
-	struct cavm_rvu_af_hwvf_rst_s {
+	struct rvu_af_hwvf_rst_s {
 		u64 hwvf                             : 8;
 		u64 reserved_8_11                    : 4;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
 	} s;
-	/* struct cavm_rvu_af_hwvf_rst_s cn; */
+	/* struct rvu_af_hwvf_rst_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_HWVF_RST(void)
+static inline u64 RVU_AF_HWVF_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_HWVF_RST(void)
+static inline u64 RVU_AF_HWVF_RST(void)
 {
 	return 0x2850;
 }
@@ -486,40 +520,61 @@ static inline u64 CAVM_RVU_AF_HWVF_RST(void)
  *
  * RVU Admin Function MSI-X Table Region Base-Address Register
  */
-union cavm_rvu_af_msixtr_base {
+union rvu_af_msixtr_base {
 	u64 u;
-	struct cavm_rvu_af_msixtr_base_s {
+	struct rvu_af_msixtr_base_s {
 		u64 reserved_0_6                     : 7;
 		u64 addr                             : 46;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_rvu_af_msixtr_base_s cn; */
+	/* struct rvu_af_msixtr_base_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_MSIXTR_BASE(void)
+static inline u64 RVU_AF_MSIXTR_BASE(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_MSIXTR_BASE(void)
+static inline u64 RVU_AF_MSIXTR_BASE(void)
 {
 	return 0x10;
 }
 
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf#_vf_bar4_addr
+ *
+ * RVU Admin Function PF/VF BAR4 Address Registers
+ */
+union rvu_af_pfx_vf_bar4_addr {
+	u64 u;
+	struct rvu_af_pfx_vf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct rvu_af_pfx_vf_bar4_addr_s cn; */
+};
+
+static inline u64 RVU_AF_PFX_VF_BAR4_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_AF_PFX_VF_BAR4_ADDR(u64 a)
+{
+	return 0x1000 + 0x10 * a;
+}
+
 /**
  * Register (RVU_PF_BAR0) rvu_af_pf_bar4_addr
  *
  * RVU Admin Function PF BAR4 Address Registers
  */
-union cavm_rvu_af_pf_bar4_addr {
+union rvu_af_pf_bar4_addr {
 	u64 u;
-	struct cavm_rvu_af_pf_bar4_addr_s {
+	struct rvu_af_pf_bar4_addr_s {
 		u64 reserved_0_15                    : 16;
 		u64 addr                             : 48;
 	} s;
-	/* struct cavm_rvu_af_pf_bar4_addr_s cn; */
+	/* struct rvu_af_pf_bar4_addr_s cn; */
 };
 
-static inline u64 CAVM_RVU_AF_PF_BAR4_ADDR(void)
+static inline u64 RVU_AF_PF_BAR4_ADDR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PF_BAR4_ADDR(void)
+static inline u64 RVU_AF_PF_BAR4_ADDR(void)
 {
 	return 0x40;
 }
@@ -529,20 +584,28 @@ static inline u64 CAVM_RVU_AF_PF_BAR4_ADDR(void)
  *
  * RVU Admin Function PF Reset Register
  */
-union cavm_rvu_af_pf_rst {
+union rvu_af_pf_rst {
 	u64 u;
-	struct cavm_rvu_af_pf_rst_s {
+	struct rvu_af_pf_rst_s {
+		u64 pf                               : 5;
+		u64 reserved_5_11                    : 7;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	struct rvu_af_pf_rst_cn96xx {
 		u64 pf                               : 4;
 		u64 reserved_4_11                    : 8;
 		u64 exec                             : 1;
 		u64 reserved_13_63                   : 51;
-	} s;
-	/* struct cavm_rvu_af_pf_rst_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pf_rst_s cn98xx; */
+	/* struct rvu_af_pf_rst_cn96xx cnf95xx; */
+	/* struct rvu_af_pf_rst_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PF_RST(void)
+static inline u64 RVU_AF_PF_RST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PF_RST(void)
+static inline u64 RVU_AF_PF_RST(void)
 {
 	return 0x2840;
 }
@@ -552,18 +615,24 @@ static inline u64 CAVM_RVU_AF_PF_RST(void)
  *
  * RVU Admin Function PF to AF Mailbox Interrupt Registers
  */
-union cavm_rvu_af_pfaf_mbox_int {
+union rvu_af_pfaf_mbox_int {
 	u64 u;
-	struct cavm_rvu_af_pfaf_mbox_int_s {
+	struct rvu_af_pfaf_mbox_int_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_cn96xx {
 		u64 mbox                             : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfaf_mbox_int_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT(void)
 {
 	return 0x2880;
 }
@@ -574,18 +643,24 @@ static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT(void)
  * RVU Admin Function PF to AF Mailbox Interrupt Enable Clear Registers
  * This register clears interrupt enable bits.
  */
-union cavm_rvu_af_pfaf_mbox_int_ena_w1c {
+union rvu_af_pfaf_mbox_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_af_pfaf_mbox_int_ena_w1c_s {
+	struct rvu_af_pfaf_mbox_int_ena_w1c_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx {
 		u64 mbox                             : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfaf_mbox_int_ena_w1c_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1c_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
 {
 	return 0x2898;
 }
@@ -596,18 +671,24 @@ static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
  * RVU Admin Function PF to AF Mailbox Interrupt Enable Set Registers
  * This register sets interrupt enable bits.
  */
-union cavm_rvu_af_pfaf_mbox_int_ena_w1s {
+union rvu_af_pfaf_mbox_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfaf_mbox_int_ena_w1s_s {
+	struct rvu_af_pfaf_mbox_int_ena_w1s_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx {
 		u64 mbox                             : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfaf_mbox_int_ena_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_ena_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
 {
 	return 0x2890;
 }
@@ -618,18 +699,24 @@ static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
  * RVU Admin Function PF to AF Mailbox Interrupt Set Registers This
  * register sets interrupt bits.
  */
-union cavm_rvu_af_pfaf_mbox_int_w1s {
+union rvu_af_pfaf_mbox_int_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfaf_mbox_int_w1s_s {
+	struct rvu_af_pfaf_mbox_int_w1s_s {
+		u64 mbox                             : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfaf_mbox_int_w1s_cn96xx {
 		u64 mbox                             : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfaf_mbox_int_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfaf_mbox_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfaf_mbox_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfaf_mbox_int_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_W1S(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_W1S(void)
+static inline u64 RVU_AF_PFAF_MBOX_INT_W1S(void)
 {
 	return 0x2888;
 }
@@ -639,18 +726,24 @@ static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_W1S(void)
  *
  * RVU Admin Function PF Function Level Reset Interrupt Registers
  */
-union cavm_rvu_af_pfflr_int {
+union rvu_af_pfflr_int {
 	u64 u;
-	struct cavm_rvu_af_pfflr_int_s {
+	struct rvu_af_pfflr_int_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_cn96xx {
 		u64 flr                              : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfflr_int_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_s cn98xx; */
+	/* struct rvu_af_pfflr_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
+static inline u64 RVU_AF_PFFLR_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
+static inline u64 RVU_AF_PFFLR_INT(void)
 {
 	return 0x28a0;
 }
@@ -661,18 +754,24 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
  * RVU Admin Function PF Function Level Reset Interrupt Enable Clear
  * Registers This register clears interrupt enable bits.
  */
-union cavm_rvu_af_pfflr_int_ena_w1c {
+union rvu_af_pfflr_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_af_pfflr_int_ena_w1c_s {
+	struct rvu_af_pfflr_int_ena_w1c_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_ena_w1c_cn96xx {
 		u64 flr                              : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfflr_int_ena_w1c_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfflr_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_ena_w1c_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1C(void)
 {
 	return 0x28b8;
 }
@@ -683,18 +782,24 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
  * RVU Admin Function PF Function Level Reset Interrupt Enable Set
  * Registers This register sets interrupt enable bits.
  */
-union cavm_rvu_af_pfflr_int_ena_w1s {
+union rvu_af_pfflr_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfflr_int_ena_w1s_s {
+	struct rvu_af_pfflr_int_ena_w1s_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_ena_w1s_cn96xx {
 		u64 flr                              : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfflr_int_ena_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfflr_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_ena_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFFLR_INT_ENA_W1S(void)
 {
 	return 0x28b0;
 }
@@ -705,18 +810,24 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1S(void)
  * RVU Admin Function PF Function Level Reset Interrupt Set Registers
  * This register sets interrupt bits.
  */
-union cavm_rvu_af_pfflr_int_w1s {
+union rvu_af_pfflr_int_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfflr_int_w1s_s {
+	struct rvu_af_pfflr_int_w1s_s {
+		u64 flr                              : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfflr_int_w1s_cn96xx {
 		u64 flr                              : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfflr_int_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfflr_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfflr_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfflr_int_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFFLR_INT_W1S(void)
+static inline u64 RVU_AF_PFFLR_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFFLR_INT_W1S(void)
+static inline u64 RVU_AF_PFFLR_INT_W1S(void)
 {
 	return 0x28a8;
 }
@@ -726,18 +837,24 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT_W1S(void)
  *
  * RVU Admin Function PF Bus Master Enable Interrupt Registers
  */
-union cavm_rvu_af_pfme_int {
+union rvu_af_pfme_int {
 	u64 u;
-	struct cavm_rvu_af_pfme_int_s {
+	struct rvu_af_pfme_int_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_cn96xx {
 		u64 me                               : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfme_int_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfme_int_s cn98xx; */
+	/* struct rvu_af_pfme_int_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFME_INT(void)
+static inline u64 RVU_AF_PFME_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFME_INT(void)
+static inline u64 RVU_AF_PFME_INT(void)
 {
 	return 0x28c0;
 }
@@ -748,18 +865,24 @@ static inline u64 CAVM_RVU_AF_PFME_INT(void)
  * RVU Admin Function PF Bus Master Enable Interrupt Enable Clear
  * Registers This register clears interrupt enable bits.
  */
-union cavm_rvu_af_pfme_int_ena_w1c {
+union rvu_af_pfme_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_af_pfme_int_ena_w1c_s {
+	struct rvu_af_pfme_int_ena_w1c_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_ena_w1c_cn96xx {
 		u64 me                               : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfme_int_ena_w1c_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfme_int_ena_w1c_s cn98xx; */
+	/* struct rvu_af_pfme_int_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_ena_w1c_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFME_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1C(void)
+static inline u64 RVU_AF_PFME_INT_ENA_W1C(void)
 {
 	return 0x28d8;
 }
@@ -770,18 +893,24 @@ static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1C(void)
  * RVU Admin Function PF Bus Master Enable Interrupt Enable Set Registers
  * This register sets interrupt enable bits.
  */
-union cavm_rvu_af_pfme_int_ena_w1s {
+union rvu_af_pfme_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfme_int_ena_w1s_s {
+	struct rvu_af_pfme_int_ena_w1s_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_ena_w1s_cn96xx {
 		u64 me                               : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfme_int_ena_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfme_int_ena_w1s_s cn98xx; */
+	/* struct rvu_af_pfme_int_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_ena_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFME_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
+static inline u64 RVU_AF_PFME_INT_ENA_W1S(void)
 {
 	return 0x28d0;
 }
@@ -792,18 +921,24 @@ static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
  * RVU Admin Function PF Bus Master Enable Interrupt Set Registers This
  * register sets interrupt bits.
  */
-union cavm_rvu_af_pfme_int_w1s {
+union rvu_af_pfme_int_w1s {
 	u64 u;
-	struct cavm_rvu_af_pfme_int_w1s_s {
+	struct rvu_af_pfme_int_w1s_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_int_w1s_cn96xx {
 		u64 me                               : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfme_int_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfme_int_w1s_s cn98xx; */
+	/* struct rvu_af_pfme_int_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_int_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFME_INT_W1S(void)
+static inline u64 RVU_AF_PFME_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFME_INT_W1S(void)
+static inline u64 RVU_AF_PFME_INT_W1S(void)
 {
 	return 0x28c8;
 }
@@ -813,18 +948,24 @@ static inline u64 CAVM_RVU_AF_PFME_INT_W1S(void)
  *
  * RVU Admin Function PF Bus Master Enable Status Registers
  */
-union cavm_rvu_af_pfme_status {
+union rvu_af_pfme_status {
 	u64 u;
-	struct cavm_rvu_af_pfme_status_s {
+	struct rvu_af_pfme_status_s {
+		u64 me                               : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pfme_status_cn96xx {
 		u64 me                               : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pfme_status_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pfme_status_s cn98xx; */
+	/* struct rvu_af_pfme_status_cn96xx cnf95xx; */
+	/* struct rvu_af_pfme_status_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFME_STATUS(void)
+static inline u64 RVU_AF_PFME_STATUS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFME_STATUS(void)
+static inline u64 RVU_AF_PFME_STATUS(void)
 {
 	return 0x2800;
 }
@@ -834,18 +975,24 @@ static inline u64 CAVM_RVU_AF_PFME_STATUS(void)
  *
  * RVU Admin Function PF Transaction Pending Registers
  */
-union cavm_rvu_af_pftrpend {
+union rvu_af_pftrpend {
 	u64 u;
-	struct cavm_rvu_af_pftrpend_s {
+	struct rvu_af_pftrpend_s {
+		u64 trpend                           : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pftrpend_cn96xx {
 		u64 trpend                           : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pftrpend_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pftrpend_s cn98xx; */
+	/* struct rvu_af_pftrpend_cn96xx cnf95xx; */
+	/* struct rvu_af_pftrpend_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFTRPEND(void)
+static inline u64 RVU_AF_PFTRPEND(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFTRPEND(void)
+static inline u64 RVU_AF_PFTRPEND(void)
 {
 	return 0x2810;
 }
@@ -856,18 +1003,24 @@ static inline u64 CAVM_RVU_AF_PFTRPEND(void)
  * RVU Admin Function PF Transaction Pending Set Registers This register
  * reads or sets bits.
  */
-union cavm_rvu_af_pftrpend_w1s {
+union rvu_af_pftrpend_w1s {
 	u64 u;
-	struct cavm_rvu_af_pftrpend_w1s_s {
+	struct rvu_af_pftrpend_w1s_s {
+		u64 trpend                           : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	struct rvu_af_pftrpend_w1s_cn96xx {
 		u64 trpend                           : 16;
 		u64 reserved_16_63                   : 48;
-	} s;
-	/* struct cavm_rvu_af_pftrpend_w1s_s cn; */
+	} cn96xx;
+	/* struct rvu_af_pftrpend_w1s_s cn98xx; */
+	/* struct rvu_af_pftrpend_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_pftrpend_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
+static inline u64 RVU_AF_PFTRPEND_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
+static inline u64 RVU_AF_PFTRPEND_W1S(void)
 {
 	return 0x2820;
 }
@@ -879,18 +1032,25 @@ static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
  * for delivery of RAS events to the SCP, so should be ignored by OS
  * drivers.
  */
-union cavm_rvu_af_ras {
+union rvu_af_ras {
 	u64 u;
-	struct cavm_rvu_af_ras_s {
+	struct rvu_af_ras_s {
 		u64 msix_poison                      : 1;
-		u64 reserved_1_63                    : 63;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_rvu_af_ras_s cn; */
+	struct rvu_af_ras_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_s cn98xx; */
+	/* struct rvu_af_ras_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_RAS(void)
+static inline u64 RVU_AF_RAS(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_RAS(void)
+static inline u64 RVU_AF_RAS(void)
 {
 	return 0x100;
 }
@@ -901,18 +1061,25 @@ static inline u64 CAVM_RVU_AF_RAS(void)
  * RVU Admin Function RAS Interrupt Enable Clear Register This register
  * clears interrupt enable bits.
  */
-union cavm_rvu_af_ras_ena_w1c {
+union rvu_af_ras_ena_w1c {
 	u64 u;
-	struct cavm_rvu_af_ras_ena_w1c_s {
+	struct rvu_af_ras_ena_w1c_s {
 		u64 msix_poison                      : 1;
-		u64 reserved_1_63                    : 63;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_rvu_af_ras_ena_w1c_s cn; */
+	struct rvu_af_ras_ena_w1c_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_ena_w1c_s cn98xx; */
+	/* struct rvu_af_ras_ena_w1c_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_ena_w1c_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
+static inline u64 RVU_AF_RAS_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
+static inline u64 RVU_AF_RAS_ENA_W1C(void)
 {
 	return 0x118;
 }
@@ -923,18 +1090,25 @@ static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
  * RVU Admin Function RAS Interrupt Enable Set Register This register
  * sets interrupt enable bits.
  */
-union cavm_rvu_af_ras_ena_w1s {
+union rvu_af_ras_ena_w1s {
 	u64 u;
-	struct cavm_rvu_af_ras_ena_w1s_s {
+	struct rvu_af_ras_ena_w1s_s {
 		u64 msix_poison                      : 1;
-		u64 reserved_1_63                    : 63;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_rvu_af_ras_ena_w1s_s cn; */
+	struct rvu_af_ras_ena_w1s_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_ena_w1s_s cn98xx; */
+	/* struct rvu_af_ras_ena_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_ena_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
+static inline u64 RVU_AF_RAS_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
+static inline u64 RVU_AF_RAS_ENA_W1S(void)
 {
 	return 0x110;
 }
@@ -945,18 +1119,25 @@ static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
  * RVU Admin Function RAS Interrupt Set Register This register sets
  * interrupt bits.
  */
-union cavm_rvu_af_ras_w1s {
+union rvu_af_ras_w1s {
 	u64 u;
-	struct cavm_rvu_af_ras_w1s_s {
+	struct rvu_af_ras_w1s_s {
 		u64 msix_poison                      : 1;
-		u64 reserved_1_63                    : 63;
+		u64 bar4_mem_poison                  : 1;
+		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_rvu_af_ras_w1s_s cn; */
+	struct rvu_af_ras_w1s_cn96xx {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} cn96xx;
+	/* struct rvu_af_ras_w1s_s cn98xx; */
+	/* struct rvu_af_ras_w1s_cn96xx cnf95xx; */
+	/* struct rvu_af_ras_w1s_cn96xx loki; */
 };
 
-static inline u64 CAVM_RVU_AF_RAS_W1S(void)
+static inline u64 RVU_AF_RAS_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_AF_RAS_W1S(void)
+static inline u64 RVU_AF_RAS_W1S(void)
 {
 	return 0x108;
 }
@@ -968,9 +1149,9 @@ static inline u64 CAVM_RVU_AF_RAS_W1S(void)
  * driver to discover block resources that are provisioned to its PF. The
  * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
  */
-union cavm_rvu_pf_block_addrx_disc {
+union rvu_pf_block_addrx_disc {
 	u64 u;
-	struct cavm_rvu_pf_block_addrx_disc_s {
+	struct rvu_pf_block_addrx_disc_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_10                    : 2;
 		u64 imp                              : 1;
@@ -978,12 +1159,12 @@ union cavm_rvu_pf_block_addrx_disc {
 		u64 btype                            : 8;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_rvu_pf_block_addrx_disc_s cn; */
+	/* struct rvu_pf_block_addrx_disc_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+static inline u64 RVU_PF_BLOCK_ADDRX_DISC(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+static inline u64 RVU_PF_BLOCK_ADDRX_DISC(u64 a)
 {
 	return 0x200 + 8 * a;
 }
@@ -993,18 +1174,18 @@ static inline u64 CAVM_RVU_PF_BLOCK_ADDRX_DISC(u64 a)
  *
  * RVU PF Interrupt Registers
  */
-union cavm_rvu_pf_int {
+union rvu_pf_int {
 	u64 u;
-	struct cavm_rvu_pf_int_s {
+	struct rvu_pf_int_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_pf_int_s cn; */
+	/* struct rvu_pf_int_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_INT(void)
+static inline u64 RVU_PF_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_INT(void)
+static inline u64 RVU_PF_INT(void)
 {
 	return 0xc20;
 }
@@ -1015,18 +1196,18 @@ static inline u64 CAVM_RVU_PF_INT(void)
  * RVU PF Interrupt Enable Clear Register This register clears interrupt
  * enable bits.
  */
-union cavm_rvu_pf_int_ena_w1c {
+union rvu_pf_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_pf_int_ena_w1c_s {
+	struct rvu_pf_int_ena_w1c_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_pf_int_ena_w1c_s cn; */
+	/* struct rvu_pf_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
+static inline u64 RVU_PF_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
+static inline u64 RVU_PF_INT_ENA_W1C(void)
 {
 	return 0xc38;
 }
@@ -1037,18 +1218,18 @@ static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
  * RVU PF Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_rvu_pf_int_ena_w1s {
+union rvu_pf_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_pf_int_ena_w1s_s {
+	struct rvu_pf_int_ena_w1s_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_pf_int_ena_w1s_s cn; */
+	/* struct rvu_pf_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
+static inline u64 RVU_PF_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
+static inline u64 RVU_PF_INT_ENA_W1S(void)
 {
 	return 0xc30;
 }
@@ -1058,18 +1239,18 @@ static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
  *
  * RVU PF Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_rvu_pf_int_w1s {
+union rvu_pf_int_w1s {
 	u64 u;
-	struct cavm_rvu_pf_int_w1s_s {
+	struct rvu_pf_int_w1s_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_pf_int_w1s_s cn; */
+	/* struct rvu_pf_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_INT_W1S(void)
+static inline u64 RVU_PF_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_INT_W1S(void)
+static inline u64 RVU_PF_INT_W1S(void)
 {
 	return 0xc28;
 }
@@ -1080,17 +1261,17 @@ static inline u64 CAVM_RVU_PF_INT_W1S(void)
  * RVU PF MSI-X Pending-Bit-Array Registers This register is the MSI-X PF
  * PBA table.
  */
-union cavm_rvu_pf_msix_pbax {
+union rvu_pf_msix_pbax {
 	u64 u;
-	struct cavm_rvu_pf_msix_pbax_s {
+	struct rvu_pf_msix_pbax_s {
 		u64 pend                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_msix_pbax_s cn; */
+	/* struct rvu_pf_msix_pbax_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
+static inline u64 RVU_PF_MSIX_PBAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
+static inline u64 RVU_PF_MSIX_PBAX(u64 a)
 {
 	return 0xf0000 + 8 * a;
 }
@@ -1106,20 +1287,20 @@ static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
  * writes have completed before interrupts are generated to the modified
  * vectors.
  */
-union cavm_rvu_pf_msix_vecx_addr {
+union rvu_pf_msix_vecx_addr {
 	u64 u;
-	struct cavm_rvu_pf_msix_vecx_addr_s {
+	struct rvu_pf_msix_vecx_addr_s {
 		u64 secvec                           : 1;
 		u64 reserved_1                       : 1;
 		u64 addr                             : 51;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_rvu_pf_msix_vecx_addr_s cn; */
+	/* struct rvu_pf_msix_vecx_addr_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
+static inline u64 RVU_PF_MSIX_VECX_ADDR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
+static inline u64 RVU_PF_MSIX_VECX_ADDR(u64 a)
 {
 	return 0x80000 + 0x10 * a;
 }
@@ -1130,19 +1311,19 @@ static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
  * RVU PF MSI-X Vector-Table Control and Data Registers These registers
  * and RVU_PF_MSIX_VEC()_ADDR form the PF MSI-X vector table.
  */
-union cavm_rvu_pf_msix_vecx_ctl {
+union rvu_pf_msix_vecx_ctl {
 	u64 u;
-	struct cavm_rvu_pf_msix_vecx_ctl_s {
+	struct rvu_pf_msix_vecx_ctl_s {
 		u64 data                             : 32;
 		u64 mask                             : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_rvu_pf_msix_vecx_ctl_s cn; */
+	/* struct rvu_pf_msix_vecx_ctl_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_MSIX_VECX_CTL(u64 a)
+static inline u64 RVU_PF_MSIX_VECX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_MSIX_VECX_CTL(u64 a)
+static inline u64 RVU_PF_MSIX_VECX_CTL(u64 a)
 {
 	return 0x80008 + 0x10 * a;
 }
@@ -1152,17 +1333,17 @@ static inline u64 CAVM_RVU_PF_MSIX_VECX_CTL(u64 a)
  *
  * RVU PF/AF Mailbox Registers
  */
-union cavm_rvu_pf_pfaf_mboxx {
+union rvu_pf_pfaf_mboxx {
 	u64 u;
-	struct cavm_rvu_pf_pfaf_mboxx_s {
+	struct rvu_pf_pfaf_mboxx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_pfaf_mboxx_s cn; */
+	/* struct rvu_pf_pfaf_mboxx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_PFAF_MBOXX(u64 a)
+static inline u64 RVU_PF_PFAF_MBOXX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_PFAF_MBOXX(u64 a)
+static inline u64 RVU_PF_PFAF_MBOXX(u64 a)
 {
 	return 0xc00 + 8 * a;
 }
@@ -1172,17 +1353,17 @@ static inline u64 CAVM_RVU_PF_PFAF_MBOXX(u64 a)
  *
  * RVU PF/VF Mailbox Registers
  */
-union cavm_rvu_pf_vfx_pfvf_mboxx {
+union rvu_pf_vfx_pfvf_mboxx {
 	u64 u;
-	struct cavm_rvu_pf_vfx_pfvf_mboxx_s {
+	struct rvu_pf_vfx_pfvf_mboxx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfx_pfvf_mboxx_s cn; */
+	/* struct rvu_pf_vfx_pfvf_mboxx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+static inline u64 RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+static inline u64 RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
 {
 	return 0 + 0x1000 * a + 8 * b;
 }
@@ -1192,18 +1373,18 @@ static inline u64 CAVM_RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
  *
  * RVU PF VF BAR4 Address Registers
  */
-union cavm_rvu_pf_vf_bar4_addr {
+union rvu_pf_vf_bar4_addr {
 	u64 u;
-	struct cavm_rvu_pf_vf_bar4_addr_s {
+	struct rvu_pf_vf_bar4_addr_s {
 		u64 reserved_0_15                    : 16;
 		u64 addr                             : 48;
 	} s;
-	/* struct cavm_rvu_pf_vf_bar4_addr_s cn; */
+	/* struct rvu_pf_vf_bar4_addr_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VF_BAR4_ADDR(void)
+static inline u64 RVU_PF_VF_BAR4_ADDR(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VF_BAR4_ADDR(void)
+static inline u64 RVU_PF_VF_BAR4_ADDR(void)
 {
 	return 0x10;
 }
@@ -1213,17 +1394,17 @@ static inline u64 CAVM_RVU_PF_VF_BAR4_ADDR(void)
  *
  * RVU PF VF Function Level Reset Interrupt Registers
  */
-union cavm_rvu_pf_vfflr_intx {
+union rvu_pf_vfflr_intx {
 	u64 u;
-	struct cavm_rvu_pf_vfflr_intx_s {
+	struct rvu_pf_vfflr_intx_s {
 		u64 flr                              : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfflr_intx_s cn; */
+	/* struct rvu_pf_vfflr_intx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
+static inline u64 RVU_PF_VFFLR_INTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
+static inline u64 RVU_PF_VFFLR_INTX(u64 a)
 {
 	return 0x900 + 8 * a;
 }
@@ -1234,17 +1415,17 @@ static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
  * RVU PF VF Function Level Reset Interrupt Enable Clear Registers This
  * register clears interrupt enable bits.
  */
-union cavm_rvu_pf_vfflr_int_ena_w1cx {
+union rvu_pf_vfflr_int_ena_w1cx {
 	u64 u;
-	struct cavm_rvu_pf_vfflr_int_ena_w1cx_s {
+	struct rvu_pf_vfflr_int_ena_w1cx_s {
 		u64 flr                              : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfflr_int_ena_w1cx_s cn; */
+	/* struct rvu_pf_vfflr_int_ena_w1cx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
 {
 	return 0x960 + 8 * a;
 }
@@ -1255,17 +1436,17 @@ static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
  * RVU PF VF Function Level Reset Interrupt Enable Set Registers This
  * register sets interrupt enable bits.
  */
-union cavm_rvu_pf_vfflr_int_ena_w1sx {
+union rvu_pf_vfflr_int_ena_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfflr_int_ena_w1sx_s {
+	struct rvu_pf_vfflr_int_ena_w1sx_s {
 		u64 flr                              : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfflr_int_ena_w1sx_s cn; */
+	/* struct rvu_pf_vfflr_int_ena_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
 {
 	return 0x940 + 8 * a;
 }
@@ -1276,17 +1457,17 @@ static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
  * RVU PF VF Function Level Reset Interrupt Set Registers This register
  * sets interrupt bits.
  */
-union cavm_rvu_pf_vfflr_int_w1sx {
+union rvu_pf_vfflr_int_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfflr_int_w1sx_s {
+	struct rvu_pf_vfflr_int_w1sx_s {
 		u64 flr                              : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfflr_int_w1sx_s cn; */
+	/* struct rvu_pf_vfflr_int_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFFLR_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFFLR_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFFLR_INT_W1SX(u64 a)
 {
 	return 0x920 + 8 * a;
 }
@@ -1296,17 +1477,17 @@ static inline u64 CAVM_RVU_PF_VFFLR_INT_W1SX(u64 a)
  *
  * RVU PF VF Bus Master Enable Interrupt Registers
  */
-union cavm_rvu_pf_vfme_intx {
+union rvu_pf_vfme_intx {
 	u64 u;
-	struct cavm_rvu_pf_vfme_intx_s {
+	struct rvu_pf_vfme_intx_s {
 		u64 me                               : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfme_intx_s cn; */
+	/* struct rvu_pf_vfme_intx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
+static inline u64 RVU_PF_VFME_INTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
+static inline u64 RVU_PF_VFME_INTX(u64 a)
 {
 	return 0x980 + 8 * a;
 }
@@ -1317,17 +1498,17 @@ static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
  * RVU PF VF Bus Master Enable Interrupt Enable Clear Registers This
  * register clears interrupt enable bits.
  */
-union cavm_rvu_pf_vfme_int_ena_w1cx {
+union rvu_pf_vfme_int_ena_w1cx {
 	u64 u;
-	struct cavm_rvu_pf_vfme_int_ena_w1cx_s {
+	struct rvu_pf_vfme_int_ena_w1cx_s {
 		u64 me                               : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfme_int_ena_w1cx_s cn; */
+	/* struct rvu_pf_vfme_int_ena_w1cx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFME_INT_ENA_W1CX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFME_INT_ENA_W1CX(u64 a)
 {
 	return 0x9e0 + 8 * a;
 }
@@ -1338,17 +1519,17 @@ static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
  * RVU PF VF Bus Master Enable Interrupt Enable Set Registers This
  * register sets interrupt enable bits.
  */
-union cavm_rvu_pf_vfme_int_ena_w1sx {
+union rvu_pf_vfme_int_ena_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfme_int_ena_w1sx_s {
+	struct rvu_pf_vfme_int_ena_w1sx_s {
 		u64 me                               : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfme_int_ena_w1sx_s cn; */
+	/* struct rvu_pf_vfme_int_ena_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFME_INT_ENA_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFME_INT_ENA_W1SX(u64 a)
 {
 	return 0x9c0 + 8 * a;
 }
@@ -1359,17 +1540,17 @@ static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
  * RVU PF VF Bus Master Enable Interrupt Set Registers This register sets
  * interrupt bits.
  */
-union cavm_rvu_pf_vfme_int_w1sx {
+union rvu_pf_vfme_int_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfme_int_w1sx_s {
+	struct rvu_pf_vfme_int_w1sx_s {
 		u64 me                               : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfme_int_w1sx_s cn; */
+	/* struct rvu_pf_vfme_int_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFME_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFME_INT_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFME_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFME_INT_W1SX(u64 a)
 {
 	return 0x9a0 + 8 * a;
 }
@@ -1379,17 +1560,17 @@ static inline u64 CAVM_RVU_PF_VFME_INT_W1SX(u64 a)
  *
  * RVU PF VF Bus Master Enable Status Registers
  */
-union cavm_rvu_pf_vfme_statusx {
+union rvu_pf_vfme_statusx {
 	u64 u;
-	struct cavm_rvu_pf_vfme_statusx_s {
+	struct rvu_pf_vfme_statusx_s {
 		u64 me                               : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfme_statusx_s cn; */
+	/* struct rvu_pf_vfme_statusx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFME_STATUSX(u64 a)
+static inline u64 RVU_PF_VFME_STATUSX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFME_STATUSX(u64 a)
+static inline u64 RVU_PF_VFME_STATUSX(u64 a)
 {
 	return 0x800 + 8 * a;
 }
@@ -1399,17 +1580,17 @@ static inline u64 CAVM_RVU_PF_VFME_STATUSX(u64 a)
  *
  * RVU VF to PF Mailbox Interrupt Registers
  */
-union cavm_rvu_pf_vfpf_mbox_intx {
+union rvu_pf_vfpf_mbox_intx {
 	u64 u;
-	struct cavm_rvu_pf_vfpf_mbox_intx_s {
+	struct rvu_pf_vfpf_mbox_intx_s {
 		u64 mbox                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfpf_mbox_intx_s cn; */
+	/* struct rvu_pf_vfpf_mbox_intx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INTX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INTX(u64 a)
 {
 	return 0x880 + 8 * a;
 }
@@ -1420,17 +1601,17 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
  * RVU VF to PF Mailbox Interrupt Enable Clear Registers This register
  * clears interrupt enable bits.
  */
-union cavm_rvu_pf_vfpf_mbox_int_ena_w1cx {
+union rvu_pf_vfpf_mbox_int_ena_w1cx {
 	u64 u;
-	struct cavm_rvu_pf_vfpf_mbox_int_ena_w1cx_s {
+	struct rvu_pf_vfpf_mbox_int_ena_w1cx_s {
 		u64 mbox                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfpf_mbox_int_ena_w1cx_s cn; */
+	/* struct rvu_pf_vfpf_mbox_int_ena_w1cx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
 {
 	return 0x8e0 + 8 * a;
 }
@@ -1441,17 +1622,17 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
  * RVU VF to PF Mailbox Interrupt Enable Set Registers This register sets
  * interrupt enable bits.
  */
-union cavm_rvu_pf_vfpf_mbox_int_ena_w1sx {
+union rvu_pf_vfpf_mbox_int_ena_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfpf_mbox_int_ena_w1sx_s {
+	struct rvu_pf_vfpf_mbox_int_ena_w1sx_s {
 		u64 mbox                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfpf_mbox_int_ena_w1sx_s cn; */
+	/* struct rvu_pf_vfpf_mbox_int_ena_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
 {
 	return 0x8c0 + 8 * a;
 }
@@ -1462,17 +1643,17 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
  * RVU VF to PF Mailbox Interrupt Set Registers This register sets
  * interrupt bits.
  */
-union cavm_rvu_pf_vfpf_mbox_int_w1sx {
+union rvu_pf_vfpf_mbox_int_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vfpf_mbox_int_w1sx_s {
+	struct rvu_pf_vfpf_mbox_int_w1sx_s {
 		u64 mbox                             : 64;
 	} s;
-	/* struct cavm_rvu_pf_vfpf_mbox_int_w1sx_s cn; */
+	/* struct rvu_pf_vfpf_mbox_int_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+static inline u64 RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
 {
 	return 0x8a0 + 8 * a;
 }
@@ -1482,17 +1663,17 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
  *
  * RVU PF VF Transaction Pending Registers
  */
-union cavm_rvu_pf_vftrpendx {
+union rvu_pf_vftrpendx {
 	u64 u;
-	struct cavm_rvu_pf_vftrpendx_s {
+	struct rvu_pf_vftrpendx_s {
 		u64 trpend                           : 64;
 	} s;
-	/* struct cavm_rvu_pf_vftrpendx_s cn; */
+	/* struct rvu_pf_vftrpendx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
+static inline u64 RVU_PF_VFTRPENDX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
+static inline u64 RVU_PF_VFTRPENDX(u64 a)
 {
 	return 0x820 + 8 * a;
 }
@@ -1503,17 +1684,17 @@ static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
  * RVU PF VF Transaction Pending Set Registers This register reads or
  * sets bits.
  */
-union cavm_rvu_pf_vftrpend_w1sx {
+union rvu_pf_vftrpend_w1sx {
 	u64 u;
-	struct cavm_rvu_pf_vftrpend_w1sx_s {
+	struct rvu_pf_vftrpend_w1sx_s {
 		u64 trpend                           : 64;
 	} s;
-	/* struct cavm_rvu_pf_vftrpend_w1sx_s cn; */
+	/* struct rvu_pf_vftrpend_w1sx_s cn; */
 };
 
-static inline u64 CAVM_RVU_PF_VFTRPEND_W1SX(u64 a)
+static inline u64 RVU_PF_VFTRPEND_W1SX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PF_VFTRPEND_W1SX(u64 a)
+static inline u64 RVU_PF_VFTRPEND_W1SX(u64 a)
 {
 	return 0x840 + 8 * a;
 }
@@ -1523,17 +1704,17 @@ static inline u64 CAVM_RVU_PF_VFTRPEND_W1SX(u64 a)
  *
  * RVU Active Program Counter Register
  */
-union cavm_rvu_priv_active_pc {
+union rvu_priv_active_pc {
 	u64 u;
-	struct cavm_rvu_priv_active_pc_s {
+	struct rvu_priv_active_pc_s {
 		u64 active_pc                        : 64;
 	} s;
-	/* struct cavm_rvu_priv_active_pc_s cn; */
+	/* struct rvu_priv_active_pc_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
+static inline u64 RVU_PRIV_ACTIVE_PC(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
+static inline u64 RVU_PRIV_ACTIVE_PC(void)
 {
 	return 0x8000030;
 }
@@ -1546,18 +1727,18 @@ static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
  * type enumerated by RVU_BLOCK_TYPE_E, to assist VF/PF software
  * discovery.
  */
-union cavm_rvu_priv_block_typex_rev {
+union rvu_priv_block_typex_rev {
 	u64 u;
-	struct cavm_rvu_priv_block_typex_rev_s {
+	struct rvu_priv_block_typex_rev_s {
 		u64 rid                              : 8;
 		u64 reserved_8_63                    : 56;
 	} s;
-	/* struct cavm_rvu_priv_block_typex_rev_s cn; */
+	/* struct rvu_priv_block_typex_rev_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+static inline u64 RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+static inline u64 RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
 {
 	return 0x8000400 + 8 * a;
 }
@@ -1567,19 +1748,19 @@ static inline u64 CAVM_RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
  *
  * RVU Privileged General Configuration Register
  */
-union cavm_rvu_priv_clk_cfg {
+union rvu_priv_clk_cfg {
 	u64 u;
-	struct cavm_rvu_priv_clk_cfg_s {
+	struct rvu_priv_clk_cfg_s {
 		u64 blk_clken                        : 1;
 		u64 ncbi_clken                       : 1;
 		u64 reserved_2_63                    : 62;
 	} s;
-	/* struct cavm_rvu_priv_clk_cfg_s cn; */
+	/* struct rvu_priv_clk_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
+static inline u64 RVU_PRIV_CLK_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
+static inline u64 RVU_PRIV_CLK_CFG(void)
 {
 	return 0x8000020;
 }
@@ -1590,21 +1771,21 @@ static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
  * RVU Privileged Constants Register This register contains constants for
  * software discovery.
  */
-union cavm_rvu_priv_const {
+union rvu_priv_const {
 	u64 u;
-	struct cavm_rvu_priv_const_s {
+	struct rvu_priv_const_s {
 		u64 max_msix                         : 20;
 		u64 hwvfs                            : 12;
 		u64 pfs                              : 8;
 		u64 max_vfs_per_pf                   : 8;
 		u64 reserved_48_63                   : 16;
 	} s;
-	/* struct cavm_rvu_priv_const_s cn; */
+	/* struct rvu_priv_const_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_CONST(void)
+static inline u64 RVU_PRIV_CONST(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_CONST(void)
+static inline u64 RVU_PRIV_CONST(void)
 {
 	return 0x8000000;
 }
@@ -1614,18 +1795,18 @@ static inline u64 CAVM_RVU_PRIV_CONST(void)
  *
  * RVU Privileged General Configuration Register
  */
-union cavm_rvu_priv_gen_cfg {
+union rvu_priv_gen_cfg {
 	u64 u;
-	struct cavm_rvu_priv_gen_cfg_s {
+	struct rvu_priv_gen_cfg_s {
 		u64 lock                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_priv_gen_cfg_s cn; */
+	/* struct rvu_priv_gen_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
+static inline u64 RVU_PRIV_GEN_CFG(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
+static inline u64 RVU_PRIV_GEN_CFG(void)
 {
 	return 0x8000010;
 }
@@ -1636,18 +1817,18 @@ static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
  * RVU Privileged Hardware VF CPT Configuration Registers Similar to
  * RVU_PRIV_HWVF()_NIX()_CFG, but for CPT({a}) block.
  */
-union cavm_rvu_priv_hwvfx_cptx_cfg {
+union rvu_priv_hwvfx_cptx_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_cptx_cfg_s {
+	struct rvu_priv_hwvfx_cptx_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_cptx_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_cptx_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
 {
 	return 0x8001350 + 0x10000 * a + 8 * b;
 }
@@ -1657,20 +1838,20 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
  *
  * RVU Privileged Hardware VF Interrupt Configuration Registers
  */
-union cavm_rvu_priv_hwvfx_int_cfg {
+union rvu_priv_hwvfx_int_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_int_cfg_s {
+	struct rvu_priv_hwvfx_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_int_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_INT_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_INT_CFG(u64 a)
 {
 	return 0x8001280 + 0x10000 * a;
 }
@@ -1685,18 +1866,18 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
  * The VF driver can read RVU_VF_BLOCK_ADDR()_DISC to discover the
  * configuration.
  */
-union cavm_rvu_priv_hwvfx_nixx_cfg {
+union rvu_priv_hwvfx_nixx_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_nixx_cfg_s {
+	struct rvu_priv_hwvfx_nixx_cfg_s {
 		u64 has_lf                           : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_nixx_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_nixx_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
 {
 	return 0x8001300 + 0x10000 * a + 8 * b;
 }
@@ -1707,40 +1888,62 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
  * RVU Privileged Hardware VF NPA Configuration Registers Similar to
  * RVU_PRIV_HWVF()_NIX()_CFG, but for NPA block.
  */
-union cavm_rvu_priv_hwvfx_npa_cfg {
+union rvu_priv_hwvfx_npa_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_npa_cfg_s {
+	struct rvu_priv_hwvfx_npa_cfg_s {
 		u64 has_lf                           : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_npa_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_npa_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_NPA_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_NPA_CFG(u64 a)
 {
 	return 0x8001310 + 0x10000 * a;
 }
 
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_ree#_cfg
+ *
+ * RVU Privileged Hardware VF REE Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for REE({a}) block.
+ */
+union rvu_priv_hwvfx_reex_cfg {
+	u64 u;
+	struct rvu_priv_hwvfx_reex_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_hwvfx_reex_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_HWVFX_REEX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_HWVFX_REEX_CFG(u64 a, u64 b)
+{
+	return 0x8001360 + 0x10000 * a + 8 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) rvu_priv_hwvf#_sso_cfg
  *
  * RVU Privileged Hardware VF SSO Configuration Registers Similar to
  * RVU_PRIV_HWVF()_NIX()_CFG, but for SSO block.
  */
-union cavm_rvu_priv_hwvfx_sso_cfg {
+union rvu_priv_hwvfx_sso_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_sso_cfg_s {
+	struct rvu_priv_hwvfx_sso_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_sso_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_sso_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_SSO_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_SSO_CFG(u64 a)
 {
 	return 0x8001320 + 0x10000 * a;
 }
@@ -1751,18 +1954,18 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_SSO_CFG(u64 a)
  * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
  * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for SSOW block.
  */
-union cavm_rvu_priv_hwvfx_ssow_cfg {
+union rvu_priv_hwvfx_ssow_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_ssow_cfg_s {
+	struct rvu_priv_hwvfx_ssow_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_ssow_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_ssow_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
 {
 	return 0x8001330 + 0x10000 * a;
 }
@@ -1773,18 +1976,18 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
  * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
  * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for TIM block.
  */
-union cavm_rvu_priv_hwvfx_tim_cfg {
+union rvu_priv_hwvfx_tim_cfg {
 	u64 u;
-	struct cavm_rvu_priv_hwvfx_tim_cfg_s {
+	struct rvu_priv_hwvfx_tim_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_hwvfx_tim_cfg_s cn; */
+	/* struct rvu_priv_hwvfx_tim_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_TIM_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+static inline u64 RVU_PRIV_HWVFX_TIM_CFG(u64 a)
 {
 	return 0x8001340 + 0x10000 * a;
 }
@@ -1794,22 +1997,34 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_TIM_CFG(u64 a)
  *
  * RVU Privileged PF Configuration Registers
  */
-union cavm_rvu_priv_pfx_cfg {
+union rvu_priv_pfx_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_cfg_s {
+	struct rvu_priv_pfx_cfg_s {
 		u64 first_hwvf                       : 12;
 		u64 nvf                              : 8;
 		u64 ena                              : 1;
 		u64 af_ena                           : 1;
 		u64 me_flr_ena                       : 1;
-		u64 reserved_23_63                   : 41;
+		u64 pf_vf_io_bar4                    : 1;
+		u64 reserved_24_63                   : 40;
 	} s;
-	/* struct cavm_rvu_priv_pfx_cfg_s cn; */
+	struct rvu_priv_pfx_cfg_cn96xxp1 {
+		u64 first_hwvf                       : 12;
+		u64 nvf                              : 8;
+		u64 ena                              : 1;
+		u64 af_ena                           : 1;
+		u64 me_flr_ena                       : 1;
+		u64 reserved_23_63                   : 41;
+	} cn96xxp1;
+	/* struct rvu_priv_pfx_cfg_s cn96xxp3; */
+	/* struct rvu_priv_pfx_cfg_s cn98xx; */
+	/* struct rvu_priv_pfx_cfg_cn96xxp1 cnf95xx; */
+	/* struct rvu_priv_pfx_cfg_s loki; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_CFG(u64 a)
 {
 	return 0x8000100 + 0x10000 * a;
 }
@@ -1820,18 +2035,18 @@ static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
  * RVU Privileged PF CPT Configuration Registers Similar to
  * RVU_PRIV_PF()_NIX()_CFG, but for CPT({a}) block.
  */
-union cavm_rvu_priv_pfx_cptx_cfg {
+union rvu_priv_pfx_cptx_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_cptx_cfg_s {
+	struct rvu_priv_pfx_cptx_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_pfx_cptx_cfg_s cn; */
+	/* struct rvu_priv_pfx_cptx_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
 {
 	return 0x8000350 + 0x10000 * a + 8 * b;
 }
@@ -1841,20 +2056,20 @@ static inline u64 CAVM_RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
  *
  * RVU Privileged PF ID Configuration Registers
  */
-union cavm_rvu_priv_pfx_id_cfg {
+union rvu_priv_pfx_id_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_id_cfg_s {
+	struct rvu_priv_pfx_id_cfg_s {
 		u64 pf_devid                         : 8;
 		u64 vf_devid                         : 8;
 		u64 class_code                       : 24;
 		u64 reserved_40_63                   : 24;
 	} s;
-	/* struct cavm_rvu_priv_pfx_id_cfg_s cn; */
+	/* struct rvu_priv_pfx_id_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_ID_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_ID_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_ID_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_ID_CFG(u64 a)
 {
 	return 0x8000120 + 0x10000 * a;
 }
@@ -1864,20 +2079,20 @@ static inline u64 CAVM_RVU_PRIV_PFX_ID_CFG(u64 a)
  *
  * RVU Privileged PF Interrupt Configuration Registers
  */
-union cavm_rvu_priv_pfx_int_cfg {
+union rvu_priv_pfx_int_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_int_cfg_s {
+	struct rvu_priv_pfx_int_cfg_s {
 		u64 msix_offset                      : 11;
 		u64 reserved_11                      : 1;
 		u64 msix_size                        : 8;
 		u64 reserved_20_63                   : 44;
 	} s;
-	/* struct cavm_rvu_priv_pfx_int_cfg_s cn; */
+	/* struct rvu_priv_pfx_int_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_INT_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_INT_CFG(u64 a)
 {
 	return 0x8000200 + 0x10000 * a;
 }
@@ -1903,20 +2118,20 @@ static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
  * VFs must have non-overlapping vector ranges, and the last index of any
  * range must be less than RVU_PRIV_CONST[MAX_MSIX].
  */
-union cavm_rvu_priv_pfx_msix_cfg {
+union rvu_priv_pfx_msix_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_msix_cfg_s {
+	struct rvu_priv_pfx_msix_cfg_s {
 		u64 vf_msixt_sizem1                  : 12;
 		u64 vf_msixt_offset                  : 20;
 		u64 pf_msixt_sizem1                  : 12;
 		u64 pf_msixt_offset                  : 20;
 	} s;
-	/* struct cavm_rvu_priv_pfx_msix_cfg_s cn; */
+	/* struct rvu_priv_pfx_msix_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_MSIX_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_MSIX_CFG(u64 a)
 {
 	return 0x8000110 + 0x10000 * a;
 }
@@ -1930,18 +2145,18 @@ static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
  * The PF driver can read RVU_PF_BLOCK_ADDR()_DISC to discover the
  * configuration.
  */
-union cavm_rvu_priv_pfx_nixx_cfg {
+union rvu_priv_pfx_nixx_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_nixx_cfg_s {
+	struct rvu_priv_pfx_nixx_cfg_s {
 		u64 has_lf                           : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_priv_pfx_nixx_cfg_s cn; */
+	/* struct rvu_priv_pfx_nixx_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+static inline u64 RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
 {
 	return 0x8000300 + 0x10000 * a + 8 * b;
 }
@@ -1952,40 +2167,62 @@ static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
  * RVU Privileged PF NPA Configuration Registers Similar to
  * RVU_PRIV_PF()_NIX()_CFG, but for NPA block.
  */
-union cavm_rvu_priv_pfx_npa_cfg {
+union rvu_priv_pfx_npa_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_npa_cfg_s {
+	struct rvu_priv_pfx_npa_cfg_s {
 		u64 has_lf                           : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_priv_pfx_npa_cfg_s cn; */
+	/* struct rvu_priv_pfx_npa_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_NPA_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_NPA_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_NPA_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_NPA_CFG(u64 a)
 {
 	return 0x8000310 + 0x10000 * a;
 }
 
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_ree#_cfg
+ *
+ * RVU Privileged PF REE Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for REE({a}) block.
+ */
+union rvu_priv_pfx_reex_cfg {
+	u64 u;
+	struct rvu_priv_pfx_reex_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct rvu_priv_pfx_reex_cfg_s cn; */
+};
+
+static inline u64 RVU_PRIV_PFX_REEX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 RVU_PRIV_PFX_REEX_CFG(u64 a, u64 b)
+{
+	return 0x8000360 + 0x10000 * a + 8 * b;
+}
+
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_sso_cfg
  *
  * RVU Privileged PF SSO Configuration Registers Similar to
  * RVU_PRIV_PF()_NIX()_CFG, but for SSO block.
  */
-union cavm_rvu_priv_pfx_sso_cfg {
+union rvu_priv_pfx_sso_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_sso_cfg_s {
+	struct rvu_priv_pfx_sso_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_pfx_sso_cfg_s cn; */
+	/* struct rvu_priv_pfx_sso_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_SSO_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_SSO_CFG(u64 a)
 {
 	return 0x8000320 + 0x10000 * a;
 }
@@ -1996,18 +2233,18 @@ static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
  * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
  * RVU_PRIV_PF()_NIX()_CFG, but for SSOW block.
  */
-union cavm_rvu_priv_pfx_ssow_cfg {
+union rvu_priv_pfx_ssow_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_ssow_cfg_s {
+	struct rvu_priv_pfx_ssow_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_pfx_ssow_cfg_s cn; */
+	/* struct rvu_priv_pfx_ssow_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_SSOW_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_SSOW_CFG(u64 a)
 {
 	return 0x8000330 + 0x10000 * a;
 }
@@ -2018,18 +2255,18 @@ static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
  * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
  * RVU_PRIV_PF()_NIX()_CFG, but for TIM block.
  */
-union cavm_rvu_priv_pfx_tim_cfg {
+union rvu_priv_pfx_tim_cfg {
 	u64 u;
-	struct cavm_rvu_priv_pfx_tim_cfg_s {
+	struct rvu_priv_pfx_tim_cfg_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_63                    : 55;
 	} s;
-	/* struct cavm_rvu_priv_pfx_tim_cfg_s cn; */
+	/* struct rvu_priv_pfx_tim_cfg_s cn; */
 };
 
-static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_TIM_CFG(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
+static inline u64 RVU_PRIV_PFX_TIM_CFG(u64 a)
 {
 	return 0x8000340 + 0x10000 * a;
 }
@@ -2041,9 +2278,9 @@ static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
  * driver to discover block resources that are provisioned to its VF. The
  * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
  */
-union cavm_rvu_vf_block_addrx_disc {
+union rvu_vf_block_addrx_disc {
 	u64 u;
-	struct cavm_rvu_vf_block_addrx_disc_s {
+	struct rvu_vf_block_addrx_disc_s {
 		u64 num_lfs                          : 9;
 		u64 reserved_9_10                    : 2;
 		u64 imp                              : 1;
@@ -2051,12 +2288,12 @@ union cavm_rvu_vf_block_addrx_disc {
 		u64 btype                            : 8;
 		u64 reserved_28_63                   : 36;
 	} s;
-	/* struct cavm_rvu_vf_block_addrx_disc_s cn; */
+	/* struct rvu_vf_block_addrx_disc_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+static inline u64 RVU_VF_BLOCK_ADDRX_DISC(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+static inline u64 RVU_VF_BLOCK_ADDRX_DISC(u64 a)
 {
 	return 0x200 + 8 * a;
 }
@@ -2066,18 +2303,18 @@ static inline u64 CAVM_RVU_VF_BLOCK_ADDRX_DISC(u64 a)
  *
  * RVU VF Interrupt Registers
  */
-union cavm_rvu_vf_int {
+union rvu_vf_int {
 	u64 u;
-	struct cavm_rvu_vf_int_s {
+	struct rvu_vf_int_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_vf_int_s cn; */
+	/* struct rvu_vf_int_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_INT(void)
+static inline u64 RVU_VF_INT(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_INT(void)
+static inline u64 RVU_VF_INT(void)
 {
 	return 0x20;
 }
@@ -2088,18 +2325,18 @@ static inline u64 CAVM_RVU_VF_INT(void)
  * RVU VF Interrupt Enable Clear Register This register clears interrupt
  * enable bits.
  */
-union cavm_rvu_vf_int_ena_w1c {
+union rvu_vf_int_ena_w1c {
 	u64 u;
-	struct cavm_rvu_vf_int_ena_w1c_s {
+	struct rvu_vf_int_ena_w1c_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_vf_int_ena_w1c_s cn; */
+	/* struct rvu_vf_int_ena_w1c_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
+static inline u64 RVU_VF_INT_ENA_W1C(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
+static inline u64 RVU_VF_INT_ENA_W1C(void)
 {
 	return 0x38;
 }
@@ -2110,18 +2347,18 @@ static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
  * RVU VF Interrupt Enable Set Register This register sets interrupt
  * enable bits.
  */
-union cavm_rvu_vf_int_ena_w1s {
+union rvu_vf_int_ena_w1s {
 	u64 u;
-	struct cavm_rvu_vf_int_ena_w1s_s {
+	struct rvu_vf_int_ena_w1s_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_vf_int_ena_w1s_s cn; */
+	/* struct rvu_vf_int_ena_w1s_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
+static inline u64 RVU_VF_INT_ENA_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
+static inline u64 RVU_VF_INT_ENA_W1S(void)
 {
 	return 0x30;
 }
@@ -2131,18 +2368,18 @@ static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
  *
  * RVU VF Interrupt Set Register This register sets interrupt bits.
  */
-union cavm_rvu_vf_int_w1s {
+union rvu_vf_int_w1s {
 	u64 u;
-	struct cavm_rvu_vf_int_w1s_s {
+	struct rvu_vf_int_w1s_s {
 		u64 mbox                             : 1;
 		u64 reserved_1_63                    : 63;
 	} s;
-	/* struct cavm_rvu_vf_int_w1s_s cn; */
+	/* struct rvu_vf_int_w1s_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_INT_W1S(void)
+static inline u64 RVU_VF_INT_W1S(void)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_INT_W1S(void)
+static inline u64 RVU_VF_INT_W1S(void)
 {
 	return 0x28;
 }
@@ -2153,17 +2390,17 @@ static inline u64 CAVM_RVU_VF_INT_W1S(void)
  * RVU VF MSI-X Pending-Bit-Array Registers This register is the MSI-X VF
  * PBA table.
  */
-union cavm_rvu_vf_msix_pbax {
+union rvu_vf_msix_pbax {
 	u64 u;
-	struct cavm_rvu_vf_msix_pbax_s {
+	struct rvu_vf_msix_pbax_s {
 		u64 pend                             : 64;
 	} s;
-	/* struct cavm_rvu_vf_msix_pbax_s cn; */
+	/* struct rvu_vf_msix_pbax_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
+static inline u64 RVU_VF_MSIX_PBAX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
+static inline u64 RVU_VF_MSIX_PBAX(u64 a)
 {
 	return 0xf0000 + 8 * a;
 }
@@ -2179,20 +2416,20 @@ static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
  * writes have completed before interrupts are generated to the modified
  * vectors.
  */
-union cavm_rvu_vf_msix_vecx_addr {
+union rvu_vf_msix_vecx_addr {
 	u64 u;
-	struct cavm_rvu_vf_msix_vecx_addr_s {
+	struct rvu_vf_msix_vecx_addr_s {
 		u64 secvec                           : 1;
 		u64 reserved_1                       : 1;
 		u64 addr                             : 51;
 		u64 reserved_53_63                   : 11;
 	} s;
-	/* struct cavm_rvu_vf_msix_vecx_addr_s cn; */
+	/* struct rvu_vf_msix_vecx_addr_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
+static inline u64 RVU_VF_MSIX_VECX_ADDR(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
+static inline u64 RVU_VF_MSIX_VECX_ADDR(u64 a)
 {
 	return 0x80000 + 0x10 * a;
 }
@@ -2203,19 +2440,19 @@ static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
  * RVU VF MSI-X Vector-Table Control and Data Registers These registers
  * and RVU_VF_MSIX_VEC()_ADDR form the VF MSI-X vector table.
  */
-union cavm_rvu_vf_msix_vecx_ctl {
+union rvu_vf_msix_vecx_ctl {
 	u64 u;
-	struct cavm_rvu_vf_msix_vecx_ctl_s {
+	struct rvu_vf_msix_vecx_ctl_s {
 		u64 data                             : 32;
 		u64 mask                             : 1;
 		u64 reserved_33_63                   : 31;
 	} s;
-	/* struct cavm_rvu_vf_msix_vecx_ctl_s cn; */
+	/* struct rvu_vf_msix_vecx_ctl_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_MSIX_VECX_CTL(u64 a)
+static inline u64 RVU_VF_MSIX_VECX_CTL(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_MSIX_VECX_CTL(u64 a)
+static inline u64 RVU_VF_MSIX_VECX_CTL(u64 a)
 {
 	return 0x80008 + 0x10 * a;
 }
@@ -2225,19 +2462,19 @@ static inline u64 CAVM_RVU_VF_MSIX_VECX_CTL(u64 a)
  *
  * RVU VF/PF Mailbox Registers
  */
-union cavm_rvu_vf_vfpf_mboxx {
+union rvu_vf_vfpf_mboxx {
 	u64 u;
-	struct cavm_rvu_vf_vfpf_mboxx_s {
+	struct rvu_vf_vfpf_mboxx_s {
 		u64 data                             : 64;
 	} s;
-	/* struct cavm_rvu_vf_vfpf_mboxx_s cn; */
+	/* struct rvu_vf_vfpf_mboxx_s cn; */
 };
 
-static inline u64 CAVM_RVU_VF_VFPF_MBOXX(u64 a)
+static inline u64 RVU_VF_VFPF_MBOXX(u64 a)
 	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_RVU_VF_VFPF_MBOXX(u64 a)
+static inline u64 RVU_VF_VFPF_MBOXX(u64 a)
 {
 	return 0 + 8 * a;
 }
 
-#endif /* __CAVM_CSRS_RVU_H__ */
+#endif /* __CSRS_RVU_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/fdt-helper.h b/arch/arm/include/asm/arch-octeontx2/fdt-helper.h
deleted file mode 100644
index b01dbe0412..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/fdt-helper.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef __FDT_HELPER_H__
-#define __FDT_HELPER_H__
-
-/**
- * Given a FDT node, check if it is compatible with a list of devices
- *
- * @param[in]	fdt		Flat device tree pointer
- * @param	node_offset	Node offset in device tree
- * @param[in]	strlist		Array of FDT devices to check, end must be NULL
- *
- * @return	0 if at least one device is compatible, 1 if not compatible.
- */
-int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
-				     const char * const *strlist);
-
-/**
- * Given a FDT node, return the next compatible node.
- *
- * @param[in]	fdt_addr	Pointer to flat device tree
- * @param	start_offset	Starting node offset or -1 to find the first
- * @param	strlist		Array of FDT device compatibility strings, must
- *				end with NULL or empty string.
- *
- * @return	next matching node or -1 if no more matches.
- */
-int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
-					      int startoffset,
-					      const char * const *strlist);
-
-#endif /* __FDT_HELPER_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/gpio.h b/arch/arm/include/asm/arch-octeontx2/gpio.h
new file mode 100644
index 0000000000..3943ffd952
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/gpio.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h b/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
deleted file mode 120000
index dfa9755025..0000000000
--- a/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
+++ /dev/null
@@ -1 +0,0 @@
-../arch-octeontx/octeontx_mmc.h
\ No newline at end of file
diff --git a/arch/arm/mach-octeontx/Makefile b/arch/arm/mach-octeontx/Makefile
index c3192343dd..20cb48ad92 100644
--- a/arch/arm/mach-octeontx/Makefile
+++ b/arch/arm/mach-octeontx/Makefile
@@ -1,7 +1,7 @@
-#/*
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
 # * Copyright (C) 2018 Marvell International Ltd.
 # *
-# * SPDX-License-Identifier:    GPL-2.0
 # * https://spdx.org/licenses
 # */
 
diff --git a/arch/arm/mach-octeontx/clock.c b/arch/arm/mach-octeontx/clock.c
index b6c127dc4b..8b8b046d20 100644
--- a/arch/arm/mach-octeontx/clock.c
+++ b/arch/arm/mach-octeontx/clock.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
diff --git a/arch/arm/mach-octeontx/cpu.c b/arch/arm/mach-octeontx/cpu.c
index 013dd8157c..96b0982dab 100644
--- a/arch/arm/mach-octeontx/cpu.c
+++ b/arch/arm/mach-octeontx/cpu.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -41,6 +41,7 @@ static struct mm_region octeontx_mem_map[] = {
 		0,
 	}
 };
+
 struct mm_region *mem_map = octeontx_mem_map;
 
 u64 get_page_table_size(void)
@@ -50,5 +51,4 @@ u64 get_page_table_size(void)
 
 void reset_cpu(ulong addr)
 {
-
 }
diff --git a/arch/arm/mach-octeontx/fdt-helper.c b/arch/arm/mach-octeontx/fdt-helper.c
deleted file mode 100644
index 0bef17aa11..0000000000
--- a/arch/arm/mach-octeontx/fdt-helper.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-/* This file contains flat device-tree helper functions.
- * At some later point these functions should be moved into U-Boot common code.
- */
-
-#include <common.h>
-#include <libfdt.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <asm/arch/fdt-helper.h>
-
-/**
- * Given a FDT node, check if it is compatible with a list of devices
- *
- * @param[in]	fdt		Flat device tree pointer
- * @param	node_offset	Node offset in device tree
- * @param[in]	strlist		Array of FDT devices to check, end must be NULL
- *
- * @return	0 if at least one device is compatible, 1 if not compatible.
- */
-int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
-				     const char * const *strlist)
-{
-	while (*strlist && **strlist) {
-		debug("%s: Checking %s\n", __func__, *strlist);
-		if (!fdt_node_check_compatible(fdt, node_offset, *strlist)) {
-			debug("%s: match found\n", __func__);
-			return 0;
-		}
-		strlist++;
-	}
-	debug("%s: No match found\n", __func__);
-	return 1;
-}
-
-/**
- * Given a FDT node, return the next compatible node.
- *
- * @param[in]	fdt_addr	Pointer to flat device tree
- * @param	start_offset	Starting node offset or -1 to find the first
- * @param	strlist		Array of FDT device compatibility strings, must
- *				end with NULL or empty string.
- *
- * @return	next matching node or -1 if no more matches.
- */
-int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
-					      int startoffset,
-					      const char * const *strlist)
-{
-	int offset;
-	const char * const *searchlist;
-
-	for (offset = fdt_next_node(fdt_addr, startoffset, NULL);
-	     offset >= 0;
-	offset = fdt_next_node(fdt_addr, offset, NULL)) {
-		searchlist = strlist;
-		while (*searchlist && **searchlist) {
-			if (!fdt_node_check_compatible(fdt_addr, offset,
-				*searchlist))
-				return offset;
-			searchlist++;
-		}
-	}
-	return -1;
-}
-
diff --git a/arch/arm/mach-octeontx/lowlevel_init.S b/arch/arm/mach-octeontx/lowlevel_init.S
index ed52ed2481..18b7d3956b 100644
--- a/arch/arm/mach-octeontx/lowlevel_init.S
+++ b/arch/arm/mach-octeontx/lowlevel_init.S
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
diff --git a/arch/arm/mach-octeontx2/clock.c b/arch/arm/mach-octeontx2/clock.c
index b6c127dc4b..8b8b046d20 100644
--- a/arch/arm/mach-octeontx2/clock.c
+++ b/arch/arm/mach-octeontx2/clock.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
diff --git a/arch/arm/mach-octeontx2/cpu.c b/arch/arm/mach-octeontx2/cpu.c
index 12d1daab44..ad9a50264b 100644
--- a/arch/arm/mach-octeontx2/cpu.c
+++ b/arch/arm/mach-octeontx2/cpu.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -47,6 +47,7 @@ static struct mm_region octeontx2_mem_map[] = {
 		0,
 	}
 };
+
 struct mm_region *mem_map = octeontx2_mem_map;
 
 u64 get_page_table_size(void)
@@ -56,5 +57,4 @@ u64 get_page_table_size(void)
 
 void reset_cpu(ulong addr)
 {
-
 }
diff --git a/arch/arm/mach-octeontx2/fdt-helper.c b/arch/arm/mach-octeontx2/fdt-helper.c
deleted file mode 100644
index 0bef17aa11..0000000000
--- a/arch/arm/mach-octeontx2/fdt-helper.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-/* This file contains flat device-tree helper functions.
- * At some later point these functions should be moved into U-Boot common code.
- */
-
-#include <common.h>
-#include <libfdt.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <asm/arch/fdt-helper.h>
-
-/**
- * Given a FDT node, check if it is compatible with a list of devices
- *
- * @param[in]	fdt		Flat device tree pointer
- * @param	node_offset	Node offset in device tree
- * @param[in]	strlist		Array of FDT devices to check, end must be NULL
- *
- * @return	0 if at least one device is compatible, 1 if not compatible.
- */
-int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
-				     const char * const *strlist)
-{
-	while (*strlist && **strlist) {
-		debug("%s: Checking %s\n", __func__, *strlist);
-		if (!fdt_node_check_compatible(fdt, node_offset, *strlist)) {
-			debug("%s: match found\n", __func__);
-			return 0;
-		}
-		strlist++;
-	}
-	debug("%s: No match found\n", __func__);
-	return 1;
-}
-
-/**
- * Given a FDT node, return the next compatible node.
- *
- * @param[in]	fdt_addr	Pointer to flat device tree
- * @param	start_offset	Starting node offset or -1 to find the first
- * @param	strlist		Array of FDT device compatibility strings, must
- *				end with NULL or empty string.
- *
- * @return	next matching node or -1 if no more matches.
- */
-int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
-					      int startoffset,
-					      const char * const *strlist)
-{
-	int offset;
-	const char * const *searchlist;
-
-	for (offset = fdt_next_node(fdt_addr, startoffset, NULL);
-	     offset >= 0;
-	offset = fdt_next_node(fdt_addr, offset, NULL)) {
-		searchlist = strlist;
-		while (*searchlist && **searchlist) {
-			if (!fdt_node_check_compatible(fdt_addr, offset,
-				*searchlist))
-				return offset;
-			searchlist++;
-		}
-	}
-	return -1;
-}
-
diff --git a/arch/arm/mach-octeontx2/lowlevel_init.S b/arch/arm/mach-octeontx2/lowlevel_init.S
index cb6a5a05dd..66583108aa 100644
--- a/arch/arm/mach-octeontx2/lowlevel_init.S
+++ b/arch/arm/mach-octeontx2/lowlevel_init.S
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
diff --git a/board/Marvell/octeontx/atf.c b/board/Marvell/octeontx/atf.c
index 073eccc3af..1aa4101e3d 100644
--- a/board/Marvell/octeontx/atf.c
+++ b/board/Marvell/octeontx/atf.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -11,7 +11,6 @@
 #include <asm/system.h>
 #include <asm/arch/octeontx_svc.h>
 #include <asm/arch/atf.h>
-#include <asm/arch/atf_part.h>
 
 #include <asm/psci.h>
 
@@ -22,19 +21,9 @@ DECLARE_GLOBAL_DATA_PTR;
 ssize_t atf_dram_size(unsigned int node)
 {
 	struct pt_regs regs;
+
 	regs.regs[0] = OCTEONTX_DRAM_SIZE;
 	regs.regs[1] = node;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_node_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = OCTEONTX_NODE_COUNT;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
diff --git a/board/Marvell/octeontx/fdt.c b/board/Marvell/octeontx/fdt.c
index faf866c36b..7b2b2bfdd5 100644
--- a/board/Marvell/octeontx/fdt.c
+++ b/board/Marvell/octeontx/fdt.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -65,12 +65,12 @@ void octeontx_parse_phy_info(void)
 	int len, rgx_id = 0, eth_id = 0;
 	int phandle, phy_offset;
 	int subnode, i;
-
 	int bgxnode;
+
 	bgxnode = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
 	if (bgxnode < 0) {
 		printf("%s: /cavium,bdk is missing from device tree: %s\n",
-			__func__, fdt_strerror(bgxnode));
+		       __func__, fdt_strerror(bgxnode));
 	}
 
 	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
@@ -81,6 +81,7 @@ void octeontx_parse_phy_info(void)
 			int mdio_bus[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = -1};
 			bool lmac_reg[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = 0};
 			bool lmac_enable[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = 0};
+
 			snprintf(bgxname, sizeof(bgxname),
 				 "bgx%d", bgx_id);
 			node = fdt_subnode_offset(fdt, offset, bgxname);
@@ -91,14 +92,16 @@ void octeontx_parse_phy_info(void)
 				node = fdt_subnode_offset(fdt, offset, bgxname);
 				if (node < 0) {
 					debug("bgx%d/rgx0 node not found\n",
-					       bgx_id);
+					      bgx_id);
 					return;
 				}
 			}
 			debug("bgx%d node found\n", bgx_id);
 
-			/* loop through each of the bgx/rgx nodes
-			to find PHY nodes */
+			/*
+			 * loop through each of the bgx/rgx nodes
+			 * to find PHY nodes
+			 */
 			fdt_for_each_subnode(subnode, fdt, node) {
 				/* Check for reg property */
 				val = fdt_getprop(fdt, subnode, "reg",
@@ -128,10 +131,10 @@ void octeontx_parse_phy_info(void)
 						octeontx_get_mdio_bus
 							(fdt, phy_offset);
 					}
-				} else
+				} else {
 					debug("phy-handle property not found %d\n",
 					      lmacid);
-
+				}
 				/* check for autonegotiation property */
 				val = fdt_getprop(fdt, subnode,
 						  "cavium,disable-autonegotiation",
@@ -145,6 +148,7 @@ void octeontx_parse_phy_info(void)
 
 			for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
 				const char *str;
+
 				snprintf(bgxname, sizeof(bgxname), "BGX-ENABLE.N0.BGX%d.P%d", bgx_id, i);
 				if (bgxnode >= 0) {
 					str = fdt_getprop(gd->fdt_blob, bgxnode, bgxname, &len);
@@ -177,9 +181,9 @@ int ft_board_setup(void *blob, bd_t *bd)
 		return ret;
 	}
 
-	if (blob != NULL) {
+	if (blob) {
 		offset = fdt_path_offset(blob, "/cavium,bdk");
-		if(offset < 0) {
+		if (offset < 0) {
 			printf("ERROR: FDT BDK node not found\n");
 			return offset;
 		}
@@ -191,7 +195,7 @@ int ft_board_setup(void *blob, bd_t *bd)
 			return ret;
 		}
 
-		debug("%s deleted 'cavium,bdk' node\n", __FUNCTION__);
+		debug("%s deleted 'cavium,bdk' node\n", __func__);
 	}
 
 	return 0;
diff --git a/board/Marvell/octeontx/octeontx.c b/board/Marvell/octeontx/octeontx.c
index aa346f55c3..748965c26f 100644
--- a/board/Marvell/octeontx/octeontx.c
+++ b/board/Marvell/octeontx/octeontx.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -14,8 +14,8 @@
 #include <linux/compiler.h>
 #include <linux/libfdt.h>
 #include <fdt_support.h>
-#include <asm/arch/octeontx.h>
 #include <asm/arch/atf.h>
+#include <asm/arch/octeontx.h>
 #include <dm/util.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -27,9 +27,10 @@ extern void eth_common_init(void);
 void octeontx_cleanup_ethaddr(void)
 {
 	char ename[32];
+
 	for (int i = 0; i < 20; i++) {
 		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
-		if(env_get(ename))
+		if (env_get(ename))
 			env_set_force(ename, NULL);
 	}
 }
@@ -45,14 +46,15 @@ void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
 	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
 	if (offset < 0) {
 		printf("%s couldn't find mrml bridge node in fdt\n",
-			 __func__);
+		       __func__);
 		return;
 	}
 	if (bgx == 2 && is_board_model(CN81XX)) {
 		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
 		lmac = 0;
-	} else
+	} else {
 		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx);
+	}
 
 	node = fdt_subnode_offset(fdt, offset, bgxname);
 
@@ -60,13 +62,13 @@ void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
 		if (i++ != lmac)
 			continue;
 		/* check for local-mac-address */
-		mac = fdt_getprop(fdt, subnode,
-				       "local-mac-address", &len);
-		if(mac) {
+		mac = fdt_getprop(fdt, subnode, "local-mac-address", &len);
+		if (mac) {
 			debug("%s mac %pM\n", __func__, mac);
 			memcpy(eth, mac, ARP_HLEN);
-		} else
+		} else {
 			memset(eth, 0, ARP_HLEN);
+		}
 		debug("%s eth %pM\n", __func__, eth);
 		return;
 	}
@@ -75,7 +77,7 @@ void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
 int octeontx_board_has_pmp(void)
 {
 	if ((strcasecmp(g_cavm_bdt.type, "sff8104") == 0) ||
-		(strcasecmp(g_cavm_bdt.type, "nas8104") == 0))
+	    (strcasecmp(g_cavm_bdt.type, "nas8104") == 0))
 		return 1;
 
 	return 0;
@@ -96,8 +98,8 @@ void octeontx_parse_board_info(void)
 
 	val = readq(CAVM_MIO_FUS_DAT2);
 	g_cavm_bdt.alt_pkg = (val >> 22) & 0x3;
-	if ((g_cavm_bdt.prod_id == CN81XX) &&
-		(g_cavm_bdt.alt_pkg || ((val >> 30) & 0x1)))
+	if (g_cavm_bdt.prod_id == CN81XX &&
+	    (g_cavm_bdt.alt_pkg || ((val >> 30) & 0x1)))
 		g_cavm_bdt.alt_pkg = 2;
 
 	if (!gd->fdt_blob) {
@@ -123,7 +125,7 @@ void octeontx_parse_board_info(void)
 	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
 	if (str) {
 		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
-		debug("fdt: BOARD-MODEL bdt.type %s \n", g_cavm_bdt.type);
+		debug("fdt: BOARD-MODEL bdt.type %s\n", g_cavm_bdt.type);
 	} else {
 		printf("Error: cannot retrieve board type from fdt\n");
 	}
@@ -169,20 +171,7 @@ int timer_init(void)
 
 int dram_init(void)
 {
-	ssize_t node_count = atf_node_count();
-	ssize_t dram_size;
-	int node;
-
-	debug("Initializing\nNodes in system: %zd\n", node_count);
-
-	gd->ram_size = 0;
-
-	for (node = 0; node < node_count; node++) {
-		dram_size = atf_dram_size(node);
-		debug("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
-		gd->ram_size += dram_size;
-	}
-
+	gd->ram_size = atf_dram_size(0);
 	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
 
 	return 0;
@@ -246,9 +235,8 @@ int show_board_info(void)
 	}
 	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
 	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (!str) {
+	if (!str)
 		printf("Error: cannot retrieve board type from fdt\n");
-	}
 
 	if (prod_id == CN81XX)
 		printf("OcteonTX CN81XX ARM V8 Core\n");
diff --git a/board/Marvell/octeontx2/atf.c b/board/Marvell/octeontx2/atf.c
index 0f27209a23..c9eae788c7 100644
--- a/board/Marvell/octeontx2/atf.c
+++ b/board/Marvell/octeontx2/atf.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -21,19 +21,9 @@ DECLARE_GLOBAL_DATA_PTR;
 ssize_t atf_dram_size(unsigned int node)
 {
 	struct pt_regs regs;
+
 	regs.regs[0] = OCTEONTX2_DRAM_SIZE;
 	regs.regs[1] = node;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_node_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = OCTEONTX2_NODE_COUNT;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -42,9 +32,9 @@ ssize_t atf_node_count(void)
 ssize_t atf_disable_rvu_lfs(unsigned int node)
 {
 	struct pt_regs regs;
+
 	regs.regs[0] = OCTEONTX2_DISABLE_RVU_LFS;
 	regs.regs[1] = node;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -53,9 +43,9 @@ ssize_t atf_disable_rvu_lfs(unsigned int node)
 ssize_t atf_configure_ooo(unsigned int val)
 {
 	struct pt_regs regs;
+
 	regs.regs[0] = OCTEONTX2_CONFIG_OOO;
 	regs.regs[1] = val;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -66,7 +56,6 @@ ssize_t atf_flsf_fw_booted(void)
 	struct pt_regs regs;
 
 	regs.regs[0] = OCTEONTX2_FSAFE_PR_BOOT_SUCCESS;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -77,7 +66,6 @@ ssize_t atf_flsf_clr_force_2ndry(void)
 	struct pt_regs regs;
 
 	regs.regs[0] = OCTEONTX2_FSAFE_CLR_FORCE_SEC;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -94,7 +82,6 @@ ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
 	regs.regs[3] = phyaddr;
 	regs.regs[4] = devad;
 	regs.regs[5] = reg;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
@@ -112,7 +99,6 @@ ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
 	regs.regs[4] = devad;
 	regs.regs[5] = reg;
 	regs.regs[6] = val;
-
 	smc_call(&regs);
 
 	return regs.regs[0];
diff --git a/board/Marvell/octeontx2/fdt.c b/board/Marvell/octeontx2/fdt.c
index 292112e097..a938f1f712 100644
--- a/board/Marvell/octeontx2/fdt.c
+++ b/board/Marvell/octeontx2/fdt.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -17,7 +17,6 @@
 #include <asm/arch/atf.h>
 #include <asm/arch/octeontx2.h>
 
-
 DECLARE_GLOBAL_DATA_PTR;
 
 extern unsigned long fdt_base_addr;
@@ -38,9 +37,9 @@ int ft_board_setup(void *blob, bd_t *bd)
 		return ret;
 	}
 
-	if (blob != NULL) {
+	if (blob) {
 		offset = fdt_path_offset(blob, "/cavium,bdk");
-		if(offset < 0) {
+		if (offset < 0) {
 			printf("ERROR: FDT BDK node not found\n");
 			return offset;
 		}
@@ -52,7 +51,7 @@ int ft_board_setup(void *blob, bd_t *bd)
 			return ret;
 		}
 
-		debug("%s deleted 'cavium,bdk' node\n", __FUNCTION__);
+		debug("%s deleted 'cavium,bdk' node\n", __func__);
 	}
 
 	return 0;
diff --git a/board/Marvell/octeontx2/octeontx2.c b/board/Marvell/octeontx2/octeontx2.c
index 26a6d55d23..1a7956f1c2 100644
--- a/board/Marvell/octeontx2/octeontx2.c
+++ b/board/Marvell/octeontx2/octeontx2.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -125,7 +125,7 @@ void octeontx_parse_board_info(void)
 	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
 	if (str) {
 		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
-		debug("fdt: BOARD-MODEL bdt.type %s \n", g_cavm_bdt.type);
+		debug("fdt: BOARD-MODEL bdt.type %s\n", g_cavm_bdt.type);
 	} else {
 		printf("Error: cannot retrieve board type from fdt\n");
 	}
@@ -158,8 +158,6 @@ void octeontx_parse_board_info(void)
 
 void board_quiesce_devices(void)
 {
-	ssize_t node_count = atf_node_count();
-	int node;
 	struct uclass *uc_dev;
 	int ret;
 
@@ -183,9 +181,7 @@ void board_quiesce_devices(void)
 		printf("couldn't remove misc (cgx/rvu_af) devices\n");
 
 	/* SMC call - removes all LF<->PF mappings */
-	for (node = 0; node < node_count; node++) {
-		atf_disable_rvu_lfs(node);
-	}
+	atf_disable_rvu_lfs(0);
 }
 
 int board_early_init_r(void)
@@ -207,19 +203,10 @@ int timer_init(void)
 
 int dram_init(void)
 {
-	ssize_t node_count = atf_node_count();
-	ssize_t dram_size;
-	int node;
-
-	debug("Initializing\nNodes in system: %zd\n", node_count);
-
 	gd->ram_size = 0;
 
-	for (node = 0; node < node_count; node++) {
-		dram_size = atf_dram_size(node);
-		debug("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
-		gd->ram_size += dram_size;
-	}
+	gd->ram_size = atf_dram_size(0);
+	debug("Node0: %lld MBytes of DRAM\n", gd->ram_size >> 20);
 
 	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
 
@@ -339,9 +326,8 @@ int show_board_info(void)
 	}
 	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
 	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
-	if (!str) {
+	if (!str)
 		printf("Error: cannot retrieve board type from fdt\n");
-	}
 
 	if (prod_id == CN96XX)
 		printf("OcteonTX2 CN96XX ARM V8 Core\n");
@@ -360,7 +346,7 @@ void acquire_flash_arb(bool acquire)
 {
 	union cavm_cpc_boot_ownerx ownerx;
 
-	if (acquire == false) {
+	if (!acquire) {
 		ownerx.u = readl(CAVM_CPC_BOOT_OWNERX(3));
 		ownerx.s.boot_req = 0;
 		writel(ownerx.u, CAVM_CPC_BOOT_OWNERX(3));
diff --git a/cmd/bootimgup.c b/cmd/bootimgup.c
index eda5fef34d..d24c1fbdd8 100644
--- a/cmd/bootimgup.c
+++ b/cmd/bootimgup.c
@@ -240,7 +240,6 @@ static int do_bootu_spi(int argc, char * const argv[], bool update_scp)
 	char *endp;
 	int ret = 1;
 	unsigned int bus = 0, cs;
-	unsigned long bytes_written = 0;
 	u8 scp_rom_buf[SCP_ROM_SIZE];
 	u8 old_buf_data[SCP_ROM_SIZE];
 
@@ -585,7 +584,7 @@ static int do_bootu_mmc(int argc, char * const argv[],
 			goto error;
 	}
 error:
-	printf("%u blocks written: %s",
+	printf("%lu blocks written: %s",
 	       update_scp ? blk_cnt : blk_cnt - SCP_ROM_BLOCKS,
 	       (blk_cnt == len) ? "OK" : "ERROR");
 	if (!update_scp)
diff --git a/drivers/gpio/octeontx_gpio.c b/drivers/gpio/octeontx_gpio.c
index 98098d0a4c..fa72c747a9 100644
--- a/drivers/gpio/octeontx_gpio.c
+++ b/drivers/gpio/octeontx_gpio.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  *
  * (C) Copyright 2011
@@ -42,7 +42,7 @@ DECLARE_GLOBAL_DATA_PTR;
 			  ((value) ? GPIO_TX_SET : GPIO_TX_CLR))
 
 /** Returns the offset to the input data register based on the offset */
-#define GPIO_RX_DAT_REG(offset) ((offset >= 64) ? GPIO_RX1_DAT : GPIO_RX_DAT)
+#define GPIO_RX_DAT_REG(offset) (((offset) >= 64) ? GPIO_RX1_DAT : GPIO_RX_DAT)
 
 /** Returns the bit configuration register based on the offset */
 #define GPIO_BIT_CFG(x)		(0x400 + 8 * (x))
@@ -66,16 +66,17 @@ struct octeontx_gpio {
 	void __iomem *baseaddr;
 };
 
-static int octeontx_gpio_dir_input(struct udevice *dev, unsigned offset)
+static int octeontx_gpio_dir_input(struct udevice *dev, unsigned int offset)
 {
 	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
 	debug("%s(%s, %u)\n", __func__, dev->name, offset);
 	clrbits_le64(gpio->baseaddr + GPIO_BIT_CFG(offset),
 		     (0x3ffUL << 16) | 4UL | 2UL | 1UL);
 	return 0;
 }
 
-static int octeontx_gpio_dir_output(struct udevice *dev, unsigned offset,
+static int octeontx_gpio_dir_output(struct udevice *dev, unsigned int offset,
 				    int value)
 {
 	struct octeontx_gpio *gpio = dev_get_priv(dev);
@@ -89,7 +90,7 @@ static int octeontx_gpio_dir_output(struct udevice *dev, unsigned offset,
 }
 
 static int octeontx_gpio_get_value(struct udevice *dev,
-				   unsigned offset)
+				   unsigned int offset)
 {
 	struct octeontx_gpio *gpio = dev_get_priv(dev);
 	u64 reg = readq(gpio->baseaddr + GPIO_RX_DAT_REG(offset));
@@ -101,7 +102,7 @@ static int octeontx_gpio_get_value(struct udevice *dev,
 }
 
 static int octeontx_gpio_set_value(struct udevice *dev,
-				   unsigned offset, int value)
+				   unsigned int offset, int value)
 {
 	struct octeontx_gpio *gpio = dev_get_priv(dev);
 
@@ -109,14 +110,14 @@ static int octeontx_gpio_set_value(struct udevice *dev,
 	writeq(GPIO_BIT(offset), gpio->baseaddr + GPIO_TX_REG(offset, value));
 
 	return 0;
-
 }
 
 static int octeontx_gpio_get_function(struct udevice *dev,
-				      unsigned offset)
+				      unsigned int offset)
 {
 	struct octeontx_gpio *gpio = dev_get_priv(dev);
 	u64 pinsel = readl(gpio->baseaddr + GPIO_BIT_CFG(offset));
+
 	debug("%s(%s, %u): pinsel: 0x%llx\n", __func__, dev->name, offset,
 	      pinsel);
 	if (GPIO_BIT_CFG_FN(pinsel))
@@ -128,7 +129,7 @@ static int octeontx_gpio_get_function(struct udevice *dev,
 }
 
 static int octeontx_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
-			    struct ofnode_phandle_args *args)
+			       struct ofnode_phandle_args *args)
 {
 	if (args->args_count < 1)
 		return -EINVAL;
@@ -194,7 +195,6 @@ static int octeontx_gpio_probe(struct udevice *dev)
 	return 0;
 }
 
-
 static const struct udevice_id octeontx_gpio_ids[] = {
 	{ .compatible = "cavium,thunder-8890-gpio" },
 	{ .compatible = "cavium,gpio" },
diff --git a/drivers/i2c/octeontx_i2c.c b/drivers/i2c/octeontx_i2c.c
index 958c1daac6..2fecbd01b5 100644
--- a/drivers/i2c/octeontx_i2c.c
+++ b/drivers/i2c/octeontx_i2c.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -103,24 +103,24 @@ union twsx_sw_twsi {
 union twsx_sw_twsi_ext {
 	u64 u;
 	struct {
-		u64	data:32;
-		u64	ia:8;
-		u64	:24;
+		u64 data:32;
+		u64 ia:8;
+		u64 rsvd:24;
 	} s;
 };
 
 union twsx_int {
 	u64 u;
 	struct {
-		u64	st_int:1;	/** TWSX_SW_TWSI register update int */
-		u64	ts_int:1;	/** TWSX_TWSI_SW register update int */
-		u64	core_int:1;	/** TWSI core interrupt, ignored for HLC */
-		u64	:5;		/** Reserved */
-		u64	sda_ovr:1;	/** SDA testing override */
-		u64	scl_ovr:1;	/** SCL testing override */
-		u64	sda:1;		/** SDA signal */
-		u64	scl:1;		/** SCL signal */
-		u64	:52;		/** Reserved */
+		u64 st_int:1;	/** TWSX_SW_TWSI register update int */
+		u64 ts_int:1;	/** TWSX_TWSI_SW register update int */
+		u64 core_int:1;	/** TWSI core interrupt, ignored for HLC */
+		u64 rsvd1:5;		/** Reserved */
+		u64 sda_ovr:1;	/** SDA testing override */
+		u64 scl_ovr:1;	/** SCL testing override */
+		u64 sda:1;		/** SDA signal */
+		u64 scl:1;		/** SCL signal */
+		u64 rsvd2:52;		/** Reserved */
 	} s;
 };
 
@@ -237,7 +237,7 @@ struct octeontx_twsi {
 };
 
 /** Array of bus speeds */
-static unsigned speeds[] = {
+static unsigned int speeds[] = {
 	CONFIG_SYS_I2C_OCTEONTX_SPEED_0,
 	CONFIG_SYS_I2C_OCTEONTX_SPEED_1,
 	CONFIG_SYS_I2C_OCTEONTX_SPEED_2,
@@ -253,12 +253,11 @@ static unsigned speeds[] = {
 };
 
 /** Last i2c id assigned */
-static int last_id = 0;
+static int last_id;
 
 static void twsi_unblock(void *baseaddr);
 static int twsi_stop(void *baseaddr);
 
-
 /**
  * Converts the i2c status to a meaningful string
  *
@@ -388,7 +387,7 @@ static int twsi_i2c_lost_arb(u8 code, int final_read)
 	return 0;
 }
 
-#define RST_BOOT_PNR_MUL(Val)  ((Val >> 33) & 0x1F)
+#define RST_BOOT_PNR_MUL(val)  (((val) >> 33) & 0x1F)
 
 /**
  * Writes to the MIO_TWS(0..5)_SW_TWSI register
@@ -427,6 +426,7 @@ static u64 twsi_write_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
 static u64 twsi_read_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
 {
 	unsigned long start = get_timer(0);
+
 	sw_twsi.s.r = 1;
 	sw_twsi.s.v = 1;
 
@@ -580,6 +580,7 @@ static int twsi_start(void *baseaddr)
 static int twsi_stop(void *baseaddr)
 {
 	u8 stat;
+
 	twsi_write_ctl(baseaddr, TWSI_CTL_STP | TWSI_CTL_ENAB);
 
 	stat = twsi_read_status(baseaddr);
@@ -624,7 +625,7 @@ static int twsi_write_data(void *baseaddr, u8  slave_addr,
 	twsi_sw.u	 = 0;
 	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
 	twsi_sw.s.eop_ia = TWSI_DATA;
-	twsi_sw.s.data	 = (u32) (slave_addr << 1) | TWSI_OP_WRITE;
+	twsi_sw.s.data	 = (u32)(slave_addr << 1) | TWSI_OP_WRITE;
 
 	twsi_write_sw(baseaddr, twsi_sw);
 	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
@@ -639,7 +640,7 @@ static int twsi_write_data(void *baseaddr, u8  slave_addr,
 	result = twsi_read_status(baseaddr);
 	debug("%s: status: (%d) %s\n", __func__, result,
 	      twsi_i2c_status_str(result));
-	if ((result = twsi_read_status(baseaddr)) != TWSI_STAT_TXADDR_ACK) {
+	if (result != TWSI_STAT_TXADDR_ACK) {
 		debug("%s: status: (%d) %s\n", __func__, result,
 		      twsi_i2c_status_str(result));
 		twsi_stop(baseaddr);
@@ -735,7 +736,7 @@ static int twsi_read_data(void *baseaddr, u8 slave_addr,
 	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
 	twsi_sw.s.eop_ia = TWSI_DATA;
 
-	twsi_sw.s.data  = (u32) (slave_addr << 1) | TWSI_OP_READ;
+	twsi_sw.s.data  = (u32)(slave_addr << 1) | TWSI_OP_READ;
 
 	twsi_write_sw(baseaddr, twsi_sw);
 	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
@@ -835,7 +836,6 @@ static int twsi_init(void *baseaddr, unsigned int speed, int slaveaddr)
 	debug("%s: Writing 0x%llx to sw_twsi, m_div: 0x%x, n_div: 0x%x\n",
 	      __func__, sw_twsi.u, m_div, n_div);
 
-
 	sw_twsi.u = 0;
 	sw_twsi.s.v = 1;
 	sw_twsi.s.op = TWSI_SW_EOP_IA;
@@ -872,21 +872,21 @@ static int octeontx_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
 	struct octeontx_twsi *twsi = dev_get_priv(bus);
 	int result;
 
-	debug("octeontx_i2c_xfer: %d messages\n", nmsgs);
+	debug("%s: %d messages\n", __func__, nmsgs);
 	for (; nmsgs > 0; nmsgs--, msg++) {
-		debug("octeontx_i2c_xfer: chip=0x%x, len=0x%x\n",
-		      msg->addr, msg->len);
+		debug("%s: chip=0x%x, len=0x%x\n", __func__, msg->addr,
+		      msg->len);
 		if (msg->flags & I2C_M_RD) {
 			debug("%s: Reading data\n", __func__);
 			result = twsi_read_data(twsi->baseaddr, msg->addr,
-					     msg->buf, msg->len);
+						msg->buf, msg->len);
 		} else {
 			debug("%s: Writing data\n", __func__);
 			result = twsi_write_data(twsi->baseaddr, msg->addr,
-					      msg->buf, msg->len);
+						 msg->buf, msg->len);
 		}
 		if (result) {
-			debug("octeontx_i2c_xfer: error sending\n");
+			debug("%s: error sending\n", __func__);
 			return -EREMOTEIO;
 		}
 	}
@@ -933,7 +933,7 @@ static int octeontx_pci_i2c_probe(struct udevice *dev)
 	twsi->baseaddr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
 	twsi->id = last_id++;
 
-	debug("TWSI bus %d at %p\n",dev->seq, twsi->baseaddr);
+	debug("TWSI bus %d at %p\n", dev->seq, twsi->baseaddr);
 
 	return twsi_init(twsi->baseaddr,
 			 twsi->id < ARRAY_SIZE(speeds) ?
diff --git a/drivers/mmc/octeontx_hsmmc.c b/drivers/mmc/octeontx_hsmmc.c
index 3c8d1dfee9..01596334c2 100644
--- a/drivers/mmc/octeontx_hsmmc.c
+++ b/drivers/mmc/octeontx_hsmmc.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
- * Copyright (C) 2019 Marvell International Ltd.
+ * Copyright (C) 201i9 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -17,8 +17,7 @@
 #include <pci.h>
 #include <linux/libfdt.h>
 #include <fdtdec.h>
-#include <asm/arch/fdt-helper.h>
-#include <asm/arch/cavm-csrs-mio_emm.h>
+#include <asm/arch/csrs/csrs-mio_emm.h>
 #include <asm/arch/clock.h>
 #include <linux/list.h>
 #include <div64.h>
@@ -70,7 +69,7 @@ static int octeontx_mmc_configure_delay(struct mmc *mmc);
 static void octeontx_mmc_set_timing(struct mmc *mmc);
 #endif
 static void set_wdog(struct mmc *mmc, u64 us);
-static void do_switch(struct mmc *mmc, union cavm_mio_emm_switch emm_switch);
+static void do_switch(struct mmc *mmc, union mio_emm_switch emm_switch);
 static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 				 struct mmc_data *data);
 #ifndef CONFIG_ARCH_OCTEONTX
@@ -108,62 +107,62 @@ static inline struct mmc *dev_to_mmc(struct udevice *dev)
 #ifdef DEBUG
 const char *mmc_reg_str(u64 reg)
 {
-	if (reg == CAVM_MIO_EMM_DMA_CFG())
+	if (reg == MIO_EMM_DMA_CFG())
 		return "MIO_EMM_DMA_CFG";
-	if (reg == CAVM_MIO_EMM_DMA_ADR())
+	if (reg == MIO_EMM_DMA_ADR())
 		return "MIO_EMM_DMA_ADR";
-	if (reg == CAVM_MIO_EMM_DMA_INT())
+	if (reg == MIO_EMM_DMA_INT())
 		return "MIO_EMM_DMA_INT";
-	if (reg == CAVM_MIO_EMM_CFG())
+	if (reg == MIO_EMM_CFG())
 		return "MIO_EMM_CFG";
-	if (reg == CAVM_MIO_EMM_MODEX(0))
+	if (reg == MIO_EMM_MODEX(0))
 		return "MIO_EMM_MODE0";
-	if (reg == CAVM_MIO_EMM_MODEX(1))
+	if (reg == MIO_EMM_MODEX(1))
 		return "MIO_EMM_MODE1";
-	if (reg == CAVM_MIO_EMM_MODEX(2))
+	if (reg == MIO_EMM_MODEX(2))
 		return "MIO_EMM_MODE2";
-	if (reg == CAVM_MIO_EMM_MODEX(3))
+	if (reg == MIO_EMM_MODEX(3))
 		return "MIO_EMM_MODE3";
-	if (reg == CAVM_MIO_EMM_IO_CTL())
+	if (reg == MIO_EMM_IO_CTL())
 		return "MIO_EMM_IO_CTL";
-	if (reg == CAVM_MIO_EMM_SWITCH())
+	if (reg == MIO_EMM_SWITCH())
 		return "MIO_EMM_SWITCH";
-	if (reg == CAVM_MIO_EMM_DMA())
+	if (reg == MIO_EMM_DMA())
 		return "MIO_EMM_DMA";
-	if (reg == CAVM_MIO_EMM_CMD())
+	if (reg == MIO_EMM_CMD())
 		return "MIO_EMM_CMD";
-	if (reg == CAVM_MIO_EMM_RSP_STS())
+	if (reg == MIO_EMM_RSP_STS())
 		return "MIO_EMM_RSP_STS";
-	if (reg == CAVM_MIO_EMM_RSP_LO())
+	if (reg == MIO_EMM_RSP_LO())
 		return "MIO_EMM_RSP_LO";
-	if (reg == CAVM_MIO_EMM_RSP_HI())
+	if (reg == MIO_EMM_RSP_HI())
 		return "MIO_EMM_RSP_HI";
-	if (reg == CAVM_MIO_EMM_INT())
+	if (reg == MIO_EMM_INT())
 		return "MIO_EMM_INT";
-	if (reg == CAVM_MIO_EMM_WDOG())
+	if (reg == MIO_EMM_WDOG())
 		return "MIO_EMM_WDOG";
-	if (reg == CAVM_MIO_EMM_DMA_ARG())
+	if (reg == MIO_EMM_DMA_ARG())
 		return "MIO_EMM_DMA_ARG";
 #if defined(CONFIG_ARCH_OCTEONTX)
-	if (reg == CAVM_MIO_EMM_SAMPLE())
+	if (reg == MIO_EMM_SAMPLE())
 		return "MIO_EMM_SAMPLE";
 #endif
-	if (reg == CAVM_MIO_EMM_STS_MASK())
+	if (reg == MIO_EMM_STS_MASK())
 		return "MIO_EMM_STS_MASK";
-	if (reg == CAVM_MIO_EMM_RCA())
+	if (reg == MIO_EMM_RCA())
 		return "MIO_EMM_RCA";
-	if (reg == CAVM_MIO_EMM_BUF_IDX())
+	if (reg == MIO_EMM_BUF_IDX())
 		return "MIO_EMM_BUF_IDX";
-	if (reg == CAVM_MIO_EMM_BUF_DAT())
+	if (reg == MIO_EMM_BUF_DAT())
 		return "MIO_EMM_BUF_DAT";
 #if !defined(CONFIG_ARCH_OCTEONTX)
-	if (reg == CAVM_MIO_EMM_CALB())
+	if (reg == MIO_EMM_CALB())
 		return "MIO_EMM_CALB";
-	if (reg == CAVM_MIO_EMM_TAP())
+	if (reg == MIO_EMM_TAP())
 		return "MIO_EMM_TAP";
-	if (reg == CAVM_MIO_EMM_TIMING())
+	if (reg == MIO_EMM_TIMING())
 		return "MIO_EMM_TIMING";
-	if (reg == CAVM_MIO_EMM_DEBUG())
+	if (reg == MIO_EMM_DEBUG())
 		return "MIO_EMM_DEBUG";
 #endif
 	return "UNKNOWN";
@@ -173,7 +172,7 @@ const char *mmc_reg_str(u64 reg)
 static void octeontx_print_rsp_sts(struct mmc *mmc)
 {
 #ifdef DEBUG
-	union cavm_mio_emm_rsp_sts emm_rsp_sts;
+	union mio_emm_rsp_sts emm_rsp_sts;
 	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
 	static const char * const ctype_xor_str[] = {
 		"No data",
@@ -193,7 +192,7 @@ static void octeontx_print_rsp_sts(struct mmc *mmc)
 		"Reserved 7"
 	};
 
-	emm_rsp_sts.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_STS());
+	emm_rsp_sts.u = readq(host->base_addr + MIO_EMM_RSP_STS());
 	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
 	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
 	printf("    59:    cmd_val:             %s\n",
@@ -345,30 +344,30 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 					  struct octeontx_mmc_host *host)
 {
 	struct octeontx_mmc_slot *slot = mmc ? mmc->priv : NULL;
-	union cavm_mio_emm_dma_cfg emm_dma_cfg;
-	union cavm_mio_emm_dma_adr emm_dma_adr;
-	union cavm_mio_emm_dma_int emm_dma_int;
-	union cavm_mio_emm_cfg emm_cfg;
-	union cavm_mio_emm_modex emm_mode;
-	union cavm_mio_emm_switch emm_switch;
-	union cavm_mio_emm_dma emm_dma;
-	union cavm_mio_emm_cmd emm_cmd;
-	union cavm_mio_emm_rsp_sts emm_rsp_sts;
-	union cavm_mio_emm_rsp_lo emm_rsp_lo;
-	union cavm_mio_emm_rsp_hi emm_rsp_hi;
-	union cavm_mio_emm_int emm_int;
-	union cavm_mio_emm_wdog emm_wdog;
+	union mio_emm_dma_cfg emm_dma_cfg;
+	union mio_emm_dma_adr emm_dma_adr;
+	union mio_emm_dma_int emm_dma_int;
+	union mio_emm_cfg emm_cfg;
+	union mio_emm_modex emm_mode;
+	union mio_emm_switch emm_switch;
+	union mio_emm_dma emm_dma;
+	union mio_emm_cmd emm_cmd;
+	union mio_emm_rsp_sts emm_rsp_sts;
+	union mio_emm_rsp_lo emm_rsp_lo;
+	union mio_emm_rsp_hi emm_rsp_hi;
+	union mio_emm_int emm_int;
+	union mio_emm_wdog emm_wdog;
 #if defined(CONFIG_ARCH_OCTEONTX)
-	union cavm_mio_emm_sample emm_sample;
+	union mio_emm_sample emm_sample;
 #else
-	union cavm_mio_emm_calb emm_calb;
-	union cavm_mio_emm_tap emm_tap;
-	union cavm_mio_emm_timing emm_timing;
-	union cavm_mio_emm_io_ctl io_ctl;
-	union cavm_mio_emm_debug emm_debug;
+	union mio_emm_calb emm_calb;
+	union mio_emm_tap emm_tap;
+	union mio_emm_timing emm_timing;
+	union mio_emm_io_ctl io_ctl;
+	union mio_emm_debug emm_debug;
 #endif
-	union cavm_mio_emm_sts_mask emm_sts_mask;
-	union cavm_mio_emm_rca emm_rca;
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_rca emm_rca;
 	int bus;
 
 	static const char * const bus_width_str[] = {
@@ -412,7 +411,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 
 	if (mmc)
 		printf("%s: bus id: %u\n", __func__, slot->bus_id);
-	emm_dma_cfg.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_CFG());
+	emm_dma_cfg.u = readq(host->base_addr + MIO_EMM_DMA_CFG());
 	printf("MIO_EMM_DMA_CFG:                0x%016llx\n",
 	       emm_dma_cfg.u);
 	printf("    63:    en:                  %s\n",
@@ -432,19 +431,19 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    36-55: size:                %u\n",
 	       emm_dma_cfg.s.size);
 
-	emm_dma_adr.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_ADR());
+	emm_dma_adr.u = readq(host->base_addr + MIO_EMM_DMA_ADR());
 	printf("MIO_EMM_DMA_ADR:              0x%016llx\n", emm_dma_adr.u);
 	printf("    0-49:  adr:                 0x%llx\n",
 	       (u64)emm_dma_adr.s.adr);
 
-	emm_dma_int.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_INT());
+	emm_dma_int.u = readq(host->base_addr + MIO_EMM_DMA_INT());
 	printf("\nMIO_EMM_DMA_INT:              0x%016llx\n",
 	       emm_dma_int.u);
 	printf("    1:     FIFO:                %s\n",
 	       emm_dma_int.s.fifo ? "yes" : "no");
 	printf("    0:     Done:                %s\n",
 	       emm_dma_int.s.done ? "yes" : "no");
-		emm_cfg.u = readq(host->base_addr + CAVM_MIO_EMM_CFG());
+		emm_cfg.u = readq(host->base_addr + MIO_EMM_CFG());
 
 	printf("\nMIO_EMM_CFG:                  0x%016llx\n",
 	       emm_cfg.u);
@@ -457,7 +456,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    0:     bus_ena0:            %s\n",
 	       emm_cfg.s.bus_ena & 0x01 ? "yes" : "no");
 	for (bus = 0; bus < 4; bus++) {
-		emm_mode.u = readq(host->base_addr + CAVM_MIO_EMM_MODEX(bus));
+		emm_mode.u = readq(host->base_addr + MIO_EMM_MODEX(bus));
 		printf("\nMIO_EMM_MODE%u:               0x%016llx\n",
 		       bus, emm_mode.u);
 #ifndef CONFIG_ARCH_OCTEONTX
@@ -478,7 +477,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 		       emm_mode.s.clk_lo);
 	}
 
-	emm_switch.u = readq(host->base_addr + CAVM_MIO_EMM_SWITCH());
+	emm_switch.u = readq(host->base_addr + MIO_EMM_SWITCH());
 	printf("\nMIO_EMM_SWITCH:               0x%016llx\n", emm_switch.u);
 	printf("    60-61: bus_id:              %u\n", emm_switch.s.bus_id);
 	printf("    59:    switch_exe:          %s\n",
@@ -499,7 +498,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	       emm_switch.s.clk_hi);
 	printf("    0-15:  clk_lo:              %u\n", emm_switch.s.clk_lo);
 
-	emm_dma.u = readq(host->base_addr + CAVM_MIO_EMM_DMA());
+	emm_dma.u = readq(host->base_addr + MIO_EMM_DMA());
 	printf("\nMIO_EMM_DMA:                  0x%016llx\n", emm_dma.u);
 	printf("    60-61: bus_id:              %u\n", emm_dma.s.bus_id);
 	printf("    59:    dma_val:             %s\n",
@@ -520,7 +519,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    0-31:  card_addr:           0x%x\n",
 	       emm_dma.s.card_addr);
 
-	emm_cmd.u = readq(host->base_addr + CAVM_MIO_EMM_CMD());
+	emm_cmd.u = readq(host->base_addr + MIO_EMM_CMD());
 	printf("\nMIO_EMM_CMD:                  0x%016llx\n", emm_cmd.u);
 	printf("\n  62:    skip_busy:           %s\n",
 	       emm_cmd.s.skip_busy ? "yes" : "no");
@@ -536,7 +535,7 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    32-37: cmd_idx:             %u\n", emm_cmd.s.cmd_idx);
 	printf("    0-31:  arg:                 0x%x\n", emm_cmd.s.arg);
 
-	emm_rsp_sts.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_STS());
+	emm_rsp_sts.u = readq(host->base_addr + MIO_EMM_RSP_STS());
 	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
 	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
 	printf("    59:    cmd_val:             %s\n",
@@ -581,13 +580,13 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    0:     cmd_done:            %s\n",
 	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
 
-	emm_rsp_lo.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_LO());
+	emm_rsp_lo.u = readq(host->base_addr + MIO_EMM_RSP_LO());
 	printf("\nMIO_EMM_RSP_STS_LO:           0x%016llx\n", emm_rsp_lo.u);
 
-	emm_rsp_hi.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_HI());
+	emm_rsp_hi.u = readq(host->base_addr + MIO_EMM_RSP_HI());
 	printf("\nMIO_EMM_RSP_STS_HI:           0x%016llx\n", emm_rsp_hi.u);
 
-	emm_int.u = readq(host->base_addr + CAVM_MIO_EMM_INT());
+	emm_int.u = readq(host->base_addr + MIO_EMM_INT());
 	printf("\nMIO_EMM_INT:                  0x%016llx\n", emm_int.u);
 	printf("    6:    switch_err:           %s\n",
 	       emm_int.s.switch_err ? "yes" : "no");
@@ -604,32 +603,32 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	printf("    0:    buf_done:             %s\n",
 	       emm_int.s.buf_done ? "yes" : "no");
 
-	emm_wdog.u = readq(host->base_addr + CAVM_MIO_EMM_WDOG());
+	emm_wdog.u = readq(host->base_addr + MIO_EMM_WDOG());
 	printf("\nMIO_EMM_WDOG:                 0x%016llx (%u)\n",
 	       emm_wdog.u, emm_wdog.s.clk_cnt);
 
 #if defined(CONFIG_ARCH_OCTEONTX)
-	emm_sample.u = readq(host->base_addr + CAVM_MIO_EMM_SAMPLE());
+	emm_sample.u = readq(host->base_addr + MIO_EMM_SAMPLE());
 	printf("\nMIO_EMM_SAMPLE:               0x%016llx\n", emm_sample.u);
 	printf("    16-25: cmd_cnt:             %u\n", emm_sample.s.cmd_cnt);
 	printf("    0-9:   dat_cnt:             %u\n", emm_sample.s.dat_cnt);
 #endif
 
-	emm_sts_mask.u = readq(host->base_addr + CAVM_MIO_EMM_STS_MASK());
+	emm_sts_mask.u = readq(host->base_addr + MIO_EMM_STS_MASK());
 	printf("\nMIO_EMM_STS_MASK:             0x%016llx\n", emm_sts_mask.u);
 
-	emm_rca.u = readq(host->base_addr + CAVM_MIO_EMM_RCA());
+	emm_rca.u = readq(host->base_addr + MIO_EMM_RCA());
 	printf("\nMIO_EMM_RCA:                  0x%016llx\n", emm_rca.u);
 	printf("    0-15:  card_rca:            0x%04x\n",
 	       emm_rca.s.card_rca);
 #if !defined(CONFIG_ARCH_OCTEONTX)
-	emm_calb.u = readq(host->base_addr + CAVM_MIO_EMM_CALB());
+	emm_calb.u = readq(host->base_addr + MIO_EMM_CALB());
 	printf("\nMIO_EMM_CALB:                 0x%016llx\n", emm_calb.u);
 	printf("       0:  start:               %u\n", emm_calb.s.start);
-	emm_tap.u = readq(host->base_addr + CAVM_MIO_EMM_TAP());
+	emm_tap.u = readq(host->base_addr + MIO_EMM_TAP());
 	printf("\nMIO_EMM_TAP:                  0x%016llx\n", emm_tap.u);
 	printf("     7-0:  delay:               %u\n", emm_tap.s.delay);
-	emm_timing.u = readq(host->base_addr + CAVM_MIO_EMM_TIMING());
+	emm_timing.u = readq(host->base_addr + MIO_EMM_TIMING());
 	printf("\nMIO_EMM_TIMING:               0x%016llx\n", emm_timing.u);
 	printf("   53-48:  cmd_in_tap:          %u\n",
 	       emm_timing.s.cmd_in_tap);
@@ -639,13 +638,13 @@ static void octeontx_mmc_print_registers2(struct mmc *mmc,
 	       emm_timing.s.data_in_tap);
 	printf("     5-0:  data_out_tap:        %u\n",
 	       emm_timing.s.data_out_tap);
-	io_ctl.u = readq(host->base_addr + CAVM_MIO_EMM_IO_CTL());
+	io_ctl.u = readq(host->base_addr + MIO_EMM_IO_CTL());
 	printf("\nMIO_IO_CTL:                   0x%016llx\n", io_ctl.u);
 	printf("     3-2:  drive:               %u (%u mA)\n",
 	       io_ctl.s.drive, 2 << io_ctl.s.drive);
 	printf("       0:  slew:                %u %s\n", io_ctl.s.slew,
 	       io_ctl.s.slew ? "high" : "low");
-	emm_debug.u = readq(host->base_addr + CAVM_MIO_EMM_DEBUG());
+	emm_debug.u = readq(host->base_addr + MIO_EMM_DEBUG());
 	printf("\nMIO_EMM_DEBUG:                0x%016llx\n", emm_debug.u);
 	printf("   19-16: dma_sm:               0x%x\n", emm_debug.s.dma_sm);
 	printf("   15-12: data_sm:              0x%x\n", emm_debug.s.data_sm);
@@ -849,7 +848,7 @@ static void octeontx_mmc_track_switch(struct mmc *mmc, u32 cmd_arg)
 }
 
 static int octeontx_mmc_print_rsp_errors(struct mmc *mmc,
-					 union cavm_mio_emm_rsp_sts rsp_sts)
+					 union mio_emm_rsp_sts rsp_sts)
 {
 	bool err = false;
 	const char *name = mmc->dev->name;
@@ -903,13 +902,13 @@ static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
 				   u32 size, int timeout)
 {
 	const struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_dma_cfg emm_dma_cfg;
-	union cavm_mio_emm_dma_adr emm_dma_adr;
-	union cavm_mio_emm_dma emm_dma;
+	union mio_emm_dma_cfg emm_dma_cfg;
+	union mio_emm_dma_adr emm_dma_adr;
+	union mio_emm_dma emm_dma;
 
 	/* Clear any interrupts */
-	write_csr(mmc, CAVM_MIO_EMM_DMA_INT(),
-		  read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
+	write_csr(mmc, MIO_EMM_DMA_INT(),
+		  read_csr(mmc, MIO_EMM_DMA_INT()));
 
 	emm_dma_cfg.u = 0;
 	emm_dma_cfg.s.en = 1;
@@ -921,8 +920,8 @@ static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
 #endif
 	emm_dma_adr.u = 0;
 	emm_dma_adr.s.adr = adr;
-	write_csr(mmc, CAVM_MIO_EMM_DMA_ADR(), emm_dma_adr.u);
-	write_csr(mmc, CAVM_MIO_EMM_DMA_CFG(), emm_dma_cfg.u);
+	write_csr(mmc, MIO_EMM_DMA_ADR(), emm_dma_adr.u);
+	write_csr(mmc, MIO_EMM_DMA_CFG(), emm_dma_cfg.u);
 
 	emm_dma.u = 0;
 	emm_dma.s.bus_id = slot->bus_id;
@@ -930,7 +929,7 @@ static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
 	emm_dma.s.rw = !!write;
 	emm_dma.s.sector = mmc->high_capacity ? 1 : 0;
 
-	if ((size > 1) && ((IS_SD(mmc) && (mmc->scr[0] & 2)) || !IS_SD(mmc)))
+	if (size > 1 && ((IS_SD(mmc) && (mmc->scr[0] & 2)) || !IS_SD(mmc)))
 		emm_dma.s.multi = 1;
 	else
 		emm_dma.s.multi = 0;
@@ -947,7 +946,7 @@ static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
 	set_wdog(mmc, timeout);
 
 	debug("  Writing 0x%llx to mio_emm_dma\n", emm_dma.u);
-	write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+	write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
 }
 
 /**
@@ -966,33 +965,33 @@ static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
  * @param	rsp_sts	rsp status
  */
 static void octeontx_mmc_cleanup_dma(struct mmc *mmc,
-				     union cavm_mio_emm_rsp_sts rsp_sts)
+				     union mio_emm_rsp_sts rsp_sts)
 {
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_dma emm_dma;
+	union mio_emm_dma emm_dma;
 	ulong start;
 
 	debug("%s(%s): rsp_sts: 0x%llx, rsp_lo: 0x%llx, dma_int: 0x%llx\n",
 	      __func__, mmc->dev->name, rsp_sts.u,
-	      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
-	      read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
-	emm_dma.u = read_csr(mmc, CAVM_MIO_EMM_DMA());
+	      read_csr(mmc, MIO_EMM_RSP_LO()),
+	      read_csr(mmc, MIO_EMM_DMA_INT()));
+	emm_dma.u = read_csr(mmc, MIO_EMM_DMA());
 	emm_dma.s.dma_val = 1;
 	emm_dma.s.dat_null = 1;
 	emm_dma.s.bus_id = slot->bus_id;
-	write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+	write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
 	start = get_timer(0);
 	do {
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		WATCHDOG_RESET();
 	} while (get_timer(start) < 100 && rsp_sts.s.dma_val);
 	if (rsp_sts.s.dma_val) {
 		pr_err("%s(%s): Error: could not clean up DMA.  RSP_STS: 0x%llx, RSP_LO: 0x%llx\n",
 		       __func__, mmc->dev->name, rsp_sts.u,
-		       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+		       read_csr(mmc, MIO_EMM_RSP_LO()));
 	}
 	debug("  rsp_sts after clearing up DMA: 0x%llx\n",
-	      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()));
+	      read_csr(mmc, MIO_EMM_RSP_STS()));
 }
 
 /**
@@ -1007,16 +1006,17 @@ static void octeontx_mmc_cleanup_dma(struct mmc *mmc,
 static int octeontx_mmc_wait_dma(struct mmc *mmc, bool write, ulong timeout)
 {
 	ulong start_time = get_timer(0);
-	union cavm_mio_emm_dma_int emm_dma_int;
-	union cavm_mio_emm_rsp_sts rsp_sts;
-	union cavm_mio_emm_dma emm_dma;
+	union mio_emm_dma_int emm_dma_int;
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_dma emm_dma;
 	bool timed_out = false;
 	bool err = false;
+
 	debug("%s(%s, %lu)\n", __func__, mmc->dev->name, timeout);
 
 	do {
-		emm_dma_int.u = read_csr(mmc, CAVM_MIO_EMM_DMA_INT());
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		emm_dma_int.u = read_csr(mmc, MIO_EMM_DMA_INT());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		if (write) {
 			if ((rsp_sts.s.dma_pend && !rsp_sts.s.dma_val) ||
 			    rsp_sts.s.blk_timeout ||
@@ -1043,16 +1043,16 @@ static int octeontx_mmc_wait_dma(struct mmc *mmc, bool write, ulong timeout)
 			 * If this is set then an error has occurred.
 			 * Try and restart the DMA operation.
 			 */
-			emm_dma.u = read_csr(mmc, CAVM_MIO_EMM_DMA());
+			emm_dma.u = read_csr(mmc, MIO_EMM_DMA());
 			pr_err("%s(%s): DMA pending error: rsp_sts: 0x%llx, dma_int: 0x%llx, emm_dma: 0x%llx\n",
 			       __func__, mmc->dev->name, rsp_sts.u,
 			       emm_dma_int.u, emm_dma.u);
 			octeontx_print_rsp_sts(mmc);
 			debug("  MIO_EMM_DEBUG: 0x%llx\n",
-			      read_csr(mmc, CAVM_MIO_EMM_DEBUG()));
+			      read_csr(mmc, MIO_EMM_DEBUG()));
 			pr_err("%s: Trying DMA resume...\n", __func__);
 			emm_dma.s.dma_val = 1;
-			write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+			write_csr(mmc, MIO_EMM_DMA(), emm_dma.u);
 		} else if (!rsp_sts.s.dma_val && emm_dma_int.s.done) {
 			break;
 		}
@@ -1066,14 +1066,14 @@ static int octeontx_mmc_wait_dma(struct mmc *mmc, bool write, ulong timeout)
 			timed_out ? "timed out" : "error",
 			get_timer(start_time), rsp_sts.u,
 		       emm_dma_int.u,
-		       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
-		       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+		       read_csr(mmc, MIO_EMM_RSP_LO()),
+		       read_csr(mmc, MIO_EMM_DMA()));
 		octeontx_print_rsp_sts(mmc);
 		if (rsp_sts.s.dma_pend)
 			octeontx_mmc_cleanup_dma(mmc, rsp_sts);
 	} else {
-		write_csr(mmc, CAVM_MIO_EMM_DMA_INT(),
-			  read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
+		write_csr(mmc, MIO_EMM_DMA_INT(),
+			  read_csr(mmc, MIO_EMM_DMA_INT()));
 	}
 
 	return timed_out ? -ETIMEDOUT : (err ? -EIO : 0);
@@ -1092,7 +1092,7 @@ static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 				    struct mmc_data *data)
 {
 	struct octeontx_mmc_host *host = mmc_to_host(mmc);
-	union cavm_mio_emm_rsp_sts rsp_sts;
+	union mio_emm_rsp_sts rsp_sts;
 	dma_addr_t dma_addr = (dma_addr_t)dm_pci_virt_to_mem(host->dev,
 							     data->dest);
 	ulong count;
@@ -1105,7 +1105,7 @@ static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 	debug("%s(%s): dest: %p, dma address: 0x%llx, blkcnt: %lu, start: %lu\n",
 	      __func__, mmc->dev->name, data->dest, dma_addr, blkcnt, start);
 	debug("%s: rsp_sts: 0x%llx\n", __func__,
-	      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()));
+	      read_csr(mmc, MIO_EMM_RSP_STS()));
 	/* use max timeout for multi-block transfers */
 	/* timeout = 0; */
 
@@ -1114,7 +1114,7 @@ static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 	 * mask to check for CRC errors and timeouts only.
 	 * Otherwise, use the default power on reset value.
 	 */
-	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(),
+	write_csr(mmc, MIO_EMM_STS_MASK(),
 		  IS_SD(mmc) ? 0x00b00000ull : 0xe4390080ull);
 	invalidate_dcache_range((u64)data->dest,
 				(u64)data->dest + blkcnt * data->blocksize);
@@ -1123,13 +1123,13 @@ static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 		octeontx_mmc_start_dma(mmc, false, false, start, dma_addr,
 				       blkcnt, timeout);
 		timed_out = !!octeontx_mmc_wait_dma(mmc, false, timeout);
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
 			pr_err("%s(%s): Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
 			       __func__, mmc->dev->name, rsp_sts.u,
-			       read_csr(mmc, CAVM_MIO_EMM_INT()),
-			       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
-			       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+			       read_csr(mmc, MIO_EMM_INT()),
+			       read_csr(mmc, MIO_EMM_DMA_INT()),
+			       read_csr(mmc, MIO_EMM_RSP_LO()));
 			pr_err("%s: block count: %lu, start: 0x%lx\n",
 			       __func__, blkcnt, start);
 			octeontx_mmc_print_registers(mmc);
@@ -1146,14 +1146,14 @@ static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 
 			timed_out = !!octeontx_mmc_wait_dma(mmc, false,
 							    timeout);
-			rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+			rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 			if (timed_out || rsp_sts.s.dma_val ||
 			    rsp_sts.s.dma_pend) {
 				pr_err("%s: Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
 				       __func__, rsp_sts.u,
-				       read_csr(mmc, CAVM_MIO_EMM_INT()),
-				       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
-				       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+				       read_csr(mmc, MIO_EMM_INT()),
+				       read_csr(mmc, MIO_EMM_DMA_INT()),
+				       read_csr(mmc, MIO_EMM_RSP_LO()));
 				pr_err("%s: block count: 1, start: 0x%lx\n",
 				       __func__, start);
 				octeontx_mmc_print_registers(mmc);
@@ -1209,8 +1209,8 @@ static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 	ulong start = cmd->cmdarg;
 	ulong blkcnt = data->blocks;
 	dma_addr_t dma_addr;
-	union cavm_mio_emm_rsp_sts rsp_sts;
-	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_sts_mask emm_sts_mask;
 	ulong timeout;
 	int count;
 	bool timed_out = false;
@@ -1220,7 +1220,7 @@ static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 	octeontx_mmc_switch_to(mmc);
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = R1_BLOCK_WRITE_MASK;
-	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
+	write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
 
 	if (octeontx_mmc_poll_ready(mmc, 10000)) {
 		pr_err("%s(%s): Ready timed out\n", __func__, mmc->dev->name);
@@ -1234,15 +1234,15 @@ static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 		octeontx_mmc_start_dma(mmc, true, false, start, dma_addr,
 				       blkcnt, timeout);
 		timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout);
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
 			pr_err("%s(%s): Error: multi-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
 			       __func__, mmc->dev->name, timeout,
 			       rsp_sts.u,
-			       read_csr(mmc, CAVM_MIO_EMM_INT()),
-			       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
-			       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
-			       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+			       read_csr(mmc, MIO_EMM_INT()),
+			       read_csr(mmc, MIO_EMM_DMA_INT()),
+			       read_csr(mmc, MIO_EMM_RSP_LO()),
+			       read_csr(mmc, MIO_EMM_DMA()));
 			return 0;
 		}
 	} else {
@@ -1255,15 +1255,16 @@ static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
 			start++;
 
 			timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout);
+			rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 			if (timed_out || rsp_sts.s.dma_val ||
 			    rsp_sts.s.dma_pend) {
 				pr_err("%s(%s): Error: single-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
 				       __func__, mmc->dev->name, timeout,
 				       rsp_sts.u,
-				       read_csr(mmc, CAVM_MIO_EMM_RSP_STS()),
-				       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
-				       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
-				       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+				       read_csr(mmc, MIO_EMM_RSP_STS()),
+				       read_csr(mmc, MIO_EMM_DMA_INT()),
+				       read_csr(mmc, MIO_EMM_RSP_LO()),
+				       read_csr(mmc, MIO_EMM_DMA()));
 				return blkcnt - count;
 			}
 			WATCHDOG_RESET();
@@ -1288,11 +1289,11 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 	const char *name = slot->dev->name;
 	struct octeontx_mmc_cr_mods mods = {0, 0};
-	union cavm_mio_emm_rsp_sts rsp_sts;
-	union cavm_mio_emm_cmd emm_cmd;
-	union cavm_mio_emm_rsp_lo rsp_lo;
-	union cavm_mio_emm_buf_idx emm_buf_idx;
-	union cavm_mio_emm_buf_dat emm_buf_dat;
+	union mio_emm_rsp_sts rsp_sts;
+	union mio_emm_cmd emm_cmd;
+	union mio_emm_rsp_lo rsp_lo;
+	union mio_emm_buf_idx emm_buf_idx;
+	union mio_emm_buf_dat emm_buf_dat;
 	ulong start;
 	int i;
 	ulong blkcnt;
@@ -1308,11 +1309,11 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 	uint timeout;
 
 	if (cmd->cmdidx == MMC_CMD_SEND_EXT_CSD) {
-		union cavm_mio_emm_rca emm_rca;
+		union mio_emm_rca emm_rca;
 
 		emm_rca.u = 0;
 		emm_rca.s.card_rca = mmc->rca;
-		write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+		write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
 	}
 
 	if (timeout_short & (1ull << cmd->cmdidx))
@@ -1325,8 +1326,8 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		timeout = MMC_TIMEOUT_LONG;
 
 	debug("%s(%s): cmd idx: %u, arg: 0x%x, resp type: 0x%x, timeout: %u\n",
-		 __func__, name, cmd->cmdidx, cmd->cmdarg, cmd->resp_type,
-		 timeout);
+	      __func__, name, cmd->cmdidx, cmd->cmdarg, cmd->resp_type,
+	      timeout);
 	if (data)
 		debug("  data: addr: %p, flags: 0x%x, blocks: %u, blocksize: %u\n",
 		      data->dest, data->flags, data->blocks, data->blocksize);
@@ -1334,7 +1335,7 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 	octeontx_mmc_switch_to(mmc);
 
 	/* Clear any interrupts */
-	write_csr(mmc, CAVM_MIO_EMM_INT(), read_csr(mmc, CAVM_MIO_EMM_INT()));
+	write_csr(mmc, MIO_EMM_INT(), read_csr(mmc, MIO_EMM_INT()));
 
 	/*
 	 * We need to override the default command types and response types
@@ -1362,11 +1363,11 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 	case MMC_CMD_SELECT_CARD:
 		/* Set the RCA register (is it set automatically?) */
 		if (IS_SD(mmc)) {
-			union cavm_mio_emm_rca emm_rca;
+			union mio_emm_rca emm_rca;
 
 			emm_rca.u = 0;
 			emm_rca.s.card_rca = (cmd->cmdarg >> 16);
-			write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+			write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
 			debug("%s: Set SD relative address (RCA) to 0x%x\n",
 			      __func__, emm_rca.s.card_rca);
 		}
@@ -1385,7 +1386,7 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 	emm_cmd.s.arg = cmd->cmdarg;
 	emm_cmd.s.ctype_xor = mods.ctype_xor;
 	emm_cmd.s.rtype_xor = mods.rtype_xor;
-	if (data && (data->blocks == 1) && (data->blocksize != 512)) {
+	if (data && data->blocks == 1 && data->blocksize != 512) {
 		emm_cmd.s.offset =
 			64 - ((data->blocks * data->blocksize) / 8);
 		debug("%s: offset set to %u\n", __func__, emm_cmd.s.offset);
@@ -1410,25 +1411,24 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 #endif
 		emm_buf_idx.u = 0;
 		emm_buf_idx.s.inc = 1;
-		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		write_csr(mmc, MIO_EMM_BUF_IDX(), emm_buf_idx.u);
 		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
 			memcpy(&emm_buf_dat.u, src, sizeof(emm_buf_dat.u));
-			write_csr(mmc, CAVM_MIO_EMM_BUF_DAT(),
+			write_csr(mmc, MIO_EMM_BUF_DAT(),
 				  cpu_to_be64(emm_buf_dat.u));
 			src += sizeof(emm_buf_dat.u);
 		}
-		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), 0);
-
+		write_csr(mmc, MIO_EMM_BUF_IDX(), 0);
 	}
 	debug("%s(%s): Sending command %u (emm_cmd: 0x%llx)\n", __func__,
 	      name, cmd->cmdidx, emm_cmd.u);
 	set_wdog(mmc, timeout * 1000);
-	write_csr(mmc, CAVM_MIO_EMM_CMD(), emm_cmd.u);
+	write_csr(mmc, MIO_EMM_CMD(), emm_cmd.u);
 
 	/* Wait for command to finish or time out */
 	start = get_timer(0);
 	do {
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		WATCHDOG_RESET();
 	} while (!rsp_sts.s.cmd_done && !rsp_sts.s.rsp_timeout &&
 		 (get_timer(start) < timeout + 10));
@@ -1453,7 +1453,7 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		goto error;
 	}
 	if (rsp_sts.s.rsp_bad_sts) {
-		rsp_lo.u = read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
+		rsp_lo.u = read_csr(mmc, MIO_EMM_RSP_LO());
 		debug("%s: Bad response for bus id %d, cmd id %d:\n"
 		      "    rsp_timeout: %d\n"
 		      "    rsp_bad_sts: %d\n"
@@ -1476,7 +1476,7 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		      __func__, name, rsp_sts.s.cmd_idx, cmd->cmdidx);
 		octeontx_print_rsp_sts(mmc);
 		debug("%s: rsp_lo: 0x%llx\n", __func__,
-		      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+		      read_csr(mmc, MIO_EMM_RSP_LO()));
 
 		goto error;
 	}
@@ -1488,9 +1488,9 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		      cmd->resp_type);
 	/* Get the response if present */
 	if (rsp_sts.s.rsp_val && (cmd->resp_type & MMC_RSP_PRESENT)) {
-		union cavm_mio_emm_rsp_hi rsp_hi;
+		union mio_emm_rsp_hi rsp_hi;
 
-		rsp_lo.u = read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
+		rsp_lo.u = read_csr(mmc, MIO_EMM_RSP_LO());
 
 		switch (rsp_sts.s.rsp_type) {
 		case 1:
@@ -1507,7 +1507,7 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		case 2:
 			cmd->response[3] = rsp_lo.u & 0xffffffff;
 			cmd->response[2] = (rsp_lo.u >> 32) & 0xffffffff;
-			rsp_hi.u = read_csr(mmc, CAVM_MIO_EMM_RSP_HI());
+			rsp_hi.u = read_csr(mmc, MIO_EMM_RSP_HI());
 			cmd->response[1] = rsp_hi.u & 0xffffffff;
 			cmd->response[0] = (rsp_hi.u >> 32) & 0xffffffff;
 			debug("  response: 0x%08x 0x%08x 0x%08x 0x%08x\n",
@@ -1540,14 +1540,14 @@ static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		}
 		emm_buf_idx.u = 0;
 		emm_buf_idx.s.inc = 1;
-		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		write_csr(mmc, MIO_EMM_BUF_IDX(), emm_buf_idx.u);
 		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
-			emm_buf_dat.u = read_csr(mmc, CAVM_MIO_EMM_BUF_DAT());
+			emm_buf_dat.u = read_csr(mmc, MIO_EMM_BUF_DAT());
 			emm_buf_dat.u = be64_to_cpu(emm_buf_dat.u);
 			memcpy(dest, &emm_buf_dat.u, sizeof(emm_buf_dat.u));
 			dest += sizeof(emm_buf_dat.u);
 		}
-		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), 0);
+		write_csr(mmc, MIO_EMM_BUF_IDX(), 0);
 #ifdef DEBUG
 		debug("%s: Received %d bytes data\n", __func__,
 		      data->blocksize);
@@ -1633,21 +1633,21 @@ static int octeontx_mmc_test_get_ext_csd(struct mmc *mmc, u32 opcode,
  * preserved.
  */
 static void octeontx_mmc_set_emm_timing(struct mmc *mmc,
-					union cavm_mio_emm_timing emm_timing)
+					union mio_emm_timing emm_timing)
 {
-	union cavm_mio_emm_cfg emm_cfg;
+	union mio_emm_cfg emm_cfg;
 
 	pr_debug("%s(%s, 0x%llx) din: %u\n", __func__, mmc->dev->name,
 		 emm_timing.u, emm_timing.s.data_in_tap);
 
-	emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
+	emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
 	emm_cfg.s.bus_ena = 1 << 3;
-	write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+	write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 	udelay(1);
-	write_csr(mmc, CAVM_MIO_EMM_TIMING(), emm_timing.u);
+	write_csr(mmc, MIO_EMM_TIMING(), emm_timing.u);
 	udelay(1);
 	emm_cfg.s.bus_ena = 1 << mmc_to_slot(mmc)->bus_id;
-	write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+	write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 }
 
 struct adj {
@@ -1685,7 +1685,7 @@ static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
 				      u32 opcode)
 {
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_timing timing;
+	union mio_emm_timing timing;
 	int tap;
 	int err;
 	int run = 0;
@@ -1717,10 +1717,10 @@ static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
 	 */
 	for (tap = 0; tap <= MAX_NO_OF_TAPS; tap++, prev_ok = !err) {
 		if (tap < MAX_NO_OF_TAPS) {
-			timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+			timing.u = read_csr(mmc, MIO_EMM_TIMING());
 			timing.u &= ~(0x3full << adj->mask_shift);
 			timing.u |= (u64)tap << adj->mask_shift;
-			write_csr(mmc, CAVM_MIO_EMM_TIMING(), timing.u);
+			write_csr(mmc, MIO_EMM_TIMING(), timing.u);
 			debug("%s(%s): Testing ci: %d, co: %d, di: %d, do: %d\n",
 			      __func__, mmc->dev->name, timing.s.cmd_in_tap,
 			      timing.s.cmd_out_tap, timing.s.data_in_tap,
@@ -1733,9 +1733,9 @@ static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
 					      __func__, mmc->dev->name,
 					      adj->name, tap, count,
 					      read_csr(mmc,
-						       CAVM_MIO_EMM_RSP_STS()),
+						       MIO_EMM_RSP_STS()),
 					      read_csr(mmc,
-						       CAVM_MIO_EMM_RSP_LO()));
+						       MIO_EMM_RSP_LO()));
 					debug("%s(%s, %s): tap: %d, do: %d, di: %d, co: %d, ci: %d\n",
 					      __func__, mmc->dev->name,
 					      adj->name, tap,
@@ -1748,8 +1748,8 @@ static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
 				debug("%s(%s, %s): tap %d passed, count: %d, rsp_sts: 0x%llx, rsp_lo: 0x%llx\n",
 				      __func__, mmc->dev->name, adj->name, tap,
 				      count,
-				      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()),
-				      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+				      read_csr(mmc, MIO_EMM_RSP_STS()),
+				      read_csr(mmc, MIO_EMM_RSP_LO()));
 			}
 #ifdef DEBUG
 			how[tap] = "-+"[!err];
@@ -1821,7 +1821,6 @@ static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
 	slot->taps.u &= ~(0x3full << adj->mask_shift);
 	slot->taps.u |= (u64)tap << adj->mask_shift;
 
-
 #ifdef DEBUG
 	if (opcode == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
 		debug("%s(%s, %s): After successful tuning\n",
@@ -1843,7 +1842,7 @@ static int octeontx_mmc_execute_tuning(struct udevice *dev, u32 opcode)
 {
 	struct mmc *mmc = dev_to_mmc(dev);
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_timing emm_timing;
+	union mio_emm_timing emm_timing;
 	int err;
 	struct adj *a;
 	bool is_hs200;
@@ -1861,7 +1860,7 @@ static int octeontx_mmc_execute_tuning(struct udevice *dev, u32 opcode)
 		slot->tuned = false;
 	octeontx_mmc_set_output_bus_timing(mmc);
 	octeontx_mmc_set_input_bus_timing(mmc);
-	emm_timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	emm_timing.u = read_csr(mmc, MIO_EMM_TIMING());
 	if (mmc->selected_mode == MMC_HS_200) {
 		slot->hs200_taps.s.cmd_out_tap = emm_timing.s.cmd_out_tap;
 		slot->hs200_taps.s.data_out_tap = emm_timing.s.data_out_tap;
@@ -1899,8 +1898,8 @@ static int octeontx_mmc_execute_tuning(struct udevice *dev, u32 opcode)
 			}
 		}
 
-		err = octeontx_mmc_adjust_tuning(mmc, a,
-					a->opcode ? a->opcode : opcode);
+		err = octeontx_mmc_adjust_tuning(mmc, a, a->opcode ?
+						 a->opcode : opcode);
 		if (err) {
 			pr_err("%s(%s, %u): tuning %s failed\n", __func__,
 			       dev->name, opcode, a->name);
@@ -1937,8 +1936,8 @@ static int octeontx_mmc_set_ios(struct udevice *dev)
 	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
 	struct mmc *mmc = &slot->mmc;
 	struct octeontx_mmc_host *host = slot->host;
-	union cavm_mio_emm_switch emm_switch;
-	union cavm_mio_emm_modex mode;
+	union mio_emm_switch emm_switch;
+	union mio_emm_modex mode;
 	uint clock;
 	int bus_width = 0;
 	int clk_period = 0;
@@ -2044,7 +2043,7 @@ static int octeontx_mmc_set_ios(struct udevice *dev)
 	set_wdog(mmc, 1000);
 	do_switch(mmc, emm_switch);
 	mdelay(100);
-	mode.u = read_csr(mmc, CAVM_MIO_EMM_MODEX(slot->bus_id));
+	mode.u = read_csr(mmc, MIO_EMM_MODEX(slot->bus_id));
 	debug("%s(%s): mode: 0x%llx w:%d, hs:%d, hs200:%d, hs400:%d\n",
 	      __func__, dev->name, mode.u, mode.s.bus_width,
 	      mode.s.hs_timing, mode.s.hs200_timing, mode.s.hs400_timing);
@@ -2089,7 +2088,7 @@ static int octeontx_mmc_get_wp(struct udevice *dev)
 #if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
 static void octeontx_mmc_set_timing(struct mmc *mmc)
 {
-	union cavm_mio_emm_timing timing;
+	union mio_emm_timing timing;
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 
 	if (mmc->selected_mode == MMC_HS_200 ||
@@ -2115,12 +2114,12 @@ static int octeontx_mmc_configure_delay(struct mmc *mmc)
 	debug("%s(%s)\n", __func__, mmc->dev->name);
 #if defined(CONFIG_ARCH_OCTEONTX)
 	{
-		union cavm_mio_emm_sample emm_sample;
+		union mio_emm_sample emm_sample;
 
 		emm_sample.u = 0;
 		emm_sample.s.cmd_cnt = slot->cmd_cnt;
 		emm_sample.s.dat_cnt = slot->dat_cnt;
-		write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), emm_sample.u);
+		write_csr(mmc, MIO_EMM_SAMPLE(), emm_sample.u);
 	}
 #else
 	is_hs200 = ((mmc->selected_mode == MMC_HS_200) ||
@@ -2213,7 +2212,7 @@ static int octeontx_mmc_configure_delay(struct mmc *mmc)
  */
 static void set_wdog(struct mmc *mmc, u64 us)
 {
-	union cavm_mio_emm_wdog wdog;
+	union mio_emm_wdog wdog;
 	u64 val;
 
 	val = (us * mmc->clock) / 1000000;
@@ -2227,7 +2226,7 @@ static void set_wdog(struct mmc *mmc, u64 us)
 	}
 	wdog.u = 0;
 	wdog.s.clk_cnt = val;
-	write_csr(mmc, CAVM_MIO_EMM_WDOG(), wdog.u);
+	write_csr(mmc, MIO_EMM_WDOG(), wdog.u);
 }
 
 /**
@@ -2239,14 +2238,14 @@ static void octeontx_mmc_io_drive_setup(struct mmc *mmc)
 {
 #if !defined(CONFIG_ARCH_OCTEONTX)
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_io_ctl io_ctl;
+	union mio_emm_io_ctl io_ctl;
 
-	if ((slot->drive < 0) || (slot->slew < 0))
+	if (slot->drive < 0 || slot->slew < 0)
 		return;
 	io_ctl.u = 0;
 	io_ctl.s.drive = slot->drive;
 	io_ctl.s.slew = slot->slew;
-	write_csr(mmc, CAVM_MIO_EMM_IO_CTL(), io_ctl.u);
+	write_csr(mmc, MIO_EMM_IO_CTL(), io_ctl.u);
 #endif
 }
 
@@ -2257,9 +2256,9 @@ static void octeontx_mmc_io_drive_setup(struct mmc *mmc)
  */
 static void check_switch_errors(struct mmc *mmc)
 {
-	union cavm_mio_emm_switch emm_switch;
+	union mio_emm_switch emm_switch;
 
-	emm_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
+	emm_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
 	if (emm_switch.s.switch_err0)
 		pr_err("%s: Switch power class error\n", mmc->cfg->name);
 	if (emm_switch.s.switch_err1)
@@ -2268,24 +2267,24 @@ static void check_switch_errors(struct mmc *mmc)
 		pr_err("%s: Switch bus width error\n", mmc->cfg->name);
 }
 
-static void do_switch(struct mmc *mmc, union cavm_mio_emm_switch emm_switch)
+static void do_switch(struct mmc *mmc, union mio_emm_switch emm_switch)
 {
-	union cavm_mio_emm_rsp_sts rsp_sts;
+	union mio_emm_rsp_sts rsp_sts;
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 	int bus_id = emm_switch.s.bus_id;
 	ulong start;
 
 	if (emm_switch.s.bus_id != 0) {
 		emm_switch.s.bus_id = 0;
-		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
 		udelay(100);
 		emm_switch.s.bus_id = bus_id;
 	}
-	write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+	write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
 
 	start = get_timer(0);
 	do {
-		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		rsp_sts.u = read_csr(mmc, MIO_EMM_RSP_STS());
 		if (!rsp_sts.s.switch_val)
 			break;
 		udelay(100);
@@ -2298,8 +2297,8 @@ static void do_switch(struct mmc *mmc, union cavm_mio_emm_switch emm_switch)
 	check_switch_errors(mmc);
 	slot->cached_switch.u = emm_switch.u;
 	debug("%s: emm_switch: 0x%llx, rsp_lo: 0x%llx\n",
-	      __func__, read_csr(mmc, CAVM_MIO_EMM_SWITCH()),
-				 read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+	      __func__, read_csr(mmc, MIO_EMM_SWITCH()),
+				 read_csr(mmc, MIO_EMM_RSP_LO()));
 }
 
 #ifndef CONFIG_ARCH_OCTEONTX
@@ -2340,15 +2339,15 @@ static int octeontx2_mmc_calc_delay(struct mmc *mmc, int delay)
  */
 static int octeontx_mmc_calibrate_delay(struct mmc *mmc)
 {
-	union cavm_mio_emm_calb emm_calb;
-	union cavm_mio_emm_tap emm_tap;
-	union cavm_mio_emm_cfg emm_cfg;
-	union cavm_mio_emm_io_ctl emm_io_ctl;
-	union cavm_mio_emm_switch emm_switch;
-	union cavm_mio_emm_wdog emm_wdog;
-	union cavm_mio_emm_sts_mask emm_sts_mask;
-	union cavm_mio_emm_debug emm_debug;
-	union cavm_mio_emm_timing emm_timing;
+	union mio_emm_calb emm_calb;
+	union mio_emm_tap emm_tap;
+	union mio_emm_cfg emm_cfg;
+	union mio_emm_io_ctl emm_io_ctl;
+	union mio_emm_switch emm_switch;
+	union mio_emm_wdog emm_wdog;
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_debug emm_debug;
+	union mio_emm_timing emm_timing;
 	struct octeontx_mmc_host *host = mmc_to_host(mmc);
 	ulong start;
 	u8 bus_id, bus_ena;
@@ -2363,53 +2362,53 @@ static int octeontx_mmc_calibrate_delay(struct mmc *mmc)
 		emm_tap.s.delay = MMC_DEFAULT_TAP_DELAY;
 	} else {
 		/* Save registers */
-		emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
-		emm_io_ctl.u = read_csr(mmc, CAVM_MIO_EMM_IO_CTL());
-		emm_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
-		emm_wdog.u = read_csr(mmc, CAVM_MIO_EMM_WDOG());
-		emm_sts_mask.u = read_csr(mmc, CAVM_MIO_EMM_STS_MASK());
-		emm_debug.u = read_csr(mmc, CAVM_MIO_EMM_DEBUG());
-		emm_timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+		emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
+		emm_io_ctl.u = read_csr(mmc, MIO_EMM_IO_CTL());
+		emm_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
+		emm_wdog.u = read_csr(mmc, MIO_EMM_WDOG());
+		emm_sts_mask.u = read_csr(mmc, MIO_EMM_STS_MASK());
+		emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
+		emm_timing.u = read_csr(mmc, MIO_EMM_TIMING());
 		bus_ena = emm_cfg.s.bus_ena;
 		bus_id = emm_switch.s.bus_id;
 		emm_cfg.s.bus_ena = 0;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 		udelay(1);
 		emm_cfg.s.bus_ena = 1ULL << 3;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 		mdelay(1);
 		emm_calb.u = 0;
-		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
 		emm_calb.s.start = 1;
-		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
 		start = get_timer(0);
 		/* This should only take 3 microseconds */
 		do {
 			udelay(5);
-			emm_tap.u = read_csr(mmc, CAVM_MIO_EMM_TAP());
+			emm_tap.u = read_csr(mmc, MIO_EMM_TAP());
 		} while (!emm_tap.s.delay && get_timer(start) < 10);
 
 		emm_calb.s.start = 0;
-		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+		write_csr(mmc, MIO_EMM_CALB(), emm_calb.u);
 
 		emm_cfg.s.bus_ena = 0;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 		udelay(1);
 		/* Restore registers */
 		emm_cfg.s.bus_ena = bus_ena;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
-		write_csr(mmc, CAVM_MIO_EMM_TIMING(), emm_timing.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_TIMING(), emm_timing.u);
 		udelay(1);
-		write_csr(mmc, CAVM_MIO_EMM_IO_CTL(), emm_io_ctl.u);
+		write_csr(mmc, MIO_EMM_IO_CTL(), emm_io_ctl.u);
 		bus_id = emm_switch.s.bus_id;
 		emm_switch.s.bus_id = 0;
-		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
 		emm_switch.s.bus_id = bus_id;
-		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
-		write_csr(mmc, CAVM_MIO_EMM_WDOG(), emm_wdog.u);
-		write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
-		write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
-		write_csr(mmc, CAVM_MIO_EMM_DEBUG(), emm_debug.u);
+		write_csr(mmc, MIO_EMM_SWITCH(), emm_switch.u);
+		write_csr(mmc, MIO_EMM_WDOG(), emm_wdog.u);
+		write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
+		write_csr(mmc, MIO_EMM_RCA(), mmc->rca);
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
 
 		if (!emm_tap.s.delay) {
 			pr_err("%s: Error: delay calibration failed, timed out.\n",
@@ -2432,17 +2431,17 @@ static int octeontx_mmc_set_input_bus_timing(struct mmc *mmc)
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 
 #ifdef CONFIG_ARCH_OCTEONTX
-	union cavm_mio_emm_sample sample;
+	union mio_emm_sample sample;
 
 	sample.u = 0;
 	sample.s.cmd_cnt = slot->cmd_clk_skew;
 	sample.s.dat_cnt = slot->dat_clk_skew;
-	write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), sample.u);
+	write_csr(mmc, MIO_EMM_SAMPLE(), sample.u);
 
 #else
-	union cavm_mio_emm_timing timing;
+	union mio_emm_timing timing;
 
-	timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	timing.u = read_csr(mmc, MIO_EMM_TIMING());
 	if (mmc->selected_mode == MMC_HS_200 ||
 	    mmc->selected_mode == MMC_HS_400) {
 		if (slot->hs200_tuned) {
@@ -2479,7 +2478,7 @@ static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc)
 	return 0;
 #else
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
-	union cavm_mio_emm_timing timing;
+	union mio_emm_timing timing;
 	int cout_bdelay, dout_bdelay;
 	unsigned int cout_delay, dout_delay;
 	char env_name[32];
@@ -2520,7 +2519,7 @@ static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc)
 		       __func__);
 		return -1;
 	}
-	timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	timing.u = read_csr(mmc, MIO_EMM_TIMING());
 	timing.s.cmd_out_tap = cout_bdelay;
 	timing.s.data_out_tap = dout_bdelay;
 	if (mmc->selected_mode == MMC_HS_200 ||
@@ -2568,18 +2567,18 @@ static void octeontx_mmc_switch_io(struct mmc *mmc)
 	struct octeontx_mmc_host *host = slot->host;
 	struct mmc *last_mmc = host->last_mmc;
 	static struct udevice *last_reg;
-	union cavm_mio_emm_cfg emm_cfg;
+	union mio_emm_cfg emm_cfg;
 	int bus;
 	static bool initialized;
 
 	/* First time? */
-	if (!initialized || (mmc != host->last_mmc)) {
+	if (!initialized || mmc != host->last_mmc) {
 		struct mmc *ommc;
 
 		/* Switch to bus 3 which is unused */
-		emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
+		emm_cfg.u = read_csr(mmc, MIO_EMM_CFG());
 		emm_cfg.s.bus_ena = 1 << 3;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 
 		/* Turn off all other I/O interfaces with first initialization
 		 * if at least one supply was found.
@@ -2588,7 +2587,7 @@ static void octeontx_mmc_switch_io(struct mmc *mmc)
 			ommc = &host->slots[bus].mmc;
 
 			/* Handle self case later */
-			if ((ommc == mmc) || !ommc->vqmmc_supply)
+			if (ommc == mmc || !ommc->vqmmc_supply)
 				continue;
 
 			/* Skip if we're not switching regulators */
@@ -2605,7 +2604,7 @@ static void octeontx_mmc_switch_io(struct mmc *mmc)
 		mdelay(1);	/* Settle time */
 		/* Switch to new bus */
 		emm_cfg.s.bus_ena = 1 << slot->bus_id;
-		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, MIO_EMM_CFG(), emm_cfg.u);
 		last_reg = mmc->vqmmc_supply;
 		initialized = true;
 		return;
@@ -2656,9 +2655,9 @@ static void octeontx_mmc_switch_to(struct mmc *mmc)
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 	struct octeontx_mmc_slot *old_slot;
 	struct octeontx_mmc_host *host = slot->host;
-	union cavm_mio_emm_switch emm_switch;
-	union cavm_mio_emm_sts_mask emm_sts_mask;
-	union cavm_mio_emm_rca emm_rca;
+	union mio_emm_switch emm_switch;
+	union mio_emm_sts_mask emm_sts_mask;
+	union mio_emm_rca emm_rca;
 
 	if (slot->bus_id == host->last_slotid)
 		return;
@@ -2669,16 +2668,16 @@ static void octeontx_mmc_switch_to(struct mmc *mmc)
 
 	if (host->last_slotid >= 0 && slot->valid) {
 		old_slot = &host->slots[host->last_slotid];
-		old_slot->cached_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
-		old_slot->cached_rca.u = read_csr(mmc, CAVM_MIO_EMM_RCA());
+		old_slot->cached_switch.u = read_csr(mmc, MIO_EMM_SWITCH());
+		old_slot->cached_rca.u = read_csr(mmc, MIO_EMM_RCA());
 	}
 	if (mmc->rca)
-		write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
+		write_csr(mmc, MIO_EMM_RCA(), mmc->rca);
 	emm_switch = slot->cached_switch;
 	do_switch(mmc, emm_switch);
 	emm_rca.u = 0;
 	emm_rca.s.card_rca = mmc->rca;
-	write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+	write_csr(mmc, MIO_EMM_RCA(), emm_rca.u);
 	mdelay(100);
 
 	set_wdog(mmc, 100000);
@@ -2690,7 +2689,7 @@ static void octeontx_mmc_switch_to(struct mmc *mmc)
 
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
-	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
+	write_csr(mmc, MIO_EMM_STS_MASK(), emm_sts_mask.u);
 	host->last_slotid = slot->bus_id;
 	host->last_mmc = mmc;
 	mdelay(10);
@@ -2708,7 +2707,7 @@ static void octeontx_mmc_switch_to(struct mmc *mmc)
  */
 static int octeontx_mmc_init_timing(struct mmc *mmc)
 {
-	union cavm_mio_emm_timing timing;
+	union mio_emm_timing timing;
 
 	if (mmc_to_slot(mmc)->is_asim || mmc_to_slot(mmc)->is_emul)
 		return 0;
@@ -2735,26 +2734,26 @@ static int octeontx_mmc_init_lowlevel(struct mmc *mmc)
 {
 	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
 	struct octeontx_mmc_host *host = slot->host;
-	union cavm_mio_emm_switch emm_switch;
+	union mio_emm_switch emm_switch;
 	u32 clk_period;
 
 	debug("%s(%s): lowlevel init for slot %d\n", __func__,
 	      mmc->dev->name, slot->bus_id);
 	host->emm_cfg.s.bus_ena &= ~(1 << slot->bus_id);
-	write_csr(mmc, CAVM_MIO_EMM_CFG(), host->emm_cfg.u);
+	write_csr(mmc, MIO_EMM_CFG(), host->emm_cfg.u);
 	udelay(100);
 	host->emm_cfg.s.bus_ena |= 1 << slot->bus_id;
-	write_csr(mmc, CAVM_MIO_EMM_CFG(), host->emm_cfg.u);
+	write_csr(mmc, MIO_EMM_CFG(), host->emm_cfg.u);
 	udelay(10);
 	slot->clock = mmc->cfg->f_min;
 	octeontx_mmc_set_clock(&slot->mmc);
 #ifdef CONFIG_ARCH_OCTEONTX2
 	if (host->cond_clock_glitch) {
-		union cavm_mio_emm_debug emm_debug;
+		union mio_emm_debug emm_debug;
 
-		emm_debug.u = read_csr(mmc, CAVM_MIO_EMM_DEBUG());
+		emm_debug.u = read_csr(mmc, MIO_EMM_DEBUG());
 		emm_debug.s.clk_on = 1;
-		write_csr(mmc, CAVM_MIO_EMM_DEBUG(), emm_debug.u);
+		write_csr(mmc, MIO_EMM_DEBUG(), emm_debug.u);
 	}
 	octeontx_mmc_calibrate_delay(&slot->mmc);
 #endif
@@ -2775,8 +2774,8 @@ static int octeontx_mmc_init_lowlevel(struct mmc *mmc)
 #endif
 
 	set_wdog(mmc, 1000000); /* Set to 1 second */
-	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), 0xe4390080ull);
-	write_csr(mmc, CAVM_MIO_EMM_RCA(), 1);
+	write_csr(mmc, MIO_EMM_STS_MASK(), 0xe4390080ull);
+	write_csr(mmc, MIO_EMM_RCA(), 1);
 	mdelay(10);
 	debug("%s: done\n", __func__);
 	return 0;
@@ -2946,8 +2945,8 @@ static int octeontx_mmc_get_config(struct udevice *dev)
 	    ofnode_read_bool(node, "cap-mmc-highspeed") ||
 	    ofnode_read_bool(node, "sd-uhs-sdr25"))
 		slot->cfg.host_caps |= MMC_MODE_HS;
-	if ((slot->cfg.f_max >= 50000000) &&
-	    (slot->cfg.host_caps & MMC_MODE_HS))
+	if (slot->cfg.f_max >= 50000000 &&
+	    slot->cfg.host_caps & MMC_MODE_HS)
 		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
 	if (ofnode_read_bool(node, "sd-uhs-sdr50"))
 		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
@@ -3091,7 +3090,7 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 	size_t size;
 	pci_dev_t bdf = dm_pci_get_bdf(dev);
 	struct octeontx_mmc_host *host = dev_get_priv(dev);
-	union cavm_mio_emm_int emm_int;
+	union mio_emm_int emm_int;
 	const char *board_model;
 	ofnode node;
 #if defined(CONFIG_ARCH_OCTEONTX2)
@@ -3129,12 +3128,12 @@ static int octeontx_mmc_host_probe(struct udevice *dev)
 			host->is_emul = true;
 	}
 	/* Force reset of eMMC */
-	writeq(0, host->base_addr + CAVM_MIO_EMM_CFG());
+	writeq(0, host->base_addr + MIO_EMM_CFG());
 	debug("%s: Clearing MIO_EMM_CFG\n", __func__);
 	udelay(100);
-	emm_int.u = readq(host->base_addr + CAVM_MIO_EMM_INT());
+	emm_int.u = readq(host->base_addr + MIO_EMM_INT());
 	debug("%s: Writing 0x%llx to MIO_EMM_INT\n", __func__, emm_int.u);
-	writeq(emm_int.u, host->base_addr + CAVM_MIO_EMM_INT());
+	writeq(emm_int.u, host->base_addr + MIO_EMM_INT());
 
 	debug("%s(%s): Getting I/O clock\n", __func__, dev->name);
 	host->sys_freq = octeontx_get_io_clock();
@@ -3278,11 +3277,3 @@ U_BOOT_DRIVER(octeontx_hsmmc_host) = {
 	.flags	= DM_FLAG_PRE_RELOC,
 };
 
-#if 0	/* Do not use PCI device for now with pseudo device */
-static struct pci_device_id octeontx_mmc_host_supported[] = {
-	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_EMMC) },
-	{ },
-};
-
-U_BOOT_PCI_DEVICE(octeontx_hsmmc_host, octeontx_mmc_host_supported);
-#endif
diff --git a/drivers/mmc/octeontx_hsmmc.h b/drivers/mmc/octeontx_hsmmc.h
index e503f405e0..8cdc8f6bfc 100644
--- a/drivers/mmc/octeontx_hsmmc.h
+++ b/drivers/mmc/octeontx_hsmmc.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2019 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 #ifndef __OCTEONTX_HSMMC_H__
@@ -14,7 +14,7 @@
 /** Maximum supported MMC slots */
 #define OCTEONTX_MAX_MMC_SLOT		3
 
-#define POWER_ON_TIME			40	/** See SD 4.1 spec figure 6-5 */
+#define POWER_ON_TIME			40 /** See SD 4.1 spec figure 6-5 */
 
 /**
  * Timeout used when waiting for commands to complete.  We need to keep this
@@ -53,11 +53,11 @@ struct octeontx_mmc_slot {
 	struct gpio_desc	wp_gpio;
 	struct gpio_desc	power_gpio;
 	enum bus_mode		mode;
-	union cavm_mio_emm_switch	cached_switch;
-	union cavm_mio_emm_switch	want_switch;
-	union cavm_mio_emm_rca		cached_rca;
-	union cavm_mio_emm_timing	taps;	/* otx2: MIO_EMM_TIMING */
-	union cavm_mio_emm_timing	hs200_taps;
+	union mio_emm_switch	cached_switch;
+	union mio_emm_switch	want_switch;
+	union mio_emm_rca		cached_rca;
+	union mio_emm_timing	taps;	/* otx2: MIO_EMM_TIMING */
+	union mio_emm_timing	hs200_taps;
 	/* These are used to see if our tuning is still valid or not */
 	enum bus_mode		last_mode;
 	u32			last_clock;
@@ -108,7 +108,7 @@ struct octeontx_mmc_host {
 	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT + 1];
 	pci_dev_t	pdev;
 	u64		sys_freq;
-	union cavm_mio_emm_cfg emm_cfg;
+	union mio_emm_cfg emm_cfg;
 	u64		timing_taps;
 	struct mmc	*last_mmc;	/** Last mmc used */
 	ofnode		node;
@@ -159,8 +159,8 @@ struct octeontx_mmc_host {
 #define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
 #define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
 #define R1_ERASE_RESET		BIT(13)		/* sr, c */
-#define R1_STATUS(x)		(x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_STATUS(x)		((x) & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)	(((x) & 0x00001E00) >> 9) /* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
 #define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
 
diff --git a/drivers/net/octeontx/Makefile b/drivers/net/octeontx/Makefile
index 0596617f91..e0bb524c37 100644
--- a/drivers/net/octeontx/Makefile
+++ b/drivers/net/octeontx/Makefile
@@ -1,10 +1,9 @@
-#/*
+#/* SPDX-License-Identifier:    GPL-2.0
+# *
 # * Copyright (C) 2018 Marvell International Ltd.
 # *
-# * SPDX-License-Identifier:    GPL-2.0
 # * https://spdx.org/licenses
 # */
 
-
 obj-$(CONFIG_NET_OCTEONTX) += octeontx_bgx.o nic_main.o nicvf_queues.o \
 		nicvf_main.o octeontx_xcv.o
diff --git a/drivers/net/octeontx/nic.h b/drivers/net/octeontx/nic.h
index b26976c42c..471621ecf4 100644
--- a/drivers/net/octeontx/nic.h
+++ b/drivers/net/octeontx/nic.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef NIC_H
 #define	NIC_H
 
@@ -15,7 +14,7 @@
 /**
  * Macro to get the physical address of a CSR on a node
  */
-#define CSR_PA(node, csr) ((csr) | ((uint64_t)(node) << 44))
+#define CSR_PA(node, csr) ((csr) | ((u64)(node) << 44))
 
 /* PCI device IDs */
 #define	PCI_DEVICE_ID_OCTEONTX_NIC_PF	0xA01E
@@ -48,8 +47,8 @@
 #define	NIC_TNS_MODE			1
 
 /* NIC priv flags */
-#define	NIC_SRIOV_ENABLED		(1 << 0)
-#define	NIC_TNS_ENABLED			(1 << 1)
+#define	NIC_SRIOV_ENABLED		BIT(0)
+#define	NIC_TNS_ENABLED			BIT(1)
 
 /* VNIC HW optimiation features */
 #define	VNIC_RX_CSUM_OFFLOAD_SUPPORT
@@ -98,10 +97,10 @@
 #define	NICVF_INTR_CQ_MASK		(0xFF << NICVF_INTR_CQ_SHIFT)
 #define	NICVF_INTR_SQ_MASK		(0xFF << NICVF_INTR_SQ_SHIFT)
 #define	NICVF_INTR_RBDR_MASK		(0x03 << NICVF_INTR_RBDR_SHIFT)
-#define	NICVF_INTR_PKT_DROP_MASK	(1 << NICVF_INTR_PKT_DROP_SHIFT)
-#define	NICVF_INTR_TCP_TIMER_MASK	(1 << NICVF_INTR_TCP_TIMER_SHIFT)
-#define	NICVF_INTR_MBOX_MASK		(1 << NICVF_INTR_MBOX_SHIFT)
-#define	NICVF_INTR_QS_ERR_MASK		(1 << NICVF_INTR_QS_ERR_SHIFT)
+#define	NICVF_INTR_PKT_DROP_MASK	BIT(NICVF_INTR_PKT_DROP_SHIFT)
+#define	NICVF_INTR_TCP_TIMER_MASK	BIT(NICVF_INTR_TCP_TIMER_SHIFT)
+#define	NICVF_INTR_MBOX_MASK		BIT(NICVF_INTR_MBOX_SHIFT)
+#define	NICVF_INTR_QS_ERR_MASK		BIT(NICVF_INTR_QS_ERR_SHIFT)
 
 /* MSI-X interrupts */
 #define	NIC_PF_MSIX_VECTORS		10
@@ -127,30 +126,30 @@
 #define NICPF_CLK_PER_INT_TICK		43750
 
 struct nicvf_cq_poll {
-	uint8_t	cq_idx;		/* Completion queue index */
+	u8	cq_idx;		/* Completion queue index */
 };
 
 #define NIC_MAX_RSS_HASH_BITS		8
-#define NIC_MAX_RSS_IDR_TBL_SIZE	(1 << NIC_MAX_RSS_HASH_BITS)
+#define NIC_MAX_RSS_IDR_TBL_SIZE	BIT(NIC_MAX_RSS_HASH_BITS)
 #define RSS_HASH_KEY_SIZE		5 /* 320 bit key */
 
 #ifdef VNIC_RSS_SUPPORT
 struct nicvf_rss_info {
 	bool enable;
-#define	RSS_L2_EXTENDED_HASH_ENA	(1 << 0)
-#define	RSS_IP_HASH_ENA			(1 << 1)
-#define	RSS_TCP_HASH_ENA		(1 << 2)
-#define	RSS_TCP_SYN_DIS			(1 << 3)
-#define	RSS_UDP_HASH_ENA		(1 << 4)
-#define RSS_L4_EXTENDED_HASH_ENA	(1 << 5)
-#define	RSS_ROCE_ENA			(1 << 6)
-#define	RSS_L3_BI_DIRECTION_ENA		(1 << 7)
-#define	RSS_L4_BI_DIRECTION_ENA		(1 << 8)
-	uint64_t cfg;
-	uint8_t  hash_bits;
-	uint16_t rss_size;
-	uint8_t  ind_tbl[NIC_MAX_RSS_IDR_TBL_SIZE];
-	uint64_t key[RSS_HASH_KEY_SIZE];
+#define	RSS_L2_EXTENDED_HASH_ENA	BIT(0)
+#define	RSS_IP_HASH_ENA			BIT(1)
+#define	RSS_TCP_HASH_ENA		BIT(2)
+#define	RSS_TCP_SYN_DIS			BIT(3)
+#define	RSS_UDP_HASH_ENA		BIT(4)
+#define RSS_L4_EXTENDED_HASH_ENA	BIT(5)
+#define	RSS_ROCE_ENA			BIT(6)
+#define	RSS_L3_BI_DIRECTION_ENA		BIT(7)
+#define	RSS_L4_BI_DIRECTION_ENA		BIT(8)
+	u64 cfg;
+	u8  hash_bits;
+	u16 rss_size;
+	u8  ind_tbl[NIC_MAX_RSS_IDR_TBL_SIZE];
+	u64 key[RSS_HASH_KEY_SIZE];
 };
 #endif
 
@@ -240,23 +239,23 @@ struct hw_info {
 
 struct nicvf {
 	struct udevice		*dev;
-	uint8_t			vf_id;
+	u8			vf_id;
 	bool			sqs_mode:1;
 	bool			loopback_supported:1;
-	uint8_t			tns_mode;
-	uint8_t			node;
-	uint16_t		mtu;
+	u8			tns_mode;
+	u8			node;
+	u16		mtu;
 	struct queue_set	*qs;
 #define		MAX_SQS_PER_VF_SINGLE_NODE	5
 #define		MAX_SQS_PER_VF			11
-	uint8_t			num_qs;
+	u8			num_qs;
 	void			*addnl_qs;
-	uint16_t		vf_mtu;
+	u16		vf_mtu;
 	void __iomem		*reg_base;
 #define	MAX_QUEUES_PER_QSET			8
 	struct nicvf_cq_poll	*napi[8];
 
-	uint8_t			cpi_alg;
+	u8			cpi_alg;
 
 	struct nicvf_hw_stats	stats;
 	struct nicvf_drv_stats	drv_stats;
@@ -269,11 +268,11 @@ struct nicvf {
 	bool			set_mac_pending;
 
 	bool			link_up;
-	uint8_t			duplex;
-	uint32_t		speed;
-	uint8_t			rev_id;
-	uint8_t			rx_queues;
-	uint8_t			tx_queues;
+	u8			duplex;
+	u32		speed;
+	u8			rev_id;
+	u8			rx_queues;
+	u8			tx_queues;
 
 	bool			open;
 	bool			rb_alloc_fail;
@@ -289,10 +288,10 @@ static inline int node_id(void *addr)
 struct nicpf {
 	struct udevice		*udev;
 	struct hw_info		*hw;
-	uint8_t			node;
+	u8			node;
 	unsigned int		flags;
-	uint16_t		total_vf_cnt;	/* Total num of VF supported */
-	uint16_t		num_vf_en;	/* No of VF enabled */
+	u16			total_vf_cnt;	/* Total num of VF supported */
+	u16			num_vf_en;	/* No of VF enabled */
 	void __iomem		*reg_base;	/* Register start address */
 	u16			rss_ind_tbl_size;
 	u8			num_sqs_en;	/* Secondary qsets enabled */
@@ -301,21 +300,21 @@ struct nicpf {
 	u8			pqs_vf[MAX_NUM_VFS_SUPPORTED];
 	bool			sqs_used[MAX_NUM_VFS_SUPPORTED];
 	struct pkind_cfg	pkind;
-	uint8_t			bgx_cnt;
-	uint8_t			rev_id;
-#define	NIC_SET_VF_LMAC_MAP(bgx, lmac)	(((bgx & 0xF) << 4) | (lmac & 0xF))
-#define	NIC_GET_BGX_FROM_VF_LMAC_MAP(map)	((map >> 4) & 0xF)
-#define	NIC_GET_LMAC_FROM_VF_LMAC_MAP(map)	(map & 0xF)
-	uint8_t			vf_lmac_map[MAX_LMAC];
-	uint16_t		cpi_base[MAX_NUM_VFS_SUPPORTED];
-	uint64_t		mac[MAX_NUM_VFS_SUPPORTED];
+	u8			bgx_cnt;
+	u8			rev_id;
+#define	NIC_SET_VF_LMAC_MAP(bgx, lmac)	((((bgx) & 0xF) << 4) | ((lmac) & 0xF))
+#define	NIC_GET_BGX_FROM_VF_LMAC_MAP(map)	(((map) >> 4) & 0xF)
+#define	NIC_GET_LMAC_FROM_VF_LMAC_MAP(map)	((map) & 0xF)
+	u8			vf_lmac_map[MAX_LMAC];
+	u16			cpi_base[MAX_NUM_VFS_SUPPORTED];
+	u64			mac[MAX_NUM_VFS_SUPPORTED];
 	bool			mbx_lock[MAX_NUM_VFS_SUPPORTED];
-	uint8_t			link[MAX_LMAC];
-	uint8_t			duplex[MAX_LMAC];
-	uint32_t		speed[MAX_LMAC];
+	u8			link[MAX_LMAC];
+	u8			duplex[MAX_LMAC];
+	u32			speed[MAX_LMAC];
 	bool			vf_enabled[MAX_NUM_VFS_SUPPORTED];
-	uint16_t		rssi_base[MAX_NUM_VFS_SUPPORTED];
-	uint8_t			lmac_cnt;
+	u16			rssi_base[MAX_NUM_VFS_SUPPORTED];
+	u8			lmac_cnt;
 };
 
 /* PF <--> VF Mailbox communication
@@ -468,6 +467,7 @@ struct set_loopback {
 	u8    vf_id;
 	bool  enable;
 };
+
 /* 128 bit shared memory between PF and each VF */
 union nic_mbx {
 	struct { u8 msg; }	msg;
diff --git a/drivers/net/octeontx/nic_main.c b/drivers/net/octeontx/nic_main.c
index 99f65eec22..e850bd6e1a 100644
--- a/drivers/net/octeontx/nic_main.c
+++ b/drivers/net/octeontx/nic_main.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <config.h>
 #include <common.h>
 #include <net.h>
@@ -45,12 +44,12 @@ static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf);
 static int nic_rcv_queue_sw_sync(struct nicpf *nic);
 
 /* Register read/write APIs */
-static void nic_reg_write(struct nicpf *nic, uint64_t offset, uint64_t val)
+static void nic_reg_write(struct nicpf *nic, u64 offset, u64 val)
 {
 	writeq(val, nic->reg_base + offset);
 }
 
-static uint64_t nic_reg_read(struct nicpf *nic, uint64_t offset)
+static u64 nic_reg_read(struct nicpf *nic, u64 offset)
 {
 	return readq(nic->reg_base + offset);
 }
@@ -60,7 +59,6 @@ static u64 nic_get_mbx_addr(int vf)
 	return NIC_PF_VF_0_127_MAILBOX_0_1 + (vf << NIC_VF_NUM_SHIFT);
 }
 
-
 static void nic_send_msg_to_vf(struct nicpf *nic, int vf, union nic_mbx *mbx)
 {
 	void __iomem *mbx_addr = (void *)(nic->reg_base + nic_get_mbx_addr(vf));
@@ -104,7 +102,7 @@ static void nic_mbx_send_ready(struct nicpf *nic, int vf)
 		if (mac)
 			memcpy((u8 *)&mbx.nic_cfg.mac_addr, mac, 6);
 
-		while (timeout-- && (link <= 0)){
+		while (timeout-- && (link <= 0)) {
 			link = bgx_poll_for_link(nic->node, bgx_idx, lmac);
 			debug("Link status: %d\n", link);
 			if (link <= 0)
@@ -121,7 +119,6 @@ static void nic_mbx_send_ready(struct nicpf *nic, int vf)
 	nic_send_msg_to_vf(nic, vf, &mbx);
 }
 
-
 /* ACKs VF's mailbox message
  * @vf: VF to which ACK to be sent
  */
@@ -183,8 +180,7 @@ void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 		mbx_addr += sizeof(u64);
 	}
 
-	debug("%s: Mailbox msg %d from VF%d\n",
-		__func__, mbx.msg.msg, vf);
+	debug("%s: Mailbox msg %d from VF%d\n", __func__, mbx.msg.msg, vf);
 	switch (mbx.msg.msg) {
 	case NIC_MBOX_MSG_READY:
 		nic_mbx_send_ready(nic, vf);
@@ -242,7 +238,8 @@ void nic_handle_mbx_intr(struct nicpf *nic, int vf)
 			   (mbx.sq.qs_num << NIC_QS_ID_SHIFT) |
 			   (mbx.sq.sq_num << NIC_Q_NUM_SHIFT);
 		nic_reg_write(nic, reg_addr, mbx.sq.cfg);
-		nic_tx_channel_cfg(nic, mbx.qs.num, (struct sq_cfg_msg*)&mbx.sq);
+		nic_tx_channel_cfg(nic, mbx.qs.num,
+				   (struct sq_cfg_msg *)&mbx.sq);
 		break;
 	case NIC_MBOX_MSG_SET_MAC:
 #ifdef VNIC_MULTI_QSET_SUPPORT
@@ -327,7 +324,6 @@ unlock:
 	nic->mbx_lock[vf] = false;
 }
 
-
 static int nic_rcv_queue_sw_sync(struct nicpf *nic)
 {
 	int timeout = 20;
@@ -349,10 +345,12 @@ static int nic_rcv_queue_sw_sync(struct nicpf *nic)
 
 static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)
 {
-	uint64_t *pkind = (uint64_t *)&nic->pkind;
-	if ((new_frs > NIC_HW_MAX_FRS) || (new_frs < NIC_HW_MIN_FRS)) {
-		printf("Invalid MTU setting from VF%d rejected, should be between %d and %d\n",
-				vf, NIC_HW_MIN_FRS, NIC_HW_MAX_FRS);
+	u64 *pkind = (u64 *)&nic->pkind;
+
+	if (new_frs > NIC_HW_MAX_FRS || new_frs < NIC_HW_MIN_FRS) {
+		printf("Invalid MTU setting from VF%d rejected,", vf);
+		printf(" should be between %d and %d\n", NIC_HW_MIN_FRS,
+		       NIC_HW_MAX_FRS);
 		return 1;
 	}
 	new_frs += ETH_HLEN;
@@ -369,7 +367,7 @@ static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)
 static void nic_set_tx_pkt_pad(struct nicpf *nic, int size)
 {
 	int lmac;
-	uint64_t lmac_cfg;
+	u64 lmac_cfg;
 	struct hw_info *hw = nic->hw;
 	int max_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;
 
@@ -396,7 +394,7 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 {
 	int bgx, bgx_count, next_bgx_lmac = 0;
 	int lmac, lmac_cnt = 0;
-	uint64_t lmac_credit;
+	u64 lmac_credit;
 
 	nic->num_vf_en = 0;
 	if (nic->flags & NIC_TNS_ENABLED) {
@@ -425,8 +423,8 @@ static void nic_set_lmac_vf_mapping(struct nicpf *nic)
 				NIC_HW_MAX_FRS) / 16) << 12);
 		lmac = bgx * MAX_LMAC_PER_BGX;
 		for (; lmac < lmac_cnt + (bgx * MAX_LMAC_PER_BGX); lmac++)
-			nic_reg_write(nic,
-				NIC_PF_LMAC_0_7_CREDIT + (lmac * 8), lmac_credit);
+			nic_reg_write(nic, NIC_PF_LMAC_0_7_CREDIT + (lmac * 8),
+				      lmac_credit);
 	}
 }
 
@@ -488,8 +486,8 @@ static void nic_get_hw_info(struct nicpf *nic)
 static void nic_init_hw(struct nicpf *nic)
 {
 	int i;
-	uint64_t reg;
-	uint64_t *pkind = (uint64_t *)&nic->pkind;
+	u64 reg;
+	u64 *pkind = (u64 *)&nic->pkind;
 
 	/* Get HW capability info */
 	nic_get_hw_info(nic);
@@ -500,7 +498,8 @@ static void nic_init_hw(struct nicpf *nic)
 	/* Enable backpressure */
 	nic_reg_write(nic, NIC_PF_BP_CFG, (1ULL << 6) | 0x03);
 	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG, (1ULL << 63) | 0x08);
-	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8), (1ULL << 63) | 0x09);
+	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8),
+		      (1ULL << 63) | 0x09);
 
 	for (i = 0; i < NIC_MAX_CHANS; i++)
 		nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (i << 3), 1);
@@ -616,7 +615,6 @@ static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)
 	nic->rssi_base[cfg->vf_id] = rssi_base;
 }
 
-
 /* Transmit channel configuration (TL4 -> TL3 -> Chan)
  * VNIC0-SQ0 -> TL4(0)  -> TL4A(0) -> TL3[0] -> BGX0/LMAC0/Chan0
  * VNIC1-SQ0 -> TL4(8)  -> TL4A(2) -> TL3[2] -> BGX0/LMAC1/Chan0
@@ -660,7 +658,8 @@ static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
 					break;
 			}
 			tl4 += (MAX_LMAC_PER_BGX * MAX_QUEUES_PER_QSET);
-			tl4 += (lmac * MAX_QUEUES_PER_QSET * MAX_SQS_PER_VF_SINGLE_NODE);
+			tl4 += (lmac * MAX_QUEUES_PER_QSET *
+				MAX_SQS_PER_VF_SINGLE_NODE);
 			tl4 += (svf * MAX_QUEUES_PER_QSET);
 		}
 	} else {
@@ -717,9 +716,8 @@ int nic_initialize(struct udevice *dev)
 
 	nic->udev = dev;
 	nic->hw = calloc(1, sizeof(struct hw_info));
-	if (!nic->hw) {
+	if (!nic->hw)
 		return -ENOMEM;
-	}
 
 	/* MAP PF's configuration registers */
 	nic->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
@@ -761,14 +759,9 @@ int octeontx_nic_probe(struct udevice *dev)
 		return ret;
 	}
 	ret = pci_sriov_init(dev, nicpf->num_vf_en);
-	if (ret < 0) {
-		printf("enabling SRIOV failed for num VFs %d",nicpf->num_vf_en);
-	}
-#if 0
-	for (int vf = 0; vf < nicpf->num_vf_en; vf++) {
-		 nicvf_initialize(dev, vf);
-	}
-#endif
+	if (ret < 0)
+		printf("enabling SRIOV failed for num VFs %d",
+		       nicpf->num_vf_en);
 	return ret;
 }
 
diff --git a/drivers/net/octeontx/nic_reg.h b/drivers/net/octeontx/nic_reg.h
index a4e7df2690..d8a4a7bd39 100644
--- a/drivers/net/octeontx/nic_reg.h
+++ b/drivers/net/octeontx/nic_reg.h
@@ -1,15 +1,13 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef NIC_REG_H
 #define NIC_REG_H
 
-
 #define   NIC_PF_REG_COUNT			29573
 #define   NIC_VF_REG_COUNT			249
 
@@ -228,24 +226,27 @@ struct pkind_cfg {
 #endif
 };
 
-static inline uint64_t BGXX_PF_BAR0(unsigned long param1) __attribute__ ((pure, always_inline));
+static inline uint64_t BGXX_PF_BAR0(unsigned long param1)
+				     __attribute__ ((pure, always_inline));
 static inline uint64_t BGXX_PF_BAR0(unsigned long param1)
 {
 	assert(param1 <= 1);
 	return 0x87E0E0000000 + (param1 << 24);
 }
-#define BGXX_PF_BAR0_SIZE 0x400000
 
+#define BGXX_PF_BAR0_SIZE 0x400000
 #define NIC_PF_BAR0 0x843000000000
 #define NIC_PF_BAR0_SIZE 0x40000000
 
-static inline uint64_t NIC_VFX_BAR0(unsigned long param1) __attribute__ ((pure, always_inline));
+static inline uint64_t NIC_VFX_BAR0(unsigned long param1)
+				     __attribute__ ((pure, always_inline));
 static inline uint64_t NIC_VFX_BAR0(unsigned long param1)
 {
 	assert(param1 <= 127);
 
 	return 0x8430A0000000 + (param1 << 21);
 }
+
 #define NIC_VFX_BAR0_SIZE 0x200000
 
 #endif /* NIC_REG_H */
diff --git a/drivers/net/octeontx/nicvf_main.c b/drivers/net/octeontx/nicvf_main.c
index 06a0208539..d7b8a7211f 100644
--- a/drivers/net/octeontx/nicvf_main.c
+++ b/drivers/net/octeontx/nicvf_main.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <config.h>
 #include <common.h>
 #include <dm.h>
@@ -25,27 +24,26 @@
 
 #define ETH_ALEN 6
 
-
 /* Register read/write APIs */
-void nicvf_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val)
+void nicvf_reg_write(struct nicvf *nic, u64 offset, u64 val)
 {
 	writeq(val, nic->reg_base + offset);
 }
 
-uint64_t nicvf_reg_read(struct nicvf *nic, uint64_t offset)
+u64 nicvf_reg_read(struct nicvf *nic, u64 offset)
 {
 	return readq(nic->reg_base + offset);
 }
 
-void nicvf_queue_reg_write(struct nicvf *nic, uint64_t offset,
-			   uint64_t qidx, uint64_t val)
+void nicvf_queue_reg_write(struct nicvf *nic, u64 offset,
+			   u64 qidx, u64 val)
 {
 	void *addr = nic->reg_base + offset;
 
 	writeq(val, (void *)(addr + (qidx << NIC_Q_NUM_SHIFT)));
 }
 
-uint64_t nicvf_queue_reg_read(struct nicvf *nic, uint64_t offset, uint64_t qidx)
+u64 nicvf_queue_reg_read(struct nicvf *nic, u64 offset, u64 qidx)
 {
 	void *addr = nic->reg_base + offset;
 
@@ -95,10 +93,9 @@ int nicvf_send_msg_to_pf(struct nicvf *nic, union nic_mbx *mbx)
 	return 0;
 }
 
-
 /* Checks if VF is able to comminicate with PF
-* and also gets the VNIC number this VF is associated to.
-*/
+ * and also gets the VNIC number this VF is associated to.
+ */
 static int nicvf_check_pf_ready(struct nicvf *nic)
 {
 	union nic_mbx mbx = {};
@@ -138,7 +135,7 @@ static void  nicvf_handle_mbx_intr(struct nicvf *nic)
 		nic->node = mbx.nic_cfg.node_id;
 		if (!nic->set_mac_pending)
 			memcpy(pdata->enetaddr,
-					mbx.nic_cfg.mac_addr, 6);
+			       mbx.nic_cfg.mac_addr, 6);
 		nic->loopback_supported = mbx.nic_cfg.loopback_supported;
 		nic->link_up = false;
 		nic->duplex = 0;
@@ -157,12 +154,11 @@ static void  nicvf_handle_mbx_intr(struct nicvf *nic)
 		nic->speed = mbx.link_status.speed;
 		if (nic->link_up) {
 			printf("%s: Link is Up %d Mbps %s\n",
-				    nic->dev->name, nic->speed,
-				    nic->duplex == 1 ?
-				"Full duplex" : "Half duplex");
+			       nic->dev->name, nic->speed,
+			       nic->duplex == 1 ?
+			       "Full duplex" : "Half duplex");
 		} else {
-			printf("%s: Link is Down\n",
-				    nic->dev->name);
+			printf("%s: Link is Down\n", nic->dev->name);
 		}
 		break;
 	default:
@@ -197,7 +193,6 @@ static void nicvf_config_cpi(struct nicvf *nic)
 	nicvf_send_msg_to_pf(nic, &mbx);
 }
 
-
 static int nicvf_init_resources(struct nicvf *nic)
 {
 	int err;
@@ -216,12 +211,7 @@ static int nicvf_init_resources(struct nicvf *nic)
 	}
 	return 0;
 }
-#if 0
-void nicvf_free_pkt(struct nicvf *nic, void *pkt)
-{
-	free(pkt);
-}
-#endif
+
 static void nicvf_snd_pkt_handler(struct nicvf *nic,
 				  struct cmp_queue *cq,
 				  void *cq_desc, int cqe_type)
@@ -287,7 +277,8 @@ int nicvf_cq_handler(struct nicvf *nic, void **ppkt, int *pkt_len)
 		return 0;
 
 	/* Get head of the valid CQ entries */
-	cqe_head = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, cq_qnum) >> 9;
+	cqe_head = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, cq_qnum);
+	cqe_head >>= 9;
 	cqe_head &= 0xFFFF;
 
 	if (cqe_count) {
@@ -301,7 +292,8 @@ int nicvf_cq_handler(struct nicvf *nic, void **ppkt, int *pkt_len)
 		switch (cq_desc->cqe_type) {
 		case CQE_TYPE_RX:
 			debug("%s: Got Rx CQE\n", nic->dev->name);
-			*pkt_len = nicvf_rcv_pkt_handler(nic, cq, cq_desc, ppkt, CQE_TYPE_RX);
+			*pkt_len = nicvf_rcv_pkt_handler(nic, cq, cq_desc,
+							 ppkt, CQE_TYPE_RX);
 			processed_rq_cqe++;
 			break;
 		case CQE_TYPE_SEND:
@@ -310,20 +302,20 @@ int nicvf_cq_handler(struct nicvf *nic, void **ppkt, int *pkt_len)
 			processed_sq_cqe++;
 			break;
 		default:
-			debug("%s: Got CQ type %u\n", nic->dev->name, cq_desc->cqe_type);
+			debug("%s: Got CQ type %u\n", nic->dev->name,
+			      cq_desc->cqe_type);
 			break;
 		}
 		processed_cqe++;
 	}
 
-
 	/* Dequeue CQE */
 	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_DOOR,
 			      cq_qnum, processed_cqe);
 
 	asm volatile ("dsb sy");
 
-	return (processed_sq_cqe | processed_rq_cqe)  ;
+	return (processed_sq_cqe | processed_rq_cqe);
 }
 
 /* Qset error interrupt handler
@@ -334,7 +326,7 @@ void nicvf_handle_qs_err(struct nicvf *nic)
 {
 	struct queue_set *qs = nic->qs;
 	int qidx;
-	uint64_t status;
+	u64 status;
 
 	/* Check if it is CQ err */
 	for (qidx = 0; qidx < qs->cq_cnt; qidx++) {
@@ -376,9 +368,8 @@ static int nicvf_xmit(struct udevice *dev, void *pkt, int pkt_len)
 	/* check and update CQ for pkt sent */
 	while (!ret && timeout--) {
 		ret = nicvf_cq_handler(nic, &rpkt, &rcv_len);
-		if (!ret)
-		{
-			debug("%s: %d, Not sent\n", __FUNCTION__, __LINE__);
+		if (!ret) {
+			debug("%s: %d, Not sent\n", __func__, __LINE__);
 			udelay(10);
 		}
 	}
@@ -404,9 +395,8 @@ static int nicvf_recv(struct udevice *dev, int flags, uchar **packetp)
 		printf("RX packet contents:\n");
 		for (i = 0; i < 8; i++) {
 			puts("\t");
-			for (j = 0; j < 10; j++) {
+			for (j = 0; j < 10; j++)
 				printf("%02x ", dpkt[i * 10 + j]);
-			}
 			puts("\n");
 		}
 #endif
@@ -450,9 +440,8 @@ int nicvf_open(struct udevice *dev)
 	if (err)
 		return -1;
 
-	if (!nicvf_check_pf_ready(nic)) {
+	if (!nicvf_check_pf_ready(nic))
 		return -1;
-	}
 
 	nic->open = true;
 
@@ -472,12 +461,12 @@ struct nicpf *nicvf_get_nicpf(void)
 				 0, &pdev);
 	if (err)
 		printf("%s couldn't find NIC PF device..VF probe failed\n",
-			__func__);
+		       __func__);
 
-	return (err ? NULL : dev_get_priv(pdev));
+	return err ? NULL : dev_get_priv(pdev);
 }
 
-static int vfid = 0;
+static int vfid;
 int nicvf_initialize(struct udevice *dev)
 {
 	struct nicvf *nicvf = dev_get_priv(dev);
@@ -486,6 +475,7 @@ int nicvf_initialize(struct udevice *dev)
 	size_t size;
 	char   name[16];
 	unsigned char ethaddr[ARP_HLEN];
+	struct nicpf *pfptr;
 
 	nicvf->nicpf = nicvf_get_nicpf();
 	if (!nicvf->nicpf) {
@@ -516,30 +506,22 @@ int nicvf_initialize(struct udevice *dev)
 	debug("%s name %s\n", __func__, name);
 	device_set_name(dev, name);
 
-	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(
-				nicvf->nicpf->vf_lmac_map[nicvf->vf_id]);
-	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(
-				nicvf->nicpf->vf_lmac_map[nicvf->vf_id]);
-	debug("%s VF %d BGX %d LMAC %d \n",
-		__func__, nicvf->vf_id, bgx, lmac);
-	debug("%s PF %p pfdev %p VF %p vfdev %p vf->pdata %p \n",
-		__func__, nicvf->nicpf, nicvf->nicpf->udev, nicvf, nicvf->dev, pdata);
+	pfptr = nicvf->nicpf;
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(pfptr->vf_lmac_map[nicvf->vf_id]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(pfptr->vf_lmac_map[nicvf->vf_id]);
+	debug("%s VF %d BGX %d LMAC %d\n", __func__, nicvf->vf_id, bgx, lmac);
+	debug("%s PF %p pfdev %p VF %p vfdev %p vf->pdata %p\n",
+	      __func__, nicvf->nicpf, nicvf->nicpf->udev, nicvf, nicvf->dev,
+	      pdata);
 
 	octeontx_board_get_ethaddr(bgx, lmac, ethaddr);
 
-	debug("%s bgx %d lmac %d ethaddr %pM\n",
-		__func__, bgx, lmac, ethaddr);
+	debug("%s bgx %d lmac %d ethaddr %pM\n", __func__, bgx, lmac, ethaddr);
 
 	memcpy(pdata->enetaddr, ethaddr, ARP_HLEN);
-	debug("%s enetaddr %pM ethaddr %pM\n",
-		__func__, pdata->enetaddr, ethaddr);
+	debug("%s enetaddr %pM ethaddr %pM\n", __func__, pdata->enetaddr,
+	      ethaddr);
 	eth_env_set_enetaddr_by_index("eth", dev->seq, ethaddr);
-#if 0
-	if (!eth_env_get_enetaddr_by_index("eth", nicvf->vf_id, netdev->enetaddr)) {
-		eth_env_get_enetaddr("ethaddr", netdev->enetaddr);
-		netdev->enetaddr[5] += nicvf->vf_id;
-	}
-#endif
 
 fail:
 	return ret;
diff --git a/drivers/net/octeontx/nicvf_queues.c b/drivers/net/octeontx/nicvf_queues.c
index c8cb693739..e4868decbc 100644
--- a/drivers/net/octeontx/nicvf_queues.c
+++ b/drivers/net/octeontx/nicvf_queues.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <config.h>
 #include <common.h>
 #include <net.h>
@@ -18,10 +17,10 @@
 #include "nicvf_queues.h"
 
 static int nicvf_poll_reg(struct nicvf *nic, int qidx,
-			  uint64_t reg, int bit_pos, int bits, int val)
+			  u64 reg, int bit_pos, int bits, int val)
 {
-	uint64_t bit_mask;
-	uint64_t reg_val;
+	u64 bit_mask;
+	u64 reg_val;
 	int timeout = 10;
 
 	bit_mask = (1ULL << bits) - 1;
@@ -68,14 +67,13 @@ static void nicvf_free_q_desc_mem(struct nicvf *nic, struct q_desc_mem *dmem)
 	dmem->base = NULL;
 }
 
-
 static void *nicvf_rb_ptr_to_pkt(struct nicvf *nic, uintptr_t rb_ptr)
 {
 	return (void *)rb_ptr;
 }
 
 static int nicvf_init_rbdr(struct nicvf *nic, struct rbdr *rbdr,
-			    int ring_len, int buf_size)
+			   int ring_len, int buf_size)
 {
 	int idx;
 	uintptr_t rbuf;
@@ -95,7 +93,7 @@ static int nicvf_init_rbdr(struct nicvf *nic, struct rbdr *rbdr,
 	rbdr->thresh = RBDR_THRESH;
 
 	debug("%s: %d: allocating %lld bytes for rcv buffers\n",
-	      __FUNCTION__, __LINE__,
+	      __func__, __LINE__,
 	      ring_len * buf_size + NICVF_RCV_BUF_ALIGN_BYTES);
 	rbdr->buf_mem = (uintptr_t)calloc(1, ring_len * buf_size
 						+ NICVF_RCV_BUF_ALIGN_BYTES);
@@ -105,16 +103,18 @@ static int nicvf_init_rbdr(struct nicvf *nic, struct rbdr *rbdr,
 		return -1;
 	}
 
-	rbdr->buffers = NICVF_ALIGNED_ADDR(rbdr->buf_mem, NICVF_RCV_BUF_ALIGN_BYTES);
+	rbdr->buffers = NICVF_ALIGNED_ADDR(rbdr->buf_mem,
+					   NICVF_RCV_BUF_ALIGN_BYTES);
 
 	debug("%s: %d: rbdr->buf_mem: %lx, rbdr->buffers: %lx\n",
-		__FUNCTION__, __LINE__, rbdr->buf_mem, rbdr->buffers);
+	      __func__, __LINE__, rbdr->buf_mem, rbdr->buffers);
 
 	for (idx = 0; idx < ring_len; idx++) {
 		rbuf = rbdr->buffers + DMA_BUFFER_LEN * idx;
 		desc = GET_RBDR_DESC(rbdr, idx);
 		desc->buf_addr = rbuf >> NICVF_RCV_BUF_ALIGN;
-		flush_dcache_range((uintptr_t)desc, (uintptr_t)desc + sizeof(desc));
+		flush_dcache_range((uintptr_t)desc,
+				   (uintptr_t)desc + sizeof(desc));
 	}
 	return 0;
 }
@@ -128,7 +128,7 @@ static void nicvf_free_rbdr(struct nicvf *nic, struct rbdr *rbdr)
 	if (!rbdr->dmem.base)
 		return;
 
-	debug("%s: %d: rbdr->buf_mem: %p\n", __FUNCTION__,
+	debug("%s: %d: rbdr->buf_mem: %p\n", __func__,
 	      __LINE__, (void *)rbdr->buf_mem);
 	free((void *)rbdr->buf_mem);
 
@@ -166,8 +166,7 @@ void nicvf_refill_rbdr(struct nicvf *nic)
 	rb_cnt = qs->rbdr_len - qcount - 1;
 
 	debug("%s: %d: qcount: %lu, head: %lx, tail: %lx, rb_cnt: %lu\n",
-	      __FUNCTION__, __LINE__, qcount, head, tail, rb_cnt);
-
+	      __func__, __LINE__, qcount, head, tail, rb_cnt);
 
 	/* Notify HW */
 	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_DOOR, rbdr_idx, rb_cnt);
@@ -175,7 +174,6 @@ void nicvf_refill_rbdr(struct nicvf *nic)
 	asm volatile ("dsb sy");
 }
 
-
 /* TBD: how to handle full packets received in CQ
  * i.e conversion of buffers into SKBs
  */
@@ -219,7 +217,7 @@ static int nicvf_init_snd_queue(struct nicvf *nic,
 	}
 
 	sq->desc = sq->dmem.base;
-	sq->skbuff = calloc(q_len, sizeof(uint64_t));
+	sq->skbuff = calloc(q_len, sizeof(u64));
 	sq->head = 0;
 	sq->tail = 0;
 	sq->free_cnt = q_len - 1;
@@ -235,7 +233,7 @@ static void nicvf_free_snd_queue(struct nicvf *nic, struct snd_queue *sq)
 	if (!sq->dmem.base)
 		return;
 
-	debug("%s: %d\n", __FUNCTION__, __LINE__);
+	debug("%s: %d\n", __func__, __LINE__);
 	free(sq->skbuff);
 
 	nicvf_free_q_desc_mem(nic, &sq->dmem);
@@ -323,7 +321,6 @@ static void nicvf_reclaim_rbdr(struct nicvf *nic,
 		return;
 }
 
-
 /* Configures receive queue */
 static void nicvf_rcv_queue_config(struct nicvf *nic, struct queue_set *qs,
 				   int qidx, bool enable)
@@ -388,7 +385,7 @@ void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
 {
 	struct cmp_queue *cq;
 	union {
-		uint64_t u;
+		u64 u;
 		struct cq_cfg s;
 	} cq_cfg;
 
@@ -408,7 +405,7 @@ void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
 
 	/* Set completion queue base address */
 	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_BASE,
-			      qidx, (uint64_t)(cq->dmem.phys_base));
+			      qidx, (u64)(cq->dmem.phys_base));
 
 	/* Enable Completion queue */
 	cq_cfg.s.ena = 1;
@@ -420,7 +417,8 @@ void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
 
 	/* Set threshold value for interrupt generation */
 	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_THRESH, qidx, cq->thresh);
-	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx, cq->intr_timer_thresh);
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx,
+			      cq->intr_timer_thresh);
 }
 
 /* Configures transmit queue */
@@ -689,7 +687,7 @@ static int nicvf_get_nxt_sqentry(struct snd_queue *sq, int qentry)
 
 void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx)
 {
-	uint64_t sq_cfg;
+	u64 sq_cfg;
 
 	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
 	sq_cfg |= NICVF_SQ_EN;
@@ -700,7 +698,7 @@ void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx)
 
 void nicvf_sq_disable(struct nicvf *nic, int qidx)
 {
-	uint64_t sq_cfg;
+	u64 sq_cfg;
 
 	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
 	sq_cfg &= ~NICVF_SQ_EN;
@@ -708,9 +706,9 @@ void nicvf_sq_disable(struct nicvf *nic, int qidx)
 }
 
 void nicvf_sq_free_used_descs(struct udevice *dev, struct snd_queue *sq,
-								int qidx)
+			      int qidx)
 {
-	uint64_t head;
+	u64 head;
 	struct nicvf *nic = dev_get_priv(dev);
 	struct sq_hdr_subdesc *hdr;
 
@@ -820,7 +818,7 @@ append_fail:
 	return 0;
 }
 
-static unsigned frag_num(unsigned i)
+static unsigned int frag_num(unsigned int i)
 {
 #ifdef __BIG_ENDIAN
 	return (i & ~3) + 3 - (i & 3);
@@ -838,14 +836,14 @@ void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len)
 	struct rbdr *rbdr;
 	struct rcv_queue *rq;
 	struct queue_set *qs = nic->qs;
-	uint16_t *rb_lens = NULL;
-	uint64_t *rb_ptrs = NULL;
+	u16 *rb_lens = NULL;
+	u64 *rb_ptrs = NULL;
 
 	cqe_rx = (struct cqe_rx_t *)cq_desc;
 
 	rq = &qs->rq[cqe_rx->rq_idx];
 	rbdr = &qs->rbdr[rq->start_qs_rbdr_idx];
-	rb_lens = cq_desc + (3 * sizeof(uint64_t)); /* Use offsetof */
+	rb_lens = cq_desc + (3 * sizeof(u64)); /* Use offsetof */
 	/* Except 88xx pass1 on all other chips CQE_RX2_S is added to
 	 * CQE_RX at word6, hence buffer pointers move by word
 	 *
@@ -888,9 +886,8 @@ void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len)
 		invalidate_dcache_range((uintptr_t)pkt,
 					(uintptr_t)pkt + payload_len);
 
-		if (cqe_rx->align_pad) {
+		if (cqe_rx->align_pad)
 			pkt += cqe_rx->align_pad;
-		}
 		debug("pkt_buf %p, pkt %p payload_len %d\n", pkt_buf, pkt,
 		      payload_len);
 		memcpy(buffer, pkt, payload_len);
@@ -904,7 +901,7 @@ void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len)
 /* Clear interrupt */
 void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx)
 {
-	uint64_t reg_val = 0;
+	u64 reg_val = 0;
 
 	switch (int_type) {
 	case NICVF_INTR_CQ:
@@ -942,7 +939,7 @@ void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx)
 
 #define GET_RQ_STATS(reg) \
 	nicvf_reg_read(nic, NIC_QSET_RQ_0_7_STAT_0_1 |\
-			    (rq_idx << NIC_Q_NUM_SHIFT) | (reg << 3))
+			    (rq_idx << NIC_Q_NUM_SHIFT) | ((reg) << 3))
 
 	rq = &nic->qs->rq[rq_idx];
 	rq->stats.bytes = GET_RQ_STATS(RQ_SQ_STATS_OCTS);
@@ -955,7 +952,7 @@ void nicvf_update_sq_stats(struct nicvf *nic, int sq_idx)
 
 #define GET_SQ_STATS(reg) \
 	nicvf_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1 |\
-			    (sq_idx << NIC_Q_NUM_SHIFT) | (reg << 3))
+			    (sq_idx << NIC_Q_NUM_SHIFT) | ((reg) << 3))
 
 	sq = &nic->qs->sq[sq_idx];
 	sq->stats.bytes = GET_SQ_STATS(RQ_SQ_STATS_OCTS);
diff --git a/drivers/net/octeontx/nicvf_queues.h b/drivers/net/octeontx/nicvf_queues.h
index e0c64a572b..390eaa793b 100644
--- a/drivers/net/octeontx/nicvf_queues.h
+++ b/drivers/net/octeontx/nicvf_queues.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef NICVF_QUEUES_H
 #define NICVF_QUEUES_H
 
@@ -24,13 +23,6 @@
 #define	NICVF_INTR_ID_MISC		18
 #define	NICVF_INTR_ID_QS_ERR		19
 
-#define	for_each_cq_irq(irq)	\
-	for (irq = NICVF_INTR_ID_CQ; irq < NICVF_INTR_ID_SQ; irq++)
-#define	for_each_sq_irq(irq)	\
-	for (irq = NICVF_INTR_ID_SQ; irq < NICVF_INTR_ID_RBDR; irq++)
-#define	for_each_rbdr_irq(irq)	\
-	for (irq = NICVF_INTR_ID_RBDR; irq < NICVF_INTR_ID_MISC; irq++)
-
 #define RBDR_SIZE0		0ULL /* 8K entries */
 #define RBDR_SIZE1		1ULL /* 16K entries */
 #define RBDR_SIZE2		2ULL /* 32K entries */
@@ -62,21 +54,21 @@
 #define CMP_QUEUE_CNT		1 /* Max of RCV and SND qcount */
 
 #define SND_QSIZE		SND_QUEUE_SIZE0
-#define SND_QUEUE_LEN		(1ULL << (SND_QSIZE + 10))
+#define SND_QUEUE_LEN		BIT_ULL((SND_QSIZE + 10))
 #define SND_QUEUE_THRESH	2ULL
 #define MIN_SQ_DESC_PER_PKT_XMIT	2
 #define MAX_CQE_PER_PKT_XMIT		2
 
 #define CMP_QSIZE		CMP_QUEUE_SIZE0
-#define CMP_QUEUE_LEN		(1ULL << (CMP_QSIZE + 10))
+#define CMP_QUEUE_LEN		BIT_ULL((CMP_QSIZE + 10))
 #define CMP_QUEUE_CQE_THRESH	0
 #define CMP_QUEUE_TIMER_THRESH	1 /* 1 ms */
 
 #define RBDR_SIZE		RBDR_SIZE0
-#define RCV_BUF_COUNT		(1ULL << (RBDR_SIZE + 13))
+#define RCV_BUF_COUNT		BIT_ULL((RBDR_SIZE + 13))
 #define RBDR_THRESH		(RCV_BUF_COUNT / 2)
 #define DMA_BUFFER_LEN		2048 /* In multiples of 128bytes */
-#define RCV_FRAG_LEN	 	DMA_BUFFER_LEN
+#define RCV_FRAG_LEN		DMA_BUFFER_LEN
 
 #define MAX_CQES_FOR_TX		((SND_QUEUE_LEN / MIN_SQ_DESC_PER_PKT_XMIT) *\
 				 MAX_CQE_PER_PKT_XMIT)
@@ -88,23 +80,19 @@
 
 /* Buffer / descriptor alignments */
 #define NICVF_RCV_BUF_ALIGN		7
-#define NICVF_RCV_BUF_ALIGN_BYTES	(1ULL << NICVF_RCV_BUF_ALIGN)
+#define NICVF_RCV_BUF_ALIGN_BYTES	BIT_ULL(NICVF_RCV_BUF_ALIGN)
 #define NICVF_CQ_BASE_ALIGN_BYTES	512  /* 9 bits */
 #define NICVF_SQ_BASE_ALIGN_BYTES	128  /* 7 bits */
 
 #define NICVF_ALIGNED_ADDR(ADDR, ALIGN_BYTES)	ALIGN(ADDR, ALIGN_BYTES)
-#define NICVF_ADDR_ALIGN_LEN(ADDR, BYTES)\
-	(NICVF_ALIGNED_ADDR(ADDR, BYTES) - BYTES)
-#define NICVF_RCV_BUF_ALIGN_LEN(X)\
-	(NICVF_ALIGNED_ADDR(X, NICVF_RCV_BUF_ALIGN_BYTES) - X)
 
 /* Queue enable/disable */
-#define NICVF_SQ_EN            (1ULL << 19)
+#define NICVF_SQ_EN            BIT_ULL(19)
 
 /* Queue reset */
-#define NICVF_CQ_RESET		(1ULL << 41)
-#define NICVF_SQ_RESET		(1ULL << 17)
-#define NICVF_RBDR_RESET	(1ULL << 43)
+#define NICVF_CQ_RESET		BIT_ULL(41)
+#define NICVF_SQ_RESET		BIT_ULL(17)
+#define NICVF_RBDR_RESET	BIT_ULL(43)
 
 enum CQ_RX_ERRLVL_E {
 	CQ_ERRLVL_MAC,
@@ -237,8 +225,8 @@ struct rx_tx_queue_stats {
 
 struct q_desc_mem {
 	uintptr_t	dma;
-	uint64_t	size;
-	uint16_t	q_len;
+	u64	size;
+	u16	q_len;
 	uintptr_t	phys_base;
 	void		*base;
 	void		*unalign_base;
@@ -247,11 +235,11 @@ struct q_desc_mem {
 
 struct rbdr {
 	bool		enable;
-	uint32_t	dma_size;
-	uint32_t	thresh;      /* Threshold level for interrupt */
+	u32	dma_size;
+	u32	thresh;      /* Threshold level for interrupt */
 	void		*desc;
-	uint32_t	head;
-	uint32_t	tail;
+	u32	head;
+	u32	tail;
 	struct		q_desc_mem   dmem;
 	uintptr_t	buf_mem;
 	uintptr_t	buffers;
@@ -262,20 +250,20 @@ struct rcv_queue {
 	struct	rbdr	*rbdr_start;
 	struct	rbdr	*rbdr_cont;
 	bool		en_tcp_reassembly;
-	uint8_t		cq_qs;  /* CQ's QS to which this RQ is assigned */
-	uint8_t		cq_idx; /* CQ index (0 to 7) in the QS */
-	uint8_t		cont_rbdr_qs;      /* Continue buffer ptrs - QS num */
-	uint8_t		cont_qs_rbdr_idx;  /* RBDR idx in the cont QS */
-	uint8_t		start_rbdr_qs;     /* First buffer ptrs - QS num */
-	uint8_t		start_qs_rbdr_idx; /* RBDR idx in the above QS */
-	uint8_t         caching;
+	u8		cq_qs;  /* CQ's QS to which this RQ is assigned */
+	u8		cq_idx; /* CQ index (0 to 7) in the QS */
+	u8		cont_rbdr_qs;      /* Continue buffer ptrs - QS num */
+	u8		cont_qs_rbdr_idx;  /* RBDR idx in the cont QS */
+	u8		start_rbdr_qs;     /* First buffer ptrs - QS num */
+	u8		start_qs_rbdr_idx; /* RBDR idx in the above QS */
+	u8         caching;
 	struct		rx_tx_queue_stats stats;
 };
 
 struct cmp_queue {
 	bool		enable;
-	uint16_t	intr_timer_thresh;
-	uint16_t	thresh;
+	u16	intr_timer_thresh;
+	u16	thresh;
 	void		*desc;
 	struct q_desc_mem   dmem;
 	struct cmp_queue_stats	stats;
@@ -283,13 +271,13 @@ struct cmp_queue {
 
 struct snd_queue {
 	bool		enable;
-	uint8_t		cq_qs;  /* CQ's QS to which this SQ is pointing */
-	uint8_t		cq_idx; /* CQ index (0 to 7) in the above QS */
-	uint16_t	thresh;
-	uint32_t	free_cnt;
-	uint32_t	head;
-	uint32_t	tail;
-	uint64_t	*skbuff;
+	u8		cq_qs;  /* CQ's QS to which this SQ is pointing */
+	u8		cq_idx; /* CQ index (0 to 7) in the above QS */
+	u16	thresh;
+	u32	free_cnt;
+	u32	head;
+	u32	tail;
+	u64	*skbuff;
 	void		*desc;
 	struct q_desc_mem   dmem;
 	struct rx_tx_queue_stats stats;
@@ -298,14 +286,14 @@ struct snd_queue {
 struct queue_set {
 	bool		enable;
 	bool		be_en;
-	uint8_t		vnic_id;
-	uint8_t		rq_cnt;
-	uint8_t		cq_cnt;
-	uint64_t	cq_len;
-	uint8_t		sq_cnt;
-	uint64_t	sq_len;
-	uint8_t		rbdr_cnt;
-	uint64_t	rbdr_len;
+	u8		vnic_id;
+	u8		rq_cnt;
+	u8		cq_cnt;
+	u64	cq_len;
+	u8		sq_cnt;
+	u64	sq_len;
+	u8		rbdr_cnt;
+	u64	rbdr_len;
 	struct	rcv_queue	rq[MAX_RCV_QUEUES_PER_QS];
 	struct	cmp_queue	cq[MAX_CMP_QUEUES_PER_QS];
 	struct	snd_queue	sq[MAX_SND_QUEUES_PER_QS];
@@ -320,9 +308,9 @@ struct queue_set {
 		(&(((union cq_desc_t *)((RING)->desc))[idx]))
 
 /* CQ status bits */
-#define	CQ_WR_FULL	(1 << 26)
-#define	CQ_WR_DISABLE	(1 << 25)
-#define	CQ_WR_FAULT	(1 << 24)
+#define	CQ_WR_FULL	BIT(26)
+#define	CQ_WR_DISABLE	BIT(25)
+#define	CQ_WR_FAULT	BIT(24)
 #define	CQ_CQE_COUNT	(0xFFFF << 0)
 
 #define	CQ_ERR_MASK	(CQ_WR_FULL | CQ_WR_DISABLE | CQ_WR_FAULT)
@@ -337,7 +325,7 @@ void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx);
 void nicvf_sq_disable(struct nicvf *nic, int qidx);
 void nicvf_put_sq_desc(struct snd_queue *sq, int desc_cnt);
 void nicvf_sq_free_used_descs(struct udevice *dev,
-					struct snd_queue *sq, int qidx);
+			      struct snd_queue *sq, int qidx);
 int nicvf_sq_append_pkt(struct nicvf *nic, void *pkt, size_t pkt_len);
 
 void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len);
@@ -349,14 +337,13 @@ void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx);
 int nicvf_is_intr_enabled(struct nicvf *nic, int int_type, int q_idx);
 
 /* Register access APIs */
-void nicvf_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val);
-uint64_t nicvf_reg_read(struct nicvf *nic, uint64_t offset);
-void nicvf_qset_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val);
-uint64_t nicvf_qset_reg_read(struct nicvf *nic, uint64_t offset);
-void nicvf_queue_reg_write(struct nicvf *nic, uint64_t offset,
-			   uint64_t qidx, uint64_t val);
-uint64_t nicvf_queue_reg_read(struct nicvf *nic,
-			      uint64_t offset, uint64_t qidx);
+void nicvf_reg_write(struct nicvf *nic, u64 offset, u64 val);
+u64 nicvf_reg_read(struct nicvf *nic, u64 offset);
+void nicvf_qset_reg_write(struct nicvf *nic, u64 offset, u64 val);
+u64 nicvf_qset_reg_read(struct nicvf *nic, u64 offset);
+void nicvf_queue_reg_write(struct nicvf *nic, u64 offset,
+			   u64 qidx, u64 val);
+u64 nicvf_queue_reg_read(struct nicvf *nic, u64 offset, u64 qidx);
 
 /* Stats */
 void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx);
diff --git a/drivers/net/octeontx/octeontx_bgx.c b/drivers/net/octeontx/octeontx_bgx.c
index a2f9c2be5c..1993dcb4ea 100644
--- a/drivers/net/octeontx/octeontx_bgx.c
+++ b/drivers/net/octeontx/octeontx_bgx.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <config.h>
 #include <common.h>
 #include <errno.h>
@@ -73,41 +72,41 @@ struct bgx {
 struct bgx_board_info bgx_board_info[CONFIG_MAX_BGX];
 
 struct bgx *bgx_vnic[CONFIG_MAX_BGX];
-bool is_altpkg = 0;
+bool is_altpkg;
 extern int __cavm_if_phy_xs_init(struct mii_dev *bus, int phy_addr);
 
 /* APIs to read/write BGXX CSRs */
-static uint64_t bgx_reg_read(struct bgx *bgx, uint8_t lmac, uint64_t offset)
+static u64 bgx_reg_read(struct bgx *bgx, uint8_t lmac, u64 offset)
 {
-	uint64_t addr = (uintptr_t)bgx->reg_base +
+	u64 addr = (uintptr_t)bgx->reg_base +
 				((uint32_t)lmac << 20) + offset;
 
 	return readq((void *)addr);
 }
 
 static void bgx_reg_write(struct bgx *bgx, uint8_t lmac,
-			  uint64_t offset, uint64_t val)
+			  u64 offset, u64 val)
 {
-	uint64_t addr = (uintptr_t)bgx->reg_base +
+	u64 addr = (uintptr_t)bgx->reg_base +
 				((uint32_t)lmac << 20) + offset;
 
 	writeq(val, (void *)addr);
 }
 
 static void bgx_reg_modify(struct bgx *bgx, uint8_t lmac,
-			   uint64_t offset, uint64_t val)
+			   u64 offset, u64 val)
 {
-	uint64_t addr = (uintptr_t)bgx->reg_base +
+	u64 addr = (uintptr_t)bgx->reg_base +
 				((uint32_t)lmac << 20) + offset;
 
 	writeq(val | bgx_reg_read(bgx, lmac, offset), (void *)addr);
 }
 
 static int bgx_poll_reg(struct bgx *bgx, uint8_t lmac,
-			uint64_t reg, uint64_t mask, bool zero)
+			u64 reg, u64 mask, bool zero)
 {
 	int timeout = 200;
-	uint64_t reg_val;
+	u64 reg_val;
 
 	while (timeout) {
 		reg_val = bgx_reg_read(bgx, lmac, reg);
@@ -121,11 +120,13 @@ static int bgx_poll_reg(struct bgx *bgx, uint8_t lmac,
 	return 1;
 }
 
-static int gser_poll_reg(uint64_t reg, int bit, uint64_t mask, uint64_t expected_val, int timeout)
+static int gser_poll_reg(u64 reg, int bit, u64 mask, u64 expected_val,
+			 int timeout)
 {
-	uint64_t reg_val;
-	debug("gser_poll_reg: reg = %#llx, mask = %#llx, expected_val = %#llx, bit = %d\n",
-		reg, mask, expected_val, bit);
+	u64 reg_val;
+
+	debug("%s reg = %#llx, mask = %#llx,", __func__, reg, mask);
+	debug(" expected_val = %#llx, bit = %d\n", expected_val, bit);
 	while (timeout) {
 		reg_val = readq(CSR_PA(0, reg)) >> bit;
 		if ((reg_val & mask) == (expected_val))
@@ -138,8 +139,8 @@ static int gser_poll_reg(uint64_t reg, int bit, uint64_t mask, uint64_t expected
 
 static bool is_bgx_port_valid(int bgx, int lmac)
 {
-	debug("is_bgx_port_valid bgx %d lmac %d valid %d\n",
-	      bgx, lmac, bgx_board_info[bgx].lmac_reg[lmac]);
+	debug("%s bgx %d lmac %d valid %d\n", __func__, bgx, lmac,
+	      bgx_board_info[bgx].lmac_reg[lmac]);
 
 	if (bgx_board_info[bgx].lmac_reg[lmac])
 		return 1;
@@ -186,7 +187,8 @@ void bgx_get_count(int node, int *bgx_count)
 	*bgx_count = 0;
 	for (i = 0; i < CONFIG_MAX_BGX_PER_NODE; i++) {
 		bgx = bgx_vnic[node * CONFIG_MAX_BGX_PER_NODE + i];
-		debug("bgx_vnic[%u]: %p\n", node * CONFIG_MAX_BGX_PER_NODE + i, bgx);
+		debug("bgx_vnic[%u]: %p\n", node * CONFIG_MAX_BGX_PER_NODE + i,
+		      bgx);
 		if (bgx)
 			*bgx_count |= (1 << i);
 	}
@@ -220,10 +222,10 @@ void bgx_lmac_rx_tx_enable(int node, int bgx_idx, int lmacid, bool enable)
 	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
 }
 
-static void bgx_flush_dmac_addrs(struct bgx *bgx, uint64_t lmac)
+static void bgx_flush_dmac_addrs(struct bgx *bgx, u64 lmac)
 {
-	uint64_t dmac = 0x00;
-	uint64_t offset, addr;
+	u64 dmac = 0x00;
+	u64 offset, addr;
 
 	while (bgx->lmac[lmac].dmac > 0) {
 		offset = ((bgx->lmac[lmac].dmac - 1) * sizeof(dmac)) +
@@ -269,7 +271,7 @@ void bgx_lmac_internal_loopback(int node, int bgx_idx,
 static int get_qlm_for_bgx(int node, int bgx_id, int index)
 {
 	int qlm = 0;
-	uint64_t cfg;
+	u64 cfg;
 
 	if (is_board_model(CN81XX)) {
 		qlm = (bgx_id) ? 2 : 0;
@@ -295,7 +297,7 @@ static int get_qlm_for_bgx(int node, int bgx_id, int index)
 	}
 
 	cfg = readq(CSR_PA(node, GSERX_CFG(qlm))) & GSERX_CFG_BGX;
-	debug("get_qlm_for_bgx:qlm%d: cfg = %lld\n", qlm, cfg);
+	debug("%s:qlm%d: cfg = %lld\n", __func__, qlm, cfg);
 
 	/* Check if DLM is configured as BGX# */
 	if (cfg) {
@@ -313,7 +315,7 @@ static int bgx_lmac_sgmii_init(struct bgx *bgx, int lmacid)
 
 	lmac = &bgx->lmac[lmacid];
 
-	debug("bgx_lmac_sgmii_init: bgx_id = %d, lmacid = %d\n", bgx->bgx_id, lmacid);
+	debug("%s:bgx_id = %d, lmacid = %d\n", __func__, bgx->bgx_id, lmacid);
 
 	bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_TXX_THRESH, 0x30);
 	/* max packet size */
@@ -346,7 +348,8 @@ static int bgx_lmac_sgmii_init(struct bgx *bgx, int lmacid)
 	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
 
 	/* Disable disparity for QSGMII mode, to prevent propogation across
-	   ports. */
+	 * ports.
+	 */
 
 	if (lmac->qlm_mode == QLM_MODE_QSGMII) {
 		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL);
@@ -363,7 +366,7 @@ static int bgx_lmac_sgmii_init(struct bgx *bgx, int lmacid)
 
 	if (lmac->qlm_mode == QLM_MODE_SGMII) {
 		if (bgx_poll_reg(bgx, lmacid, BGX_GMP_PCS_MRX_STATUS,
-			 PCS_MRX_STATUS_AN_CPT, false)) {
+				 PCS_MRX_STATUS_AN_CPT, false)) {
 			printf("BGX AN_CPT not completed\n");
 			return -1;
 		}
@@ -379,31 +382,32 @@ static int bgx_lmac_sgmii_set_link_speed(struct lmac *lmac)
 	u64 cfg;
 	struct bgx *bgx = lmac->bgx;
 	unsigned int lmacid = lmac->lmacid;
-		
-	debug("bgx_lmac_sgmii_set_link_speed(): lmacid %d\n", lmac->lmacid);
+
+	debug("%s: lmacid %d\n", __func__, lmac->lmacid);
 
 	/* Disable LMAC before setting up speed */
 	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
 	cfg &= ~CMR_EN;
-        bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
 
 	/* Read GMX CFG */
 	prtx_cfg = bgx_reg_read(bgx, lmacid,
 				BGX_GMP_GMI_PRTX_CFG);
- 	/* Read PCS MISCS CTL */
+	/* Read PCS MISCS CTL */
 	pcs_miscx_ctl = bgx_reg_read(bgx, lmacid,
-				BGX_GMP_PCS_MISCX_CTL);
+				     BGX_GMP_PCS_MISCX_CTL);
 
 	/* Use GMXENO to force the link down*/
 	if (lmac->link_up) {
 		pcs_miscx_ctl &= ~PCS_MISC_CTL_GMX_ENO;
 		/* change the duplex setting if the link is up */
 		prtx_cfg |= GMI_PORT_CFG_DUPLEX;
-	} else 
+	} else {
 		pcs_miscx_ctl |= PCS_MISC_CTL_GMX_ENO;
+	}
 
 	/* speed based setting for GMX */
-	switch( lmac->last_speed) {
+	switch (lmac->last_speed) {
 	case 10:
 		prtx_cfg &= ~GMI_PORT_CFG_SPEED;
 		prtx_cfg |= GMI_PORT_CFG_SPEED_MSB;
@@ -429,23 +433,24 @@ static int bgx_lmac_sgmii_set_link_speed(struct lmac *lmac)
 		if (lmac->last_duplex)
 			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
 		else /* half duplex */
-			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0x2000);
+			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST,
+				      0x2000);
 		break;
 	default:
 		break;
 	}
-	
+
 	/* write back the new PCS misc and GMX settings */
 	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, pcs_miscx_ctl);
 	bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG, prtx_cfg);
 
 	/* read back GMX CFG again to check config completion */
 	bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG);
-		
+
 	/* enable BGX back */
 	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
 	cfg |= CMR_EN;
-       	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
 
 	return 0;
 }
@@ -546,17 +551,18 @@ static int bgx_lmac_xaui_init(struct bgx *bgx, int lmacid, int lmac_type)
 	bgx_reg_modify(bgx, lmacid, BGX_SMUX_RX_JABBER, MAX_FRAME_SIZE);
 
 	debug("xaui_init: lmacid = %d, qlm = %d, qlm_mode = %d\n",
-		lmacid, lmac->qlm, lmac->qlm_mode);
+	      lmacid, lmac->qlm, lmac->qlm_mode);
 	/* RXAUI with Marvell PHY requires some tweaking */
 	if (lmac->qlm_mode == QLM_MODE_RXAUI) {
 		char mii_name[20];
-		snprintf(mii_name, sizeof(mii_name), "smi%d",
-			 bgx_board_info[bgx->bgx_id].phy_info[lmacid].mdio_bus);
+		struct phy_info *phy;
+
+		phy = &bgx_board_info[bgx->bgx_id].phy_info[lmacid];
+		snprintf(mii_name, sizeof(mii_name), "smi%d", phy->mdio_bus);
 
 		debug("mii_name: %s\n", mii_name);
 		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
-		lmac->phy_addr = bgx_board_info[bgx->bgx_id].
-				 phy_info[lmacid].phy_addr;
+		lmac->phy_addr = phy->phy_addr;
 		__cavm_if_phy_xs_init(lmac->mii_bus, lmac->phy_addr);
 	}
 
@@ -580,24 +586,30 @@ int __rx_equalization(int qlm, int lane)
 	int l;
 	int fail = 0;
 
-	/* Before completing Rx equalization wait for GSERx_RX_EIE_DETSTS[CDRLOCK] to be set
-	   This ensures the rx data is valid */
+	/* Before completing Rx equalization wait for
+	 * GSERx_RX_EIE_DETSTS[CDRLOCK] to be set
+	 * This ensures the rx data is valid
+	 */
 	if (lane == -1) {
-		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, 0xf, (1 << max_lanes) - 1, 100)) {
-			debug("ERROR: DLM%d: CDR Lock not detected for 2 lanes\n", qlm);
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, 0xf,
+				  (1 << max_lanes) - 1, 100)) {
+			debug("ERROR: CDR Lock not detected");
+			debug(" on DLM%d for 2 lanes\n", qlm);
 			return -1;
 		}
 	} else {
-		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, (0xf & (1 << lane)), (1 << lane), 100)) {
-			debug("ERROR: DLM%d: CDR Lock not detected on %d lane\n", qlm, lane);
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK,
+				  (0xf & (1 << lane)), (1 << lane), 100)) {
+			debug("ERROR: DLM%d: CDR Lock not detected", qlm);
+			debug(" on %d lane\n", lane);
 			return -1;
 		}
 	}
 
 	for (l = 0; l < max_lanes; l++) {
-		uint64_t rctl, reer;
+		u64 rctl, reer;
 
-		if ((lane != -1) && (lane != l))
+		if (lane != -1 && lane != l)
 			continue;
 
 		/* Enable software control */
@@ -614,9 +626,9 @@ int __rx_equalization(int qlm, int lane)
 
 	/* Wait for RX equalization to complete */
 	for (l = 0; l < max_lanes; l++) {
-		uint64_t rctl, reer;
+		u64 rctl, reer;
 
-		if ((lane != -1) && (lane != l))
+		if (lane != -1 && lane != l)
 			continue;
 
 		gser_poll_reg(GSER_BR_RXX_EER(qlm, l), EER_RXT_ESV, 1, 1, 200);
@@ -628,10 +640,11 @@ int __rx_equalization(int qlm, int lane)
 		writeq(rctl, CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
 
 		if (reer & GSER_BR_RXX_EER_RXT_ESV) {
-			debug("Rx equalization completed on DLM%d lane%d, rxt_esm = 0x%llx\n",
-				qlm, l, (reer & 0x3fff));
+			debug("Rx equalization completed on DLM%d", qlm);
+			debug(" QLM%d rxt_esm = 0x%llx\n", l, (reer & 0x3fff));
 		} else {
-			debug("Rx equalization timedout on DLM%d lane%d\n", qlm, l);
+			debug("Rx equalization timedout on DLM%d", qlm);
+			debug(" lane %d\n", l);
 			fail = 1;
 		}
 	}
@@ -655,12 +668,13 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 		if (!(cfg & SPU_AN_STS_AN_COMPLETE)) {
 			/* Restart autonegotiation */
 			debug("restarting auto-neg\n");
-			bgx_reg_modify(bgx, lmacid, BGX_SPUX_AN_CONTROL, SPU_AN_CTL_AN_RESTART);
+			bgx_reg_modify(bgx, lmacid, BGX_SPUX_AN_CONTROL,
+				       SPU_AN_CTL_AN_RESTART);
 			return -1;
 		}
 	}
 
-	debug("%s link use_training %d\n",__func__, lmac->use_training);
+	debug("%s link use_training %d\n", __func__, lmac->use_training);
 	if (lmac->use_training) {
 		cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
 		if (!(cfg & (1ull << 13))) {
@@ -679,12 +693,14 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 	}
 
 	/* Perform RX Equalization. Applies to non-KR interfaces for speeds
-	   >= 6.25Gbps. */
+	 * >= 6.25Gbps.
+	 */
 	if (!lmac->use_training) {
 		int qlm;
 		bool use_dlm = 0;
-		if (is_board_model(CN81XX)
-		    || (is_board_model(CN83XX) && (bgx->bgx_id == 2)))
+
+		if (is_board_model(CN81XX) || (is_board_model(CN83XX) &&
+					       bgx->bgx_id == 2))
 			use_dlm = 1;
 		switch (lmac->lmac_type) {
 		default:
@@ -696,47 +712,57 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 		case BGX_MODE_XLAUI:
 			if (use_dlm) {
 				if (__rx_equalization(lmac->qlm, -1) ||
-					__rx_equalization(lmac->qlm+1, -1)) {
-					printf("BGX%d:%d: Waiting for RX Equalization on DLM%d/DLM%d\n",
-						bgx->bgx_id, lmacid, lmac->qlm, lmac->qlm+1);
+				    __rx_equalization(lmac->qlm + 1, -1)) {
+					printf("BGX%d:%d", bgx->bgx_id, lmacid);
+					printf(" Waiting for RX Equalization");
+					printf(" on DLM%d/DLM%d\n",
+					       lmac->qlm, lmac->qlm + 1);
 					return -1;
 				}
 			} else {
 				if (__rx_equalization(lmac->qlm, -1)) {
-					printf("BGX%d:%d: Waiting for RX Equalization on QLM%d:\n",
-						bgx->bgx_id, lmacid, lmac->qlm);
+					printf("BGX%d:%d", bgx->bgx_id, lmacid);
+					printf(" Waiting for RX Equalization");
+					printf(" on QLM%d\n", lmac->qlm);
 					return -1;
 				}
 			}
 			break;
 		case BGX_MODE_RXAUI:
-			/* RXAUI0 uses LMAC0:QLM0/QLM2 and RXAUI1 uses LMAC1:QLM1/QLM3
-			   RXAUI requires 2 lanes for each interface */
+			/* RXAUI0 uses LMAC0:QLM0/QLM2 and RXAUI1 uses
+			 * LMAC1:QLM1/QLM3 RXAUI requires 2 lanes
+			 * for each interface
+			 */
 			qlm = lmac->qlm;
 			if (__rx_equalization(qlm, 0)) {
-				printf("BGX%d:%d: Waiting for RX Equalization on QLM%d, Lane0\n",
-					bgx->bgx_id, lmacid, qlm);
+				printf("BGX%d:%d", bgx->bgx_id, lmacid);
+				printf(" Waiting for RX Equalization");
+				printf(" on QLM%d, Lane0\n", qlm);
 				return -1;
 			}
 			if (__rx_equalization(qlm, 1)) {
-				printf("BGX%d:%d: Waiting for RX Equalization on QLM%d, Lane1\n",
-					bgx->bgx_id, lmacid, qlm);
+				printf("BGX%d:%d", bgx->bgx_id, lmacid);
+				printf(" Waiting for RX Equalization");
+				printf(" on QLM%d, Lane1\n", qlm);
 				return -1;
 			}
 			break;
 		case BGX_MODE_XFI:
 			{
 				int lid;
-				if ((bgx->bgx_id == 0) && is_altpkg && lmacid)
+
+				if (bgx->bgx_id == 0 && is_altpkg && lmacid)
 					lid = 0;
 				else if ((lmacid >= 2) && use_dlm)
 					lid = lmacid - 2;
 				else
 					lid = lmacid;
 
-				if (__rx_equalization(lmac->qlm, lid))
-					printf("BGX%d:%d: Waiting for RX Equalization on QLM%d\n",
-						bgx->bgx_id, lid, lmac->qlm);
+				if (__rx_equalization(lmac->qlm, lid)) {
+					printf("BGX%d:%d", bgx->bgx_id, lid);
+					printf(" Waiting for RX Equalization");
+					printf(" on QLM%d\n", lmac->qlm);
+				}
 			}
 			break;
 		}
@@ -748,7 +774,7 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 		return -1;
 	}
 
-	if ((lmac_type == 3) || (lmac_type == 4)) {
+	if (lmac_type == 3 || lmac_type == 4) {
 		if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_BR_STATUS1,
 				 SPU_BR_STATUS_BLK_LOCK, false)) {
 			printf("SPU_BR_STATUS_BLK_LOCK not completed\n");
@@ -785,7 +811,7 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 	/* Wait for MAC RX to be ready */
 	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_RX_CTL,
 			 SMU_RX_CTL_STATUS, true)) {
-		printf( "SMU RX link not okay\n");
+		printf("SMU RX link not okay\n");
 		return -1;
 	}
 
@@ -807,8 +833,10 @@ static int bgx_xaui_check_link(struct lmac *lmac)
 	}
 
 	/* Receive link is latching low. Force it high and verify it */
-	if (!(bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS1) & SPU_STATUS1_RCV_LNK))
-		bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS1, SPU_STATUS1_RCV_LNK);
+	if (!(bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS1) &
+	    SPU_STATUS1_RCV_LNK))
+		bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS1,
+			       SPU_STATUS1_RCV_LNK);
 	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_STATUS1,
 			 SPU_STATUS1_RCV_LNK, false)) {
 		printf("SPU receive link down\n");
@@ -826,8 +854,9 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 	int ret;
 	struct lmac *lmac = bgx_get_lmac(node, bgx_idx, lmacid);
 	char mii_name[10];
+	struct phy_info *phy;
 
-	if (lmac == NULL) {
+	if (!lmac) {
 		printf("LMAC %d/%d/%d is disabled or doesn't exist\n",
 		       node, bgx_idx, lmacid);
 		return 0;
@@ -837,10 +866,9 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 	      __FILE__, __LINE__,
 	      node, bgx_idx, lmacid, lmac);
 
-	if ((lmac->qlm_mode == QLM_MODE_SGMII) ||
-	    (lmac->qlm_mode == QLM_MODE_RGMII) ||
-	    (lmac->qlm_mode == QLM_MODE_QSGMII)) {
-
+	if (lmac->qlm_mode == QLM_MODE_SGMII ||
+	    lmac->qlm_mode == QLM_MODE_RGMII ||
+	    lmac->qlm_mode == QLM_MODE_QSGMII) {
 		if (bgx_board_info[bgx_idx].phy_info[lmacid].phy_addr == -1) {
 			lmac->link_up = 1;
 			lmac->last_speed = 1000;
@@ -854,10 +882,10 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 		debug("mii_name: %s\n", mii_name);
 
 		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
-		lmac->phy_addr = bgx_board_info[bgx_idx].
-				 phy_info[lmacid].phy_addr;
+		phy = &bgx_board_info[bgx_idx].phy_info[lmacid];
+		lmac->phy_addr = phy->phy_addr;
 
-		debug("lmac->mii_bus: %p\n",lmac->mii_bus);
+		debug("lmac->mii_bus: %p\n", lmac->mii_bus);
 		if (!lmac->mii_bus) {
 			printf("MDIO device %s not found\n", mii_name);
 			ret = -ENODEV;
@@ -869,15 +897,14 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 					   if_mode[lmac->qlm_mode]);
 
 		if (!lmac->phydev) {
-			printf("%s: No PHY device\n",
-				__func__);
+			printf("%s: No PHY device\n", __func__);
 			return -1;
 		}
 
 		ret = phy_config(lmac->phydev);
 		if (ret) {
 			printf("%s: Could not initialize PHY %s\n",
-				__func__, lmac->phydev->dev->name);
+			       __func__, lmac->phydev->dev->name);
 			return ret;
 		}
 
@@ -885,7 +912,7 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 		debug("%s: %d\n", __FILE__, __LINE__);
 		if (ret) {
 			printf("%s: Could not initialize PHY %s\n",
-				__func__, lmac->phydev->dev->name);
+			       __func__, lmac->phydev->dev->name);
 		}
 
 #ifdef CONFIG_OCTEONTX_XCV
@@ -897,9 +924,10 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 		lmac->last_speed = lmac->phydev->speed;
 		lmac->last_duplex = lmac->phydev->duplex;
 
-		debug("bgx_poll_for_link(), qlm_mode %d phy link status 0x%x,"
-			"last speed 0x%x, duplex 0x%x\n",
-			lmac->qlm_mode, lmac->link_up, lmac->last_speed, lmac->last_duplex);
+		debug("%s qlm_mode %d phy link status 0x%x,last speed 0x%x,",
+		      __func__, lmac->qlm_mode, lmac->link_up,
+		      lmac->last_speed);
+		debug(" duplex 0x%x\n", lmac->last_duplex);
 
 		if (lmac->qlm_mode != QLM_MODE_RGMII)
 			bgx_lmac_sgmii_set_link_speed(lmac);
@@ -908,22 +936,24 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 		u64 status1;
 		u64 tx_ctl;
 		u64 rx_ctl;
-		status1 = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS1);
+
+		status1 = bgx_reg_read(lmac->bgx, lmac->lmacid,
+				       BGX_SPUX_STATUS1);
 		tx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_TX_CTL);
 		rx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_RX_CTL);
 
-		debug("BGX%d LMAC%d BGX_SPUX_STATUS2: %lx\n",
-		      bgx_idx, lmacid,
-		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS2));
-		debug("BGX%d LMAC%d BGX_SPUX_STATUS1: %lx\n",
-		      bgx_idx, lmacid,
-		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS1));
-		debug("BGX%d LMAC%d BGX_SMUX_RX_CTL: %lx\n",
-		      bgx_idx, lmacid,
-		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_RX_CTL));
-		debug("BGX%d LMAC%d BGX_SMUX_TX_CTL: %lx\n",
-		      bgx_idx, lmacid,
-		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_TX_CTL));
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS2: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SPUX_STATUS2));
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS1: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SPUX_STATUS1));
+		debug("BGX%d LMAC%d BGX_SMUX_RX_CTL: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SMUX_RX_CTL));
+		debug("BGX%d LMAC%d BGX_SMUX_TX_CTL: %lx\n", bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid,
+						  BGX_SMUX_TX_CTL));
 
 		if ((status1 & SPU_STATUS1_RCV_LNK) &&
 		    ((tx_ctl & SMU_TX_CTL_LNK_STATUS) == 0) &&
@@ -944,25 +974,25 @@ int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
 		lmac->last_link = lmac->link_up;
 	}
 
-	printf("BGX%d:LMAC %u link %s\n", bgx_idx, lmacid,  (lmac->link_up) ? "up" : "down");
+	printf("BGX%d:LMAC %u link %s\n", bgx_idx, lmacid,
+	       (lmac->link_up) ? "up" : "down");
 
 	return lmac->link_up;
 }
 
-
 static int bgx_lmac_enable(struct bgx *bgx, int8_t lmacid)
 {
 	struct lmac *lmac;
-	uint64_t cfg;
+	u64 cfg;
 
 	lmac = &bgx->lmac[lmacid];
 	lmac->bgx = bgx;
 
-	debug("bgx_lmac_enable: lmac: %p, lmacid = %d\n", lmac, lmacid);
+	debug("%s: lmac: %p, lmacid = %d\n", __func__, lmac, lmacid);
 
-	if ((lmac->qlm_mode == QLM_MODE_SGMII) ||
-	    (lmac->qlm_mode == QLM_MODE_RGMII) ||
-	    (lmac->qlm_mode == QLM_MODE_QSGMII)) {
+	if (lmac->qlm_mode == QLM_MODE_SGMII ||
+	    lmac->qlm_mode == QLM_MODE_RGMII ||
+	    lmac->qlm_mode == QLM_MODE_QSGMII) {
 		if (bgx_lmac_sgmii_init(bgx, lmacid)) {
 			debug("bgx_lmac_sgmii_init failed\n");
 			return -1;
@@ -990,7 +1020,7 @@ static int bgx_lmac_enable(struct bgx *bgx, int8_t lmacid)
 void bgx_lmac_disable(struct bgx *bgx, uint8_t lmacid)
 {
 	struct lmac *lmac;
-	uint64_t cmrx_cfg;
+	u64 cmrx_cfg;
 
 	lmac = &bgx->lmac[lmacid];
 
@@ -1007,19 +1037,21 @@ void bgx_lmac_disable(struct bgx *bgx, uint8_t lmacid)
 
 /* Program BGXX_CMRX_CONFIG.{lmac_type,lane_to_sds} for each interface.
  * And the number of LMACs used by this interface. Each lmac can be in
- * programmed in a different mode, so parse each lmac one at a time. */
+ * programmed in a different mode, so parse each lmac one at a time.
+ */
 static void bgx_init_hw(struct bgx *bgx)
 {
 	struct lmac *lmac;
 	int i, lmacid, count = 0, inc = 0;
 	char buf[40];
-	static int qsgmii_configured = 0;
+	static int qsgmii_configured;
 
 	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
 		struct lmac *tlmac;
 
 		lmac = &bgx->lmac[lmacid];
-		debug("bgx_init_hw: lmacid = %d, qlm = %d, mode = %d\n", lmacid, lmac->qlm, lmac->qlm_mode);
+		debug("%s: lmacid = %d, qlm = %d, mode = %d\n",
+		      __func__, lmacid, lmac->qlm, lmac->qlm_mode);
 		/* If QLM is not programmed, skip */
 		if (lmac->qlm == -1)
 			continue;
@@ -1028,8 +1060,9 @@ static void bgx_init_hw(struct bgx *bgx)
 		case QLM_MODE_SGMII:
 		{
 			/* EBB8000 (alternative pkg) has only lane0 present on
-			   DLM0 and DLM1, skip configuring other lanes */
-			if ((bgx->bgx_id == 0) && is_altpkg) {
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && is_altpkg) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1056,22 +1089,25 @@ static void bgx_init_hw(struct bgx *bgx)
 				lmac->lane_to_sds = 0x4;
 			} else if (lmacid == 1) {
 				struct lmac *tlmac;
+
 				tlmac = &bgx->lmac[2];
 				if (tlmac->qlm_mode == QLM_MODE_RXAUI) {
 					lmac->lmac_type = 2;
 					lmac->lane_to_sds = 0xe;
 					lmac->qlm = tlmac->qlm;
 				}
-			} else
+			} else {
 				continue;
+			}
 			snprintf(buf, sizeof(buf),
 				 "BGX%d QLM%d LMAC%d mode: RXAUI\n",
 				 bgx->bgx_id, lmac->qlm, lmacid);
 			break;
 		case QLM_MODE_XFI:
 			/* EBB8000 (alternative pkg) has only lane0 present on
-			   DLM0 and DLM1, skip configuring other lanes */
-			if ((bgx->bgx_id == 0) && is_altpkg) {
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && is_altpkg) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1092,8 +1128,9 @@ static void bgx_init_hw(struct bgx *bgx)
 			break;
 		case QLM_MODE_10G_KR:
 			/* EBB8000 (alternative pkg) has only lane0 present on
-			   DLM0 and DLM1, skip configuring other lanes */
-			if ((bgx->bgx_id == 0) && is_altpkg) {
+			 * DLM0 and DLM1, skip configuring other lanes
+			 */
+			if (bgx->bgx_id == 0 && is_altpkg) {
 				if (lmacid % 2)
 					continue;
 			}
@@ -1126,19 +1163,23 @@ static void bgx_init_hw(struct bgx *bgx)
 		case QLM_MODE_QSGMII:
 			if (qsgmii_configured)
 				continue;
-			if ((lmacid == 0) || (lmacid == 2)) {
+			if (lmacid == 0 || lmacid == 2) {
 				count = 4;
 				printf("BGX%d QLM%d LMAC%d mode: QSGMII\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				       bgx->bgx_id, lmac->qlm, lmacid);
 				for (i = 0; i < count; i++) {
 					struct lmac *l;
+					int type;
+
 					l = &bgx->lmac[i];
 					l->lmac_type = 6;
+					type = l->lmac_type;
 					l->qlm_mode = QLM_MODE_QSGMII;
 					l->lane_to_sds = lmacid + i;
 					if (is_bgx_port_valid(bgx->bgx_id, i))
-						bgx_reg_write(bgx, i, BGX_CMRX_CFG,
-							      (l->lmac_type << 8) |
+						bgx_reg_write(bgx, i,
+							      BGX_CMRX_CFG,
+							      (type << 8) |
 							      l->lane_to_sds);
 				}
 				qsgmii_configured = 1;
@@ -1150,19 +1191,26 @@ static void bgx_init_hw(struct bgx *bgx)
 
 		/* Reset lmac to the unused slot */
 		if (is_bgx_port_valid(bgx->bgx_id, count) &&
-		    (lmac->qlm_mode != QLM_MODE_QSGMII)) {
-			int lmac_enable = 0;
+		    lmac->qlm_mode != QLM_MODE_QSGMII) {
+			int lmac_en = 0;
+			int tmp, idx;
+
 			tlmac = &bgx->lmac[count];
 			tlmac->lmac_type = lmac->lmac_type;
+			idx = bgx->bgx_id;
+			tmp = count + inc;
 			/* Adjust lane_to_sds based on BGX-ENABLE */
-			for (; (inc + count) < MAX_LMAC_PER_BGX; inc++) {
-				lmac_enable = bgx_board_info[bgx->bgx_id].lmac_enable[count + inc];
-				if (lmac_enable)
+			for (; tmp < MAX_LMAC_PER_BGX; inc++) {
+				lmac_en = bgx_board_info[idx].lmac_enable[tmp];
+				if (lmac_en)
 					break;
+				tmp = count + inc;
 			}
 
-			if ((inc != 0) && (inc < MAX_LMAC_PER_BGX) && lmac_enable && (inc != count))
-				tlmac->lane_to_sds = lmac->lane_to_sds + abs(inc - count);
+			if (inc != 0 && inc < MAX_LMAC_PER_BGX &&
+			    lmac_en && inc != count)
+				tlmac->lane_to_sds =
+					lmac->lane_to_sds + abs(inc - count);
 			else
 				tlmac->lane_to_sds = lmac->lane_to_sds;
 			tlmac->qlm = lmac->qlm;
@@ -1217,8 +1265,8 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 		int train_en;
 		int index = 0;
 
-		if (is_board_model(CN81XX)
-		    || (is_board_model(CN83XX) && (bgx->bgx_id == 2)))
+		if (is_board_model(CN81XX) || (is_board_model(CN83XX) &&
+					       bgx->bgx_id == 2))
 			index = (lmacid < 2) ? 0 : 2;
 
 		lmac = &bgx->lmac[lmacid];
@@ -1229,24 +1277,24 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 
 		lmac_type = bgx_reg_read(bgx, index, BGX_CMRX_CFG);
 		lmac->lmac_type = (lmac_type >> 8) & 0x07;
-		debug("bgx_get_qlm_mode:%d:%d: lmac_type = %d, altpkg = %d\n", bgx->bgx_id,
-				lmacid, lmac->lmac_type, is_altpkg);
+		debug("%s:%d:%d: lmac_type = %d, altpkg = %d\n", __func__,
+		      bgx->bgx_id, lmacid, lmac->lmac_type, is_altpkg);
 
 		train_en = (readq(CSR_PA(0, GSERX_SCRATCH(lmac->qlm))) & 0xf);
 		lmac->is_1gx = bgx_reg_read(bgx, index, BGX_GMP_PCS_MISCX_CTL)
 				& (PCS_MISC_CTL_MODE) ? true : false;
 
-		switch(lmac->lmac_type) {
+		switch (lmac->lmac_type) {
 		case BGX_MODE_SGMII:
 			if (bgx->is_rgx) {
 				if (lmacid == 0) {
 					lmac->qlm_mode = QLM_MODE_RGMII;
 					debug("BGX%d LMAC%d mode: RGMII\n",
-							bgx->bgx_id, lmacid);
+					      bgx->bgx_id, lmacid);
 				}
 				continue;
 			} else {
-				if ((bgx->bgx_id == 0) && is_altpkg) {
+				if (bgx->bgx_id == 0 && is_altpkg) {
 					if (lmacid % 2)
 						continue;
 				}
@@ -1257,69 +1305,68 @@ static void bgx_get_qlm_mode(struct bgx *bgx)
 			}
 			break;
 		case BGX_MODE_XAUI:
-			if ((bgx->bgx_id == 0) && is_altpkg)
+			if (bgx->bgx_id == 0 && is_altpkg)
 				continue;
 			lmac->qlm_mode = QLM_MODE_XAUI;
 			if (lmacid != 0)
 				continue;
 			debug("BGX%d QLM%d LMAC%d mode: XAUI\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+			      bgx->bgx_id, lmac->qlm, lmacid);
 			break;
 		case BGX_MODE_RXAUI:
-			if ((bgx->bgx_id == 0) && is_altpkg)
+			if (bgx->bgx_id == 0 && is_altpkg)
 				continue;
 			lmac->qlm_mode = QLM_MODE_RXAUI;
 			if (index == lmacid) {
 				debug("BGX%d QLM%d LMAC%d mode: RXAUI\n",
-					bgx->bgx_id, lmac->qlm, (index ? 1 : 0));
+				      bgx->bgx_id, lmac->qlm, (index ? 1 : 0));
 			}
 			break;
 		case BGX_MODE_XFI:
-			if ((bgx->bgx_id == 0) && is_altpkg) {
+			if (bgx->bgx_id == 0 && is_altpkg) {
 				if (lmacid % 2)
 					continue;
 			}
-			if (((lmacid < 2) && (train_en & (1 << lmacid)))
-			    || (train_en & (1 << (lmacid - 2)))) {
+			if ((lmacid < 2 && (train_en & (1 << lmacid))) ||
+			    (train_en & (1 << (lmacid - 2)))) {
 				lmac->qlm_mode = QLM_MODE_10G_KR;
 				debug("BGX%d QLM%d LMAC%d mode: 10G_KR\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				      bgx->bgx_id, lmac->qlm, lmacid);
 			} else {
 				lmac->qlm_mode = QLM_MODE_XFI;
 				debug("BGX%d QLM%d LMAC%d mode: XFI\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				      bgx->bgx_id, lmac->qlm, lmacid);
 			}
 			break;
 		case BGX_MODE_XLAUI:
-			if ((bgx->bgx_id == 0) && is_altpkg)
+			if (bgx->bgx_id == 0 && is_altpkg)
 				continue;
 			if (train_en) {
 				lmac->qlm_mode = QLM_MODE_40G_KR4;
 				if (lmacid != 0)
 					break;
 				debug("BGX%d QLM%d LMAC%d mode: 40G_KR4\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				      bgx->bgx_id, lmac->qlm, lmacid);
 			} else {
 				lmac->qlm_mode = QLM_MODE_XLAUI;
 				if (lmacid != 0)
 					break;
 				debug("BGX%d QLM%d LMAC%d mode: XLAUI\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				      bgx->bgx_id, lmac->qlm, lmacid);
 			}
 		break;
 		case BGX_MODE_QSGMII:
 			/* If QLM is configured as QSGMII, use lmac0 */
-			if (is_board_model(CN83XX)
-			    && (lmacid == 2)
-			    && (bgx->bgx_id != 2)) {
+			if (is_board_model(CN83XX) && lmacid == 2 &&
+			    bgx->bgx_id != 2) {
 				//lmac->qlm_mode = QLM_MODE_DISABLED;
 				continue;
 			}
 
-			if ((lmacid == 0) || (lmacid == 2)) {
+			if (lmacid == 0 || lmacid == 2) {
 				lmac->qlm_mode = QLM_MODE_QSGMII;
 				debug("BGX%d QLM%d LMAC%d mode: QSGMII\n",
-					bgx->bgx_id, lmac->qlm, lmacid);
+				      bgx->bgx_id, lmac->qlm, lmacid);
 			}
 			break;
 		default:
@@ -1340,17 +1387,17 @@ void bgx_set_board_info(int bgx_id, int *mdio_bus,
 		bgx_board_info[bgx_id].phy_info[i].autoneg_dis = autoneg_dis[i];
 		bgx_board_info[bgx_id].lmac_reg[i] = lmac_reg[i];
 		bgx_board_info[bgx_id].lmac_enable[i] = lmac_enable[i];
-		debug("bgx_set_board_info bgx_id %d lmac %d phy_addr 0x%x mdio bus %d\n"
-		      "autoneg_dis %d lmac_reg %d, lmac_enable = %d\n", bgx_id, i,
-			bgx_board_info[bgx_id].phy_info[i].phy_addr,
-			bgx_board_info[bgx_id].phy_info[i].mdio_bus,
-			bgx_board_info[bgx_id].phy_info[i].autoneg_dis,
-			bgx_board_info[bgx_id].lmac_reg[i],
-			bgx_board_info[bgx_id].lmac_enable[i]);
+		debug("%s bgx_id %d lmac %d\n", __func__, bgx_id, i);
+		debug("phy addr %x mdio bus %d autoneg_dis %d lmac_reg %d\n",
+		      bgx_board_info[bgx_id].phy_info[i].phy_addr,
+		      bgx_board_info[bgx_id].phy_info[i].mdio_bus,
+		      bgx_board_info[bgx_id].phy_info[i].autoneg_dis,
+		      bgx_board_info[bgx_id].lmac_reg[i]);
+		debug("lmac_enable = %x\n",
+		      bgx_board_info[bgx_id].lmac_enable[i]);
 	}
 }
 
-
 int octeontx_bgx_remove(struct udevice *dev)
 {
 	int lmacid;
@@ -1358,28 +1405,30 @@ int octeontx_bgx_remove(struct udevice *dev)
 	int count = MAX_LMAC_PER_BGX;
 	struct bgx *bgx = dev_get_priv(dev);
 
-	if (bgx->reg_base == NULL)
+	if (!bgx->reg_base)
 		return 0;
 
 	if (bgx->is_rgx)
 		count = 1;
 
 	for (lmacid = 0; lmacid < count; lmacid++) {
-		struct lmac *lmac;	
+		struct lmac *lmac;
+
 		lmac = &bgx->lmac[lmacid];
 		cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
 		cfg &= ~(CMR_PKT_RX_EN | CMR_PKT_TX_EN);
 		bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
 
 		/* Disable PCS for 1G interface */
-		if ((lmac->lmac_type == BGX_MODE_SGMII)
-		    || (lmac->lmac_type == BGX_MODE_QSGMII)) {
+		if (lmac->lmac_type == BGX_MODE_SGMII ||
+		    lmac->lmac_type == BGX_MODE_QSGMII) {
 			cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MRX_CTL);
 			cfg |= PCS_MRX_CTL_PWR_DN;
 			bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
 		}
 
-		debug("%s disabling bgx%d lmacid%d\n", __func__, bgx->bgx_id, lmacid);
+		debug("%s disabling bgx%d lmacid%d\n", __func__, bgx->bgx_id,
+		      lmacid);
 		bgx_lmac_disable(bgx, lmacid);
 	}
 	return 0;
@@ -1389,14 +1438,14 @@ int octeontx_bgx_probe(struct udevice *dev)
 {
 	int err;
 	struct bgx *bgx = dev_get_priv(dev);
-	uint8_t lmac = 0;
+	u8 lmac = 0;
 	int qlm[4] = {-1, -1, -1, -1};
 	int bgx_idx, node;
 	size_t size;
 	int inc = 1;
 
 	bgx->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
-	if (bgx->reg_base == NULL) {
+	if (!bgx->reg_base) {
 		debug("No PCI region found\n");
 		return 0;
 	}
@@ -1431,18 +1480,20 @@ int octeontx_bgx_probe(struct udevice *dev)
 
 	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac += inc) {
 		/* BGX3 (DLM4), has only 2 lanes */
-		if (is_board_model(CN83XX) && (bgx_idx == 3) && lmac >= 2)
+		if (is_board_model(CN83XX) && bgx_idx == 3 && lmac >= 2)
 			continue;
 		qlm[lmac + 0] = get_qlm_for_bgx(node, bgx_idx, lmac);
 		/* Each DLM has 2 lanes, configure both lanes with
-		   same qlm configuration */
+		 * same qlm configuration
+		 */
 		if (inc == 2)
 			qlm[lmac + 1] = qlm[lmac];
 		debug("qlm[%d] = %d\n", lmac, qlm[lmac]);
 	}
 
 	/* A BGX can take 1 or 2 DLMs, if both the DLMs are not configured
-	   as BGX, then return, nothing to initialize */
+	 * as BGX, then return, nothing to initialize
+	 */
 	if (is_board_model(CN81XX))
 		if ((qlm[0] == -1) && (qlm[2] == -1))
 			return -ENODEV;
@@ -1465,11 +1516,12 @@ skip_qlm_config:
 	/* Enable all LMACs */
 	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
 		struct lmac *tlmac = &bgx->lmac[lmac];
+
 		tlmac->dev = dev;
 		err = bgx_lmac_enable(bgx, lmac);
 		if (err) {
 			printf("BGX%d failed to enable lmac%d\n",
-				bgx->bgx_id, lmac);
+			       bgx->bgx_id, lmac);
 		}
 	}
 
diff --git a/drivers/net/octeontx/octeontx_bgx.h b/drivers/net/octeontx/octeontx_bgx.h
index d64fad112f..a00fa7a794 100644
--- a/drivers/net/octeontx/octeontx_bgx.h
+++ b/drivers/net/octeontx/octeontx_bgx.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef OCTEONT_BGX_H
 #define OCTEONT_BGX_H
 
@@ -19,28 +18,30 @@
 #define    MAX_LMAC	(CONFIG_MAX_BGX_PER_NODE * MAX_LMAC_PER_BGX)
 
 #define    NODE_ID_MASK				0x300000000000
-#define    NODE_ID(x)				((x & NODE_ID_MASK) >> 44)
+#define    NODE_ID(x)				(((x) & NODE_ID_MASK) >> 44)
 
 /* Registers */
-#define GSERX_CFG(x)		(0x000087E090000080ull + (x) * 0x1000000ull)
-#define GSERX_SCRATCH(x)	(0x000087E090000020ull + (x) * 0x1000000ull)
-#define GSERX_PHY_CTL(x)	(0x000087E090000000ull + (x) * 0x1000000ull)
-#define GSERX_CFG_BGX		(1 << 2)
-#define GSER_RX_EIE_DETSTS(x)	(0x000087e090000150ull + (x) * 0x1000000ull)
+#define GSERX_CFG(x)		(0x87E090000080ull + (x) * 0x1000000ull)
+#define GSERX_SCRATCH(x)	(0x87E090000020ull + (x) * 0x1000000ull)
+#define GSERX_PHY_CTL(x)	(0x87E090000000ull + (x) * 0x1000000ull)
+#define GSERX_CFG_BGX		BIT(2)
+#define GSER_RX_EIE_DETSTS(x)	(0x87E090000150ull + (x) * 0x1000000ull)
 #define GSER_CDRLOCK		(8)
-#define GSER_BR_RXX_CTL(x,y)	(0x000087e090000400ull + (x) * 0x1000000ull + (y) * 0x80) 
-#define GSER_BR_RXX_CTL_RXT_SWM	(1 << 2)
-#define GSER_BR_RXX_EER(x,y)	(0x000087e090000418ull + (x) * 0x1000000ull + (y) * 0x80)
-#define GSER_BR_RXX_EER_RXT_ESV (1 << 14)
-#define GSER_BR_RXX_EER_RXT_EER (1 << 15)
+#define GSER_BR_RXX_CTL(x, y)	(0x87E090000400ull + (x) * 0x1000000ull + \
+				(y) * 0x80)
+#define GSER_BR_RXX_CTL_RXT_SWM	BIT(2)
+#define GSER_BR_RXX_EER(x, y)	(0x87E090000418ull + (x) * 0x1000000ull + \
+				(y) * 0x80)
+#define GSER_BR_RXX_EER_RXT_ESV BIT(14)
+#define GSER_BR_RXX_EER_RXT_EER BIT(15)
 #define EER_RXT_ESV		(14)
 
 #define BGX_CMRX_CFG			0x00
-#define CMR_PKT_TX_EN				(1ull << 13)
-#define CMR_PKT_RX_EN				(1ull << 14)
-#define CMR_EN					(1ull << 15)
+#define CMR_PKT_TX_EN				BIT_ULL(13)
+#define CMR_PKT_RX_EN				BIT_ULL(14)
+#define CMR_EN					BIT_ULL(15)
 #define BGX_CMR_GLOBAL_CFG		0x08
-#define CMR_GLOBAL_CFG_FCS_STRIP		(1ull << 6)
+#define CMR_GLOBAL_CFG_FCS_STRIP		BIT_ULL(6)
 #define BGX_CMRX_RX_ID_MAP		0x60
 #define BGX_CMRX_RX_STAT0		0x70
 #define BGX_CMRX_RX_STAT1		0x78
@@ -56,11 +57,11 @@
 #define BGX_CMRX_RX_BP_DROP		0xC8
 #define BGX_CMRX_RX_DMAC_CTL		0x0E8
 #define BGX_CMR_RX_DMACX_CAM		0x200
-#define RX_DMACX_CAM_EN				(1ull << 48)
-#define RX_DMACX_CAM_LMACID(x)			(x << 49)
-#define RX_DMAC_COUNT				32
+#define RX_DMACX_CAM_EN				BIT_ULL(48)
+#define RX_DMACX_CAM_LMACID(x)			((x) << 49)
+#define RX_DMAC_COUNT			32
 #define BGX_CMR_RX_STREERING		0x300
-#define RX_TRAFFIC_STEER_RULE_COUNT		8
+#define RX_TRAFFIC_STEER_RULE_COUNT	8
 #define BGX_CMR_CHAN_MSK_AND		0x450
 #define BGX_CMR_BIST_STATUS		0x460
 #define BGX_CMR_RX_LMACS		0x468
@@ -85,81 +86,81 @@
 #define BGX_CMR_TX_LMACS		0x1000
 
 #define BGX_SPUX_CONTROL1		0x10000
-#define SPU_CTL_LOW_POWER			(1ull << 11)
-#define SPU_CTL_LOOPBACK                        (1ull << 14)
-#define SPU_CTL_RESET				(1ull << 15)
+#define SPU_CTL_LOW_POWER			BIT_ULL(11)
+#define SPU_CTL_LOOPBACK                        BIT_ULL(14)
+#define SPU_CTL_RESET				BIT_ULL(15)
 #define BGX_SPUX_STATUS1		0x10008
-#define SPU_STATUS1_RCV_LNK			(1ull << 2)
+#define SPU_STATUS1_RCV_LNK			BIT_ULL(2)
 #define BGX_SPUX_STATUS2		0x10020
-#define SPU_STATUS2_RCVFLT			(1ull << 10)
+#define SPU_STATUS2_RCVFLT			BIT_ULL(10)
 #define BGX_SPUX_BX_STATUS		0x10028
-#define SPU_BX_STATUS_RX_ALIGN                  (1ull << 12)
+#define SPU_BX_STATUS_RX_ALIGN                  BIT_ULL(12)
 #define BGX_SPUX_BR_STATUS1		0x10030
-#define SPU_BR_STATUS_BLK_LOCK			(1ull << 0)
-#define SPU_BR_STATUS_RCV_LNK			(1ull << 12)
+#define SPU_BR_STATUS_BLK_LOCK			BIT_ULL(0)
+#define SPU_BR_STATUS_RCV_LNK			BIT_ULL(12)
 #define BGX_SPUX_BR_PMD_CRTL		0x10068
-#define SPU_PMD_CRTL_TRAIN_EN			(1ull << 1)
+#define SPU_PMD_CRTL_TRAIN_EN			BIT_ULL(1)
 #define BGX_SPUX_BR_PMD_LP_CUP		0x10078
 #define BGX_SPUX_BR_PMD_LD_CUP		0x10088
 #define BGX_SPUX_BR_PMD_LD_REP		0x10090
 #define BGX_SPUX_FEC_CONTROL		0x100A0
-#define SPU_FEC_CTL_FEC_EN			(1ull << 0)
-#define SPU_FEC_CTL_ERR_EN			(1ull << 1)
+#define SPU_FEC_CTL_FEC_EN			BIT_ULL(0)
+#define SPU_FEC_CTL_ERR_EN			BIT_ULL(1)
 #define BGX_SPUX_AN_CONTROL		0x100C8
-#define SPU_AN_CTL_AN_EN			(1ull << 12)
-#define SPU_AN_CTL_XNP_EN			(1ull << 13)
-#define SPU_AN_CTL_AN_RESTART			(1ull << 15)
+#define SPU_AN_CTL_AN_EN			BIT_ULL(12)
+#define SPU_AN_CTL_XNP_EN			BIT_ULL(13)
+#define SPU_AN_CTL_AN_RESTART			BIT_ULL(15)
 #define BGX_SPUX_AN_STATUS		0x100D0
-#define SPU_AN_STS_AN_COMPLETE			(1ull << 5)
+#define SPU_AN_STS_AN_COMPLETE			BIT_ULL(5)
 #define BGX_SPUX_AN_ADV			0x100D8
 #define BGX_SPUX_MISC_CONTROL		0x10218
-#define SPU_MISC_CTL_INTLV_RDISP		(1ull << 10)
-#define SPU_MISC_CTL_RX_DIS			(1ull << 12)
+#define SPU_MISC_CTL_INTLV_RDISP		BIT_ULL(10)
+#define SPU_MISC_CTL_RX_DIS			BIT_ULL(12)
 #define BGX_SPUX_INT			0x10220	/* +(0..3) << 20 */
 #define BGX_SPUX_INT_W1S		0x10228
 #define BGX_SPUX_INT_ENA_W1C		0x10230
 #define BGX_SPUX_INT_ENA_W1S		0x10238
 #define BGX_SPU_DBG_CONTROL		0x10300
-#define SPU_DBG_CTL_AN_ARB_LINK_CHK_EN		(1ull << 18)
-#define SPU_DBG_CTL_AN_NONCE_MCT_DIS		(1ull << 29)
+#define SPU_DBG_CTL_AN_ARB_LINK_CHK_EN		BIT_ULL(18)
+#define SPU_DBG_CTL_AN_NONCE_MCT_DIS		BIT_ULL(29)
 
 #define BGX_SMUX_RX_INT			0x20000
 #define BGX_SMUX_RX_JABBER		0x20030
 #define BGX_SMUX_RX_CTL			0x20048
 #define SMU_RX_CTL_STATUS			(3ull << 0)
 #define BGX_SMUX_TX_APPEND		0x20100
-#define SMU_TX_APPEND_FCS_D			(1ull << 2)
+#define SMU_TX_APPEND_FCS_D			BIT_ULL(2)
 #define BGX_SMUX_TX_MIN_PKT		0x20118
 #define BGX_SMUX_TX_INT			0x20140
 #define BGX_SMUX_TX_CTL			0x20178
-#define SMU_TX_CTL_DIC_EN			(1ull << 0)
-#define SMU_TX_CTL_UNI_EN			(1ull << 1)
+#define SMU_TX_CTL_DIC_EN			BIT_ULL(0)
+#define SMU_TX_CTL_UNI_EN			BIT_ULL(1)
 #define SMU_TX_CTL_LNK_STATUS			(3ull << 4)
 #define BGX_SMUX_TX_THRESH		0x20180
 #define BGX_SMUX_CTL			0x20200
-#define SMU_CTL_RX_IDLE				(1ull << 0)
-#define SMU_CTL_TX_IDLE				(1ull << 1)
+#define SMU_CTL_RX_IDLE				BIT_ULL(0)
+#define SMU_CTL_TX_IDLE				BIT_ULL(1)
 
 #define BGX_GMP_PCS_MRX_CTL		0x30000
-#define	PCS_MRX_CTL_RST_AN			(1ull << 9)
-#define	PCS_MRX_CTL_PWR_DN			(1ull << 11)
-#define	PCS_MRX_CTL_AN_EN			(1ull << 12)
-#define PCS_MRX_CTL_LOOPBACK1                   (1ull << 14)
-#define	PCS_MRX_CTL_RESET			(1ull << 15)
+#define	PCS_MRX_CTL_RST_AN			BIT_ULL(9)
+#define	PCS_MRX_CTL_PWR_DN			BIT_ULL(11)
+#define	PCS_MRX_CTL_AN_EN			BIT_ULL(12)
+#define PCS_MRX_CTL_LOOPBACK1                   BIT_ULL(14)
+#define	PCS_MRX_CTL_RESET			BIT_ULL(15)
 #define BGX_GMP_PCS_MRX_STATUS		0x30008
-#define	PCS_MRX_STATUS_AN_CPT			(1ull << 5)
+#define	PCS_MRX_STATUS_AN_CPT			BIT_ULL(5)
 #define BGX_GMP_PCS_ANX_AN_RESULTS	0x30020
 #define BGX_GMP_PCS_SGM_AN_ADV		0x30068
 #define BGX_GMP_PCS_MISCX_CTL		0x30078
-#define PCS_MISCX_CTL_DISP_EN			(1ull << 13)
-#define PCS_MISC_CTL_GMX_ENO			(1ull << 11)
+#define PCS_MISCX_CTL_DISP_EN			BIT_ULL(13)
+#define PCS_MISC_CTL_GMX_ENO			BIT_ULL(11)
 #define PCS_MISC_CTL_SAMP_PT_MASK		0x7Full
-#define PCS_MISC_CTL_MODE			(1ull << 8)
+#define PCS_MISC_CTL_MODE			BIT_ULL(8)
 #define BGX_GMP_GMI_PRTX_CFG		0x38020
-#define GMI_PORT_CFG_SPEED			(1ull << 1)
-#define GMI_PORT_CFG_DUPLEX			(1ull << 2)
-#define GMI_PORT_CFG_SLOT_TIME			(1ull << 3)
-#define GMI_PORT_CFG_SPEED_MSB			(1ull << 8)
+#define GMI_PORT_CFG_SPEED			BIT_ULL(1)
+#define GMI_PORT_CFG_DUPLEX			BIT_ULL(2)
+#define GMI_PORT_CFG_SLOT_TIME			BIT_ULL(3)
+#define GMI_PORT_CFG_SPEED_MSB			BIT_ULL(8)
 #define BGX_GMP_GMI_RXX_JABBER		0x38038
 #define BGX_GMP_GMI_TXX_THRESH		0x38210
 #define BGX_GMP_GMI_TXX_APPEND		0x38218
@@ -187,8 +188,8 @@
 #define CMR_MEM_INT		28
 #define SPU_MEM_INT		29
 
-#define LMAC_INTR_LINK_UP	(1 << 0)
-#define LMAC_INTR_LINK_DOWN	(1 << 1)
+#define LMAC_INTR_LINK_UP	BIT(0)
+#define LMAC_INTR_LINK_DOWN	BIT(1)
 
 /*  RX_DMAC_CTL configuration*/
 enum MCAST_MODE {
@@ -202,7 +203,7 @@ enum MCAST_MODE {
 #define CAM_ACCEPT	1
 
 int octeontx_bgx_initialize(unsigned int bgx_idx, unsigned int node);
-void bgx_add_dmac_addr(uint64_t dmac, int node, int bgx_idx, int lmac);
+void bgx_add_dmac_addr(u64 dmac, int node, int bgx_idx, int lmac);
 void bgx_get_count(int node, int *bgx_count);
 int bgx_get_lmac_count(int node, int bgx);
 void bgx_print_stats(int bgx_idx, int lmac);
diff --git a/drivers/net/octeontx/octeontx_smi.c b/drivers/net/octeontx/octeontx_smi.c
index 2b21170d95..fa9aca2b05 100644
--- a/drivers/net/octeontx/octeontx_smi.c
+++ b/drivers/net/octeontx/octeontx_smi.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <dm.h>
 #include <pci.h>
@@ -167,7 +166,6 @@ int octeontx_phy_read(struct mii_dev *bus, int addr, int devad, int regnum)
 	smix_cmd.u = 0;
 	smix_cmd.s.phy_adr = addr;
 
-
 	if (mode == CLAUSE45) {
 		smix_cmd.s.reg_adr = devad;
 		smix_cmd.s.phy_op = SMI_OP_C45_READ;
@@ -271,40 +269,39 @@ int __cavm_if_phy_xs_init(struct mii_dev *bus, int phy_addr)
 	phy_id1 = octeontx_phy_read(bus, phy_addr, 1, 0x2);
 	phy_id2 = octeontx_phy_read(bus, phy_addr, 1, 0x3);
 	model_number = (phy_id2 >> 4) & 0x3F;
-	debug("%s model %x\n", __func__,model_number);
+	debug("%s model %x\n", __func__, model_number);
 	oui = phy_id1;
 	oui <<= 6;
 	oui |= (phy_id2 >> 10) & 0x3F;
-	debug("%s oui %x\n", __func__,oui);
-	switch (oui)
-	{
-		case 0x5016:
-			if (model_number == 9)
-			{
-				debug("%s +\n", __func__);
-				/* Perform hardware reset in XGXS control */
+	debug("%s oui %x\n", __func__, oui);
+	switch (oui) {
+	case 0x5016:
+		if (model_number == 9) {
+			debug("%s +\n", __func__);
+			/* Perform hardware reset in XGXS control */
+			reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
+			if ((reg & 0xffff) < 0)
+				goto read_error;
+			reg |= 0x8000;
+			octeontx_phy_write(bus, phy_addr, 4, 0x0, reg);
+
+			start_time = get_timer(0);
+			do {
 				reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
 				if ((reg & 0xffff) < 0)
-				       goto read_error;
-				reg |= 0x8000;
-				octeontx_phy_write(bus, phy_addr, 4, 0x0, reg);
-
-				start_time = get_timer(0);
-				do {
-				       reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
-				       if ((reg & 0xffff) < 0)
-					       goto read_error;
-				} while ((reg & 0x8000) && get_timer(start_time) < 500);
-				if (reg & 0x8000) {
-				       printf("Hardware reset for M88X3120 PHY failed, MII_BMCR: 0x%x\n", reg);
-				       return -1;
-				}
-				/* program 4.49155 with 0x5 */
-				octeontx_phy_write(bus, phy_addr, 4, 0xc003, 0x5);
+					goto read_error;
+			} while ((reg & 0x8000) && get_timer(start_time) < 500);
+			if (reg & 0x8000) {
+				printf("HW reset for M88X3120 PHY failed");
+				printf("MII_BMCR: 0x%x\n", reg);
+				return -1;
 			}
-			break;
-			default:
-				break;
+			/* program 4.49155 with 0x5 */
+			octeontx_phy_write(bus, phy_addr, 4, 0xc003, 0x5);
+		}
+		break;
+	default:
+		break;
 	}
 
 	return 0;
@@ -322,9 +319,9 @@ int octeontx_smi_probe(struct udevice *dev)
 	struct octeontx_smi_priv *priv;
 	pci_dev_t bdf = dm_pci_get_bdf(dev);
 
-        debug("SMI PCI device: %x\n", bdf);
-        dev->req_seq = PCI_FUNC(bdf);
-        if ( !dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM)) {
+	debug("SMI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+	if (!dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM)) {
 		printf("Failed to map PCI region for bdf %x\n", bdf);
 		return -1;
 	}
@@ -339,7 +336,7 @@ int octeontx_smi_probe(struct udevice *dev)
 		priv = malloc(sizeof(*priv));
 		if (!bus || !priv) {
 			printf("Failed to allocate OcteonTX MDIO bus # %u\n",
-				dev->seq);
+			       dev->seq);
 			return -1;
 		}
 
@@ -350,16 +347,16 @@ int octeontx_smi_probe(struct udevice *dev)
 
 		priv->mode = CLAUSE22;
 		priv->baseaddr = (void __iomem *)fdtdec_get_addr(gd->fdt_blob,
-							 subnode, "reg");
+								 subnode,
+								 "reg");
 		debug("mdio base addr %p\n", priv->baseaddr);
 
 		/* use given name or generate its own unique name */
 		snprintf(bus->name, MDIO_NAME_LEN, "smi%d", cnt++);
 
 		ret = mdio_register(bus);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 	}
 	return 0;
 }
diff --git a/drivers/net/octeontx/octeontx_xcv.c b/drivers/net/octeontx/octeontx_xcv.c
index ca2951a738..4dce07d12a 100644
--- a/drivers/net/octeontx/octeontx_xcv.c
+++ b/drivers/net/octeontx/octeontx_xcv.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <config.h>
 #include <common.h>
 #include <errno.h>
@@ -24,7 +23,6 @@
 #endif
 
 #include <asm/arch/octeontx_xcv.h>
-#include <asm/arch/octeontx_smi.h>
 #include <asm/arch/octeontx_vnic.h>
 
 struct lxcv {
@@ -37,64 +35,61 @@ struct lxcv *xcv;
 /* Initialize XCV block */
 void xcv_init_hw(void)
 {
-	//union cavm_xcvx_ctl xcv_ctl;
-	union cavm_xcvx_reset reset;
-	union cavm_xcvx_dll_ctl xcv_dll_ctl;
-	//union cavm_xcvx_comp_ctl xcv_comp_ctl;
+	union xcvx_reset reset;
+	union xcvx_dll_ctl xcv_dll_ctl;
 
 	/* Take the DLL out of reset */
-	reset.u = readq(CAVM_XCVX_RESET);
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	reset.s.dllrst = 0;
-	writeq(reset.u, CAVM_XCVX_RESET);
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 
 	/* Take the clock tree out of reset */
-	reset.u = readq(CAVM_XCVX_RESET);
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	reset.s.clkrst = 0;
-	writeq(reset.u, CAVM_XCVX_RESET);
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 
-	/* Once the 125MHz ref clock is stable, wait 10us for DLL to lock *.
- */
+	/* Once the 125MHz ref clock is stable, wait 10us for DLL to lock */
 	udelay(10);
 
 	/* Optionally, bypass the DLL setting */
-	xcv_dll_ctl.u = readq(CAVM_XCVX_DLL_CTL);
+	xcv_dll_ctl.u = readq(XCVX_BASE + XCVX_DLL_CTL(0));
 	xcv_dll_ctl.s.clkrx_set = 0;
 	xcv_dll_ctl.s.clkrx_byp = 1;
 	xcv_dll_ctl.s.clktx_byp = 0;
-	writeq(xcv_dll_ctl.u, CAVM_XCVX_DLL_CTL);
+	writeq(xcv_dll_ctl.u, XCVX_BASE + XCVX_DLL_CTL(0));
 
 	/* Enable the compensation controller */
-	reset.u = readq(CAVM_XCVX_RESET);
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	reset.s.comp = 1;
-	writeq(reset.u, CAVM_XCVX_RESET);
-	reset.u = readq(CAVM_XCVX_RESET);
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 
-	/* Wait for 1040 reference clock cycles for the compensation state 
-	   machine lock. */
-	udelay(100); 
+	/* Wait for 1040 reference clock cycles for the compensation state
+	 * machine lock.
+	 */
+	udelay(100);
 
 	/* Enable the XCV block */
-	reset.u = readq(CAVM_XCVX_RESET);
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	reset.s.enable = 1;
-	writeq(reset.u, CAVM_XCVX_RESET);
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 
 	/* set XCV(0)_RESET[CLKRST] to 1 */
-	reset.u = readq(CAVM_XCVX_RESET);
+	reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	reset.s.clkrst = 1;
-	writeq(reset.u, CAVM_XCVX_RESET);
+	writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 }
 
-/* 
+/*
  * Configure XCV link based on the speed
  * link_up   : Set to 1 when link is up otherwise 0
  * link_speed: The speed of the link.
- */ 
+ */
 void xcv_setup_link(bool link_up, int link_speed)
 {
-	union cavm_xcvx_ctl xcv_ctl;
-	union cavm_xcvx_reset reset;
-	//union cavm_xcvx_comp_ctl xcv_comp_ctl;
-	union cavm_xcvx_batch_crd_ret xcv_crd_ret;
+	union xcvx_ctl xcv_ctl;
+	union xcvx_reset reset;
+	union xcvx_batch_crd_ret xcv_crd_ret;
 	int speed = 2;
 
 	/* Check RGMII link */
@@ -105,36 +100,37 @@ void xcv_setup_link(bool link_up, int link_speed)
 
 	if (link_up) {
 		/* Set operating speed */
-		xcv_ctl.u = readq(CAVM_XCVX_CTL);
+		xcv_ctl.u = readq(XCVX_BASE + XCVX_CTL(0));
 		xcv_ctl.s.speed = speed;
-		writeq(xcv_ctl.u, CAVM_XCVX_CTL);
+		writeq(xcv_ctl.u, XCVX_BASE + XCVX_CTL(0));
 
 		/* Datapaths come out of reset
-		   - The datapath resets will disengage BGX from the
-		     RGMII interface
-		   - XCV will continue to return TX credits for each tick
-		     that is sent on the TX data path */
-		reset.u = readq(CAVM_XCVX_RESET);
+		 * - The datapath resets will disengage BGX from the
+		 *   RGMII interface
+		 * - XCV will continue to return TX credits for each tick
+		 *   that is sent on the TX data path
+		 */
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 		reset.s.tx_dat_rst_n = 1;
 		reset.s.rx_dat_rst_n = 1;
-		writeq(reset.u, CAVM_XCVX_RESET);
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 
 		/* Enable packet flow */
-		reset.u = readq(CAVM_XCVX_RESET);
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 		reset.s.tx_pkt_rst_n = 1;
 		reset.s.rx_pkt_rst_n = 1;
-		writeq(reset.u, CAVM_XCVX_RESET);
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
 
-		xcv_crd_ret.u = readq(CAVM_XCVX_BATCH_CRD_RET);
+		xcv_crd_ret.u = readq(XCVX_BASE + XCVX_BATCH_CRD_RET(0));
 		xcv_crd_ret.s.crd_ret = 1;
-		writeq(xcv_crd_ret.u, CAVM_XCVX_BATCH_CRD_RET);
+		writeq(xcv_crd_ret.u, XCVX_BASE + XCVX_BATCH_CRD_RET(0));
 	} else {
 		/* Enable packet flow */
-		reset.u = readq(CAVM_XCVX_RESET);
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 		reset.s.tx_pkt_rst_n = 0;
 		reset.s.rx_pkt_rst_n = 0;
-		writeq(reset.u, CAVM_XCVX_RESET);
-		reset.u = readq(CAVM_XCVX_RESET);
+		writeq(reset.u, XCVX_BASE + XCVX_RESET(0));
+		reset.u = readq(XCVX_BASE + XCVX_RESET(0));
 	}
 }
 
@@ -143,9 +139,8 @@ int octeontx_xcv_probe(struct udevice *dev)
 	size_t size;
 
 	xcv = dev_get_priv(dev);
-	if (xcv == NULL) {
+	if (!xcv)
 		return -ENOMEM;
-	}
 
 	xcv->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
 
@@ -161,11 +156,10 @@ static const struct udevice_id octeontx_xcv_ids[] = {
 };
 
 U_BOOT_DRIVER(octeontx_xcv) = {
-        .name   = "octeontx_xcv",
-        .id     = UCLASS_MISC,
-        .probe  = octeontx_xcv_probe,
-        .of_match = octeontx_xcv_ids,
-        .ops    = &octeontx_xcv_ops,
-        .priv_auto_alloc_size = sizeof(struct lxcv),
+	.name   = "octeontx_xcv",
+	.id     = UCLASS_MISC,
+	.probe  = octeontx_xcv_probe,
+	.of_match = octeontx_xcv_ids,
+	.ops    = &octeontx_xcv_ops,
+	.priv_auto_alloc_size = sizeof(struct lxcv),
 };
-
diff --git a/drivers/net/octeontx/q_struct.h b/drivers/net/octeontx/q_struct.h
index 723d73030b..b08b271818 100644
--- a/drivers/net/octeontx/q_struct.h
+++ b/drivers/net/octeontx/q_struct.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef Q_STRUCT_H
 #define Q_STRUCT_H
 
@@ -170,185 +169,185 @@ enum cqe_rx_err_opcode {
 
 struct cqe_rx_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   cqe_type:4; /* W0 */
-	uint64_t   stdn_fault:1;
-	uint64_t   rsvd0:1;
-	uint64_t   rq_qs:7;
-	uint64_t   rq_idx:3;
-	uint64_t   rsvd1:12;
-	uint64_t   rss_alg:4;
-	uint64_t   rsvd2:4;
-	uint64_t   rb_cnt:4;
-	uint64_t   vlan_found:1;
-	uint64_t   vlan_stripped:1;
-	uint64_t   vlan2_found:1;
-	uint64_t   vlan2_stripped:1;
-	uint64_t   l4_type:4;
-	uint64_t   l3_type:4;
-	uint64_t   l2_present:1;
-	uint64_t   err_level:3;
-	uint64_t   err_opcode:8;
-
-	uint64_t   pkt_len:16; /* W1 */
-	uint64_t   l2_ptr:8;
-	uint64_t   l3_ptr:8;
-	uint64_t   l4_ptr:8;
-	uint64_t   cq_pkt_len:8;
-	uint64_t   align_pad:3;
-	uint64_t   rsvd3:1;
-	uint64_t   chan:12;
-
-	uint64_t   rss_tag:32; /* W2 */
-	uint64_t   vlan_tci:16;
-	uint64_t   vlan_ptr:8;
-	uint64_t   vlan2_ptr:8;
-
-	uint64_t   rb3_sz:16; /* W3 */
-	uint64_t   rb2_sz:16;
-	uint64_t   rb1_sz:16;
-	uint64_t   rb0_sz:16;
-
-	uint64_t   rb7_sz:16; /* W4 */
-	uint64_t   rb6_sz:16;
-	uint64_t   rb5_sz:16;
-	uint64_t   rb4_sz:16;
-
-	uint64_t   rb11_sz:16; /* W5 */
-	uint64_t   rb10_sz:16;
-	uint64_t   rb9_sz:16;
-	uint64_t   rb8_sz:16;
+	u64   cqe_type:4; /* W0 */
+	u64   stdn_fault:1;
+	u64   rsvd0:1;
+	u64   rq_qs:7;
+	u64   rq_idx:3;
+	u64   rsvd1:12;
+	u64   rss_alg:4;
+	u64   rsvd2:4;
+	u64   rb_cnt:4;
+	u64   vlan_found:1;
+	u64   vlan_stripped:1;
+	u64   vlan2_found:1;
+	u64   vlan2_stripped:1;
+	u64   l4_type:4;
+	u64   l3_type:4;
+	u64   l2_present:1;
+	u64   err_level:3;
+	u64   err_opcode:8;
+
+	u64   pkt_len:16; /* W1 */
+	u64   l2_ptr:8;
+	u64   l3_ptr:8;
+	u64   l4_ptr:8;
+	u64   cq_pkt_len:8;
+	u64   align_pad:3;
+	u64   rsvd3:1;
+	u64   chan:12;
+
+	u64   rss_tag:32; /* W2 */
+	u64   vlan_tci:16;
+	u64   vlan_ptr:8;
+	u64   vlan2_ptr:8;
+
+	u64   rb3_sz:16; /* W3 */
+	u64   rb2_sz:16;
+	u64   rb1_sz:16;
+	u64   rb0_sz:16;
+
+	u64   rb7_sz:16; /* W4 */
+	u64   rb6_sz:16;
+	u64   rb5_sz:16;
+	u64   rb4_sz:16;
+
+	u64   rb11_sz:16; /* W5 */
+	u64   rb10_sz:16;
+	u64   rb9_sz:16;
+	u64   rb8_sz:16;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   err_opcode:8;
-	uint64_t   err_level:3;
-	uint64_t   l2_present:1;
-	uint64_t   l3_type:4;
-	uint64_t   l4_type:4;
-	uint64_t   vlan2_stripped:1;
-	uint64_t   vlan2_found:1;
-	uint64_t   vlan_stripped:1;
-	uint64_t   vlan_found:1;
-	uint64_t   rb_cnt:4;
-	uint64_t   rsvd2:4;
-	uint64_t   rss_alg:4;
-	uint64_t   rsvd1:12;
-	uint64_t   rq_idx:3;
-	uint64_t   rq_qs:7;
-	uint64_t   rsvd0:1;
-	uint64_t   stdn_fault:1;
-	uint64_t   cqe_type:4; /* W0 */
-	uint64_t   chan:12;
-	uint64_t   rsvd3:1;
-	uint64_t   align_pad:3;
-	uint64_t   cq_pkt_len:8;
-	uint64_t   l4_ptr:8;
-	uint64_t   l3_ptr:8;
-	uint64_t   l2_ptr:8;
-	uint64_t   pkt_len:16; /* W1 */
-	uint64_t   vlan2_ptr:8;
-	uint64_t   vlan_ptr:8;
-	uint64_t   vlan_tci:16;
-	uint64_t   rss_tag:32; /* W2 */
-	uint64_t   rb0_sz:16;
-	uint64_t   rb1_sz:16;
-	uint64_t   rb2_sz:16;
-	uint64_t   rb3_sz:16; /* W3 */
-	uint64_t   rb4_sz:16;
-	uint64_t   rb5_sz:16;
-	uint64_t   rb6_sz:16;
-	uint64_t   rb7_sz:16; /* W4 */
-	uint64_t   rb8_sz:16;
-	uint64_t   rb9_sz:16;
-	uint64_t   rb10_sz:16;
-	uint64_t   rb11_sz:16; /* W5 */
+	u64   err_opcode:8;
+	u64   err_level:3;
+	u64   l2_present:1;
+	u64   l3_type:4;
+	u64   l4_type:4;
+	u64   vlan2_stripped:1;
+	u64   vlan2_found:1;
+	u64   vlan_stripped:1;
+	u64   vlan_found:1;
+	u64   rb_cnt:4;
+	u64   rsvd2:4;
+	u64   rss_alg:4;
+	u64   rsvd1:12;
+	u64   rq_idx:3;
+	u64   rq_qs:7;
+	u64   rsvd0:1;
+	u64   stdn_fault:1;
+	u64   cqe_type:4; /* W0 */
+	u64   chan:12;
+	u64   rsvd3:1;
+	u64   align_pad:3;
+	u64   cq_pkt_len:8;
+	u64   l4_ptr:8;
+	u64   l3_ptr:8;
+	u64   l2_ptr:8;
+	u64   pkt_len:16; /* W1 */
+	u64   vlan2_ptr:8;
+	u64   vlan_ptr:8;
+	u64   vlan_tci:16;
+	u64   rss_tag:32; /* W2 */
+	u64   rb0_sz:16;
+	u64   rb1_sz:16;
+	u64   rb2_sz:16;
+	u64   rb3_sz:16; /* W3 */
+	u64   rb4_sz:16;
+	u64   rb5_sz:16;
+	u64   rb6_sz:16;
+	u64   rb7_sz:16; /* W4 */
+	u64   rb8_sz:16;
+	u64   rb9_sz:16;
+	u64   rb10_sz:16;
+	u64   rb11_sz:16; /* W5 */
 #endif
-	uint64_t   rb0_ptr:64;
-	uint64_t   rb1_ptr:64;
-	uint64_t   rb2_ptr:64;
-	uint64_t   rb3_ptr:64;
-	uint64_t   rb4_ptr:64;
-	uint64_t   rb5_ptr:64;
-	uint64_t   rb6_ptr:64;
-	uint64_t   rb7_ptr:64;
-	uint64_t   rb8_ptr:64;
-	uint64_t   rb9_ptr:64;
-	uint64_t   rb10_ptr:64;
-	uint64_t   rb11_ptr:64;
+	u64   rb0_ptr:64;
+	u64   rb1_ptr:64;
+	u64   rb2_ptr:64;
+	u64   rb3_ptr:64;
+	u64   rb4_ptr:64;
+	u64   rb5_ptr:64;
+	u64   rb6_ptr:64;
+	u64   rb7_ptr:64;
+	u64   rb8_ptr:64;
+	u64   rb9_ptr:64;
+	u64   rb10_ptr:64;
+	u64   rb11_ptr:64;
 };
 
 struct cqe_rx_tcp_err_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   cqe_type:4; /* W0 */
-	uint64_t   rsvd0:60;
-
-	uint64_t   rsvd1:4; /* W1 */
-	uint64_t   partial_first:1;
-	uint64_t   rsvd2:27;
-	uint64_t   rbdr_bytes:8;
-	uint64_t   rsvd3:24;
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:60;
+
+	u64   rsvd1:4; /* W1 */
+	u64   partial_first:1;
+	u64   rsvd2:27;
+	u64   rbdr_bytes:8;
+	u64   rsvd3:24;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   rsvd0:60;
-	uint64_t   cqe_type:4;
-
-	uint64_t   rsvd3:24;
-	uint64_t   rbdr_bytes:8;
-	uint64_t   rsvd2:27;
-	uint64_t   partial_first:1;
-	uint64_t   rsvd1:4;
+	u64   rsvd0:60;
+	u64   cqe_type:4;
+
+	u64   rsvd3:24;
+	u64   rbdr_bytes:8;
+	u64   rsvd2:27;
+	u64   partial_first:1;
+	u64   rsvd1:4;
 #endif
 };
 
 struct cqe_rx_tcp_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   cqe_type:4; /* W0 */
-	uint64_t   rsvd0:52;
-	uint64_t   cq_tcp_status:8;
-
-	uint64_t   rsvd1:32; /* W1 */
-	uint64_t   tcp_cntx_bytes:8;
-	uint64_t   rsvd2:8;
-	uint64_t   tcp_err_bytes:16;
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:52;
+	u64   cq_tcp_status:8;
+
+	u64   rsvd1:32; /* W1 */
+	u64   tcp_cntx_bytes:8;
+	u64   rsvd2:8;
+	u64   tcp_err_bytes:16;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   cq_tcp_status:8;
-	uint64_t   rsvd0:52;
-	uint64_t   cqe_type:4; /* W0 */
-
-	uint64_t   tcp_err_bytes:16;
-	uint64_t   rsvd2:8;
-	uint64_t   tcp_cntx_bytes:8;
-	uint64_t   rsvd1:32; /* W1 */
+	u64   cq_tcp_status:8;
+	u64   rsvd0:52;
+	u64   cqe_type:4; /* W0 */
+
+	u64   tcp_err_bytes:16;
+	u64   rsvd2:8;
+	u64   tcp_cntx_bytes:8;
+	u64   rsvd1:32; /* W1 */
 #endif
 };
 
 struct cqe_send_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   cqe_type:4; /* W0 */
-	uint64_t   rsvd0:4;
-	uint64_t   sqe_ptr:16;
-	uint64_t   rsvd1:4;
-	uint64_t   rsvd2:10;
-	uint64_t   sq_qs:7;
-	uint64_t   sq_idx:3;
-	uint64_t   rsvd3:8;
-	uint64_t   send_status:8;
-
-	uint64_t   ptp_timestamp:64; /* W1 */
+	u64   cqe_type:4; /* W0 */
+	u64   rsvd0:4;
+	u64   sqe_ptr:16;
+	u64   rsvd1:4;
+	u64   rsvd2:10;
+	u64   sq_qs:7;
+	u64   sq_idx:3;
+	u64   rsvd3:8;
+	u64   send_status:8;
+
+	u64   ptp_timestamp:64; /* W1 */
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   send_status:8;
-	uint64_t   rsvd3:8;
-	uint64_t   sq_idx:3;
-	uint64_t   sq_qs:7;
-	uint64_t   rsvd2:10;
-	uint64_t   rsvd1:4;
-	uint64_t   sqe_ptr:16;
-	uint64_t   rsvd0:4;
-	uint64_t   cqe_type:4; /* W0 */
-
-	uint64_t   ptp_timestamp:64; /* W1 */
+	u64   send_status:8;
+	u64   rsvd3:8;
+	u64   sq_idx:3;
+	u64   sq_qs:7;
+	u64   rsvd2:10;
+	u64   rsvd1:4;
+	u64   sqe_ptr:16;
+	u64   rsvd0:4;
+	u64   cqe_type:4; /* W0 */
+
+	u64   ptp_timestamp:64; /* W1 */
 #endif
 };
 
 union cq_desc_t {
-	uint64_t u[64];
+	u64 u[64];
 	struct cqe_send_t snd_hdr;
 	struct cqe_rx_t rx_hdr;
 	struct cqe_rx_tcp_t rx_tcp_hdr;
@@ -357,54 +356,54 @@ union cq_desc_t {
 
 struct rbdr_entry_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   rsvd0:15;
-	uint64_t   buf_addr:42;
-	uint64_t   cache_align:7;
+	u64   rsvd0:15;
+	u64   buf_addr:42;
+	u64   cache_align:7;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   cache_align:7;
-	uint64_t   buf_addr:42;
-	uint64_t   rsvd0:15;
+	u64   cache_align:7;
+	u64   buf_addr:42;
+	u64   rsvd0:15;
 #endif
 };
 
 /* TCP reassembly context */
 struct rbe_tcp_cnxt_t {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t   tcp_pkt_cnt:12;
-	uint64_t   rsvd1:4;
-	uint64_t   align_hdr_bytes:4;
-	uint64_t   align_ptr_bytes:4;
-	uint64_t   ptr_bytes:16;
-	uint64_t   rsvd2:24;
-	uint64_t   cqe_type:4;
-	uint64_t   rsvd0:54;
-	uint64_t   tcp_end_reason:2;
-	uint64_t   tcp_status:4;
+	u64   tcp_pkt_cnt:12;
+	u64   rsvd1:4;
+	u64   align_hdr_bytes:4;
+	u64   align_ptr_bytes:4;
+	u64   ptr_bytes:16;
+	u64   rsvd2:24;
+	u64   cqe_type:4;
+	u64   rsvd0:54;
+	u64   tcp_end_reason:2;
+	u64   tcp_status:4;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t   tcp_status:4;
-	uint64_t   tcp_end_reason:2;
-	uint64_t   rsvd0:54;
-	uint64_t   cqe_type:4;
-	uint64_t   rsvd2:24;
-	uint64_t   ptr_bytes:16;
-	uint64_t   align_ptr_bytes:4;
-	uint64_t   align_hdr_bytes:4;
-	uint64_t   rsvd1:4;
-	uint64_t   tcp_pkt_cnt:12;
+	u64   tcp_status:4;
+	u64   tcp_end_reason:2;
+	u64   rsvd0:54;
+	u64   cqe_type:4;
+	u64   rsvd2:24;
+	u64   ptr_bytes:16;
+	u64   align_ptr_bytes:4;
+	u64   align_hdr_bytes:4;
+	u64   rsvd1:4;
+	u64   tcp_pkt_cnt:12;
 #endif
 };
 
 /* Always Big endian */
 struct rx_hdr_t {
-	uint64_t   opaque:32;
-	uint64_t   rss_flow:8;
-	uint64_t   skip_length:6;
-	uint64_t   disable_rss:1;
-	uint64_t   disable_tcp_reassembly:1;
-	uint64_t   nodrop:1;
-	uint64_t   dest_alg:2;
-	uint64_t   rsvd0:2;
-	uint64_t   dest_rq:11;
+	u64   opaque:32;
+	u64   rss_flow:8;
+	u64   skip_length:6;
+	u64   disable_rss:1;
+	u64   disable_tcp_reassembly:1;
+	u64   nodrop:1;
+	u64   dest_alg:2;
+	u64   rsvd0:2;
+	u64   dest_rq:11;
 };
 
 enum send_l4_csum_type {
@@ -451,247 +450,247 @@ enum sq_subdesc_type {
 
 struct sq_crc_subdesc {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t    rsvd1:32;
-	uint64_t    crc_ival:32;
-	uint64_t    subdesc_type:4;
-	uint64_t    crc_alg:2;
-	uint64_t    rsvd0:10;
-	uint64_t    crc_insert_pos:16;
-	uint64_t    hdr_start:16;
-	uint64_t    crc_len:16;
+	u64    rsvd1:32;
+	u64    crc_ival:32;
+	u64    subdesc_type:4;
+	u64    crc_alg:2;
+	u64    rsvd0:10;
+	u64    crc_insert_pos:16;
+	u64    hdr_start:16;
+	u64    crc_len:16;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t    crc_len:16;
-	uint64_t    hdr_start:16;
-	uint64_t    crc_insert_pos:16;
-	uint64_t    rsvd0:10;
-	uint64_t    crc_alg:2;
-	uint64_t    subdesc_type:4;
-	uint64_t    crc_ival:32;
-	uint64_t    rsvd1:32;
+	u64    crc_len:16;
+	u64    hdr_start:16;
+	u64    crc_insert_pos:16;
+	u64    rsvd0:10;
+	u64    crc_alg:2;
+	u64    subdesc_type:4;
+	u64    crc_ival:32;
+	u64    rsvd1:32;
 #endif
 };
 
 struct sq_gather_subdesc {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t    subdesc_type:4; /* W0 */
-	uint64_t    ld_type:2;
-	uint64_t    rsvd0:42;
-	uint64_t    size:16;
+	u64    subdesc_type:4; /* W0 */
+	u64    ld_type:2;
+	u64    rsvd0:42;
+	u64    size:16;
 
-	uint64_t    rsvd1:15; /* W1 */
-	uint64_t    addr:49;
+	u64    rsvd1:15; /* W1 */
+	u64    addr:49;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t    size:16;
-	uint64_t    rsvd0:42;
-	uint64_t    ld_type:2;
-	uint64_t    subdesc_type:4; /* W0 */
+	u64    size:16;
+	u64    rsvd0:42;
+	u64    ld_type:2;
+	u64    subdesc_type:4; /* W0 */
 
-	uint64_t    addr:49;
-	uint64_t    rsvd1:15; /* W1 */
+	u64    addr:49;
+	u64    rsvd1:15; /* W1 */
 #endif
 };
 
 /* SQ immediate subdescriptor */
 struct sq_imm_subdesc {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t    subdesc_type:4; /* W0 */
-	uint64_t    rsvd0:46;
-	uint64_t    len:14;
+	u64    subdesc_type:4; /* W0 */
+	u64    rsvd0:46;
+	u64    len:14;
 
-	uint64_t    data:64; /* W1 */
+	u64    data:64; /* W1 */
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t    len:14;
-	uint64_t    rsvd0:46;
-	uint64_t    subdesc_type:4; /* W0 */
+	u64    len:14;
+	u64    rsvd0:46;
+	u64    subdesc_type:4; /* W0 */
 
-	uint64_t    data:64; /* W1 */
+	u64    data:64; /* W1 */
 #endif
 };
 
 struct sq_mem_subdesc {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t    subdesc_type:4; /* W0 */
-	uint64_t    mem_alg:4;
-	uint64_t    mem_dsz:2;
-	uint64_t    wmem:1;
-	uint64_t    rsvd0:21;
-	uint64_t    offset:32;
-
-	uint64_t    rsvd1:15; /* W1 */
-	uint64_t    addr:49;
+	u64    subdesc_type:4; /* W0 */
+	u64    mem_alg:4;
+	u64    mem_dsz:2;
+	u64    wmem:1;
+	u64    rsvd0:21;
+	u64    offset:32;
+
+	u64    rsvd1:15; /* W1 */
+	u64    addr:49;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t    offset:32;
-	uint64_t    rsvd0:21;
-	uint64_t    wmem:1;
-	uint64_t    mem_dsz:2;
-	uint64_t    mem_alg:4;
-	uint64_t    subdesc_type:4; /* W0 */
-
-	uint64_t    addr:49;
-	uint64_t    rsvd1:15; /* W1 */
+	u64    offset:32;
+	u64    rsvd0:21;
+	u64    wmem:1;
+	u64    mem_dsz:2;
+	u64    mem_alg:4;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    addr:49;
+	u64    rsvd1:15; /* W1 */
 #endif
 };
 
 struct sq_hdr_subdesc {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t    subdesc_type:4;
-	uint64_t    tso:1;
-	uint64_t    post_cqe:1; /* Post CQE on no error also */
-	uint64_t    dont_send:1;
-	uint64_t    tstmp:1;
-	uint64_t    subdesc_cnt:8;
-	uint64_t    csum_l4:2;
-	uint64_t    csum_l3:1;
-	uint64_t    rsvd0:5;
-	uint64_t    l4_offset:8;
-	uint64_t    l3_offset:8;
-	uint64_t    rsvd1:4;
-	uint64_t    tot_len:20; /* W0 */
-
-	uint64_t    tso_sdc_cont:8;
-	uint64_t    tso_sdc_first:8;
-	uint64_t    tso_l4_offset:8;
-	uint64_t    tso_flags_last:12;
-	uint64_t    tso_flags_first:12;
-	uint64_t    rsvd2:2;
-	uint64_t    tso_max_paysize:14; /* W1 */
+	u64    subdesc_type:4;
+	u64    tso:1;
+	u64    post_cqe:1; /* Post CQE on no error also */
+	u64    dont_send:1;
+	u64    tstmp:1;
+	u64    subdesc_cnt:8;
+	u64    csum_l4:2;
+	u64    csum_l3:1;
+	u64    rsvd0:5;
+	u64    l4_offset:8;
+	u64    l3_offset:8;
+	u64    rsvd1:4;
+	u64    tot_len:20; /* W0 */
+
+	u64    tso_sdc_cont:8;
+	u64    tso_sdc_first:8;
+	u64    tso_l4_offset:8;
+	u64    tso_flags_last:12;
+	u64    tso_flags_first:12;
+	u64    rsvd2:2;
+	u64    tso_max_paysize:14; /* W1 */
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t    tot_len:20;
-	uint64_t    rsvd1:4;
-	uint64_t    l3_offset:8;
-	uint64_t    l4_offset:8;
-	uint64_t    rsvd0:5;
-	uint64_t    csum_l3:1;
-	uint64_t    csum_l4:2;
-	uint64_t    subdesc_cnt:8;
-	uint64_t    tstmp:1;
-	uint64_t    dont_send:1;
-	uint64_t    post_cqe:1; /* Post CQE on no error also */
-	uint64_t    tso:1;
-	uint64_t    subdesc_type:4; /* W0 */
-
-	uint64_t    tso_max_paysize:14;
-	uint64_t    rsvd2:2;
-	uint64_t    tso_flags_first:12;
-	uint64_t    tso_flags_last:12;
-	uint64_t    tso_l4_offset:8;
-	uint64_t    tso_sdc_first:8;
-	uint64_t    tso_sdc_cont:8; /* W1 */
+	u64    tot_len:20;
+	u64    rsvd1:4;
+	u64    l3_offset:8;
+	u64    l4_offset:8;
+	u64    rsvd0:5;
+	u64    csum_l3:1;
+	u64    csum_l4:2;
+	u64    subdesc_cnt:8;
+	u64    tstmp:1;
+	u64    dont_send:1;
+	u64    post_cqe:1; /* Post CQE on no error also */
+	u64    tso:1;
+	u64    subdesc_type:4; /* W0 */
+
+	u64    tso_max_paysize:14;
+	u64    rsvd2:2;
+	u64    tso_flags_first:12;
+	u64    tso_flags_last:12;
+	u64    tso_l4_offset:8;
+	u64    tso_sdc_first:8;
+	u64    tso_sdc_cont:8; /* W1 */
 #endif
 };
 
 /* Queue config register formats */
 struct rq_cfg {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t reserved_2_63:62;
-	uint64_t ena:1;
-	uint64_t tcp_ena:1;
+	u64 reserved_2_63:62;
+	u64 ena:1;
+	u64 tcp_ena:1;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t tcp_ena:1;
-	uint64_t ena:1;
-	uint64_t reserved_2_63:62;
+	u64 tcp_ena:1;
+	u64 ena:1;
+	u64 reserved_2_63:62;
 #endif
 };
 
 struct cq_cfg {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t reserved_43_63:21;
-	uint64_t ena:1;
-	uint64_t reset:1;
-	uint64_t caching:1;
-	uint64_t reserved_35_39:5;
-	uint64_t qsize:3;
-	uint64_t reserved_25_31:7;
-	uint64_t avg_con:9;
-	uint64_t reserved_0_15:16;
+	u64 reserved_43_63:21;
+	u64 ena:1;
+	u64 reset:1;
+	u64 caching:1;
+	u64 reserved_35_39:5;
+	u64 qsize:3;
+	u64 reserved_25_31:7;
+	u64 avg_con:9;
+	u64 reserved_0_15:16;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t reserved_0_15:16;
-	uint64_t avg_con:9;
-	uint64_t reserved_25_31:7;
-	uint64_t qsize:3;
-	uint64_t reserved_35_39:5;
-	uint64_t caching:1;
-	uint64_t reset:1;
-	uint64_t ena:1;
-	uint64_t reserved_43_63:21;
+	u64 reserved_0_15:16;
+	u64 avg_con:9;
+	u64 reserved_25_31:7;
+	u64 qsize:3;
+	u64 reserved_35_39:5;
+	u64 caching:1;
+	u64 reset:1;
+	u64 ena:1;
+	u64 reserved_43_63:21;
 #endif
 };
 
 struct sq_cfg {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t reserved_20_63:44;
-	uint64_t ena:1;
-	uint64_t reserved_18_18:1;
-	uint64_t reset:1;
-	uint64_t ldwb:1;
-	uint64_t reserved_11_15:5;
-	uint64_t qsize:3;
-	uint64_t reserved_3_7:5;
-	uint64_t tstmp_bgx_intf:3;
+	u64 reserved_20_63:44;
+	u64 ena:1;
+	u64 reserved_18_18:1;
+	u64 reset:1;
+	u64 ldwb:1;
+	u64 reserved_11_15:5;
+	u64 qsize:3;
+	u64 reserved_3_7:5;
+	u64 tstmp_bgx_intf:3;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t tstmp_bgx_intf:3;
-	uint64_t reserved_3_7:5;
-	uint64_t qsize:3;
-	uint64_t reserved_11_15:5;
-	uint64_t ldwb:1;
-	uint64_t reset:1;
-	uint64_t reserved_18_18:1;
-	uint64_t ena:1;
-	uint64_t reserved_20_63:44;
+	u64 tstmp_bgx_intf:3;
+	u64 reserved_3_7:5;
+	u64 qsize:3;
+	u64 reserved_11_15:5;
+	u64 ldwb:1;
+	u64 reset:1;
+	u64 reserved_18_18:1;
+	u64 ena:1;
+	u64 reserved_20_63:44;
 #endif
 };
 
 struct rbdr_cfg {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t reserved_45_63:19;
-	uint64_t ena:1;
-	uint64_t reset:1;
-	uint64_t ldwb:1;
-	uint64_t reserved_36_41:6;
-	uint64_t qsize:4;
-	uint64_t reserved_25_31:7;
-	uint64_t avg_con:9;
-	uint64_t reserved_12_15:4;
-	uint64_t lines:12;
+	u64 reserved_45_63:19;
+	u64 ena:1;
+	u64 reset:1;
+	u64 ldwb:1;
+	u64 reserved_36_41:6;
+	u64 qsize:4;
+	u64 reserved_25_31:7;
+	u64 avg_con:9;
+	u64 reserved_12_15:4;
+	u64 lines:12;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t lines:12;
-	uint64_t reserved_12_15:4;
-	uint64_t avg_con:9;
-	uint64_t reserved_25_31:7;
-	uint64_t qsize:4;
-	uint64_t reserved_36_41:6;
-	uint64_t ldwb:1;
-	uint64_t reset:1;
-	uint64_t ena: 1;
-	uint64_t reserved_45_63:19;
+	u64 lines:12;
+	u64 reserved_12_15:4;
+	u64 avg_con:9;
+	u64 reserved_25_31:7;
+	u64 qsize:4;
+	u64 reserved_36_41:6;
+	u64 ldwb:1;
+	u64 reset:1;
+	u64 ena: 1;
+	u64 reserved_45_63:19;
 #endif
 };
 
 struct qs_cfg {
 #if defined(__BIG_ENDIAN_BITFIELD)
-	uint64_t reserved_32_63:32;
-	uint64_t ena:1;
-	uint64_t reserved_27_30:4;
-	uint64_t sq_ins_ena:1;
-	uint64_t sq_ins_pos:6;
-	uint64_t lock_ena:1;
-	uint64_t lock_viol_cqe_ena:1;
-	uint64_t send_tstmp_ena:1;
-	uint64_t be:1;
-	uint64_t reserved_7_15:9;
-	uint64_t vnic:7;
+	u64 reserved_32_63:32;
+	u64 ena:1;
+	u64 reserved_27_30:4;
+	u64 sq_ins_ena:1;
+	u64 sq_ins_pos:6;
+	u64 lock_ena:1;
+	u64 lock_viol_cqe_ena:1;
+	u64 send_tstmp_ena:1;
+	u64 be:1;
+	u64 reserved_7_15:9;
+	u64 vnic:7;
 #elif defined(__LITTLE_ENDIAN_BITFIELD)
-	uint64_t vnic:7;
-	uint64_t reserved_7_15:9;
-	uint64_t be:1;
-	uint64_t send_tstmp_ena:1;
-	uint64_t lock_viol_cqe_ena:1;
-	uint64_t lock_ena:1;
-	uint64_t sq_ins_pos:6;
-	uint64_t sq_ins_ena:1;
-	uint64_t reserved_27_30:4;
-	uint64_t ena:1;
-	uint64_t reserved_32_63:32;
+	u64 vnic:7;
+	u64 reserved_7_15:9;
+	u64 be:1;
+	u64 send_tstmp_ena:1;
+	u64 lock_viol_cqe_ena:1;
+	u64 lock_ena:1;
+	u64 sq_ins_pos:6;
+	u64 sq_ins_ena:1;
+	u64 reserved_27_30:4;
+	u64 ena:1;
+	u64 reserved_32_63:32;
 #endif
 };
 
diff --git a/drivers/net/octeontx2/cavm-csrs-lmt.h b/drivers/net/octeontx2/cavm-csrs-lmt.h
deleted file mode 100644
index 1a3ecae1b7..0000000000
--- a/drivers/net/octeontx2/cavm-csrs-lmt.h
+++ /dev/null
@@ -1,61 +0,0 @@
-#ifndef __CAVM_CSRS_LMT_H__
-#define __CAVM_CSRS_LMT_H__
-/* This file is auto-generated.  Do not edit */
-
-/***********************license start***********************************
-* Copyright (C) 2019 Marvell International Ltd.
-* SPDX-License-Identifier: BSD-3-Clause
-* https://spdx.org/licenses
-***********************license end**************************************/
-
-/**
- * @file
- *
- * Configuration and status register (CSR) address and type definitions for
- * Cavium LMT.
- *
- * This file is auto generated.  Do not edit.
- *
- */
-
-/**
- * Register (RVU_PFVF_BAR2) lmt_lf_lmtcancel
- *
- * RVU VF LMT Cancel Register
- */
-union cavm_lmt_lf_lmtcancel {
-	u64 u;
-	struct cavm_lmt_lf_lmtcancel_s {
-		u64 data                             : 64;
-	} s;
-	/* struct cavm_lmt_lf_lmtcancel_s cn; */
-};
-
-static inline u64 CAVM_LMT_LF_LMTCANCEL(void)
-	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_LMT_LF_LMTCANCEL(void)
-{
-	return 0x400;
-}
-
-/**
- * Register (RVU_PFVF_BAR2) lmt_lf_lmtline#
- *
- * RVU VF LMT Line Registers
- */
-union cavm_lmt_lf_lmtlinex {
-	u64 u;
-	struct cavm_lmt_lf_lmtlinex_s {
-		u64 data                             : 64;
-	} s;
-	/* struct cavm_lmt_lf_lmtlinex_s cn; */
-};
-
-static inline u64 CAVM_LMT_LF_LMTLINEX(u64 a)
-	__attribute__ ((pure, always_inline));
-static inline u64 CAVM_LMT_LF_LMTLINEX(u64 a)
-{
-	return 0 + 8 * a;
-}
-
-#endif /* __CAVM_CSRS_LMT_H__ */
diff --git a/drivers/net/octeontx2/cgx.c b/drivers/net/octeontx2/cgx.c
index 4059c41e64..fb278ad178 100644
--- a/drivers/net/octeontx2/cgx.c
+++ b/drivers/net/octeontx2/cgx.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -15,7 +14,7 @@
 #include <errno.h>
 #include <linux/list.h>
 #include <asm/arch/octeontx2.h>
-#include "cavm-csrs-cgx.h"
+#include <asm/arch/csrs/csrs-cgx.h>
 #include "cgx.h"
 
 char lmac_type_to_str[][8] = {
@@ -71,7 +70,7 @@ struct lmac *nix_get_cgx_lmac(int lmac_instance)
 
 		cgx = dev_get_priv(dev);
 		debug("%s udev %p cgx %p instance %d\n", __func__, dev, cgx,
-			lmac_instance);
+		      lmac_instance);
 		for (idx = 0; idx < cgx->lmac_count; idx++) {
 			if (cgx->lmac[idx]->instance == lmac_instance)
 				return cgx->lmac[idx];
@@ -82,13 +81,13 @@ struct lmac *nix_get_cgx_lmac(int lmac_instance)
 
 void cgx_lmac_mac_filter_clear(struct lmac *lmac)
 {
-	union cavm_cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
-	union cavm_cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
+	union cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
 	void *reg_addr;
 
 	dmac_cam0.u = 0x0;
 	reg_addr = lmac->cgx->reg_base +
-			CAVM_CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+			CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
 	writeq(dmac_cam0.u, reg_addr);
 	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
 
@@ -97,20 +96,15 @@ void cgx_lmac_mac_filter_clear(struct lmac *lmac)
 	dmac_ctl0.s.mcst_mode = 1;
 	dmac_ctl0.s.cam_accept = 0;
 	reg_addr = lmac->cgx->reg_base +
-			CAVM_CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+			CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
 	writeq(dmac_ctl0.u, reg_addr);
 	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
 }
 
 void cgx_lmac_mac_filter_setup(struct lmac *lmac)
 {
-	union cavm_cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
-	union cavm_cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
-#if 0
-	union cavm_cgxx_cmr_rx_steering0x steering0;
-	union cavm_cgxx_cmr_rx_steering_default0 steering_default0;
-	static int str_idx = 1;
-#endif
+	union cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
 	u64 mac, tmp;
 	void *reg_addr;
 
@@ -124,7 +118,7 @@ void cgx_lmac_mac_filter_setup(struct lmac *lmac)
 	dmac_cam0.s.adr = mac;
 	dmac_cam0.s.en = 1;
 	reg_addr = lmac->cgx->reg_base +
-			CAVM_CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+			CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
 	writeq(dmac_cam0.u, reg_addr);
 	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
 	dmac_ctl0.u = 0x0;
@@ -132,50 +126,18 @@ void cgx_lmac_mac_filter_setup(struct lmac *lmac)
 	dmac_ctl0.s.mcst_mode = 0;
 	dmac_ctl0.s.cam_accept = 1;
 	reg_addr = lmac->cgx->reg_base +
-			CAVM_CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+			CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
 	writeq(dmac_ctl0.u, reg_addr);
 	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
-
-#if 0
-	steering_default0.u = 0x0;
-	steering_default0.s.pass = 0;
-	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING_DEFAULT0();
-	writeq(steering_default0.u, reg_addr);
-	debug("%s: reg %p str_def0 %llx\n", __func__, reg_addr,
-			 steering_default0.u);
-
-	steering0.u = 0x0;
-	steering0.s.pass = 1;
-	steering0.s.mcst_en = 0;
-	steering0.s.dmac_en = 1;
-	steering0.s.dmac = mac;
-	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING0X(0);
-	writeq(steering0.u, reg_addr);
-	debug("%s: reg %p steering00 %llx\n", __func__, reg_addr,
-			 steering0.u);
-
-	mac = 0x0000FFFFFFFFFFFF;	/* broadcast addr */
-	steering0.u = 0x0;
-	steering0.s.pass = 1;
-	steering0.s.mcst_en = 0;
-	steering0.s.dmac_en = 1;
-	steering0.s.dmac = mac;
-	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING0X(1);
-	writeq(steering0.u, reg_addr);
-	debug("%s: reg %p steering01 %llx\n", __func__, reg_addr,
-			 steering0.u);
-#endif
 }
 
-
 int cgx_lmac_set_pkind(struct lmac *lmac, u8 lmac_id, int pkind)
 {
-	cgx_write(lmac->cgx, lmac_id, CAVM_CGXX_CMRX_RX_ID_MAP(0),
+	cgx_write(lmac->cgx, lmac_id, CGXX_CMRX_RX_ID_MAP(0),
 		  (pkind & 0x3f));
 	return 0;
 }
 
-
 int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status)
 {
 	int ret = 0;
@@ -192,15 +154,15 @@ int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status)
 int cgx_lmac_rx_tx_enable(struct lmac *lmac, int lmac_id, bool enable)
 {
 	struct cgx *cgx = lmac->cgx;
-	union cavm_cgxx_cmrx_config cmrx_config;
+	union cgxx_cmrx_config cmrx_config;
 
 	if (!cgx || lmac_id >= cgx->lmac_count)
 		return -ENODEV;
 
-	cmrx_config.u = cgx_read(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0));
+	cmrx_config.u = cgx_read(cgx, lmac_id, CGXX_CMRX_CONFIG(0));
 	cmrx_config.s.data_pkt_rx_en =
 	cmrx_config.s.data_pkt_tx_en = enable ? 1 : 0;
-	cgx_write(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0), cmrx_config.u);
+	cgx_write(cgx, lmac_id, CGXX_CMRX_CONFIG(0), cmrx_config.u);
 	return 0;
 }
 
@@ -222,27 +184,27 @@ int cgx_lmac_link_enable(struct lmac *lmac, int lmac_id, bool enable,
 int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable)
 {
 	struct cgx *cgx = lmac->cgx;
-	union cavm_cgxx_cmrx_config cmrx_cfg;
-	union cavm_cgxx_gmp_pcs_mrx_control mrx_control;
-	union cavm_cgxx_spux_control1 spux_control1;
+	union cgxx_cmrx_config cmrx_cfg;
+	union cgxx_gmp_pcs_mrx_control mrx_control;
+	union cgxx_spux_control1 spux_control1;
 	enum lmac_type lmac_type;
 
 	if (!cgx || lmac_id >= cgx->lmac_count)
 		return -ENODEV;
 
-	cmrx_cfg.u = cgx_read(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0));
+	cmrx_cfg.u = cgx_read(cgx, lmac_id, CGXX_CMRX_CONFIG(0));
 	lmac_type = cmrx_cfg.s.lmac_type;
 	if (lmac_type == LMAC_MODE_SGMII || lmac_type == LMAC_MODE_QSGMII) {
 		mrx_control.u = cgx_read(cgx, lmac_id,
-					 CAVM_CGXX_GMP_PCS_MRX_CONTROL(0));
+					 CGXX_GMP_PCS_MRX_CONTROL(0));
 		mrx_control.s.loopbck1 = enable ? 1 : 0;
-		cgx_write(cgx, lmac_id, CAVM_CGXX_GMP_PCS_MRX_CONTROL(0),
+		cgx_write(cgx, lmac_id, CGXX_GMP_PCS_MRX_CONTROL(0),
 			  mrx_control.u);
 	} else {
 		spux_control1.u = cgx_read(cgx, lmac_id,
-					   CAVM_CGXX_SPUX_CONTROL1(0));
+					   CGXX_SPUX_CONTROL1(0));
 		spux_control1.s.loopbck = enable ? 1 : 0;
-		cgx_write(cgx, lmac_id, CAVM_CGXX_SPUX_CONTROL1(0),
+		cgx_write(cgx, lmac_id, CGXX_SPUX_CONTROL1(0),
 			  spux_control1.u);
 	}
 	return 0;
@@ -251,11 +213,11 @@ int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable)
 static int cgx_lmac_init(struct cgx *cgx)
 {
 	struct lmac *lmac;
-	union cavm_cgxx_cmrx_config cmrx_cfg;
+	union cgxx_cmrx_config cmrx_cfg;
 	static int instance = 1;
 	int i;
 
-	cgx->lmac_count = cgx_read(cgx, 0, CAVM_CGXX_CMR_RX_LMACS());
+	cgx->lmac_count = cgx_read(cgx, 0, CGXX_CMR_RX_LMACS());
 	debug("%s: Found %d lmacs for cgx %d@%p\n", __func__, cgx->lmac_count,
 	      cgx->cgx_id, cgx->reg_base);
 
@@ -267,15 +229,15 @@ static int cgx_lmac_init(struct cgx *cgx)
 		snprintf(lmac->name, sizeof(lmac->name), "cgx_fwi_%d_%d",
 			 cgx->cgx_id, i);
 		/* Get LMAC type */
-		cmrx_cfg.u = cgx_read(cgx, i, CAVM_CGXX_CMRX_CONFIG(0));
+		cmrx_cfg.u = cgx_read(cgx, i, CGXX_CMRX_CONFIG(0));
 		lmac->lmac_type = cmrx_cfg.s.lmac_type;
 
 		lmac->lmac_id = i;
 		lmac->cgx = cgx;
 		cgx->lmac[i] = lmac;
-		debug("%s: mapping id %d to lmac %p (%s), lmac type: %d"
-			" lmac instance %d\n", __func__, i, lmac, lmac->name,
-			 lmac->lmac_type, lmac->instance);
+		debug("%s: map id %d to lmac %p (%s), type:%d instance %d\n",
+		      __func__, i, lmac, lmac->name, lmac->lmac_type,
+		      lmac->instance);
 		lmac->init_pend = 1;
 		printf("CGX%d LMAC%d [%s]\n", lmac->cgx->cgx_id,
 		       lmac->lmac_id, lmac_type_to_str[lmac->lmac_type]);
@@ -297,8 +259,8 @@ int cgx_probe(struct udevice *dev)
 	cgx->dev = dev;
 	cgx->cgx_id = ((u64)(cgx->reg_base) >> 24) & 0x7;
 
-	debug("%s CGX BAR %p, id: %d\n", __func__,
-		 cgx->reg_base, cgx->cgx_id);
+	debug("%s CGX BAR %p, id: %d\n", __func__, cgx->reg_base,
+	      cgx->cgx_id);
 	debug("%s CGX %p, udev: %p\n", __func__, cgx, dev);
 
 	err = cgx_lmac_init(cgx);
@@ -312,7 +274,7 @@ int cgx_remove(struct udevice *dev)
 	int i;
 
 	debug("%s: cgx remove reg_base %p cgx_id %d",
-		__func__, cgx->reg_base, cgx->cgx_id);
+	      __func__, cgx->reg_base, cgx->cgx_id);
 	for (i = 0; i < cgx->lmac_count; i++)
 		cgx_lmac_mac_filter_clear(cgx->lmac[i]);
 
@@ -320,16 +282,16 @@ int cgx_remove(struct udevice *dev)
 }
 
 U_BOOT_DRIVER(cgx) = {
-        .name   = "cgx",
-        .id     = UCLASS_MISC,
-        .probe  = cgx_probe,
-        .remove  = cgx_remove,
-        .priv_auto_alloc_size = sizeof(struct cgx),
+	.name	= "cgx",
+	.id	= UCLASS_MISC,
+	.probe	= cgx_probe,
+	.remove	= cgx_remove,
+	.priv_auto_alloc_size = sizeof(struct cgx),
 };
 
 static struct pci_device_id cgx_supported[] = {
-        { PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX2_CGX) },
-        {}
+	{PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX2_CGX) },
+	{}
 };
 
 U_BOOT_PCI_DEVICE(cgx, cgx_supported);
diff --git a/drivers/net/octeontx2/cgx.h b/drivers/net/octeontx2/cgx.h
index 869fe10e70..7f2b1f5889 100644
--- a/drivers/net/octeontx2/cgx.h
+++ b/drivers/net/octeontx2/cgx.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef __CGX_H__
 #define __CGX_H__
 
@@ -14,7 +13,7 @@
 #define PCI_DEVICE_ID_OCTEONTX2_CGX	0xA059
 
 #define MAX_LMAC_PER_CGX		4
-#define CGX_PER_NODE 			3
+#define CGX_PER_NODE			3
 
 enum lmac_type {
 	LMAC_MODE_SGMII		= 0,
diff --git a/drivers/net/octeontx2/cgx_intf.c b/drivers/net/octeontx2/cgx_intf.c
index 51e954a8c3..b31d5055b2 100644
--- a/drivers/net/octeontx2/cgx_intf.c
+++ b/drivers/net/octeontx2/cgx_intf.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -61,6 +60,7 @@ static void cgx_wr_scr1(u8 cgx, u8 lmac, u64 val)
 static inline void set_ownership(u8 cgx, u8 lmac, u8 val)
 {
 	union cgx_scratchx1 scr1;
+
 	scr1.u = cgx_rd_scr1(cgx, lmac);
 	scr1.s.own_status = val;
 	cgx_wr_scr1(cgx, lmac, scr1.u);
@@ -74,12 +74,11 @@ static int wait_for_ownership(u8 cgx, u8 lmac)
 	int timeout = 5000;
 
 	do {
-	
 		scr1.u = cgx_rd_scr1(cgx, lmac);
 		scr0.u = cgx_rd_scr0(cgx, lmac);
 		/* clear async events if any */
-		if ((scr0.s.evt_sts.evt_type == CGX_EVT_ASYNC) &&
-			scr0.s.evt_sts.ack) {
+		if (scr0.s.evt_sts.evt_type == CGX_EVT_ASYNC &&
+		    scr0.s.evt_sts.ack) {
 			/* clear interrupt */
 			cmrx_int = readq(CGX_CMR_INT +
 					 CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
@@ -136,10 +135,10 @@ int cgx_intf_req(u8 cgx, u8 lmac, union cgx_cmd_s cmd_args, u64 *rsp,
 		scr0.u = cgx_rd_scr0(cgx, lmac);
 		scr1.u = cgx_rd_scr1(cgx, lmac);
 		mdelay(10);
-	} while (timeout-- && ( !scr0.s.evt_sts.ack) &&
+	} while (timeout-- && (!scr0.s.evt_sts.ack) &&
 		 (scr1.s.own_status == CGX_OWN_FIRMWARE));
 	if (timeout < 0) {
-		debug("%s timeout waiting for ack\n",__func__);
+		debug("%s timeout waiting for ack\n", __func__);
 		err = -ETIMEDOUT;
 		goto error;
 	}
@@ -180,7 +179,6 @@ error:
 	return err;
 }
 
-
 int cgx_intf_get_mac_addr(u8 cgx, u8 lmac, u8 *mac)
 {
 	union cgx_scratchx0 scr0;
diff --git a/drivers/net/octeontx2/cgx_intf.h b/drivers/net/octeontx2/cgx_intf.h
index 46371b3986..f4f2676749 100644
--- a/drivers/net/octeontx2/cgx_intf.h
+++ b/drivers/net/octeontx2/cgx_intf.h
@@ -1,7 +1,7 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -16,8 +16,8 @@
 #define CGX_CMR_SCRATCH0	0x87e0e0001050
 #define CGX_CMR_SCRATCH1	0x87e0e0001058
 
-#define CGX_SHIFT(x)		(0x1000000 * (x & 0x3))
-#define CMR_SHIFT(x)		(0x40000 * (x & 0x3))
+#define CGX_SHIFT(x)		(0x1000000 * ((x) & 0x3))
+#define CMR_SHIFT(x)		(0x40000 * ((x) & 0x3))
 
 /* CGX error types. set for cmd response status as CGX_STAT_FAIL */
 enum cgx_error_type {
@@ -135,11 +135,11 @@ enum cgx_cmd_own {
  * For any updates/new bitfields, corresponding structures needs to be updated
  */
 struct cgx_evt_sts_s {			/* start from bit 0 */
-	uint64_t ack:1;
-	uint64_t evt_type:1;		/* cgx_evt_type */
-	uint64_t stat:1;		/* cgx_stat */
-	uint64_t id:6;			/* cgx_evt_id/cgx_cmd_id */
-	uint64_t reserved:55;
+	u64 ack:1;
+	u64 evt_type:1;		/* cgx_evt_type */
+	u64 stat:1;		/* cgx_stat */
+	u64 id:6;			/* cgx_evt_id/cgx_cmd_id */
+	u64 reserved:55;
 };
 
 /* all the below structures are in the same memory location of SCRATCHX(0)
@@ -152,31 +152,31 @@ struct cgx_evt_sts_s {			/* start from bit 0 */
  *	check struct cgx_lnk_sts_s comments
  */
 struct cgx_err_sts_s {			/* start from bit 9 */
-	uint64_t reserved1:9;
-	uint64_t type:10;		/* cgx_error_type */
-	uint64_t reserved2:35;
+	u64 reserved1:9;
+	u64 type:10;		/* cgx_error_type */
+	u64 reserved2:35;
 };
 
 /* Resp to cmd ID as CGX_CMD_GET_FW_VER with cmd status as CGX_STAT_SUCCESS */
 struct cgx_ver_s {			/* start from bit 9 */
-	uint64_t reserved1:9;
-	uint64_t major_ver:4;
-	uint64_t minor_ver:4;
-	uint64_t reserved2:47;
+	u64 reserved1:9;
+	u64 major_ver:4;
+	u64 minor_ver:4;
+	u64 reserved2:47;
 };
 
 /* Resp to cmd ID as CGX_CMD_GET_MAC_ADDR with cmd status as CGX_STAT_SUCCESS
  * Returns each byte of MAC address in a separate bit field
  */
 struct cgx_mac_addr_s {			/* start from bit 9 */
-	uint64_t reserved1:9;
-	uint64_t addr_0:8;
-	uint64_t addr_1:8;
-	uint64_t addr_2:8;
-	uint64_t addr_3:8;
-	uint64_t addr_4:8;
-	uint64_t addr_5:8;
-	uint64_t reserved2:7;
+	u64 reserved1:9;
+	u64 addr_0:8;
+	u64 addr_1:8;
+	u64 addr_2:8;
+	u64 addr_3:8;
+	u64 addr_4:8;
+	u64 addr_5:8;
+	u64 reserved2:7;
 };
 
 /* Resp to cmd ID - CGX_CMD_LINK_BRING_UP/DOWN, event ID CGX_EVT_LINK_CHANGE
@@ -188,25 +188,25 @@ struct cgx_mac_addr_s {			/* start from bit 9 */
  * link status will be updated
  */
 struct cgx_lnk_sts_s {
-	uint64_t reserved1:9;
-	uint64_t link_up:1;
-	uint64_t full_duplex:1;
-	uint64_t speed:4;	/* cgx_link_speed */
-	uint64_t err_type:10;
-	uint64_t an:1;		/* Current AN state : enabled/disabled */
-	uint64_t fec:2;		/* Current FEC type if enabled, if not 0 */
-	uint64_t port:8;	/* Share the current port info if required */
-	uint64_t reserved2:28;
+	u64 reserved1:9;
+	u64 link_up:1;
+	u64 full_duplex:1;
+	u64 speed:4;	/* cgx_link_speed */
+	u64 err_type:10;
+	u64 an:1;		/* Current AN state : enabled/disabled */
+	u64 fec:2;		/* Current FEC type if enabled, if not 0 */
+	u64 port:8;	/* Share the current port info if required */
+	u64 reserved2:28;
 };
 
 struct sh_fwd_base_s {
-	uint64_t reserved1:9;
-	uint64_t addr:55;
+	u64 reserved1:9;
+	u64 addr:55;
 };
 
 struct cgx_link_modes_s {
-	uint64_t reserved1:9;
-	uint64_t modes:55;
+	u64 reserved1:9;
+	u64 modes:55;
 };
 
 /* Resp to cmd ID - CGX_CMD_GET_ADV_FEC/CGX_CMD_GET_SUPPORTED_FEC
@@ -218,23 +218,23 @@ struct cgx_link_modes_s {
  * } fec_type_t;
  */
 struct cgx_fec_types_s {
-	uint64_t reserved1:9;
-	uint64_t fec:2;
-	uint64_t reserved2:53;
+	u64 reserved1:9;
+	u64 fec:2;
+	u64 reserved2:53;
 };
 
 /* Resp to cmd ID - CGX_CMD_GET_AN */
 struct cgx_get_an_s {
-	uint64_t reserved1:9;
-	uint64_t an:1;
-	uint64_t reserved2:54;
+	u64 reserved1:9;
+	u64 an:1;
+	u64 reserved2:54;
 };
 
 /* Resp to cmd ID - CGX_CMD_GET_PHY_MOD_TYPE */
 struct cgx_get_phy_mod_type_s {
-	uint64_t reserved1:9;
-	uint64_t mod:1;		/* 0=NRZ, 1=PAM4 */
-	uint64_t reserved2:54;
+	u64 reserved1:9;
+	u64 mod:1;		/* 0=NRZ, 1=PAM4 */
+	u64 reserved2:54;
 };
 
 union cgx_rsp_sts {
@@ -271,7 +271,7 @@ union cgx_rsp_sts {
 };
 
 union cgx_scratchx0 {
-	uint64_t u;
+	u64 u;
 	union cgx_rsp_sts s;
 };
 
@@ -279,9 +279,9 @@ union cgx_scratchx0 {
  * This CSR acts as a command register
  */
 struct cgx_cmd {			/* start from bit 2 */
-	uint64_t reserved1:2;
-	uint64_t id:6;			/* cgx_request_id */
-	uint64_t reserved2:56;
+	u64 reserved1:2;
+	u64 id:6;			/* cgx_request_id */
+	u64 reserved2:56;
 };
 
 /* all the below structures are in the same memory location of SCRATCHX(1)
@@ -293,67 +293,67 @@ struct cgx_cmd {			/* start from bit 2 */
  * Ex: Loopback, HiGig...
  */
 struct cgx_ctl_args {			/* start from bit 8 */
-	uint64_t reserved1:8;
-	uint64_t enable:1;
-	uint64_t reserved2:55;
+	u64 reserved1:8;
+	u64 enable:1;
+	u64 reserved2:55;
 };
 
 /* command argument to be passed for cmd ID - CGX_CMD_SET_MTU */
 struct cgx_mtu_args {
-	uint64_t reserved1:8;
-	uint64_t size:16;
-	uint64_t reserved2:40;
+	u64 reserved1:8;
+	u64 size:16;
+	u64 reserved2:40;
 };
 
 /* command argument to be passed for cmd ID - CGX_CMD_LINK_CHANGE */
 struct cgx_link_change_args {		/* start from bit 8 */
-	uint64_t reserved1:8;
-	uint64_t link_up:1;
-	uint64_t full_duplex:1;
-	uint64_t speed:4;		/* cgx_link_speed */
-	uint64_t reserved2:50;
+	u64 reserved1:8;
+	u64 link_up:1;
+	u64 full_duplex:1;
+	u64 speed:4;		/* cgx_link_speed */
+	u64 reserved2:50;
 };
 
 /* command argument to be passed for cmd ID - CGX_CMD_SET_LINK_MODE */
 struct cgx_set_mode_args {
-	uint64_t reserved1:8;
-	uint64_t mode:56;
+	u64 reserved1:8;
+	u64 mode:56;
 };
 
 /* command argument to be passed for cmd ID - CGX_CMD_SET_FEC */
 struct cgx_set_fec_args {
-	uint64_t reserved1:8;
-	uint64_t fec:2;
-	uint64_t reserved2:54;
+	u64 reserved1:8;
+	u64 fec:2;
+	u64 reserved2:54;
 };
 
 /* command argument to be passed for cmd ID - CGX_CMD_SET_PHY_MOD_TYPE */
 struct cgx_set_phy_mod_args {
-	uint64_t reserved1:8;
-	uint64_t mod:1;		/* 0=NRZ, 1=PAM4 */
-	uint64_t reserved2:55;
+	u64 reserved1:8;
+	u64 mod:1;		/* 0=NRZ, 1=PAM4 */
+	u64 reserved2:55;
 };
 
 struct cgx_prbs_args {
-	uint64_t reserved1:8; /* start from bit 8 */
-	uint64_t qlm:8;
-	uint64_t stop_on_error:1;
-	uint64_t mode:8;
-	uint64_t time:39;
+	u64 reserved1:8; /* start from bit 8 */
+	u64 qlm:8;
+	u64 stop_on_error:1;
+	u64 mode:8;
+	u64 time:39;
 };
 
 struct cgx_display_eye_args {
-	uint64_t reserved1:8; /* start from bit 8 */
-	uint64_t qlm:8;
-	uint64_t lane:47;
+	u64 reserved1:8; /* start from bit 8 */
+	u64 qlm:8;
+	u64 lane:47;
 };
 
 union cgx_cmd_s {
-	uint64_t own_status:2;			/* cgx_cmd_own */
+	u64 own_status:2;			/* cgx_cmd_own */
 	struct cgx_cmd cmd;
 	struct cgx_ctl_args cmd_args;
 	struct cgx_mtu_args mtu_size;
-	struct cgx_link_change_args lnk_args;	/* Input to CGX_CMD_LINK_CHANGE */
+	struct cgx_link_change_args lnk_args; /* Input CGX_CMD_LINK_CHANGE */
 	struct cgx_set_mode_args mode_args;
 	struct cgx_set_fec_args fec_args;
 	struct cgx_set_phy_mod_args phy_mod_args;
@@ -363,7 +363,7 @@ union cgx_cmd_s {
 };
 
 union cgx_scratchx1 {
-	uint64_t u;
+	u64 u;
 	union cgx_cmd_s s;
 };
 
diff --git a/drivers/net/octeontx2/lmt.h b/drivers/net/octeontx2/lmt.h
index 0108a05635..a2453204a6 100644
--- a/drivers/net/octeontx2/lmt.h
+++ b/drivers/net/octeontx2/lmt.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 /**
  * Atomically adds a signed value to a 64 bit (aligned) memory location,
  * and returns previous value.
@@ -33,13 +32,13 @@ static inline s64 cavm_atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
 
 static inline void cavm_lmt_cancel(const struct nix *nix)
 {
-	writeq(0, nix->lmt_base + CAVM_LMT_LF_LMTCANCEL());
+	writeq(0, nix->lmt_base + LMT_LF_LMTCANCEL());
 }
 
-static inline volatile u64 *cavm_lmt_store_ptr(struct nix *nix)
+static inline u64 *cavm_lmt_store_ptr(struct nix *nix)
 {
-	return (volatile u64 *)((u8 *)(nix->lmt_base) +
-				       CAVM_LMT_LF_LMTLINEX(0));
+	return (u64 *)((u8 *)(nix->lmt_base) +
+				       LMT_LF_LMTLINEX(0));
 }
 
 static inline s64 cavm_lmt_submit(u64 io_address)
diff --git a/drivers/net/octeontx2/nix.c b/drivers/net/octeontx2/nix.c
index cba68d943d..152f944af4 100644
--- a/drivers/net/octeontx2/nix.c
+++ b/drivers/net/octeontx2/nix.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -19,7 +18,7 @@
 #include <linux/types.h>
 #include <linux/log2.h>
 #include <asm/arch/octeontx2.h>
-#include "cavm-csrs-lmt.h"
+#include <asm/arch/csrs/csrs-lmt.h>
 #include "nix.h"
 #include "lmt.h"
 #include "cgx.h"
@@ -42,15 +41,14 @@ static void *nix_memalloc(int num_elements, size_t elem_size, const char *msg)
 	void *base = memalign(CONFIG_SYS_CACHELINE_SIZE, alloc_size);
 
 	if (!base)
-		printf("NIX: Memory alloc failed for %s (%d * %zu = %zu bytes)\n",
+		printf("NIX: Mem alloc failed for %s (%d * %zu = %zu bytes)\n",
 		       msg ? msg : __func__, num_elements, elem_size,
 		       alloc_size);
 	else
 		memset(base, 0, alloc_size);
 
 	debug("NIX: Memory alloc for %s (%d * %zu = %zu bytes) at %p\n",
-	       msg ? msg : __func__, num_elements, elem_size,
-	       alloc_size, base);
+	      msg ? msg : __func__, num_elements, elem_size, alloc_size, base);
 	return base;
 }
 
@@ -71,8 +69,8 @@ static int npa_setup_pool(struct npa *npa, u32 pool_id,
 			  size_t buffer_size, u32 queue_length, void *buffers[])
 {
 	struct {
-		union cavm_npa_lf_aura_op_free0 f0;
-		union cavm_npa_lf_aura_op_free1 f1;
+		union npa_lf_aura_op_free0 f0;
+		union npa_lf_aura_op_free1 f1;
 	} aura_descr;
 	int index;
 
@@ -80,12 +78,12 @@ static int npa_setup_pool(struct npa *npa, u32 pool_id,
 		buffers[index] = memalign(CONFIG_SYS_CACHELINE_SIZE,
 					  buffer_size);
 		if (!buffers[index]) {
-			printf("%s: Out of memory allocating buffer %d, size: %zu\n",
+			printf("%s: Out of memory %d, size: %zu\n",
 			       __func__, index, buffer_size);
 			return -ENOMEM;
 		}
 		debug("%s: allocating buffer %d, addr %p size: %zu\n",
-		       __func__, index, buffers[index], buffer_size);
+		      __func__, index, buffers[index], buffer_size);
 
 		/* Add the newly obtained pointer to the pool.  128 bit
 		 * writes only.
@@ -93,7 +91,7 @@ static int npa_setup_pool(struct npa *npa, u32 pool_id,
 		aura_descr.f0.s.addr = (u64)buffers[index];
 		aura_descr.f1.u = 0;
 		aura_descr.f1.s.aura = pool_id;
-		cavm_st128(npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+		cavm_st128(npa->npa_base + NPA_LF_AURA_OP_FREE0(),
 			   aura_descr.f0.u, aura_descr.f1.u);
 	}
 
@@ -104,11 +102,11 @@ int npa_lf_setup(struct nix *nix)
 {
 	struct rvu_pf *rvu = dev_get_priv(nix->dev);
 	struct nix_af *nix_af = nix->nix_af;
-	struct npa *npa; 
-	union cavm_npa_af_const npa_af_const;
-	union cavm_npa_aura_s *aura;
-	union cavm_npa_pool_s *pool;
-	union cavm_rvu_func_addr_s block_addr;
+	struct npa *npa;
+	union npa_af_const npa_af_const;
+	union npa_aura_s *aura;
+	union npa_pool_s *pool;
+	union rvu_func_addr_s block_addr;
 	int idx;
 	int stack_page_pointers;
 	int stack_page_bytes;
@@ -120,12 +118,12 @@ int npa_lf_setup(struct nix *nix)
 		return -ENOMEM;
 	}
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPA;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPA;
 	npa->npa_base = rvu->pf_base + block_addr.u;
 	npa->npa_af = nix_af->npa_af;
 	nix->npa = npa;
 
-	npa_af_const.u = npa_af_reg_read(npa->npa_af, CAVM_NPA_AF_CONST());
+	npa_af_const.u = npa_af_reg_read(npa->npa_af, NPA_AF_CONST());
 	stack_page_pointers = npa_af_const.s.stack_page_ptrs;
 	stack_page_bytes = npa_af_const.s.stack_page_bytes;
 
@@ -145,31 +143,33 @@ int npa_lf_setup(struct nix *nix)
 	npa->buf_size[NPA_POOL_TX] = MAX_MTU + CONFIG_SYS_CACHELINE_SIZE;
 	npa->buf_size[NPA_POOL_SQB] = nix_af->sqb_size;
 
-	npa->aura_ctx = nix_memalloc(NPA_POOL_COUNT, sizeof(union cavm_npa_aura_s),
-					"aura context");
+	npa->aura_ctx = nix_memalloc(NPA_POOL_COUNT,
+				     sizeof(union npa_aura_s),
+				     "aura context");
 	if (!npa->aura_ctx) {
 		printf("%s: Out of memory for aura context\n", __func__);
 		return -ENOMEM;
 	}
 
 	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
-		npa->pool_ctx[idx] = nix_memalloc(1, sizeof(union cavm_npa_pool_s),
-							"pool context");
+		npa->pool_ctx[idx] = nix_memalloc(1,
+						  sizeof(union npa_pool_s),
+						  "pool context");
 		if (!npa->pool_ctx[idx]) {
 			printf("%s: Out of memory for pool context\n",
 			       __func__);
 			return -ENOMEM;
 		}
 		npa->pool_stack[idx] = nix_memalloc(npa->stack_pages[idx],
-							 stack_page_bytes,
-							 "pool stack");
-		if (!npa->pool_stack[idx]){
+						    stack_page_bytes,
+						    "pool stack");
+		if (!npa->pool_stack[idx]) {
 			printf("%s: Out of memory for pool stack\n", __func__);
 			return -ENOMEM;
 		}
 	}
 
-	err = npa_lf_admin_setup(npa, nix->lf, (dma_addr_t) npa->aura_ctx);
+	err = npa_lf_admin_setup(npa, nix->lf, (dma_addr_t)npa->aura_ctx);
 	if (err) {
 		printf("%s: Error setting up NPA LF admin for lf %d\n",
 		       __func__, nix->lf);
@@ -178,14 +178,14 @@ int npa_lf_setup(struct nix *nix)
 
 	/* Set up the auras */
 	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
-		aura = npa->aura_ctx + (idx * sizeof(union cavm_npa_aura_s));
+		aura = npa->aura_ctx + (idx * sizeof(union npa_aura_s));
 		pool = npa->pool_ctx[idx];
-		debug("%s aura %p pool %p\n",__func__,aura,pool);
-		memset(aura, 0, sizeof(union cavm_npa_aura_s));
+		debug("%s aura %p pool %p\n", __func__, aura, pool);
+		memset(aura, 0, sizeof(union npa_aura_s));
 		aura->s.fc_ena = 0;
 		aura->s.pool_addr = (u64)npa->pool_ctx[idx];
-		debug("%s aura.s.pool_addr %llx pool_addr %p\n",__func__,
-			aura->s.pool_addr,npa->pool_ctx[idx]);
+		debug("%s aura.s.pool_addr %llx pool_addr %p\n", __func__,
+		      aura->s.pool_addr, npa->pool_ctx[idx]);
 		aura->s.shift = 64 - __builtin_clzll(npa->q_len[idx]) - 8;
 		aura->s.count = npa->q_len[idx];
 		aura->s.limit = npa->q_len[idx];
@@ -198,10 +198,10 @@ int npa_lf_setup(struct nix *nix)
 		pool->s.fc_ena = 0;
 		pool->s.nat_align = 1;
 		pool->s.stack_base = (u64)(npa->pool_stack[idx]);
-		debug("%s pool.s.stack_base %llx stack_base %p\n",__func__,
-			pool->s.stack_base,npa->pool_stack[idx]);
-		pool->s.buf_size = 
-			npa->buf_size[idx]/CONFIG_SYS_CACHELINE_SIZE;
+		debug("%s pool.s.stack_base %llx stack_base %p\n", __func__,
+		      pool->s.stack_base, npa->pool_stack[idx]);
+		pool->s.buf_size =
+			npa->buf_size[idx] / CONFIG_SYS_CACHELINE_SIZE;
 		pool->s.stack_max_pages = npa->stack_pages[idx];
 		pool->s.shift =
 			64 - __builtin_clzll(npa->pool_stack_pointers) - 8;
@@ -290,24 +290,24 @@ int nix_lf_setup(struct nix *nix)
 	memset(nix->cq_ctx_base, 0, nix_af->cq_ctx_sz * NIX_CQ_COUNT);
 	/* Alloc NIX CQ Ring memory */
 	for (idx = 0; idx < NIX_CQ_COUNT; idx++) {
-		err = qmem_alloc(&(nix->cq[idx]), CQ_ENTRIES, CQ_ENTRY_SIZE);
+		err = qmem_alloc(&nix->cq[idx], CQ_ENTRIES, CQ_ENTRY_SIZE);
 		if (err)
 			goto error;
 	}
 
 	/* Alloc memory for Qints HW contexts */
 	nix->qint_base = nix_memalloc(nix_af->qints, nix_af->qint_ctx_sz,
-					"Qint CTX");
+				      "Qint CTX");
 	if (!nix->qint_base)
 		goto error;
 	/* Alloc memory for CQints HW contexts */
 	nix->cint_base = nix_memalloc(nix_af->cints, nix_af->cint_ctx_sz,
-					"Cint CTX");
+				      "Cint CTX");
 	if (!nix->cint_base)
 		goto error;
 	/* Alloc NIX RSS HW context memory and config the base */
 	nix->rss_base = nix_memalloc(nix->rss_grps, nix_af->rsse_ctx_sz,
-					"RSS CTX");
+				     "RSS CTX");
 	if (!nix->rss_base)
 		goto error;
 
@@ -346,7 +346,7 @@ int nix_lf_shutdown(struct nix *nix)
 	int err;
 
 	err = nix_lf_admin_shutdown(nix_af, nix->lf, nix->cq_cnt,
-					nix->rq_cnt, nix->sq_cnt);
+				    nix->rq_cnt, nix->sq_cnt);
 	if (err) {
 		printf("%s: Error shutting down LF admin\n", __func__);
 		return err;
@@ -368,18 +368,17 @@ int nix_lf_shutdown(struct nix *nix)
 	for (index = 0; index < NIX_CQ_COUNT; index++)
 		qmem_free(&nix->cq[index]);
 
-	debug("%s: nix lf %d reset -- \n", __func__, nix->lf);
+	debug("%s: nix lf %d reset --\n", __func__, nix->lf);
 	return 0;
 }
 
-
 struct nix *nix_lf_alloc(struct udevice *dev)
 {
-	union cavm_rvu_func_addr_s block_addr;
+	union rvu_func_addr_s block_addr;
 	struct nix *nix;
 	struct rvu_pf *rvu = dev_get_priv(dev);
 	struct rvu_af *rvu_af = dev_get_priv(rvu->afdev);
-	union cavm_rvu_pf_func_s pf_func;
+	union rvu_pf_func_s pf_func;
 	int err;
 
 	debug("%s(%s )\n", __func__, dev->name);
@@ -392,13 +391,13 @@ struct nix *nix_lf_alloc(struct udevice *dev)
 	nix->nix_af = rvu_af->nix_af;
 
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NIXX(0);
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NIXX(0);
 	nix->nix_base = rvu->pf_base + block_addr.u;
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPC;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPC;
 	nix->npc_base = rvu->pf_base + block_addr.u;
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_LMT;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_LMT;
 	nix->lmt_base = rvu->pf_base + block_addr.u;
 
 	pf_func.u = 0;
@@ -407,9 +406,11 @@ struct nix *nix_lf_alloc(struct udevice *dev)
 	nix->lf = rvu->nix_lfid;
 	nix->pf = rvu->pfid;
 	nix->dev = dev;
-	nix->sq_cnt = nix->rq_cnt = nix->rss_grps = 1;
+	nix->sq_cnt = 1;
+	nix->rq_cnt = 1;
+	nix->rss_grps = 1;
 	nix->cq_cnt = 2;
-	nix->xqe_sz = NIX_CQE_SIZE_W16; 
+	nix->xqe_sz = NIX_CQE_SIZE_W16;
 
 	nix->lmac = nix_get_cgx_lmac(nix->pf);
 	if (!nix->lmac) {
@@ -419,25 +420,24 @@ struct nix *nix_lf_alloc(struct udevice *dev)
 		return NULL;
 	}
 	nix->lmac->link_num =
-		CAVM_NIX_LINK_E_CGXX_LMACX(nix->lmac->cgx->cgx_id,
-					   nix->lmac->lmac_id);
+		NIX_LINK_E_CGXX_LMACX(nix->lmac->cgx->cgx_id,
+				      nix->lmac->lmac_id);
 	nix->lmac->chan_num =
-		CAVM_NIX_CHAN_E_CGXX_LMACX_CHX(nix->lmac->cgx->cgx_id,
-						nix->lmac->lmac_id, 0);
+		NIX_CHAN_E_CGXX_LMACX_CHX(nix->lmac->cgx->cgx_id,
+					  nix->lmac->lmac_id, 0);
 	/* This is rx pkind in 1:1 mapping to NIX_LINK_E */
 	nix->lmac->pknd = nix->lmac->link_num;
 
 	cgx_lmac_set_pkind(nix->lmac, nix->lmac->lmac_id, nix->lmac->pknd);
 	debug("%s(%s CGX%x LMAC%x)\n", __func__, dev->name,
-			nix->lmac->cgx->cgx_id, nix->lmac->lmac_id);
+	      nix->lmac->cgx->cgx_id, nix->lmac->lmac_id);
 	debug("%s(%s Link %x Chan %x Pknd %x)\n", __func__, dev->name,
-			nix->lmac->link_num, nix->lmac->chan_num,
-			nix->lmac->pknd);
+	      nix->lmac->link_num, nix->lmac->chan_num,	nix->lmac->pknd);
 
 	err = npa_lf_setup(nix);
 	if (err)
 		return NULL;
-	
+
 	err = npc_lf_setup(nix);
 	if (err)
 		return NULL;
@@ -451,70 +451,51 @@ struct nix *nix_lf_alloc(struct udevice *dev)
 
 u64 npa_aura_op_alloc(struct npa *npa, u64 aura_id)
 {
-	union cavm_npa_lf_aura_op_allocx op_allocx;
+	union npa_lf_aura_op_allocx op_allocx;
 
 	op_allocx.u = cavm_atomic_fetch_and_add64_nosync(npa->npa_base +
-			CAVM_NPA_LF_AURA_OP_ALLOCX(0), aura_id);
+			NPA_LF_AURA_OP_ALLOCX(0), aura_id);
 	return op_allocx.s.addr;
 }
 
 u64 nix_cq_op_status(struct nix *nix, u64 cq_id)
 {
-	union cavm_nixx_lf_cq_op_status op_status;
+	union nixx_lf_cq_op_status op_status;
+	s64 *reg = nix->nix_base + NIXX_LF_CQ_OP_STATUS();
 
-	op_status.u = cavm_atomic_fetch_and_add64_nosync(
-			nix->nix_base + CAVM_NIXX_LF_CQ_OP_STATUS(),
-			(u64)cq_id << 32);
+	op_status.u = cavm_atomic_fetch_and_add64_nosync(reg, cq_id << 32);
 	return op_status.u;
 }
 
 /* TX */
-int nix_alloc_tx_dr(struct nix *nix)
-{
-	int i;
-
-	for (i = 0; i < (SQ_QLEN*2); i++) {
-		if (nix->tx_desc[i].in_use == 0) {
-	debug("%s i%d tx_desc %p  in_use %llx\n", __func__,
-		 i, &nix->tx_desc[i], nix->tx_desc[i].in_use);
-			return i;
-		}
-	}
-	return -1;
-}
-
-void nix_free_tx_dr(struct nix *nix, int sqe_id)
-{
-	debug("%s sqe_id %d\n", __func__, sqe_id);
-	nix->tx_desc[sqe_id].in_use = 0;
-}
-
 static inline void nix_write_lmt(struct nix *nix, void *buffer,
 				 int num_words)
 {
 	int i;
-	volatile u64 *lmt_ptr = cavm_lmt_store_ptr(nix);
+
+	u64 *lmt_ptr = cavm_lmt_store_ptr(nix);
 	u64 *ptr = buffer;
 
 	debug("%s lmt_ptr %p %p\n", __func__, nix->lmt_base, lmt_ptr);
 	for (i = 0; i < num_words; i++) {
 		debug("%s data %llx lmt_ptr %p\n", __func__, ptr[i],
-			 lmt_ptr+i);
+		      lmt_ptr + i);
 		lmt_ptr[i] = ptr[i];
 	}
 }
 
 void nix_cqe_tx_pkt_handler(struct nix *nix, void *cqe)
 {
-	union cavm_nix_cqe_hdr_s *txcqe = (union cavm_nix_cqe_hdr_s *)cqe;
+	union nix_cqe_hdr_s *txcqe = (union nix_cqe_hdr_s *)cqe;
+
 	debug("%s: txcqe: %p\n", __func__, txcqe);
 
-	if (txcqe->s.cqe_type != CAVM_NIX_XQE_TYPE_E_SEND) {
+	if (txcqe->s.cqe_type != NIX_XQE_TYPE_E_SEND) {
 		printf("%s: Error: Unsupported CQ header type %d\n",
 		       __func__, txcqe->s.cqe_type);
 		return;
 	}
-	nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+	nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
 			 (NIX_CQ_TX << 32) | 1);
 }
 
@@ -522,10 +503,10 @@ void nix_lf_flush_tx(struct udevice *dev)
 {
 	struct rvu_pf *rvu = dev_get_priv(dev);
 	struct nix *nix = rvu->nix;
-	union cavm_nixx_lf_cq_op_status op_status;
+	union nixx_lf_cq_op_status op_status;
 	u32 head, tail;
 	void *cq_tx_base = nix->cq[NIX_CQ_TX].base;
-	union cavm_nix_cqe_hdr_s *cqe;
+	union nix_cqe_hdr_s *cqe;
 
 	/* ack tx cqe entries */
 	op_status.u = nix_cq_op_status(nix, NIX_CQ_TX);
@@ -573,19 +554,19 @@ int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len)
 	tx_dr.hdr.s.sq = 0;
 	tx_dr.hdr.s.total = pkt_len;
 	tx_dr.hdr.s.sizem1 = dr_sz - 2; /* FIXME - for now hdr+sg+sg1addr */
-	debug("%s dr_sz %d \n", __func__, dr_sz);
+	debug("%s dr_sz %d\n", __func__, dr_sz);
 
 	tx_dr.tx_sg.s.segs = 1;
-	tx_dr.tx_sg.s.subdc = CAVM_NIX_SUBDC_E_SG;
+	tx_dr.tx_sg.s.subdc = NIX_SUBDC_E_SG;
 	tx_dr.tx_sg.s.seg1_size = pkt_len;
-	tx_dr.tx_sg.s.ld_type = CAVM_NIX_SENDLDTYPE_E_LDT;
+	tx_dr.tx_sg.s.ld_type = NIX_SENDLDTYPE_E_LDT;
 	tx_dr.sg1_addr = (dma_addr_t)packet;
 
 #define DEBUG_PKT
 #ifdef DEBUG_PKT
 	debug("TX PKT Data\n");
 	for (int i = 0; i < pkt_len; i++) {
-		if (i && (i%8 == 0))
+		if (i && (i % 8 == 0))
 			debug("\n");
 		debug("%02x ", *((u8 *)pkt + i));
 	}
@@ -595,7 +576,7 @@ int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len)
 		nix_write_lmt(nix, &tx_dr, (dr_sz - 1) * 2);
 		__iowmb();
 		result = cavm_lmt_submit((u64)(nix->nix_base +
-					       CAVM_NIXX_LF_OP_SENDX(0)));
+					       NIXX_LF_OP_SENDX(0)));
 		WATCHDOG_RESET();
 	} while (result == 0);
 
@@ -607,10 +588,10 @@ void nix_lf_flush_rx(struct udevice *dev)
 {
 	struct rvu_pf *rvu = dev_get_priv(dev);
 	struct nix *nix = rvu->nix;
-	union cavm_nixx_lf_cq_op_status op_status;
+	union nixx_lf_cq_op_status op_status;
 	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
 	struct nix_rx_dr *rx_dr;
-	union cavm_nix_rx_parse_s *rxparse;
+	union nix_rx_parse_s *rxparse;
 	u32 head, tail;
 	u32 rx_cqe_sz = nix->cq[NIX_CQ_RX].entry_sz;
 	u64 *seg;
@@ -625,19 +606,19 @@ void nix_lf_flush_rx(struct udevice *dev)
 	debug("%s cq rx head %d tail %d\n", __func__, head, tail);
 	while (head != tail) {
 		rx_dr = (struct nix_rx_dr *)cq_rx_base + head * rx_cqe_sz;
-		rxparse = &(rx_dr->rx_parse);
+		rxparse = &rx_dr->rx_parse;
 
 		debug("%s: rx parse: %p\n", __func__, rxparse);
-		debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x \n",
-		 __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+		debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x\n",
+		      __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
 
 		seg = (dma_addr_t *)(&rx_dr->rx_sg + 1);
 
-		cavm_st128(nix->npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+		cavm_st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
 			   seg[0], (1ULL << 63) | NPA_POOL_RX);
 
-		debug("%s return %llx to NPA \n", __func__, seg[0]);
-		nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+		debug("%s return %llx to NPA\n", __func__, seg[0]);
+		nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
 				 (NIX_CQ_RX << 32) | 1);
 
 		op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
@@ -655,10 +636,10 @@ int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
 	struct nix *nix = rvu->nix;
 
 	/* Return rx packet to NPA */
-	debug("%s return %p to NPA \n", __func__, pkt);
-	cavm_st128(nix->npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+	debug("%s return %p to NPA\n", __func__, pkt);
+	cavm_st128(nix->npa->npa_base + NPA_LF_AURA_OP_FREE0(),
 		   (u64)pkt, (1ULL << 63) | NPA_POOL_RX);
-	nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+	nix_pf_reg_write(nix, NIXX_LF_CQ_OP_DOOR(),
 			 (NIX_CQ_RX << 32) | 1);
 
 	nix_lf_flush_tx(dev);
@@ -669,10 +650,10 @@ int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp)
 {
 	struct rvu_pf *rvu = dev_get_priv(dev);
 	struct nix *nix = rvu->nix;
-	union cavm_nixx_lf_cq_op_status op_status;
+	union nixx_lf_cq_op_status op_status;
 	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
 	struct nix_rx_dr *rx_dr;
-	union cavm_nix_rx_parse_s *rxparse;
+	union nix_rx_parse_s *rxparse;
 	void *pkt, *cqe;
 	int pkt_len = 0;
 	u64 *addr;
@@ -688,20 +669,21 @@ int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp)
 	if (head == tail)
 		return -EAGAIN;
 
-	debug("%s: rx_base %p head %d sz %d \n", __func__, cq_rx_base, head, nix->cq[NIX_CQ_RX].entry_sz);
+	debug("%s: rx_base %p head %d sz %d\n", __func__, cq_rx_base, head,
+	      nix->cq[NIX_CQ_RX].entry_sz);
 	cqe = cq_rx_base + head * nix->cq[NIX_CQ_RX].entry_sz;
 	rx_dr = (struct nix_rx_dr *)cqe;
-	rxparse = &(rx_dr->rx_parse);
+	rxparse = &rx_dr->rx_parse;
 
 	debug("%s: rx completion: %p\n", __func__, cqe);
 	debug("%s: rx dr: %p\n", __func__, rx_dr);
 	debug("%s: rx parse: %p\n", __func__, rxparse);
-	debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x \n",
-		 __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
-	debug("%s: rx parse: pkind %x chan %x \n",
-		 __func__, rxparse->s.pkind, rxparse->s.chan);
+	debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x\n",
+	      __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+	debug("%s: rx parse: pkind %x chan %x\n",
+	      __func__, rxparse->s.pkind, rxparse->s.chan);
 
-	if (rx_dr->hdr.s.cqe_type != CAVM_NIX_XQE_TYPE_E_RX) {
+	if (rx_dr->hdr.s.cqe_type != NIX_XQE_TYPE_E_RX) {
 		printf("%s: Error: Unsupported CQ header type in Rx %d\n",
 		       __func__, rx_dr->hdr.s.cqe_type);
 		return -1;
@@ -726,7 +708,7 @@ int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp)
 #ifdef DEBUG_PKT
 	debug("RX PKT Data\n");
 	for (int i = 0; i < pkt_len; i++) {
-		if (i && (i%8 == 0))
+		if (i && (i % 8 == 0))
 			debug("\n");
 		debug("%02x ", *((u8 *)pkt + i));
 	}
@@ -761,11 +743,6 @@ int nix_lf_setup_mac(struct udevice *dev)
 	return 0;
 }
 
-int nix_lf_read_rom_mac(struct udevice *dev)
-{
-	return -ENOSYS;
-}
-
 void nix_lf_halt(struct udevice *dev)
 {
 	struct rvu_pf *rvu = dev_get_priv(dev);
diff --git a/drivers/net/octeontx2/nix.h b/drivers/net/octeontx2/nix.h
index 265f164c1d..5de8b20e08 100644
--- a/drivers/net/octeontx2/nix.h
+++ b/drivers/net/octeontx2/nix.h
@@ -1,16 +1,15 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef __NIX_H__
 #define	__NIX_H__
 
-#include "cavm-csrs-npa.h"
-#include "cavm-csrs-nix.h"
+#include <asm/arch/csrs/csrs-npa.h>
+#include <asm/arch/csrs/csrs-nix.h>
 #include "rvu.h"
 
 /** Maximum number of LMACs supported */
@@ -68,7 +67,7 @@
 #define MAX_LMAC_PKIND			12
 
 /** Number of Admin queue entries */
-#define AQ_RING_SIZE 			Q_COUNT(Q_SIZE_16)
+#define AQ_RING_SIZE	Q_COUNT(Q_SIZE_16)
 
 /** Each completion queue contains 256 entries, see NIC_CQ_CTX_S[qsize] */
 #define CQS_QSIZE			Q_SIZE_256
@@ -97,6 +96,7 @@ enum npa_aura_size {
 	NPA_AURA_SZ_1M,
 	NPA_AURA_SZ_MAX,
 };
+
 #define NPA_AURA_SIZE_DEFAULT		NPA_AURA_SZ_128
 
 /* NIX Transmit schedulers */
@@ -166,8 +166,8 @@ struct nix_af {
 };
 
 struct nix_tx_dr {
-	union cavm_nix_send_hdr_s	hdr;
-	union cavm_nix_send_sg_s	tx_sg;
+	union nix_send_hdr_s	hdr;
+	union nix_send_sg_s	tx_sg;
 	dma_addr_t			sg1_addr;
 	dma_addr_t			sg2_addr;
 	dma_addr_t			sg3_addr;
@@ -175,9 +175,9 @@ struct nix_tx_dr {
 };
 
 struct nix_rx_dr {
-	union cavm_nix_cqe_hdr_s hdr;
-	union cavm_nix_rx_parse_s rx_parse;
-	union cavm_nix_rx_sg_s rx_sg;
+	union nix_cqe_hdr_s hdr;
+	union nix_rx_parse_s rx_parse;
+	union nix_rx_sg_s rx_sg;
 };
 
 struct nix {
@@ -186,12 +186,12 @@ struct nix {
 	struct nix_af			*nix_af;
 	struct npa			*npa;
 	struct lmac			*lmac;
-	union cavm_nix_cint_hw_s	*cint_base;
-	union cavm_nix_cq_ctx_s		*cq_ctx_base;
-	union cavm_nix_qint_hw_s	*qint_base;
-	union cavm_nix_rq_ctx_s		*rq_ctx_base;
-	union cavm_nix_rsse_s		*rss_base;
-	union cavm_nix_sq_ctx_s		*sq_ctx_base;
+	union nix_cint_hw_s	*cint_base;
+	union nix_cq_ctx_s		*cq_ctx_base;
+	union nix_qint_hw_s	*qint_base;
+	union nix_rq_ctx_s		*rq_ctx_base;
+	union nix_rsse_s		*rss_base;
+	union nix_sq_ctx_s		*sq_ctx_base;
 	void				*cqe_base;
 	struct qmem			sq;
 	struct qmem			cq[NIX_CQ_COUNT];
@@ -203,7 +203,6 @@ struct nix {
 	void __iomem			*nix_base;	/** PF reg base */
 	void __iomem			*npc_base;
 	void __iomem			*lmt_base;
-	struct nix_tx_dr		tx_desc[SQ_QLEN*2];
 	struct nix_stats		tx_stats;
 	struct nix_stats		rx_stats;
 	u32				aura;
@@ -211,9 +210,9 @@ struct nix {
 	int				lf;
 	int				pf;
 	u16				pf_func;
-	u32				rq_cnt;		/** Number of receive queues */
-	u32				sq_cnt;		/** Number of send squeues */
-	u32				cq_cnt;		/** Number of completion queues */
+	u32				rq_cnt;	/** receive queues count */
+	u32				sq_cnt;	/** send queues count */
+	u32				cq_cnt;	/** completion queues count */
 	u16				rss_sz;
 	u16				sqb_size;
 	u8				rss_grps;
@@ -221,25 +220,26 @@ struct nix {
 };
 
 struct nix_aq_cq_request {
-	union cavm_nix_aq_res_s	resp	ALIGNED;
-	union cavm_nix_cq_ctx_s	cq	ALIGNED;
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_cq_ctx_s	cq ALIGNED;
 };
 
 struct nix_aq_rq_request {
-	union cavm_nix_aq_res_s	resp	ALIGNED;
-	union cavm_nix_rq_ctx_s	rq	ALIGNED;
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_rq_ctx_s	rq ALIGNED;
 };
 
 struct nix_aq_sq_request {
-	union cavm_nix_aq_res_s	resp	ALIGNED;
-	union cavm_nix_sq_ctx_s	sq	ALIGNED;
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_sq_ctx_s	sq ALIGNED;
 };
 
 static inline u64 nix_af_reg_read(struct nix_af *nix_af, u64 offset)
 {
 	u64 val = readq(nix_af->nix_af_base + offset);
+
 	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
-		val);
+	      val);
 	return val;
 }
 
@@ -247,15 +247,16 @@ static inline void nix_af_reg_write(struct nix_af *nix_af, u64 offset,
 				    u64 val)
 {
 	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
-		val);
+	      val);
 	writeq(val, nix_af->nix_af_base + offset);
 }
 
 static inline u64 nix_pf_reg_read(struct nix *nix, u64 offset)
 {
 	u64 val = readq(nix->nix_base + offset);
+
 	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
-		val);
+	      val);
 	return val;
 }
 
@@ -263,15 +264,16 @@ static inline void nix_pf_reg_write(struct nix *nix, u64 offset,
 				    u64 val)
 {
 	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
-		val);
+	      val);
 	writeq(val, nix->nix_base + offset);
 }
 
 static inline u64 npa_af_reg_read(struct npa_af *npa_af, u64 offset)
 {
 	u64 val = readq(npa_af->npa_af_base + offset);
+
 	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
-		val);
+	      val);
 	return val;
 }
 
@@ -279,15 +281,16 @@ static inline void npa_af_reg_write(struct npa_af *npa_af, u64 offset,
 				    u64 val)
 {
 	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
-		val);
+	      val);
 	writeq(val, npa_af->npa_af_base + offset);
 }
 
 static inline u64 npc_af_reg_read(struct nix_af *nix_af, u64 offset)
 {
 	u64 val = readq(nix_af->npc_af_base + offset);
+
 	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
-		val);
+	      val);
 	return val;
 }
 
@@ -295,14 +298,14 @@ static inline void npc_af_reg_write(struct nix_af *nix_af, u64 offset,
 				    u64 val)
 {
 	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
-		val);
+	      val);
 	writeq(val, nix_af->npc_af_base + offset);
 }
 
 int npa_attach_aura(struct nix_af *nix_af, int lf,
-			const union cavm_npa_aura_s *desc, u32 aura_id);
+		    const union npa_aura_s *desc, u32 aura_id);
 int npa_attach_pool(struct nix_af *nix_af, int lf,
-			const union cavm_npa_pool_s *desc, u32 pool_id);
+		    const union npa_pool_s *desc, u32 pool_id);
 int npa_af_setup(struct npa_af *npa_af);
 int npa_af_shutdown(struct npa_af *npa_af);
 int npa_lf_setup(struct nix *nix);
diff --git a/drivers/net/octeontx2/nix_af.c b/drivers/net/octeontx2/nix_af.c
index 92ddf42ad8..6f42587101 100644
--- a/drivers/net/octeontx2/nix_af.c
+++ b/drivers/net/octeontx2/nix_af.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -19,52 +18,52 @@
 #include <linux/list.h>
 #include <linux/log2.h>
 #include <asm/arch/octeontx2.h>
-#include "cavm-csrs-npc.h"
-#include "cavm-csrs-lmt.h"
+#include "asm/arch/csrs/csrs-npc.h"
+#include "asm/arch/csrs/csrs-lmt.h"
 #include "nix.h"
 #include "lmt.h"
 #include "cgx.h"
 
 /***************
- * NPA API 
+ * NPA API
  ***************/
 int npa_attach_aura(struct nix_af *nix_af, int lf,
-			   const union cavm_npa_aura_s *desc, u32 aura_id)
+		    const union npa_aura_s *desc, u32 aura_id)
 {
 	struct npa_af *npa = nix_af->npa_af;
-	union cavm_npa_aq_inst_s *inst;
-	volatile union cavm_npa_aq_res_s *res;
-	union cavm_npa_af_aq_status aq_stat;
-	union cavm_npa_aura_s *context;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
+	union npa_aura_s *context;
 	u64 head;
 	ulong start;
 
 	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, aura_id);
-	aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
 	head = aq_stat.s.head_ptr;
-	inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
-	res = (volatile union cavm_npa_aq_res_s *)(npa->aq.res.base);
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
 
 	memset(inst, 0, sizeof(*inst));
 	inst->s.lf = lf;
 	inst->s.doneint = 0;
-	inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_AURA;
-	inst->s.op = CAVM_NPA_AQ_INSTOP_E_INIT;
+	inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
 	inst->s.res_addr = npa->aq.res.iova;
 	inst->s.cindex = aura_id;
 
-	context = (union cavm_npa_aura_s *)(npa->aq.res.base +
+	context = (union npa_aura_s *)(npa->aq.res.base +
 						CONFIG_SYS_CACHELINE_SIZE);
 	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
-	memcpy(context, desc, sizeof(union cavm_npa_aura_s));
+	memcpy(context, desc, sizeof(union npa_aura_s));
 	__iowmb();
-	npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
 
 	start = get_timer(0);
-	while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
 	       (get_timer(start) < 1000))
 		WATCHDOG_RESET();
-	if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
 		printf("%s: Error: result 0x%x not good\n",
 		       __func__, res->s.compcode);
 		return -1;
@@ -74,44 +73,44 @@ int npa_attach_aura(struct nix_af *nix_af, int lf,
 }
 
 int npa_attach_pool(struct nix_af *nix_af, int lf,
-			   const union cavm_npa_pool_s *desc, u32 pool_id)
+		    const union npa_pool_s *desc, u32 pool_id)
 {
-	union cavm_npa_aq_inst_s *inst;
-	volatile union cavm_npa_aq_res_s *res;
-	union cavm_npa_af_aq_status aq_stat;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
 	struct npa_af *npa = nix_af->npa_af;
-	union cavm_npa_aura_s *context;
+	union npa_aura_s *context;
 	u64 head;
 	ulong start;
 
 	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, pool_id);
-	aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
 	head = aq_stat.s.head_ptr;
 
-	inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
-	res = (union cavm_npa_aq_res_s *)(npa->aq.res.base);
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
 
 	memset(inst, 0, sizeof(*inst));
 	inst->s.cindex = pool_id;
 	inst->s.lf = lf;
 	inst->s.doneint = 0;
-	inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_POOL;
-	inst->s.op = CAVM_NPA_AQ_INSTOP_E_INIT;
+	inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
 	inst->s.res_addr = npa->aq.res.iova;
 
-	context = (union cavm_npa_aura_s *)(npa->aq.res.base +
+	context = (union npa_aura_s *)(npa->aq.res.base +
 						CONFIG_SYS_CACHELINE_SIZE);
 	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
-	memcpy(context, desc, sizeof(union cavm_npa_aura_s));
+	memcpy(context, desc, sizeof(union npa_aura_s));
 	__iowmb();
-	npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
 
 	start = get_timer(0);
-	while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
 	       (get_timer(start) < 1000))
 		WATCHDOG_RESET();
 
-	if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
 		printf("%s: Error: result 0x%x not good\n",
 		       __func__, res->s.compcode);
 		return -1;
@@ -120,34 +119,33 @@ int npa_attach_pool(struct nix_af *nix_af, int lf,
 	return 0;
 }
 
-
 int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base)
 {
-	union cavm_npa_af_lf_rst lf_rst;
-	union cavm_npa_af_lfx_auras_cfg auras_cfg;
+	union npa_af_lf_rst lf_rst;
+	union npa_af_lfx_auras_cfg auras_cfg;
 	struct npa_af *npa_af = npa->npa_af;
 
 	debug("%s(%p, %d, 0x%llx)\n", __func__, npa_af, lf, aura_base);
 	lf_rst.u = 0;
 	lf_rst.s.exec = 1;
 	lf_rst.s.lf = lf;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_LF_RST(), lf_rst.u);
+	npa_af_reg_write(npa_af, NPA_AF_LF_RST(), lf_rst.u);
 
 	do {
-		lf_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_LF_RST());
+		lf_rst.u = npa_af_reg_read(npa_af, NPA_AF_LF_RST());
 		WATCHDOG_RESET();
 	} while (lf_rst.s.exec);
 
 	/* Set Aura size and enable caching of contexts */
-	auras_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_LFX_AURAS_CFG(lf));
+	auras_cfg.u = npa_af_reg_read(npa_af, NPA_AF_LFX_AURAS_CFG(lf));
 	auras_cfg.s.loc_aura_size = NPA_AURA_SIZE_DEFAULT; //FIXME aura_size;
 	auras_cfg.s.caching = 1;
 	auras_cfg.s.rmt_aura_size = 0;
 	auras_cfg.s.rmt_aura_offset = 0;
 	auras_cfg.s.rmt_lf = 0;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_LFX_AURAS_CFG(lf), auras_cfg.u);
+	npa_af_reg_write(npa_af, NPA_AF_LFX_AURAS_CFG(lf), auras_cfg.u);
 	/* Configure aura HW context base */
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_LFX_LOC_AURAS_BASE(lf),
+	npa_af_reg_write(npa_af, NPA_AF_LFX_LOC_AURAS_BASE(lf),
 			 aura_base);
 
 	return 0;
@@ -157,35 +155,35 @@ int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
 {
 	int pool_id;
 	u32 head;
-	union cavm_npa_aq_inst_s *inst;
-	volatile union cavm_npa_aq_res_s *res;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
 	struct npa_aq_pool_request {
-		union cavm_npa_aq_res_s	resp	ALIGNED;
-		union cavm_npa_pool_s	p0	ALIGNED;
-		union cavm_npa_pool_s	p1	ALIGNED;
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_pool_s p0 ALIGNED;
+		union npa_pool_s p1 ALIGNED;
 	} pool_req ALIGNED;
 	struct npa_aq_aura_request {
-		union cavm_npa_aq_res_s	resp	ALIGNED;
-		union cavm_npa_aura_s	a0	ALIGNED;
-		union cavm_npa_aura_s	a1	ALIGNED;
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_aura_s a0 ALIGNED;
+		union npa_aura_s a1 ALIGNED;
 	} aura_req ALIGNED;
-	union cavm_npa_af_aq_status aq_stat;
-	union cavm_npa_af_lf_rst lf_rst;
+	union npa_af_aq_status aq_stat;
+	union npa_af_lf_rst lf_rst;
 	struct npa_af *npa = nix_af->npa_af;
 	ulong start;
 
 	for (pool_id = 0; pool_id < pool_count; pool_id++) {
-		aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
 		head = aq_stat.s.head_ptr;
-		inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
 		res = &pool_req.resp;
 
 		memset(inst, 0, sizeof(*inst));
 		inst->s.cindex = pool_id;
 		inst->s.lf = lf;
 		inst->s.doneint = 0;
-		inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_POOL;
-		inst->s.op = CAVM_NPA_AQ_INSTOP_E_WRITE;
+		inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
 		inst->s.res_addr = (u64)&pool_req.resp;
 
 		memset((void *)&pool_req, 0, sizeof(pool_req));
@@ -193,35 +191,35 @@ int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
 		pool_req.p1.s.ena = 1;	/* Write mask */
 		__iowmb();
 
-		npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
 
 		start = get_timer(0);
-		while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
 		       (get_timer(start) < 1000))
 			WATCHDOG_RESET();
 
-		if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
-			printf("%s: Error: result 0x%x not good for lf %d \n"
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
 			       " aura id %d", __func__, res->s.compcode, lf,
 				pool_id);
 			return -1;
 		}
 		debug("%s(LF %d, pool id %d) disabled\n", __func__, lf,
-			 pool_id);
+		      pool_id);
 	}
 
 	for (pool_id = 0; pool_id < pool_count; pool_id++) {
-		aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
 		head = aq_stat.s.head_ptr;
-		inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
 		res = &aura_req.resp;
 
 		memset(inst, 0, sizeof(*inst));
 		inst->s.cindex = pool_id;
 		inst->s.lf = lf;
 		inst->s.doneint = 0;
-		inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_AURA;
-		inst->s.op = CAVM_NPA_AQ_INSTOP_E_WRITE;
+		inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
 		inst->s.res_addr = (u64)&aura_req.resp;
 
 		memset((void *)&aura_req, 0, sizeof(aura_req));
@@ -229,31 +227,31 @@ int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
 		aura_req.a1.s.ena = 1;	/* Write mask */
 		__iowmb();
 
-		npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
 
 		start = get_timer(0);
-		while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
 		       (get_timer(start) < 1000))
 			WATCHDOG_RESET();
 
-		if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
-			printf("%s: Error: result 0x%x not good for lf %d \n"
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
 			       " aura id %d", __func__, res->s.compcode, lf,
-				pool_id);
+			       pool_id);
 			return -1;
 		}
 		debug("%s(LF %d, aura id %d) disabled\n", __func__, lf,
-			 pool_id);
+		      pool_id);
 	}
 
 	/* Reset the LF */
 	lf_rst.u = 0;
 	lf_rst.s.exec = 1;
 	lf_rst.s.lf = lf;
-	npa_af_reg_write(npa, CAVM_NPA_AF_LF_RST(), lf_rst.u);
+	npa_af_reg_write(npa, NPA_AF_LF_RST(), lf_rst.u);
 
 	do {
-		lf_rst.u = npa_af_reg_read(npa, CAVM_NPA_AF_LF_RST());
+		lf_rst.u = npa_af_reg_read(npa, NPA_AF_LF_RST());
 		WATCHDOG_RESET();
 	} while (lf_rst.s.exec);
 
@@ -263,14 +261,14 @@ int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
 int npa_af_setup(struct npa_af *npa_af)
 {
 	int err;
-	union cavm_npa_af_gen_cfg npa_cfg;
-	union cavm_npa_af_ndc_cfg ndc_cfg;
-	union cavm_npa_af_aq_cfg aq_cfg;
-	union cavm_npa_af_blk_rst blk_rst;
+	union npa_af_gen_cfg npa_cfg;
+	union npa_af_ndc_cfg ndc_cfg;
+	union npa_af_aq_cfg aq_cfg;
+	union npa_af_blk_rst blk_rst;
 
 	err = rvu_aq_alloc(&npa_af->aq, Q_COUNT(AQ_SIZE),
-				sizeof(union cavm_npa_aq_inst_s),
-				sizeof(union cavm_npa_aq_res_s));
+			   sizeof(union npa_aq_inst_s),
+			   sizeof(union npa_aq_res_s));
 	if (err) {
 		printf("%s: Error %d allocating admin queue\n", __func__, err);
 		return err;
@@ -280,55 +278,55 @@ int npa_af_setup(struct npa_af *npa_af)
 
 	blk_rst.u = 0;
 	blk_rst.s.rst = 1;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_BLK_RST(), blk_rst.u);
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
 
 	/* Wait for reset to complete */
 	do {
-		blk_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_BLK_RST());
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
 		WATCHDOG_RESET();
 	} while (blk_rst.s.busy);
 
 	/* Set little Endian */
-	npa_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_GEN_CFG());
+	npa_cfg.u = npa_af_reg_read(npa_af, NPA_AF_GEN_CFG());
 	npa_cfg.s.af_be = 0;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_GEN_CFG(), npa_cfg.u);
+	npa_af_reg_write(npa_af, NPA_AF_GEN_CFG(), npa_cfg.u);
 	/* Enable NDC cache */
-	ndc_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_NDC_CFG());
+	ndc_cfg.u = npa_af_reg_read(npa_af, NPA_AF_NDC_CFG());
 	ndc_cfg.s.ndc_bypass = 0;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_NDC_CFG(), ndc_cfg.u);
+	npa_af_reg_write(npa_af, NPA_AF_NDC_CFG(), ndc_cfg.u);
 	/* Set up queue size */
-	aq_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_AQ_CFG());
+	aq_cfg.u = npa_af_reg_read(npa_af, NPA_AF_AQ_CFG());
 	aq_cfg.s.qsize = AQ_SIZE;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_AQ_CFG(), aq_cfg.u);
+	npa_af_reg_write(npa_af, NPA_AF_AQ_CFG(), aq_cfg.u);
 	/* Set up queue base address */
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_AQ_BASE(), npa_af->aq.inst.iova);
+	npa_af_reg_write(npa_af, NPA_AF_AQ_BASE(), npa_af->aq.inst.iova);
 
 	return 0;
 }
 
 int npa_af_shutdown(struct npa_af *npa_af)
 {
-	union cavm_npa_af_blk_rst blk_rst;
+	union npa_af_blk_rst blk_rst;
 
 	blk_rst.u = 0;
 	blk_rst.s.rst = 1;
-	npa_af_reg_write(npa_af, CAVM_NPA_AF_BLK_RST(), blk_rst.u);
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
 
 	/* Wait for reset to complete */
 	do {
-		blk_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_BLK_RST());
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
 		WATCHDOG_RESET();
 	} while (blk_rst.s.busy);
 
 	rvu_aq_free(&npa_af->aq);
 
-	debug("%s: npa af reset -- \n", __func__);
+	debug("%s: npa af reset --\n", __func__);
 
 	return 0;
 }
 
 /***************
- * NIX API 
+ * NIX API
  ***************/
 /**
  * Setup SMQ -> TL4 -> TL3 -> TL2 -> TL1 -> MAC mapping
@@ -339,94 +337,96 @@ int npa_af_shutdown(struct npa_af *npa_af)
  */
 static int nix_af_setup_sq(struct nix *nix)
 {
-	union cavm_nixx_af_tl1x_schedule tl1_sched;
-	union cavm_nixx_af_tl2x_parent tl2_parent;
-	union cavm_nixx_af_tl3x_parent tl3_parent;
-	union cavm_nixx_af_tl3_tl2x_cfg tl3_tl2_cfg;
-	union cavm_nixx_af_tl3_tl2x_linkx_cfg tl3_tl2_link_cfg;
-	union cavm_nixx_af_tl4x_parent tl4_parent;
-	union cavm_nixx_af_tl4x_sdp_link_cfg tl4_sdp_link_cfg;
-	union cavm_nixx_af_smqx_cfg smq_cfg;
-	union cavm_nixx_af_mdqx_schedule mdq_sched;
-	union cavm_nixx_af_mdqx_parent mdq_parent;
-	union cavm_nixx_af_rx_linkx_cfg link_cfg;
+	union nixx_af_tl1x_schedule tl1_sched;
+	union nixx_af_tl2x_parent tl2_parent;
+	union nixx_af_tl3x_parent tl3_parent;
+	union nixx_af_tl3_tl2x_cfg tl3_tl2_cfg;
+	union nixx_af_tl3_tl2x_linkx_cfg tl3_tl2_link_cfg;
+	union nixx_af_tl4x_parent tl4_parent;
+	union nixx_af_tl4x_sdp_link_cfg tl4_sdp_link_cfg;
+	union nixx_af_smqx_cfg smq_cfg;
+	union nixx_af_mdqx_schedule mdq_sched;
+	union nixx_af_mdqx_parent mdq_parent;
+	union nixx_af_rx_linkx_cfg link_cfg;
 	int tl1_index = nix->lmac->link_num; /* NIX_LINK_E enum */
 	int tl2_index = tl1_index;
 	int tl3_index = tl2_index;
 	int tl4_index = tl3_index;
 	int smq_index = tl4_index;
 	struct nix_af *nix_af = nix->nix_af;
+	u64 offset = 0;
 
 	tl1_sched.u = nix_af_reg_read(nix_af,
-					CAVM_NIXX_AF_TL1X_SCHEDULE(tl1_index));
+				      NIXX_AF_TL1X_SCHEDULE(tl1_index));
 	tl1_sched.s.rr_quantum = MAX_MTU;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL1X_SCHEDULE(tl1_index),
-				      tl1_sched.u);
+	nix_af_reg_write(nix_af, NIXX_AF_TL1X_SCHEDULE(tl1_index),
+			 tl1_sched.u);
 
 	tl2_parent.u = nix_af_reg_read(nix_af,
-					CAVM_NIXX_AF_TL2X_PARENT(tl2_index));
+				       NIXX_AF_TL2X_PARENT(tl2_index));
 	tl2_parent.s.parent = tl1_index;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL2X_PARENT(tl2_index),
-				      tl2_parent.u);
+	nix_af_reg_write(nix_af, NIXX_AF_TL2X_PARENT(tl2_index),
+			 tl2_parent.u);
 
 	tl3_parent.u = nix_af_reg_read(nix_af,
-					CAVM_NIXX_AF_TL3X_PARENT(tl3_index));
+				       NIXX_AF_TL3X_PARENT(tl3_index));
 	tl3_parent.s.parent = tl2_index;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL3X_PARENT(tl3_index),
-				      tl3_parent.u);
+	nix_af_reg_write(nix_af, NIXX_AF_TL3X_PARENT(tl3_index),
+			 tl3_parent.u);
 	tl3_tl2_cfg.u = nix_af_reg_read(nix_af,
-					CAVM_NIXX_AF_TL3_TL2X_CFG(tl3_index));
+					NIXX_AF_TL3_TL2X_CFG(tl3_index));
 	tl3_tl2_cfg.s.express = 0;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL3_TL2X_CFG(tl3_index),
-				      tl3_tl2_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_TL3_TL2X_CFG(tl3_index),
+			 tl3_tl2_cfg.u);
 
-	tl3_tl2_link_cfg.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
-				nix->lmac->link_num));
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	tl3_tl2_link_cfg.u = nix_af_reg_read(nix_af, offset);
 	tl3_tl2_link_cfg.s.bp_ena = 1;
 	tl3_tl2_link_cfg.s.ena = 1;
 	tl3_tl2_link_cfg.s.relchan = 0;
-	nix_af_reg_write(nix_af,
-				CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
-				nix->lmac->link_num), tl3_tl2_link_cfg.u);
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	nix_af_reg_write(nix_af, offset, tl3_tl2_link_cfg.u);
 
 	tl4_parent.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_TL4X_PARENT(tl4_index));
+				       NIXX_AF_TL4X_PARENT(tl4_index));
 	tl4_parent.s.parent = tl3_index;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL4X_PARENT(tl4_index),
-				tl4_parent.u);
-	tl4_sdp_link_cfg.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index));
+	nix_af_reg_write(nix_af, NIXX_AF_TL4X_PARENT(tl4_index),
+			 tl4_parent.u);
+
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	tl4_sdp_link_cfg.u = nix_af_reg_read(nix_af, offset);
 	tl4_sdp_link_cfg.s.bp_ena = 0;
 	tl4_sdp_link_cfg.s.ena = 0;
 	tl4_sdp_link_cfg.s.relchan = 0;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index),
-				tl4_sdp_link_cfg.u);
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	nix_af_reg_write(nix_af, offset, tl4_sdp_link_cfg.u);
 
-	smq_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_SMQX_CFG(smq_index));
+	smq_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_SMQX_CFG(smq_index));
 	smq_cfg.s.express = 0;
 	smq_cfg.s.lf = nix->lf;
 	smq_cfg.s.desc_shp_ctl_dis = 1;
 	smq_cfg.s.maxlen = MAX_MTU;
 	smq_cfg.s.minlen = NIX_MIN_HW_MTU;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_SMQX_CFG(smq_index), smq_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_SMQX_CFG(smq_index), smq_cfg.u);
 
 	mdq_sched.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_MDQX_SCHEDULE(smq_index));
+				      NIXX_AF_MDQX_SCHEDULE(smq_index));
 	mdq_sched.s.rr_quantum = MAX_MTU;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_MDQX_SCHEDULE(smq_index),
-		      mdq_sched.u);
+	offset = NIXX_AF_MDQX_SCHEDULE(smq_index);
+	nix_af_reg_write(nix_af, offset, mdq_sched.u);
 	mdq_parent.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_MDQX_PARENT(smq_index));
+				       NIXX_AF_MDQX_PARENT(smq_index));
 	mdq_parent.s.parent = tl4_index;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_MDQX_PARENT(smq_index),
-		      mdq_parent.u);
+	nix_af_reg_write(nix_af, NIXX_AF_MDQX_PARENT(smq_index),
+			 mdq_parent.u);
 
 	link_cfg.u = 0;
 	link_cfg.s.maxlen = NIX_MAX_HW_MTU;
 	link_cfg.s.minlen = NIX_MIN_HW_MTU;
 	nix_af_reg_write(nix->nix_af,
-			 CAVM_NIXX_AF_RX_LINKX_CFG(nix->lmac->link_num),
+			 NIXX_AF_RX_LINKX_CFG(nix->lmac->link_num),
 			 link_cfg.u);
 
 	return 0;
@@ -448,17 +448,17 @@ static int nix_aq_issue_command(struct nix_af *nix_af,
 				int lf,
 				int op,
 				int ctype,
-				int cindex, union cavm_nix_aq_res_s *resp)
+				int cindex, union nix_aq_res_s *resp)
 {
-	union cavm_nixx_af_aq_status aq_status;
-	union cavm_nix_aq_inst_s *aq_inst;
-	volatile union cavm_nix_aq_res_s *result = resp;
+	union nixx_af_aq_status aq_status;
+	union nix_aq_inst_s *aq_inst;
+	union nix_aq_res_s *result = resp;
 	ulong start;
 
 	debug("%s(%p, 0x%x, 0x%x, 0x%x, 0x%x, %p)\n", __func__, nix_af, lf,
 	      op, ctype, cindex, resp);
-	aq_status.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_AQ_STATUS());
-	aq_inst = (union cavm_nix_aq_inst_s *)(nix_af->aq.inst.base) +
+	aq_status.u = nix_af_reg_read(nix_af, NIXX_AF_AQ_STATUS());
+	aq_inst = (union nix_aq_inst_s *)(nix_af->aq.inst.base) +
 						aq_status.s.head_ptr;
 	aq_inst->u[0] = 0;
 	aq_inst->u[1] = 0;
@@ -473,7 +473,7 @@ static int nix_aq_issue_command(struct nix_af *nix_af,
 	__iowmb();
 
 	/* Ring doorbell and wait for result */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_DOOR(), 1);
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_DOOR(), 1);
 
 	start = get_timer(0);
 	/* Wait for completion */
@@ -482,8 +482,8 @@ static int nix_aq_issue_command(struct nix_af *nix_af,
 		dsb();
 	} while (result->s.compcode == 0 && get_timer(start) < 2);
 
-	if (result->s.compcode != CAVM_NIX_AQ_COMP_E_GOOD) {
-		printf("NIX: Admin Queue failed or timed out with code %d after %ld ms\n",
+	if (result->s.compcode != NIX_AQ_COMP_E_GOOD) {
+		printf("NIX:AQ fail or time out with code %d after %ld ms\n",
 		       result->s.compcode, get_timer(start));
 		return -EBUSY;
 	}
@@ -498,7 +498,7 @@ static int nix_attach_receive_queue(struct nix_af *nix_af, int lf)
 	debug("%s(%p, %d)\n", __func__, nix_af, lf);
 
 	memset(&rq_req, 0, sizeof(struct nix_aq_rq_request));
-	
+
 	rq_req.rq.s.ena = 1;
 	rq_req.rq.s.spb_ena = 1;
 	rq_req.rq.s.ipsech_ena = 0;
@@ -534,10 +534,10 @@ static int nix_attach_receive_queue(struct nix_af *nix_af, int lf)
 	rq_req.rq.s.qint_idx = 0;
 
 	err = nix_aq_issue_command(nix_af, lf,
-				   CAVM_NIX_AQ_INSTOP_E_INIT,
-				   CAVM_NIX_AQ_CTYPE_E_RQ,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_RQ,
 				   0, &rq_req.resp);
-	if (err) { 
+	if (err) {
 		printf("%s: Error requesting send queue\n", __func__);
 		return err;
 	}
@@ -552,13 +552,13 @@ static int nix_attach_send_queue(struct nix *nix)
 	int err;
 
 	debug("%s(%p)\n", __func__, nix_af);
-	err = nix_af_setup_sq(nix); 
+	err = nix_af_setup_sq(nix);
 
 	memset(&sq_req, 0, sizeof(sq_req));
 
 	sq_req.sq.s.ena = 1;
 	sq_req.sq.s.cq_ena = 1;
-	sq_req.sq.s.max_sqe_size = CAVM_NIX_MAXSQESZ_E_W16;
+	sq_req.sq.s.max_sqe_size = NIX_MAXSQESZ_E_W16;
 	sq_req.sq.s.substream = 0; // FIXME: Substream IDs?
 	sq_req.sq.s.sdp_mcast = 0;
 	sq_req.sq.s.cq = NIX_CQ_TX;
@@ -567,13 +567,13 @@ static int nix_attach_send_queue(struct nix *nix)
 	sq_req.sq.s.sso_ena = 0;
 	sq_req.sq.s.smq_rr_quantum = MAX_MTU / 4;
 	sq_req.sq.s.default_chan = nix->lmac->chan_num;
-	sq_req.sq.s.sqe_stype = CAVM_NIX_STYPE_E_STP;
+	sq_req.sq.s.sqe_stype = NIX_STYPE_E_STP;
 	sq_req.sq.s.qint_idx = 0;
 	sq_req.sq.s.sqb_aura = NPA_POOL_SQB;
 
 	err = nix_aq_issue_command(nix_af, nix->lf,
-				   CAVM_NIX_AQ_INSTOP_E_INIT,
-				   CAVM_NIX_AQ_CTYPE_E_SQ,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_SQ,
 				   0, &sq_req.resp);
 	if (err) {
 		printf("%s: Error requesting send queue\n", __func__);
@@ -601,12 +601,12 @@ static int nix_attach_completion_queue(struct nix *nix, int cq_idx)
 	cq_req.cq.s.qint_idx = 0;
 	cq_req.cq.s.cint_idx = 0;
 	cq_req.cq.s.base = nix->cq[cq_idx].iova;
-	debug("%s: CQ(%d)  base %p \n", __func__, cq_idx,
+	debug("%s: CQ(%d)  base %p\n", __func__, cq_idx,
 	      nix->cq[cq_idx].base);
 
 	err = nix_aq_issue_command(nix_af, nix->lf,
-				   CAVM_NIX_AQ_INSTOP_E_INIT,
-				   CAVM_NIX_AQ_CTYPE_E_CQ,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_CQ,
 				   cq_idx, &cq_req.resp);
 	if (err) {
 		printf("%s: Error requesting completion queue\n", __func__);
@@ -620,16 +620,16 @@ static int nix_attach_completion_queue(struct nix *nix, int cq_idx)
 
 int nix_lf_admin_setup(struct nix *nix)
 {
-	union cavm_nixx_af_lfx_rqs_cfg rqs_cfg;
-	union cavm_nixx_af_lfx_sqs_cfg sqs_cfg;
-	union cavm_nixx_af_lfx_cqs_cfg cqs_cfg;
-	union cavm_nixx_af_lfx_rss_cfg rss_cfg;
-	union cavm_nixx_af_lfx_cints_cfg cints_cfg;
-	union cavm_nixx_af_lfx_qints_cfg qints_cfg;
-	union cavm_nixx_af_lfx_rss_grpx rss_grp;
-	union cavm_nixx_af_lfx_tx_cfg2 tx_cfg2;
-	union cavm_nixx_af_lfx_cfg lfx_cfg;
-	union cavm_nixx_af_lf_rst lf_rst;
+	union nixx_af_lfx_rqs_cfg rqs_cfg;
+	union nixx_af_lfx_sqs_cfg sqs_cfg;
+	union nixx_af_lfx_cqs_cfg cqs_cfg;
+	union nixx_af_lfx_rss_cfg rss_cfg;
+	union nixx_af_lfx_cints_cfg cints_cfg;
+	union nixx_af_lfx_qints_cfg qints_cfg;
+	union nixx_af_lfx_rss_grpx rss_grp;
+	union nixx_af_lfx_tx_cfg2 tx_cfg2;
+	union nixx_af_lfx_cfg lfx_cfg;
+	union nixx_af_lf_rst lf_rst;
 	u32 index;
 	struct nix_af *nix_af = nix->nix_af;
 	int err;
@@ -638,87 +638,87 @@ int nix_lf_admin_setup(struct nix *nix)
 	lf_rst.u = 0;
 	lf_rst.s.lf = nix->lf;
 	lf_rst.s.exec = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LF_RST(), lf_rst.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
 
 	do {
-		lf_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LF_RST());
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
 		WATCHDOG_RESET();
 	} while (lf_rst.s.exec);
 
 	/* Config NIX RQ HW context and base*/
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RQS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_BASE(nix->lf),
 			 (u64)nix->rq_ctx_base);
 	/* Set caching and queue count in HW */
-	rqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_RQS_CFG(nix->lf));
+	rqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf));
 	rqs_cfg.s.caching = 1;
 	rqs_cfg.s.max_queuesm1 = nix->rq_cnt - 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RQS_CFG(nix->lf), rqs_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf), rqs_cfg.u);
 
 	/* Config NIX SQ HW context and base*/
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_SQS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_BASE(nix->lf),
 			 (u64)nix->sq_ctx_base);
-	sqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_SQS_CFG(nix->lf));
+	sqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf));
 	sqs_cfg.s.caching = 1;
 	sqs_cfg.s.max_queuesm1 = nix->sq_cnt - 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_SQS_CFG(nix->lf), sqs_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf), sqs_cfg.u);
 
 	/* Config NIX CQ HW context and base*/
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CQS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_BASE(nix->lf),
 			 (u64)nix->cq_ctx_base);
-	cqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_CQS_CFG(nix->lf));
+	cqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf));
 	cqs_cfg.s.caching = 1;
 	cqs_cfg.s.max_queuesm1 = nix->cq_cnt - 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CQS_CFG(nix->lf), cqs_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf), cqs_cfg.u);
 
 	/* Config NIX RSS HW context and base */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RSS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_BASE(nix->lf),
 			 (u64)nix->rss_base);
-	rss_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_RSS_CFG(nix->lf));
+	rss_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf));
 	rss_cfg.s.ena = 1;
 	rss_cfg.s.size = ilog2(nix->rss_sz) / 256;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RSS_CFG(nix->lf), rss_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf), rss_cfg.u);
 
 	for (index = 0; index < nix->rss_grps; index++) {
 		rss_grp.u = 0;
 		rss_grp.s.sizem1 = 0x7;
 		rss_grp.s.offset = nix->rss_sz * index;
 		nix_af_reg_write(nix_af,
-				 CAVM_NIXX_AF_LFX_RSS_GRPX(nix->lf, index),
+				 NIXX_AF_LFX_RSS_GRPX(nix->lf, index),
 				 rss_grp.u);
 	}
 
 	/* Config CQints HW contexts and base */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CINTS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_BASE(nix->lf),
 			 (u64)nix->cint_base);
 	cints_cfg.u = nix_af_reg_read(nix_af,
-				      CAVM_NIXX_AF_LFX_CINTS_CFG(nix->lf));
+				      NIXX_AF_LFX_CINTS_CFG(nix->lf));
 	cints_cfg.s.caching = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CINTS_CFG(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_CFG(nix->lf),
 			 cints_cfg.u);
 
 	/* Config Qints HW context and base */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_QINTS_BASE(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_BASE(nix->lf),
 			 (u64)nix->qint_base);
 	qints_cfg.u = nix_af_reg_read(nix_af,
-				      CAVM_NIXX_AF_LFX_QINTS_CFG(nix->lf));
+				      NIXX_AF_LFX_QINTS_CFG(nix->lf));
 	qints_cfg.s.caching = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_QINTS_CFG(nix->lf),
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_CFG(nix->lf),
 			 qints_cfg.u);
 
 	debug("%s(%p, %d, %d)\n", __func__, nix_af, nix->lf, nix->pf);
 
 	/* Enable LMTST for this NIX LF */
-	tx_cfg2.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_TX_CFG2(nix->lf));
+	tx_cfg2.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf));
 	tx_cfg2.s.lmt_ena = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_TX_CFG2(nix->lf), tx_cfg2.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf), tx_cfg2.u);
 
 	/* Use 16-word XQEs, write the npa pf_func number only */
-	lfx_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_CFG(nix->lf));
-	lfx_cfg.s.xqe_size = CAVM_NIX_XQESZ_E_W16;
+	lfx_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CFG(nix->lf));
+	lfx_cfg.s.xqe_size = NIX_XQESZ_E_W16;
 	lfx_cfg.s.npa_pf_func = nix->pf_func;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CFG(nix->lf), lfx_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CFG(nix->lf), lfx_cfg.u);
 
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RX_CFG(nix->lf), 0);
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RX_CFG(nix->lf), 0);
 
 	for (index = 0; index < nix->cq_cnt; index++) {
 		err = nix_attach_completion_queue(nix, index);
@@ -753,32 +753,32 @@ int nix_lf_admin_setup(struct nix *nix)
 int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 			  u32 cq_count, u32 rq_count, u32 sq_count)
 {
-	union cavm_nixx_af_rx_sw_sync sw_sync;
+	union nixx_af_rx_sw_sync sw_sync;
 	struct nix_aq_cq_request {
-		union cavm_nix_aq_res_s	resp	ALIGNED;
-		union cavm_nix_cq_ctx_s	cq0	ALIGNED;
-		union cavm_nix_cq_ctx_s	cq1	ALIGNED;
+		union nix_aq_res_s	resp;
+		union nix_cq_ctx_s	cq0;
+		union nix_cq_ctx_s	cq1;
 	} cq_req ALIGNED;
 	struct nix_aq_rq_request {
-		union cavm_nix_aq_res_s	resp	ALIGNED;
-		union cavm_nix_rq_ctx_s	rq0	ALIGNED;
-		union cavm_nix_rq_ctx_s	rq1	ALIGNED;
+		union nix_aq_res_s	resp;
+		union nix_rq_ctx_s	rq0;
+		union nix_rq_ctx_s	rq1;
 	} rq_req ALIGNED;
 	struct nix_aq_sq_request {
-		union cavm_nix_aq_res_s	resp	ALIGNED;
-		union cavm_nix_sq_ctx_s	sq0	ALIGNED;
-		union cavm_nix_sq_ctx_s	sq1	ALIGNED;
+		union nix_aq_res_s	resp;
+		union nix_sq_ctx_s	sq0;
+		union nix_sq_ctx_s	sq1;
 	} sq_req ALIGNED;
-	union cavm_nixx_af_lf_rst lf_rst;
+	union nixx_af_lf_rst lf_rst;
 	int index, err;
 
 	/* Flush all tx packets */
 	sw_sync.u = 0;
 	sw_sync.s.ena = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_RX_SW_SYNC(), sw_sync.u);
+	nix_af_reg_write(nix_af, NIXX_AF_RX_SW_SYNC(), sw_sync.u);
 
 	do {
-		sw_sync.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_RX_SW_SYNC());
+		sw_sync.u = nix_af_reg_read(nix_af, NIXX_AF_RX_SW_SYNC());
 		WATCHDOG_RESET();
 	} while (sw_sync.s.ena);
 
@@ -789,12 +789,12 @@ int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 		__iowmb();
 
 		err = nix_aq_issue_command(nix_af, lf,
-					   CAVM_NIX_AQ_INSTOP_E_WRITE,
-					   CAVM_NIX_AQ_CTYPE_E_RQ,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_RQ,
 					   index, &rq_req.resp);
 		if (err) {
 			printf("%s: Error disabling LF %d RQ(%d)\n",
-				 __func__, lf, index);
+			       __func__, lf, index);
 			return err;
 		}
 		debug("%s: LF %d RQ(%d) disabled\n", __func__, lf, index);
@@ -807,12 +807,12 @@ int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 		__iowmb();
 
 		err = nix_aq_issue_command(nix_af, lf,
-					   CAVM_NIX_AQ_INSTOP_E_WRITE,
-					   CAVM_NIX_AQ_CTYPE_E_SQ,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_SQ,
 					   index, &sq_req.resp);
 		if (err) {
 			printf("%s: Error disabling LF %d SQ(%d)\n",
-				 __func__, lf, index);
+			       __func__, lf, index);
 			return err;
 		}
 		debug("%s: LF %d SQ(%d) disabled\n", __func__, lf, index);
@@ -825,12 +825,12 @@ int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 		__iowmb();
 
 		err = nix_aq_issue_command(nix_af, lf,
-					   CAVM_NIX_AQ_INSTOP_E_WRITE,
-					   CAVM_NIX_AQ_CTYPE_E_CQ,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_CQ,
 					   index, &cq_req.resp);
 		if (err) {
 			printf("%s: Error disabling LF %d CQ(%d)\n",
-				 __func__, lf, index);
+			       __func__, lf, index);
 			return err;
 		}
 		debug("%s: LF %d CQ(%d) disabled\n", __func__, lf, index);
@@ -840,10 +840,10 @@ int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 	lf_rst.u = 0;
 	lf_rst.s.lf = lf;
 	lf_rst.s.exec = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LF_RST(), lf_rst.u);
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
 
 	do {
-		lf_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LF_RST());
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
 		WATCHDOG_RESET();
 	} while (lf_rst.s.exec);
 
@@ -852,78 +852,79 @@ int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
 
 int npc_lf_admin_setup(struct nix *nix)
 {
-	union cavm_npc_af_const af_const;
-	union cavm_npc_af_pkindx_action0 action0;
-	union cavm_npc_af_pkindx_action1 action1;
-	union cavm_npc_af_intfx_kex_cfg kex_cfg;
-	union cavm_npc_af_intfx_miss_stat_act intfx_stat_act;
-	union cavm_npc_af_mcamex_bankx_camx_intf camx_intf;
-	union cavm_npc_af_mcamex_bankx_camx_w0 camx_w0;
-	union cavm_npc_af_mcamex_bankx_cfg bankx_cfg;
-	union cavm_npc_af_mcamex_bankx_stat_act mcamex_stat_act;
-
-	union cavm_nix_rx_action_s rx_action;
-	union cavm_nix_tx_action_s tx_action;
+	union npc_af_const af_const;
+	union npc_af_pkindx_action0 action0;
+	union npc_af_pkindx_action1 action1;
+	union npc_af_intfx_kex_cfg kex_cfg;
+	union npc_af_intfx_miss_stat_act intfx_stat_act;
+	union npc_af_mcamex_bankx_camx_intf camx_intf;
+	union npc_af_mcamex_bankx_camx_w0 camx_w0;
+	union npc_af_mcamex_bankx_cfg bankx_cfg;
+	union npc_af_mcamex_bankx_stat_act mcamex_stat_act;
+
+	union nix_rx_action_s rx_action;
+	union nix_tx_action_s tx_action;
 
 	struct nix_af *nix_af = nix->nix_af;
 	u32 kpus;
 	int pkind = nix->lmac->link_num;
 	int index;
+	u64 offset;
 
 	debug("%s(%p, pkind 0x%x)\n", __func__, nix_af, pkind);
-	af_const.u = npc_af_reg_read(nix_af, CAVM_NPC_AF_CONST());
+	af_const.u = npc_af_reg_read(nix_af, NPC_AF_CONST());
 	kpus = af_const.s.kpus;
 
 	action0.u = 0;
 	action0.s.parse_done = 1;
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_PKINDX_ACTION0(pkind), action0.u);
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION0(pkind), action0.u);
 
 	action1.u = 0;
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_PKINDX_ACTION1(pkind), action1.u);
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION1(pkind), action1.u);
 
 	kex_cfg.u = 0;
-	kex_cfg.s.keyw = CAVM_NPC_MCAMKEYW_E_X1;
+	kex_cfg.s.keyw = NPC_MCAMKEYW_E_X1;
 	kex_cfg.s.parse_nibble_ena = 0x7;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_INTFX_KEX_CFG(CAVM_NPC_INTF_E_NIXX_RX(0)),
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_RX(0)),
 			 kex_cfg.u);
 
 	/* Errata #35786 */
 	kex_cfg.u = 0;
 	kex_cfg.s.parse_nibble_ena = 0x7;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_INTFX_KEX_CFG(CAVM_NPC_INTF_E_NIXX_TX(0)),
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_TX(0)),
 			 kex_cfg.u);
 
 	camx_intf.u = 0;
-	camx_intf.s.intf = ~CAVM_NPC_INTF_E_NIXX_RX(0);
+	camx_intf.s.intf = ~NPC_INTF_E_NIXX_RX(0);
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 0),
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 0),
 			 camx_intf.u);
 
 	camx_intf.u = 0;
-	camx_intf.s.intf = CAVM_NPC_INTF_E_NIXX_RX(0);
+	camx_intf.s.intf = NPC_INTF_E_NIXX_RX(0);
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 1),
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 1),
 			 camx_intf.u);
 
 	camx_w0.u = 0;
 	camx_w0.s.md = ~(nix->lmac->chan_num) & (~((~0x0ull) << 12));
 	debug("NPC LF ADMIN camx_w0.u %llx\n", camx_w0.u);
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 0),
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 0),
 			 camx_w0.u);
 
 	camx_w0.u = 0;
 	camx_w0.s.md = nix->lmac->chan_num;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 1),
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 1),
 			 camx_w0.u);
 
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 0),
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 0),
 			 0);
 
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 1),
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 1),
 			 0);
 
 	/* Enable stats for NPC INTF RX */
@@ -931,43 +932,42 @@ int npc_lf_admin_setup(struct nix *nix)
 	mcamex_stat_act.s.ena = 1;
 	mcamex_stat_act.s.stat_sel = pkind;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(pkind, 0),
+			 NPC_AF_MCAMEX_BANKX_STAT_ACT(pkind, 0),
 			 mcamex_stat_act.u);
 	intfx_stat_act.u = 0;
 	intfx_stat_act.s.ena = 1;
 	intfx_stat_act.s.stat_sel = 16;
-	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
-			 intfx_stat_act.u);
+	offset = NPC_AF_INTFX_MISS_STAT_ACT(NPC_INTF_E_NIXX_RX(0));
+	npc_af_reg_write(nix_af, offset, intfx_stat_act.u);
 	rx_action.u = 0;
 	rx_action.s.pf_func = nix->pf_func;
-	rx_action.s.op = CAVM_NIX_RX_ACTIONOP_E_UCAST;
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_ACTION(pkind, 0),
+	rx_action.s.op = NIX_RX_ACTIONOP_E_UCAST;
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_ACTION(pkind, 0),
 			 rx_action.u);
 
 	for (index = 0; index < kpus; index++)
-		npc_af_reg_write(nix_af, CAVM_NPC_AF_KPUX_CFG(index), 0);
+		npc_af_reg_write(nix_af, NPC_AF_KPUX_CFG(index), 0);
 
 	rx_action.u = 0;
 	rx_action.s.pf_func = nix->pf_func;
-	rx_action.s.op = CAVM_NIX_RX_ACTIONOP_E_DROP;
+	rx_action.s.op = NIX_RX_ACTIONOP_E_DROP;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_RX(0)),
 			 rx_action.u);
 	bankx_cfg.u = 0;
 	bankx_cfg.s.ena = 1;
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CFG(pkind, 0),
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CFG(pkind, 0),
 			 bankx_cfg.u);
 
 	tx_action.u = 0;
-	tx_action.s.op = CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT;
+	tx_action.s.op = NIX_TX_ACTIONOP_E_UCAST_DEFAULT;
 	npc_af_reg_write(nix_af,
-			 CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_TX(0)),
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_TX(0)),
 			 tx_action.u);
 
 #ifdef DEBUG
 	/* Enable debug capture on RX intf */
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_DBG_CTL(), 0x4);
+	npc_af_reg_write(nix_af, NPC_AF_DBG_CTL(), 0x4);
 #endif
 
 	return 0;
@@ -975,19 +975,19 @@ int npc_lf_admin_setup(struct nix *nix)
 
 int npc_af_shutdown(struct nix_af *nix_af)
 {
-	union cavm_npc_af_blk_rst blk_rst;
+	union npc_af_blk_rst blk_rst;
 
 	blk_rst.u = 0;
 	blk_rst.s.rst = 1;
-	npc_af_reg_write(nix_af, CAVM_NPC_AF_BLK_RST(), blk_rst.u);
+	npc_af_reg_write(nix_af, NPC_AF_BLK_RST(), blk_rst.u);
 
 	/* Wait for reset to complete */
 	do {
-		blk_rst.u = npc_af_reg_read(nix_af, CAVM_NPC_AF_BLK_RST());
+		blk_rst.u = npc_af_reg_read(nix_af, NPC_AF_BLK_RST());
 		WATCHDOG_RESET();
 	} while (blk_rst.s.busy);
 
-	debug("%s: npc af reset -- \n", __func__);
+	debug("%s: npc af reset --\n", __func__);
 
 	return 0;
 }
@@ -995,19 +995,19 @@ int npc_af_shutdown(struct nix_af *nix_af)
 int nix_af_setup(struct nix_af *nix_af)
 {
 	int err;
-	union cavm_nixx_af_const2 af_const2;
-	union cavm_nixx_af_const3 af_const3;
-	union cavm_nixx_af_sq_const sq_const;
-	union cavm_nixx_af_cfg af_cfg;
-	union cavm_nixx_af_status af_status;
-	union cavm_nixx_af_ndc_cfg ndc_cfg;
-	union cavm_nixx_af_aq_cfg aq_cfg;
-	union cavm_nixx_af_blk_rst blk_rst;
+	union nixx_af_const2 af_const2;
+	union nixx_af_const3 af_const3;
+	union nixx_af_sq_const sq_const;
+	union nixx_af_cfg af_cfg;
+	union nixx_af_status af_status;
+	union nixx_af_ndc_cfg ndc_cfg;
+	union nixx_af_aq_cfg aq_cfg;
+	union nixx_af_blk_rst blk_rst;
 
 	debug("%s(%p)\n", __func__, nix_af);
 	err = rvu_aq_alloc(&nix_af->aq, Q_COUNT(AQ_SIZE),
-				sizeof(union cavm_nix_aq_inst_s),
-				sizeof(union cavm_nix_aq_res_s));
+			   sizeof(union nix_aq_inst_s),
+			   sizeof(union nix_aq_res_s));
 	if (err) {
 		printf("%s: Error allocating nix admin queue\n", __func__);
 		return err;
@@ -1015,43 +1015,43 @@ int nix_af_setup(struct nix_af *nix_af)
 
 	blk_rst.u = 0;
 	blk_rst.s.rst = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_BLK_RST(), blk_rst.u);
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
 
 	/* Wait for reset to complete */
 	do {
-		blk_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_BLK_RST());
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
 		WATCHDOG_RESET();
 	} while (blk_rst.s.busy);
 
 	/* Put in LE mode */
-	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
-	if (af_cfg.s.force_cond_clk_en ||
-	    af_cfg.s.calibrate_x2p || af_cfg.s.force_intf_clk_en) {
-		    printf("%s: Error: Invalid NIX_AF_CFG value 0x%llx\n",
-			   __func__, af_cfg.u);
-		    return -1;
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	if (af_cfg.s.force_cond_clk_en || af_cfg.s.calibrate_x2p ||
+	    af_cfg.s.force_intf_clk_en) {
+		printf("%s: Error: Invalid NIX_AF_CFG value 0x%llx\n",
+		       __func__, af_cfg.u);
+		return -1;
 	}
 	af_cfg.s.af_be = 0;
 	af_cfg.u |= 0x5E;	/* Errata 35057 */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
 
 	/* Perform Calibration */
-	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
 	af_cfg.s.calibrate_x2p = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
 
 	/* Wait for calibration to complete */
 	do {
-		af_status.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_STATUS());
+		af_status.u = nix_af_reg_read(nix_af, NIXX_AF_STATUS());
 		WATCHDOG_RESET();
 	} while (af_status.s.calibrate_done == 0);
 
-	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
 	af_cfg.s.calibrate_x2p = 0;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
 
 	/* Enable NDC cache */
-	ndc_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_NDC_CFG());
+	ndc_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_NDC_CFG());
 	ndc_cfg.s.ndc_ign_pois = 0;
 	ndc_cfg.s.byp_sq = 0;
 	ndc_cfg.s.byp_sqb = 0;
@@ -1066,19 +1066,19 @@ int nix_af_setup(struct nix_af *nix_af)
 	ndc_cfg.s.byp_mr_data = 0;
 	ndc_cfg.s.byp_mr_wqe = 0;
 	ndc_cfg.s.byp_qints = 0;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_NDC_CFG(), ndc_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_NDC_CFG(), ndc_cfg.u);
 
 	/* Set up queue size */
 	aq_cfg.u = 0;
 	aq_cfg.s.qsize = AQ_SIZE;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_CFG(), aq_cfg.u);
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_CFG(), aq_cfg.u);
 
 	/* Set up queue base address */
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_BASE(), nix_af->aq.inst.iova);
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_BASE(), nix_af->aq.inst.iova);
 
-	af_const3.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CONST3());
-	af_const2.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CONST2());
-	sq_const.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_SQ_CONST());
+	af_const3.u = nix_af_reg_read(nix_af, NIXX_AF_CONST3());
+	af_const2.u = nix_af_reg_read(nix_af, NIXX_AF_CONST2());
+	sq_const.u = nix_af_reg_read(nix_af, NIXX_AF_SQ_CONST());
 	nix_af->rq_ctx_sz = 1ULL << af_const3.s.rq_ctx_log2bytes;
 	nix_af->sq_ctx_sz = 1ULL << af_const3.s.sq_ctx_log2bytes;
 	nix_af->cq_ctx_sz = 1ULL << af_const3.s.cq_ctx_log2bytes;
@@ -1094,21 +1094,21 @@ int nix_af_setup(struct nix_af *nix_af)
 
 int nix_af_shutdown(struct nix_af *nix_af)
 {
-	union cavm_nixx_af_blk_rst blk_rst;
+	union nixx_af_blk_rst blk_rst;
 
 	blk_rst.u = 0;
 	blk_rst.s.rst = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_BLK_RST(), blk_rst.u);
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
 
 	/* Wait for reset to complete */
 	do {
-		blk_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_BLK_RST());
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
 		WATCHDOG_RESET();
 	} while (blk_rst.s.busy);
 
 	rvu_aq_free(&nix_af->aq);
 
-	debug("%s: nix af reset -- \n", __func__);
+	debug("%s: nix af reset --\n", __func__);
 
 	return 0;
 }
diff --git a/drivers/net/octeontx2/npc.c b/drivers/net/octeontx2/npc.c
deleted file mode 100644
index 5eec2797a0..0000000000
--- a/drivers/net/octeontx2/npc.c
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#include <common.h>
-#include <net.h>
-#include <netdev.h>
-#include <malloc.h>
-#include <dm.h>
-#include <misc.h>
-#include <pci.h>
-#include <memalign.h>
-#include <watchdog.h>
-#include <asm/io.h>
-#include <linux/types.h>
-#include <linux/bitops.h>
-#include <asm/arch/octeontx2.h>
-#include "cavm-csrs-npc.h"
-#include "cavm-csrs-nix.h"
-#include "npc_profile.h"
-#include "nix_af.h"
-#include "nix.h"
-#include "npc.h"
-
-#define RSVD_MCAM_ENTRIES_PER_PF	2 /** Ucast & Bcast */
-#define RSVD_MCAM_ENTRIES_PER_NIXLF	1 /** Ucast for VFs */
-#if 0
-static u64 npc_af_reg_read(struct npc_af *npc, u64 offset)
-{
-	return readq(npc->npc_af_base + offset);
-}
-
-static void npc_af_reg_write(struct npc_af *npc, u64 offset, u64 val)
-{
-	writeq(va, npc->npc_af_base + offset);
-}
-#endif
-static inline u64 enable_mask(int count)
-{
-	return ((count < 64) ? ~(BIT_ULL(count) - 1) : (0x00ULL));
-}
-
-
-#define LDATA_EXTRACT_CONFIG(intf, lid, ltype, ld, cfg) \
-	npc_af_reg_write(npc,			\
-		CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(intf, lid, ltype, ld), cfg)
-
-#define LDATA_FLAGS_CONFIG(intf, ld, flags, cfg)	\
-	npc_af_reg_write(npc,			\
-		CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(intf, ld, flags), cfg)
-
-static void npc_af_config_layer_info(struct npc_af *npc)
-{
-	union cavm_npc_af_const af_const;
-	union cavm_npc_af_intfx_lidx_ltx_ldx_cfg cfg;
-	int lid_count;
-	int lid, ltype;
-	struct npc_mcam *mcam = &npc->mcam;
-
-	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
-	lid_count = af_const.s.lids;
-
-	/* First clear any existing config i.e
-	 * disable LDATA and FLAGS extraction.
-	 */
-	for (lid = 0; lid < lid_count; lid++) {
-		for (ltype = 0; ltype < 16; ltype++) {
-			LDATA_EXTRACT_CONFIG(NIX_INTF_RX, lid, ltype, 0, 0ULL);
-			LDATA_EXTRACT_CONFIG(NIX_INTF_RX, lid, ltype, 1, 0ULL);
-			LDATA_EXTRACT_CONFIG(NIX_INTF_TX, lid, ltype, 0, 0ULL);
-			LDATA_EXTRACT_CONFIG(NIX_INTF_TX, lid, ltype, 1, 0ULL);
-
-			LDATA_FLAGS_CONFIG(NIX_INTF_RX, 0, ltype, 0ULL);
-			LDATA_FLAGS_CONFIG(NIX_INTF_RX, 1, ltype, 0ULL);
-			LDATA_FLAGS_CONFIG(NIX_INTF_TX, 0, ltype, 0ULL);
-			LDATA_FLAGS_CONFIG(NIX_INTF_TX, 1, ltype, 0ULL);
-		}
-	}
-
-	/* If we plan to extract Outer IPv4 tuple for TCP/UDP pkts
-	 * then 112bit key is not sufficient
-	 */
-	if (mcam->keysize != NPC_MCAM_KEY_X2)
-		return;
-
-	/* Start placing extracted data/flags from 64bit onwards, for now */
-	/* Extract DMAC from the packet */
-	cfg.u = 0;
-	cfg.s.bytesm1 = 0x05;
-	cfg.s.ena = 1;
-	cfg.s.key_offset = 0x8;
-	LDATA_EXTRACT_CONFIG(NIX_INTF_RX, CAVM_NPC_LID_E_LA, NPC_LT_LA_ETHER, 0, cfg.u);
-}
-
-static void npc_af_config_kpuaction(struct npc_af *npc,
-				    struct npc_kpu_profile_action *kpuaction,
-				    int kpu, int entry, bool pkind)
-{
-	u64 reg;
-	union cavm_npc_af_pkindx_action0 action0;
-	union cavm_npc_af_pkindx_action1 action1;
-
-	action0.u = 0;
-	action1.u = 0;
-	action1.s.errlev = kpuaction->errlev;
-	action1.s.errcode = kpuaction->errcode;
-	action1.s.dp0_offset = kpuaction->dp0_offset;
-	action1.s.dp1_offset = kpuaction->dp1_offset;
-	action1.s.dp2_offset = kpuaction->dp2_offset;
-
-	reg = pkind ? CAVM_NPC_AF_PKINDX_ACTION1(entry) :
-		      CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(kpu, entry);
-	npc_af_reg_write(npc, reg, action1.u);
-
-	action0.s.byp_count = kpuaction->bypass_count;
-	action0.s.capture_ena = kpuaction->cap_ena;
-	action0.s.parse_done = kpuaction->parse_done;
-	action0.s.next_state = kpuaction->next_state;
-	action0.s.capture_lid = kpuaction->lid;
-	action0.s.capture_ltype = kpuaction->ltype;
-	action0.s.capture_flags = kpuaction->flags;
-	action0.s.ptr_advance = kpuaction->ptr_advance;
-	action0.s.var_len_offset = kpuaction->offset;
-	action0.s.var_len_mask = kpuaction->mask;
-	action0.s.var_len_right = kpuaction->right;
-	action0.s.var_len_shift = kpuaction->shift;
-
-	reg = pkind ? CAVM_NPC_AF_PKINDX_ACTION0(entry) :
-		      CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(kpu, entry);
-	npc_af_reg_write(npc, reg, action0.u);
-}
-
-static void npc_af_config_kpucam(struct npc_af *npc,
-				 struct npc_kpu_profile_cam *kpucam,
-				 int kpu, int entry)
-{
-	union cavm_npc_af_kpux_entryx_camx cam0, cam1;
-
-	cam0.u = 0;
-	cam1.u = 0;
-	cam1.s.state = kpucam->state & kpucam->state_mask;
-	cam1.s.dp0_data = kpucam->dp0 & kpucam->dp0_mask;
-	cam1.s.dp1_data = kpucam->dp1 & kpucam->dp1_mask;
-	cam1.s.dp2_data = kpucam->dp2 & kpucam->dp2_mask;
-
-	cam0.s.state = ~kpucam->state & kpucam->state_mask;
-	cam0.s.dp0_data = ~kpucam->dp0 & kpucam->dp0_mask;
-	cam0.s.dp1_data = ~kpucam->dp1 & kpucam->dp1_mask;
-	cam0.s.dp2_data = ~kpucam->dp2 & kpucam->dp2_mask;
-
-	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 0),
-			 cam0.u);
-	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 1),
-			 cam1.u);
-}
-
-static void npc_af_program_kpu_profile(struct npc_af *npc, int kpu,
-				       struct npc_kpu_profile *profile)
-{
-	int entry, num_entries, max_entries;
-	union cavm_npc_af_const1 af_const1;
-	union cavm_npc_af_kpux_cfg kpu_cfg;
-
-	if (profile->cam_entries != profile->action_entries) {
-		printf("%s: KPU%d: CAM and action entries [%d != %d] not equal\n",
-		       __func__, kpu, profile->cam_entries,
-		       profile->action_entries);
-		return;
-	}
-
-	af_const1.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST1());
-	max_entries = af_const1.s.kpu_entries;
-
-	/* Program CAM match entries for previous KPU extracted data */
-	num_entries = min_t(int, profile->cam_entries, max_entries);
-	for (entry = 0; entry < num_entries; entry++)
-		npc_af_config_kpucam(npc, &profile->cam[entry], kpu, entry);
-
-	/* Program this KPU's actions */
-	num_entries = min_t(int, profile->action_entries, max_entries);
-	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(kpu, 0),
-			 enable_mask(num_entries));
-	if (num_entries > 64)
-		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(kpu, 1),
-				 enable_mask(num_entries - 64));
-
-	/* Enable this KPU */
-	kpu_cfg.u = npc_af_reg_read(CAVM_NPC_AF_KPUX_CFG(kpu));
-	kpu_cfg.s.ena = 1;
-	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_CFG(kpu), kpu_cfg.u);
-}
-
-static void npc_parser_profile_init(struct npc_af *npc)
-{
-	int num_pkinds, num_kpus, idx;
-	struct npc_pkind *pkind = &npc->pkind;
-	union cavm_npc_af_const af_const;
-
-	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
-	npc->npc_kpus = af_const.s.kpus;
-
-	/* Disable all KPUs and their entries */
-	for (idx = 0; idx < npc->npc_kpus; idx++) {
-		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(idx, 0),
-				 ~0ULL);
-		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(idx, 1),
-				 ~0ULL);
-		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_CFG(idx), 0);
-	}
-
-	/* First program IKPU profile (i.e. PKIND configs).
-	 * Check HW max count to avoid configuring junk or writing to
-	 * unsupported CSR addresses.
-	 */
-
-	num_pkinds = ARRAY_SIZE(ikpu_action_entries);
-	num_pkinds = min_t(int, pkind->rsrc.max, num_pkinds);
-
-	for (idx = 0; idx < num_pkinds; idx++)
-		npc_af_config_kpuaction(npc, &ikpu_action_entries[idx],
-					0, idx, true);
-	/* Program KPU CAM and Action profiles */
-	num_kpus = ARRAY_SIZE(npc_kpu_profiles);
-	num_kpus = min_t(int, npc->npc_kpus, num_kpus);
-
-	for (idx = 0; idx < num_kpus; idx++)
-		npc_af_program_kpu_profile(npc, idx, &npc_kpu_profiles[idx]);
-
-	npc_af_config_layer_info(npc);
-}
-
-static int npc_af_mcam_rsrcs_init(struct npc_af *npc)
-{
-	int err, rsvd;
-	struct npc_mcam *mcam = &npc->mcam;
-	union cavm_npc_af_const af_const;
-	union cavm_npc_af_intfx_kex_cfg kex_cfg;
-	struct nix_af_handle *nix = npc->nix_af;
-
-	/* Get HW limits */
-	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
-	mcam->banks = af_const.s.mcam_banks;
-	mcam->banksize = af_const.s.mcam_bank_depth;
-	mcam->counters = af_const.s.match_stats;
-
-	/* Actual number of MCAM entries vary by entry size */
-	kex_cfg.u = npc_af_reg_read(npc, CAVM_NPC_AF_INTFX_KEX_CFG(0));
-	mcam->total_entries = (mcam->banks / kex_cfg.s.keyw) * mcam->banksize;
-	mcam->keysize = kex_cfg.s.keyw;
-
-	/* Number of banks combined per MCAM entry */
-	switch (kex_cfg.s.keyw) {
-	case CAVM_NPC_MCAMKEYW_E_X4:
-		mcam->banks_per_entry = 4;
-		break;
-	case CAVM_NPC_MCAMKEYW_E_X2:
-		mcam->banks_per_entry = 2;
-		break;
-	default:
-		mcam->banks_per_entry = 1;
-		break;
-	}
-
-	/* Reserve one MCAM entry for each of the NIX LFs to guarantee space
-	 * to install default matching DMAC rule.  Also reserve 2 MCAM entries
-	 * for each PF for default channel based matchingor 'ucast & bcast'
-	 * matching to support UCAST and PROMISC modes of operation for PFs.
-	 * PF0 is excluded.
-	 */
-	rsvd = (npc->block.rsrc.max * RSVD_MCAM_ENTRIES_PER_NIXLF) +
-		((npc->hw->total_pfs - 1) * RSVD_MCAM_ENTRIES_PER_PF);
-	if (mcam->total_entries <= rsvd) {
-		printf("%s: Insufficient NPC MCAM size %d for pkt I/O, exiting\n",
-		       __func__);
-		return -ENOMEM;
-	}
-	mcam->entries = mcam->total_entries - rsvd;
-	mcam->nixlf_offset = mcam->entries;
-	mcam->pf_offset = mcam->nixlf_offset + nix->rsrc.max;
-
-	/* Allocate bitmap for this resource and memory for MCAM entry to
-	 * RVU PFFUNC allocation mapping info.
-	 */
-	mcam->rsrc.max = mcam->entries;
-	err = rvu_alloc_bitmap(&mcam->rsrc);
-	if (err)
-		return err;
-	mcam->pfvf_map = calloc(mcam->rsrc.max, sizeof(u16));
-	if (!mcam->pfvf_map)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int npc_af_init(struct npc_af *npc)
-{
-	int err;
-	u64 keyz = NPC_MCAM_KEY_X2;
-	struct npc_pkind *pkind = &npc->pkind;
-	union cavm_npc_af_const1 af_const1;
-	union cavm_npc_af_pck_def_ol2 pck_ol2;
-	union cavm_nixx_af_rx_def_ol2 rx_def_ol2;
-	union cavm_nixx_af_rx_def_oudp rx_oudp;
-	union cavm_nixx_af_rx_def_otcp rx_otcp;
-	union cavm_nixx_af_rx_def_oip4 rx_oip4;
-	union cavm_npc_af_pck_def_oip4 pck_oip4;
-	union cavm_npc_af_pck_cfg pck_cfg;
-	union cavm_npc_af_intfx_kex_cfg key_cfg;
-
-	af_const1.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST1());
-	pkind->rsrc.max = af_const1.s.pkinds;
-
-	err = rvu_alloc_bitmap(&pkind->rsrc);
-	if (err)
-		return err;
-
-	pkind->pfchan_map = calloc(pkind->rsrc.max, sizeof(u32));
-	if (!pkind->pfchan_map)
-		return -ENOMEM;
-
-	/* Configure KPU profile */
-	npc_parser_profile_init(npc);
-
-	/* Config outer L2, IP, TCP and UDP's NPC layer info */
-	pck_ol2.u = 0;
-	pck_ol2.s.lid = CAVM_NPC_LID_E_LA;
-	pck_ol2.s.ltype_match = NPC_LT_LA_ETHER;
-	pck_ol2.s.ltype_mask = 0x0f;
-	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_DEF_OL2(), pck_ol2.u);
-	rx_def_ol2.u = 0;
-	rx_def_ol2.s.lid = CAVM_NPC_LID_E_LA;
-	rx_def_ol2.s.ltype_match = NPC_LT_LA_ETHER;
-	rx_def_ol2.s.ltype_mask = 0x0f;
-	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OL2(), rx_def_ol2.u);
-	rx_oudp.u = 0;
-	rx_oudp.s.lid = CAVM_NPC_LID_E_LD;
-	rx_oudp.s.ltype_match = NPC_LT_LD_UDP;
-	rx_oudp.s.ltype_mask = 0x0f;
-	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OUDP(), rx_oudp.u);
-	rx_otcp.s.lid = CAVM_NPC_LID_E_LD;
-	rx_otcp.s.ltype_match = NPC_LT_LD_TCP;
-	rx_otcp.s.ltype_mask = 0x0f;
-	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OTCP(), rx_otcp.u);
-	rx_oip4.u = 0;
-	rx_oip4.s.lid = CAVM_NPC_LID_E_LC;
-	rx_oip4.s.ltype_match = NPC_LT_LC_IP;
-	rx_oip4.s.ltype_mask = 0x0f;
-	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OIP4(), rx_oip4.u);
-	pck_oip4.u = 0;
-	pck_oip4.s.lid = CAVM_NPC_LID_E_LC;
-	pck_oip4.s.ltype_match = NPC_LT_LC_IP;
-	pck_oip4.s.ltype_mask = 0x0f;
-	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_DEF_OIP4(), pck_oip4.u);
-
-	/* Enable below for Rx packets
-	 * - IPv4 header checksum validation
-	 * - Detect outer L2 broadcast addresses/
-	 */
-	pck_cfg.u = npc_af_reg_read(npc, CAVM_NPC_AF_PCK_CFG());
-	pck_cfg.s.oip4_cksum = 1;
-	pck_cfg.s.l2b = 1;
-	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_CFG(), pck_cfg.u)
-
-	/* Set RX and TX side MCAM search key size.
-	 * Also enable parse key extract nibles such that execpt layer E to H,
-	 * rest of the key is included for MCAM search.
-	 * Layer E-H is excluded since all KPUs are not yet in use.
-	 */
-	key_cfg.u = 0;
-	key_cfg.s.keyw = keyz & 0x3;
-	key_cfg.s.parse_nibble_ena = (1 << 20) - 1;
-	npc_af_reg_write(npc,
-		      CAVM_NPC_AF_INTFX_KEY_CFG(CAVM_NPC_INTF_E_NIXX_RX(0)), key_cfg.u);
-	key_cfg.u = 0;
-	key_cfg.s.keyw = keyz & 0x3;
-	key_cfg.s.parse_nibble_ena = (1 << 20) - 1;
-	npc_af_reg_write(npc,
-		      CAVM_NPC_AF_INTFX_KEY_CFG(CAVM_NPC_INTF_E_NIXX_TX(0)),
-		      key_cfg.u);
-
-	/* Set TX miss action to UCAST_DEFAULT, i.e. transmit the packet on
-	 * NIX LF SQ's default channel
-	 */
-	npc_af_reg_write(npc,
-		      CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_TX(0)),
-		      CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT);
-
-	/* If MCAM lookup doesn't result in a match, drop the received packet */
-	npc_af_reg_write(npc,
-		      CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
-		      CAVM_NIX_RX_ACTIONOP_E_DROP);
-
-	err = npc_mcam_rsrcs_init(npc);
-
-	return err;
-}
diff --git a/drivers/net/octeontx2/npc.h b/drivers/net/octeontx2/npc.h
index 112ef03f2e..30dca18b1f 100644
--- a/drivers/net/octeontx2/npc.h
+++ b/drivers/net/octeontx2/npc.h
@@ -1,11 +1,10 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef __NPC_H__
 #define __NPC_H__
 
diff --git a/drivers/net/octeontx2/npc_profile.h b/drivers/net/octeontx2/npc_profile.h
deleted file mode 100644
index 4f521fb2c7..0000000000
--- a/drivers/net/octeontx2/npc_profile.h
+++ /dev/null
@@ -1,3354 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-#ifndef NPC_PROFILE_H
-#define NPC_PROFILE_H
-
-#define NPC_ETYPE_IP		0x0800
-#define NPC_ETYPE_IP6		0x86dd
-#define NPC_ETYPE_ARP		0x0806
-#define NPC_ETYPE_RARP		0x8035
-#define NPC_ETYPE_MPLSU		0x8847
-#define NPC_ETYPE_MPLSM		0x8848
-#define NPC_ETYPE_ETAG		0x893f
-#define NPC_ETYPE_CTAG		0x8100
-#define NPC_ETYPE_SBTAG		0x88a8
-#define NPC_ETYPE_ITAG		0X88e7
-#define NPC_ETYPE_QINQ		0x9100
-#define NPC_ETYPE_TRANS_ETH_BR	0x6558
-#define NPC_ETYPE_PPP		0x880b
-
-#define NPC_IPNH_HOP		0
-#define NPC_IPNH_ICMP		1
-#define NPC_IPNH_IGMP		2
-#define NPC_IPNH_IP		4
-#define NPC_IPNH_TCP		6
-#define NPC_IPNH_UDP		17
-#define NPC_IPNH_IP6		41
-#define NPC_IPNH_ROUT		43
-#define NPC_IPNH_FRAG		44
-#define NPC_IPNH_GRE		47
-#define NPC_IPNH_ESP		50
-#define NPC_IPNH_AH		51
-#define NPC_IPNH_ICMP6		58
-#define NPC_IPNH_NONH		59
-#define NPC_IPNH_DEST		60
-#define NPC_IPNH_SCTP		132
-
-#define NPC_UDP_PORT_GTPC	2123
-#define NPC_UDP_PORT_GTPU	2152
-#define NPC_UDP_PORT_VXLAN	4789
-#define NPC_UDP_PORT_GENEVE	6081
-
-#define NPC_TCP_PORT_HTTP	80
-#define NPC_TCP_PORT_HTTPS	443
-
-#define NPC_IP_VER_4		0x4000
-#define NPC_IP_VER_6		0x6000
-#define NPC_IP_VER_MASK		0xf000
-#define NPC_IP_HDR_LEN_5	0x0500
-#define NPC_IP_HDR_LEN_MASK	0x0f00
-
-#define NPC_GRE_F_CSUM		(0x1 << 15)
-#define NPC_GRE_F_ROUTE		(0x1 << 14)
-#define NPC_GRE_F_KEY		(0x1 << 13)
-#define NPC_GRE_F_SEQ		(0x1 << 12)
-#define NPC_GRE_F_ACK		(0x1 << 7)
-#define NPC_GRE_FLAG_MASK	(NPC_GRE_F_CSUM | NPC_GRE_F_ROUTE | \
-				 NPC_GRE_F_KEYNPC_GRE_F_SEQNPC_GRE_F_ACK)
-#define NPC_GRE_VER_MASK	0x0003
-#define NPC_GRE_VER_1		0x0001
-
-#define NPC_VXLAN_I		0x0800
-
-#define NPC_GENEVE_F_OAM	(0x1 << 7)
-#define NPC_GENEVE_F_CRI_OPT	(0x1 << 6)
-#define NPC_GTP_PT_GTP		(0x1 << 12)
-#define NPC_GTP_PT_MASK		(0x1 << 12)
-#define NPC_GTP_VER1		(0x1 << 13)
-#define NPC_GTP_VER_MASK	(0x7 << 13)
-#define NPC_GTP_MT_G_PDU	0xff
-#define NPC_GTP_MT_MASK		0xff
-
-#define NPC_TCP_DATA_OFFSET_5		0x5000
-#define NPC_TCP_DATA_OFFSET_MASK	0xf000
-
-enum NPC_ERRLEV_E {
-	NPC_ERRLEV_RE = 0,
-	NPC_ERRLEV_LA = 1,
-	NPC_ERRLEV_LB = 2,
-	NPC_ERRLEV_LC = 3,
-	NPC_ERRLEV_LD = 4,
-	NPC_ERRLEV_LE = 5,
-	NPC_ERRLEV_LF = 6,
-	NPC_ERRLEV_LG = 7,
-	NPC_ERRLEV_LH = 8,
-	NPC_ERRLEV_NIX = 15,
-	NPC_ERRLEV_ENUM_LAST = 16,
-};
-
-enum npc_kpu_err_code {
-	NPC_EC_NOERR = 0, /* has to be zero */
-	NPC_EC_UNK,
-	NPC_EC_L2_K1,
-	NPC_EC_L2_K2,
-	NPC_EC_L2_K3,
-	NPC_EC_L2_K3_ETYPE_UNK,
-	NPC_EC_IP_VER,
-	NPC_EC_IP6_VER,
-	NPC_EC_VXLAN,
-	NPC_EC_NVGRE,
-	NPC_EC_GRE,
-	NPC_EC_GRE_VER1,
-	NPC_EC_L4,
-	NPC_EC_LAST /* has to be the last item */
-};
-
-enum npc_kpu_parser_state {
-	NPC_S_NA = 0,
-	NPC_S_KPU1_ETHER,
-	NPC_S_KPU1_PKI,
-	NPC_S_KPU2_CTAG,
-	NPC_S_KPU2_SBTAG,
-	NPC_S_KPU2_QINQ,
-	NPC_S_KPU2_ETAG,
-	NPC_S_KPU3_CTAG,
-	NPC_S_KPU3_STAG,
-	NPC_S_KPU3_QINQ,
-	NPC_S_KPU4_MPLS,
-	NPC_S_KPU5_IP,
-	NPC_S_KPU5_IP6,
-	NPC_S_KPU5_ARP,
-	NPC_S_KPU5_RARP,
-	NPC_S_KPU6_IP6_EXT,
-	NPC_S_KPU7_IP6_EXT,
-	NPC_S_KPU8_TCP,
-	NPC_S_KPU8_UDP,
-	NPC_S_KPU8_SCTP,
-	NPC_S_KPU8_ICMP,
-	NPC_S_KPU8_IGMP,
-	NPC_S_KPU8_ICMP6,
-	NPC_S_KPU8_GRE,
-	NPC_S_KPU8_ESP,
-	NPC_S_KPU8_AH,
-	NPC_S_KPU9_TU_ETHER,
-	NPC_S_KPU9_TU_PPP,
-	NPC_S_KPU11_TU_IP,
-	NPC_S_KPU11_TU_IP6,
-	NPC_S_KPU11_TU_ARP,
-	NPC_S_KPU12_TU_IP6_EXT,
-	NPC_S_KPU13_TU_IP6_EXT,
-	NPC_S_KPU14_TU_TCP,
-	NPC_S_KPU14_TU_UDP,
-	NPC_S_KPU14_TU_SCTP,
-	NPC_S_KPU14_TU_ICMP,
-	NPC_S_KPU14_TU_IGMP,
-	NPC_S_KPU14_TU_ICMP6,
-	NPC_S_KPU14_TU_ESP,
-	NPC_S_KPU14_TU_AH,
-	NPC_S_KPU15_HTTP_DATA,
-	NPC_S_KPU15_HTTPS_DATA,
-	NPC_S_KPU15_TCP_DATA,
-	NPC_S_KPU15_UDP_DATA,
-	NPC_S_LAST /* has to be the last item */
-};
-
-enum npc_kpu_parser_flag {
-	NPC_F_NA = 0,
-	NPC_F_HAS_PKI,
-	NPC_F_HAS_PKI_HAS_VLAN,
-	NPC_F_HAS_PKI_HAS_ETAG,
-	NPC_F_HAS_PKI_HAS_MPLS,
-	NPC_F_ETYPE_UNK,
-	NPC_F_ETHER_HAS_VLAN,
-	NPC_F_ETHER_HAS_ETAG,
-	NPC_F_ETHER_HAS_MPLS,
-	NPC_F_VLAN_2_TAGS,
-	NPC_F_VLAN_2_TAGS_ETYPE_UNK,
-	NPC_F_VLAN_3_TAGS,
-	NPC_F_VLAN_4_TAGS,
-	NPC_F_QINQ_DBL,
-	NPC_F_BTAG_HAS_CTAG,
-	NPC_F_IP_HAS_OPTIONS,
-	NPC_F_IP_IN_IP,
-	NPC_F_IP_6TO4,
-	NPC_F_IP_UNK_PROTO,
-	NPC_F_IP_IN_IP_HAS_OPTIONS,
-	NPC_F_IP_6TO4_HAS_OPTIONS,
-	NPC_F_IP_UNK_PROTO_HAS_OPTIONS,
-	NPC_F_IP6_HAS_EXT,
-	NPC_F_IP6_TUN_IP6,
-	NPC_F_TCP_HAS_OPTIONS,
-	NPC_F_TCP_HTTP,
-	NPC_F_TCP_HTTPS,
-	NPC_F_TCP_UNK_PORT,
-	NPC_F_TCP_HTTP_HAS_OPTIONS,
-	NPC_F_TCP_HTTPS_HAS_OPTIONS,
-	NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
-	NPC_F_UDP_VXLAN_NOVNI,
-	NPC_F_UDP_GTPU_G_PDU,
-	NPC_F_UDP_GTPU_UNK,
-	NPC_F_UDP_UNK_PORT,
-	NPC_F_UDP_GENEVE_OAM,
-	NPC_F_UDP_GENEVE_CRI_OPT,
-	NPC_F_UDP_GENEVE_OAM_CRI_OPT,
-	NPC_F_GRE_HAS_SRE,
-	NPC_F_GRE_HAS_CSUM,
-	NPC_F_GRE_HAS_KEY,
-	NPC_F_GRE_HAS_SEQ,
-	NPC_F_GRE_HAS_CSUM_KEY,
-	NPC_F_GRE_HAS_CSUM_SEQ,
-	NPC_F_GRE_HAS_KEY_SEQ,
-	NPC_F_GRE_HAS_CSUM_KEY_SEQ,
-	NPC_F_GRE_HAS_ROUTE,
-	NPC_F_GRE_UNK_PROTO,
-	NPC_F_GRE_VER1,
-	NPC_F_GRE_VER1_HAS_SEQ,
-	NPC_F_GRE_VER1_HAS_ACK,
-	NPC_F_GRE_VER1_HAS_SEQ_ACK,
-	NPC_F_GRE_VER1_UNK_PROTO,
-	NPC_F_TU_ETHER_ETYPE_UNK,
-	NPC_F_TU_ETHER_HAS_CTAG,
-	NPC_F_TU_ETHER_HAS_CTAG_ETYPE_UNK,
-	NPC_F_TU_ETHER_HAS_STAG_CTAG,
-	NPC_F_TU_ETHER_HAS_STAG_CTAG_ETYPE_UNK,
-	NPC_F_TU_ETHER_HAS_STAG_ETYPE_UNK,
-	NPC_F_TU_ETHER_HAS_QINQ_CTAG,
-	NPC_F_TU_ETHER_HAS_QINQ_CTAG_ETYPE_UNK,
-	NPC_F_TU_ETHER_HAS_QINQ_ETYPE_UNK,
-	NPC_F_LAST /* has to be the last item */
-};
-
-struct npc_kpu_profile_action ikpu_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
-		0, 0, NPC_S_KPU1_ETHER, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 1, 0xff,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_cam kpu1_cam_entries[] = {
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_SBTAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_QINQ, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_ETAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, 0x0000, 0xfc00, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, 0x0400, 0xfe00, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_ETHER, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_SBTAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_QINQ, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_ETAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0010,
-		0x0010, 0x0000, 0xffff,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0010,
-		0x0010, 0x0000, 0xffff,
-	},
-	{
-		NPC_S_KPU1_PKI, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu2_cam_entries[] = {
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_CTAG, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_MPLSU,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_MPLSM,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
-		NPC_ETYPE_CTAG, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
-		NPC_ETYPE_SBTAG, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, NPC_ETYPE_ARP, 0xffff,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, NPC_ETYPE_RARP, 0xffff,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, NPC_ETYPE_CTAG, 0xffff,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_SBTAG, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_IP, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_IP6, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_ARP, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_RARP, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_MPLSU, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		NPC_ETYPE_MPLSM, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_QINQ, 0xffff,
-		NPC_ETYPE_CTAG, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_QINQ, 0xffff,
-		NPC_ETYPE_QINQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_IP, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_IP6, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_ARP, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_RARP, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_CTAG, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_QINQ, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU2_ETAG, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu3_cam_entries[] = {
-	{
-		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_CTAG, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_STAG, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU3_QINQ, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu4_cam_entries[] = {
-	{
-		NPC_S_KPU4_MPLS, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu5_cam_entries[] = {
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_TCP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_UDP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_SCTP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ICMP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IGMP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ESP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_AH, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_GRE, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP6, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_TCP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_UDP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_SCTP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ICMP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IGMP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ESP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_AH, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_GRE, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP6, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_ARP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_RARP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_TCP << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_UDP << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_SCTP << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ICMP << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ICMP6 << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ESP << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_AH << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_GRE << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_IP6 << 8, 0xff00, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, 0x0000, 0x0000, NPC_IP_VER_6,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU5_IP6, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu6_cam_entries[] = {
-	{
-		NPC_S_KPU6_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu7_cam_entries[] = {
-	{
-		NPC_S_KPU7_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu8_cam_entries[] = {
-	{
-		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTP,
-		0xffff, NPC_TCP_DATA_OFFSET_5,
-		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTPS,
-		0xffff, NPC_TCP_DATA_OFFSET_5,
-		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_TCP, 0xff, 0x0000, 0x0000, NPC_TCP_DATA_OFFSET_5,
-		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_TCP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, NPC_VXLAN_I,
-		NPC_VXLAN_I, 0x0000, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, 0x0000,
-		0xffff, 0x0000, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		0x0000, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		0x0000, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff, 0x0000,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
-		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPC, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPU, 0xffff,
-		NPC_GTP_PT_GTP | NPC_GTP_VER1 | NPC_GTP_MT_G_PDU,
-		NPC_GTP_PT_MASK | NPC_GTP_VER_MASK | NPC_GTP_MT_MASK,
-		0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPU, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_UDP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_SCTP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_ICMP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_IGMP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_ICMP6, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_ESP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_AH, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_TRANS_ETH_BR, 0xffff,
-		0x0000, 0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		0x0000, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_CSUM, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_KEY | NPC_GRE_F_SEQ,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		0x0000, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_CSUM, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
-		NPC_GRE_F_CSUM | NPC_GRE_F_KEY | NPC_GRE_F_SEQ,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, NPC_GRE_F_ROUTE,
-		0x4fff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0000,
-		0x4fff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0000,
-		0x0003, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_VER_1, 0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_F_SEQ | NPC_GRE_VER_1,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_F_ACK | NPC_GRE_VER_1,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
-		NPC_GRE_F_KEY | NPC_GRE_F_SEQ | NPC_GRE_F_ACK | NPC_GRE_VER_1,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x2001,
-		0xef7f, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0001,
-		0x0003, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu9_cam_entries[] = {
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_IP,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_IP6,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_ARP,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP6,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_ARP,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_ARP, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_IP6, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, NPC_ETYPE_ARP, 0xffff,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
-		0xffff, NPC_ETYPE_CTAG,
-		0xffff, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
-		0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_ETHER, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU9_TU_PPP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu10_cam_entries[] = {
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu11_cam_entries[] = {
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_TCP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_UDP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_SCTP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ICMP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_IGMP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ESP, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_AH, 0x00ff,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000,
-		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
-		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_TCP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_UDP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_SCTP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ICMP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_IGMP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ESP, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_AH, 0x00ff, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000, NPC_IP_VER_4,
-		NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_ARP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_TCP << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_UDP << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_SCTP << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ICMP << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ICMP6 << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ESP << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_AH << 8, 0xff00,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, 0x0000, 0x0000,
-		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU11_TU_IP6, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu12_cam_entries[] = {
-	{
-		NPC_S_KPU12_TU_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu13_cam_entries[] = {
-	{
-		NPC_S_KPU13_TU_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu14_cam_entries[] = {
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff,
-		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff,
-		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, 0x0000, 0x0000,
-		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_TCP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_UDP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_SCTP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_ICMP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_IGMP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_ICMP6, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_ESP, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU14_TU_AH, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_cam kpu15_cam_entries[] = {
-	{
-		NPC_S_KPU15_TCP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU15_HTTP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU15_HTTPS_DATA, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-	{
-		NPC_S_KPU15_UDP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000,
-	},
-};
-
-struct npc_kpu_profile_action kpu1_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		3, 0, NPC_S_KPU5_IP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		3, 0, NPC_S_KPU5_IP6, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		3, 0, NPC_S_KPU5_ARP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		3, 0, NPC_S_KPU5_RARP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU2_CTAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 20,
-		0, 0, NPC_S_KPU2_SBTAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU2_QINQ, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		0, 0, NPC_S_KPU2_ETAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_ETAG, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_MPLS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_MPLS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LA, NPC_LT_LA_8023, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LA, NPC_LT_LA_8023, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		3, 0, NPC_S_KPU5_IP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		3, 0, NPC_S_KPU5_IP6, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		3, 0, NPC_S_KPU5_ARP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		3, 0, NPC_S_KPU5_RARP, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU2_CTAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 20,
-		0, 0, NPC_S_KPU2_SBTAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU2_QINQ, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		0, 0, NPC_S_KPU2_ETAG, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_ETAG, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_MPLS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 14, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_MPLS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LA, NPC_EC_L2_K1, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu2_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU5_IP, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU5_IP6, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_ARP, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_RARP, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_CTAG, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU5_IP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU5_IP6, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_ARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_RARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_CTAG, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_3_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_STAG, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_4_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU5_IP, 22, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU5_IP6, 22, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_ARP, 22, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_RARP, 22, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU3_CTAG, 22, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_BTAG_HAS_CTAG, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU5_IP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU5_IP6, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_ARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_RARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU4_MPLS, 4, 1,
-		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_CTAG, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_3_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_QINQ, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_4_TAGS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU5_IP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU5_IP6, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_ARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU5_RARP, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_CTAG, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG_CTAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_STAG, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG_STAG, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
-		0, 0, NPC_S_KPU3_QINQ, 8, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG_QINQ, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LB, NPC_LT_LB_ETAG, NPC_F_ETYPE_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LB, NPC_EC_L2_K2, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu3_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU5_IP, 4, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU5_IP6, 4, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_ARP, 4, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_RARP, 4, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU5_IP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU5_IP6, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_ARP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_RARP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU5_IP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU5_IP6, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_ARP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU5_RARP, 8, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LB, NPC_EC_L2_K3, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu4_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		0, 0, NPC_S_KPU5_IP, 4, 0,
-		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu5_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU8_TCP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
-		2, 0, NPC_S_KPU8_UDP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_SCTP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_ICMP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_IGMP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU8_ESP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU8_AH, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		2, 0, NPC_S_KPU8_GRE, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		5, 0, NPC_S_KPU11_TU_IP, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_IN_IP, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		5, 0, NPC_S_KPU11_TU_IP6, 20, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_6TO4, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_UNK_PROTO, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU8_TCP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
-		2, 0, NPC_S_KPU8_UDP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_SCTP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_ICMP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_IGMP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU8_ESP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU8_AH, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		2, 0, NPC_S_KPU8_GRE, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		5, 0, NPC_S_KPU11_TU_IP, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_IN_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		5, 0, NPC_S_KPU11_TU_IP6, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_6TO4_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_UNK_PROTO_HAS_OPTIONS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LC, NPC_EC_IP_VER, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_ARP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_RARP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU8_TCP, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
-		2, 0, NPC_S_KPU8_UDP, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_SCTP, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_ICMP, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_ICMP6, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_ESP, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_AH, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU8_GRE, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		5, 0, NPC_S_KPU11_TU_IP6, 40, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, NPC_F_IP6_TUN_IP6, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU6_IP6_EXT, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, NPC_F_IP6_HAS_EXT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LC, NPC_EC_IP6_VER, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LC, NPC_EC_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu6_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu7_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu8_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_HTTP_DATA, 20, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTP, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_HTTPS_DATA, 20, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTPS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_TCP_DATA, 20, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_UNK_PORT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_HTTP_DATA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTP_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_HTTPS_DATA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTPS_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_TCP_DATA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_VXLAN, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_VXLAN, NPC_F_UDP_VXLAN_NOVNI,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_LD, NPC_EC_VXLAN, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
-		8, 0x3f, 0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GTPC, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GTPU, NPC_F_UDP_GTPU_G_PDU, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP_GTPU, NPC_F_UDP_GTPU_UNK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		6, 0, NPC_S_KPU15_UDP_DATA, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_UDP, NPC_F_UDP_UNK_PORT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_SCTP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_ICMP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_IGMP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_ICMP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_ESP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_AH, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
-		0, 0, NPC_S_KPU9_TU_ETHER, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_NVGRE, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LD, NPC_EC_NVGRE, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 4, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 4, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_ROUTE, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_UNK_PROTO, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LD, NPC_EC_GRE, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU9_TU_PPP, 8, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU9_TU_PPP, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_SEQ, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU9_TU_PPP, 12, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_ACK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU9_TU_PPP, 16, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_SEQ_ACK, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_UNK_PROTO, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LD, NPC_EC_GRE_VER1, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LD, NPC_EC_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu9_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP, 14, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP6, 14, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU11_TU_ARP, 14, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP, 18, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP6, 18, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU11_TU_ARP, 18, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_CTAG_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP6, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU11_TU_ARP, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_STAG_CTAG_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_STAG_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
-		1, 0, NPC_S_KPU11_TU_IP6, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		1, 0, NPC_S_KPU11_TU_ARP, 22, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_QINQ_CTAG_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_HAS_QINQ_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
-		NPC_F_TU_ETHER_ETYPE_UNK, 0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LE, NPC_LT_LE_TU_PPP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LE, NPC_EC_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LE, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu10_action_entries[] = {
-	{
-		NPC_ERRLEV_LE, NPC_EC_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LE, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu11_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU14_TU_TCP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		2, 0, NPC_S_KPU14_TU_UDP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_SCTP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ICMP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_IGMP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ESP, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_AH, 20, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_UNK_PROTO, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU14_TU_TCP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		2, 0, NPC_S_KPU14_TU_UDP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_SCTP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ICMP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_IGMP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ESP, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_AH, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
-		0, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_UNK_PROTO_HAS_OPTIONS,
-		0, 0, 0, 0,
-	},
-	{
-		NPC_ERRLEV_LF, NPC_EC_IP_VER, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_ARP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
-		2, 0, NPC_S_KPU14_TU_TCP, 40, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		2, 0, NPC_S_KPU14_TU_UDP, 40, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_SCTP, 40, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ICMP, 40, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ICMP6, 40, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_ESP, 40, 1,
-		NPC_LID_LC, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		2, 0, NPC_S_KPU14_TU_AH, 40, 1,
-		NPC_LID_LC, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
-		0, 0, NPC_S_KPU12_TU_IP6_EXT, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, NPC_F_IP6_HAS_EXT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LF, NPC_EC_IP6_VER, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LF, NPC_EC_UNK, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LF, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu12_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu13_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu14_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_HTTP_DATA, 20, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTP, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_HTTPS_DATA, 20, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTPS, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_TCP_DATA, 20, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_UNK_PORT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_HTTP_DATA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTP_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_HTTPS_DATA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTPS_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_TCP_DATA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
-		12, 0xf0, 1, 2,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 0, NPC_S_KPU15_UDP_DATA, 8, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_UDP, NPC_F_UDP_UNK_PORT, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_SCTP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_ICMP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_IGMP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_ICMP6, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_ESP, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LG, NPC_LT_LG_TU_AH, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_LG, NPC_EC_L4, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 0,
-		NPC_LID_LG, NPC_LT_NA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile_action kpu15_action_entries[] = {
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LH, NPC_LT_LH_TCP_DATA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LH, NPC_LT_LH_HTTP_DATA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LH, NPC_LT_LH_HTTPS_DATA, 0, 0, 0,
-		0, 0,
-	},
-	{
-		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
-		0, 1, NPC_S_NA, 0, 1,
-		NPC_LID_LH, NPC_LT_LH_UDP_DATA, 0, 0, 0,
-		0, 0,
-	},
-};
-
-struct npc_kpu_profile npc_kpu_profiles[] = {
-	{
-		ARRAY_SIZE(kpu1_cam_entries),
-		ARRAY_SIZE(kpu1_action_entries),
-		&kpu1_cam_entries[0],
-		&kpu1_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu2_cam_entries),
-		ARRAY_SIZE(kpu2_action_entries),
-		&kpu2_cam_entries[0],
-		&kpu2_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu3_cam_entries),
-		ARRAY_SIZE(kpu3_action_entries),
-		&kpu3_cam_entries[0],
-		&kpu3_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu4_cam_entries),
-		ARRAY_SIZE(kpu4_action_entries),
-		&kpu4_cam_entries[0],
-		&kpu4_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu5_cam_entries),
-		ARRAY_SIZE(kpu5_action_entries),
-		&kpu5_cam_entries[0],
-		&kpu5_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu6_cam_entries),
-		ARRAY_SIZE(kpu6_action_entries),
-		&kpu6_cam_entries[0],
-		&kpu6_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu7_cam_entries),
-		ARRAY_SIZE(kpu7_action_entries),
-		&kpu7_cam_entries[0],
-		&kpu7_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu8_cam_entries),
-		ARRAY_SIZE(kpu8_action_entries),
-		&kpu8_cam_entries[0],
-		&kpu8_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu9_cam_entries),
-		ARRAY_SIZE(kpu9_action_entries),
-		&kpu9_cam_entries[0],
-		&kpu9_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu10_cam_entries),
-		ARRAY_SIZE(kpu10_action_entries),
-		&kpu10_cam_entries[0],
-		&kpu10_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu11_cam_entries),
-		ARRAY_SIZE(kpu11_action_entries),
-		&kpu11_cam_entries[0],
-		&kpu11_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu12_cam_entries),
-		ARRAY_SIZE(kpu12_action_entries),
-		&kpu12_cam_entries[0],
-		&kpu12_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu13_cam_entries),
-		ARRAY_SIZE(kpu13_action_entries),
-		&kpu13_cam_entries[0],
-		&kpu13_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu14_cam_entries),
-		ARRAY_SIZE(kpu14_action_entries),
-		&kpu14_cam_entries[0],
-		&kpu14_action_entries[0],
-	},
-	{
-		ARRAY_SIZE(kpu15_cam_entries),
-		ARRAY_SIZE(kpu15_action_entries),
-		&kpu15_cam_entries[0],
-		&kpu15_action_entries[0],
-	},
-};
-
-#endif /* NPC_PROFILE_H */
diff --git a/drivers/net/octeontx2/npc_reg.h b/drivers/net/octeontx2/npc_reg.h
deleted file mode 100644
index 4f3e993570..0000000000
--- a/drivers/net/octeontx2/npc_reg.h
+++ /dev/null
@@ -1,639 +0,0 @@
-/*
- * Copyright (C) 2018 Marvell International Ltd.
- *
- * SPDX-License-Identifier:    GPL-2.0
- * https://spdx.org/licenses
- */
-
-
-/* Register definitions */
-
-/**
- * NPC AF General Configuration Register
- */
-union cavm_npc_af_cfg {
-	u64 u;
-	struct npc_af_cfg_s {
-		u64 rsvd_1_0:           2;
-		u64 cclk_force:         1;
-		u64 force_intf_clk_en:  1;
-		u64 rsvd_63_4:          60;
-	} s;
-};
-
-/**
- * NPC Interrupt-Timer Configuration Register
- */
-union cavm_npc_af_active_pc {
-	u64 u;
-	struct npc_af_active_pc_s {
-		u64 active_pc;                      
-	} s;
-};
-
-/**
- * NPC AF Constants Register
- * This register contains constants for software discovery.
- */
-union cavm_npc_af_const {
-	u64 u;
-	struct npc_af_const_s {
-		u64 intfs:              4;
-		u64 lids:               4;
-		u64 kpus:               5;
-		u64 rsvd_15_13:         3;
-		u64 mcam_bank_width:    10;
-		u64 rsvd_27_26:         2;
-		u64 mcam_bank_depth:    16;
-		u64 mcam_banks:         4;
-		u64 match_stats:        16;
-	} s;
-};
-
-/**
- * NPC AF Constants 1 Register
- * This register contains constants for software discovery.
- */
-union cavm_npc_af_const1 {
-	u64 u;
-	struct npc_af_const1_s {
-		u64 kpu_entries:        12;
-		u64 pkinds:             8;
-		u64 cpi_size:           16;
-		u64 rsvd_63_36:         28;
-	} s;
-};
-
-/**
- * NPC AF MCAM Scrub Control Register
- */
-union cavm_npc_af_mcam_scrub_ctl {
-	u64 u;
-	struct npc_af_mcam_scrub_ctl_s {
-		u64 ena:        1;
-		u64 rsvd_7_1:   7;
-		u64 lp_dis:     1;
-		u64 rsvd_15_9:  7;
-		u64 toth:       4;
-		u64 rsvd_63_20: 44;
-	} s;
-};
-
-/**
- * NPC AF KPU Configuration Registers
- */
-union cavm_npc_af_kpux_cfg {
-	u64 u;
-	struct npc_af_kpux_cfg_s {
-		u64 ena:        1;
-		u64 rsvd_63_1:  63;
-	} s;
-};
-
-/**
- * NPC AF Protocol Check Configuration Register
- */
-union cavm_npc_af_pck_cfg {
-	u64 u;
-	struct npc_af_pck_cfg_s {
-		u64 rsvd_0:             1;
-		u64 iip4_cksum:         1;
-		u64 oip4_cksum:         1;
-		u64 rsvd_3:             1;
-		u64 l3b:                1;
-		u64 l3m:                1;
-		u64 l2b:                1;
-		u64 l2m:                1;
-		u64 rsvd_23_8:          16;
-		u64 iip4_cksum_errcode: 8;
-		u64 oip4_cksum_errcode: 8;
-		u64 rsvd_63_40:         24;
-	} s;
-};
-
-/**
- * NPC AF Protocol Check Outer L2 Definition Register
- * Provides layer information used by the protocol checker to identify an
- * outer L2 header.
- */
-union cavm_npc_af_pck_def_ol2 {
-	u64 u;
-	struct npc_af_pck_def_ol2_s {
-		u64 ltype_mask:         4;
-		u64 ltype_match:        4;
-		u64 lid:                3;
-		u64 rsvd_63_11:         53;
-	} s;
-};
-
-/**
- * NPC AF Key Extract Layer Data Flags Configuration Register
- */
-union cavm_npc_af_kex_ldatax_flags_cfg {
-	u64 u;
-	struct npc_af_kex_ldatax_flags_cfg_s {
-		u64 lid:        3;
-		u64 rsvd_63_3:  61;
-	} s;
-};
-
-/**
- * NPC AF Interface Key Extract Configuration Registers
- */
-union cavm_npc_af_intfx_kex_cfg {
-	u64 u;
-	struct npc_af_intfx_kex_cfg_s {
-		u64 parse_nibble_ena:   31;
-		u64 rsvd_31:            1;
-		u64 keyw:               3;
-		u64 rsvd_63_35:         29;
-	} s;
-};
-
-/**
- * NPC AF Port Kind Channel Parse Index Definition Registers
- * These registers specify the layer information and algorithm to compute a
- * packet's channel parse index (CPI), which provides a port to channel adder
- * for calculating NPC_RESULT_S[CHAN]. There are two CPI definitions per port
- * kind, allowing the CPI computation to use two possible layer definitions in
- * the parsed packet, e.g. DiffServ DSCP from either IPv4 or IPv6 header. CPI
- * pseudocode: <pre> for (i = 0; i < 2; i++) {  cpi_def =
- * NPC_AF_PKIND()_CPI_DEF(i);  LX = LA, LB, ..., or LH as selected by
- * cpi_def[LID];   if (cpi_def[VALID]    && ((cpi_def[LTYPE_MATCH] &
- * cpi_def[LTYPE_MASK])       == (NPC_RESULT_S[LX[LTYPE]] &
- * cpi_def[LTYPE_MASK]))    && ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])
- * == (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))  {    // Found
- * matching layer    nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) +
- * cpi_def[ADD_OFFSET];    add_byte = byte at nibble_offset from start of
- * packet;    cpi_add = (add_byte & cpi_def[ADD_MASK]) >> cpi_def[ADD_SHIFT];
- * cpi = cpi_def[CPI_BASE] + cpi_add;    NPC_RESULT_S[CHAN] +=
- * NPC_AF_CPI(cpi)_CFG[PADD];    break;  } } </pre>
- */
-union cavm_npc_af_pkindx_cpi_defx {
-	u64 u;
-	struct npc_af_pkindx_cpi_defx_s {
-		u64 cpi_base:           10;
-		u64 rsvd_11_10:         2;
-		u64 add_shift:          3;
-		u64 rsvd_15:            1;
-		u64 add_mask:           8;
-		u64 add_offset:         8;
-		u64 flags_mask:         8;
-		u64 flags_match:        8;
-		u64 ltype_mask:         4;
-		u64 ltype_match:        4;
-		u64 lid:                3;
-		u64 rsvd_62_59:         4;
-		u64 ena:                1;
-	} s;
-};
-
-/**
- * NPC AF KPU Entry CAM Registers
- * KPU comparison ternary data. The field values in NPC_AF_KPU()_ENTRY()_CAM()
- * are ternary, where each data bit of the search key matches as follows: _
- * [CAM(1)]<n>=0, [CAM(0)]<n>=0: Always match; search key data<n> don't care.
- * _ [CAM(1)]<n>=0, [CAM(0)]<n>=1: Match when search key data<n> == 0. _
- * [CAM(1)]<n>=1, [CAM(0)]<n>=0: Match when search key data<n> == 1. _
- * [CAM(1)]<n>=1, [CAM(0)]<n>=1: Reserved. The reserved combination is not
- * allowed. Hardware suppresses any write to CAM(0) or CAM(1) that would
- * result in the reserved combination for any CAM bit. Software must program a
- * default entry for each KPU, e.g. by programming each KPU's last entry {b}
- * (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match all bits.
- */
-union cavm_npc_af_kpux_entryx_camx {
-	u64 u;
-	struct npc_af_kpux_entryx_camx_s {
-		u64 dp0_data:   16;
-		u64 dp1_data:   16;
-		u64 dp2_data:   16;
-		u64 state:      8;
-		u64 rsvd_63_56: 8;
-	} s;
-};
-
-/**
- * NPC AF KPU Entry Action Data 0 Registers
- * When a KPU's search data matches a KPU CAM entry in
- * NPC_AF_KPU()_ENTRY()_CAM(), the corresponding entry action in
- * NPC_AF_KPU()_ENTRY()_ACTION0 and NPC_AF_KPU()_ENTRY()_ACTION1 specifies the
- * next state and operations to perform before exiting the KPU.
- */
-union cavm_npc_af_kpux_entryx_action0 {
-	u64 u;
-	struct npc_af_kpux_entryx_action0_s {
-		u64 var_len_shift:      3;
-		u64 var_len_right:      1;
-		u64 var_len_mask:       8;
-		u64 var_len_offset:     8;
-		u64 ptr_advance:        8;
-		u64 capture_flags:      8;
-		u64 capture_ltype:      4;
-		u64 capture_lid:        3;
-		u64 rsvd_43:            1;
-		u64 next_state:         8;
-		u64 parse_done:         1;
-		u64 capture_ena:        1;
-		u64 byp_count:          3;
-		u64 rsvd_63_57:         7;
-	} s;
-};
-
-/**
- * NPC AF KPU Entry Action Data 0 Registers
- * See NPC_AF_KPU()_ENTRY()_ACTION0.
- */
-union cavm_npc_af_kpux_entryx_action1 {
-	u64 u;
-	struct npc_af_kpux_entryx_action1_s {
-		u64 dp0_offset: 8;
-		u64 dp1_offset: 8;
-		u64 dp2_offset: 8;
-		u64 errcode:    8;
-		u64 errlev:     4;
-		u64 rsvd_63_36: 28;
-	} s;
-};
-
-/**
- * NPC AF KPU Entry Disable Registers
- * See NPC_AF_KPU()_ENTRY()_ACTION0.
- */
-union cavm_npc_af_kpux_entry_disx {
-	u64 u;
-	struct npc_af_kpux_entry_disx_s {
-		u64 dis;                            
-	} s;
-};
-
-/**
- * NPC AF Channel Parse Index Table Registers
- */
-union cavm_npc_af_cpix_cfg {
-	u64 u;
-	struct npc_af_cpix_cfg_s {
-		u64 padd:       4;
-		u64 rsvd_63_4:  60;
-	} s;
-};
-
-/**
- * NPC AF Interface Layer Data Extract Configuration Registers
- * These registers control the extraction of layer data (LDATA) into the MCAM
- * search key for each interface. Up to two LDATA fields can be extracted per
- * layer (LID(0..7) indexed by NPC_LID_E), with up to 16 bytes per LDATA
- * field. For each layer, the corresponding NPC_LAYER_INFO_S[LTYPE] value in
- * NPC_RESULT_S is used as the LTYPE(0..15) index and select the associated
- * LDATA(0..1) registers. NPC_LAYER_INFO_S[LTYPE]=0x0 means the corresponding
- * layer not parsed (invalid), so software should keep
- * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction when
- * LTYPE is zero.
- */
-union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
-	u64 u;
-	struct npc_af_intfx_lidx_ltx_ldx_cfg_s {
-		u64 key_offset: 6;
-		u64 flags_ena:  1;
-		u64 ena:        1;
-		u64 hdr_offset: 8;
-		u64 bytesm1:    4;
-		u64 rsvd_63_20: 44;
-	} s;
-};
-
-/**
- * NPC AF Interface Layer Data Flags Configuration Registers
- * These registers control the extraction of layer data (LDATA) into the MCAM
- * search key for each interface based on the FLAGS<3:0> bits of two layers
- * selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
- */
-union cavm_npc_af_intfx_ldatax_flagsx_cfg {
-	u64 u;
-	struct npc_af_intfx_ldatax_flagsx_cfg_s {
-		u64 key_offset: 6;
-		u64 rsvd_6:     1;
-		u64 ena:        1;
-		u64 hdr_offset: 8;
-		u64 bytesm1:    4;
-		u64 rsvd_63_20: 44;
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank CAM Data Interface Registers
- * MCAM comparison ternary data interface word. The field values in
- * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
- * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where each data bit of the
- * search key matches as follows: _ [CAM(1)]<n>=0, [CAM(0)]<n>=0: Always
- * match; search key data<n> don't care. _ [CAM(1)]<n>=0, [CAM(0)]<n>=1: Match
- * when search key data<n> == 0. _ [CAM(1)]<n>=1, [CAM(0)]<n>=0: Match when
- * search key data<n> == 1. _ [CAM(1)]<n>=1, [CAM(0)]<n>=1: Reserved. The
- * reserved combination is not allowed. Hardware suppresses any write to
- * CAM(0) or CAM(1) that would result in the reserved combination for any CAM
- * bit. When an interface is configured to use the NPC_MCAM_KEY_X1_S search
- * key format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the four
- * banks of every MCAM entry are used as individual entries, each of which is
- * independently compared with the search key as follows: _
- * NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to
- * NPC_MCAM_KEY_X1_S[INTF]. _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD] corresponds
- * to NPC_MCAM_KEY_X1_S[KW0]. _ NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds
- * to NPC_MCAM_KEY_X1_S[KW1]. When an interface is configured to use the
- * NPC_MCAM_KEY_X2_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
- * NPC_MCAMKEYW_E::X2), banks 0-1 of every MCAM entry are used as one
- * double-wide entry, banks 2-3 as a second double-wide entry, and each
- * double-wide entry is independently compared with the search key as follows:
- * _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to
- * NPC_MCAM_KEY_X2_S[INTF]. _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD]
- * corresponds to NPC_MCAM_KEY_X2_S[KW0]. _
- * NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to
- * NPC_MCAM_KEY_X2_S[KW1]<47:0>. _ NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF]
- * corresponds to NPC_MCAM_KEY_X2_S[INTF]. _
- * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]<15:0> corresponds to
- * NPC_MCAM_KEY_X2_S[KW1]<63:48>. _
- * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]<63:16> corresponds to
- * NPC_MCAM_KEY_X2_S[KW2]<47:0>. _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]<15:0>
- * corresponds to NPC_MCAM_KEY_X2_S[KW2]<63:48>. _
- * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]<47:16> corresponds to
- * NPC_MCAM_KEY_X2_S[KW3]<31:0>. When an interface is configured to use the
- * NPC_MCAM_KEY_X4_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
- * NPC_MCAMKEYW_E::X4), the four banks of every MCAM entry are used as a
- * single quad-wide entry that is compared with the search key as follows: _
- * NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to
- * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD] corresponds
- * to NPC_MCAM_KEY_X4_S[KW0]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD]
- * corresponds to NPC_MCAM_KEY_X4_S[KW1]<47:0>. _
- * NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to
- * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]<15:0>
- * corresponds to NPC_MCAM_KEY_X4_S[KW1]<63:48>. _
- * NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]<63:16> corresponds to
- * NPC_MCAM_KEY_X4_S[KW2]<47:0>. _ NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]<15:0>
- * corresponds to NPC_MCAM_KEY_X4_S[KW2]<63:48>. _
- * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]<47:16> corresponds to
- * NPC_MCAM_KEY_X4_S[KW3]<31:0>. _ NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF]
- * corresponds to NPC_MCAM_KEY_X4_S[INTF]. _
- * NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]<31:0> corresponds to
- * NPC_MCAM_KEY_X4_S[KW3]<63:32>. _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]<63:32>
- * corresponds to NPC_MCAM_KEY_X4_S[KW4]<31:0>. _
- * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]<31:0> corresponds to
- * NPC_MCAM_KEY_X4_S[KW4]<63:32>. _ NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]<47:32>
- * corresponds to NPC_MCAM_KEY_X4_S[KW5]<15:0>. _
- * NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to
- * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]<47:0>
- * corresponds to NPC_MCAM_KEY_X4_S[KW5]<63:16>. _
- * NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]<63:48> corresponds to
- * NPC_MCAM_KEY_X4_S[KW6]<15:0>. _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD]
- * corresponds to NPC_MCAM_KEY_X4_S[KW6]<63:16>. Note that for the X2 and X4
- * formats, a wide entry will not match unless the INTF fields from the
- * associated two or four banks match the INTF value from the search key. For
- * the X1 and X2 formats, a match in a lower-numbered bank takes priority over
- * a match in any higher numbered banks. Within each bank, the lowest numbered
- * matching entry takes priority over any higher numbered entry.
- */
-union cavm_npc_af_mcamex_bankx_camx_intf {
-	u64 u;
-	struct npc_af_mcamex_bankx_camx_intf_s {
-		u64 intf:       2;
-		u64 rsvd_63_2:  62;
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank CAM Data Word 0 Registers
- * MCAM comparison ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
- */
-union cavm_npc_af_mcamex_bankx_camx_w0 {
-	u64 u;
-	struct npc_af_mcamex_bankx_camx_w0_s {
-		u64 md;                             
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank Data Word 1 Registers
- * MCAM comparison ternary data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
- */
-union cavm_npc_af_mcamex_bankx_camx_w1 {
-	u64 u;
-	struct npc_af_mcamex_bankx_camx_w1_s {
-		u64 md:         48;
-		u64 rsvd_63_48: 16;
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank Configuration Registers
- */
-union cavm_npc_af_mcamex_bankx_cfg {
-	u64 u;
-	struct npc_af_mcamex_bankx_cfg_s {
-		u64 ena:        1;
-		u64 rsvd_63_1:  63;
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank Statistics Action Registers
- * Used to optionally increment a NPC_AF_MATCH_STAT() counter when a packet
- * matches an MCAM entry. See also NPC_AF_MCAME()_BANK()_ACTION.
- */
-union cavm_npc_af_mcamex_bankx_stat_act {
-	u64 u;
-	struct npc_af_mcamex_bankx_stat_act_s {
-		u64 stat_sel:   9;
-		u64 ena:        1;
-		u64 rsvd_63_10: 54;
-	} s;
-};
-
-/**
- * NPC AF Match Statistics Registers
- */
-union cavm_npc_af_match_statx {
-	u64 u;
-	struct npc_af_match_statx_s {
-		u64 count:      48;
-		u64 rsvd_63_48: 16;
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank Action Data Registers
- * Specifies a packet's match action captured in NPC_RESULT_S[ACTION]. When an
- * interface is configured to use the NPC_MCAM_KEY_X2_S search key format
- * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), *
- * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*. *
- * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*. *
- * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used. When an
- * interface is configured to use the NPC_MCAM_KEY_X4_S search key format
- * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4): *
- * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
- * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
- */
-union cavm_npc_af_mcamex_bankx_action {
-	u64 u;
-	struct npc_af_mcamex_bankx_action_s {
-		u64 action;                         
-	} s;
-};
-
-/**
- * NPC AF MCAM Entry Bank VTag Action Data Registers
- * Specifies a packet's match Vtag action captured in
- * NPC_RESULT_S[VTAG_ACTION]. See also NPC_AF_MCAME()_BANK()_ACTION.
- */
-union cavm_npc_af_mcamex_bankx_tag_act {
-	u64 u;
-	struct npc_af_mcamex_bankx_tag_act_s {
-		u64 vtag_action;                    
-	} s;
-};
-
-/**
- * NPC AF MCAM Bank Hit Registers
- */
-union cavm_npc_af_mcam_bankx_hitx {
-	u64 u;
-	struct npc_af_mcam_bankx_hitx_s {
-		u64 hit;                            
-	} s;
-};
-
-/**
- * NPC AF Software Lookup Control Registers
- */
-union cavm_npc_af_lkup_ctl {
-	u64 u;
-	struct npc_af_lkup_ctl_s {
-		u64 intf:       2;
-		u64 pkind:      6;
-		u64 chan:       12;
-		u64 hdr_sizem1: 8;
-		u64 op:         3;
-		u64 exec:       1;
-		u64 rsvd_63_32: 32;
-	} s;
-};
-
-/**
- * NPC AF Software Lookup Data Registers
- */
-union cavm_npc_af_lkup_datax {
-	u64 u;
-	struct npc_af_lkup_datax_s {
-		u64 data;                           
-	} s;
-};
-
-/**
- * NPC AF Software Lookup Result Registers
- */
-union cavm_npc_af_lkup_resultx {
-	u64 u;
-	struct npc_af_lkup_resultx_s {
-		u64 data;                           
-	} s;
-};
-
-/**
- * NPC AF Interface Statistics Registers
- * Statistics per interface. Index enumerated by NPC_INTF_E.
- */
-union cavm_npc_af_intfx_stat {
-	u64 u;
-	struct npc_af_intfx_stat_s {
-		u64 count:      48;
-		u64 rsvd_63_48: 16;
-	} s;
-};
-
-/**
- * NPC AF Debug Control Register
- * This register controls the capture of debug information in
- * NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG, NPC_AF_DBG_DATA() and
- * NPC_AF_DBG_RESULT().
- */
-union cavm_npc_af_dbg_ctl {
-	u64 u;
-	struct npc_af_dbg_ctl_s {
-		u64 continuous: 1;
-		u64 lkup_dbg:   1;
-		u64 intf_dbg:   4;
-		u64 rsvd_63_6:  58;
-	} s;
-};
-
-/**
- * NPC AF Debug Status Register
- * This register controls the capture of debug information in
- * NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG, NPC_AF_LKUP_DATA() and
- * NPC_AF_LKUP_RESULT().
- */
-union cavm_npc_af_dbg_status {
-	u64 u;
-	struct npc_af_dbg_status_s {
-		u64 done:       1;
-		u64 rsvd_63_1:  63;
-	} s;
-};
-
-/**
- * NPC AF KPU Debug Registers
- * This register contains information for the last packet/lookup for which
- * debug is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
- */
-union cavm_npc_af_kpux_dbg {
-	u64 u;
-	struct npc_af_kpux_dbg_s {
-		u64 hit_entry:  8;
-		u64 byp:        1;
-		u64 rsvd_63_9:  55;
-	} s;
-};
-
-/**
- * NPC AF KPU Error Control Registers
- * This register specifies values captured in NPC_RESULT_S[ERRLEV,ERRCODE]
- * when errors are detected by a KPU.
- */
-union cavm_npc_af_kpux_err_ctl {
-	u64 u;
-	struct npc_af_kpux_err_ctl_s {
-		u64 errlev:                     4;
-		u64 dp_offset_errcode:          8;
-		u64 ptr_advance_errcode:        8;
-		u64 var_len_offset_errcode:     8;
-		u64 rsvd_63_28:                 36;
-	} s;
-};
-
-/**
- * NPC AF MCAM Debug Register
- * This register contains information for the last packet/lookup for which
- * debug is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
- */
-union cavm_npc_af_mcam_dbg {
-	u64 u;
-	struct npc_af_mcam_dbg_s {
-		u64 hit_entry:  10;
-		u64 rsvd_11_10: 2;
-		u64 hit_bank:   2;
-		u64 rsvd_15_14: 2;
-		u64 miss:       1;
-		u64 rsvd_63_17: 47;
-	} s;
-};
-
-/**
- * NPC AF Debug Data Registers
- * This register contains packet header data for the last packet/lookup for
- * which debug information is captured by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
- */
-union cavm_npc_af_dbg_datax {
-	u64 u;
-	struct npc_af_dbg_datax_s {
-		u64 data;                           
-	} s;
-};
diff --git a/drivers/net/octeontx2/rvu.h b/drivers/net/octeontx2/rvu.h
index a61da69ae7..24b107ea69 100644
--- a/drivers/net/octeontx2/rvu.h
+++ b/drivers/net/octeontx2/rvu.h
@@ -1,15 +1,14 @@
-/*
+/* SPDX-License-Identifier:    GPL-2.0
+ *
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #ifndef __RVU_H__
 #define __RVU_H__
 
-#include "cavm-csrs-rvu.h"
+#include <asm/arch/csrs/csrs-rvu.h>
 
 #define ALIGNED		__aligned(CONFIG_SYS_CACHELINE_SIZE)
 
@@ -31,7 +30,7 @@
 #define Q_SIZE_MIN		Q_SIZE_16
 #define Q_SIZE_MAX		Q_SIZE_1M
 
-#define Q_COUNT(x)		(16ULL << (2 * x))
+#define Q_COUNT(x)		(16ULL << (2 * (x)))
 #define Q_SIZE(x, n)		((ilog2(x) - (n)) / 2)
 
 /* Admin queue info */
@@ -81,9 +80,7 @@ struct rvu_pf {
  */
 static inline void cavm_st128(void *dest, u64 val0, u64 val1)
 {
-	__asm__ __volatile__(
-		"stp %x[x0], %x[x1], [%[pm]]"
-		:
+	__asm__ __volatile__("stp %x[x0], %x[x1], [%[pm]]" :
 		: [x0]"r"(val0), [x1]"r"(val1), [pm]"r"(dest)
 		: "memory");
 }
@@ -97,10 +94,8 @@ static inline void cavm_st128(void *dest, u64 val0, u64 val1)
  */
 static inline void cavm_ld128(const u64 *src, u64 *val0, u64 *val1)
 {
-	__asm__ __volatile__ (
-		"ldp %x[x0], %x[x1], [%[pm]]"
-		:
-		: [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
+	__asm__ __volatile__ ("ldp %x[x0], %x[x1], [%[pm]]" :
+		 : [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
 }
 
 void qmem_free(struct qmem *q);
@@ -116,8 +111,8 @@ int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz);
  *
  * @return	-ENOMEM on error, 0 on success
  */
-int rvu_aq_alloc(struct admin_queue *aq, unsigned qsize,
-		      size_t inst_size, size_t res_size);
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size);
 
 /**
  * Frees an admin queue
diff --git a/drivers/net/octeontx2/rvu_af.c b/drivers/net/octeontx2/rvu_af.c
index c0016974b4..92b350a9ab 100644
--- a/drivers/net/octeontx2/rvu_af.c
+++ b/drivers/net/octeontx2/rvu_af.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -15,10 +14,10 @@
 #include <linux/list.h>
 #include <asm/io.h>
 #include <asm/arch/octeontx2.h>
-#include "cavm-csrs-npa.h"
+#include <asm/arch/csrs/csrs-npa.h>
 #include "nix.h"
 
-struct udevice *rvu_af_dev=NULL;
+struct udevice *rvu_af_dev;
 
 inline struct rvu_af *get_af(void)
 {
@@ -27,9 +26,9 @@ inline struct rvu_af *get_af(void)
 
 void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid)
 {
-	union cavm_nixx_af_rvu_lf_cfg_debug nix_lf_dbg;
-	union cavm_npa_af_rvu_lf_cfg_debug npa_lf_dbg;
-	union cavm_rvu_pf_func_s pf_func;
+	union nixx_af_rvu_lf_cfg_debug nix_lf_dbg;
+	union npa_af_rvu_lf_cfg_debug npa_lf_dbg;
+	union rvu_pf_func_s pf_func;
 	struct rvu_af *af = dev_get_priv(rvu_af_dev);
 	struct nix_af *nix_af = af->nix_af;
 
@@ -39,40 +38,39 @@ void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid)
 	nix_lf_dbg.u = 0;
 	nix_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
 	nix_lf_dbg.s.exec = 1;
-	nix_af_reg_write(nix_af, CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(),
+	nix_af_reg_write(nix_af, NIXX_AF_RVU_LF_CFG_DEBUG(),
 			 nix_lf_dbg.u);
 	do {
 		nix_lf_dbg.u = nix_af_reg_read(nix_af,
-				CAVM_NIXX_AF_RVU_LF_CFG_DEBUG());
+					       NIXX_AF_RVU_LF_CFG_DEBUG());
 	} while (nix_lf_dbg.s.exec);
 
 	if (nix_lf_dbg.s.lf_valid)
-		*nixid = nix_lf_dbg.s.lf; 
+		*nixid = nix_lf_dbg.s.lf;
 
 	debug("%s: nix lf_valid %d lf %d nixid %d\n", __func__,
-		nix_lf_dbg.s.lf_valid,nix_lf_dbg.s.lf,*nixid);
+	      nix_lf_dbg.s.lf_valid, nix_lf_dbg.s.lf, *nixid);
 
 	npa_lf_dbg.u = 0;
 	npa_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
 	npa_lf_dbg.s.exec = 1;
-	npa_af_reg_write(nix_af->npa_af, CAVM_NPA_AF_RVU_LF_CFG_DEBUG(),
+	npa_af_reg_write(nix_af->npa_af, NPA_AF_RVU_LF_CFG_DEBUG(),
 			 npa_lf_dbg.u);
 	do {
 		npa_lf_dbg.u = npa_af_reg_read(nix_af->npa_af,
-				CAVM_NPA_AF_RVU_LF_CFG_DEBUG());
+					       NPA_AF_RVU_LF_CFG_DEBUG());
 	} while (npa_lf_dbg.s.exec);
 
 	if (npa_lf_dbg.s.lf_valid)
-		*npaid = npa_lf_dbg.s.lf; 
+		*npaid = npa_lf_dbg.s.lf;
 	debug("%s: npa lf_valid %d lf %d npaid %d\n", __func__,
-		npa_lf_dbg.s.lf_valid,npa_lf_dbg.s.lf,*npaid);
-
+	      npa_lf_dbg.s.lf_valid, npa_lf_dbg.s.lf, *npaid);
 }
 
 struct nix_af *rvu_af_init(struct rvu_af *rvu_af)
 {
 	struct nix_af *nix_af;
-	union cavm_rvu_af_addr_s block_addr;
+	union rvu_af_addr_s block_addr;
 	int err;
 
 	nix_af = (struct nix_af *)calloc(1, sizeof(struct nix_af));
@@ -84,7 +82,7 @@ struct nix_af *rvu_af_init(struct rvu_af *rvu_af)
 	nix_af->dev = rvu_af->dev;
 
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NIXX(0);
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NIXX(0);
 	nix_af->nix_af_base = rvu_af->af_base + block_addr.u;
 
 	nix_af->npa_af = (struct npa_af *)calloc(1, sizeof(struct npa_af));
@@ -94,11 +92,11 @@ struct nix_af *rvu_af_init(struct rvu_af *rvu_af)
 	}
 
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPA;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPA;
 	nix_af->npa_af->npa_af_base = rvu_af->af_base + block_addr.u;
 
 	block_addr.u = 0;
-	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPC;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPC;
 	nix_af->npc_af_base = rvu_af->af_base + block_addr.u;
 
 	debug("%s: Setting up npa admin\n", __func__);
@@ -121,9 +119,8 @@ error:
 		free(nix_af->npa_af);
 		memset(nix_af, 0, sizeof(*nix_af));
 	}
-	if (nix_af) {
+	if (nix_af)
 		free(nix_af);
-	}
 	return NULL;
 }
 
@@ -133,11 +130,12 @@ int rvu_af_probe(struct udevice *dev)
 	size_t size;
 
 	af_ptr->af_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
-	debug("%s RVU AF BAR %p \n", __func__, af_ptr->af_base);
-	af_ptr->dev = rvu_af_dev = dev;
+	debug("%s RVU AF BAR %p\n", __func__, af_ptr->af_base);
+	af_ptr->dev = dev;
+	rvu_af_dev = dev;
 
 	af_ptr->nix_af = rvu_af_init(af_ptr);
-	if ( !af_ptr->nix_af) {
+	if (!af_ptr->nix_af) {
 		printf("%s: Error: could not initialize NIX AF\n", __func__);
 		return -1;
 	}
@@ -154,27 +152,27 @@ int rvu_af_remove(struct udevice *dev)
 	npa_af_shutdown(rvu_af->nix_af->npa_af);
 	npc_af_shutdown(rvu_af->nix_af);
 
-	debug("%s: rvu af down -- \n", __func__);
+	debug("%s: rvu af down --\n", __func__);
 	return 0;
 }
 
 static const struct udevice_id rvu_af_ids[] = {
-        { .compatible = "cavium,rvu-af" },
-        {}
+	{ .compatible = "cavium,rvu-af" },
+	{}
 };
 
 U_BOOT_DRIVER(rvu_af) = {
-        .name   = "rvu_af",
-        .id     = UCLASS_MISC,
-        .probe  = rvu_af_probe,
-        .remove = rvu_af_remove,
-        .of_match = rvu_af_ids,
-        .priv_auto_alloc_size = sizeof(struct rvu_af),
+	.name   = "rvu_af",
+	.id     = UCLASS_MISC,
+	.probe  = rvu_af_probe,
+	.remove = rvu_af_remove,
+	.of_match = rvu_af_ids,
+	.priv_auto_alloc_size = sizeof(struct rvu_af),
 };
 
 static struct pci_device_id rvu_af_supported[] = {
-        { PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },
-        {}
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },
+	{}
 };
 
 U_BOOT_PCI_DEVICE(rvu_af, rvu_af_supported);
diff --git a/drivers/net/octeontx2/rvu_common.c b/drivers/net/octeontx2/rvu_common.c
index 5622b65d16..02ad27bebe 100644
--- a/drivers/net/octeontx2/rvu_common.c
+++ b/drivers/net/octeontx2/rvu_common.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -26,7 +25,7 @@ int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz)
 	q->alloc_sz = (size_t)qsize * entry_sz;
 	q->iova = (dma_addr_t)(q->base);
 	debug("NIX: qmem alloc for (%d * %d = %ld bytes) at %p\n",
-	       q->qsize, q->entry_sz, q->alloc_sz, q->base);
+	      q->qsize, q->entry_sz, q->alloc_sz, q->base);
 	return 0;
 }
 
@@ -47,8 +46,8 @@ void qmem_free(struct qmem *q)
  *
  * @return	-ENOMEM on error, 0 on success
  */
-int rvu_aq_alloc(struct admin_queue *aq, unsigned qsize,
-		      size_t inst_size, size_t res_size)
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size)
 {
 	int err;
 
@@ -73,4 +72,3 @@ void rvu_aq_free(struct admin_queue *aq)
 	qmem_free(&aq->res);
 	memset(aq, 0, sizeof(*aq));
 }
-
diff --git a/drivers/net/octeontx2/rvu_pf.c b/drivers/net/octeontx2/rvu_pf.c
index 99d1a12411..00ae8be34f 100644
--- a/drivers/net/octeontx2/rvu_pf.c
+++ b/drivers/net/octeontx2/rvu_pf.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <net.h>
 #include <malloc.h>
@@ -51,7 +50,6 @@ static const struct eth_ops nix_eth_ops = {
 	.free_pkt		= nix_lf_free_pkt,
 	.stop			= nix_lf_halt,
 	.write_hwaddr		= nix_lf_setup_mac,
-	.read_rom_hwaddr	= nix_lf_read_rom_mac,
 };
 
 int rvu_pf_probe(struct udevice *dev)
@@ -75,8 +73,7 @@ int rvu_pf_probe(struct udevice *dev)
 
 	debug("RVU PF %u BAR2 %p\n", rvu->pfid, rvu->pf_base);
 
-	rvu_get_lfid_for_pf(rvu->pfid, &rvu->nix_lfid,
-				 &rvu->npa_lfid);
+	rvu_get_lfid_for_pf(rvu->pfid, &rvu->nix_lfid, &rvu->npa_lfid);
 
 	err = rvu_pf_init(rvu);
 	if (err)
@@ -99,31 +96,30 @@ int rvu_pf_remove(struct udevice *dev)
 	nix_lf_shutdown(rvu->nix);
 	npa_lf_shutdown(rvu->nix);
 
-	debug("%s: rvu pf%d down -- \n", __func__,  rvu->pfid);
+	debug("%s: rvu pf%d down --\n", __func__,  rvu->pfid);
 
 	return 0;
 }
 
 static const struct udevice_id rvu_pf_ids[] = {
-        { .compatible = "cavium,rvu-pf" },
-        {}
+	{ .compatible = "cavium,rvu-pf" },
+	{}
 };
 
 U_BOOT_DRIVER(rvu_pf) = {
-        .name   = "rvu_pf",
-        .id     = UCLASS_ETH,
-        .of_match = rvu_pf_ids,
-        .probe  = rvu_pf_probe,
-        .remove = rvu_pf_remove,
+	.name   = "rvu_pf",
+	.id     = UCLASS_ETH,
+	.of_match = rvu_pf_ids,
+	.probe	= rvu_pf_probe,
+	.remove = rvu_pf_remove,
 	.ops    = &nix_eth_ops,
-        .priv_auto_alloc_size = sizeof(struct rvu_pf),
+	.priv_auto_alloc_size = sizeof(struct rvu_pf),
 	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
 };
 
 static struct pci_device_id rvu_pf_supported[] = {
-        { PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_PF) },
-        {}
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_PF) },
+	{}
 };
 
 U_BOOT_PCI_DEVICE(rvu_pf, rvu_pf_supported);
-
diff --git a/drivers/pci/pci_octeontx_ecam.c b/drivers/pci/pci_octeontx_ecam.c
index 63e304daa1..9a90e5d591 100644
--- a/drivers/pci/pci_octeontx_ecam.c
+++ b/drivers/pci/pci_octeontx_ecam.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
-
 #include <common.h>
 #include <dm.h>
 #include <errno.h>
@@ -31,7 +30,6 @@
 
 #endif
 
-
 DECLARE_GLOBAL_DATA_PTR;
 
 struct octeontx_pci {
@@ -73,16 +71,14 @@ static int pci_octeontx_ecam_read_config(struct udevice *bus, pci_dev_t bdf,
 		break;
 	};
 
-/*
 	debug("%02x.%02x.%02x: u%d %x -> %lx\n",
 	      b, d, f, size, offset, *valuep);
-*/
 	return 0;
 }
 
 static int pci_octeontx_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
-					 uint offset, ulong valuep,
-					 enum pci_size_t size)
+					  uint offset, ulong valuep,
+					  enum pci_size_t size)
 {
 	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
 	struct pci_controller *hose = dev_get_uclass_priv(bus);
@@ -109,10 +105,8 @@ static int pci_octeontx_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
 		break;
 	};
 
-/*
 	debug("%02x.%02x.%02x: u%d %x <- %lx\n",
 	      b, d, f, size, offset, valuep);
-*/
 	return 0;
 }
 
@@ -157,16 +151,14 @@ static int pci_octeontx_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 
 	hdrtype = readb(address + PCI_HEADER_TYPE);
 
-	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
-	    (offset >= PCI_PRIMARY_BUS) &&
-	    (offset <= PCI_SUBORDINATE_BUS) &&
+	if (hdrtype == PCI_HEADER_TYPE_BRIDGE &&
+	    offset >= PCI_PRIMARY_BUS &&
+	    offset <= PCI_SUBORDINATE_BUS &&
 	    *valuep != pci_conv_32_to_size(~0UL, offset, size)) {
 		*valuep -= pci_conv_32_to_size(bus_offs, offset, size);
 	}
-/*
 	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
 	      b, d, f, size, offset, address, *valuep);
-*/
 	return 0;
 }
 
@@ -192,10 +184,10 @@ static int pci_octeontx_pem_write_config(struct udevice *bus, pci_dev_t bdf,
 
 	hdrtype = readb(address + PCI_HEADER_TYPE);
 
-	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
-	    (offset >= PCI_PRIMARY_BUS) &&
-	    (offset <= PCI_SUBORDINATE_BUS) &&
-	    (value != pci_conv_32_to_size(~0UL, offset, size))) {
+	if (hdrtype == PCI_HEADER_TYPE_BRIDGE &&
+	    offset >= PCI_PRIMARY_BUS &&
+	    offset <= PCI_SUBORDINATE_BUS &&
+	    value != pci_conv_32_to_size(~0UL, offset, size)) {
 		value +=  pci_conv_32_to_size(bus_offs, offset, size);
 	}
 
@@ -215,16 +207,14 @@ static int pci_octeontx_pem_write_config(struct udevice *bus, pci_dev_t bdf,
 	default:
 		printf("Invalid size\n");
 	}
-/*
 	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
 	      b, d, f, size, offset, address, value);
-*/
 	return 0;
 }
 
 static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
-					uint offset, ulong *valuep,
-					enum pci_size_t size)
+					 uint offset, ulong *valuep,
+					 enum pci_size_t size)
 {
 	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
 	struct pci_controller *hose = dev_get_uclass_priv(bus);
@@ -237,11 +227,11 @@ static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 
 	address = (b << 20) | (d << 15) | (f << 12);
 
-	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx) \n",
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx)\n",
 	      bdf, b, d, f, size, offset, address);
 	address += pcie->cfg.start;
 
-	debug("%02x.%02x.%02x: u%d %x (%lx) %lx \n",
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx\n",
 	      b, d, f, size, offset, address, *valuep);
 	*valuep = pci_conv_32_to_size(~0UL, offset, size);
 
@@ -250,15 +240,15 @@ static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 
 	switch (size) {
 	case PCI_SIZE_8:
-		debug("byte %lx\n",address+offset);
+		debug("byte %lx\n", address + offset);
 		*valuep = readb(address + offset);
 		break;
 	case PCI_SIZE_16:
-		debug("word %lx\n",address+offset);
+		debug("word %lx\n", address + offset);
 		*valuep = readw(address + offset);
 		break;
 	case PCI_SIZE_32:
-		debug("long %lx\n",address+offset);
+		debug("long %lx\n", address + offset);
 		*valuep = readl(address + offset);
 		break;
 	default:
@@ -272,7 +262,7 @@ static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
 }
 
 static void pci_octeontx2_pem_errata(struct udevice *bus, uint offset,
-					 enum pci_size_t size)
+				     enum pci_size_t size)
 {
 #if defined(CONFIG_ARCH_OCTEONTX2)
 	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
@@ -285,8 +275,6 @@ static void pci_octeontx2_pem_errata(struct udevice *bus, uint offset,
 	waddr = pcie->pem.start + PEM_CFG_WR;
 
 	debug("%s raddr %llx waddr %llx\n", __func__, raddr, waddr);
-		cfg_off = rval = wval = data = 0;
-
 		cfg_off = PCIERC_RASDP_DE_ME;
 		wval = cfg_off;
 	debug("%s DE_ME raddr %llx wval %llx\n", __func__, raddr, wval);
@@ -337,17 +325,17 @@ static void pci_octeontx2_pem_errata(struct udevice *bus, uint offset,
 	writeq(wval, waddr);
 
 	switch (size) {
-		case PCI_SIZE_8:
-			shift = offset % 4;
-			data = (0x1 << shift);
+	case PCI_SIZE_8:
+		shift = offset % 4;
+		data = (0x1 << shift);
 		break;
-		case PCI_SIZE_16:
-			shift = (offset % 4) ? 2 : 0;
-			data = (0x3 << shift);
+	case PCI_SIZE_16:
+		shift = (offset % 4) ? 2 : 0;
+		data = (0x3 << shift);
 		break;
-		default:
-		case PCI_SIZE_32:
-			data = 0xF;
+	default:
+	case PCI_SIZE_32:
+		data = 0xF;
 		break;
 	}
 
@@ -369,8 +357,8 @@ static void pci_octeontx2_pem_errata(struct udevice *bus, uint offset,
 }
 
 static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
-					 uint offset, ulong value,
-					 enum pci_size_t size)
+					  uint offset, ulong value,
+					  enum pci_size_t size)
 {
 	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
 	struct pci_controller *hose = dev_get_uclass_priv(bus);
@@ -385,11 +373,11 @@ static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
 
 	address = (b << 20) | (d << 15) | (f << 12);
 
-	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx) \n",
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx)\n",
 	      bdf, b, d, f, size, offset, address);
 	address += pcie->cfg.start;
 
-	debug("%02x.%02x.%02x: u%d %x (%lx) %lx \n",
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx\n",
 	      b, d, f, size, offset, address, value);
 
 	if (b == 1 && d > 0)
@@ -401,7 +389,7 @@ static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
 		tmp = (address + offset) & 0x3;
 		size = PCI_SIZE_32;
 		data = readl(addr);
-		debug("tmp 8 long %lx %x\n",addr, data);
+		debug("tmp 8 long %lx %x\n", addr, data);
 		tmp *= 8;
 		value = (data & ~(0xFFUL << tmp)) | ((value & 0xFF) << tmp);
 	break;
@@ -409,28 +397,28 @@ static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
 		tmp = (address + offset) & 0x3;
 		size = PCI_SIZE_32;
 		data = readl(addr);
-		debug("tmp 16 long %lx %x\n",addr, data);
+		debug("tmp 16 long %lx %x\n", addr, data);
 		tmp *= 8;
 		value = (data & 0xFFFF) | (value << tmp);
 	break;
 	case PCI_SIZE_32:
 	break;
 	}
-	debug("tmp long %lx %lx\n",addr, value);
+	debug("tmp long %lx %lx\n", addr, value);
 
 	pci_octeontx2_pem_errata(bus, offset, size);
 
 	switch (size) {
 	case PCI_SIZE_8:
-		debug("byte %lx %lx\n",address+offset, value);
+		debug("byte %lx %lx\n", address + offset, value);
 		writeb(value, address + offset);
 		break;
 	case PCI_SIZE_16:
-		debug("word %lx %lx\n",address+offset, value);
+		debug("word %lx %lx\n", address + offset, value);
 		writew(value, address + offset);
 		break;
 	case PCI_SIZE_32:
-		debug("long %lx %lx\n",addr, value);
+		debug("long %lx %lx\n", addr, value);
 		writel(value, addr);
 		break;
 	default:
@@ -466,11 +454,11 @@ static int pci_octeontx_ecam_probe(struct udevice *dev)
 					"marvell,pci-host-octeontx2-pem");
 	if (!err) {
 		err = fdt_get_resource(gd->fdt_blob, dev->node.of_offset,
-					"reg", 1, &pcie->pem);
+				       "reg", 1, &pcie->pem);
 
 		if (err) {
 			printf("Error reading resource: %s\n",
-				fdt_strerror(err));
+			       fdt_strerror(err));
 			return err;
 		}
 	}
diff --git a/drivers/spi/octeontx_spi.c b/drivers/spi/octeontx_spi.c
index 06452a8536..449c9ba555 100644
--- a/drivers/spi/octeontx_spi.c
+++ b/drivers/spi/octeontx_spi.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier:    GPL-2.0
 /*
  * Copyright (C) 2018 Marvell International Ltd.
  *
- * SPDX-License-Identifier:    GPL-2.0
  * https://spdx.org/licenses
  */
 
@@ -74,7 +74,7 @@ union mpi_cfg {
 		/** 0 = shift MSB first, 1 = shift LSB first */
 		u64 lsbfirst	:1;
 		u64 cs_sticky	:1;	/** cs sticky bit */
-		u64 rsvd		:1;	/** Reserved */
+		u64 rsvd	:1;	/** Reserved */
 		/**
 		 * SPI_CSn_L high.  1 = SPI_CSn_L is asserted high,
 		 * 0 = SPI_CS_n asserted low.
@@ -101,9 +101,9 @@ union mpi_cfg {
 		u64 csena2	:1;	/** cs enable 2 */
 		u64 csena3	:1;	/** cs enable 3 */
 		u64 clkdiv	:13;	/** clock divisor */
-		u64		:2;
+		u64 rsvd1	:2;
 		u64 legacy_dis	:1;	/** Disable legacy mode */
-		u64		:2;
+		u64 rsvd2	:2;
 		/**
 		 * I/O Mode (legacy_dis must be 1):
 		 *   0x0	One-lane unidirectional mode.
@@ -112,7 +112,7 @@ union mpi_cfg {
 		 *   0x3	Four-lane bidirectional mode.
 		 */
 		u64 iomode	:2;
-		u64		:8;
+		u64 rsvd3	:8;
 		/**
 		 * Enable ESPI mode per slave.  Each bit corresponds to each
 		 * of the four possible CS's.
@@ -121,13 +121,13 @@ union mpi_cfg {
 		 * If 1, CRC hardware is enabled and the hardware will
 		 * automatically calculate the CRC for one transaction and then
 		 * apply it to the end of the transaction and then check the
-		 * CRC on the reponse and if there is an error the
+		 * CRC on the response and if there is an error the
 		 * MPI(0..1)_STS[CRC_ERR] bit will be set. The turn around
 		 * time (TAR in the ESPI spec) is set to two cicles and parsing
 		 * for special state is enabled.
 		 */
 		u64 cs_espi_en	:4;
-		u64		:1;
+		u64 rsvd4	:1;
 		/**
 		 * SPI 100MHz clock enable.
 		 *
@@ -139,7 +139,7 @@ union mpi_cfg {
 		 *	sclk agnostic.
 		 */
 		u64 tb100_en	:1;
-		u64		:14;
+		u64 rsvd5	:14;
 	} s;
 	/* struct mpi_cfg_s cn; */
 };
@@ -170,9 +170,9 @@ union mpi_sts {
 		u64 mpi_intr	:1;	/** Transaction done int */
 		u64 reserved_2_7:6;
 		u64 rxnum	:5;	/** ESPI number of rx bytes */
-		u64		:6;
+		u64 rsvd	:6;
 		u64 crc_err	:1;	/** CRC error from ESPI */
-		u64		:5;
+		u64 rsvd1	:5;
 		u64 crc		:8;	/** ESPI CRC received */
 		u64 reserved_40_63	:24;
 	} s;
@@ -188,13 +188,13 @@ union mpi_tx {
 	u64 u;
 	struct mpi_tx_s {
 		u64 totnum	:5;	/** Total bytes to shift */
-		u64 		:3;
+		u64 rsvd	:3;
 		u64 txnum	:5;	/** Number of words to tx */
-		u64		:3;
+		u64 rsvd1	:3;
 		u64 leavecs	:1;	/** Leave CS asserted */
-		u64		:3;
+		u64 rsvd2	:3;
 		u64 csid	:2;	/** Which CS to assert */
-		u64		:42;
+		u64 rsvd3	:42;
 	} s;
 	/* struct mpi_tx_s cn; */
 };
@@ -242,8 +242,8 @@ static union mpi_cfg octeontx_spi_set_mpicfg(struct udevice *dev)
 	if (max_speed > OCTEONTX_SPI_MAX_CLOCK_HZ)
 		max_speed = OCTEONTX_SPI_MAX_CLOCK_HZ;
 
-	debug ("\n slave params %d %d %d \n", slave->cs,
-		slave->max_hz, slave->mode);
+	debug("\n slave params %d %d %d\n", slave->cs,
+	      slave->max_hz, slave->mode);
 	cpha = !!(slave->mode & SPI_CPHA);
 	cpol = !!(slave->mode & SPI_CPOL);
 
@@ -260,7 +260,7 @@ static union mpi_cfg octeontx_spi_set_mpicfg(struct udevice *dev)
 	mpi_cfg.s.csena2 = 1;
 	mpi_cfg.s.csena3 = 1;
 
-	debug("\n mpi_cfg %llx\n",mpi_cfg.u);
+	debug("\n mpi_cfg %llx\n", mpi_cfg.u);
 	return mpi_cfg;
 }
 
@@ -282,6 +282,7 @@ static void octeontx_spi_wait_ready(struct udevice *dev)
 	} while (mpi_sts.s.busy);
 	debug("%s(%s)\n", __func__, dev->name);
 }
+
 /**
  * Claim the bus for a slave device
  *
@@ -355,8 +356,8 @@ static int octeontx_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	u64 wide_dat = 0;
 	int len = bitlen / 8;
 	int i;
-	const uint8_t *tx_data = dout;
-	uint8_t *rx_data = din;
+	const u8 *tx_data = dout;
+	u8 *rx_data = din;
 	int cs = spi_chip_select(dev);
 
 	if (!OCTEONTX_SPI_CS_VALID(cs))
@@ -628,7 +629,7 @@ static int octeontx_pci_spi_probe(struct udevice *dev)
 	dev->req_seq = PCI_FUNC(bdf);
 	priv->baseaddr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
 
-	debug("SPI bus %s %d at %p\n",dev->name, dev->seq, priv->baseaddr);
+	debug("SPI bus %s %d at %p\n", dev->name, dev->seq, priv->baseaddr);
 
 	return 0;
 }
@@ -650,8 +651,8 @@ static const struct udevice_id octeontx_spi_ids[] = {
 U_BOOT_DRIVER(octeontx_pci_spi) = {
 	.name			= "spi_octeontx",
 	.id			= UCLASS_SPI,
-	.of_match 		= octeontx_spi_ids,
+	.of_match		= octeontx_spi_ids,
 	.probe			= octeontx_pci_spi_probe,
-	.priv_auto_alloc_size 	= sizeof(struct octeontx_spi),
+	.priv_auto_alloc_size	= sizeof(struct octeontx_spi),
 	.ops			= &octeontx_spi_ops,
 };
-- 
2.29.0

