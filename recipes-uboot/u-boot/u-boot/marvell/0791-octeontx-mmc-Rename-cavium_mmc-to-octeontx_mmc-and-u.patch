From 16e156f267e72b0d9e9886536ef29d7169630461 Mon Sep 17 00:00:00 2001
From: Aaron Williams <aaron.williams@cavium.com>
Date: Fri, 31 Aug 2018 20:47:32 -0700
Subject: [PATCH 0791/1239] octeontx: mmc: Rename cavium_mmc to octeontx_mmc
 and use hw generated regs

This patch renames the cavium_mmc driver to octeontx_mmc.  Additionally it
modifies the driver to use an auto-generated hardware register definition
file in order to make supporting future SOCs easier.

Renaming cavium to octeontx was done due to the recent aquisition of Cavium
by Marvell, Inc.  Note that there are still a few places that need to be
fixed.

A future patch will clean up the changes required for the generic mmc files.

Signed-off-by: Aaron Williams <aaron.williams@cavium.com>
---
 .../include/asm/arch-octeontx/cavium_mmc.h    | 1845 -----------------
 .../asm/arch-octeontx/cavm-csrs-mio_emm.h     | 1197 +++++++++++
 .../include/asm/arch-octeontx/octeontx_mmc.h  |  202 ++
 cmd/Kconfig                                   |    2 +-
 cmd/mmc.c                                     |    4 +-
 configs/octeontx2_95xx_defconfig              |    2 +-
 configs/octeontx2_96xx_defconfig              |    2 +-
 configs/octeontx_81xx_defconfig               |    2 +-
 configs/octeontx_83xx_defconfig               |    2 +-
 drivers/mmc/Kconfig                           |    4 +-
 drivers/mmc/Makefile                          |    2 +-
 drivers/mmc/mmc-uclass.c                      |   39 +-
 drivers/mmc/{cavium_mmc.c => octeontx_mmc.c}  | 1161 +++++------
 13 files changed, 2008 insertions(+), 2456 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-octeontx/cavium_mmc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
 rename drivers/mmc/{cavium_mmc.c => octeontx_mmc.c} (86%)

diff --git a/arch/arm/include/asm/arch-octeontx/cavium_mmc.h b/arch/arm/include/asm/arch-octeontx/cavium_mmc.h
deleted file mode 100644
index 5f4a6e26c4..0000000000
--- a/arch/arm/include/asm/arch-octeontx/cavium_mmc.h
+++ /dev/null
@@ -1,1845 +0,0 @@
-/***********************license start************************************
- * Copyright (c) 2012 Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *     * Neither the name of Cavium Inc. nor the names of
- *       its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written
- *       permission.
- *
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS
- * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
- * RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
- * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT
- * DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES
- * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR
- * PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET
- * POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT
- * OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- *
- *
- * For any questions regarding licensing please contact
- * support@cavium.com
- *
- ***********************license end**************************************/
-#ifndef __OCTEON_MMC_H__
-#define __OCTEON_MMC_H__
-
-#include <mmc.h>
-#include <dm/device.h>
-
-/* NOTE: this file is used by both Octeon and OcteonTX */
-
-/*
- * Card Command Classes (CCC)
- */
-#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
-					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
-					/* (and for SPI, CMD58,59) */
-#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
-					/* (CMD11) */
-#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
-					/* (CMD16,17,18) */
-#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
-					/* (CMD20) */
-#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
-					/* (CMD16,24,25,26,27) */
-#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
-					/* (CMD32,33,34,35,36,37,38,39) */
-#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
-					/* (CMD28,29,30) */
-#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
-					/* (CMD16,CMD42) */
-#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
-					/* (CMD55,56,57,ACMD*) */
-#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
-					/* (CMD5,39,40,52,53) */
-#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
-					/* (CMD6,34,35,36,37,50) */
-					/* (11) Reserved */
-					/* (CMD?) */
-
-/*
- * NOTE: This was copied from the Linux kernel.
- *
- * MMC status in R1, for native mode (SPI bits are different)
- * Type
- *	e:error bit
- *	s:status bit
- *	r:detected and set for the actual command response
- *	x:detected and set during command execution. the host must poll
- *	    the card by sending status command in order to read these bits.
- * Clear condition
- *	a:according to the card state
- *	b:always related to the previous command. Reception of
- *	    a valid command will clear it (with a delay of one command)
- *	c:clear by read
- */
-#define R1_OUT_OF_RANGE         (1 << 31)       /* er, c */
-#define R1_ADDRESS_ERROR        (1 << 30)       /* erx, c */
-#define R1_BLOCK_LEN_ERROR      (1 << 29)       /* er, c */
-#define R1_ERASE_SEQ_ERROR      (1 << 28)       /* er, c */
-#define R1_ERASE_PARAM          (1 << 27)       /* ex, c */
-#define R1_WP_VIOLATION         (1 << 26)       /* erx, c */
-#define R1_CARD_IS_LOCKED       (1 << 25)       /* sx, a */
-#define R1_LOCK_UNLOCK_FAILED   (1 << 24)       /* erx, c */
-#define R1_COM_CRC_ERROR        (1 << 23)       /* er, b */
-#define R1_ILLEGAL_COMMAND      (1 << 22)       /* er, b */
-#define R1_CARD_ECC_FAILED      (1 << 21)       /* ex, c */
-#define R1_CC_ERROR             (1 << 20)       /* erx, c */
-#define R1_ERROR                (1 << 19)       /* erx, c */
-#define R1_UNDERRUN             (1 << 18)       /* ex, c */
-#define R1_OVERRUN              (1 << 17)       /* ex, c */
-#define R1_CID_CSD_OVERWRITE    (1 << 16)       /* erx, c, CID/CSD overwrite */
-#define R1_WP_ERASE_SKIP        (1 << 15)       /* sx, c */
-#define R1_CARD_ECC_DISABLED    (1 << 14)       /* sx, a */
-#define R1_ERASE_RESET          (1 << 13)       /* sr, c */
-#define R1_STATUS(x)            (x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
-#define R1_READY_FOR_DATA       (1 << 8)        /* sx, a */
-#define R1_SWITCH_ERROR         (1 << 7)        /* sx, c */
-#define R1_APP_CMD              (1 << 5)        /* sr, c */
-
-#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR;
-#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
-				R1_ADDRESS_ERROR |	\
-				R1_BLOCK_LEN_ERROR |	\
-				R1_WP_VIOLATION |	\
-				R1_CARD_IS_LOCKED |	\
-				R1_COM_CRC_ERROR |	\
-				R1_ILLEGAL_COMMAND |	\
-				R1_CARD_ECC_FAILED |	\
-				R1_CC_ERROR |		\
-				R1_ERROR |		\
-				R1_UNDERRUN |		\
-				R1_OVERRUN
-
-/**
- * Flag indicates that CMD23 is supported.  This is required for multi-block
- * hardware transfers to work.
- */
-#define OCTEON_MMC_FLAG_SD_CMD23	1
-
-#ifdef __mips
-# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
-#endif
-
-/* Offsets of various registers */
-#define MIO_EMM_DMA_FIFO_CFG		0x0160
-#define MIO_EMM_DMA_FIFO_ADR		0x0170
-#define MIO_EMM_DMA_FIFO_CMD		0x0178
-#define MIO_EMM_DMA_CFG			0x0180
-#define MIO_EMM_DMA_ADR			0x0188
-#define MIO_EMM_DMA_INT			0x0190
-#define NDF_DMA_INT			(-1)	/** Not supported yet */
-#define MIO_EMM_DMA_INT_W1S		0x0198
-#ifdef __arm
-# define MIO_EMM_DMA_INT_ENA_W1S	0x01A0
-# define MIO_EMM_DMA_INT_ENA_W1C	0x01A8
-#endif
-#define MIO_EMM_CFG			0x2000
-#define MIO_EMM_MODEX(X)		(0x2008 + ((X) * 0x8))
-#ifdef __arm
-# define MIO_EMM_COMP			0x2040
-#endif
-#define MIO_EMM_SWITCH			0x2048
-#define MIO_EMM_DMA			0x2050
-#define MIO_EMM_CMD			0x2058
-#define MIO_EMM_RSP_STS			0x2060
-#define MIO_EMM_RSP_LO			0x2068
-#define MIO_EMM_RSP_HI			0x2070
-#define MIO_EMM_INT			0x2078
-#ifdef __arm
-# define MIO_EMM_INT_W1S		0x2080
-#endif
-#define MIO_EMM_WDOG			0x2088
-#define MIO_EMM_SAMPLE			0x2090
-#define MIO_EMM_STS_MASK		0x2098
-#define MIO_EMM_RCA			0x20A0
-#ifdef __arm
-# define MIO_EMM_INT_ENA_W1S		0x20B0
-# define MIO_EMM_INT_ENA_W1C		0x20B8
-#endif
-#define MIO_EMM_BUF_IDX			0x20E0
-#define MIO_EMM_BUF_DAT			0x20E8
-#define MIO_EMM_ACCESS_WDOG		0x20F0
-
-/** Maximum supported MMC slots */
-#define CAVIUM_MAX_MMC_SLOT		2
-
-#define CAVIUM_MMC_NAME_LEN		32
-
-struct mmc;
-struct mmc_config;
-struct cavium_mmc_host;
-struct cavium_mmc_slot;
-struct gpio_desc;
-
-struct cavium_mmc_slot {
-	char		name[CAVIUM_MMC_NAME_LEN];	/** Name of device */
-	uint8_t		ext_csd[512];	/** Extended CSD register */
-	struct mmc	*mmc;		/** Ptr back to mmc structure */
-	struct cavium_mmc_host *host;	/** Host controller data structure */
-	struct mmc_config cfg;		/** Slot configuration */
-	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
-	struct gpio_desc cd_gpio;	/** Card detect GPIO */
-	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
-	int		power_delay;	/** Time in usec to wait for power */
-	int		bus_id;		/** BUS ID of device */
-	int		of_offset;	/** Device tree node */
-	int		clk_period;	/** Clock period */
-	int		bus_max_width;	/** Bus width 1, 4 or 8 */
-	int		power_class;	/** Power class for device */
-	int		flags;
-	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
-	int		dat_clk_skew;	/** Clock skew for data in SCLK */
-	int		power_gpio_of_offset;	/** Offset of power node */
-	/**
-	 * Register bus-width value where:
-	 * 0: 1-bit
-	 * 1: 4-bit
-	 * 2: 8-bit
-	 * 5: 4-bit DDR
-	 * 6: 8-bit DDR
-	 * All other values are reserved.
-	 */
-	uint8_t		bus_width;
-	bool		non_removable:1;/** True if device is not removable */
-	bool		have_ext_csd:1;	/** True if have extended CSD register */
-	bool		sector_mode:1;	/** Sector or byte mode */
-	bool		powered:1;	/** True if powered on */
-	/** True if power GPIO is active high */
-	bool		power_active_high:1;
-	bool		ro_inverted:1;	/** True if write-protect is inverted */
-	bool		cd_inverted:1;	/** True if card-detect is inverted */
-};
-
-struct cavium_mmc_host {
-	void		*base_addr;	/** Base address of device */
-	pci_dev_t	pdev;		/** PCI device */
-	uint64_t	sclock;		/** SCLK in hz */
-	int		of_offset;	/** Device tree node */
-	int		cur_slotid;	/** Current slot to use */
-	int		last_slotid;	/** last slot in use */
-	int		max_width;	/** Maximum width hardware supports */
-#ifdef __mips
-	int		node;		/** OCX node for Octeon (MIPS) */
-	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
-#endif
-	bool		initialized;
-	struct udevice  *dev;		/** Device host is associated with */
-	/** Slots associated with host controller */
-	struct cavium_mmc_slot slots[CAVIUM_MAX_MMC_SLOT];
-};
-
-
-/* Register definitions */
-
-/**
- * Register (RSL) mio_emm_buf_dat
- *
- * eMMC Data Buffer Access Register
- */
-union mio_emm_buf_dat {
-	uint64_t u;
-	struct mio_emm_buf_dat_s {
-		/**
-		 * [ 63:  0](R/W/H) Direct access to the 1 KB data
-		 * buffer memory. Address specified by MIO_EMM_BUF_IDX.
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_buf_dat_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_buf_idx
- *
- * eMMC Data Buffer Address Register
- */
-union mio_emm_buf_idx {
-	uint64_t u;
-	struct mio_emm_buf_idx_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_17_63:47;
-		/**
-		 * [ 16: 16](R/W) Automatically advance [BUF_NUM]/[OFFSET]
-		 * after each access to MIO_EMM_BUF_DAT.  Wraps after the
-		 * last offset of the last data buffer.
-		 */
-		uint64_t inc:1;
-		uint64_t reserved_7_15:9;
-		/**
-		 * [ 6:  6](R/W/H) Specify the data buffer for the next
-		 * access to MIO_EMM_BUF_DAT.
-		 */
-		uint64_t buf_num:1;
-		/**
-		 * [  5:  0](R/W/H) Specify the 8B data buffer offset for
-		 * the next access to MIO_EMM_BUF_DAT.
-		 */
-		uint64_t offset:6;
-#else /* Word 0 - Little Endian */
-		uint64_t offset:6;
-		uint64_t buf_num:1;
-		uint64_t reserved_7_15:9;
-		uint64_t inc:1;
-		uint64_t reserved_17_63:47;
-#endif /* Word 0 - End */
-	} s;
-};
-
-/**
- * Register (RSL) mio_emm_cfg
- *
- * eMMC Configuration Register
- */
-union mio_emm_cfg {
-	uint64_t u;
-	struct mio_emm_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_4_63:60;
-		/**
-		 * [  3:  0](R/W) eMMC bus enable mask.
-		 *
-		 * Setting bit0 of [BUS_ENA] causes EMMC_CMD[0] to become
-		 * dedicated eMMC bus 0 command (i.e. disabling any NOR use).
-		 *
-		 * Setting bit1 of [BUS_ENA] causes EMMC_CMD[1] to become
-		 * dedicated eMMC bus 1 command (i.e. disabling any NOR use).
-		 *
-		 * Setting bit2 of [BUS_ENA] causes EMMC_CMD[2] to become
-		 * dedicated eMMC bus 2 command (i.e. disabling any NOR use).
-		 *
-		 * Bit3 of [BUS_ENA] is reserved.
-		 *
-		 * Clearing all bits of this field will reset the other
-		 * MIO_EMM_* registers.
-		 * To ensure a proper reset the BUS_ENA bits should be
-		 * cleared for a minimum of 2 EMMC_CLK periods.  This
-		 * period be determined by waiting twice the number of
-		 * coprocessor clocks specified in MIO_EMM_MODE0[CLK_HI]
-		 * and MIO_EMM_MODE0[CLK_LO].
-		 *
-		 * Setting one or more bits will enable EMMC_CLK operation.
-		 */
-		uint64_t bus_ena:4;
-#else /* Word 0 - Little Endian */
-		uint64_t bus_ena:4;
-		uint64_t reserved_4_63:60;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_cmd
- *
- * eMMC Command Register
- */
-union  mio_emm_cmd {
-	uint64_t u;
-	struct mio_emm_cmd_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/**
-		 * [ 62: 62](R/W) Controls when command is completed.
-		 * 0 = Command doesn't complete until card has dropped
-		 *     the BUSY signal.
-		 * 1 = Complete command regardless of the BUSY signal.
-		 *     Status of signal can be read in
-		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
-		 */
-		uint64_t skip_busy:1;
-		/** [ 61: 60](R/W) Specify the eMMC bus */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) Request valid. Software writes this bit
-		 * to a 1.  Hardware clears it when the operation completes.
-		 */
-		uint64_t cmd_val:1;
-		uint64_t reserved_56_58:3;
-		/**
-		 * [ 55: 55](R/W) Specify the data buffer to be used for a
-		 * block transfer.
-		 */
-		uint64_t dbuf:1;
-		/**
-		 * [ 54: 49](R/W/H) Debug only.  Specify the number of
-		 * 8-byte transfers used in the command.  Value is 64-OFFSET.
-		 * The block transfer still starts at the first byte in
-		 * the 512 B data buffer.
-		 * Software must ensure CMD16 has updated the card block
-		 * length.
-		 */
-		uint64_t offset:6;
-		uint64_t reserved_43_48:6;
-		/**
-		 * [ 42: 41](R/W) Command type override; typically zero.
-		 * Value is XOR'd with the default command type.  See
-		 * Command and Response Types for command types per command
-		 * index. Types are:
-		 * 0x0 = No data.
-		 * 0x1 = Read data into Dbuf.
-		 * 0x2 = Write data from Dbuf.
-		 * 0x3 = Reserved.
-		 */
-		uint64_t ctype_xor:2;
-		/**
-		 * [ 40: 38](R/W) Response type override; typically zero.
-		 * Value is XOR'd with default response type.  See
-		 * Command and Response Types for response types per command
-		 * index.
-		 * Types are:
-		 * 0x0 = No Response.
-		 * 0x1 = R1, 48 bits.
-		 * 0x2 = R2, 136 bits.
-		 * 0x3 = R3, 48 bits.
-		 * 0x4 = R4, 48 bits.
-		 * 0x5 = R5, 48 bits.
-		 * 0x6, 0x7 = Reserved.
-		 */
-		uint64_t rtype_xor:3;
-		/** [ 37: 32](R/W/H) eMMC command */
-		uint64_t cmd_idx:6;
-		/** [ 31:  0](R/W/H) eMMC command argument */
-		uint64_t arg:32;
-#else /* Word 0 - Little Endian */
-		uint64_t arg:32;
-		uint64_t cmd_idx:6;
-		uint64_t rtype_xor:3;
-		uint64_t ctype_xor:2;
-		uint64_t reserved_43_48:6;
-		uint64_t offset:6;
-		uint64_t dbuf:1;
-		uint64_t reserved_56_58:3;
-		uint64_t cmd_val:1;
-		uint64_t bus_id:2;
-		uint64_t skip_busy:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_cmd_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_comp
- *
- * eMMC Compensation Register
- */
-union mio_emm_comp {
-	uint64_t u;
-	struct mio_emm_comp_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_11_63:53;
-		/**
-		 * [ 10:  8](R/W) eMMC bus driver PCTL. Typical values:
-		 * 0x4 = 60 ohm.
-		 * 0x6 = 40 ohm.
-		 * 0x7 = 30 ohm.
-		 */
-		uint64_t pctl:3;
-
-		uint64_t reserved_3_7:5;
-		/**
-		 * [  2:  0](R/W) eMMC bus driver NCTL. Typical values:
-		 * 0x4 = 60 ohm.
-		 * 0x6 = 40 ohm.
-		 * 0x7 = 30 ohm.
-		 */
-		uint64_t nctl:3;
-#else /* Word 0 - Little Endian */
-		uint64_t nctl:3;
-		uint64_t reserved_3_7:5;
-		uint64_t pctl:3;
-		uint64_t reserved_11_63:53;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_comp_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma
- *
- * eMMC External DMA Configuration Register
- */
-union mio_emm_dma {
-	uint64_t u;
-	struct mio_emm_dma_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/**
-		 * [ 62: 62](R/W) Controls when DMA is completed.
-		 * 0 = DMA doesn't complete until card has dropped the BUSY
-		 *     signal.
-		 * 1 = Complete DMA after last transfer regardless of the BUSY
-		 *     signal.  Status of signal can be read in
-		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
-		 */
-		uint64_t skip_busy:1;
-		/** [ 61: 60](R/W) Specify the eMMC bus */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) Software writes this bit to a 1 to
-		 * indicate that hardware should perform the DMA
-		 * transfer.
-		 * Hardware clears this bit when the DMA operation
-		 * completes or is terminated.
-		 */
-		uint64_t dma_val:1;
-		/**
-		 * [ 58: 58](R/W/H) Specify CARD_ADDR and eMMC are using
-		 * sector (512 B) addressing.
-		 */
-		uint64_t sector:1;
-		/**
-		 * [ 57: 57](R/W) Do not perform any eMMC commands.  A DMA
-		 * read returns all 0s.  A DMA write tosses the data.
-		 * In the case of a failure, this can be used to unwind the
-		 * DMA engine.
-		 */
-		uint64_t dat_null:1;
-		/**
-		 * [ 56: 51](R/W) Number of 8-byte blocks of data that
-		 * must exist in the DBUF before starting the 512-byte
-		 * block transfer.  Zero indicates to wait for the
-		 * entire block.
-		 */
-		uint64_t thres:6;
-		/**
-		 * [ 50: 50](R/W) Set the reliable write parameter when
-		 * performing CMD23 (SET_BLOCK_COUNT) for a multiple block.
-		 */
-		uint64_t rel_wr:1;
-		/** [ 49: 49](R/W) Read/write bit (0 = read, 1 = write). */
-		uint64_t rw:1;
-		/**
-		 * [ 48: 48](R/W) Perform operation using a multiple block
-		 * command instead of a series of single block commands.
-		 */
-		uint64_t multi:1;
-		/**
-		 * [ 47: 32](R/W/H) Number of blocks to read/write.  Hardware
-		 * decrements the block count after each successful
-		 * block transfer.
-		 */
-		uint64_t block_cnt:16;
-		/**
-		 * [ 31:  0](R/W/H) Data address for media <= 2 GB is a 32-bit
-		 * byte address, and data address for media > 2 GB is a 32-bit
-		 * sector (512 B) address.  Hardware advances the card address
-		 * after each successful block transfer by 512 for byte
-		 * addressing and by 1 for sector addressing.
-		 */
-		uint64_t card_addr:32;
-#else /* Word 0 - Little Endian */
-		uint64_t card_addr:32;
-		uint64_t block_cnt:16;
-		uint64_t multi:1;
-		uint64_t rw:1;
-		uint64_t rel_wr:1;
-		uint64_t thres:6;
-		uint64_t dat_null:1;
-		uint64_t sector:1;
-		uint64_t dma_val:1;
-		uint64_t bus_id:2;
-		uint64_t skip_busy:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_adr
- *
- * eMMC DMA Address Register
- * This register sets the address for eMMC/SD flash transfers to/from memory.
- * Sixty-four-bit operations must be used to access this register.  This
- * register is updated by the DMA hardware and can be reloaded by the values
- * placed in the MIO_EMM_DMA_FIFO_ADR.
- */
-union mio_emm_dma_adr {
-	uint64_t u;
-	struct mio_emm_dma_adr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/** [ 48:  0](R/W/H) DMA engine IOVA. Must be 64-bit aligned. */
-		uint64_t adr:49;
-#else /* Word 0 - Little Endian */
-		uint64_t adr:49;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_adr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_cfg
- *
- * eMMC DMA Configuration Register
- * This register controls the internal DMA engine used with the eMMC/SD flash
- * controller. Sixty-four-bit operations must be used to access this register.
- * This register is updated by the hardware DMA engine and can also be reloaded
- * by writes to the MIO_EMM_DMA_FIFO_CMD register.
- */
-union mio_emm_dma_cfg {
-	uint64_t u;
-	struct mio_emm_dma_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		/** [ 63: 63](R/W/H) DMA engine enable. */
-		uint64_t en:1;
-		/** [ 62: 62](R/W/H) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		/**
-		 * [ 61: 61](R/W/H) DMA engine abort.  When set to 1, DMA is
-		 * aborted and EN is cleared on completion.
-		 */
-		uint64_t clr:1;
-		uint64_t reserved_60:1;
-		/** [ 59: 59](R/W/H) DMA engine 32-bit swap. */
-		uint64_t swap32:1;
-		/** [ 58: 58](R/W/H) DMA engine enable 16-bit swap. */
-		uint64_t swap16:1;
-		/** [ 57: 57](R/W/H) DMA engine enable 8-bit swap. */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W/H) DMA engine endian mode: 0 = big-endian,
-		 * 1 = little-endian.
-		 */
-		uint64_t endian:1;
-		/**
-		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
-		 * 64-bit transfers (encoded in -1 notation).  For example, to
-		 * transfer 512 bytes, SIZE = 64 - 1 = 63.
-		 */
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t reserved_60:1;
-		uint64_t clr:1;
-		uint64_t rw:1;
-		uint64_t en:1;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_adr
- *
- * eMMC Internal DMA FIFO Address Register
- * This register specifies the internal address that is loaded into the eMMC
- * internal DMA FIFO.  The FIFO is used to queue up operations for the
- * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
- */
-union mio_emm_dma_fifo_adr {
-	uint64_t u;
-	struct mio_emm_dma_fifo_adr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/** [ 48:  3](R/W) DMA engine IOVA. Must be 64-bit aligned. */
-		uint64_t adr:46;
-		uint64_t reserved_0_2:3;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_2:3;
-		uint64_t adr:46;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_fifo_adr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cfg
- *
- * eMMC Internal DMA FIFO Configuration Register
- * This register controls DMA FIFO Operations.
- */
-union mio_emm_dma_fifo_cfg {
-	uint64_t u;
-	struct mio_emm_dma_fifo_cfg_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_17_63:47;
-		/**
-		 * [ 16: 16](R/W) DMA FIFO Clear. When set erases all commands
-		 * in the DMA FIFO. Must be zero for normal operation.
-		 */
-		uint64_t clr:1;
-		uint64_t reserved_13_15:3;
-		/**
-		 * [ 12:  8](R/W) Interrupt threshold indicating the number of
-		 * entries remaining in the DMA FIFO.  An interrupt occurs if
-		 * the FIFO is read at the level specified.
-		 * A value of 0 disables the interrupt.  A value of 17 or
-		 * greater will cause an interrupt only if the FIFO is
-		 * overflowed.
-		 * See MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t int_lvl:5;
-		uint64_t reserved_5_7:3;
-		/**
-		 * [  4:  0](RO/H) Number of entries in the DMA FIFO.  This
-		 * count is incremented by writes to the MIO_EMM_DMA_FIFO_CMD
-		 * register and decremented each time the internal DMA engine
-		 * completes the previous command successfully.
-		 *
-		 * Up to 16 entries can be placed in the FIFO.  Entries written
-		 * to a full FIFO will potentially corrupt existing entries.
-		 * Care must be taken by software to insure that this condition
-		 * does not occur.
-		 */
-		uint64_t count:5;
-#else /* Word 0 - Little Endian */
-		uint64_t count:5;
-		uint64_t reserved_5_7:3;
-		uint64_t int_lvl:5;
-		uint64_t reserved_13_15:3;
-		uint64_t clr:1;
-		uint64_t reserved_17_63:47;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_fifo_cfg_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_fifo_cmd
- *
- * eMMC Internal DMA FIFO Command Register
- * This register specifies a command that is loaded into the eMMC internal DMA
- * FIFO.  The FIFO is used to queue up operations for the
- * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.  Writes
- * to this register store both the MIO_EMM_DMA_FIFO_CMD and the
- * MIO_EMM_DMA_FIFO_ADR contents into the FIFO and increment the
- * MIO_EMM_DMA_FIFO_CFG[COUNT] field.
- *
- * Note: This register has a similar format to the MIO_EMM_DMA_CFG register with
- * the exception that the EN and CLR fields are absent.  These are supported in
- * the MIO_EMM_DMA_FIFO_CFG.
- */
-union mio_emm_dma_fifo_cmd {
-	uint64_t u;
-	struct mio_emm_dma_fifo_cmd_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		uint64_t reserved_61:1;
-		/**
-		 * [ 60: 60](R/W) DMA command interrupt disable.  When set, the
-		 * DMA command being submitted will not generate a
-		 * MIO_EMM_DMA_INT[DONE] interrupt when it completes.  When
-		 * cleared the command will generate the interrupt.
-		 *
-		 * For example, this field can be set for all the DMA commands
-		 * submitted to the DMA FIFO in the case of a write to the eMMC
-		 * device because the MIO_EMM_INT[DMA_DONE] interrupt would
-		 * signify the end of the operation.  It could be cleared on the
-		 * last DMA command being submitted to the DMA FIFO and the
-		 * MIO_EMM_DMA_INT[DONE] would occur when the read data from the
-		 * eMMC device was available in local memory.
-		 */
-		uint64_t intdis:1;
-		/**
-		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
-		 *  See [ENDIAN].
-		 */
-		uint64_t swap32:1;
-		/**
-		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap16:1;
-		/**
-		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W) DMA engine endian mode:
-		 *  0 = little-endian
-		 *  1 = big-endian
-		 * Using 0..7 to identify bytes.
-		 *
-		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
-		 * 0        0        0      0       7 6 5 4 3 2 1 0
-		 * 0        0        1      0       6 7 4 5 2 3 0 1
-		 * 0        1        0      0       5 4 7 6 1 0 3 2
-		 * 1        0        0      0       3 2 1 0 7 6 5 4
-		 * 0        0        0      1       0 1 2 3 4 5 6 7
-		 * 0        0        1      1       1 0 3 2 5 4 7 6
-		 * 0        1        0      1       2 3 0 1 6 7 4 5
-		 * 1        0        0      1       4 5 6 7 0 1 2 3
-		 */
-		uint64_t endian:1;
-		/**
-		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
-		 * 64-bit transfers (encoded in -1 notation).  For
-		 * example, to transfer 512 bytes, SIZE = 64 - 1 = 63.
-		 */
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t intdis:1;
-		uint64_t reserved_61:1;
-		uint64_t rw:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} s;
-	struct mio_emm_dma_fifo_cmd_cn88xxp1 {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_63:1;
-		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
-		uint64_t rw:1;
-		uint64_t reserved_61:1;
-		uint64_t reserved_60:1;
-		/**
-		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap32:1;
-		/**
-		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap16:1;
-		/**
-		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
-		 * See [ENDIAN].
-		 */
-		uint64_t swap8:1;
-		/**
-		 * [ 56: 56](R/W) DMA engine endian mode:
-		 *  0 = little-endian
-		 *  1 = big-endian
-		 * Using 0..7 to identify bytes.
-		 *
-		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
-		 * 0        0        0      0       7 6 5 4 3 2 1 0
-		 * 0        0        1      0       6 7 4 5 2 3 0 1
-		 * 0        1        0      0       5 4 7 6 1 0 3 2
-		 * 1        0        0      0       3 2 1 0 7 6 5 4
-		 * 0        0        0      1       0 1 2 3 4 5 6 7
-		 * 0        0        1      1       1 0 3 2 5 4 7 6
-		 * 0        1        0      1       2 3 0 1 6 7 4 5
-		 * 1        0        0      1       4 5 6 7 0 1 2 3
-		 */
-		uint64_t endian:1;
-		uint64_t size:20;
-		uint64_t reserved_0_35:36;
-#else /* Word 0 - Little Endian */
-		uint64_t reserved_0_35:36;
-		uint64_t size:20;
-		uint64_t endian:1;
-		uint64_t swap8:1;
-		uint64_t swap16:1;
-		uint64_t swap32:1;
-		uint64_t reserved_60:1;
-		uint64_t reserved_61:1;
-		uint64_t rw:1;
-		uint64_t reserved_63:1;
-#endif /* Word 0 - End */
-	} cn88xxp1;
-	/* struct mio_emm_dma_fifo_cmd_s cn9; */
-	/* struct mio_emm_dma_fifo_cmd_s cn81xx; */
-	/* struct mio_emm_dma_fifo_cmd_s cn83xx; */
-	/* struct mio_emm_dma_fifo_cmd_s cn88xxp2; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int
- *
- * eMMC DMA Interrupt Register
- * Sixty-four-bit operations must be used to access this register.
- */
-union mio_emm_dma_int {
-	uint64_t u;
-	struct mio_emm_dma_int_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1C/H) Internal DMA FIFO has dropped to level
-		 * specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1C/H) Internal DMA engine request completion
-		 * interrupt.
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1c
- *
- * eMMC DMA Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
- */
-union mio_emm_dma_int_ena_w1c {
-	uint64_t u;
-	struct mio_emm_dma_int_ena_w1c_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_DMA_INT[DONE].
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_ena_w1c_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_ena_w1s
- *
- * eMMC DMA Interrupt Enable Set Register
- * This register sets interrupt enable bits.
- */
-union mio_emm_dma_int_ena_w1s {
-	uint64_t u;
-	struct mio_emm_dma_int_ena_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/**
-		 * [  1:  1](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_DMA_INT[FIFO].
-		 */
-		uint64_t fifo:1;
-		/**
-		 * [  0:  0](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_DMA_INT[DONE].
-		 */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_ena_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_dma_int_w1s
- *
- * eMMC DMA Interrupt Set Register
- * This register sets interrupt bits.
- */
-union mio_emm_dma_int_w1s {
-	uint64_t u;
-	struct mio_emm_dma_int_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_2_63:62;
-		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[FIFO]. */
-		uint64_t fifo:1;
-		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[DONE]. */
-		uint64_t done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t done:1;
-		uint64_t fifo:1;
-		uint64_t reserved_2_63:62;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_dma_int_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int
- *
- * eMMC Interrupt Register
- */
-union mio_emm_int {
-	uint64_t u;
-	struct mio_emm_int_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/** [  6:  6](R/W1C/H) Switch operation encountered an error. */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1C/H) Switch operation completed successfully.
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1C/H) External DMA transfer encountered an
-		 * error. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1C/H) Operation specified by MIO_EMM_CMD
-		 * encountered an error. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t cmd_err:1;
-		/**
-		 * [  2:  2](R/W1C/H) External DMA transfer completed
-		 * successfully.
-		 */
-		uint64_t dma_done:1;
-		/** [  1:  1](R/W1C/H) Operation specified by MIO_EMM_CMD
-		 * completed successfully.
-		 */
-		uint64_t cmd_done:1;
-		/**
-		 * [  0:  0](R/W1C/H) The next 512B block transfer of a
-		 * multiblock transfer has completed.
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_ena_w1c
- *
- * eMMC Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
- */
-union mio_emm_int_ena_w1c {
-	uint64_t u;
-	struct mio_emm_int_ena_w1c_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/**
-		 * [  6:  6](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[SWITCH_ERR].
-		 */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[DMA_ERR].
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[CMD_ERR].
-		 */
-		uint64_t cmd_err:1;
-		/**
-		 * [  2:  2](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[DMA_DONE].
-		 */
-		uint64_t dma_done:1;
-		/**
-		 * [  1:  1](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[CMD_DONE].
-		 */
-		uint64_t cmd_done:1;
-		/** [  0:  0](R/W1C/H) Reads or clears enable for
-		 * MIO_EMM_INT[BUF_DONE].
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_ena_w1c_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_ena_w1s
- *
- * eMMC Interrupt Enable Set Register
- * This register sets interrupt enable bits.
- */
-union mio_emm_int_ena_w1s {
-	uint64_t u;
-	struct mio_emm_int_ena_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/**
-		 * [  6:  6](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[SWITCH_ERR].
-		 */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/**
-		 * [  4:  4](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[DMA_ERR].
-		 */
-		uint64_t dma_err:1;
-		/**
-		 * [  3:  3](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[CMD_ERR].
-		 */
-		uint64_t cmd_err:1;
-		/** [  2:  2](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[DMA_DONE].
-		 */
-		uint64_t dma_done:1;
-		/**
-		 * [  1:  1](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[CMD_DONE].
-		 */
-		uint64_t cmd_done:1;
-		/**
-		 * [  0:  0](R/W1S/H) Reads or sets enable for
-		 * MIO_EMM_INT[BUF_DONE].
-		 */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_ena_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_int_w1s
- *
- * eMMC Interrupt Set Register
- * This register sets interrupt bits.
- */
-union mio_emm_int_w1s {
-	uint64_t u;
-	struct mio_emm_int_w1s_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_7_63:57;
-		/** [  6:  6](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_ERR]. */
-		uint64_t switch_err:1;
-		/**
-		 * [  5:  5](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_DONE].
-		 */
-		uint64_t switch_done:1;
-		/** [  4:  4](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_ERR]. */
-		uint64_t dma_err:1;
-		/** [  3:  3](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_ERR]. */
-		uint64_t cmd_err:1;
-		/** [  2:  2](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_DONE]. */
-		uint64_t dma_done:1;
-		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_DONE]. */
-		uint64_t cmd_done:1;
-		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_INT[BUF_DONE]. */
-		uint64_t buf_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t buf_done:1;
-		uint64_t cmd_done:1;
-		uint64_t dma_done:1;
-		uint64_t cmd_err:1;
-		uint64_t dma_err:1;
-		uint64_t switch_done:1;
-		uint64_t switch_err:1;
-		uint64_t reserved_7_63:57;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_int_w1s_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_mode#
- *
- * eMMC Operating Mode Register
- */
-union mio_emm_modex {
-	uint64_t u;
-	struct mio_emm_modex_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/**
-		 * [ 48: 48](RO/H) Current high-speed timing mode.  Required
-		 * when CLK frequency is higher than 20 MHz.
-		 */
-		uint64_t hs_timing:1;
-		uint64_t reserved_43_47:5;
-		/**
-		 * [ 42: 40](RO/H) Current card bus mode. Out of reset, the
-		 * card is in 1-bit data bus mode. Select bus width.
-		 * 0x0 = 1-bit data b*us (power on).
-		 * 0x1 = 4-bit data bus.
-		 * 0x2 = 8-bit data bus.
-		 * 0x3 = Reserved.
-		 * 0x4 = Reserved.
-		 * 0x5 = 4-bit data bus (dual data rate).
-		 * 0x6 = 8-bit data bus (dual data rate).
-		 * 0x7 = Reserved.
-		 * 0x8 = Reserved.
-		 */
-		uint64_t bus_width:3;
-		uint64_t reserved_36_39:4;
-		/**
-		 * [ 35: 32](RO/H) Out of reset, the card power class is 0,
-		 * which is the minimum current consumption class for the card.
-		 * EXT_CSD bytes [203:200] and [239:238] contain the power class
-		 * for different BUS_WITDH and CLK frequencies.  Software should
-		 * write this field with the 4-bit field from the EXT_CSD bytes
-		 * corresponding to the selected operating mode.
-		 */
-		uint64_t power_class:4;
-		/**
-		 * [ 31: 16](RO/H) Current number of coprocessor-clocks to hold
-		 * the eMMC CLK pin high.
-		 */
-		uint64_t clk_hi:16;
-		/**
-		 * [ 15:  0](RO/H) Current number of coprocessor-clocks to
-		 * hold the eMMC CLK pin low.
-		 */
-		uint64_t clk_lo:16;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_lo:16;
-		uint64_t clk_hi:16;
-		uint64_t power_class:4;
-		uint64_t reserved_36_39:4;
-		uint64_t bus_width:3;
-		uint64_t reserved_43_47:5;
-		uint64_t hs_timing:1;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_modex_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_pba#
- *
- * eMMC MSI-X Pending Bit Array Registers
- * This register is the MSI-X PBA table; the bit number is indexed by the
- * MIO_EMM_INT_VEC_E enumeration.
- */
-union mio_emm_msix_pbax {
-	uint64_t u;
-	struct mio_emm_msix_pbax_s {
-		/**
-		 * [ 63:  0](RO/H) Pending message for the associated
-		 * MIO_EMM_MSIX_VEC()_CTL, enumerated by MIO_EMM_INT_VEC_E.
-		 * Bits that have no associated MIO_EMM_INT_VEC_E are 0.
-		 */
-		uint64_t pend:64;
-	} s;
-	/* struct mio_emm_msix_pbax_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_vec#_addr
- *
- * eMMC MSI-X Vector-Table Address Register
- * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
- * enumeration.
- */
-union mio_emm_msix_vecx_addr {
-	uint64_t u;
-	struct mio_emm_msix_vecx_addr_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_49_63:15;
-		/**
-		 * [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector.
-		 */
-		uint64_t addr:47;
-		uint64_t reserved_1:1;
-		/**
-		 * [  0:  0](SR/W) Secure vector.
-		 * 0 = This vector may be read or written by either secure or
-		 *     nonsecure states.
-		 * 1 = This vector's MIO_EMM_MSIX_VEC()_ADDR,
-		 *     MIO_EMM_MSIX_VEC()_CTL, and corresponding bit of
-		 *     MIO_EMM_MSIX_PBA() are RAZ/WI and does not cause a fault
-		 *     when accessed by the nonsecure world.
-		 *
-		 * If PCCPF_MIO_EMM_VSEC_SCTL[MSIX_SEC] (for documentation, see
-		 * PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is set, all vectors are secure
-		 * and function as if [SECVEC] was set.
-		 */
-		uint64_t secvec:1;
-#else /* Word 0 - Little Endian */
-		uint64_t secvec:1;
-		uint64_t reserved_1:1;
-		uint64_t addr:47;
-		uint64_t reserved_49_63:15;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_msix_vecx_addr_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_msix_vec#_ctl
- *
- * eMMC MSI-X Vector-Table Control and Data Register
- * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
- * enumeration.
- */
-union mio_emm_msix_vecx_ctl {
-	uint64_t u;
-	struct mio_emm_msix_vecx_ctl_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_33_63:31;
-		/**
-		 * [ 32: 32](R/W) When set, no MSI-X interrupts are sent to this
-		 * vector.
-		 */
-		uint64_t mask:1;
-		uint64_t reserved_20_31:12;
-		/**
-		 * [ 19:  0](R/W) Data to use for MSI-X delivery of this vector.
-		 */
-		uint64_t data:20;
-#else /* Word 0 - Little Endian */
-		uint64_t data:20;
-		uint64_t reserved_20_31:12;
-		uint64_t mask:1;
-		uint64_t reserved_33_63:31;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_msix_vecx_ctl_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rca
- *
- * eMMC Relative Card Address Register
- */
-union mio_emm_rca {
-	uint64_t u;
-	struct mio_emm_rca_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_16_63:48;
-		/**
-		 * [ 15:  0](R/W/H) Whenever software performs CMD7, hardware
-		 * updates [CARD_RCA] with the relative card address from the
-		 * MIO_EMM_CMD[ARG], unless the operation encounters an error.
-		 */
-		uint64_t card_rca:16;
-#else /* Word 0 - Little Endian */
-		uint64_t card_rca:16;
-		uint64_t reserved_16_63:48;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_rca_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_hi
- *
- * eMMC Response Data High Register
- */
-union mio_emm_rsp_hi {
-	uint64_t u;
-	struct mio_emm_rsp_hi_s {
-		/**
-		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
-		 * SD Specifications):
-		 * _ RSP_TYPE = 1: DAT[63:0] = 0x0.   *
-		 * _ RSP_TYPE = 2: DAT[63:0] = CID[127:64] or CSD[127:64].
-		 * _ RSP_TYPE = 3: DAT[63:0] = 0x0.
-		 * _ RSP_TYPE = 4: DAT[63:0] = 0x0.
-		 * _ RSP_TYPE = 5: DAT[63:0] = 0x0.
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_rsp_hi_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_lo
- *
- * eMMC Response Data Low Register
- */
-union mio_emm_rsp_lo {
-	uint64_t u;
-	struct mio_emm_rsp_lo_s {
-		/**
-		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
-		 * SD Specifications).
-		 *
-		 *
-		 * RSP_TYPE = 1:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = Command index
-		 * DAT[39: 8] = Card status
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 2:
-		 * DAT[63: 1] = CID[63:1] or CSD[63:1] including CRC
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 3:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = Check bits (0x3F)
-		 * DAT[39: 8] = OCR register
-		 * DAT[ 7: 1] = Check bits (0x7F)
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 4:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = CMD39 ('10111')
-		 * DAT[39:24] = RCA[31:16]
-		 * DAT[   23] = Status
-		 * DAT[22:16] = Register address
-		 * DAT[15: 8] = Register contents
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 *
-		 * RSP_TYPE = 5:
-		 * DAT[63:46] = 0x0
-		 * DAT[45:40] = CMD40 ('10100')
-		 * DAT[39:24] = RCA[31:16]
-		 * DAT[   23] = Status
-		 * DAT[22:16] = Register address
-		 * DAT[15: 8] = Not defined. May be used for IRQ data
-		 * DAT[ 7: 1] = CRC7
-		 * DAT[    0] = End bit
-		 */
-		uint64_t dat:64;
-	} s;
-	/* struct mio_emm_rsp_lo_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_rsp_sts
- *
- * eMMC Response Status Register
- */
-union mio_emm_rsp_sts {
-	uint64_t u;
-	struct mio_emm_rsp_sts_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_62_63:2;
-		/**
-		 * [ 61: 60](RO/H) eMMC bus ID to which the response status
-		 * corresponds.
-		 */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](RO/H) Read-only copy of MIO_EMM_CMD[CMD_VAL].
-		 * [CMD_VAL] = 1 indicates that a direct operation is in
-		 * progress.
-		 */
-		uint64_t cmd_val:1;
-		/**
-		 * [ 58: 58](RO/H) Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE].
-		 * [SWITCH_VAL] = 1 indicates that a switch operation is in
-		 * progress.
-		 */
-		uint64_t switch_val:1;
-		/**
-		 * [ 57: 57](RO/H) Read-only copy of MIO_EMM_DMA[DMA_VAL].
-		 * [DMA_VAL] = 1 indicates that a DMA operation is in progress.
-		 */
-		uint64_t dma_val:1;
-		/**
-		 * [ 56: 56](RO/H) The DMA engine has a pending transfer
-		 * resulting from an error. Software can resume the transfer by
-		 * writing MIO_EMM_DMA[DMA_VAL] = 1.
-		 *
-		 * Software can terminate the transfer by writing
-		 * MIO_EMM_DMA[DMA_VAL] = 1 and MIO_EMM_DMA[DAT_NULL] = 1.
-		 * Hardware will then clear [DMA_PEND] and perform the DMA
-		 * operation.
-		 */
-		uint64_t dma_pend:1;
-		/**
-		 * [ 55: 55](RO/H) The store operation to the device took longer
-		 * than MIO_EMM_ACCESS_WDOG[CLK_CNT] coprocessor-clocks to
-		 * complete.
-		 * Valid when [DMA_PEND] is set.
-		 */
-		uint64_t acc_timeout:1;
-		uint64_t reserved_29_54:26;
-		/**
-		 * [ 28: 28](RO/H) For [CMD_TYPE] = 1, indicates that a DMA read
-		 * data arrived from the card without a free DBUF.  For
-		 * [CMD_TYPE] = 2, indicates a DBUF underflow occurred during a
-		 * DMA write. See MIO_EMM_DMA[THRES].
-		 */
-		uint64_t dbuf_err:1;
-		uint64_t reserved_24_27:4;
-		/**
-		 * [ 23: 23](RO/H) DBUF corresponding to the most recently
-		 * attempted block transfer.
-		 */
-		uint64_t dbuf:1;
-		/**
-		 * [ 22: 22](RO/H) Timeout waiting for read data or 3-bit CRC
-		 * token.
-		 */
-		uint64_t blk_timeout:1;
-		/**
-		 * [ 21: 21](RO/H) For [CMD_TYPE] = 1, indicates a card read
-		 * data CRC mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the
-		 * failing data buffer.
-		 *
-		 * For [CMD_TYPE] = 2, indicates card returned 3-bit CRC status
-		 * token indicating that the card encountered a write data CRC
-		 * check mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the failing
-		 * data buffer.
-		 */
-		uint64_t blk_crc_err:1;
-		/**
-		 * [ 20: 20](RO/H) Debug only. eMMC protocol utilizes DAT0 as a
-		 * busy signal during block writes and R1b responses.  This bit
-		 * should read zero before any DMA or Command with data is
-		 * executed.
-		 */
-		uint64_t rsp_busybit:1;
-		/** [ 19: 19](RO/H) Stop transmission response timeout. */
-		uint64_t stp_timeout:1;
-		/**
-		 * [ 18: 18](RO/H) Stop transmission response had a CRC error.
-		 */
-		uint64_t stp_crc_err:1;
-		/**
-		 * [ 17: 17](RO/H) Stop transmission response had bad status.
-		 */
-		uint64_t stp_bad_sts:1;
-		/** [ 16: 16](RO/H) Stop transmission response valid. */
-		uint64_t stp_val:1;
-		/** [ 15: 15](RO/H) Response timeout. */
-		uint64_t rsp_timeout:1;
-		/** [ 14: 14](RO/H) Response CRC error. */
-		uint64_t rsp_crc_err:1;
-		/** [ 13: 13](RO/H) Response bad status. */
-		uint64_t rsp_bad_sts:1;
-		/**
-		 * [ 12: 12](RO/H) Response ID.  See
-		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
-		 */
-		uint64_t rsp_val:1;
-		/**
-		 * [ 11:  9](RO/H) Indicates the response type.  See
-		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
-		 */
-		uint64_t rsp_type:3;
-		/**
-		 * [  8:  7](RO/H) eMMC command type.
-		 * 0x0 = No data.
-		 * 0x1 = Read.
-		 * 0x2 = Write.
-		 */
-		uint64_t cmd_type:2;
-		/**
-		 * [  6:  1](RO/H) eMMC command index most recently attempted.
-		 */
-		uint64_t cmd_idx:6;
-		/**
-		 * [  0:  0](RO/H) eMMC command completed.  Once the command has
-		 * completed, the status is final and can be examined by
-		 * software.
-		 */
-		uint64_t cmd_done:1;
-#else /* Word 0 - Little Endian */
-		uint64_t cmd_done:1;
-		uint64_t cmd_idx:6;
-		uint64_t cmd_type:2;
-		uint64_t rsp_type:3;
-		uint64_t rsp_val:1;
-		uint64_t rsp_bad_sts:1;
-		uint64_t rsp_crc_err:1;
-		uint64_t rsp_timeout:1;
-		uint64_t stp_val:1;
-		uint64_t stp_bad_sts:1;
-		uint64_t stp_crc_err:1;
-		uint64_t stp_timeout:1;
-		uint64_t rsp_busybit:1;
-		uint64_t blk_crc_err:1;
-		uint64_t blk_timeout:1;
-		uint64_t dbuf:1;
-		uint64_t reserved_24_27:4;
-		uint64_t dbuf_err:1;
-		uint64_t reserved_29_54:26;
-		uint64_t acc_timeout:1;
-		uint64_t dma_pend:1;
-		uint64_t dma_val:1;
-		uint64_t switch_val:1;
-		uint64_t cmd_val:1;
-		uint64_t bus_id:2;
-		uint64_t reserved_62_63:2;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_rsp_sts_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_sample
- *
- * eMMC Sampling Register
- */
-union mio_emm_sample {
-	uint64_t u;
-	struct mio_emm_sample_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_26_63:38;
-		/**
-		 * [ 25: 16](R/W) Number of coprocessor-clocks before the eMMC
-		 * clock rising edge to sample the command pin.
-		 */
-		uint64_t cmd_cnt:10;
-		uint64_t reserved_10_15:6;
-		/**
-		 * [  9:  0](R/W) Number of coprocessor-clocks before the eMMC
-		 * clock edge to sample the data pin.
-		 */
-		uint64_t dat_cnt:10;
-#else /* Word 0 - Little Endian */
-		uint64_t dat_cnt:10;
-		uint64_t reserved_10_15:6;
-		uint64_t cmd_cnt:10;
-		uint64_t reserved_26_63:38;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_sample_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_sts_mask
- *
- * eMMC Status Mask Register
- */
-union mio_emm_sts_mask {
-	uint64_t u;
-	struct mio_emm_sts_mask_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_32_63:32;
-		/**
-		 * [ 31:  0](R/W) Any bit set in [STS_MSK] causes the
-		 * corresponding bit in the card status to be considered when
-		 * computing response bad status.
-		 */
-		uint64_t sts_msk:32;
-#else /* Word 0 - Little Endian */
-		uint64_t sts_msk:32;
-		uint64_t reserved_32_63:32;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_sts_mask_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_switch
- *
- * eMMC Operating Mode Switch Register
- */
-union mio_emm_switch {
-	uint64_t u;
-	struct mio_emm_switch_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_62_63:2;
-		/** [ 61: 60](R/W/H) Specifies the eMMC bus id. */
-		uint64_t bus_id:2;
-		/**
-		 * [ 59: 59](R/W/H) When clear, the operating modes are updated
-		 * directly without performing any SWITCH operations.  This
-		 * allows software to perform the SWITCH operations manually,
-		 * then update the hardware.
-		 *
-		 * Software writes this bit to a 1 to indicate that hardware
-		 * should perform the necessary SWITCH operations.
-		 *
-		 * First, the POWER_CLASS switch is performed.  If it fails,
-		 * [SWITCH_ERR0] is set and the remaining SWITCH operations are
-		 * not performed.  If it succeeds, [POWER_CLASS] is updated and
-		 * the HS_TIMING switch is performed.
-		 *
-		 * If the HS_TIMING switch fails, [SWITCH_ERR1] is set and the
-		 * remaining SWITCH operations are not performed.  If it
-		 * succeeds, [HS_TIMING] is updated and the BUS_WIDTH switch
-		 * operation is performed.
-		 *
-		 * If the BUS_WIDTH switch operation fails, [SWITCH_ERR2] is
-		 * set.  If it succeeds, the BUS_WITDH is updated.
-		 *
-		 * Changes to CLK_HI and CLK_LO are discarded if any SWITCH_ERR
-		 * occurs.
-		 */
-		uint64_t switch_exe:1;
-		/**
-		 * [ 58: 58](RO/H) Error encountered while performing
-		 * POWER_CLASS switch. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err0:1;
-		/**
-		 * [ 57: 57](RO/H) Error encountered while performing HS_TIMING
-		 * switch.  See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err1:1;
-		/**
-		 * [ 56: 56](RO/H) Error encountered while performing BUS_WIDTH
-		 * switch. See MIO_EMM_RSP_STS.
-		 */
-		uint64_t switch_err2:1;
-		uint64_t reserved_49_55:7;
-		/** [ 48: 48](R/W) Requested update to HS_TIMING. */
-		uint64_t hs_timing:1;
-		uint64_t reserved_43_47:5;
-		/** [ 42: 40](R/W) Requested update to BUS_WIDTH. */
-		uint64_t bus_width:3;
-		uint64_t reserved_36_39:4;
-		/** [ 35: 32](R/W) Requested update to POWER_CLASS. */
-		uint64_t power_class:4;
-		/** [ 31: 16](R/W) Requested update to CLK_HI. */
-		uint64_t clk_hi:16;
-		/** [ 15:  0](R/W) Requested update to CLK_LO. */
-		uint64_t clk_lo:16;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_lo:16;
-		uint64_t clk_hi:16;
-		uint64_t power_class:4;
-		uint64_t reserved_36_39:4;
-		uint64_t bus_width:3;
-		uint64_t reserved_43_47:5;
-		uint64_t hs_timing:1;
-		uint64_t reserved_49_55:7;
-		uint64_t switch_err2:1;
-		uint64_t switch_err1:1;
-		uint64_t switch_err0:1;
-		uint64_t switch_exe:1;
-		uint64_t bus_id:2;
-		uint64_t reserved_62_63:2;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_switch_s cn; */
-};
-
-/**
- * Register (RSL) mio_emm_wdog
- *
- * eMMC Watchdog Register
- */
-union mio_emm_wdog {
-	uint64_t u;
-	struct mio_emm_wdog_s {
-#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
-		uint64_t reserved_26_63:38;
-		/**
-		 * [ 25:  0](R/W) Maximum number of CLK_CNT cycles to wait for
-		 * the card to return a response, read data, or the 3-bit CRC
-		 * status token following write data.  The following timeouts
-		 * are detected:
-		 *
-		 * Expected response to a command doesn't occur causing
-		 * MIO_EMM_RSP_STS[RSP_TIMEOUT].
-		 *
-		 * On a read command, expected data isn't returned causing
-		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * On a multi read command, expected data isn't returned causing
-		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * On a write command, expected token to a write block isn't
-		 * received causing MIO_EMM_RSP_STS[BLK_TIMEOUT].
-		 *
-		 * If a stop command is issued by the hardware and no response
-		 * is returned causing MIO_EMM_RSP_STS[STP_TIMEOUT].
-		 *
-		 * Issues this timeout doesn't cover are stalls induced by the
-		 * card which are not limited by the specifications.
-		 * For example, when a write multi command is issued to the card
-		 * and a block (not the last) is transferred the card can
-		 * "stall" CNXXXX by forcing emmc_data<0> low for as long as
-		 * it wants to free up buffer space.
-		 *
-		 * The second case is when the last block of a write or multi
-		 * write is being transferred and the card elects to perform
-		 * some background tasks. The same stall mechanism with
-		 * emmc_data<0> is used but this can last for an extend time
-		 * period.
-		 */
-		uint64_t clk_cnt:26;
-#else /* Word 0 - Little Endian */
-		uint64_t clk_cnt:26;
-		uint64_t reserved_26_63:38;
-#endif /* Word 0 - End */
-	} s;
-	/* struct mio_emm_wdog_s cn; */
-};
-
-/**
- * Returns the card write protect status
- *
- * @param mmc	pointer to mmc data structure
- * @return 1 if card is write protected, 0 otherwise
- */
-int cavium_mmc_getwp(struct udevice *dev);
-
-/**
- * Gets the card-detect status
- *
- * @param mmc	pointer to mmc data structure
- *
- * @return	1 if card is detected, false if not detected.
- */
-int cavium_mmc_getcd(struct udevice *dev);
-
-
-#endif /* __OCTEON_MMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
new file mode 100644
index 0000000000..9d2ea976d6
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
@@ -0,0 +1,1197 @@
+#ifndef __CAVM_CSRS_MIO_EMM_H__
+#define __CAVM_CSRS_MIO_EMM_H__
+/* This file is auto-generated. Do not edit */
+
+/***********************license start***************
+ * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com).  All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export
+ * control laws, including the U.S. Export Administration Act and its
+ * associated regulations, and may be subject to export or import regulations
+ * in other countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS
+ * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
+ * RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR
+ * PATENT DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY)
+ * WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
+ * PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
+ * ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE
+ * RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium MIO_EMM.
+ *
+ * This file is auto generated. Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define CAVM_MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define CAVM_MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union cavm_mio_emm_access_wdog {
+	u64 u;
+	struct cavm_mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union cavm_mio_emm_buf_dat {
+	u64 u;
+	struct cavm_mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union cavm_mio_emm_buf_idx {
+	u64 u;
+	struct cavm_mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union cavm_mio_emm_calb {
+	u64 u;
+	struct cavm_mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_mio_emm_calb_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union cavm_mio_emm_cfg {
+	u64 u;
+	struct cavm_mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_mio_emm_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union cavm_mio_emm_cmd {
+	u64 u;
+	struct cavm_mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_mio_emm_cmd_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union cavm_mio_emm_comp {
+	u64 u;
+	struct cavm_mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_mio_emm_comp_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union cavm_mio_emm_debug {
+	u64 u;
+	struct cavm_mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_mio_emm_debug_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union cavm_mio_emm_dma {
+	u64 u;
+	struct cavm_mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct cavm_mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct cavm_mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 CAVM_MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union cavm_mio_emm_dma_adr {
+	u64 u;
+	struct cavm_mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union cavm_mio_emm_dma_arg {
+	u64 u;
+	struct cavm_mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct cavm_mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union cavm_mio_emm_dma_cfg {
+	u64 u;
+	struct cavm_mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct cavm_mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union cavm_mio_emm_dma_fifo_adr {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union cavm_mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union cavm_mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn81xx; */
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn83xx; */
+	struct cavm_mio_emm_dma_fifo_cmd_cn88xxp1 {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} cn88xxp1;
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn88xxp2; */
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union cavm_mio_emm_dma_int {
+	u64 u;
+	struct cavm_mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct cavm_mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct cavm_mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_mio_emm_dma_int_w1s {
+	u64 u;
+	struct cavm_mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union cavm_mio_emm_int {
+	u64 u;
+	struct cavm_mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cavm_mio_emm_int_ena_w1c {
+	u64 u;
+	struct cavm_mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union cavm_mio_emm_int_ena_w1s {
+	u64 u;
+	struct cavm_mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_mio_emm_int_w1s {
+	u64 u;
+	struct cavm_mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union cavm_mio_emm_io_ctl {
+	u64 u;
+	struct cavm_mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union cavm_mio_emm_modex {
+	u64 u;
+	struct cavm_mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct cavm_mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_modex_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_pbax {
+	u64 u;
+	struct cavm_mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cavm_mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_vecx_addr {
+	u64 u;
+	struct cavm_mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct cavm_mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct cavm_mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct cavm_mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union cavm_mio_emm_rca {
+	u64 u;
+	struct cavm_mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_mio_emm_rca_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union cavm_mio_emm_rsp_hi {
+	u64 u;
+	struct cavm_mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union cavm_mio_emm_rsp_lo {
+	u64 u;
+	struct cavm_mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union cavm_mio_emm_rsp_sts {
+	u64 u;
+	struct cavm_mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cavm_mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union cavm_mio_emm_sample {
+	u64 u;
+	struct cavm_mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct cavm_mio_emm_sample_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union cavm_mio_emm_sts_mask {
+	u64 u;
+	struct cavm_mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union cavm_mio_emm_switch {
+	u64 u;
+	struct cavm_mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct cavm_mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	/* struct cavm_mio_emm_switch_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union cavm_mio_emm_tap {
+	u64 u;
+	struct cavm_mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_mio_emm_tap_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union cavm_mio_emm_timing {
+	u64 u;
+	struct cavm_mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_mio_emm_timing_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union cavm_mio_emm_wdog {
+	u64 u;
+	struct cavm_mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct cavm_mio_emm_wdog_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CAVM_CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h b/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
new file mode 100644
index 0000000000..065f567999
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2012-2018 Marvell Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __OCTEONTX_MMC_H__
+#define __OCTEONTX_MMC_H__
+
+#include <mmc.h>
+#include <dm/device.h>
+
+/* NOTE: this file is used by both Octeon and OcteonTX */
+
+/*
+ * Card Command Classes (CCC)
+ */
+#define CCC_BASIC		BIT(0)	/* (0) Basic protocol functions */
+					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
+					/* (and for SPI, CMD58,59) */
+#define CCC_STREAM_READ		BIT(1)	/* (1) Stream read commands */
+					/* (CMD11) */
+#define CCC_BLOCK_READ		BIT(2)	/* (2) Block read commands */
+					/* (CMD16,17,18) */
+#define CCC_STREAM_WRITE	BIT(3)	/* (3) Stream write commands */
+					/* (CMD20) */
+#define CCC_BLOCK_WRITE		BIT(4)	/* (4) Block write commands */
+					/* (CMD16,24,25,26,27) */
+#define CCC_ERASE		BIT(5)	/* (5) Ability to erase blocks */
+					/* (CMD32,33,34,35,36,37,38,39) */
+#define CCC_WRITE_PROT		BIT(6)	/* (6) Able to write protect blocks */
+					/* (CMD28,29,30) */
+#define CCC_LOCK_CARD		BIT(7)	/* (7) Able to lock down card */
+					/* (CMD16,CMD42) */
+#define CCC_APP_SPEC		BIT(8)	/* (8) Application specific */
+					/* (CMD55,56,57,ACMD*) */
+#define CCC_IO_MODE		BIT(9)	/* (9) I/O mode */
+					/* (CMD5,39,40,52,53) */
+#define CCC_SWITCH		BIT(10)	/* (10) High speed switch */
+					/* (CMD6,34,35,36,37,50) */
+					/* (11) Reserved */
+					/* (CMD?) */
+
+/*
+ * NOTE: This was copied from the Linux kernel.
+ *
+ * MMC status in R1, for native mode (SPI bits are different)
+ * Type
+ *	e:error bit
+ *	s:status bit
+ *	r:detected and set for the actual command response
+ *	x:detected and set during command execution. the host must poll
+ *	    the card by sending status command in order to read these bits.
+ * Clear condition
+ *	a:according to the card state
+ *	b:always related to the previous command. Reception of
+ *	    a valid command will clear it (with a delay of one command)
+ *	c:clear by read
+ */
+#define R1_OUT_OF_RANGE		BIT(31)		/* er, c */
+#define R1_ADDRESS_ERROR	BIT(30)		/* erx, c */
+#define R1_BLOCK_LEN_ERROR	BIT(29)		/* er, c */
+#define R1_ERASE_SEQ_ERROR	BIT(28)		/* er, c */
+#define R1_ERASE_PARAM          BIT(27)		/* ex, c */
+#define R1_WP_VIOLATION		BIT(26)		/* erx, c */
+#define R1_CARD_IS_LOCKED	BIT(25)		/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	BIT(24)		/* erx, c */
+#define R1_COM_CRC_ERROR	BIT(23)		/* er, b */
+#define R1_ILLEGAL_COMMAND	BIT(22)		/* er, b */
+#define R1_CARD_ECC_FAILED	BIT(21)		/* ex, c */
+#define R1_CC_ERROR		BIT(20)		/* erx, c */
+#define R1_ERROR		BIT(19)		/* erx, c */
+#define R1_UNDERRUN		BIT(18)		/* ex, c */
+#define R1_OVERRUN		BIT(17)		/* ex, c */
+#define R1_CID_CSD_OVERWRITE	BIT(16)		/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
+#define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
+#define R1_ERASE_RESET		BIT(13)		/* sr, c */
+#define R1_STATUS(x)		(x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
+#define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
+#define R1_APP_CMD		BIT(5)		/* sr, c */
+
+#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR
+#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_WP_VIOLATION |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR |		\
+				R1_UNDERRUN |		\
+				R1_OVERRUN
+
+/**
+ * Flag indicates that CMD23 is supported.  This is required for multi-block
+ * hardware transfers to work.
+ */
+#define OCTEON_MMC_FLAG_SD_CMD23	1
+
+#ifdef __mips
+# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
+#endif
+
+/** Maximum supported MMC slots */
+#define OCTEONTX_MAX_MMC_SLOT		2
+
+#define OCTEONTX_MMC_NAME_LEN		32
+
+struct mmc;
+struct mmc_config;
+struct octeontx_mmc_host;
+struct octeontx_mmc_slot;
+struct gpio_desc;
+
+struct octeontx_mmc_slot {
+	char		name[OCTEONTX_MMC_NAME_LEN];	/** Name of device */
+	u8		ext_csd[512];	/** Extended CSD register */
+	struct mmc	*mmc;		/** Ptr back to mmc structure */
+	struct octeontx_mmc_host *host;	/** Host controller data structure */
+	struct mmc_config cfg;		/** Slot configuration */
+	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
+	struct gpio_desc cd_gpio;	/** Card detect GPIO */
+	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
+	int		power_delay;	/** Time in usec to wait for power */
+	int		bus_id;		/** BUS ID of device */
+	int		of_offset;	/** Device tree node */
+	int		clk_period;	/** Clock period */
+	int		bus_max_width;	/** Bus width 1, 4 or 8 */
+	int		power_class;	/** Power class for device */
+	int		flags;
+	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
+	int		dat_clk_skew;	/** Clock skew for data in SCLK */
+	int		power_gpio_of_offset;	/** Offset of power node */
+	/**
+	 * Register bus-width value where:
+	 * 0: 1-bit
+	 * 1: 4-bit
+	 * 2: 8-bit
+	 * 5: 4-bit DDR
+	 * 6: 8-bit DDR
+	 * All other values are reserved.
+	 */
+	u8		bus_width;
+	bool		non_removable:1;/** True if device is not removable */
+	/** True if have extended CSD register */
+	bool		have_ext_csd:1;
+	bool		sector_mode:1;	/** Sector or byte mode */
+	bool		powered:1;	/** True if powered on */
+	/** True if power GPIO is active high */
+	bool		power_active_high:1;
+	bool		ro_inverted:1;	/** True if write-protect is inverted */
+	bool		cd_inverted:1;	/** True if card-detect is inverted */
+};
+
+struct octeontx_mmc_host {
+	void		*base_addr;	/** Base address of device */
+	pci_dev_t	pdev;		/** PCI device */
+	u64		sclock;		/** SCLK in hz */
+	int		of_offset;	/** Device tree node */
+	int		cur_slotid;	/** Current slot to use */
+	int		last_slotid;	/** last slot in use */
+	int		max_width;	/** Maximum width hardware supports */
+#ifdef __mips
+	int		node;		/** OCX node for Octeon (MIPS) */
+	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
+#endif
+	bool		initialized;	/** True if initialized */
+	struct udevice  *dev;		/** Device host is associated with */
+	/** Slots associated with host controller */
+	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT];
+};
+
+/**
+ * Returns the card write protect status
+ *
+ * @param mmc	pointer to mmc data structure
+ * @return 1 if card is write protected, 0 otherwise
+ */
+int octeontx_mmc_getwp(struct udevice *dev);
+
+/**
+ * Gets the card-detect status
+ *
+ * @param mmc	pointer to mmc data structure
+ *
+ * @return	1 if card is detected, false if not detected.
+ */
+int octeontx_mmc_getcd(struct udevice *dev);
+
+#endif /* __OCTEONTX_MMC_H__ */
diff --git a/cmd/Kconfig b/cmd/Kconfig
index d24512d259..9a610aacb5 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -1531,7 +1531,7 @@ endif
 menu "Misc commands"
 
 config CMD_BOOTIMGUP
-	depends on MMC_CAVIUM
+	depends on MMC_OCTEONTX
 	bool "bootimgup"
 	help
 	  bootimgup command support
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 941393f69e..6ee11e0b25 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -13,7 +13,7 @@
 
 static int curr_device = -1;
 
-#ifdef CONFIG_MMC_CAVIUM
+#ifdef CONFIG_MMC_OCTEONTX
 extern void print_mmc_device_info(struct mmc *mmc);
 #else
 static void print_mmcinfo(struct mmc *mmc)
@@ -138,7 +138,7 @@ static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (!mmc)
 		return CMD_RET_FAILURE;
 
-#ifdef CONFIG_MMC_CAVIUM
+#ifdef CONFIG_MMC_OCTEONTX
 	print_mmc_device_info(mmc);
 #else
 	print_mmcinfo(mmc);
diff --git a/configs/octeontx2_95xx_defconfig b/configs/octeontx2_95xx_defconfig
index 8ebdfe6aef..b39cfa6826 100644
--- a/configs/octeontx2_95xx_defconfig
+++ b/configs/octeontx2_95xx_defconfig
@@ -61,7 +61,7 @@ CONFIG_DM_I2C=y
 CONFIG_MISC=y
 # CONFIG_MMC is not set
 CONFIG_DM_MMC=y
-CONFIG_MMC_CAVIUM=y
+CONFIG_MMC_OCTEONTX=y
 CONFIG_MTD=y
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
diff --git a/configs/octeontx2_96xx_defconfig b/configs/octeontx2_96xx_defconfig
index 352c6dcbba..77e40b08f5 100644
--- a/configs/octeontx2_96xx_defconfig
+++ b/configs/octeontx2_96xx_defconfig
@@ -61,7 +61,7 @@ CONFIG_DM_I2C=y
 CONFIG_MISC=y
 # CONFIG_MMC is not set
 CONFIG_DM_MMC=y
-CONFIG_MMC_CAVIUM=y
+CONFIG_MMC_OCTEONTX=y
 CONFIG_MTD=y
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
diff --git a/configs/octeontx_81xx_defconfig b/configs/octeontx_81xx_defconfig
index 58938da170..998dc5b9e9 100644
--- a/configs/octeontx_81xx_defconfig
+++ b/configs/octeontx_81xx_defconfig
@@ -63,7 +63,7 @@ CONFIG_DM_I2C=y
 CONFIG_MISC=y
 # CONFIG_MMC is not set
 CONFIG_DM_MMC=y
-CONFIG_MMC_CAVIUM=y
+CONFIG_MMC_OCTEONTX=y
 CONFIG_MTD=y
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
diff --git a/configs/octeontx_83xx_defconfig b/configs/octeontx_83xx_defconfig
index 288785c4a7..c54852cfc4 100644
--- a/configs/octeontx_83xx_defconfig
+++ b/configs/octeontx_83xx_defconfig
@@ -63,7 +63,7 @@ CONFIG_DM_I2C=y
 CONFIG_MISC=y
 # CONFIG_MMC is not set
 CONFIG_DM_MMC=y
-CONFIG_MMC_CAVIUM=y
+CONFIG_MMC_OCTEONTX=y
 CONFIG_MTD=y
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 07ef306568..cfbc6a4e47 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -39,8 +39,8 @@ config SPL_DM_MMC
 	  appear as block devices in U-Boot and can support filesystems such
 	  as EXT4 and FAT.
 
-config MMC_CAVIUM
-	bool "Cavium OcteonTX Multimedia Card Interface support"
+config MMC_OCTEONTX
+	bool "Marvell OcteonTX Multimedia Card Interface support"
 	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
 	depends on DM_MMC
 	help
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index dc76346573..0ebd73377e 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -18,7 +18,6 @@ obj-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
 endif
 
 obj-$(CONFIG_ARM_PL180_MMCI) += arm_pl180_mmci.o
-obj-$(CONFIG_MMC_CAVIUM)		+= cavium_mmc.o
 obj-$(CONFIG_MMC_DAVINCI)		+= davinci_mmc.o
 obj-$(CONFIG_MMC_DW)			+= dw_mmc.o
 obj-$(CONFIG_MMC_DW_EXYNOS)		+= exynos_dw_mmc.o
@@ -37,6 +36,7 @@ obj-$(CONFIG_MVEBU_MMC) += mvebu_mmc.o
 obj-$(CONFIG_MMC_OMAP_HS)		+= omap_hsmmc.o
 obj-$(CONFIG_MMC_MXC)			+= mxcmmc.o
 obj-$(CONFIG_MMC_MXS)			+= mxsmmc.o
+obj-$(CONFIG_MMC_OCTEONTX)		+= octeontx_mmc.o
 obj-$(CONFIG_MMC_PCI)			+= pci_mmc.o
 obj-$(CONFIG_PXA_MMC_GENERIC) += pxa_mmc_gen.o
 obj-$(CONFIG_SUPPORT_EMMC_RPMB) += rpmb.o
diff --git a/drivers/mmc/mmc-uclass.c b/drivers/mmc/mmc-uclass.c
index d68efc31d1..69e69b5fcd 100644
--- a/drivers/mmc/mmc-uclass.c
+++ b/drivers/mmc/mmc-uclass.c
@@ -11,6 +11,13 @@
 #include <dm/lists.h>
 #include "mmc_private.h"
 
+#ifdef CONFIG_MMC_OCTEONTX
+# include <asm/gpio.h>
+# include <asm/arch/octeontx_mmc.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
 int dm_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
 		    struct mmc_data *data)
 {
@@ -196,8 +203,8 @@ struct mmc *mmc_get_mmc_dev(struct udevice *dev)
 {
 	if (!device_active(dev))
 		return NULL;
-#ifdef CONFIG_MMC_CAVIUM
-	struct cavium_mmc_host *host = dev_get_priv(dev);
+#ifdef CONFIG_MMC_OCTEONTX
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
 	if (!host)
 		return NULL;
 	struct mmc *mmc = host->slots[host->cur_slotid].mmc;
@@ -226,10 +233,12 @@ struct mmc *find_mmc_device(int dev_num)
 
 	mmc_dev = dev_get_parent(dev);
 
-#ifdef CONFIG_MMC_CAVIUM
-	struct cavium_mmc_host *host = dev_get_priv(mmc_dev);
-	if (dev_num > CAVIUM_MAX_MMC_SLOT && !host)
+#ifdef CONFIG_MMC_OCTEONTX
+	struct octeontx_mmc_host *host = dev_get_priv(mmc_dev);
+
+	if (dev_num > OCTEONTX_MAX_MMC_SLOT && !host)
 		return NULL;
+
 	host->cur_slotid = dev_num;
 #endif
 	struct mmc *mmc = mmc_get_mmc_dev(mmc_dev);
@@ -295,14 +304,18 @@ void print_mmc_devices(char separator)
 	for (uclass_first_device(UCLASS_MMC, &dev);
 	     dev;
 	     uclass_next_device(&dev), first = false) {
-#ifdef CONFIG_MMC_CAVIUM
-		struct cavium_mmc_host *host = dev_get_priv(dev);
+#ifdef CONFIG_MMC_OCTEONTX
+		/* The OcteonTX has multiple slots connected to a single
+		 * PCI device so each slot must be processed inside the
+		 * device.
+		 */
+		struct octeontx_mmc_host *host = dev_get_priv(dev);
 		struct mmc *m = NULL;
 
 		if (!host)
 			continue;
 
-		for (int devnum = 0; devnum < CAVIUM_MAX_MMC_SLOT;
+		for (int devnum = 0; devnum < OCTEONTX_MAX_MMC_SLOT;
 			devnum++, m=NULL) {
 			if (!first) {
 				printf("%c", separator);
@@ -406,12 +419,12 @@ int mmc_unbind(struct udevice *dev)
 static int mmc_select_hwpart(struct udevice *bdev, int hwpart)
 {
 	struct udevice *mmc_dev = dev_get_parent(bdev);
-#ifdef CONFIG_MMC_CAVIUM
-	struct cavium_mmc_host *host = dev_get_priv(mmc_dev);
+#ifdef CONFIG_MMC_OCTEONTX
 	struct blk_desc *desc = dev_get_uclass_platdata(bdev);
+	struct octeontx_mmc_host *host = dev_get_priv(mmc_dev);
 	struct mmc *mmc = host->slots[desc->devnum].mmc;
 
-	/* As cavium mmc have two slots, switch the slot if it
+	/* As octeontx mmc have multiple slots, switch the slot if it
 	 * is not current.
 	 */
 	if (host->cur_slotid != desc->devnum)
@@ -435,8 +448,8 @@ static int mmc_select_hwpart(struct udevice *bdev, int hwpart)
 static int mmc_blk_probe(struct udevice *dev)
 {
 	struct udevice *mmc_dev = dev_get_parent(dev);
-#ifdef CONFIG_MMC_CAVIUM
-	struct cavium_mmc_host *host = dev_get_priv(mmc_dev);
+#ifdef CONFIG_MMC_OCTEONTX
+	struct octeontx_mmc_host *host = dev_get_priv(mmc_dev);
 	struct blk_desc *desc = dev_get_uclass_platdata(dev);
 	struct mmc *mmc = host->slots[desc->devnum].mmc;
 #else
diff --git a/drivers/mmc/cavium_mmc.c b/drivers/mmc/octeontx_mmc.c
similarity index 86%
rename from drivers/mmc/cavium_mmc.c
rename to drivers/mmc/octeontx_mmc.c
index 6d63c3cca4..d7e528ae9e 100644
--- a/drivers/mmc/cavium_mmc.c
+++ b/drivers/mmc/octeontx_mmc.c
@@ -1,49 +1,29 @@
-/***********************license start************************************
- * Copyright (c) 2012 - 2016 Cavium Inc. (support@cavium.com).  All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *     * Neither the name of Cavium Inc. nor the names of
- *       its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written
- *       permission.
- *
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS
- * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
- * RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
- * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT
- * DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES
- * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR
- * PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET
- * POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT
- * OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- *
- *
- * For any questions regarding licensing please contact
- * support@cavium.com
+/*
+ * Copyright (c) 2012 - 2018 Marvell Inc.
  *
- ***********************license end**************************************/
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
 
 /*
  * Due to how MMC is implemented in the OCTEON processor it is not
  * possible to use the generic MMC support.  However, this code
  * implements all of the MMC support found in the generic MMC driver
- * and should be compatible with it for the most part.
+ * and should be compatible with it.  A few things have been enhanced,
+ * such as the code that displays information about the devices.
+ *
+ * For example, one important field for SD devices is whether or not they
+ * support CMD23.  Without CMD23 support, data transfers will be very slow
+ * on OcteonTX since only single block transfers are possible.
+ *
+ * It is planned to update the generic MMC code to simplify this driver in
+ * the future.  The changes should be fairly minimal.
  *
  * Currently both MMC and SD/SDHC/SDXC are supported.
+ *
+ * This code also contains compatibility with the Octeon MIPS driver, though
+ * the MIPS U-Boot has not been ported to the current U-Boot.
+ *
+ * TODO: Add support for OcteonTX2 and simplify after MMC core changes.
  */
 
 #include <common.h>
@@ -65,7 +45,8 @@
 #include <asm/arch/fdt-helper.h>
 #include <asm/io.h>
 #include <asm/gpio.h>
-#include <asm/arch/cavium_mmc.h>
+#include <asm/arch/cavm-csrs-mio_emm.h>
+#include <asm/arch/octeontx_mmc.h>
 #include <asm/arch/clock.h>
 #include <linux/list.h>
 #include <div64.h>
@@ -78,14 +59,14 @@
 #endif
 
 /** Name of our driver */
-#define CAVIUM_MMC_DRIVER_NAME			"mmc_cavium"
+#define OCTEONTX_MMC_DRIVER_NAME		"mmc_octeontx"
 
-#ifndef CONFIG_CAVIUM_MMC_MAX_FREQUENCY
-# define CONFIG_CAVIUM_MMC_MAX_FREQUENCY	52000000
+#ifndef CONFIG_OCTEONTX_MMC_MAX_FREQUENCY
+# define CONFIG_OCTEONTX_MMC_MAX_FREQUENCY	52000000
 #endif
 
 /* Enable support for SD as well as MMC */
-#define CONFIG_CAVIUM_MMC_SD
+#define CONFIG_OCTEONTX_MMC_SD
 
 #define POWER_ON_TIME		40	/** See SD 4.1 spec figure 6-5 */
 
@@ -110,15 +91,15 @@
  */
 #define MMC_TIMEOUT_SHORT	20
 
-#ifndef CONFIG_CAVIUM_MAX_MMC_SLOT
-# define CONFIG_CAVIUM_MAX_MMC_SLOT		4
+#ifndef CONFIG_OCTEONTX_MAX_MMC_SLOT
+# define CONFIG_OCTEONTX_MAX_MMC_SLOT		4
 #endif
 
-#ifndef CONFIG_CAVIUM_MMC_MIN_BUS_SPEED_HZ
-# define CONFIG_CAVIUM_MMC_MIN_BUS_SPEED_HZ		400000
+#ifndef CONFIG_OCTEONTX_MMC_MIN_BUS_SPEED_HZ
+# define CONFIG_OCTEONTX_MMC_MIN_BUS_SPEED_HZ		400000
 #endif
 
-#ifndef CONFIG_CAVIUM_MMC_SD
+#ifndef CONFIG_OCTEONTX_MMC_SD
 # undef IS_SD
 # define IS_SD(x) (0)
 #endif
@@ -150,49 +131,50 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value);
 static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd);
 
 static int mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
-				struct mmc_data *data, uint32_t flags,
+				struct mmc_data *data, u32 flags,
 				uint timeout);
 
 static int mmc_send_cmd_flags(struct mmc *mmc, struct mmc_cmd *cmd,
-			      struct mmc_data *data, uint32_t flags);
+			      struct mmc_data *data, u32 flags);
 
 static int mmc_send_acmd(struct mmc *mmc, struct mmc_cmd *cmd,
-			 struct mmc_data *data, uint32_t flags);
+			 struct mmc_data *data, u32 flags);
 
-static int cavium_mmc_set_ios(struct udevice *dev);
+static int octeontx_mmc_set_ios(struct udevice *dev);
 
 static void mmc_switch_dev(struct mmc *mmc);
 
-int cavium_mmc_getwp(struct udevice *dev)
-	__attribute__((weak, alias("__cavium_mmc_getwp")));
+int octeontx_mmc_getwp(struct udevice *dev)
+	__attribute__((weak, alias("__octeontx_mmc_getwp")));
 
-int cavium_mmc_getcd(struct udevice *dev)
-	__attribute__((weak, alias("__cavium_mmc_getcd")));
+int octeontx_mmc_getcd(struct udevice *dev)
+	__attribute__((weak, alias("__octeontx_mmc_getcd")));
 
-int cavium_mmc_init(struct mmc *mmc)
-	__attribute__((weak, alias("__cavium_mmc_init")));
+int octeontx_mmc_init(struct mmc *mmc)
+	__attribute__((weak, alias("__octeontx_mmc_init")));
 
 /**
  * This is the external mmc_send_cmd function.  It was required that
  * the internal version support flags so this version is required.
  */
-static int cavium_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
-			       struct mmc_data *data);
+static int octeontx_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
+				 struct mmc_data *data);
 
-static const struct udevice_id cavium_mmc_ids[] = {
+static const struct udevice_id octeontx_mmc_ids[] = {
 	{ .compatible = "cavium,thunder-8890-mmc" },
 	{ .compatible = "cavium,mmc" },
+	{ .compatible = "octeontx,mmc" },
 	{ },
 };
 
-static const struct dm_mmc_ops cavium_mmc_ops = {
-	.send_cmd = cavium_mmc_send_cmd,
-	.set_ios = cavium_mmc_set_ios,
-	.get_cd = cavium_mmc_getcd,
-	.get_wp = cavium_mmc_getwp,
+static const struct dm_mmc_ops octeontx_mmc_ops = {
+	.send_cmd = octeontx_mmc_send_cmd,
+	.set_ios = octeontx_mmc_set_ios,
+	.get_cd = octeontx_mmc_getcd,
+	.get_wp = octeontx_mmc_getwp,
 };
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_set_ios(struct mmc *mmc);
 #endif
 
@@ -205,43 +187,66 @@ static int sd_set_ios(struct mmc *mmc);
  *
  * @return	0 for success, -1 on error.
  */
-static int cavium_mmc_get_config(struct udevice *dev);
+static int octeontx_mmc_get_config(struct udevice *dev);
 
 #ifdef DEBUG
-const char *mmc_reg_str(uint64_t reg)
+const char *mmc_reg_str(u64 reg)
 {
-	switch (reg) {
 #ifdef __mips
-	case MIO_NDF_DMA_CFG:		return "MIO_NDF_DMA_CFG";
-	case MIO_NDF_DMA_INT:		return "MIO_NDF_DMA_INT";
-	case MIO_NDF_DMA_INT_EN:	return "MIO_NDF_DMA_INT_EN";
+	if (reg == CAVM_MIO_NDF_DMA_CFG())
+		return "MIO_NDF_DMA_CFG";
+	if (reg == CAVM_MIO_NDF_DMA_INT())
+		return "MIO_NDF_DMA_INT";
+	if (reg == CAVM_MIO_NDF_DMA_INT_EN())
+		return "MIO_NDF_DMA_INT_EN";
 #endif
-	case MIO_EMM_DMA_CFG:		return "MIO_EMM_DMA_CFG";
-	case MIO_EMM_DMA_ADR:		return "MIO_EMM_DMA_ADR";
-	case MIO_EMM_DMA_INT:		return "MIO_EMM_DMA_INT";
-	case MIO_EMM_CFG:		return "MIO_EMM_CFG";
-	case MIO_EMM_MODEX(0):		return "MIO_EMM_MODE0";
-	case MIO_EMM_MODEX(1):		return "MIO_EMM_MODE1";
-	case MIO_EMM_MODEX(2):		return "MIO_EMM_MODE2";
-	case MIO_EMM_MODEX(3):		return "MIO_EMM_MODE3";
-	case MIO_EMM_SWITCH:		return "MIO_EMM_SWITCH";
-	case MIO_EMM_DMA:		return "MIO_EMM_DMA";
-	case MIO_EMM_CMD:		return "MIO_EMM_CMD";
-	case MIO_EMM_RSP_STS:		return "MIO_EMM_RSP_STS";
-	case MIO_EMM_RSP_LO:		return "MIO_EMM_RSP_LO";
-	case MIO_EMM_RSP_HI:		return "MIO_EMM_RSP_HI";
-	case MIO_EMM_INT:		return "MIO_EMM_INT";
+	if (reg == CAVM_MIO_EMM_DMA_CFG())
+		return "MIO_EMM_DMA_CFG";
+	if (reg == CAVM_MIO_EMM_DMA_ADR())
+		return "MIO_EMM_DMA_ADR";
+	if (reg == CAVM_MIO_EMM_DMA_INT())
+		return "MIO_EMM_DMA_INT";
+	if (reg == CAVM_MIO_EMM_CFG())
+		return "MIO_EMM_CFG";
+	if (reg == CAVM_MIO_EMM_MODEX(0))
+		return "MIO_EMM_MODE0";
+	if (reg == CAVM_MIO_EMM_MODEX(1))
+		return "MIO_EMM_MODE1";
+	if (reg == CAVM_MIO_EMM_MODEX(2))
+		return "MIO_EMM_MODE2";
+	if (reg == CAVM_MIO_EMM_MODEX(3))
+		return "MIO_EMM_MODE3";
+	if (reg == CAVM_MIO_EMM_SWITCH())
+		return "MIO_EMM_SWITCH";
+	if (reg == CAVM_MIO_EMM_DMA())
+		return "MIO_EMM_DMA";
+	if (reg == CAVM_MIO_EMM_CMD())
+		return "MIO_EMM_CMD";
+	if (reg == CAVM_MIO_EMM_RSP_STS())
+		return "MIO_EMM_RSP_STS";
+	if (reg == CAVM_MIO_EMM_RSP_LO())
+		return "MIO_EMM_RSP_LO";
+	if (reg == CAVM_MIO_EMM_RSP_HI())
+		return "MIO_EMM_RSP_HI";
+	if (reg == CAVM_MIO_EMM_INT())
+		return "MIO_EMM_INT";
 #ifdef __mips
-	case MIO_EMM_INT_EN:		return "MIO_EMM_INT_EN";
+	if (reg == CAVM_MIO_EMM_INT_EN())
+		return "MIO_EMM_INT_EN";
 #endif
-	case MIO_EMM_WDOG:		return "MIO_EMM_WDOG";
-	case MIO_EMM_SAMPLE:		return "MIO_EMM_SAMPLE";
-	case MIO_EMM_STS_MASK:		return "MIO_EMM_STS_MASK";
-	case MIO_EMM_RCA:		return "MIO_EMM_RCA";
-	case MIO_EMM_BUF_IDX:		return "MIO_EMM_BUF_IDX";
-	case MIO_EMM_BUF_DAT:		return "MIO_EMM_BUF_DAT";
-	default:			return "UNKNOWN";
-	}
+	if (reg == CAVM_MIO_EMM_WDOG())
+		return "MIO_EMM_WDOG";
+	if (reg == CAVM_MIO_EMM_SAMPLE())
+		return "MIO_EMM_SAMPLE";
+	if (reg == CAVM_MIO_EMM_STS_MASK())
+		return "MIO_EMM_STS_MASK";
+	if (reg == CAVM_MIO_EMM_RCA())
+		return "MIO_EMM_RCA";
+	if (reg == CAVM_MIO_EMM_BUF_IDX())
+		return "MIO_EMM_BUF_IDX";
+	if (reg == CAVM_MIO_EMM_BUF_DAT())
+		return "MIO_EMM_BUF_DAT";
+	return "UNKNOWN";
 }
 #endif
 
@@ -254,16 +259,16 @@ const char *mmc_reg_str(uint64_t reg)
  *
  * @return	field extracted from the CSD register
  */
-static uint32_t get_csd_bits(const struct mmc *mmc, unsigned start,
-			     unsigned end)
+static u32 get_csd_bits(const struct mmc *mmc,
+			unsigned int start, unsigned int end)
 {
-	const uint32_t *csd = mmc->csd;
+	const u32 *csd = mmc->csd;
 	int start_off = 3 - start / 32;
 	int end_off = 3 - end / 32;
 	int start_bit = start & 0x1f;
 	int end_bit = end & 0x1f;
-	uint32_t val;
-	uint32_t mask;
+	u32 val;
+	u32 mask;
 	if (start_off == end_off) {
 		val = csd[start_off] >> start_bit;
 		mask = (1 << (end - start + 1)) - 1;
@@ -284,11 +289,11 @@ static uint32_t get_csd_bits(const struct mmc *mmc, unsigned start,
  * @param	reg	register offset
  * @param	value	value to write to register
  */
-static inline void mmc_write_csr(const struct mmc *mmc, uint64_t reg,
-				 uint64_t value)
+static inline void mmc_write_csr(const struct mmc *mmc, u64 reg,
+				 u64 value)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
 	void *addr = host->base_addr + reg;
 
 #ifdef DEBUG_CSR
@@ -306,11 +311,11 @@ static inline void mmc_write_csr(const struct mmc *mmc, uint64_t reg,
  *
  * @return	value of the register
  */
-static inline uint64_t mmc_read_csr(const struct mmc *mmc, uint64_t reg)
+static inline u64 mmc_read_csr(const struct mmc *mmc, u64 reg)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
-	uint64_t value = readq(host->base_addr + reg);
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
+	u64 value = readq(host->base_addr + reg);
 #ifdef DEBUG_CSR
 	printf("        %s: %s(0x%p) => 0x%llx\n", __func__,
 	       mmc_reg_str(reg), host->base_addr + reg,
@@ -320,7 +325,7 @@ static inline uint64_t mmc_read_csr(const struct mmc *mmc, uint64_t reg)
 }
 
 #ifdef DEBUG
-static void mmc_print_status(uint32_t status)
+static void mmc_print_status(u32 status)
 {
 #ifdef DEBUG_STATUS
 	static const char * const state[] = {
@@ -383,31 +388,36 @@ static void mmc_print_status(uint32_t status)
 }
 #endif
 
+/**
+ * Print out all of the register values
+ *
+ * @param mmc	MMC device
+ */
 static void mmc_print_registers(struct mmc *mmc)
 {
 #ifdef DEBUG_REGISTERS
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 #ifdef __mips
-	struct cavium_mmc_host *host = slot->host;
-	union mio_ndf_dma_cfg ndf_dma_cfg;
-	union mio_ndf_dma_int ndf_dma_int;
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_ndf_dma_cfg ndf_dma_cfg;
+	union cavm_mio_ndf_dma_int ndf_dma_int;
 #endif
-	union mio_emm_dma_cfg emm_dma_cfg;
-	union mio_emm_dma_adr emm_dma_adr;
-	union mio_emm_dma_int emm_dma_int;
-	union mio_emm_cfg emm_cfg;
-	union mio_emm_modex emm_mode;
-	union mio_emm_switch emm_switch;
-	union mio_emm_dma emm_dma;
-	union mio_emm_cmd emm_cmd;
-	union mio_emm_rsp_sts emm_rsp_sts;
-	union mio_emm_rsp_lo emm_rsp_lo;
-	union mio_emm_rsp_hi emm_rsp_hi;
-	union mio_emm_int emm_int;
-	union mio_emm_wdog emm_wdog;
-	union mio_emm_sample emm_sample;
-	union mio_emm_sts_mask emm_sts_mask;
-	union mio_emm_rca emm_rca;
+	union cavm_mio_emm_dma_cfg emm_dma_cfg;
+	union cavm_mio_emm_dma_adr emm_dma_adr;
+	union cavm_mio_emm_dma_int emm_dma_int;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_modex emm_mode;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_dma emm_dma;
+	union cavm_mio_emm_cmd emm_cmd;
+	union cavm_mio_emm_rsp_sts emm_rsp_sts;
+	union cavm_mio_emm_rsp_lo emm_rsp_lo;
+	union cavm_mio_emm_rsp_hi emm_rsp_hi;
+	union cavm_mio_emm_int emm_int;
+	union cavm_mio_emm_wdog emm_wdog;
+	union cavm_mio_emm_sample emm_sample;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_rca emm_rca;
 	int bus;
 
 	static const char * const bus_width_str[] = {
@@ -475,15 +485,15 @@ static void mmc_print_registers(struct mmc *mmc)
 		printf("    36-55: size:                %u\n",
 		       ndf_dma_cfg.s.size);
 		printf("    0-35:  adr:                 0x%llx\n",
-		       (uint64_t)ndf_dma_cfg.s.adr);
+		       (u64)ndf_dma_cfg.s.adr);
 
-		ndf_dma_int.u = mmc_read_csr(mmc, MIO_NDF_DMA_INT);
+		ndf_dma_int.u = mmc_read_csr(mmc, CAVM_MIO_NDF_DMA_INT());
 		printf("\nMIO_NDF_DMA_INT:              0x%016llx\n",
 		       ndf_dma_int.u);
 		printf("    0:     Done:    %s\n",
 		       ndf_dma_int.s.done ? "yes" : "no");
 
-		emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+		emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 		printf("\nMIO_EMM_CFG:                  0x%016llx\n",
 		       emm_cfg.u);
 		printf("    16:    boot_fail:           %s\n",
@@ -499,7 +509,7 @@ static void mmc_print_registers(struct mmc *mmc)
 	} else
 #endif
 	{
-		emm_dma_cfg.u = mmc_read_csr(mmc, MIO_EMM_DMA_CFG);
+		emm_dma_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_CFG());
 		printf("MIO_EMM_DMA_CFG:                0x%016llx\n",
 		       emm_dma_cfg.u);
 		printf("    63:    en:                  %s\n",
@@ -519,12 +529,12 @@ static void mmc_print_registers(struct mmc *mmc)
 		printf("    36-55: size:                %u\n",
 		       emm_dma_cfg.s.size);
 
-		emm_dma_adr.u = mmc_read_csr(mmc, MIO_EMM_DMA_ADR);
+		emm_dma_adr.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_ADR());
 		printf("MIO_EMM_DMA_ADR:        0x%016llx\n", emm_dma_adr.u);
 		printf("    0-49:  adr:                 0x%llx\n",
-		       (uint64_t)emm_dma_adr.s.adr);
+		       (u64)emm_dma_adr.s.adr);
 
-		emm_dma_int.u = mmc_read_csr(mmc, MIO_EMM_DMA_INT);
+		emm_dma_int.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_INT());
 		printf("\nMIO_EMM_DMA_INT:              0x%016llx\n",
 		       emm_dma_int.u);
 		printf("    1:     FIFO:                %s\n",
@@ -532,7 +542,7 @@ static void mmc_print_registers(struct mmc *mmc)
 		printf("    0:     Done:                %s\n",
 		       emm_dma_int.s.done ? "yes" : "no");
 
-		emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+		emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 		printf("\nMIO_EMM_CFG:                  0x%016llx\n",
 		       emm_cfg.u);
 #ifdef __mips
@@ -549,7 +559,7 @@ static void mmc_print_registers(struct mmc *mmc)
 		       emm_cfg.s.bus_ena & 0x01 ? "yes" : "no");
 	}
 	for (bus = 0; bus < 4; bus++) {
-		emm_mode.u = mmc_read_csr(mmc, MIO_EMM_MODEX(bus));
+		emm_mode.u = mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(bus));
 		printf("\nMIO_EMM_MODE%u:               0x%016llx\n",
 		       bus, emm_mode.u);
 		printf("    48:    hs_timing:           %s\n",
@@ -564,7 +574,7 @@ static void mmc_print_registers(struct mmc *mmc)
 		       emm_mode.s.clk_lo);
 	}
 
-	emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+	emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 	printf("\nMIO_EMM_SWITCH:               0x%016llx\n", emm_switch.u);
 	printf("    60-61: tbus_id:             %u\n", emm_switch.s.bus_id);
 	printf("    59:    switch_exe:          %s\n",
@@ -585,7 +595,7 @@ static void mmc_print_registers(struct mmc *mmc)
 	       emm_switch.s.clk_hi);
 	printf("    0-15:  clk_lo:              %u\n", emm_switch.s.clk_lo);
 
-	emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+	emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 	printf("\nMIO_EMM_DMA:                  0x%016llx\n", emm_dma.u);
 	printf("    60-61: bus_id:              %u\n", emm_dma.s.bus_id);
 	printf("    59:    dma_val:             %s\n",
@@ -606,7 +616,7 @@ static void mmc_print_registers(struct mmc *mmc)
 	printf("    0-31:  card_addr:           0x%x\n",
 	       emm_dma.s.card_addr);
 
-	emm_cmd.u = mmc_read_csr(mmc, MIO_EMM_CMD);
+	emm_cmd.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CMD());
 	printf("\nMIO_EMM_CMD:                  0x%016llx\n", emm_cmd.u);
 	printf("    60-61: bus_id:              %u\n", emm_cmd.s.bus_id);
 	printf("    59:    cmd_val:             %s\n",
@@ -620,7 +630,7 @@ static void mmc_print_registers(struct mmc *mmc)
 	printf("    32-37: cmd_idx:             %u\n", emm_cmd.s.cmd_idx);
 	printf("    0-31:  arg:                 0x%x\n", emm_cmd.s.arg);
 
-	emm_rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+	emm_rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
 	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
 	printf("    59:    cmd_val:             %s\n",
@@ -665,13 +675,13 @@ static void mmc_print_registers(struct mmc *mmc)
 	printf("    0:     cmd_done:            %s\n",
 	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
 
-	emm_rsp_lo.u = mmc_read_csr(mmc, MIO_EMM_RSP_LO);
+	emm_rsp_lo.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
 	printf("\nMIO_EMM_RSP_STS_LO:           0x%016llx\n", emm_rsp_lo.u);
 
-	emm_rsp_hi.u = mmc_read_csr(mmc, MIO_EMM_RSP_HI);
+	emm_rsp_hi.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_HI());
 	printf("\nMIO_EMM_RSP_STS_HI:           0x%016llx\n", emm_rsp_hi.u);
 
-	emm_int.u = mmc_read_csr(mmc, MIO_EMM_INT);
+	emm_int.u = mmc_read_csr(mmc, CAVM_MIO_EMM_INT());
 	printf("\nMIO_EMM_INT:                  0x%016llx\n", emm_int.u);
 	printf("    6:    switch_err:           %s\n",
 	       emm_int.s.switch_err ? "yes" : "no");
@@ -688,19 +698,19 @@ static void mmc_print_registers(struct mmc *mmc)
 	printf("    0:    buf_done:             %s\n",
 	       emm_int.s.buf_done ? "yes" : "no");
 
-	emm_wdog.u = mmc_read_csr(mmc, MIO_EMM_WDOG);
+	emm_wdog.u = mmc_read_csr(mmc, CAVM_MIO_EMM_WDOG());
 	printf("\nMIO_EMM_WDOG:                 0x%016llx (%u)\n",
 	       emm_wdog.u, emm_wdog.s.clk_cnt);
 
-	emm_sample.u = mmc_read_csr(mmc, MIO_EMM_SAMPLE);
+	emm_sample.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SAMPLE());
 	printf("\nMIO_EMM_SAMPLE:               0x%016llx\n", emm_sample.u);
 	printf("    16-25: cmd_cnt:             %u\n", emm_sample.s.cmd_cnt);
 	printf("    0-9:   dat_cnt:             %u\n", emm_sample.s.dat_cnt);
 
-	emm_sts_mask.u = mmc_read_csr(mmc, MIO_EMM_STS_MASK);
+	emm_sts_mask.u = mmc_read_csr(mmc, CAVM_MIO_EMM_STS_MASK());
 	printf("\nMIO_EMM_STS_MASK:             0x%016llx\n", emm_sts_mask.u);
 
-	emm_rca.u = mmc_read_csr(mmc, MIO_EMM_RCA);
+	emm_rca.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RCA());
 	printf("\nMIO_EMM_RCA:                  0x%016llx\n", emm_rca.u);
 	printf("    0-15:  card_rca:            %u\n", emm_rca.s.card_rca);
 	puts("\n");
@@ -718,20 +728,20 @@ static void mmc_print_registers(struct mmc *mmc)
 static void mmc_enable(struct mmc *mmc)
 {
 #ifdef __mips
-	union mio_emm_cfg emm_cfg;
-	struct cavium_mmc_slot *slot = mmc->priv;
+	union cavm_mio_emm_cfg emm_cfg;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 
 	debug("%s(%d)\n", __func__, slot->bus_id);
 
-	emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+	emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 	emm_cfg.s.bus_ena |= 1 << slot->bus_id;
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 
 	debug("%s: Wrote 0x%llx to MIO_EMM_CFG\n", __func__, emm_cfg.u);
 	debug("%s: MIO_EMM_MODE: 0x%llx\n", __func__,
-	      mmc_read_csr(mmc, MIO_EMM_MODEX(slot->bus_id)));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(slot->bus_id)));
 	debug("%s: MIO_EMM_SWITCH: 0x%llx\n", __func__,
-	      mmc_read_csr(mmc, MIO_EMM_SWITCH));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH()));
 #endif
 }
 
@@ -746,15 +756,15 @@ static void mmc_enable(struct mmc *mmc)
 static void mmc_disable(struct mmc *mmc)
 {
 #ifdef __mips
-	union mio_emm_cfg emm_cfg;
-	struct cavium_mmc_slot *slot = mmc->priv;
+	union cavm_mio_emm_cfg emm_cfg;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	debug("%s(%d):\n", __func__, slot->bus_id);
 again:
-	emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+	emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 	emm_cfg.s.bus_ena &= ~(1 << slot->bus_id);
 	debug("before:\n");
 	mmc_print_registers(mmc);
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 	debug("after:\n");
 	mmc_print_registers(mmc);
 
@@ -769,14 +779,15 @@ again:
 		 *    repeat steps 1-3, otherwise exit.
 		 */
 		if (emm_cfg.s.bus_ena == 0) {
-			union mio_emm_modex emm_mode;
+			union cavm_mio_emm_modex emm_mode;
 
-			emm_mode.u = mmc_read_csr(mmc, MIO_EMM_MODEX(0));
+			emm_mode.u = mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(0));
 			if (emm_mode.s.clk_hi != 2500) {
 				debug("%s: reset failed, clk_hi: %d, try again\n",
 				      __func__, (int)emm_mode.s.clk_hi);
 				emm_cfg.s.bus_ena |= (1 << slot->bus_id);
-				mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+				mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(),
+					      emm_cfg.u);
 				mdelay(1);
 				goto again;
 			}
@@ -793,15 +804,15 @@ again:
  */
 static void mmc_set_watchdog(const struct mmc *mmc, ulong timeout)
 {
-	union mio_emm_wdog emm_wdog;
-	uint64_t val;
-	struct cavium_mmc_slot *slot = mmc->priv;
+	union cavm_mio_emm_wdog emm_wdog;
+	u64 val;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 
 	val = ((u64)timeout * mmc->clock) / 1000000;
 	if (val >= (1 << 26)) {
 		debug("%s: warning: timeout %lu exceeds max value %llu, truncating\n",
 		      __func__, timeout,
-		     (uint64_t)(((1ULL << 26) - 1) * 1000000ULL) / mmc->clock);
+		     (u64)(((1ULL << 26) - 1) * 1000000ULL) / mmc->clock);
 		val = (1 << 26) - 1;
 	}
 	emm_wdog.u = 0;
@@ -810,7 +821,7 @@ static void mmc_set_watchdog(const struct mmc *mmc, ulong timeout)
 	debug("%s(%p(%s), %lu) clock: %u, period: %u, clk_cnt: %llu)\n",
 	      __func__, mmc, mmc->cfg->name, timeout,
 	      mmc->clock, slot->clk_period, emm_wdog.u);
-	mmc_write_csr(mmc, MIO_EMM_WDOG, emm_wdog.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_WDOG(), emm_wdog.u);
 }
 
 /**
@@ -826,19 +837,19 @@ static void mmc_set_watchdog(const struct mmc *mmc, ulong timeout)
  * @param timeout	timeout to set watchdog less than.
  */
 static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
-			  uint32_t block, uint64_t adr, uint32_t size,
+			  u32 block, u64 adr, u32 size,
 			  int timeout)
 {
-	const struct cavium_mmc_slot *slot = mmc->priv;
+	const struct octeontx_mmc_slot *slot = mmc->priv;
 #ifdef __mips
-	union mio_ndf_dma_cfg ndf_dma_cfg;
-	union mio_ndf_dma_int ndf_dma_int;
+	union cavm_mio_ndf_dma_cfg ndf_dma_cfg;
+	union cavm_mio_ndf_dma_int ndf_dma_int;
 #endif
-	union mio_emm_dma_cfg emm_dma_cfg;
-	union mio_emm_dma_adr emm_dma_adr;
-	union mio_emm_dma_int emm_dma_int;
-	union mio_emm_dma emm_dma;
-	union mio_emm_int emm_int;
+	union cavm_mio_emm_dma_cfg emm_dma_cfg;
+	union cavm_mio_emm_dma_adr emm_dma_adr;
+	union cavm_mio_emm_dma_int emm_dma_int;
+	union cavm_mio_emm_dma emm_dma;
+	union cavm_mio_emm_int emm_int;
 
 	debug("%s(%p(%d), %s, %s, 0x%x, 0x%llx, 0x%x, %d)\n", __func__, mmc,
 	      slot->bus_id, write ? "true" : "false", clear ? "true" : "false",
@@ -854,7 +865,7 @@ static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
 		ndf_dma_cfg.s.rw = !!write;
 		ndf_dma_cfg.s.clr = !!clear;
 		ndf_dma_cfg.s.size =
-				((uint64_t)(size * mmc->read_bl_len) / 8) - 1;
+				((u64)(size * mmc->read_bl_len) / 8) - 1;
 		ndf_dma_cfg.s.adr = adr;
 		debug("%s: Writing 0x%llx to mio_ndf_dma_cfg\n",
 		      __func__, ndf_dma_cfg.u);
@@ -865,14 +876,14 @@ static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
 		emm_dma_int.u = 0;
 		emm_dma_int.s.done = 1;
 		emm_dma_int.s.fifo = 1;
-		mmc_write_csr(mmc, MIO_EMM_DMA_INT, emm_dma_int.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_DMA_INT(), emm_dma_int.u);
 
 		emm_dma_cfg.u = 0;
 		emm_dma_cfg.s.en = 1;
 		emm_dma_cfg.s.rw = !!write;
 		emm_dma_cfg.s.clr = !!clear;
 		emm_dma_cfg.s.size =
-				((uint64_t)(size * mmc->read_bl_len) / 8) - 1;
+				((u64)(size * mmc->read_bl_len) / 8) - 1;
 #if __BYTE_ORDER != __BIG_ENDIAN
 		emm_dma_cfg.s.endian = 1;
 #endif
@@ -881,8 +892,8 @@ static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
 		emm_dma_adr.s.adr = adr;
 		debug("%s: Writing 0x%llx to mio_emm_dma_cfg and 0x%llx to mio_emm_dma_adr\n",
 		      __func__, emm_dma_cfg.u, emm_dma_adr.u);
-		mmc_write_csr(mmc, MIO_EMM_DMA_ADR, emm_dma_adr.u);
-		mmc_write_csr(mmc, MIO_EMM_DMA_CFG, emm_dma_cfg.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_DMA_ADR(), emm_dma_adr.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_DMA_CFG(), emm_dma_cfg.u);
 	}
 	emm_dma.u = 0;
 	emm_dma.s.bus_id = slot->bus_id;
@@ -907,13 +918,13 @@ static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
 	debug("%s: card address: 0x%x, size: %d, multi: %d\n",
 	      __func__, block, size, emm_dma.s.multi);
 	/* Clear interrupt */
-	emm_int.u = mmc_read_csr(mmc, MIO_EMM_INT);
-	mmc_write_csr(mmc, MIO_EMM_INT, emm_int.u);
+	emm_int.u = mmc_read_csr(mmc, CAVM_MIO_EMM_INT());
+	mmc_write_csr(mmc, CAVM_MIO_EMM_INT(), emm_int.u);
 
 	mmc_set_watchdog(mmc, timeout * 1000 - 1000);
 
 	debug("%s: Writing 0x%llx to mio_emm_dma\n", __func__, emm_dma.u);
-	mmc_write_csr(mmc, MIO_EMM_DMA, emm_dma.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
 }
 
 /**
@@ -923,12 +934,12 @@ static void mmc_start_dma(const struct mmc *mmc, bool write, bool clear,
  */
 static inline void mmc_switch_dev(struct mmc *mmc)
 {
-	union mio_emm_switch emm_switch;
-	union mio_emm_sample emm_sample;
-	union mio_emm_rca emm_rca;
-	union mio_emm_sts_mask emm_sts_mask;
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_sample emm_sample;
+	union cavm_mio_emm_rca emm_rca;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
 
 	debug("%s(%s): bus_id: %d, last: %d\n", __func__, mmc->cfg->name,
 	      host->cur_slotid, host->last_slotid);
@@ -939,9 +950,9 @@ static inline void mmc_switch_dev(struct mmc *mmc)
 	}
 	if (!mmc->has_init)
 		debug("%s: %s is not initialized\n", __func__, mmc->cfg->name);
-	emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+	emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 #if defined(DEBUG)
-	emm_rca.u = mmc_read_csr(mmc, MIO_EMM_RCA);
+	emm_rca.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RCA());
 	debug("%s(%s): Switching from:\n"
 	      "    bus id: %d, clock period: %d, width: %d, rca: 0x%x, high speed: %d to\n"
 	      "    bus id: %d, clock period: %d, width: %d, rca: 0x%x, high speed: %d\n",
@@ -952,7 +963,7 @@ static inline void mmc_switch_dev(struct mmc *mmc)
 	      slot->bus_id, slot->clk_period, slot->bus_width, mmc->rca,
 	      !!(mmc->card_caps & MMC_MODE_HS));
 #endif
-	/* mmc_write_csr(mmc, MIO_EMM_CFG, 1 << slot->bus_id);*/
+	/* mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), 1 << slot->bus_id);*/
 	emm_switch.s.bus_width = slot->bus_width;
 	emm_switch.s.hs_timing = mmc->clock > 20000000;
 	debug("%s: hs timing: %d, caps: 0x%x, bus_width: %d (%d bits)\n",
@@ -964,16 +975,16 @@ static inline void mmc_switch_dev(struct mmc *mmc)
 	emm_switch.s.power_class = slot->power_class;
 	debug("%s: Setting MIO_EMM_SWITCH to 0x%llx\n", __func__, emm_switch.u);
 	emm_switch.s.bus_id = 0;
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	udelay(100);
 	emm_switch.s.bus_id = slot->bus_id;
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 
 	debug("Switching RCA from 0x%llx to 0x%x\n",
-	      mmc_read_csr(mmc, MIO_EMM_RCA), mmc->rca);
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_RCA()), mmc->rca);
 	emm_rca.u = 0;
 	emm_rca.s.card_rca = mmc->rca;
-	mmc_write_csr(mmc, MIO_EMM_RCA, emm_rca.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
 	host->last_slotid = host->cur_slotid;
 	mdelay(100);
 	/* Update the watchdog to 100 ms */
@@ -982,20 +993,70 @@ static inline void mmc_switch_dev(struct mmc *mmc)
 	emm_sample.u = 0;
 	emm_sample.s.cmd_cnt = slot->cmd_clk_skew;
 	emm_sample.s.dat_cnt = slot->dat_clk_skew;
-	mmc_write_csr(mmc, MIO_EMM_SAMPLE, emm_sample.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), emm_sample.u);
 	/* Set status mask */
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
-	mmc_write_csr(mmc, MIO_EMM_STS_MASK, emm_sts_mask.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
 
 	debug("%s: MIO_EMM_MODE(%d): 0x%llx, MIO_EMM_SWITCH: 0x%llx\n",
 	      __func__, slot->bus_id,
-	      mmc_read_csr(mmc, MIO_EMM_MODEX(slot->bus_id)),
-	      mmc_read_csr(mmc, MIO_EMM_SWITCH));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(slot->bus_id)),
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH()));
 	mdelay(10);
 	mmc_print_registers(mmc);
 }
 
+/**
+ * Waits for a DMA operation to complete
+ *
+ * @param mmc		mmc data structure
+ * @param timeout	timeout in microseconds to wait
+ *
+ * @return	0 if completed normally, -1 if timed out
+ */
+static int octeontx_mmc_wait_dma(struct mmc *mmc, ulong timeout)
+{
+	ulong start_time = get_timer(0);
+#ifdef __mips
+	struct octeontx_mmc_slot = mmc->priv;
+	const struct octeontx_mmc_host *host = slot->host,
+#endif
+	bool timed_out = false;
+#ifdef __mips
+	if (host->use_ndf) {
+		union cavm_mio_ndf_dma_int ndf_dma_int;
+
+		do {
+			ndf_dma_int.u = mmc_read_csr(mmc,
+						     CAVM_MIO_NDF_DMA_INT());
+			if (ndf_dma_int.s.done)
+				break;
+			udelay(1);
+			WATCHDOG_RESET();
+			timed_out = get_timer(start_time) > timeout;
+		} while (!timed_out);
+	} else {
+#endif
+		union cavm_mio_emm_dma_int emm_dma_int;
+
+		do {
+			emm_dma_int.u = mmc_read_csr(mmc,
+						     CAVM_MIO_EMM_DMA_INT());
+			if (emm_dma_int.s.done)
+				break;
+			udelay(1);
+			WATCHDOG_RESET();
+			timed_out = get_timer(start_time) > timeout;
+		} while (!timed_out);
+#ifdef __mips
+	}
+#endif
+	if (timed_out)
+		puts("Error: MMC read DMA failed to terminate\n");
+	return timed_out ? -1 : 0;
+}
+
 /**
  * Reads one or more sectors into memory
  *
@@ -1006,23 +1067,22 @@ static inline void mmc_switch_dev(struct mmc *mmc)
  *
  * @return number of sectors read
  */
-int cavium_mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
+int octeontx_mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
 {
 	struct mmc_cmd cmd;
 	ulong start_time;
-	uint64_t dma_addr;
-	union mio_emm_dma emm_dma;
-	union mio_emm_dma_int emm_dma_int;
-	union mio_emm_rsp_sts rsp_sts;
-	union mio_emm_int emm_int;
-	union mio_emm_sts_mask emm_sts_mask;
+	u64 dma_addr;
+	union cavm_mio_emm_dma emm_dma;
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	union cavm_mio_emm_int emm_int;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
 #ifdef __mips
-	union mio_ndf_dma_int ndf_dma_int;
+	union cavm_mio_ndf_dma_int ndf_dma_int;
 #endif
 	int timeout;
 	int dma_retry_count = 0;
 	bool timed_out = false;
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 
 	debug("%s(%s, src: 0x%llx, dst: 0x%p, size: %d)\n", __func__,
@@ -1043,9 +1103,9 @@ int cavium_mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
 	/* Enable appropriate errors */
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = R1_BLOCK_READ_MASK;
-	mmc_write_csr(mmc, MIO_EMM_STS_MASK, emm_sts_mask.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
 	debug("%s: MIO_EMM_STS_MASK: 0x%llx\n", __func__, emm_sts_mask.u);
-	dma_addr = (uint64_t)dm_pci_virt_to_mem(mmc->dev, dst);
+	dma_addr = (u64)dm_pci_virt_to_mem(mmc->dev, dst);
 	debug("%s: dma address: 0x%llx\n", __func__, dma_addr);
 
 	timeout = 1000 + size;
@@ -1057,60 +1117,11 @@ int cavium_mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
 
 retry_dma:
 	debug("%s: timeout: %d\n", __func__, timeout);
-	start_time = get_timer(0);
-#ifdef __mips
-	if (host->use_ndf) {
-		do {
-			ndf_dma_int.u = mmc_read_csr(mmc, MIO_NDF_DMA_INT);
-#ifdef DEBUG
-			debug("%s: ndf_dma_int: 0x%llx, ndf_dma_cfg: 0x%llx, mio_emm_dma: 0x%llx, rsp sts: 0x%llx, time: %lu\n",
-			      __func__, ndf_dma_int.u,
-			      mmc_read_csr(mmc, MIO_NDF_DMA_CFG),
-			      mmc_read_csr(mmc, MIO_EMM_DMA),
-			      mmc_read_csr(mmc, MIO_EMM_RSP_STS),
-			      get_timer(start_time));
-#endif
-			if (ndf_dma_int.s.done) {
-				mmc_write_csr(mmc, MIO_NDF_DMA_INT,
-					      ndf_dma_int.u);
-				debug("%s: DMA completed normally\n", __func__);
-				break;
-			}
-
-			WATCHDOG_RESET();
-			timed_out = get_timer(start_time) > timeout;
-			rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
-
-			if (rsp_sts.s.dma_pend) {
-				printf("%s: DMA error, rsp status: 0x%llx\n",
-				       __func__, rsp_sts.u);
-				break;
-			}
-		} while (!timed_out);
-		timed_out |= !ndf_dma_int.s.done;
-	} else
-#endif
-	{
-		do {
-			emm_dma_int.u = mmc_read_csr(mmc,
-						       MIO_EMM_DMA_INT);
-			debug("%s: mio_emm_dma_int: 0x%llx\n", __func__,
-			      emm_dma_int.u);
-
-			if (emm_dma_int.s.done) {
-				mmc_write_csr(mmc, MIO_EMM_DMA_INT,
-					      emm_dma_int.u);
-				break;
-			}
-
-			WATCHDOG_RESET();
-		} while (get_timer(start_time) < timeout);
-		timed_out = !emm_dma_int.s.done;
-	}
-	rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+	timed_out = !!octeontx_mmc_wait_dma(mmc, timeout);
+	rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 	debug("%s: rsp_sts: 0x%llx\n", __func__, rsp_sts.u);
 	if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
-		emm_int.u = mmc_read_csr(mmc, MIO_EMM_INT);
+		emm_int.u = mmc_read_csr(mmc, CAVM_MIO_EMM_INT());
 		mmc_print_registers(mmc);
 		if (timed_out) {
 			printf("%s(%s, 0x%llx, %p, %d)\n",
@@ -1120,12 +1131,13 @@ retry_dma:
 			printf("    MIO_EMM_DMA: 0x%llx, last command: %d\n",
 			       emm_dma.u, rsp_sts.s.cmd_idx);
 			printf("    MIO_EMM_RSP_LO: 0x%llx, HI: 0x%llx\n",
-			       mmc_read_csr(mmc, MIO_EMM_RSP_LO),
-			       mmc_read_csr(mmc, MIO_EMM_RSP_HI));
+			       mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
+			       mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_HI()));
 			printf("    MIO_EMM_MODE(%d): 0x%llx\n", slot->bus_id,
-			       mmc_read_csr(mmc, MIO_EMM_MODEX(slot->bus_id)));
+			       mmc_read_csr(mmc,
+					    CAVM_MIO_EMM_MODEX(slot->bus_id)));
 			printf("    MIO_EMM_DMA_CFG: 0x%llx\n",
-			       mmc_read_csr(mmc, MIO_EMM_DMA_CFG));
+			       mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_CFG()));
 		}
 		if (rsp_sts.s.blk_timeout)
 			printf("Block timeout error detected\n");
@@ -1136,16 +1148,16 @@ retry_dma:
 #ifdef DEBUG
 			if (rsp_sts.s.dma_pend)
 				debug("%s: rsp_sts_low: 0x%llx\n", __func__,
-				      mmc_read_csr(mmc, MIO_EMM_RSP_LO));
+				      mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
 #endif
-			emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+			emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 			emm_dma.s.dma_val = 1;
 			emm_dma.s.dat_null = 1;
-			mmc_write_csr(mmc, MIO_EMM_DMA, emm_dma.u);
+			mmc_write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
 			start_time = get_timer(0);
 			do {
 				rsp_sts.u = mmc_read_csr(mmc,
-							   MIO_EMM_RSP_STS);
+						CAVM_MIO_EMM_RSP_STS());
 				if (rsp_sts.s.dma_val == 0)
 					break;
 				udelay(1);
@@ -1161,37 +1173,8 @@ retry_dma:
 			       src, size);
 			emm_dma.s.dma_val = 1;
 			emm_dma.s.dat_null = 1;
-			mmc_write_csr(mmc, MIO_EMM_DMA, emm_dma.u);
+			mmc_write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
 			timeout = 1000 + size;
-			start_time = get_timer(0);
-#ifdef __mips
-			if (host->use_ndf)
-				do {
-					ndf_dma_int.u =
-						mmc_read_csr(mmc,
-							     MIO_NDF_DMA_INT);
-					if (ndf_dma_int.s.done)
-						break;
-					udelay(1);
-					WATCHDOG_RESET();
-					timed_out =
-					    (get_timer(start_time) > timeout);
-				} while (!timed_out);
-			else
-#endif
-				do {
-					emm_dma_int.u =
-						mmc_read_csr(mmc, MIO_EMM_DMA_INT);
-					if (emm_dma_int.s.done)
-						break;
-					udelay(1);
-					WATCHDOG_RESET();
-					timed_out =
-					    (get_timer(start_time) > timeout);
-				} while (!timed_out);
-			if (timed_out)
-				puts("Error: MMC read DMA failed to terminate!\n");
-
 			return 0;
 		}
 	}
@@ -1202,19 +1185,19 @@ retry_dma:
 	if (timed_out) {
 		printf("MMC read block %llu timed out\n", src);
 		debug("Read status 0x%llx\n", rsp_sts.u);
-		emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+		emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 		debug("EMM_DMA: 0x%llx\n", emm_dma.u);
 
 		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
 		cmd.cmdarg = 0;
 		cmd.resp_type = MMC_RSP_R1b;
-		if (cavium_mmc_send_cmd(mmc->dev, &cmd, NULL))
+		if (octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL))
 			printf("Error sending stop transmission cmd\n");
 		return 0;
 	}
 	debug("Read status 0x%llx\n", rsp_sts.u);
 
-	emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+	emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 	debug("EMM_DMA: 0x%llx\n", emm_dma.u);
 #if defined(DEBUG)
 	print_buffer(0, dst, 1, 512, 0);
@@ -1239,13 +1222,12 @@ retry_dma:
 static ulong
 mmc_write(struct mmc *mmc, ulong start, int size, const void *src)
 {
-	uint64_t dma_addr;
-	union mio_emm_dma emm_dma;
-	union mio_emm_dma_int emm_dma_int;
-	union mio_emm_rsp_sts rsp_sts;
-	union mio_emm_int emm_int;
+	u64 dma_addr;
+	union cavm_mio_emm_dma emm_dma;
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	union cavm_mio_emm_int emm_int;
 #ifdef __mips
-	union mio_ndf_dma_int ndf_dma_int;
+	union cavm_mio_ndf_dma_int ndf_dma_int;
 #endif
 	struct mmc_cmd cmd;
 	int timeout;
@@ -1253,7 +1235,7 @@ mmc_write(struct mmc *mmc, ulong start, int size, const void *src)
 	int rc;
 	ulong start_time;
 	bool timed_out = false;
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 
 	debug("%s(start: %lu, size: %d, src: 0x%p)\n", __func__, start,
@@ -1274,7 +1256,7 @@ mmc_write(struct mmc *mmc, ulong start, int size, const void *src)
 		cmd.cmdidx = MMC_CMD_SEND_STATUS;
 		cmd.cmdarg = mmc->rca << 16;
 		cmd.resp_type = MMC_RSP_R1;
-		rc = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+		rc = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 		if (rc) {
 			printf("%s: Error getting device status\n", __func__);
 			return 0;
@@ -1294,7 +1276,7 @@ mmc_write(struct mmc *mmc, ulong start, int size, const void *src)
 
 	flush_dcache_range((ulong)src,
 			   (ulong)src + size * bdesc->blksz);
-	dma_addr = (uint64_t)dm_pci_virt_to_mem(mmc->dev, (void *)src);
+	dma_addr = (u64)dm_pci_virt_to_mem(mmc->dev, (void *)src);
 	timeout = 5000 + 5000 * size;
 
 	mmc_start_dma(mmc, true, false, start, dma_addr, size, timeout);
@@ -1309,7 +1291,7 @@ retry_dma:
 		}
 #endif
 
-		rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+		rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 		if (((rsp_sts.s.dma_val == 0) || (rsp_sts.s.dma_pend == 1)) &&
 		    rsp_sts.s.cmd_done)
 			break;
@@ -1323,34 +1305,35 @@ retry_dma:
 		printf("%s: write command completion timeout for cmd %d\n",
 		       __func__, rsp_sts.s.cmd_idx);
 	}
-	/*rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);*/
+	/*rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());*/
 	debug("emm_rsp_sts: 0x%llx, cmd: %d, response: 0x%llx\n",
 	      rsp_sts.u, rsp_sts.s.cmd_idx,
-	      mmc_read_csr(mmc, MIO_EMM_RSP_LO));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
 	if (rsp_sts.s.cmd_val || timed_out || rsp_sts.s.dma_val ||
 	    rsp_sts.s.dma_pend) {
-		emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
-		emm_int.u = mmc_read_csr(mmc, MIO_EMM_INT);
+		emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
+		emm_int.u = mmc_read_csr(mmc, CAVM_MIO_EMM_INT());
 #ifdef __mips
 		printf("%s: Error detected: MIO_EMM_RSP_STS: 0x%llx, MIO_EMM_DMA: 0x%llx,\n"
 		       "    %s: 0x%llx, timeout: %d\n",
 		       __func__, rsp_sts.u, emm_dma.u,
 		       host->use_ndf ? "MIO_NDF_DMA_CFG" : "MIO_EMM_DMA_CFG",
 		       host->use_ndf ? mmc_read_csr(mmc, MIO_NDF_DMA_CFG) :
-		       mmc_read_csr(mmc, MIO_EMM_DMA_CFG), timeout);
+		       mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_CFG()), timeout);
 #else
 		printf("%s: Error detected: MIO_EMM_RSP_STS: 0x%llx, MIO_EMM_DMA: 0x%llx,\n"
 		       "    MIO_EMM_DMA_CFG: 0x%llx, timeout: %d\n",
 		       __func__, rsp_sts.u, emm_dma.u,
-		       mmc_read_csr(mmc, MIO_EMM_DMA_CFG), timeout);
+		       mmc_read_csr(mmc, CAVM_MIO_EMM_DMA_CFG()), timeout);
 #endif
 		printf("Last command index: %d\n", rsp_sts.s.cmd_idx);
 		printf("emm_int: 0x%llx\n", emm_int.u);
 		mdelay(10);
-		rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+		rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 		printf("Re-read rsp_sts: 0x%llx, cmd_idx: %d\n", rsp_sts.u,
 		       rsp_sts.s.cmd_idx);
-		printf("  RSP_LO: 0x%llx\n", mmc_read_csr(mmc, MIO_EMM_RSP_LO));
+		printf("  RSP_LO: 0x%llx\n",
+		       mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
 		if (timed_out) {
 			printf("%s(mmc, 0x%lx, %d, 0x%p)\n",
 			       __func__, start, size, src);
@@ -1374,37 +1357,15 @@ retry_dma:
 			cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
 			cmd.cmdarg = 0;
 			cmd.resp_type = MMC_RSP_R1b;
-			cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
-			mmc_write_csr(mmc, MIO_EMM_DMA, emm_dma.u);
+			octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
+			mmc_write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
 			debug("Retrying MMC write DMA\n");
 			goto retry_dma;
 		} else {
 			emm_dma.s.dma_val = 1;
 			emm_dma.s.dat_null = 1;
-			mmc_write_csr(mmc, MIO_EMM_DMA, emm_dma.u);
-			start_time = get_timer(0);
-#ifdef __mips
-			if (host->use_ndf)
-				do {
-					ndf_dma_int.u =
-						mmc_read_csr(mmc,
-							     MIO_NDF_DMA_INT);
-					if (ndf_dma_int.s.done)
-						break;
-					udelay(1);
-				} while (get_timer(start_time) < timeout);
-			else
-#endif
-				do {
-					emm_dma_int.u =
-						mmc_read_csr(mmc,
-							     MIO_EMM_DMA_INT);
-					if (emm_dma_int.s.done)
-						break;
-					udelay(1);
-				} while (get_timer(start_time) < timeout);
-			if (timeout <= 0)
-				puts("Error: MMC write DMA failed to terminate!\n");
+			mmc_write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+			octeontx_mmc_wait_dma(mmc, timeout);
 			return 0;
 		}
 	}
@@ -1415,13 +1376,13 @@ retry_dma:
 	if (timed_out) {
 		printf("MMC write block %lu timed out\n", start);
 		debug("Write status 0x%llx\n", rsp_sts.u);
-		emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+		emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 		debug("EMM_DMA: 0x%llx\n", emm_dma.u);
 
 		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
 		cmd.cmdarg = 0;
 		cmd.resp_type = MMC_RSP_R1b;
-		if (cavium_mmc_send_cmd(mmc->dev, &cmd, NULL))
+		if (octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL))
 			printf("Error sending stop transmission cmd\n");
 		return 0;
 	}
@@ -1430,7 +1391,7 @@ retry_dma:
 	/* Poll status if we can't send data right away */
 	if (!((rsp_sts.s.cmd_idx == MMC_CMD_SEND_STATUS) &&
 	      rsp_sts.s.cmd_done &&
-	      ((mmc_read_csr(mmc, MIO_EMM_RSP_LO) >> 8) &
+	      ((mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()) >> 8) &
 	       R1_READY_FOR_DATA))) {
 		/* Poll for ready status */
 		timeout = 10000;	/* 10 seconds */
@@ -1440,7 +1401,7 @@ retry_dma:
 			cmd.cmdidx = MMC_CMD_SEND_STATUS;
 			cmd.cmdarg = mmc->rca << 16;
 			cmd.resp_type = MMC_RSP_R1;
-			rc = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+			rc = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 			if (rc) {
 				printf("%s: Error getting post device status\n",
 				       __func__);
@@ -1458,7 +1419,7 @@ retry_dma:
 		}
 	}
 
-	emm_dma.u = mmc_read_csr(mmc, MIO_EMM_DMA);
+	emm_dma.u = mmc_read_csr(mmc, CAVM_MIO_EMM_DMA());
 	debug("EMM_DMA: 0x%llx\n", emm_dma.u);
 
 	return size - emm_dma.s.block_cnt;
@@ -1495,7 +1456,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 	cmd.cmdarg = start;
 	cmd.resp_type = MMC_RSP_R1;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		goto err_out;
 
@@ -1503,7 +1464,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 	cmd.cmdarg = end;
 	cmd.resp_type = MMC_RSP_R1b;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		goto err_out;
 
@@ -1511,7 +1472,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 	cmd.cmdarg = 0;
 	cmd.resp_type = MMC_RSP_R1b;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err) {
 		printf("%s err: %d\n", __func__, err);
 		goto err_out;
@@ -1539,9 +1500,9 @@ unsigned long mmc_bread(struct udevice *dev, lbaint_t start,
 	debug("%s ->1 dev %p\n", __func__, dev);
 	debug("%s ->1 parent %p\n", __func__, dev->parent);
 	lbaint_t cur, blocks_todo = blkcnt;
-	struct cavium_mmc_host *host = dev_get_priv(dev->parent);
+	struct octeontx_mmc_host *host = dev_get_priv(dev->parent);
 	debug("%s ->2 %p\n", __func__, host);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 	unsigned char bounce_buffer[4096];
@@ -1551,9 +1512,10 @@ unsigned long mmc_bread(struct udevice *dev, lbaint_t start,
 		return 0;
 	}
 	debug("%s(%d %llu, %llu, %p) mmc: %p\n", __func__, bdesc->devnum,
-	      (uint64_t)start, (uint64_t)blkcnt, dst, mmc);
+	      (u64)start, (u64)blkcnt, dst, mmc);
 	if (!mmc) {
-		printf("%s: MMC device %d not found\n", __func__, bdesc->devnum);
+		printf("%s: MMC device %d not found\n", __func__,
+		       bdesc->devnum);
 		return 0;
 	}
 
@@ -1562,8 +1524,8 @@ unsigned long mmc_bread(struct udevice *dev, lbaint_t start,
 
 	if ((start + blkcnt) > bdesc->lba) {
 		printf("MMC: block number 0x%llx exceeds max(0x%llx)\n",
-		       (uint64_t)(start + blkcnt),
-		       (uint64_t)bdesc->lba);
+		       (u64)(start + blkcnt),
+		       (u64)bdesc->lba);
 		return 0;
 	}
 
@@ -1577,7 +1539,8 @@ unsigned long mmc_bread(struct udevice *dev, lbaint_t start,
 	if (((ulong)dst) & 7) {
 		debug("%s: Using bounce buffer due to alignment\n", __func__);
 		do {
-			if (cavium_mmc_read(mmc, start, bounce_buffer, 1) != 1)
+			if (octeontx_mmc_read(mmc, start,
+					      bounce_buffer, 1) != 1)
 				return 0;
 			memcpy(dst, bounce_buffer, mmc->read_bl_len);
 			WATCHDOG_RESET();
@@ -1588,7 +1551,7 @@ unsigned long mmc_bread(struct udevice *dev, lbaint_t start,
 	} else {
 		do {
 			cur = min(blocks_todo, (lbaint_t)(mmc->cfg->b_max));
-			if (cavium_mmc_read(mmc, start, dst, cur) != cur) {
+			if (octeontx_mmc_read(mmc, start, dst, cur) != cur) {
 				blkcnt = 0;
 				break;
 			}
@@ -1616,8 +1579,8 @@ ulong mmc_bwrite(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
 		 const void *src)
 {
 	lbaint_t cur, blocks_todo = blkcnt;
-	struct cavium_mmc_host *host = dev_get_priv(dev->parent);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev->parent);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 	int dev_num;
@@ -1628,8 +1591,8 @@ ulong mmc_bwrite(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
 		return 0;
 	}
 	dev_num = bdesc->devnum;
-	debug("%s(%d, %llu, %llu, %p)\n", __func__, dev_num, (uint64_t)start,
-	      (uint64_t)blkcnt, src);
+	debug("%s(%d, %llu, %llu, %p)\n", __func__, dev_num, (u64)start,
+	      (u64)blkcnt, src);
 	if (!mmc) {
 		printf("MMC Write: device %d not found\n", dev_num);
 		return 0;
@@ -1639,8 +1602,8 @@ ulong mmc_bwrite(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
 		return 0;
 	if ((start + blkcnt) > bdesc->lba) {
 		printf("MMC: block number 0x%llx exceeds max(0x%llx)\n",
-		       (uint64_t)(start + blkcnt),
-		       (uint64_t)bdesc->lba);
+		       (u64)(start + blkcnt),
+		       (u64)bdesc->lba);
 		return 0;
 	}
 	if (!mmc_getcd(mmc)) {
@@ -1698,8 +1661,8 @@ ulong mmc_bwrite(struct udevice *dev, lbaint_t start, lbaint_t blkcnt,
 ulong mmc_berase(struct udevice *dev, lbaint_t start, lbaint_t blkcnt)
 {
 	int err = 0;
-	struct cavium_mmc_host *host = dev_get_priv(dev->parent);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev->parent);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 	int dev_num = bdesc->devnum;
@@ -1719,8 +1682,8 @@ ulong mmc_berase(struct udevice *dev, lbaint_t start, lbaint_t blkcnt)
 		printf("\n\nCaution!  Your device's erase group is 0x%x\n"
 		       "The erase range would be changed to 0x%llx~0x%llx\n\n",
 		       mmc->erase_grp_size,
-		       (uint64_t)(start & ~(mmc->erase_grp_size - 1)),
-		       (uint64_t)((start + blkcnt + mmc->erase_grp_size)
+		       (u64)(start & ~(mmc->erase_grp_size - 1)),
+		       (u64)((start + blkcnt + mmc->erase_grp_size)
 				  & ~(mmc->erase_grp_size - 1)) - 1);
 
 	mmc_enable(mmc);
@@ -1739,18 +1702,18 @@ ulong mmc_berase(struct udevice *dev, lbaint_t start, lbaint_t blkcnt)
  *
  * @return	crc7 value left shifted by 1 with LSB set to 1.
  */
-static uint8_t mmc_crc7_32(const uint32_t *data, int count)
+static u8 mmc_crc7_32(const u32 *data, int count)
 {
-	uint8_t crc = 0;
+	u8 crc = 0;
 	int index;
-	uint8_t d;
+	u8 d;
 	int shift = 24;
 	int i;
 
-	count = count * sizeof(uint32_t) - 1;
+	count = count * sizeof(u32) - 1;
 
 	for (index = 0; index < count; index++) {
-		d = (data[index / sizeof(uint32_t)] >> shift) & 0xff;
+		d = (data[index / sizeof(u32)] >> shift) & 0xff;
 		shift = shift >= 8 ? shift - 8 : 24;
 		for (i = 0; i < 8; i++) {
 			crc <<= 1;
@@ -1785,11 +1748,11 @@ int mmc_set_dsr(struct mmc *mmc, u16 val)
  */
 void print_mmc_device_info(struct mmc *mmc)
 {
-	const struct cavium_mmc_slot *slot = mmc->priv;
+	const struct octeontx_mmc_slot *slot = mmc->priv;
 	const char *type;
 	const char *version;
-	const uint8_t *ext_csd = slot->ext_csd;
-	uint32_t card_type;
+	const u8 *ext_csd = slot->ext_csd;
+	u32 card_type;
 	int prev = 0;
 	int i;
 	static const char *cbx_str[4] = {
@@ -1806,7 +1769,7 @@ void print_mmc_device_info(struct mmc *mmc)
 
 	printf("Register base address: %p\n", slot->host->base_addr);
 	debug("MIO_EMM_MODE: 0x%llx\n",
-	      mmc_read_csr(mmc, MIO_EMM_MODEX(slot->bus_id)));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(slot->bus_id)));
 
 	if (!bdesc) {
 		printf("%s couldn't find blk desc\n", __func__);
@@ -1829,7 +1792,7 @@ void print_mmc_device_info(struct mmc *mmc)
 	}
 
 	switch (mmc->version) {
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 	case SD_VERSION_2:
 	case SD_VERSION_3:
 	case SD_VERSION_4:	/* Decode versions 2-4 here */
@@ -2010,7 +1973,7 @@ void print_mmc_device_info(struct mmc *mmc)
 	printf("Device is %sremovable\n", slot->non_removable ? "non-" : "");
 	if (IS_SD(mmc)) {
 		const char *sd_security;
-		uint8_t sd_spec, sd_spec3, sd_spec4;
+		u8 sd_spec, sd_spec3, sd_spec4;
 		const char *spec_ver;
 		const char *bus_widths;
 
@@ -2209,7 +2172,7 @@ void print_mmc_device_info(struct mmc *mmc)
 				printf("\n%3u: ", i);
 			if (i % 16 == 8)
 				puts("- ");
-			printf("%02x ", (uint32_t)ext_csd[i]);
+			printf("%02x ", (u32)ext_csd[i]);
 		}
 		puts("\n");
 	}
@@ -2241,7 +2204,7 @@ int mmc_set_blocklen(struct mmc *mmc, int len)
 	cmd.cmdarg = len;
 
 	debug("%s: Setting block length to %d\n", __func__, len);
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		printf("%s: Error setting block length to %d\n", __func__, len);
 
@@ -2250,7 +2213,7 @@ int mmc_set_blocklen(struct mmc *mmc, int len)
 
 static int mmc_set_capacity(struct mmc *mmc, int part_num)
 {
-	const struct cavium_mmc_slot *slot = mmc->priv;
+	const struct octeontx_mmc_slot *slot = mmc->priv;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 
 	if (!bdesc) {
@@ -2285,9 +2248,17 @@ static int mmc_set_capacity(struct mmc *mmc, int part_num)
 	return 0;
 }
 
+/**
+ * Switch MMC partition number
+ *
+ * @param mmc		mmc device
+ * @param part_num	partition to switch to
+ *
+ * @return 0 for success, otherwise error
+ */
 int mmc_switch_part(struct mmc *mmc, unsigned int part_num)
 {
-	const struct cavium_mmc_slot *slot = mmc->priv;
+	const struct octeontx_mmc_slot *slot = mmc->priv;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 	int ret;
 
@@ -2535,7 +2506,7 @@ static int
 oct_mmc_wait_cmd(struct mmc *mmc, int bus_id, int cmd_idx, int flags,
 		 uint timeout)
 {
-	union mio_emm_rsp_sts emm_rsp_sts;
+	union cavm_mio_emm_rsp_sts emm_rsp_sts;
 	unsigned long base_time;
 	ulong time = 0;
 
@@ -2544,7 +2515,7 @@ oct_mmc_wait_cmd(struct mmc *mmc, int bus_id, int cmd_idx, int flags,
 	base_time = get_timer(0);
 
 	do {
-		emm_rsp_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+		emm_rsp_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 		if (emm_rsp_sts.s.cmd_done || emm_rsp_sts.s.rsp_timeout)
 			break;
 		WATCHDOG_RESET();
@@ -2574,7 +2545,7 @@ oct_mmc_wait_cmd(struct mmc *mmc, int bus_id, int cmd_idx, int flags,
 	    (emm_rsp_sts.s.rsp_crc_err &&
 		!(flags & MMC_CMD_FLAG_IGNORE_CRC_ERR)) ||
 	    emm_rsp_sts.s.rsp_bad_sts) {
-		uint64_t status = mmc_read_csr(mmc, MIO_EMM_RSP_LO) >> 8;
+		u64 status = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO()) >> 8;
 		debug("%s: Bad response for bus id %d, cmd id %d:\n"
 		      "    rsp_timeout: %d\n"
 		      "    rsp_bad_sts: %d\n"
@@ -2621,14 +2592,14 @@ oct_mmc_wait_cmd(struct mmc *mmc, int bus_id, int cmd_idx, int flags,
 static int
 mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
 		     struct mmc_data *data,
-		     uint32_t flags, uint timeout)
+		     u32 flags, uint timeout)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	union mio_emm_cmd emm_cmd;
-	union mio_emm_buf_idx emm_buf_idx;
-	union mio_emm_buf_dat emm_buf_dat;
-	uint64_t resp_lo;
-	uint64_t resp_hi;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	union cavm_mio_emm_cmd emm_cmd;
+	union cavm_mio_emm_buf_idx emm_buf_idx;
+	union cavm_mio_emm_buf_dat emm_buf_dat;
+	u64 resp_lo;
+	u64 resp_hi;
 	int i;
 	int bus_id = slot->bus_id;
 
@@ -2641,7 +2612,8 @@ mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
 	mmc_set_watchdog(mmc, timeout ? timeout * 1000 : (1 << 26) - 1);
 
 	/* Clear any interrupts */
-	mmc_write_csr(mmc, MIO_EMM_INT, mmc_read_csr(mmc, MIO_EMM_INT));
+	mmc_write_csr(mmc, CAVM_MIO_EMM_INT(),
+		      mmc_read_csr(mmc, CAVM_MIO_EMM_INT()));
 	emm_cmd.u = 0;
 	emm_cmd.s.cmd_val = 1;
 	emm_cmd.s.bus_id = bus_id;
@@ -2666,18 +2638,19 @@ mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
 		}
 		emm_buf_idx.u = 0;
 		emm_buf_idx.s.inc = 1;
-		mmc_write_csr(mmc, MIO_EMM_BUF_IDX, emm_buf_idx.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
 		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
 			memcpy(&emm_buf_dat.u, src, sizeof(emm_buf_dat));
 			emm_buf_dat.u = cpu_to_be64(emm_buf_dat.u);
-			mmc_write_csr(mmc, MIO_EMM_BUF_DAT, emm_buf_dat.u);
+			mmc_write_csr(mmc, CAVM_MIO_EMM_BUF_DAT(),
+				      emm_buf_dat.u);
 			debug("mmc cmd: buffer 0x%x: 0x%llx\n",
 			      i*8, emm_buf_dat.u);
 			src += sizeof(emm_buf_dat);
 		}
 		debug("mmc cmd: wrote %d 8-byte blocks to buffer\n", i);
 	}
-	mmc_write_csr(mmc, MIO_EMM_CMD, emm_cmd.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CMD(), emm_cmd.u);
 
 	if (oct_mmc_wait_cmd(mmc, bus_id, cmd->cmdidx, flags, timeout)) {
 		if (!init_time) {
@@ -2693,9 +2666,9 @@ mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
 		return 0;
 	}
 
-	resp_lo = mmc_read_csr(mmc, MIO_EMM_RSP_LO);
+	resp_lo = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
 	if (cmd->resp_type & MMC_RSP_136) {
-		resp_hi = mmc_read_csr(mmc, MIO_EMM_RSP_HI);
+		resp_hi = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_HI());
 		debug("mmc cmd: response hi: 0x%016llx\n", resp_hi);
 		cmd->response[0] = resp_hi >> 32;
 		cmd->response[1] = resp_hi & 0xffffffff;
@@ -2722,9 +2695,10 @@ mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
 		}
 		emm_buf_idx.u = 0;
 		emm_buf_idx.s.inc = 1;
-		mmc_write_csr(mmc, MIO_EMM_BUF_IDX, emm_buf_idx.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
 		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
-			emm_buf_dat.u = mmc_read_csr(mmc, MIO_EMM_BUF_DAT);
+			emm_buf_dat.u = mmc_read_csr(mmc,
+						     CAVM_MIO_EMM_BUF_DAT());
 			emm_buf_dat.u = be64_to_cpu(emm_buf_dat.u);
 			memcpy(dest, &emm_buf_dat.u, sizeof(emm_buf_dat));
 			       dest += sizeof(emm_buf_dat);
@@ -2744,7 +2718,7 @@ mmc_send_cmd_timeout(struct mmc *mmc, struct mmc_cmd *cmd,
  * @return		0 for success, error otherwise
  */
 static int mmc_send_cmd_flags(struct mmc *mmc, struct mmc_cmd *cmd,
-			      struct mmc_data *data, uint32_t flags)
+			      struct mmc_data *data, u32 flags)
 {
 	uint timeout;
 	/**
@@ -2754,7 +2728,7 @@ static int mmc_send_cmd_flags(struct mmc *mmc, struct mmc_cmd *cmd,
 	 *   CMD6, CMD17, CMD18, CMD24, CMD25, CMD32, CMD33, CMD35, CMD36 and
 	 *   CMD38.
 	 */
-	static const uint64_t timeout_short = 0xFFFFFFA4FCF9FFDFULL;
+	static const u64 timeout_short = 0xFFFFFFA4FCF9FFDFULL;
 
 	debug("%s(%s, cmd: %u, arg: 0x%x flags: 0x%x)\n", __func__,
 	      mmc->cfg->name, cmd->cmdidx, cmd->cmdarg, flags);
@@ -2786,7 +2760,7 @@ static int mmc_send_cmd_flags(struct mmc *mmc, struct mmc_cmd *cmd,
  * @return		0 for success, error otherwise
  */
 static int mmc_send_acmd(struct mmc *mmc, struct mmc_cmd *cmd,
-			 struct mmc_data *data, uint32_t flags)
+			 struct mmc_data *data, u32 flags)
 {
 	struct mmc_cmd acmd;
 	int err;
@@ -2799,7 +2773,7 @@ static int mmc_send_acmd(struct mmc *mmc, struct mmc_cmd *cmd,
 		debug("%s: Error, not SD card\n", __func__);
 		return -1;
 	}
-	err = cavium_mmc_send_cmd(mmc->dev, &acmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &acmd, NULL);
 	if (err) {
 		printf("%s: Error sending ACMD to SD card\n", __func__);
 		return err;
@@ -2813,7 +2787,7 @@ static int mmc_send_acmd(struct mmc *mmc, struct mmc_cmd *cmd,
 /** Change the bus width */
 static void mmc_set_bus_width(struct mmc *mmc, uint width)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	mmc->bus_width = min(width, (uint)slot->bus_max_width);
 	debug("%s(%s, %u): seting bus_width to %u\n", __func__,
 	      mmc->cfg->name, width, mmc->bus_width);
@@ -2828,7 +2802,7 @@ static int mmc_pre_idle(struct mmc *mmc)
 	cmd.cmdarg = 0xf0f0f0f0;	/* Software Reset */
 	cmd.resp_type = MMC_RSP_NONE;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		debug("%s: error %d\n", __func__, err);
 	else
@@ -2849,7 +2823,7 @@ static int mmc_go_idle(struct mmc *mmc)
 		cmd.cmdarg = 0;
 		cmd.resp_type = MMC_RSP_NONE;
 
-		err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+		err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 		if (err)
 			return err;
 	}
@@ -2857,7 +2831,7 @@ static int mmc_go_idle(struct mmc *mmc)
 	return 0;
 }
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_send_relative_addr(struct mmc *mmc)
 {
 	int err;
@@ -2876,10 +2850,10 @@ static int sd_send_relative_addr(struct mmc *mmc)
 		return err;
 	}
 	mmc->rca = cmd.response[0] >> 16;
-	mmc_write_csr(mmc, MIO_EMM_RCA, mmc->rca);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
 	debug("%s: SD RCA is %d (0x%x)\n", __func__, mmc->rca, mmc->rca);
 	debug("%s: MIO_EMM_RCA: 0x%llx\n", __func__,
-	      mmc_read_csr(mmc, MIO_EMM_RCA));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_RCA()));
 	return 0;
 }
 #endif
@@ -2902,7 +2876,7 @@ static int mmc_set_relative_addr(struct mmc *mmc)
 	cmd.cmdidx = MMC_CMD_SET_RELATIVE_ADDR;
 	cmd.cmdarg = mmc->rca << 16;
 	cmd.resp_type = MMC_RSP_R1;
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		printf("%s: Error %d, failed to set RCA to %d\n", __func__,
 		       err, mmc->rca);
@@ -2922,12 +2896,12 @@ static int mmc_select_card(struct mmc *mmc)
 	cmd.resp_type = MMC_RSP_R1b;
 	cmd.cmdarg = mmc->rca << 16;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err)
 		printf("%s: Error selecting card with rca %d\n",
 		       __func__, mmc->rca);
 	else
-		mmc_write_csr(mmc, MIO_EMM_RCA, mmc->rca);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
 	return err;
 }
 
@@ -2943,7 +2917,7 @@ static int mmc_all_send_cid(struct mmc *mmc)
 	struct mmc_cmd cmd;
 	int err;
 #ifdef DEBUG
-	uint8_t crc7;
+	u8 crc7;
 #endif
 
 	memset(&cmd, 0, sizeof(cmd));
@@ -2952,7 +2926,7 @@ static int mmc_all_send_cid(struct mmc *mmc)
 	cmd.cmdidx = MMC_CMD_ALL_SEND_CID;
 	cmd.resp_type = MMC_RSP_R2;
 	cmd.cmdarg = 0;
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err) {
 		debug("%s: Error getting all CID\n", __func__);
 		return err;
@@ -3038,7 +3012,7 @@ static int mmc_get_csd(struct mmc *mmc)
 	cmd.cmdidx = MMC_CMD_SEND_CSD;
 	cmd.resp_type = MMC_RSP_R2;
 	cmd.cmdarg = mmc->rca << 16;
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 	if (err) {
 		printf("%s: Error getting CSD\n", __func__);
 		return err;
@@ -3052,13 +3026,13 @@ static int mmc_get_csd(struct mmc *mmc)
 	return 0;
 }
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_set_bus_width_speed(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
 	int err;
 #ifdef DEBUG
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	debug("%s(%s) width: %d %d\n", __func__, mmc->cfg->name,
 	      mmc->bus_width, slot->bus_width);
 #endif
@@ -3133,13 +3107,13 @@ static int mmc_set_bus_width_speed(struct mmc *mmc)
 	return 0;
 }
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 int sd_send_op_cond(struct mmc *mmc)
 {
 	int timeout = 1000;
 	int err;
 	struct mmc_cmd cmd;
-	uint32_t flags = MMC_CMD_FLAG_RTYPE_XOR(3) | MMC_CMD_FLAG_STRIP_CRC;
+	u32 flags = MMC_CMD_FLAG_RTYPE_XOR(3) | MMC_CMD_FLAG_STRIP_CRC;
 
 	debug("%s(%s)\n", __func__, mmc->cfg->name);
 	mmc->rca = 0;
@@ -3278,7 +3252,7 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	struct mmc_cmd cmd;
 	struct mmc_data data;
 #ifdef DEBUG
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 #endif
 	int err;
 
@@ -3294,7 +3268,7 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	data.blocksize = MMC_MAX_BLOCK_LEN;
 	data.flags = MMC_DATA_READ;
 
-	err = cavium_mmc_send_cmd(mmc->dev, &cmd, &data);
+	err = octeontx_mmc_send_cmd(mmc->dev, &cmd, &data);
 
 	if (err) {
 		printf("%s: Error getting extended CSD\n", __func__);
@@ -3317,15 +3291,15 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 				(index << 16) | (value << 8) | set;
 
-	return cavium_mmc_send_cmd(mmc->dev, &cmd, NULL);
+	return octeontx_mmc_send_cmd(mmc->dev, &cmd, NULL);
 }
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_set_ios(struct mmc *mmc)
 {
-	union mio_emm_switch emm_switch;
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
 	int clock = mmc->clock;
 
 	debug("%s(%s)\n", __func__, mmc->cfg->name);
@@ -3348,10 +3322,10 @@ static int sd_set_ios(struct mmc *mmc)
 	emm_switch.s.power_class = slot->power_class;
 	debug("%s: Writing emm_switch value 0x%llx\n",
 	      __func__, emm_switch.u);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	emm_switch.s.bus_id = slot->bus_id;
 	udelay(100);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	mdelay(20);
 #ifdef DEBUG
 	mmc_print_registers(mmc);
@@ -3360,14 +3334,14 @@ static int sd_set_ios(struct mmc *mmc)
 }
 #endif
 
-static int cavium_mmc_set_ios(struct udevice *dev)
+static int octeontx_mmc_set_ios(struct udevice *dev)
 {
-	union mio_emm_switch emm_switch;
-	union mio_emm_rsp_sts emm_sts;
-	union mio_emm_sample emm_sample;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_rsp_sts emm_sts;
+	union cavm_mio_emm_sample emm_sample;
 	int switch_timeout_ms = 2550;
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	int timeout = 2000;
 	char cardtype;
@@ -3376,10 +3350,10 @@ static int cavium_mmc_set_ios(struct udevice *dev)
 	int bus_width;
 	int power_class;
 	int clock = mmc->clock;
-	uint32_t flags = 0;
+	u32 flags = 0;
 	int index;
 #ifdef DEBUG
-	union mio_emm_rsp_lo emm_rsp_lo;
+	union cavm_mio_emm_rsp_lo emm_rsp_lo;
 #endif
 
 	debug("%s(%s)\n", __func__, mmc->cfg->name);
@@ -3434,7 +3408,7 @@ static int cavium_mmc_set_ios(struct udevice *dev)
 		debug("        High-Speed DDR eMMC 52MHz at 1.8V or 3V I/O\n");
 		hs_timing = true;
 		if ((mmc->cfg->voltages & MMC_VDD_165_195) ||
-		    env_get("cavium_mmc_ddr"))
+		    env_get("octeontx_mmc_ddr"))
 			ddr = true;
 	}
 	if (cardtype & EXT_CSD_CARD_TYPE_DDR_1_2V) {
@@ -3561,7 +3535,7 @@ static int cavium_mmc_set_ios(struct udevice *dev)
 	emm_sample.u = 0;
 	emm_sample.s.cmd_cnt = slot->cmd_clk_skew;
 	emm_sample.s.dat_cnt = slot->dat_clk_skew;
-	mmc_write_csr(mmc, MIO_EMM_SAMPLE, emm_sample.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), emm_sample.u);
 	debug("%s: Setting command clock skew to %d, data to %d sclock cycles\n",
 	      __func__, slot->cmd_clk_skew, slot->dat_clk_skew);
 
@@ -3604,12 +3578,12 @@ again:
 	debug("%s: clock period: %u\n", __func__, slot->clk_period);
 	debug("%s: Writing 0x%llx to mio_emm_switch\n",
 	      __func__, emm_switch.u);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	udelay(100);
 
 	timeout = (switch_timeout_ms + 10) * 10;
 	do {
-		emm_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+		emm_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 		if (!emm_sts.s.switch_val)
 			break;
 		udelay(100);
@@ -3620,16 +3594,16 @@ again:
 		return -1;
 	}
 
-	emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+	emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 	debug("Switch command response: 0x%llx, switch: 0x%llx\n",
 	      emm_sts.u, emm_switch.u);
 #if defined(DEBUG)
-	emm_rsp_lo.u = mmc_read_csr(mmc, MIO_EMM_RSP_LO);
+	emm_rsp_lo.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
 	debug("Switch response lo: 0x%llx\n", emm_rsp_lo.u);
 #endif
 
 	if (emm_sts.s.rsp_crc_err && mmc->clock <= 20000000) {
-		uint32_t next_speed;
+		u32 next_speed;
 		if (mmc->clock >= 4000000) {
 			next_speed = mmc->clock - 2000000;
 		} else if (mmc->clock > 1400000) {
@@ -3664,10 +3638,10 @@ again:
 		emm_switch.s.clk_hi = (slot->clk_period + 1) / 2;
 		emm_switch.s.clk_lo = (slot->clk_period + 1) / 2;
 		debug("%s: clock period: %u\n", __func__, slot->clk_period);
-		mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 		mdelay(1);
 		emm_switch.s.bus_id = slot->bus_id;
-		mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 		mdelay(1);
 	}
 	if ((emm_switch.s.switch_err1 | emm_switch.s.switch_err2) &&
@@ -3748,7 +3722,7 @@ again:
 			/* Width succeeded, test the bus */
 			struct mmc_cmd mmc_cmd;
 			struct mmc_data mmc_data;
-			uint8_t buffer[16];
+			u8 buffer[16];
 
 			debug("Testing bus width %d (%d)\n",
 			      mmc->bus_width, bus_width);
@@ -3800,7 +3774,8 @@ again:
 			mmc_cmd.cmdarg = 0;
 			mmc_cmd.cmdidx = 19;	/* BUSTEST_W */
 			mmc_cmd.resp_type = MMC_RSP_R1;
-			if (cavium_mmc_send_cmd(mmc->dev, &mmc_cmd, &mmc_data) != 0)
+			if (octeontx_mmc_send_cmd(mmc->dev, &mmc_cmd,
+						  &mmc_data) != 0)
 				puts("Warning: problem sending BUSTEST_W command\n");
 
 			debug("BUSTEST_W response is 0x%x 0x%x 0x%x 0x%x\n",
@@ -3940,12 +3915,12 @@ again:
 		emm_switch.s.clk_hi = (slot->clk_period + 1) / 2;
 		emm_switch.s.clk_lo = (slot->clk_period + 1) / 2;
 		debug("%s: clock period: %u\n", __func__, slot->clk_period);
-		mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 		udelay(100);
 
 		timeout = switch_timeout_ms + 10;
 		do {
-			emm_sts.u = mmc_read_csr(mmc, MIO_EMM_RSP_STS);
+			emm_sts.u = mmc_read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
 			if (!emm_sts.s.switch_val)
 				break;
 			mdelay(1);
@@ -3979,9 +3954,9 @@ again:
  */
 void mmc_set_clock(struct mmc *mmc, uint clock)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
-	union mio_emm_switch emm_switch;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
 	unsigned bus;
 
 	debug("%s(%s, %u)\n", __func__, mmc->cfg->name, clock);
@@ -4005,7 +3980,7 @@ void mmc_set_clock(struct mmc *mmc, uint clock)
 
 	debug("%s: Reading MIO_EMM_SWITCH\n", __func__);
 	/* Write the change to the hardware */
-	emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+	emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 	emm_switch.s.clk_hi = (slot->clk_period + 1) / 2;
 	emm_switch.s.clk_lo = emm_switch.s.clk_hi;
 	bus = emm_switch.s.bus_id;
@@ -4014,20 +3989,22 @@ void mmc_set_clock(struct mmc *mmc, uint clock)
 
 	emm_switch.s.bus_id = 0;
 	emm_switch.s.hs_timing = (mmc->clock > 20000000);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
-	debug("  mio_emm_switch: 0x%llx\n", mmc_read_csr(mmc, MIO_EMM_SWITCH));
-	debug("  mio_emm_mode0: 0x%llx\n", mmc_read_csr(mmc, MIO_EMM_MODEX(0)));
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+	debug("  mio_emm_switch: 0x%llx\n",
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH()));
+	debug("  mio_emm_mode0: 0x%llx\n",
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(0)));
 	udelay(1200);
 	emm_switch.s.bus_id = bus;
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	udelay(1200);
 	debug("  mio_emm_mode%d: 0x%llx\n", bus,
-	      mmc_read_csr(mmc, MIO_EMM_MODEX(bus)));
+	      mmc_read_csr(mmc, CAVM_MIO_EMM_MODEX(bus)));
 
 	mmc_set_watchdog(mmc, 1000000);
 }
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u32 *resp)
 {
 	struct mmc_cmd cmd;
@@ -4061,12 +4038,12 @@ static int sd_change_freq(struct mmc *mmc)
 {
 	int err;
 	struct mmc_cmd cmd;
-	uint32_t scr[2];
-	uint32_t switch_status[16];
+	u32 scr[2];
+	u32 switch_status[16];
 	struct mmc_data data;
 	int timeout;
-	struct cavium_mmc_slot *slot = mmc->priv;
-	uint32_t flags;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	u32 flags;
 #ifdef DEBUG
 	int i;
 #endif
@@ -4271,12 +4248,12 @@ retry_scr:
 }
 #endif
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 static int sd_version_1_x(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
 	int err;
-	uint32_t flags;
+	u32 flags;
 	ulong start;
 
 	debug("%s(%s)\n", __func__, mmc->cfg->name);
@@ -4326,10 +4303,10 @@ static int sd_version_1_x(struct mmc *mmc)
 
 static int mmc_send_if_cond(struct mmc *mmc)
 {
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 	struct mmc_cmd cmd;
 	int err;
-	uint32_t flags;
+	u32 flags;
 
 	debug("%s(%s)\n", __func__, mmc->cfg->name);
 	/* We only need a very short timeout here, 5ms */
@@ -4369,28 +4346,31 @@ static int mmc_send_if_cond(struct mmc *mmc)
 	return 0;
 }
 
+/**
+ * Resets the MMC bus.
+ */
 static void mmc_reset_bus(struct mmc *mmc, int preserve_switch)
 {
-	struct cavium_mmc_slot *slot = (struct cavium_mmc_slot *)mmc->priv;
-	union mio_emm_cfg emm_cfg;
-	union mio_emm_switch emm_switch;
+	struct octeontx_mmc_slot *slot = (struct octeontx_mmc_slot *)mmc->priv;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_switch emm_switch;
 
 	debug("%s(%s, %d)\n", __func__, mmc->cfg->name, preserve_switch);
 	if (preserve_switch) {
-		emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+		emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 		if (emm_switch.s.bus_id != slot->bus_id) {
 			emm_switch.s.bus_id = slot->bus_id;
-			mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+			mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 		}
 	}
 
 	/* Reset the bus */
-	emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+	emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 	emm_cfg.u &= ~(1 << slot->bus_id);
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 	mdelay(20);	/* Wait 20ms */
 	emm_cfg.u |= 1 << slot->bus_id;
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 
 	mdelay(20);
 
@@ -4405,10 +4385,10 @@ static void mmc_reset_bus(struct mmc *mmc, int preserve_switch)
 		debug("%s: clock period: %u\n", __func__, slot->clk_period);
 		emm_switch.s.hs_timing = (mmc->clock > 20000000);
 		emm_switch.s.bus_id = 0;
-		mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 		udelay(100);
 		emm_switch.s.bus_id = slot->bus_id;
-		mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	}
 }
 
@@ -4427,20 +4407,20 @@ static int mmc_set_dsr_cmd(struct mmc *mmc)
 
 int mmc_startup(struct mmc *mmc)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
 	u64 cmult, csize, capacity;
 	int err;
 	uint mult, freq;
-	union mio_emm_switch emm_switch;
-	union mio_emm_cfg emm_cfg;
-	union mio_emm_sts_mask emm_sts_mask;
-	union mio_emm_wdog emm_wdog;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_wdog emm_wdog;
 	int i;
 #ifdef DEBUG
 	int classes;
 #endif
-	uint8_t *ext_csd = slot->ext_csd;
+	u8 *ext_csd = slot->ext_csd;
 	bool has_parts = false;
 	bool part_completed;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
@@ -4454,20 +4434,21 @@ int mmc_startup(struct mmc *mmc)
 	mmc->rca = 0;
 
 	/* Clear interrupt status */
-	mmc_write_csr(mmc, MIO_EMM_INT, mmc_read_csr(mmc, MIO_EMM_INT));
+	mmc_write_csr(mmc, CAVM_MIO_EMM_INT(),
+		      mmc_read_csr(mmc, CAVM_MIO_EMM_INT()));
 
 	/* Enable the bus */
-	emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+	emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 	emm_cfg.u |= (1 << slot->bus_id);
 	debug("%s: writing 0x%llx to mio_emm_cfg\n", __func__, emm_cfg.u);
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 	mdelay(2);
 
 	/* Set clock period */
 	slot->clk_period = (host->sclock + mmc->clock - 1) / mmc->clock;
 
 	/* Default to RCA of 1 */
-	mmc_write_csr(mmc, MIO_EMM_RCA, 1);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_RCA(), 1);
 
 	/* Set the bus speed and width */
 	emm_switch.u = 0;
@@ -4476,10 +4457,10 @@ int mmc_startup(struct mmc *mmc)
 	emm_switch.s.clk_hi = (slot->clk_period + 1) / 2;
 	emm_switch.s.clk_lo = emm_switch.s.clk_hi;
 	debug("%s: clock period: %u\n", __func__, slot->clk_period);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	emm_switch.s.bus_id = slot->bus_id;
 	udelay(1200);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	udelay(1200);
 
 	host->last_slotid = host->cur_slotid;
@@ -4492,17 +4473,17 @@ int mmc_startup(struct mmc *mmc)
 	if (slot->bus_id == 0)
 		emm_wdog.u = 0;
 	else
-		emm_wdog.u = mmc_read_csr(mmc, MIO_EMM_WDOG);
+		emm_wdog.u = mmc_read_csr(mmc, CAVM_MIO_EMM_WDOG());
 	emm_wdog.s.clk_cnt = mmc->clock;
 	debug("Setting command timeout value to %u\n", emm_wdog.s.clk_cnt);
-	mmc_write_csr(mmc, MIO_EMM_WDOG, emm_wdog.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_WDOG(), emm_wdog.u);
 
 	mdelay(10);	/* Wait 10ms */
 
 	/* Set status mask */
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
-	mmc_write_csr(mmc, MIO_EMM_STS_MASK, emm_sts_mask.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
 
 	/* Reset the card */
 	debug("Resetting card\n");
@@ -4523,7 +4504,7 @@ int mmc_startup(struct mmc *mmc)
 		return err;
 	}
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 	/* Note that this doesn't work on the CN61XX pass 1.0.
 	 * The CN61XX pass 1.0 has an errata where only 8-bit wide buses are
 	 * supported due to checksum errors on narrower busses.
@@ -4534,7 +4515,7 @@ int mmc_startup(struct mmc *mmc)
 #endif
 	/* Now try to get the SD card's operating condition */
 	if (!err && IS_SD(mmc)) {
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 		debug("Getting SD card operating condition\n");
 		err = sd_send_op_cond(mmc);
 		if (err == ETIMEDOUT) {
@@ -4557,7 +4538,8 @@ int mmc_startup(struct mmc *mmc)
 	} else {
 		mdelay(100);
 		/* Clear interrupt status */
-		mmc_write_csr(mmc, MIO_EMM_INT, mmc_read_csr(mmc, MIO_EMM_INT));
+		mmc_write_csr(mmc, CAVM_MIO_EMM_INT(),
+			      mmc_read_csr(mmc, CAVM_MIO_EMM_INT()));
 		debug("Resetting card for MMC\n");
 		mmc_pre_idle(mmc);
 		mdelay(2);
@@ -4608,7 +4590,7 @@ int mmc_startup(struct mmc *mmc)
 	 * This also puts the cards into Standby State.
 	 */
 	if (IS_SD(mmc)) {
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 		debug("%s: Getting SD relative address\n", __func__);
 		err = sd_send_relative_addr(mmc);
 		if (err) {
@@ -4633,7 +4615,7 @@ int mmc_startup(struct mmc *mmc)
 	err = mmc_get_csd(mmc);
 	if (err) {
 		printf("%s: Error getting CSD\n", __func__);
-		emm_switch.u = mmc_read_csr(mmc, MIO_EMM_SWITCH);
+		emm_switch.u = mmc_read_csr(mmc, CAVM_MIO_EMM_SWITCH());
 		debug("clk period: %d\n",
 		      emm_switch.s.clk_hi + emm_switch.s.clk_lo);
 		return err;
@@ -4706,10 +4688,10 @@ int mmc_startup(struct mmc *mmc)
 			break;
 		}
 	} else {
-		const uint32_t tran_speed_freq[8] = {
+		const u32 tran_speed_freq[8] = {
 			10000, 100000, 1000000, 10000000, 0, 0, 0, 0
 		};
-		const uint32_t tran_mult[16] = {
+		const u32 tran_mult[16] = {
 			 0, 10, 12, 13, 15, 20, 26, 30,
 			35, 40, 45, 52, 55, 60, 70, 80
 		};
@@ -5006,7 +4988,7 @@ int mmc_startup(struct mmc *mmc)
 	}
 
 	debug("%s: Changing frequency\n", __func__);
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 	if (IS_SD(mmc))
 		err = sd_change_freq(mmc);
 #endif
@@ -5026,7 +5008,7 @@ int mmc_startup(struct mmc *mmc)
 
 
 	if (IS_SD(mmc)) {
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 		err = sd_set_bus_width_speed(mmc);
 		if (err) {
 			printf("%s: Error setting SD bus width and/or speed\n",
@@ -5107,14 +5089,14 @@ int mmc_startup(struct mmc *mmc)
  * This is the external mmc_send_cmd function.  It was required that
  * the internal version support flags so this version is required.
  */
-static int cavium_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
-			       struct mmc_data *data)
+static int octeontx_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
+				 struct mmc_data *data)
 {
-	uint32_t flags = 0;
+	u32 flags = 0;
 	int ret;
 	static bool acmd;
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 
 	/* Some SD commands require some flags to be changed */
@@ -5163,10 +5145,10 @@ static int cavium_mmc_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
 	return ret;
 }
 
-int __cavium_mmc_getwp(struct udevice *dev)
+int __octeontx_mmc_getwp(struct udevice *dev)
 {
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	int val = 0;
 	debug("%s: card \n", __func__);
@@ -5184,10 +5166,10 @@ int __cavium_mmc_getwp(struct udevice *dev)
 	return val;
 }
 
-int __cavium_mmc_getcd(struct udevice *dev)
+int __octeontx_mmc_getcd(struct udevice *dev)
 {
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot = &host->slots[host->cur_slotid];
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot = &host->slots[host->cur_slotid];
 	struct mmc *mmc = slot->mmc;
 	int bus = slot->bus_id;
 	int val = 1;
@@ -5215,7 +5197,7 @@ int __cavium_mmc_getcd(struct udevice *dev)
  */
 void __mmc_set_power(struct mmc *mmc, int on)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_slot *slot = mmc->priv;
 	int bus = slot->bus_id;
 	int val;
 
@@ -5312,11 +5294,11 @@ int mmc_initialize(bd_t *bis)
  *
  * TODO: Modify this to support multiple nodes
  */
-int cavium_mmc_initialize(struct udevice *dev)
+int octeontx_mmc_initialize(struct udevice *dev)
 {
 	static bool not_first;
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot = NULL;
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot = NULL;
 	struct mmc *mmc = NULL;
 	int bus_id = 0;
 	int rc = -1;
@@ -5335,7 +5317,7 @@ int cavium_mmc_initialize(struct udevice *dev)
 	}
 
 	debug("%s ENTER host %p\n", __func__,host);
-	for (slot_index = 0; slot_index < CAVIUM_MAX_MMC_SLOT;
+	for (slot_index = 0; slot_index < OCTEONTX_MAX_MMC_SLOT;
 	     slot_index++) {
 		slot = &host->slots[slot_index];
 	debug("%s ENTER host %p\n", __func__,host);
@@ -5351,14 +5333,14 @@ int cavium_mmc_initialize(struct udevice *dev)
 	}
 
 	debug("%s ENTER\n", __func__);
-	rc = cavium_mmc_get_config(dev);
+	rc = octeontx_mmc_get_config(dev);
 	if (rc) {
 		debug("%s: Error getting configuration for host \n",
 		      __func__);
 		return -1;
 	}
 
-	for (slot_index = 0; slot_index < CAVIUM_MAX_MMC_SLOT;
+	for (slot_index = 0; slot_index < OCTEONTX_MAX_MMC_SLOT;
 	     slot_index++) {
 		slot = &host->slots[slot_index];
 		mmc = slot->mmc;
@@ -5366,7 +5348,7 @@ int cavium_mmc_initialize(struct udevice *dev)
 			continue;
 		/* Disable all MMC slots and power them down */
 		debug("%s: Disabling MMC slot %s\n", __func__, mmc->cfg->name);
-		mmc_write_csr(mmc, MIO_EMM_CFG, 0);
+		mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), 0);
 		mmc_set_power(mmc, 0);
 	}
 
@@ -5374,7 +5356,7 @@ int cavium_mmc_initialize(struct udevice *dev)
 
 	/* Power them all up */
 	debug("Powering up all devices\n");
-	for (slot_index = 0; slot_index < CAVIUM_MAX_MMC_SLOT;
+	for (slot_index = 0; slot_index < OCTEONTX_MAX_MMC_SLOT;
 	     slot_index++) {
 		slot = &host->slots[slot_index];
 		mmc = slot->mmc;
@@ -5385,7 +5367,7 @@ int cavium_mmc_initialize(struct udevice *dev)
 	}
 	found = false;
 
-	for (slot_index = 0; slot_index < CAVIUM_MAX_MMC_SLOT;
+	for (slot_index = 0; slot_index < OCTEONTX_MAX_MMC_SLOT;
 	     slot_index++) {
 		slot = &host->slots[slot_index];
 		bus_id = slot->bus_id;
@@ -5456,30 +5438,31 @@ int cavium_mmc_initialize(struct udevice *dev)
 	return found ? 0 : rc;
 }
 
-int __cavium_mmc_init(struct mmc *mmc)
+int __octeontx_mmc_init(struct mmc *mmc)
 {
-	struct cavium_mmc_slot *slot = mmc->priv;
-	struct cavium_mmc_host *host = slot->host;
-	union mio_emm_switch emm_switch;
-	union mio_emm_cfg emm_cfg;
-	union mio_emm_sts_mask emm_sts_mask;
-	union mio_emm_wdog emm_wdog;
+	struct octeontx_mmc_slot *slot = mmc->priv;
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_wdog emm_wdog;
 
 	/* Clear interrupt status */
-	mmc_write_csr(mmc, MIO_EMM_INT, mmc_read_csr(mmc, MIO_EMM_INT));
+	mmc_write_csr(mmc, CAVM_MIO_EMM_INT(),
+		      mmc_read_csr(mmc, CAVM_MIO_EMM_INT()));
 
 	/* Enable the bus */
-	emm_cfg.u = mmc_read_csr(mmc, MIO_EMM_CFG);
+	emm_cfg.u = mmc_read_csr(mmc, CAVM_MIO_EMM_CFG());
 	emm_cfg.u |= (1 << slot->bus_id);
 	debug("%s: writing 0x%llx to mio_emm_cfg\n", __func__, emm_cfg.u);
-	mmc_write_csr(mmc, MIO_EMM_CFG, emm_cfg.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
 	mdelay(2);
 
 	/* Set clock period */
 	slot->clk_period = (host->sclock + mmc->clock - 1) / mmc->clock;
 
 	/* Default to RCA of 1 */
-	mmc_write_csr(mmc, MIO_EMM_RCA, 1);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_RCA(), 1);
 
 
 	/* Set the bus speed and width */
@@ -5489,10 +5472,10 @@ int __cavium_mmc_init(struct mmc *mmc)
 	emm_switch.s.clk_hi = (slot->clk_period + 1) / 2;
 	emm_switch.s.clk_lo = emm_switch.s.clk_hi;
 	debug("%s: clock period: %u\n", __func__, slot->clk_period);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	emm_switch.s.bus_id = slot->bus_id;
 	udelay(1200);
-	mmc_write_csr(mmc, MIO_EMM_SWITCH, emm_switch.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
 	udelay(1200);
 
 	host->last_slotid = host->cur_slotid;
@@ -5504,17 +5487,17 @@ int __cavium_mmc_init(struct mmc *mmc)
 	if (slot->bus_id == 0)
 		emm_wdog.u = 0;
 	else
-		emm_wdog.u = mmc_read_csr(mmc, MIO_EMM_WDOG);
+		emm_wdog.u = mmc_read_csr(mmc, CAVM_MIO_EMM_WDOG());
 	emm_wdog.s.clk_cnt = mmc->clock;
 	debug("Setting command timeout value to %u\n", emm_wdog.s.clk_cnt);
-	mmc_write_csr(mmc, MIO_EMM_WDOG, emm_wdog.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_WDOG(), emm_wdog.u);
 
 	mdelay(10);	/* Wait 10ms */
 
 	/* Set status mask */
 	emm_sts_mask.u = 0;
 	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
-	mmc_write_csr(mmc, MIO_EMM_STS_MASK, emm_sts_mask.u);
+	mmc_write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
 
 	mmc_set_power(mmc, 1);
 
@@ -5526,7 +5509,7 @@ int __cavium_mmc_init(struct mmc *mmc)
 int mmc_start_init(struct mmc *mmc)
 {
 	int err;
-	const struct cavium_mmc_slot *slot = mmc->priv;
+	const struct octeontx_mmc_slot *slot = mmc->priv;
 	struct blk_desc *bdesc = mmc_get_blk_desc(mmc, slot->bus_id);
 
 	debug("%s(%s): Entry\n", __func__, mmc->cfg->name);
@@ -5542,12 +5525,12 @@ int mmc_start_init(struct mmc *mmc)
 	}
 
 	mmc_set_power(mmc, 1);
-        err = cavium_mmc_init(mmc);
-        if (err) {
-                printf("%s(%s): init returned %d\n", __func__,
-                       mmc->cfg->name, err);
-                return err;
-        }
+	err = octeontx_mmc_init(mmc);
+	if (err) {
+		printf("%s(%s): init returned %d\n", __func__,
+		       mmc->cfg->name, err);
+		return err;
+	}
 
 	mmc->ddr_mode = 0;
 	mmc_set_bus_width(mmc, 1);
@@ -5561,7 +5544,7 @@ int mmc_start_init(struct mmc *mmc)
 
 	bdesc->hwpart = 0;
 
-#ifdef CONFIG_CAVIUM_MMC_SD
+#ifdef CONFIG_OCTEONTX_MMC_SD
 	/* Test for SD version 2 */
 	err = mmc_send_if_cond(mmc);
 
@@ -5643,7 +5626,7 @@ struct mmc *mmc_create(const struct mmc_config *cfg, void *priv)
 {
 	struct mmc *mmc;
 	struct blk_desc *bdesc;
-	struct cavium_mmc_slot *slot = priv;
+	struct octeontx_mmc_slot *slot = priv;
 	struct udevice *dev = slot->host->dev;
 	struct udevice *bdev;
 	int ret = -1;
@@ -5709,9 +5692,9 @@ void mmc_destroy(struct mmc *mmc)
  *
  * @return	MMC register value for voltage
  */
-static uint32_t xlate_voltage(uint32_t voltage)
+static u32 xlate_voltage(u32 voltage)
 {
-	uint32_t volt = 0;
+	u32 volt = 0;
 
 	/* Convert to millivolts */
 	voltage /= 1000;
@@ -5764,14 +5747,14 @@ static uint32_t xlate_voltage(uint32_t voltage)
  * @return	0 for success, -1 on error or if invalid
  */
 static int get_mmc_regulator(const void *blob, int of_offset,
-			     struct cavium_mmc_host *host,
-			     struct cavium_mmc_slot *slot)
+			     struct octeontx_mmc_host *host,
+			     struct octeontx_mmc_slot *slot)
 {
-	uint32_t min_microvolt;
-	uint32_t max_microvolt;
-	uint32_t power_delay;
-	uint32_t voltages;
-	uint32_t low, high;
+	u32 min_microvolt;
+	u32 max_microvolt;
+	u32 power_delay;
+	u32 voltages;
+	u32 low, high;
 	int ret;
 	bool active_high;
 
@@ -5802,9 +5785,11 @@ static int get_mmc_regulator(const void *blob, int of_offset,
 	 * we just duplicate the GPIO descriptor.
 	 */
 	if (ret == -EBUSY) {
-		struct cavium_mmc_slot *sslot;
-		for(int slot_index = 0; slot_index < CAVIUM_MAX_MMC_SLOT;
-			slot_index++) {
+		struct octeontx_mmc_slot *sslot;
+		int slot_index;
+
+		for (slot_index = 0; slot_index < OCTEONTX_MAX_MMC_SLOT;
+		     slot_index++) {
 			sslot = &host->slots[slot_index];
 			assert(sslot);
 			if (sslot->power_gpio_of_offset == of_offset) {
@@ -5853,10 +5838,10 @@ static int get_mmc_regulator(const void *blob, int of_offset,
  *
  * @return	0 for success, -1 on error.
  */
-static int cavium_mmc_get_config(struct udevice *dev)
+static int octeontx_mmc_get_config(struct udevice *dev)
 {
-	struct cavium_mmc_host *host = dev_get_priv(dev);
-	struct cavium_mmc_slot *slot;
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_slot *slot;
 	const void *blob = gd->fdt_blob;
 	int slot_node;
 	int regulator_node;
@@ -5878,7 +5863,7 @@ static int cavium_mmc_get_config(struct udevice *dev)
 			printf("Missing reg field for mmc slot in device tree\n");
 			return -1;
 		}
-		if (reg >= CAVIUM_MAX_MMC_SLOT) {
+		if (reg >= OCTEONTX_MAX_MMC_SLOT) {
 			printf("MMC slot %d is out of range\n", reg);
 			return -1;
 		}
@@ -5982,7 +5967,7 @@ static int cavium_mmc_get_config(struct udevice *dev)
 
 		slot->mmc->version = MMC_VERSION_UNKNOWN;
 		slot->mmc->rca = reg + 0x10;
-		slot->mmc->clock = CONFIG_CAVIUM_MMC_MIN_BUS_SPEED_HZ;
+		slot->mmc->clock = CONFIG_OCTEONTX_MMC_MIN_BUS_SPEED_HZ;
 		slot->bus_width = EXT_CSD_BUS_WIDTH_1;
 		slot->mmc->bus_width = fdtdec_get_int(blob, slot_node,
 						      "bus-width", 8);
@@ -5991,7 +5976,7 @@ static int cavium_mmc_get_config(struct udevice *dev)
 		if (slot->mmc->bus_width == 8)
 			slot->cfg.host_caps |= MMC_MODE_8BIT;
 
-		snprintf(slot->name, CAVIUM_MMC_NAME_LEN, "cavium_mmc%d",
+		snprintf(slot->name, OCTEONTX_MMC_NAME_LEN, "octeontx_mmc%d",
 			 slot->bus_id);
 		slot->cfg.name = slot->name;
 	}
@@ -6032,12 +6017,12 @@ int mmc_set_bkops_enable(struct mmc *mmc)
 }
 #endif
 
-static int cavium_pci_mmc_probe(struct udevice *dev)
+static int octeontx_pci_mmc_probe(struct udevice *dev)
 {
 	int rc = -1;
 	size_t size;
 	pci_dev_t bdf = dm_pci_get_bdf(dev);
-	struct cavium_mmc_host *host = dev_get_priv(dev);
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
 
 	debug("%s: Entry\n", __func__);
 	memset(host, 0, sizeof(*host));
@@ -6069,12 +6054,12 @@ static int cavium_pci_mmc_probe(struct udevice *dev)
 	      dev->node.of_offset, dev->parent, dev->priv,
 	      dev->uclass, dev->req_seq, dev->seq);
 
-	rc = cavium_mmc_initialize(dev);
+	rc = octeontx_mmc_initialize(dev);
 
 	return rc;
 }
 
-static int cavium_mmc_ofdata_to_platdata(struct udevice *dev)
+static int octeontx_mmc_ofdata_to_platdata(struct udevice *dev)
 {
 	return 0;
 }
@@ -6090,13 +6075,13 @@ int do_oct_mmc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 U_BOOT_CMD(octmmc, 2, 1, do_oct_mmc, "Octeon MMC initialization", NULL);
 #endif
 
-U_BOOT_DRIVER(cavium_pci_mmc) = {
-	.name	= CAVIUM_MMC_DRIVER_NAME,
+U_BOOT_DRIVER(octeontx_pci_mmc) = {
+	.name	= OCTEONTX_MMC_DRIVER_NAME,
 	.id	= UCLASS_MMC,
-	.of_match = of_match_ptr(cavium_mmc_ids),
-	.ofdata_to_platdata = cavium_mmc_ofdata_to_platdata,
-	.probe	= cavium_pci_mmc_probe,
-	.priv_auto_alloc_size = sizeof(struct cavium_mmc_host),
-	.ops = &cavium_mmc_ops,
+	.of_match = of_match_ptr(octeontx_mmc_ids),
+	.ofdata_to_platdata = octeontx_mmc_ofdata_to_platdata,
+	.probe	= octeontx_pci_mmc_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_mmc_host),
+	.ops = &octeontx_mmc_ops,
 };
 
-- 
2.29.0

