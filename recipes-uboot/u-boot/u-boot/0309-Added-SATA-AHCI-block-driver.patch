From 63121cf731cc052fbe133d7917ebeba709da274b Mon Sep 17 00:00:00 2001
From: Sergey Temerkhanov <sergey.temerkhanov@auriga.com>
Date: Thu, 12 Mar 2015 16:23:04 +0300
Subject: [PATCH 0309/1239] Added SATA AHCI block driver

---
 drivers/block/Makefile    |    1 +
 drivers/block/sata_ahci.c | 1035 +++++++++++++++++++++++++++++++++++++
 drivers/block/sata_ahci.h |  500 ++++++++++++++++++
 3 files changed, 1536 insertions(+)
 create mode 100644 drivers/block/sata_ahci.c
 create mode 100644 drivers/block/sata_ahci.h

diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 3feb0aa997..faacdf7072 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_IDE) += ide.o
 endif
 obj-$(CONFIG_SANDBOX) += sandbox.o
 obj-$(CONFIG_$(SPL_TPL_)BLOCK_CACHE) += blkcache.o
+obj-$(CONFIG_SATA_AHCI) += sata_ahci.o
diff --git a/drivers/block/sata_ahci.c b/drivers/block/sata_ahci.c
new file mode 100644
index 0000000000..1ea4f80e91
--- /dev/null
+++ b/drivers/block/sata_ahci.c
@@ -0,0 +1,1035 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define DEBUG
+#include <libata.h>
+#include <fis.h>
+#include <sata.h>
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+/* #include <asm/arch/clock.h> */
+#include "sata_ahci.h"
+
+struct sata_port_regs {
+	u32 clb;	/* Command List Base Address */
+	u32 clbu;	/* Command List Base Address Upper 32-bits */
+	u32 fb;		/* FIS Base Address */
+	u32 fbu;	/* FIS Base Address Upper 32-bits */
+	u32 is;		/* Interrupt Status */
+	u32 ie;		/* Interrupt Enable */
+	u32 cmd;	/* Command and Status */
+	u32 res1[1];
+	u32 tfd;	/* Task File Data */
+	u32 sig;	/* Signature */
+	u32 ssts;	/* Serial ATA Status */
+	u32 sctl;	/* Serial ATA Control */
+	u32 serr;	/* Serial ATA Error */
+	u32 sact;	/* offset=0x134 Serial ATA Active */
+	u32 ci;		/* Command Issue */
+	u32 sntf;	/* Serial ATA Notification */
+	u32 fbs;	/* FIS-based Switching Control */
+        u32 res3[11];   /* offset 0x144 - 0x16c */
+	u32 dmacr;	/* offset = 0x170 */
+	u32 res4[1];
+	u32 phycr;
+	u32 physr;
+};
+
+struct sata_host_regs {
+	u32 cap;
+	u32 ghc;
+	u32 is;
+	u32 pi;
+	u32 vs;
+	u32 ccc_ctl;
+	u32 ccc_ports;
+	u32 res1[2];
+	u32 cap2;
+	u32 res2[30];
+	u32 bistafr;
+	u32 bistcr;
+	u32 bistfctr;
+	u32 bistsr;
+	u32 bistdecr;
+	u32 res3[2];
+	u32 oobr;
+	u32 res4[8];
+	u32 timer1ms;
+	u32 res5[1];
+	u32 gparam1r;
+	u32 gparam2r;
+	u32 pparamr;
+	u32 testr;
+	u32 versionr;
+	u32 idr;
+};
+
+#define MAX_DATA_BYTES_PER_SG  (4 * 1024 * 1024)
+#define MAX_BYTES_PER_TRANS (AHCI_MAX_SG * MAX_DATA_BYTES_PER_SG)
+
+void print_h2d(struct sata_fis_h2d *cfis)
+{
+	printf("print sata_fis_h2d:\n");
+	printf("fis_type = 0x%x\n", cfis->fis_type);
+	printf("pm_port_c = 0x%x\n", cfis->pm_port_c);
+}
+
+
+static inline void ahci_writel(u32 value, volatile const void *addr)
+{
+	writel(value, addr);
+	debug("W %p <= 0x%x\n", addr, value);
+}
+
+static inline u32 ahci_readl(volatile const void *addr)
+{
+	uint32_t val = readl(addr);
+	debug("R %p => 0x%x\n", addr, val);
+	return val;
+}
+#define ahci_writel_with_flush(a,b)     do { ahci_writel(a,b); ahci_readl(b); } while (0)
+
+static int is_ready;
+
+static inline u64 ahci_port_base(u64 base, u32 port)
+{
+	return base + 0x100 + (u64)(port * 0x80);
+}
+
+static int waiting_for_cmd_completed(u8 *addr,
+					int timeout_msec,
+					u32 sign)
+{
+	int i;
+	u32 status;
+
+	for (i = 0;
+		((status = readl(addr)) & sign) && i < timeout_msec;
+		++i)
+		mdelay(1);
+
+	return (i < timeout_msec) ? 0 : -1;
+}
+
+static int ahci_setup_oobr(struct ahci_probe_ent *probe_ent,
+						int clk)
+{
+#if 0
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+
+
+	/* If needed, then write a value to this register */
+	writel(0x070E182B, &(host_mmio->oobr)); /* Default value*/
+#endif
+
+	return 0;
+}
+
+static int ahci_host_init(struct ahci_probe_ent *probe_ent)
+{
+	u32 tmp, cap_save, num_ports;
+	int i, j, timeout = 1000;
+	struct sata_port_regs *port_mmio = NULL;
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+/* 	int clk = mxc_get_clock(MXC_SATA_CLK); */
+	int clk = 100000000; /* arbitrary for now */
+
+	cap_save = ahci_readl(&(host_mmio->cap));
+	cap_save |= SATA_HOST_CAP_SSS;
+
+	/* global controller reset, self-clear */
+	tmp = ahci_readl(&(host_mmio->ghc));
+	if ((tmp & SATA_HOST_GHC_HR) == 0)
+		ahci_writel_with_flush(tmp | SATA_HOST_GHC_HR, &(host_mmio->ghc));
+
+	while ((readl(&(host_mmio->ghc)) & SATA_HOST_GHC_HR)
+		&& --timeout)
+		;
+
+	if (timeout <= 0) {
+		debug("controller reset failed (0x%x)\n", tmp);
+		return -1;
+	}
+
+	/* Set timer 1ms */
+	ahci_writel(clk / 1000, &(host_mmio->timer1ms));
+	ahci_setup_oobr(probe_ent, 0);
+
+	ahci_writel_with_flush(SATA_HOST_GHC_AE, &(host_mmio->ghc));
+	ahci_writel(cap_save, &(host_mmio->cap));
+	num_ports = (cap_save & SATA_HOST_CAP_NP_MASK) + 1;
+	ahci_writel_with_flush((1 << num_ports) - 1,
+				&(host_mmio->pi));
+
+	/*
+	 * Determine which Ports are implemented by the AHCI,
+	 * by reading the PI register. This bit map value aids the
+	 * software to determine how many Ports are available and
+	 * which Port registers need to be initialized.
+	 */
+	probe_ent->cap = ahci_readl(&(host_mmio->cap));
+	probe_ent->port_map = ahci_readl(&(host_mmio->pi));
+
+	/* Determine how many command slots the HBA supports */
+	probe_ent->n_ports =
+		(probe_ent->cap & SATA_HOST_CAP_NP_MASK) + 1;
+
+	debug("cap 0x%x  port_map 0x%x  n_ports %d\n",
+		probe_ent->cap, probe_ent->port_map, probe_ent->n_ports);
+
+	for (i = 0; i < probe_ent->n_ports; i++) {
+		probe_ent->port[i].port_mmio =
+			ahci_port_base((u64)host_mmio, i);
+		port_mmio =
+			(struct sata_port_regs *)probe_ent->port[i].port_mmio;
+
+		/* Ensure that the AHCI is in idle state */
+		tmp = ahci_readl(&(port_mmio->cmd));
+
+		/*
+		 * When P#CMD.ST, P#CMD.CR, P#CMD.FRE and P#CMD.FR
+		 * are all cleared, the Port is in an idle state.
+		 */
+		if (tmp & (SATA_PORT_CMD_CR | SATA_PORT_CMD_FR |
+			SATA_PORT_CMD_FRE | SATA_PORT_CMD_ST)) {
+
+			/*
+			 * System software places a Port into the idle state by
+			 * clearing P#CMD.ST and waiting for P#CMD.CR to return
+			 * 0 when read.
+			 */
+			tmp &= ~SATA_PORT_CMD_ST;
+			ahci_writel_with_flush(tmp, &(port_mmio->cmd));
+
+			/*
+			 * spec says 500 msecs for each bit, so
+			 * this is slightly incorrect.
+			 */
+			mdelay(500);
+
+			timeout = 1000;
+			while ((readl(&(port_mmio->cmd)) & SATA_PORT_CMD_CR)
+				&& --timeout)
+				;
+
+			if (timeout <= 0) {
+				debug("port reset failed (0x%x)\n", tmp);
+				return -1;
+			}
+		}
+
+		tmp = ahci_readl(&(port_mmio->cmd));
+		ahci_writel((tmp | SATA_PORT_CMD_SUD), &(port_mmio->cmd));
+
+		/* Wait for spin-up to finish */
+		timeout = 1000;
+		while (!(readl(&(port_mmio->cmd)) | SATA_PORT_CMD_SUD)
+			&& --timeout)
+			;
+		if (timeout <= 0) {
+			debug("Spin-Up can't finish!\n");
+			return -1;
+		}
+
+		/* Wait for Phy to be detected */
+		for (j = 0; j < 100; ++j) {
+			mdelay(10);
+			tmp = ahci_readl(&(port_mmio->ssts));
+			if (((tmp & SATA_PORT_SSTS_DET_MASK) == 0x3) ||
+				((tmp & SATA_PORT_SSTS_DET_MASK) == 0x1))
+				break;
+		}
+
+		/* Wait for COMINIT bit 26 (DIAG_X) in SERR */
+		timeout = 1000;
+		while (!(readl(&(port_mmio->serr)) | SATA_PORT_SERR_DIAG_X)
+			&& --timeout)
+			;
+		if (timeout <= 0) {
+			debug("Can't find DIAG_X set!\n");
+			return -1;
+		}
+
+		/*
+		 * For each implemented Port, clear the P#SERR
+		 * register, by writing ones to each implemented\
+		 * bit location. RWC
+		 */
+		tmp = ahci_readl(&(port_mmio->serr));
+		debug("P#SERR 0x%x\n",
+				tmp);
+		ahci_writel(tmp, &(port_mmio->serr));
+
+		/* Ack any pending irq events for this port */
+		tmp = ahci_readl(&(host_mmio->is));
+		debug("IS 0x%x\n", tmp);
+		if (tmp)
+			ahci_writel(tmp, &(host_mmio->is));
+
+		ahci_writel(1 << i, &(host_mmio->is));
+
+		/* set irq mask (enables interrupts) */
+		ahci_writel(DEF_PORT_IRQ, &(port_mmio->ie));
+
+		/* register linkup ports */
+		tmp = ahci_readl(&(port_mmio->ssts));
+		debug("Port %d status: 0x%x\n", i, tmp);
+		if ((tmp & SATA_PORT_SSTS_DET_MASK) == 0x03)
+			probe_ent->link_port_map |= (0x01 << i);
+	}
+
+	tmp = ahci_readl(&(host_mmio->ghc));
+	debug("GHC 0x%x\n", tmp);
+	ahci_writel(tmp | SATA_HOST_GHC_IE, &(host_mmio->ghc));
+	tmp = ahci_readl(&(host_mmio->ghc));
+	debug("GHC 0x%x\n", tmp);
+	return 0;
+}
+
+int reset_sata(int dev)
+{
+	struct ahci_probe_ent *probe_ent =
+			(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_host_regs *host_mmio =
+			(struct sata_host_regs *)probe_ent->mmio_base;
+
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
+		printf("The sata index %d is out of ranges\n\r", dev);
+		return -1;
+	}
+
+	setbits_le32(&host_mmio->ghc, SATA_HOST_GHC_HR);
+	while (readl(&host_mmio->ghc) & SATA_HOST_GHC_HR)
+		udelay(100);
+
+	return 0;
+}
+
+static void ahci_print_info(struct ahci_probe_ent *probe_ent)
+{
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+	u32 vers, cap, impl, speed;
+	const char *speed_s;
+	const char *scc_s;
+
+	vers = ahci_readl(&(host_mmio->vs));
+	cap = probe_ent->cap;
+	impl = probe_ent->port_map;
+
+	speed = (cap & SATA_HOST_CAP_ISS_MASK)
+		>> SATA_HOST_CAP_ISS_OFFSET;
+	if (speed == 1)
+		speed_s = "1.5";
+	else if (speed == 2)
+		speed_s = "3";
+	else
+		speed_s = "?";
+
+	scc_s = "SATA";
+
+	printf("AHCI %02x%02x.%02x%02x "
+		"%u slots %u ports %s Gbps 0x%x impl %s mode\n",
+		(vers >> 24) & 0xff,
+		(vers >> 16) & 0xff,
+		(vers >> 8) & 0xff,
+		vers & 0xff,
+		((cap >> 8) & 0x1f) + 1,
+		(cap & 0x1f) + 1,
+		speed_s,
+		impl,
+		scc_s);
+
+	printf("flags: "
+		"%s%s%s%s%s%s"
+		"%s%s%s%s%s%s%s\n",
+		cap & (1 << 31) ? "64bit " : "",
+		cap & (1 << 30) ? "ncq " : "",
+		cap & (1 << 28) ? "ilck " : "",
+		cap & (1 << 27) ? "stag " : "",
+		cap & (1 << 26) ? "pm " : "",
+		cap & (1 << 25) ? "led " : "",
+		cap & (1 << 24) ? "clo " : "",
+		cap & (1 << 19) ? "nz " : "",
+		cap & (1 << 18) ? "only " : "",
+		cap & (1 << 17) ? "pmp " : "",
+		cap & (1 << 15) ? "pio " : "",
+		cap & (1 << 14) ? "slum " : "",
+		cap & (1 << 13) ? "part " : "");
+}
+
+extern uintptr_t sata_baseaddress(int dev);
+
+static int ahci_init_one(int dev)
+{
+	int rc;
+	struct ahci_probe_ent *probe_ent = NULL;
+	probe_ent = malloc(sizeof(struct ahci_probe_ent));
+	memset(probe_ent, 0, sizeof(struct ahci_probe_ent));
+	probe_ent->dev = dev;
+
+	probe_ent->host_flags = ATA_FLAG_SATA
+				| ATA_FLAG_NO_LEGACY
+				| ATA_FLAG_MMIO
+				| ATA_FLAG_PIO_DMA
+				| ATA_FLAG_NO_ATAPI;
+
+	probe_ent->mmio_base = sata_baseaddress(dev);
+	debug("Base address for ahci%d is: 0x%llx\n", dev, probe_ent->mmio_base);
+
+	if (!probe_ent->mmio_base) {
+		rc = -1;
+		goto err_out;
+	}
+
+	/* initialize adapter */
+	rc = ahci_host_init(probe_ent);
+	if (rc)
+		goto err_out;
+
+	ahci_print_info(probe_ent);
+
+	/* Save the private struct to block device struct */
+	sata_dev_desc[dev].priv = (void *)probe_ent;
+
+	return 0;
+
+err_out:
+	free(probe_ent);
+	return rc;
+}
+
+static int ahci_fill_sg(struct ahci_probe_ent *probe_ent,
+			u8 port, unsigned char *buf, int buf_len)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+	struct ahci_sg *ahci_sg = pp->cmd_tbl_sg;
+	u32 sg_count, max_bytes;
+	int i;
+
+	max_bytes = MAX_DATA_BYTES_PER_SG;
+	sg_count = ((buf_len - 1) / max_bytes) + 1;
+	if (sg_count > AHCI_MAX_SG) {
+		printf("Error:Too much sg!\n");
+		return -1;
+	}
+
+	for (i = 0; i < sg_count; i++) {
+		ahci_sg->addr =
+			(u32) cpu_to_le32(LOWER32(buf + (i * max_bytes)));
+		ahci_sg->addr_hi = 
+			(u32) cpu_to_le32(UPPER32(buf + (i * max_bytes)));
+		ahci_sg->flags_size = (u32) cpu_to_le32(0x3fffff &
+					(buf_len < max_bytes
+					? (buf_len - 1)
+					: (max_bytes - 1)));
+		ahci_sg++;
+		buf_len -= max_bytes;
+	}
+
+	return sg_count;
+}
+
+static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 cmd_slot, u32 opts)
+{
+	struct ahci_cmd_hdr *cmd_hdr = (struct ahci_cmd_hdr *)(pp->cmd_slot +
+					AHCI_CMD_SLOT_SZ * cmd_slot);
+
+	memset(cmd_hdr, 0, AHCI_CMD_SLOT_SZ);
+	cmd_hdr->opts = (u32) cpu_to_le32(opts);
+	cmd_hdr->status = 0;
+	cmd_hdr->tbl_addr = (u32) cpu_to_le32(pp->cmd_tbl & 0xffffffff);
+	cmd_hdr->tbl_addr_hi = (u32) cpu_to_le32(UPPER32(pp->cmd_tbl));
+}
+
+#define AHCI_GET_CMD_SLOT(c) ((c) ? ffs(c) : 0)
+
+static int ahci_exec_ata_cmd(struct ahci_probe_ent *probe_ent,
+		u8 port, struct sata_fis_h2d *cfis,
+		u8 *buf, u32 buf_len, s32 is_write)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+	struct sata_port_regs *port_mmio =
+			(struct sata_port_regs *)pp->port_mmio;
+	u32 opts;
+	int sg_count = 0, cmd_slot = 0;
+
+	cmd_slot = AHCI_GET_CMD_SLOT(ahci_readl(&(port_mmio->ci)));
+	if (32 == cmd_slot) {
+		printf("Can't find empty command slot!\n");
+		return 0;
+	}
+
+	/* Check xfer length */
+	if (buf_len > MAX_BYTES_PER_TRANS) {
+		printf("Max transfer length is %dB\n\r",
+			MAX_BYTES_PER_TRANS);
+		return 0;
+	}
+
+	memcpy((u8 *)(pp->cmd_tbl), cfis, sizeof(struct sata_fis_h2d));
+
+	flush_cache((pp->cmd_tbl), sizeof(struct sata_fis_h2d));
+
+	if (buf && buf_len)
+		sg_count = ahci_fill_sg(probe_ent, port, buf, buf_len);
+
+	opts = (sizeof(struct sata_fis_h2d) >> 2) | (sg_count << 16);
+	if (is_write) {
+		opts |= 0x40;    /* device write */
+		flush_cache((ulong)buf, buf_len);
+	}
+
+	debug("opts = 0x%x\n", opts);
+	ahci_fill_cmd_slot(pp, cmd_slot, opts);
+	sync();
+
+	flush_cache((s64)(pp->cmd_slot), AHCI_PORT_PRIV_DMA_SZ);
+	ahci_writel_with_flush(1 << cmd_slot, &(port_mmio->ci));
+
+	if (waiting_for_cmd_completed((u8 *)&(port_mmio->ci),
+				10000, 0x1 << cmd_slot)) {
+		printf("timeout exit!\n");
+		return -1;
+	}
+	invalidate_dcache_range((s64)(pp->cmd_slot),
+				(s64)(pp->cmd_slot)+AHCI_PORT_PRIV_DMA_SZ);
+	debug("ahci_exec_ata_cmd: %d byte transferred.\n",
+			pp->cmd_slot->status);
+	if (!is_write)
+		invalidate_dcache_range((ulong)buf, (ulong)buf+buf_len);
+
+	return buf_len;
+}
+
+static void ahci_set_feature(u8 dev, u8 port)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 1 << 7;
+	cfis->command = ATA_CMD_SET_FEATURES;
+	cfis->features = SETFEATURES_XFER;
+	cfis->sector_count = ffs(probe_ent->udma_mask + 1) + 0x3e;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, READ_CMD);
+}
+
+static int ahci_port_start(struct ahci_probe_ent *probe_ent,
+					u8 port)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+	struct sata_port_regs *port_mmio =
+		(struct sata_port_regs *)pp->port_mmio;
+	u32 port_status;
+	u64 mem;
+	int timeout = 10000000;
+
+	debug("Enter start port: %d\n", port);
+	port_status = ahci_readl(&(port_mmio->ssts));
+	debug("Port %d status: %x\n", port, port_status);
+	if ((port_status & 0xf) != 0x03) {
+		printf("No Link on this port!\n");
+		return -1;
+	}
+
+	mem = (u64)malloc(AHCI_PORT_PRIV_DMA_SZ + 1024);
+	if (!mem) {
+		free(pp);
+		printf("No mem for table!\n");
+		return -ENOMEM;
+	}
+
+	mem = (mem + 0x400) & (~0x3ff);	/* Aligned to 1024-bytes */
+	memset((u8 *)mem, 0, AHCI_PORT_PRIV_DMA_SZ);
+
+	/*
+	 * First item in chunk of DMA memory: 32-slot command table,
+	 * 32 bytes each in size
+	 */
+	pp->cmd_slot = (struct ahci_cmd_hdr *)mem;
+	debug("cmd_slot address = 0x%llx\n", (long long unsigned int)pp->cmd_slot);
+	mem += (AHCI_CMD_SLOT_SZ * AHCI_MAX_CMD_SLOTS);
+
+	/*
+	 * Second item: Received-FIS area, 256-Byte aligned
+	 */
+	pp->rx_fis = mem;
+	mem += AHCI_RX_FIS_SZ;
+
+	/*
+	 * Third item: data area for storing a single command
+	 * and its scatter-gather table
+	 */
+	pp->cmd_tbl = mem;
+	debug("cmd_tbl_dma = 0x%llx\n", pp->cmd_tbl);
+
+	mem += AHCI_CMD_TBL_HDR;
+
+	/* ahci_writel_with_flush(0x00004444, &(port_mmio->dmacr)); */
+
+	pp->cmd_tbl_sg = (struct ahci_sg *)mem;
+	ahci_writel_with_flush(LOWER32(pp->cmd_slot), &(port_mmio->clb));
+        ahci_writel_with_flush(UPPER32(pp->cmd_slot), &(port_mmio->clbu));
+	ahci_writel_with_flush(LOWER32(pp->rx_fis), &(port_mmio->fb));
+        ahci_writel_with_flush(UPPER32(pp->rx_fis), &(port_mmio->fbu));
+
+	/* Enable FRE */
+	ahci_writel_with_flush((SATA_PORT_CMD_FRE | ahci_readl(&(port_mmio->cmd))),
+			&(port_mmio->cmd));
+
+	/* Wait device ready */
+	while ((readl(&(port_mmio->tfd)) & (SATA_PORT_TFD_STS_ERR |
+		SATA_PORT_TFD_STS_DRQ | SATA_PORT_TFD_STS_BSY))
+		&& --timeout)
+		;
+	if (timeout <= 0) {
+		debug("Device not ready for BSY, DRQ and"
+			"ERR in TFD!\n");
+		return -1;
+	}
+
+	ahci_writel_with_flush(PORT_CMD_ICC_ACTIVE | PORT_CMD_FIS_RX |
+			  PORT_CMD_POWER_ON | PORT_CMD_SPIN_UP |
+			  PORT_CMD_START, &(port_mmio->cmd));
+
+	debug("Exit start port %d\n", port);
+
+	return 0;
+}
+
+int init_sata(int dev)
+{
+	int i;
+	u32 linkmap;
+	struct ahci_probe_ent *probe_ent = NULL;
+
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
+		printf("The sata index %d is out of ranges\n\r", dev);
+		return -1;
+	}
+
+	if (ahci_init_one(dev)) {
+		return -1;
+	}
+
+	probe_ent = (struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	linkmap = probe_ent->link_port_map;
+
+	if (0 == linkmap) {
+		printf("No port device detected!\n");
+		return 1;
+	}
+
+	for (i = 0; i < probe_ent->n_ports; i++) {
+		if ((linkmap >> i) && ((linkmap >> i) & 0x01)) {
+			if (ahci_port_start(probe_ent, (u8)i)) {
+				printf("Can not start port %d\n", i);
+				return 1;
+			}
+			probe_ent->hard_port_no = i;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void print_sata_device_info(int dev)
+{
+	block_dev_desc_t *pdev = &(sata_dev_desc[dev]);
+
+	printf("SATA Device Info:\n\r");
+#ifdef CONFIG_SYS_64BIT_LBA
+	printf("S/N: %s\n\rProduct model number: %s\n\r"
+		"Firmware version: %s\n\rCapacity: %lld sectors\n\r",
+		pdev->product, pdev->vendor, pdev->revision, pdev->lba);
+#else
+	printf("S/N: %s\n\rProduct model number: %s\n\r"
+		"Firmware version: %s\n\rCapacity: %ld sectors\n\r",
+		pdev->product, pdev->vendor, pdev->revision, pdev->lba);
+#endif
+}
+
+static void ahci_sata_identify(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_ID_ATA;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis,
+			(u8 *)id, ATA_ID_WORDS * 2, READ_CMD);
+	ata_swap_buf_le16(id, ATA_ID_WORDS);
+}
+
+static void ahci_sata_xfer_mode(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+
+	probe_ent->pio_mask = id[ATA_ID_PIO_MODES];
+	probe_ent->udma_mask = id[ATA_ID_UDMA_MODES];
+	debug("pio %04x, udma %04x\n\r",
+		probe_ent->pio_mask, probe_ent->udma_mask);
+}
+
+static u32 ahci_sata_rw_cmd(int dev, u32 start, u32 blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u32 block;
+
+	block = start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = (is_write) ? ATA_CMD_WRITE : ATA_CMD_READ;
+	cfis->device = ATA_LBA;
+
+	cfis->device |= (block >> 24) & 0xf;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+	cfis->sector_count = (u8)(blkcnt & 0xff);
+
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis,
+			buffer, ATA_SECT_SIZE * blkcnt, is_write) > 0)
+		return blkcnt;
+	else
+		return 0;
+}
+
+void ahci_sata_flush_cache(int dev)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_FLUSH;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, 0);
+}
+
+static u32 ahci_sata_rw_cmd_ext(int dev, u32 start, lbaint_t blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u64 block;
+
+	block = (u64)start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+
+	cfis->command = (is_write) ? ATA_CMD_WRITE_EXT
+				 : ATA_CMD_READ_EXT;
+
+	cfis->lba_high_exp = (block >> 40) & 0xff;
+	cfis->lba_mid_exp = (block >> 32) & 0xff;
+	cfis->lba_low_exp = (block >> 24) & 0xff;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+	cfis->device = ATA_LBA;
+	cfis->sector_count_exp = (blkcnt >> 8) & 0xff;
+	cfis->sector_count = blkcnt & 0xff;
+
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis, buffer,
+			ATA_SECT_SIZE * blkcnt, is_write) > 0)
+		return blkcnt;
+	else
+		return 0;
+}
+
+#if 0
+u32 cn88_ahsata_rw_ncq_cmd(int dev, u32 start, lbaint_t blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u64 block;
+
+	if (sata_dev_desc[dev].lba48 != 1) {
+		printf("execute FPDMA command on non-LBA48 hard disk\n\r");
+		return -1;
+	}
+
+	block = (u64)start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+
+	cfis->command = (is_write) ? ATA_CMD_FPDMA_WRITE
+				 : ATA_CMD_FPDMA_READ;
+
+	cfis->lba_high_exp = (block >> 40) & 0xff;
+	cfis->lba_mid_exp = (block >> 32) & 0xff;
+	cfis->lba_low_exp = (block >> 24) & 0xff;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+
+	cfis->device = ATA_LBA;
+	cfis->features_exp = (blkcnt >> 8) & 0xff;
+	cfis->features = blkcnt & 0xff;
+
+	/* Use the latest queue */
+	ahci_exec_ata_cmd(probe_ent, port, cfis,
+			buffer, ATA_SECT_SIZE * blkcnt, is_write);
+
+	return blkcnt;
+}
+#endif
+
+void ahci_sata_flush_cache_ext(int dev)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_FLUSH_EXT;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, 0);
+}
+
+static void ahci_sata_init_wcache(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+
+	if (ata_id_has_wcache(id) && ata_id_wcache_enabled(id))
+		probe_ent->flags |= SATA_FLAG_WCACHE;
+	if (ata_id_has_flush(id))
+		probe_ent->flags |= SATA_FLAG_FLUSH;
+	if (ata_id_has_flush_ext(id))
+		probe_ent->flags |= SATA_FLAG_FLUSH_EXT;
+}
+
+u32 ata_low_level_rw_lba48(int dev, u32 blknr, lbaint_t blkcnt,
+				const void *buffer, int is_write)
+{
+	u32 start, blks;
+	u8 *addr;
+	int max_blks;
+
+	start = blknr;
+	blks = blkcnt;
+	addr = (u8 *)buffer;
+
+	max_blks = ATA_MAX_SECTORS_LBA48;
+
+	do {
+		if (blks > max_blks) {
+			if (max_blks != ahci_sata_rw_cmd_ext(dev, start,
+						max_blks, addr, is_write))
+				return 0;
+			start += max_blks;
+			blks -= max_blks;
+			addr += ATA_SECT_SIZE * max_blks;
+		} else {
+			if (blks != ahci_sata_rw_cmd_ext(dev, start,
+						blks, addr, is_write))
+				return 0;
+			start += blks;
+			blks = 0;
+			addr += ATA_SECT_SIZE * blks;
+		}
+	} while (blks != 0);
+
+	return blkcnt;
+}
+
+u32 ata_low_level_rw_lba28(int dev, u32 blknr, lbaint_t blkcnt,
+				const void *buffer, int is_write)
+{
+	u32 start, blks;
+	u8 *addr;
+	int max_blks;
+
+	start = blknr;
+	blks = blkcnt;
+	addr = (u8 *)buffer;
+
+	max_blks = ATA_MAX_SECTORS;
+	do {
+		if (blks > max_blks) {
+			if (max_blks != ahci_sata_rw_cmd(dev, start,
+						max_blks, addr, is_write))
+				return 0;
+			start += max_blks;
+			blks -= max_blks;
+			addr += ATA_SECT_SIZE * max_blks;
+		} else {
+			if (blks != ahci_sata_rw_cmd(dev, start,
+						blks, addr, is_write))
+				return 0;
+			start += blks;
+			blks = 0;
+			addr += ATA_SECT_SIZE * blks;
+		}
+	} while (blks != 0);
+
+	return blkcnt;
+}
+
+/*
+ * SATA interface between low level driver and command layer
+ */
+ulong sata_read(int dev, ulong blknr, lbaint_t blkcnt, void *buffer)
+{
+	u32 rc;
+
+	if (sata_dev_desc[dev].lba48)
+		rc = ata_low_level_rw_lba48(dev, blknr, blkcnt,
+						buffer, READ_CMD);
+	else
+		rc = ata_low_level_rw_lba28(dev, blknr, blkcnt,
+						buffer, READ_CMD);
+	return rc;
+}
+
+ulong sata_write(int dev, ulong blknr, lbaint_t blkcnt, const void *buffer)
+{
+	u32 rc;
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	u32 flags = probe_ent->flags;
+
+	if (sata_dev_desc[dev].lba48) {
+		rc = ata_low_level_rw_lba48(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH_EXT))
+			ahci_sata_flush_cache_ext(dev);
+	} else {
+		rc = ata_low_level_rw_lba28(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH))
+			ahci_sata_flush_cache(dev);
+	}
+	return rc;
+}
+
+int scan_sata(int dev)
+{
+	u8 serial[ATA_ID_SERNO_LEN + 1] = { 0 };
+	u8 firmware[ATA_ID_FW_REV_LEN + 1] = { 0 };
+	u8 product[ATA_ID_PROD_LEN + 1] = { 0 };
+	u16 *id;
+	u64 n_sectors;
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	u8 port = probe_ent->hard_port_no;
+	block_dev_desc_t *pdev = &(sata_dev_desc[dev]);
+
+	id = (u16 *)memalign(ARCH_DMA_MINALIGN,
+				roundup(ARCH_DMA_MINALIGN,
+					(ATA_ID_WORDS * 2)));
+	if (!id) {
+		printf("id malloc failed\n\r");
+		return -1;
+	}
+
+	/* Identify device to get information */
+	ahci_sata_identify(dev, id);
+
+	/* Serial number */
+	ata_id_c_string(id, serial, ATA_ID_SERNO, sizeof(serial));
+	memcpy(pdev->product, serial, sizeof(serial));
+
+	/* Firmware version */
+	ata_id_c_string(id, firmware, ATA_ID_FW_REV, sizeof(firmware));
+	memcpy(pdev->revision, firmware, sizeof(firmware));
+
+	/* Product model */
+	ata_id_c_string(id, product, ATA_ID_PROD, sizeof(product));
+	memcpy(pdev->vendor, product, sizeof(product));
+
+	/* Totoal sectors */
+	n_sectors = ata_id_n_sectors(id);
+	pdev->lba = (u32)n_sectors;
+
+	pdev->type = DEV_TYPE_HARDDISK;
+	pdev->blksz = ATA_SECT_SIZE;
+	pdev->lun = 0 ;
+
+	/* Check if support LBA48 */
+	if (ata_id_has_lba48(id)) {
+		pdev->lba48 = 1;
+		debug("Device support LBA48\n\r");
+	}
+
+	/* Get the NCQ queue depth from device */
+	probe_ent->flags &= (~SATA_FLAG_Q_DEP_MASK);
+	probe_ent->flags |= ata_id_queue_depth(id);
+
+	/* Get the xfer mode from device */
+	ahci_sata_xfer_mode(dev, id);
+
+	/* Get the write cache status from device */
+	ahci_sata_init_wcache(dev, id);
+
+	/* Set the xfer mode to highest speed */
+	ahci_set_feature(dev, port);
+
+	free((void *)id);
+
+	print_sata_device_info(dev);
+
+	is_ready = 1;
+
+	return 0;
+}
diff --git a/drivers/block/sata_ahci.h b/drivers/block/sata_ahci.h
new file mode 100644
index 0000000000..2094184e6a
--- /dev/null
+++ b/drivers/block/sata_ahci.h
@@ -0,0 +1,500 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __SATA_AHCI_H__
+#define __SATA_AHCI_H__
+#include <pci.h>
+
+#define AHCI_MAX_CMD_SLOTS	32
+
+/* Max host controller numbers */
+#define SATA_HC_MAX_NUM		16
+/* Max command queue depth per host controller */
+#define SATA_HC_MAX_CMD		32
+/* Max port number per host controller */
+#define SATA_HC_MAX_PORT	16  /* TBD */
+
+/* Generic Host Register */
+#define SATA_HOST_CAP                0x00 /* host capabilities */
+#define SATA_HOST_CTL                0x04 /* global host control */
+#define SATA_HOST_IRQ_STAT           0x08 /* interrupt status */
+#define SATA_HOST_PORTS_IMPL         0x0c /* bitmap of implemented ports */
+#define SATA_HOST_VERSION            0x10 /* AHCI spec. version compliancy */
+#define SATA_HOST_CCC_CTL            0x14 
+#define SATA_HOST_EM_LOC             0x1C /* Enclosure Management location */
+#define SATA_HOST_EM_CTL             0x20 /* Enclosure Management Control */
+#define SATA_HOST_CAP2               0x24 /* host capabilities, extended */
+#define SATA_HOST_OOBR               0xBC
+
+/* HBA Capabilities Register */
+#define SATA_HOST_CAP_S64A		0x80000000
+#define SATA_HOST_CAP_SNCQ		0x40000000
+#define SATA_HOST_CAP_SSNTF		0x20000000
+#define SATA_HOST_CAP_SMPS		0x10000000
+#define SATA_HOST_CAP_SSS		0x08000000
+#define SATA_HOST_CAP_SALP		0x04000000
+#define SATA_HOST_CAP_SAL		0x02000000
+#define SATA_HOST_CAP_SCLO		0x01000000
+#define SATA_HOST_CAP_ISS_MASK		0x00f00000	/* interface speed support */
+#define SATA_HOST_CAP_ISS_OFFSET	20
+#define SATA_HOST_CAP_SNZO		0x00080000
+#define SATA_HOST_CAP_SAM		0x00040000
+#define SATA_HOST_CAP_SPM		0x00020000
+#define SATA_HOST_CAP_PMD		0x00008000
+#define SATA_HOST_CAP_SSC		0x00004000
+#define SATA_HOST_CAP_PSC		0x00002000
+#define SATA_HOST_CAP_NCS		0x00001f00
+#define SATA_HOST_CAP_CCCS		0x00000080
+#define SATA_HOST_CAP_EMS		0x00000040
+#define SATA_HOST_CAP_SXS		0x00000020
+#define SATA_HOST_CAP_NP_MASK		0x0000001f
+
+/* Global HBA Control Register */
+#define SATA_HOST_GHC_AE	0x80000000 /* AHCI enable */
+#define SATA_HOST_GHC_IE	0x00000002 /* Interrupt Enable */
+#define SATA_HOST_GHC_HR	0x00000001 /* HBA reset; self-clear */
+
+/* Interrupt Status Register */
+
+/* Ports Implemented Register */
+
+/* AHCI Version Register */
+#define SATA_HOST_VS_MJR_MASK	0xffff0000
+#define SATA_HOST_VS_MJR_OFFSET	16
+#define SATA_HOST_VS_MJR_MNR	0x0000ffff
+
+/* Command Completion Coalescing Control */
+#define SATA_HOST_CCC_CTL_TV_MASK	0xffff0000
+#define SATA_HOST_CCC_CTL_TV_OFFSET		16
+#define SATA_HOST_CCC_CTL_CC_MASK	0x0000ff00
+#define SATA_HOST_CCC_CTL_CC_OFFSET		8
+#define SATA_HOST_CCC_CTL_INT_MASK	0x000000f8
+#define SATA_HOST_CCC_CTL_INT_OFFSET	3
+#define SATA_HOST_CCC_CTL_EN	0x00000001
+
+/* Command Completion Coalescing Ports */
+
+/* HBA Capabilities Extended Register */
+#define SATA_HOST_CAP2_DESO		0x00000020
+#define SATA_HOST_CAP2_SADM		0x00000010
+#define SATA_HOST_CAP2_SDS		0x00000008
+#define SATA_HOST_CAP2_APST		0x00000004
+#define SATA_HOST_CAP2_NVMP		0x00000002
+#define SATA_HOST_CAP2_BOH		0x00000001
+
+/* BIST Activate FIS Register */
+#define SATA_HOST_BISTAFR_NCP_MASK	0x0000ff00
+#define SATA_HOST_BISTAFR_NCP_OFFSET	8
+#define SATA_HOST_BISTAFR_PD_MASK	0x000000ff
+#define SATA_HOST_BISTAFR_PD_OFFSET		0
+
+#define SATA_FIS_BISTAFR_PATTERN_LTDP	0xF1	/* low transition density pattern */
+#define SATA_FIS_BISTAFR_PATTERN_HTDP	0xB5	/* high transition density pattern */
+#define SATA_FIS_BISTAFR_PATTERN_LFSCP	0xAB	/* low frequency spectral component pattern */
+#define SATA_FIS_BISTAFR_PATTERN_SSOP	0x7F	/* simultaneous switching outputs pattern */
+#define SATA_FIS_BISTAFR_PATTERN_MFTP	0x78	/* mid frequency test pattern */
+#define SATA_FIS_BISTAFR_PATTERN_HFTP	0x4A	/* high frequency test pattern */
+#define SATA_FIS_BISTAFR_PATTERN_LFTP	0x7E	/* low frequency test pattern */
+
+#define SATA_FIS_BISTAFR_PD_FAREND_R	0x10	/* far-end retimed */
+#define SATA_FIS_BISTAFR_PD_FAREND_T	0xC0	/* far-end transmit only */
+#define SATA_FIS_BISTAFR_PD_FAREND_TS	0xE0	/* far-end transmit only with scrambler bypassed */
+
+
+/* BIST Control Register */
+#define SATA_HOST_BISTCR_FERLB		0x00100000
+#define SATA_HOST_BISTCR_TXO		0x00040000
+#define SATA_HOST_BISTCR_CNTCLR		0x00020000
+#define SATA_HOST_BISTCR_NEALB		0x00010000
+#define SATA_HOST_BISTCR_LLC_MASK	0x00000700
+#define SATA_HOST_BISTCR_LLC_OFFSET	8
+#define SATA_HOST_BISTCR_ERREN		0x00000040
+#define SATA_HOST_BISTCR_FLIP		0x00000020
+#define SATA_HOST_BISTCR_PV		0x00000010
+#define SATA_HOST_BISTCR_PATTERN_MASK	0x0000000f
+#define SATA_HOST_BISTCR_PATTERN_OFFSET	0
+
+/* BIST FIS Count Register */
+
+/* BIST Status Register */
+#define SATA_HOST_BISTSR_FRAMERR_MASK	0x0000ffff
+#define SATA_HOST_BISTSR_FRAMERR_OFFSET	0
+#define SATA_HOST_BISTSR_BRSTERR_MASK	0x00ff0000
+#define SATA_HOST_BISTSR_BRSTERR_OFFSET	16
+
+/* BIST DWORD Error Count Register */
+
+/* OOB Register*/
+#define SATA_HOST_OOBR_WE		0x80000000
+#define SATA_HOST_OOBR_cwMin_MASK	0x7f000000
+#define SATA_HOST_OOBR_cwMAX_MASK	0x00ff0000
+#define SATA_HOST_OOBR_ciMin_MASK	0x0000ff00
+#define SATA_HOST_OOBR_ciMax_MASK	0x000000ff
+
+/* Timer 1-ms Register */
+
+/* Global Parameter 1 Register */
+#define SATA_HOST_GPARAM1R_ALIGN_M	0x80000000
+#define SATA_HOST_GPARAM1R_RX_BUFFER	0x40000000
+#define SATA_HOST_GPARAM1R_PHY_DATA_MASK	0x30000000
+#define SATA_HOST_GPARAM1R_PHY_RST	0x08000000
+#define SATA_HOST_GPARAM1R_PHY_CTRL_MASK	0x07e00000
+#define SATA_HOST_GPARAM1R_PHY_STAT_MASK	0x001f8000
+#define SATA_HOST_GPARAM1R_LATCH_M	0x00004000
+#define SATA_HOST_GPARAM1R_BIST_M	0x00002000
+#define SATA_HOST_GPARAM1R_PHY_TYPE	0x00001000
+#define SATA_HOST_GPARAM1R_RETURN_ERR	0x00000400
+#define SATA_HOST_GPARAM1R_AHB_ENDIAN_MASK	0x00000300
+#define SATA_HOST_GPARAM1R_S_HADDR	0X00000080
+#define SATA_HOST_GPARAM1R_M_HADDR	0X00000040
+
+/* Global Parameter 2 Register */
+#define SATA_HOST_GPARAM2R_BIST_M	0x00040000
+#define SATA_HOST_GPARAM2R_DEV_CP	0x00004000
+#define SATA_HOST_GPARAM2R_DEV_MP	0x00002000
+#define SATA_HOST_GPARAM2R_DEV_ENCODE_M	0x00001000
+#define SATA_HOST_GPARAM2R_RXOOB_CLK_M	0x00000800
+#define SATA_HOST_GPARAM2R_RXOOB_M	0x00000400
+#define SATA_HOST_GPARAM2R_TX_OOB_M	0x00000200
+#define SATA_HOST_GPARAM2R_RXOOB_CLK_MASK	0x000001ff
+
+/* Port Parameter Register */
+#define SATA_HOST_PPARAMR_TX_MEM_M	0x00000200
+#define SATA_HOST_PPARAMR_TX_MEM_S	0x00000100
+#define SATA_HOST_PPARAMR_RX_MEM_M	0x00000080
+#define SATA_HOST_PPARAMR_RX_MEM_S	0x00000040
+#define SATA_HOST_PPARAMR_TXFIFO_DEPTH_MASK	0x00000038
+#define SATA_HOST_PPARAMR_RXFIFO_DEPTH_MASK	0x00000007
+
+/* Test Register */
+#define SATA_HOST_TESTR_PSEL_MASK	0x00070000
+#define SATA_HOST_TESTR_TEST_IF		0x00000001
+
+/* Port Register Descriptions */
+/* Port# Command List Base Address Register */
+#define SATA_PORT_CLB_CLB_MASK		0xfffffc00
+
+/* Port# Command List Base Address Upper 32-Bits Register */
+
+/* Port# FIS Base Address Register */
+#define SATA_PORT_FB_FB_MASK		0xfffffff0
+
+/* Port# FIS Base Address Upper 32-Bits Register */
+
+/* Port# Interrupt Status Register */
+#define SATA_PORT_IS_CPDS		0x80000000
+#define SATA_PORT_IS_TFES		0x40000000
+#define SATA_PORT_IS_HBFS		0x20000000
+#define SATA_PORT_IS_HBDS		0x10000000
+#define SATA_PORT_IS_IFS		0x08000000
+#define SATA_PORT_IS_INFS		0x04000000
+#define SATA_PORT_IS_OFS		0x01000000
+#define SATA_PORT_IS_IPMS		0x00800000
+#define SATA_PORT_IS_PRCS		0x00400000
+#define SATA_PORT_IS_DMPS		0x00000080
+#define SATA_PORT_IS_PCS		0x00000040
+#define SATA_PORT_IS_DPS		0x00000020
+#define SATA_PORT_IS_UFS		0x00000010
+#define SATA_PORT_IS_SDBS		0x00000008
+#define SATA_PORT_IS_DSS		0x00000004
+#define SATA_PORT_IS_PSS		0x00000002
+#define SATA_PORT_IS_DHRS		0x00000001
+
+/* Port# Interrupt Enable Register */
+#define SATA_PORT_IE_CPDE		0x80000000
+#define SATA_PORT_IE_TFEE		0x40000000
+#define SATA_PORT_IE_HBFE		0x20000000
+#define SATA_PORT_IE_HBDE		0x10000000
+#define SATA_PORT_IE_IFE		0x08000000
+#define SATA_PORT_IE_INFE		0x04000000
+#define SATA_PORT_IE_OFE		0x01000000
+#define SATA_PORT_IE_IPME		0x00800000
+#define SATA_PORT_IE_PRCE		0x00400000
+#define SATA_PORT_IE_DMPE		0x00000080
+#define SATA_PORT_IE_PCE		0x00000040
+#define SATA_PORT_IE_DPE		0x00000020
+#define SATA_PORT_IE_UFE		0x00000010
+#define SATA_PORT_IE_SDBE		0x00000008
+#define SATA_PORT_IE_DSE		0x00000004
+#define SATA_PORT_IE_PSE		0x00000002
+#define SATA_PORT_IE_DHRE		0x00000001
+
+/* Port# Command Register */
+#define SATA_PORT_CMD_ICC_MASK		0xf0000000
+#define SATA_PORT_CMD_ASP		0x08000000
+#define SATA_PORT_CMD_ALPE		0x04000000
+#define SATA_PORT_CMD_DLAE		0x02000000
+#define SATA_PORT_CMD_ATAPI		0x01000000
+#define SATA_PORT_CMD_APSTE		0x00800000
+#define SATA_PORT_CMD_ESP		0x00200000
+#define SATA_PORT_CMD_CPD		0x00100000
+#define SATA_PORT_CMD_MPSP		0x00080000
+#define SATA_PORT_CMD_HPCP		0x00040000
+#define SATA_PORT_CMD_PMA		0x00020000
+#define SATA_PORT_CMD_CPS		0x00010000
+#define SATA_PORT_CMD_CR		0x00008000
+#define SATA_PORT_CMD_FR		0x00004000
+#define SATA_PORT_CMD_MPSS		0x00002000
+#define SATA_PORT_CMD_CCS_MASK		0x00001f00
+#define SATA_PORT_CMD_FRE		0x00000010
+#define SATA_PORT_CMD_CLO		0x00000008
+#define SATA_PORT_CMD_POD		0x00000004
+#define SATA_PORT_CMD_SUD		0x00000002
+#define SATA_PORT_CMD_ST		0x00000001
+
+/* Port# Task File Data Register */
+#define SATA_PORT_TFD_ERR_MASK		0x0000ff00
+#define SATA_PORT_TFD_STS_MASK		0x000000ff
+#define SATA_PORT_TFD_STS_ERR		0x00000001
+#define SATA_PORT_TFD_STS_DRQ		0x00000008
+#define SATA_PORT_TFD_STS_BSY		0x00000080
+
+/* Port# Signature Register */
+
+/* Port# Serial ATA Status {SStatus} Register */
+#define SATA_PORT_SSTS_IPM_MASK		0x00000f00
+#define SATA_PORT_SSTS_SPD_MASK		0x000000f0
+#define SATA_PORT_SSTS_DET_MASK		0x0000000f
+
+/* Port# Serial ATA Control {SControl} Register */
+#define SATA_PORT_SCTL_IPM_MASK		0x00000f00
+#define SATA_PORT_SCTL_SPD_MASK		0x000000f0
+#define SATA_PORT_SCTL_DET_MASK		0x0000000f
+
+/* Port# Serial ATA Error {SError} Register */
+#define SATA_PORT_SERR_DIAG_X		0x04000000
+#define SATA_PORT_SERR_DIAG_F		0x02000000
+#define SATA_PORT_SERR_DIAG_T		0x01000000
+#define SATA_PORT_SERR_DIAG_S		0x00800000
+#define SATA_PORT_SERR_DIAG_H		0x00400000
+#define SATA_PORT_SERR_DIAG_C		0x00200000
+#define SATA_PORT_SERR_DIAG_D		0x00100000
+#define SATA_PORT_SERR_DIAG_B		0x00080000
+#define SATA_PORT_SERR_DIAG_W		0x00040000
+#define SATA_PORT_SERR_DIAG_I		0x00020000
+#define SATA_PORT_SERR_DIAG_N		0x00010000
+#define SATA_PORT_SERR_ERR_E		0x00000800
+#define SATA_PORT_SERR_ERR_P		0x00000400
+#define SATA_PORT_SERR_ERR_C		0x00000200
+#define SATA_PORT_SERR_ERR_T		0x00000100
+#define SATA_PORT_SERR_ERR_M		0x00000002
+#define SATA_PORT_SERR_ERR_I		0x00000001
+
+/* Port# Serial ATA Active {SActive} Register */
+
+/* Port# Command Issue Register */
+
+/* Port# Serial ATA Notification Register */
+
+/* Port# DMA Control Register */
+#define SATA_PORT_DMACR_RXABL_MASK	0x0000f000
+#define SATA_PORT_DMACR_TXABL_MASK	0x00000f00
+#define SATA_PORT_DMACR_RXTS_MASK	0x000000f0
+#define SATA_PORT_DMACR_TXTS_MASK	0x0000000f
+
+/* Port# PHY Control Register */
+
+/* Port# PHY Status Register */
+
+#define SATA_HC_CMD_HDR_ENTRY_SIZE	sizeof(struct cmd_hdr_entry)
+
+/* DW0
+*/
+#define CMD_HDR_DI_CFL_MASK	0x0000001f
+#define CMD_HDR_DI_CFL_OFFSET	0
+#define CMD_HDR_DI_A			0x00000020
+#define CMD_HDR_DI_W			0x00000040
+#define CMD_HDR_DI_P			0x00000080
+#define CMD_HDR_DI_R			0x00000100
+#define CMD_HDR_DI_B			0x00000200
+#define CMD_HDR_DI_C			0x00000400
+#define CMD_HDR_DI_PMP_MASK	0x0000f000
+#define CMD_HDR_DI_PMP_OFFSET	12
+#define CMD_HDR_DI_PRDTL		0xffff0000
+#define CMD_HDR_DI_PRDTL_OFFSET	16
+
+/* prde_fis_len
+*/
+#define CMD_HDR_PRD_ENTRY_SHIFT	16
+#define CMD_HDR_PRD_ENTRY_MASK	0x003f0000
+#define CMD_HDR_FIS_LEN_SHIFT	2
+
+/* attribute
+*/
+#define CMD_HDR_ATTR_RES	0x00000800 /* Reserved bit, should be 1 */
+#define CMD_HDR_ATTR_VBIST	0x00000400 /* Vendor BIST */
+/* Snoop enable for all descriptor */
+#define CMD_HDR_ATTR_SNOOP	0x00000200
+#define CMD_HDR_ATTR_FPDMA	0x00000100 /* FPDMA queued command */
+#define CMD_HDR_ATTR_RESET	0x00000080 /* Reset - a SRST or device reset */
+/* BIST - require the host to enter BIST mode */
+#define CMD_HDR_ATTR_BIST	0x00000040
+#define CMD_HDR_ATTR_ATAPI	0x00000020 /* ATAPI command */
+#define CMD_HDR_ATTR_TAG	0x0000001f /* TAG mask */
+
+#define FLAGS_DMA	0x00000000
+#define FLAGS_FPDMA	0x00000001
+
+#define SATA_FLAG_Q_DEP_MASK	0x0000000f
+#define SATA_FLAG_WCACHE	0x00000100
+#define SATA_FLAG_FLUSH		0x00000200
+#define SATA_FLAG_FLUSH_EXT	0x00000400
+
+#define READ_CMD	0
+#define WRITE_CMD	1
+
+#define AHCI_PCI_BAR            0x24
+#define AHCI_MAX_SG             56 /* hardware max is 64K */
+#define AHCI_CMD_SLOT_SZ        32
+#define AHCI_MAX_CMD_SLOT       32
+#define AHCI_RX_FIS_SZ          256
+#define AHCI_CMD_TBL_HDR        0x80
+#define AHCI_CMD_TBL_CDB        0x40
+#define AHCI_CMD_TBL_SZ         AHCI_CMD_TBL_HDR + (AHCI_MAX_SG * 16)
+#define AHCI_PORT_PRIV_DMA_SZ   (AHCI_CMD_SLOT_SZ * AHCI_MAX_CMD_SLOT + \
+                                AHCI_CMD_TBL_SZ + AHCI_RX_FIS_SZ)
+#define AHCI_CMD_ATAPI          (1 << 5)
+#define AHCI_CMD_WRITE          (1 << 6)
+#define AHCI_CMD_PREFETCH       (1 << 7)
+#define AHCI_CMD_RESET          (1 << 8)
+#define AHCI_CMD_CLR_BUSY       (1 << 10)
+
+#define RX_FIS_D2H_REG          0x40    /* offset of D2H Register FIS data */
+
+/* Global controller registers */
+#define HOST_CAP                0x00 /* host capabilities */
+#define HOST_CTL                0x04 /* global host control */
+#define HOST_IRQ_STAT           0x08 /* interrupt status */
+#define HOST_PORTS_IMPL         0x0c /* bitmap of implemented ports */
+#define HOST_VERSION            0x10 /* AHCI spec. version compliancy */
+#define HOST_CAP2               0x24 /* host capabilities, extended */
+
+/* HOST_CTL bits */
+#define HOST_RESET              (1 << 0)  /* reset controller; self-clear */
+#define HOST_IRQ_EN             (1 << 1)  /* global IRQ enable */
+#define HOST_AHCI_EN            (1 << 31) /* AHCI enabled */
+
+/* Registers for each SATA port */
+#define PORT_LST_ADDR           0x00 /* command list DMA addr */
+#define PORT_LST_ADDR_HI        0x04 /* command list DMA addr hi */
+#define PORT_FIS_ADDR           0x08 /* FIS rx buf addr */
+#define PORT_FIS_ADDR_HI        0x0c /* FIS rx buf addr hi */
+#define PORT_IRQ_STAT           0x10 /* interrupt status */
+#define PORT_IRQ_MASK           0x14 /* interrupt enable/disable mask */
+#define PORT_CMD                0x18 /* port command */
+#define PORT_TFDATA             0x20 /* taskfile data */
+#define PORT_SIG                0x24 /* device TF signature */
+#define PORT_CMD_ISSUE          0x38 /* command issue */
+#define PORT_SCR                0x28 /* SATA phy register block */
+#define PORT_SCR_STAT           0x28 /* SATA phy register: SStatus */
+#define PORT_SCR_CTL            0x2c /* SATA phy register: SControl */
+#define PORT_SCR_ERR            0x30 /* SATA phy register: SError */
+#define PORT_SCR_ACT            0x34 /* SATA phy register: SActive */
+
+/* PORT_IRQ_{STAT,MASK} bits */
+#define PORT_IRQ_COLD_PRES      (1 << 31) /* cold presence detect */
+#define PORT_IRQ_TF_ERR         (1 << 30) /* task file error */
+#define PORT_IRQ_HBUS_ERR       (1 << 29) /* host bus fatal error */
+#define PORT_IRQ_HBUS_DATA_ERR  (1 << 28) /* host bus data error */
+#define PORT_IRQ_IF_ERR         (1 << 27) /* interface fatal error */
+#define PORT_IRQ_IF_NONFATAL    (1 << 26) /* interface non-fatal error */
+#define PORT_IRQ_OVERFLOW       (1 << 24) /* xfer exhausted available S/G */
+#define PORT_IRQ_BAD_PMP        (1 << 23) /* incorrect port multiplier */
+
+#define PORT_IRQ_PHYRDY         (1 << 22) /* PhyRdy changed */
+#define PORT_IRQ_DEV_ILCK       (1 << 7) /* device interlock */
+#define PORT_IRQ_CONNECT        (1 << 6) /* port connect change status */
+#define PORT_IRQ_SG_DONE        (1 << 5) /* descriptor processed */
+#define PORT_IRQ_UNK_FIS        (1 << 4) /* unknown FIS rx'd */
+#define PORT_IRQ_SDB_FIS        (1 << 3) /* Set Device Bits FIS rx'd */
+#define PORT_IRQ_DMAS_FIS       (1 << 2) /* DMA Setup FIS rx'd */
+#define PORT_IRQ_PIOS_FIS       (1 << 1) /* PIO Setup FIS rx'd */
+#define PORT_IRQ_D2H_REG_FIS    (1 << 0) /* D2H Register FIS rx'd */
+
+#define PORT_IRQ_FATAL          PORT_IRQ_TF_ERR | PORT_IRQ_HBUS_ERR     \
+                                | PORT_IRQ_HBUS_DATA_ERR | PORT_IRQ_IF_ERR
+
+#define DEF_PORT_IRQ            PORT_IRQ_FATAL | PORT_IRQ_PHYRDY        \
+                                | PORT_IRQ_CONNECT | PORT_IRQ_SG_DONE   \
+                                | PORT_IRQ_UNK_FIS | PORT_IRQ_SDB_FIS   \
+                                | PORT_IRQ_DMAS_FIS | PORT_IRQ_PIOS_FIS \
+                                | PORT_IRQ_D2H_REG_FIS
+
+/* PORT_SCR_STAT bits */
+#define PORT_SCR_STAT_DET_MASK  0x3
+#define PORT_SCR_STAT_DET_COMINIT 0x1
+#define PORT_SCR_STAT_DET_PHYRDY 0x3
+
+/* PORT_CMD bits */
+#define PORT_CMD_ATAPI          (1 << 24) /* Device is ATAPI */
+#define PORT_CMD_LIST_ON        (1 << 15) /* cmd list DMA engine running */
+#define PORT_CMD_FIS_ON         (1 << 14) /* FIS DMA engine running */
+#define PORT_CMD_FIS_RX         (1 << 4) /* Enable FIS receive DMA engine */
+#define PORT_CMD_CLO            (1 << 3) /* Command list override */
+#define PORT_CMD_POWER_ON       (1 << 2) /* Power up device */
+#define PORT_CMD_SPIN_UP        (1 << 1) /* Spin up device */
+#define PORT_CMD_START          (1 << 0) /* Enable port DMA engine */
+
+#define PORT_CMD_ICC_ACTIVE     (0x1 << 28) /* Put i/f in active state */
+#define PORT_CMD_ICC_PARTIAL    (0x2 << 28) /* Put i/f in partial state */
+#define PORT_CMD_ICC_SLUMBER    (0x6 << 28) /* Put i/f in slumber state */
+
+#define AHCI_MAX_PORTS          32
+
+#define ATA_FLAG_SATA           (1 << 3)
+#define ATA_FLAG_NO_LEGACY      (1 << 4) /* no legacy mode check */
+#define ATA_FLAG_MMIO           (1 << 6) /* use MMIO, not PIO */
+#define ATA_FLAG_SATA_RESET     (1 << 7) /* (obsolete) use COMRESET */
+#define ATA_FLAG_PIO_DMA        (1 << 8) /* PIO cmds via DMA */
+#define ATA_FLAG_NO_ATAPI       (1 << 11) /* No ATAPI support */
+
+#define LOWER32(val)	(u32)((u64)(val) & 0xffffffff)
+#define UPPER32(val)    (u32)(((u64)(val) & 0xffffffff00000000) >> 32) 
+
+struct ahci_cmd_hdr {
+        u32     opts;
+        u32     status;  	/* PRD byte Count */
+        u32     tbl_addr;
+        u32     tbl_addr_hi;
+        u32     reserved[4];
+};
+
+struct ahci_sg {	/* PRDT: Physical Region Descript or Table */
+        u32     addr;
+        u32     addr_hi;
+        u32     reserved;
+        u32     flags_size;
+};
+
+struct ahci_ioports {
+        u64     cmd_addr;
+        u64     scr_addr;
+        u64     port_mmio;
+        struct ahci_cmd_hdr     *cmd_slot;
+        struct ahci_sg          *cmd_tbl_sg;
+        u64     cmd_tbl;
+        u64     rx_fis;
+};
+
+struct ahci_probe_ent {
+        pci_dev_t       dev;
+        struct ahci_ioports     port[AHCI_MAX_PORTS];
+        u32     n_ports;
+        u32     hard_port_no;
+        u32     host_flags;
+        u32     host_set_flags;
+        u64     mmio_base;
+        u32     pio_mask;
+        u32     udma_mask;
+        u32     flags;
+        u32     cap;       /* cache of HOST_CAP register */
+        u32     port_map;  /* cache of HOST_PORTS_IMPL reg */
+        u32     link_port_map; /*linkup port map*/
+};
+
+ 
+#endif /* __SATA_AHCI_H__ */ 
-- 
2.29.0

