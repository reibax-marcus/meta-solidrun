From 06c0257306ac4f534713c223db00035fdd2203e5 Mon Sep 17 00:00:00 2001
From: Suneel Garapati <sgarapati@caviumnetworks.com>
Date: Thu, 13 Sep 2018 15:12:23 -0700
Subject: [PATCH 0820/1239] drivers: net: octeontx2: update csrs to latest

Signed-off-by: Suneel Garapati <sgarapati@caviumnetworks.com>
---
 drivers/net/cavium/octeontx2/cavm-csrs-cgx.h | 1994 ++++++++---------
 drivers/net/cavium/octeontx2/cavm-csrs-lmt.h |   47 +-
 drivers/net/cavium/octeontx2/cavm-csrs-nix.h | 2039 ++++++++----------
 drivers/net/cavium/octeontx2/cavm-csrs-npa.h |  519 ++---
 drivers/net/cavium/octeontx2/cavm-csrs-npc.h |  522 +++--
 drivers/net/cavium/octeontx2/cavm-csrs-rvu.h |  447 ++--
 6 files changed, 2510 insertions(+), 3058 deletions(-)

diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-cgx.h b/drivers/net/cavium/octeontx2/cavm-csrs-cgx.h
index d48e5fd56b..54fe1f1ead 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-cgx.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-cgx.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_CGX_H__
 #define __CAVM_CSRS_CGX_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,15 +14,15 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium CGX.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
 /**
  * Enumeration cgx_bar_e
  *
- * CGX Base Address Register Enumeration
- * Enumerates the base address registers.
+ * CGX Base Address Register Enumeration Enumerates the base address
+ * registers.
  */
 #define CAVM_CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
 #define CAVM_CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
@@ -65,8 +32,7 @@
 /**
  * Enumeration cgx_int_vec_e
  *
- * CGX MSI-X Vector Enumeration
- * Enumeration the MSI-X interrupt vectors.
+ * CGX MSI-X Vector Enumeration Enumeration the MSI-X interrupt vectors.
  */
 #define CAVM_CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
 #define CAVM_CGX_INT_VEC_E_CMR_MEM_INT (0x24)
@@ -83,8 +49,7 @@
 /**
  * Enumeration cgx_lmac_types_e
  *
- * CGX LMAC Type Enumeration
- * Enumerates the LMAC Types that CGX supports.
+ * CGX LMAC Type Enumeration Enumerates the LMAC Types that CGX supports.
  */
 #define CAVM_CGX_LMAC_TYPES_E_FIFTYG_R (8)
 #define CAVM_CGX_LMAC_TYPES_E_FORTYG_R (4)
@@ -101,9 +66,8 @@
 /**
  * Enumeration cgx_opcode_e
  *
- * INTERNAL: CGX Error Opcode Enumeration
- *
- * Enumerates the error opcodes created by CGX and presented to NCSI/NIX.
+ * INTERNAL: CGX Error Opcode Enumeration  Enumerates the error opcodes
+ * created by CGX and presented to NCSI/NIX.
  */
 #define CAVM_CGX_OPCODE_E_RE_FCS (7)
 #define CAVM_CGX_OPCODE_E_RE_FCS_RCV (8)
@@ -117,8 +81,8 @@
 /**
  * Enumeration cgx_spu_br_train_cst_e
  *
- * CGX Training Coefficient Status Enumeration
- * 2-bit status for each coefficient as defined in IEEE 802.3, Table 72-5.
+ * CGX Training Coefficient Status Enumeration 2-bit status for each
+ * coefficient as defined in IEEE 802.3, Table 72-5.
  */
 #define CAVM_CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
 #define CAVM_CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
@@ -128,8 +92,8 @@
 /**
  * Enumeration cgx_spu_br_train_cup_e
  *
- * CGX Training Coefficient Enumeration
- * 2-bit command for each coefficient as defined in IEEE 802.3, Table 72-4.
+ * CGX Training Coefficient Enumeration 2-bit command for each
+ * coefficient as defined in IEEE 802.3, Table 72-4.
  */
 #define CAVM_CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
 #define CAVM_CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
@@ -139,13 +103,13 @@
 /**
  * Enumeration cgx_usxgmii_rate_e
  *
- * CGX USXGMII Rate Enumeration
- * Enumerates the USXGMII sub-port type rate, CGX()_SPU()_CONTROL1[USXGMII_RATE].
- *
- * Selecting a rate higher than the maximum allowed for a given port sub-type
- * (specified by CGX()_SPU()_CONTROL1[USXGMII_TYPE]), e.g., selecting ::RATE_2HG (2.5
- * Gbps) for CGX_USXGMII_TYPE_E::SXGMII_2G, will cause unpredictable behavior. USXGMII
- * hardware-based autonegotiation may change this setting.
+ * CGX USXGMII Rate Enumeration Enumerates the USXGMII sub-port type
+ * rate, CGX()_SPU()_CONTROL1[USXGMII_RATE].  Selecting a rate higher
+ * than the maximum allowed for a given port sub-type (specified by
+ * CGX()_SPU()_CONTROL1[USXGMII_TYPE]), e.g., selecting ::RATE_2HG (2.5
+ * Gbps) for CGX_USXGMII_TYPE_E::SXGMII_2G, will cause unpredictable
+ * behavior. USXGMII hardware-based autonegotiation may change this
+ * setting.
  */
 #define CAVM_CGX_USXGMII_RATE_E_RATE_100M (1)
 #define CAVM_CGX_USXGMII_RATE_E_RATE_10G (5)
@@ -159,18 +123,16 @@
 /**
  * Enumeration cgx_usxgmii_type_e
  *
- * CGX USXGMII Port Sub-Type Enumeration
- * Enumerates the USXGMII sub-port type, CGX()_SPU()_CONTROL1[USXGMII_TYPE].
- *
- * The description indicates the maximum rate and the maximum number of ports (LMACs)
- * for each sub-type. The minimum rate for any port is 10M.
- * The rate selection for each LMAC is made using CGX()_SPU()_CONTROL1[USXGMII_RATE]
- * and the number of active ports/LMACs is implicitly determined by the value given to
- * CGX()_CMR()_CONFIG[ENABLE] for each LMAC.
- *
- * Selecting a rate higher than the maximum allowed for a given port sub-type or
- * enabling more LMACs than the maximum allowed for a given port sub-type will cause
- * unpredictable behavior.
+ * CGX USXGMII Port Sub-Type Enumeration Enumerates the USXGMII sub-port
+ * type, CGX()_SPU()_CONTROL1[USXGMII_TYPE].  The description indicates
+ * the maximum rate and the maximum number of ports (LMACs) for each sub-
+ * type. The minimum rate for any port is 10M. The rate selection for
+ * each LMAC is made using CGX()_SPU()_CONTROL1[USXGMII_RATE] and the
+ * number of active ports/LMACs is implicitly determined by the value
+ * given to CGX()_CMR()_CONFIG[ENABLE] for each LMAC.  Selecting a rate
+ * higher than the maximum allowed for a given port sub-type or enabling
+ * more LMACs than the maximum allowed for a given port sub-type will
+ * cause unpredictable behavior.
  */
 #define CAVM_CGX_USXGMII_TYPE_E_DXGMII_10G (3)
 #define CAVM_CGX_USXGMII_TYPE_E_DXGMII_20G (5)
@@ -184,9 +146,9 @@
 /**
  * Structure cgx_spu_br_lane_train_status_s
  *
- * CGX Lane Training Status Structure
- * This is the group of lane status bits for a single lane in the BASE-R PMD status register
- * (MDIO address 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
+ * CGX Lane Training Status Structure This is the group of lane status
+ * bits for a single lane in the BASE-R PMD status register (MDIO address
+ * 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
  */
 union cavm_cgx_spu_br_lane_train_status_s {
 	u32 u;
@@ -203,9 +165,9 @@ union cavm_cgx_spu_br_lane_train_status_s {
 /**
  * Structure cgx_spu_br_train_cup_s
  *
- * CGX Lane Training Coeffiecient Structure
- * This is the coefficient update field of the BASE-R link training packet as defined in
- * IEEE 802.3, Table 72-4.
+ * CGX Lane Training Coeffiecient Structure This is the coefficient
+ * update field of the BASE-R link training packet as defined in IEEE
+ * 802.3, Table 72-4.
  */
 union cavm_cgx_spu_br_train_cup_s {
 	u32 u;
@@ -233,9 +195,8 @@ union cavm_cgx_spu_br_train_cup_s {
 /**
  * Structure cgx_spu_br_train_rep_s
  *
- * CGX Training Report Structure
- * This is the status report field of the BASE-R link training packet as defined in IEEE 802.3,
- * Table 72-5.
+ * CGX Training Report Structure This is the status report field of the
+ * BASE-R link training packet as defined in IEEE 802.3, Table 72-5.
  */
 union cavm_cgx_spu_br_train_rep_s {
 	u32 u;
@@ -253,10 +214,9 @@ union cavm_cgx_spu_br_train_rep_s {
 /**
  * Structure cgx_spu_sds_cu_s
  *
- * INTERNAL: CGX Training Coeffiecient Structure
- *
- * This structure is similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields removed
- * and [RCVR_READY] field added.
+ * INTERNAL: CGX Training Coeffiecient Structure  This structure is
+ * similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields
+ * removed and [RCVR_READY] field added.
  */
 union cavm_cgx_spu_sds_cu_s {
 	u32 u;
@@ -275,9 +235,10 @@ union cavm_cgx_spu_sds_cu_s {
 /**
  * Structure cgx_spu_sds_skew_status_s
  *
- * CGX Skew Status Structure
- * Provides receive skew information detected for a physical SerDes lane when it is assigned to a
- * multilane LMAC/LPCS. Contents are valid when RX deskew is done for the associated LMAC/LPCS.
+ * CGX Skew Status Structure Provides receive skew information detected
+ * for a physical SerDes lane when it is assigned to a multilane
+ * LMAC/LPCS. Contents are valid when RX deskew is done for the
+ * associated LMAC/LPCS.
  */
 union cavm_cgx_spu_sds_skew_status_s {
 	u32 u;
@@ -295,9 +256,9 @@ union cavm_cgx_spu_sds_skew_status_s {
 /**
  * Structure cgx_spu_sds_sr_s
  *
- * INTERNAL: CGX Lane Training Coefficient Structure
- *
- * Similar to CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields removed.
+ * INTERNAL: CGX Lane Training Coefficient Structure  Similar to
+ * CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields
+ * removed.
  */
 union cavm_cgx_spu_sds_sr_s {
 	u32 u;
@@ -313,8 +274,8 @@ union cavm_cgx_spu_sds_sr_s {
 /**
  * Register (RSL) cgx#_active_pc
  *
- * CGX ACTIVE PC Register
- * This register counts the conditional clocks for power management.
+ * CGX ACTIVE PC Register This register counts the conditional clocks for
+ * power management.
  */
 union cavm_cgxx_active_pc {
 	u64 u;
@@ -360,73 +321,69 @@ static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_config
  *
- * CGX CMR Configuration Registers
- * Logical MAC/PCS configuration registers; one per LMAC. The maximum number of LMACs (and
- * maximum LMAC ID) that can be enabled by these registers is limited by
- * CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS].
- *
- * Internal:
- * \<pre\>
- * Example configurations:
- *   ---------------------------------------------------------------------------
- *   Configuration           LMACS  Register             [ENABLE]    [LMAC_TYPE]
- *   ---------------------------------------------------------------------------
- *   1x50G+1x25G+1xSGMII     4      CGXn_CMR0_CONFIG     1           8
- *                                  CGXn_CMR1_CONFIG     0           --
- *                                  CGXn_CMR2_CONFIG     1           7
- *                                  CGXn_CMR3_CONFIG     1           0
- *   ---------------------------------------------------------------------------
- *   USXGMII                 1-4    CGXn_CMR0_CONFIG     1           a
- *                                  CGXn_CMR1_CONFIG     1           a
- *                                  CGXn_CMR2_CONFIG     1           a
- *                                  CGXn_CMR3_CONFIG     1           a
- *   ---------------------------------------------------------------------------
- *   1x100GBASE-R4           1      CGXn_CMR0_CONFIG     1           9
- *                                  CGXn_CMR1_CONFIG     0           --
- *                                  CGXn_CMR2_CONFIG     0           --
- *                                  CGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   2x50GBASE-R2            2      CGXn_CMR0_CONFIG     1           8
- *                                  CGXn_CMR1_CONFIG     1           8
- *                                  CGXn_CMR2_CONFIG     0           --
- *                                  CGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   4x25GBASE-R             4      CGXn_CMR0_CONFIG     1           7
- *                                  CGXn_CMR1_CONFIG     1           7
- *                                  CGXn_CMR2_CONFIG     1           7
- *                                  CGXn_CMR3_CONFIG     1           7
- *   ---------------------------------------------------------------------------
- *   QSGMII                  4      CGXn_CMR0_CONFIG     1           6
- *                                  CGXn_CMR1_CONFIG     1           6
- *                                  CGXn_CMR2_CONFIG     1           6
- *                                  CGXn_CMR3_CONFIG     1           6
- *   ---------------------------------------------------------------------------
- *   1x40GBASE-R4            1      CGXn_CMR0_CONFIG     1           4
- *                                  CGXn_CMR1_CONFIG     0           --
- *                                  CGXn_CMR2_CONFIG     0           --
- *                                  CGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   4x10GBASE-R             4      CGXn_CMR0_CONFIG     1           3
- *                                  CGXn_CMR1_CONFIG     1           3
- *                                  CGXn_CMR2_CONFIG     1           3
- *                                  CGXn_CMR3_CONFIG     1           3
- *   ---------------------------------------------------------------------------
- *   2xRXAUI                 2      CGXn_CMR0_CONFIG     1           2
- *                                  CGXn_CMR1_CONFIG     1           2
- *                                  CGXn_CMR2_CONFIG     0           --
- *                                  CGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   1x10GBASE-X/XAUI/DXAUI  1      CGXn_CMR0_CONFIG     1           1
- *                                  CGXn_CMR1_CONFIG     0           --
- *                                  CGXn_CMR2_CONFIG     0           --
- *                                  CGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   4xSGMII/1000BASE-X      4      CGXn_CMR0_CONFIG     1           0
- *                                  CGXn_CMR1_CONFIG     1           0
- *                                  CGXn_CMR2_CONFIG     1           0
- *                                  CGXn_CMR3_CONFIG     1           0
- *   ---------------------------------------------------------------------------
- * \</pre\>
+ * CGX CMR Configuration Registers Logical MAC/PCS configuration
+ * registers; one per LMAC. The maximum number of LMACs (and maximum LMAC
+ * ID) that can be enabled by these registers is limited by
+ * CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS].  Internal:
+ * \<pre\> Example configurations:   ------------------------------------
+ * ---------------------------------------   Configuration
+ * LMACS  Register             [ENABLE]    [LMAC_TYPE]   ----------------
+ * -----------------------------------------------------------
+ * 1x50G+1x25G+1xSGMII     4      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------   USXGMII
+ * 1-4    CGXn_CMR0_CONFIG     1           a
+ * CGXn_CMR1_CONFIG     1           a
+ * CGXn_CMR2_CONFIG     1           a
+ * CGXn_CMR3_CONFIG     1           a   ---------------------------------
+ * ------------------------------------------   1x100GBASE-R4           1
+ * CGXn_CMR0_CONFIG     1           9
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   2x50GBASE-R2
+ * 2      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     1           8
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x25GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           7
+ * CGXn_CMR1_CONFIG     1           7
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           7   ---------------------------------
+ * ------------------------------------------   QSGMII                  4
+ * CGXn_CMR0_CONFIG     1           6
+ * CGXn_CMR1_CONFIG     1           6
+ * CGXn_CMR2_CONFIG     1           6
+ * CGXn_CMR3_CONFIG     1           6   ---------------------------------
+ * ------------------------------------------   1x40GBASE-R4            1
+ * CGXn_CMR0_CONFIG     1           4
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x10GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           3
+ * CGXn_CMR1_CONFIG     1           3
+ * CGXn_CMR2_CONFIG     1           3
+ * CGXn_CMR3_CONFIG     1           3   ---------------------------------
+ * ------------------------------------------   2xRXAUI                 2
+ * CGXn_CMR0_CONFIG     1           2
+ * CGXn_CMR1_CONFIG     1           2
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   1x10GBASE-X/XAUI/DXAUI
+ * 1      CGXn_CMR0_CONFIG     1           1
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4xSGMII/1000BASE-X
+ * 4      CGXn_CMR0_CONFIG     1           0
+ * CGXn_CMR1_CONFIG     1           0
+ * CGXn_CMR2_CONFIG     1           0
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------ \</pre\>
  */
 union cavm_cgxx_cmrx_config {
 	u64 u;
@@ -483,8 +440,8 @@ static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_int_ena_w1c
  *
- * CGX CMR Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * CGX CMR Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
  */
 union cavm_cgxx_cmrx_int_ena_w1c {
 	u64 u;
@@ -511,8 +468,8 @@ static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_int_ena_w1s
  *
- * CGX CMR Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * CGX CMR Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_cgxx_cmrx_int_ena_w1s {
 	u64 u;
@@ -539,8 +496,7 @@ static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_int_w1s
  *
- * CGX CMR Interrupt Set Register
- * This register sets interrupt bits.
+ * CGX CMR Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_cgxx_cmrx_int_w1s {
 	u64 u;
@@ -588,8 +544,7 @@ static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_prt_cbfc_ctl
  *
- * CGX CMR LMAC PFC Control Registers
- * See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
+ * CGX CMR LMAC PFC Control Registers See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
  */
 union cavm_cgxx_cmrx_prt_cbfc_ctl {
 	u64 u;
@@ -695,40 +650,26 @@ static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_dmac_ctl0
  *
- * CGX CMR Receive DMAC Address-Control0 Register
- * DMAC CAM control register for use by X2P/NIX bound traffic.
- * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
- * ACCEPT and STEERING0 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM0
- * and CGX()_CMR_RX_STEERING0().
- *
- * Internal:
- * "* ALGORITHM
- * Here is some pseudo code that represents the address filter behavior.
- * \<pre\>
- * dmac_addr_filter(uint8 prt, uint48 dmac) {
- * for (lmac=0, lmac\<4, lmac++) {
- *   if (is_bcst(dmac))                               // broadcast accept
- *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[BCST_ACCEPT] ? ACCEPT : REJECT);
- *   if (is_mcst(dmac) && CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 0)   // multicast reject
- *     return REJECT;
- *   if (is_mcst(dmac) && CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 1)   // multicast accept
- *     return ACCEPT;
- *   else        // DMAC CAM filter
- *     cam_hit = 0;
- *   for (i=0; i\<32; i++) {
- *     cam = CGX()_CMR_RX_DMAC(i)_CAM0;
- *     if (cam[EN] && cam[ID] == lmac && cam[ADR] == dmac) {
- *       cam_hit = 1;
- *       break;
- *     }
- *   }
- *   if (cam_hit) {
- *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? ACCEPT : REJECT);
- *   else
- *     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
- *   }
- * }
- * \</pre\>"
+ * CGX CMR Receive DMAC Address-Control0 Register DMAC CAM control
+ * register for use by X2P/NIX bound traffic. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM0 and
+ * CGX()_CMR_RX_STEERING0().  Internal: "* ALGORITHM Here is some pseudo
+ * code that represents the address filter behavior. \<pre\>
+ * dmac_addr_filter(uint8 prt, uint48 dmac) { for (lmac=0, lmac\<4,
+ * lmac++) {   if (is_bcst(dmac))                               //
+ * broadcast accept     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[BCST_ACCEPT]
+ * ? ACCEPT : REJECT);   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 0)   // multicast reject
+ * return REJECT;   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 1)   // multicast accept
+ * return ACCEPT;   else        // DMAC CAM filter     cam_hit = 0;   for
+ * (i=0; i\<32; i++) {     cam = CGX()_CMR_RX_DMAC(i)_CAM0;     if
+ * (cam[EN] && cam[ID] == lmac && cam[ADR] == dmac) {       cam_hit = 1;
+ * break;     }   }   if (cam_hit) {     return
+ * (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? ACCEPT : REJECT);   else
+ * return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
+ * } } \</pre\>"
  */
 union cavm_cgxx_cmrx_rx_dmac_ctl0 {
 	u64 u;
@@ -751,15 +692,13 @@ static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_dmac_ctl1
  *
- * CGX CMR Receive DMAC Address-Control1 Register
- * DMAC CAM control register for use by NCSI bound traffic.
- * Received packets are only passed to NCSI when the DMAC1 filter result is ACCEPT and
- * STEERING1 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
- * CGX()_CMR_RX_STEERING1().
- * For use with the LMAC associated with NCSI; see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
- *
- * Internal:
- * ALGORITHM: See CGX()_CMR()_RX_DMAC_CTL0.
+ * CGX CMR Receive DMAC Address-Control1 Register DMAC CAM control
+ * register for use by NCSI bound traffic. Received packets are only
+ * passed to NCSI when the DMAC1 filter result is ACCEPT and STEERING1
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI;
+ * see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR()_RX_DMAC_CTL0.
  */
 union cavm_cgxx_cmrx_rx_dmac_ctl1 {
 	u64 u;
@@ -806,8 +745,8 @@ static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_id_map
  *
- * CGX CMR Receive ID Map Register
- * These registers set the RX LMAC ID mapping for X2P/NIX.
+ * CGX CMR Receive ID Map Register These registers set the RX LMAC ID
+ * mapping for X2P/NIX.
  */
 union cavm_cgxx_cmrx_rx_id_map {
 	u64 u;
@@ -999,28 +938,16 @@ static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat0
  *
- * CGX Receive Status Register 0
- * These registers provide a count of received packets that meet the following conditions:
- * * are not recognized as ERROR packets(any OPCODE).
- * * are not recognized as PAUSE packets.
- * * are not dropped due FIFO full status.
- * * are not dropped due DMAC0 or STEERING0 filtering.
- *
- * Internal:
- * "This pseudo code represents the RX STAT0 through STAT8 accounting:
- * \<pre\>
- * If (errored)
- *   incr RX_STAT8
- * else if (ctrl packet, i.e. Pause/PFC)
- *   incr RX_STAT2,3
- * else if (fifo full drop)
- *   incr RX_STAT6,7
- * else if (DMAC0/VLAN0 filter drop)
- *   incr RX_STAT4,5 if not a filter+decision
- * else
- *   incr RX_STAT0,1
- * end
- * \</pre\>"
+ * CGX Receive Status Register 0 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are not dropped due
+ * DMAC0 or STEERING0 filtering.  Internal: "This pseudo code represents
+ * the RX STAT0 through STAT8 accounting: \<pre\> If (errored)   incr
+ * RX_STAT8 else if (ctrl packet, i.e. Pause/PFC)   incr RX_STAT2,3 else
+ * if (fifo full drop)   incr RX_STAT6,7 else if (DMAC0/VLAN0 filter
+ * drop)   incr RX_STAT4,5 if not a filter+decision else   incr
+ * RX_STAT0,1 end \</pre\>"
  */
 union cavm_cgxx_cmrx_rx_stat0 {
 	u64 u;
@@ -1041,8 +968,8 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat1
  *
- * CGX Receive Status Register 1
- * These registers provide a count of octets of received packets.
+ * CGX Receive Status Register 1 These registers provide a count of
+ * octets of received packets.
  */
 union cavm_cgxx_cmrx_rx_stat1 {
 	u64 u;
@@ -1063,12 +990,11 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat2
  *
- * CGX Receive Status Register 2
- * These registers provide a count of received packets that meet the following conditions:
- * * are not recognized as ERROR packets(any OPCODE).
- * * are recognized as PAUSE packets.
- *
- * Pause packets can be optionally dropped or forwarded based on
+ * CGX Receive Status Register 2 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are recognized as PAUSE
+ * packets.  Pause packets can be optionally dropped or forwarded based
+ * on
  * CGX()_SMU()_RX_FRM_CTL[CTL_DRP]/CGX()_GMP_GMI_RX()_FRM_CTL[CTL_DRP].
  * This count increments regardless of whether the packet is dropped.
  */
@@ -1091,8 +1017,8 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat3
  *
- * CGX Receive Status Register 3
- * These registers provide a count of octets of received PAUSE and control packets.
+ * CGX Receive Status Register 3 These registers provide a count of
+ * octets of received PAUSE and control packets.
  */
 union cavm_cgxx_cmrx_rx_stat3 {
 	u64 u;
@@ -1113,18 +1039,16 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat4
  *
- * CGX Receive Status Register 4
- * These registers provide a count of received packets that meet the following conditions:
- * * are not recognized as ERROR packets(any OPCODE).
- * * are not recognized as PAUSE packets.
- * * are not dropped due FIFO full status.
- * * are dropped due DMAC0 or STEERING0 filtering.
- *
- * 16B packets or smaller (20B in case of FCS strip) as the result of truncation
- * or other means are not dropped by CGX (unless filter and decision is also
- * asserted) and will never appear in this count.
- * Should the MAC signal to the CMR that the packet be filtered upon decision before the end of
- * packet, then STAT4 and STAT5 will not be updated.
+ * CGX Receive Status Register 4 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are dropped due
+ * DMAC0 or STEERING0 filtering.  16B packets or smaller (20B in case of
+ * FCS strip) as the result of truncation or other means are not dropped
+ * by CGX (unless filter and decision is also asserted) and will never
+ * appear in this count. Should the MAC signal to the CMR that the packet
+ * be filtered upon decision before the end of packet, then STAT4 and
+ * STAT5 will not be updated.
  */
 union cavm_cgxx_cmrx_rx_stat4 {
 	u64 u;
@@ -1145,8 +1069,8 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat5
  *
- * CGX Receive Status Register 5
- * These registers provide a count of octets of filtered DMAC0 or VLAN STEERING0 packets.
+ * CGX Receive Status Register 5 These registers provide a count of
+ * octets of filtered DMAC0 or VLAN STEERING0 packets.
  */
 union cavm_cgxx_cmrx_rx_stat5 {
 	u64 u;
@@ -1167,15 +1091,14 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat6
  *
- * CGX Receive Status Register 6
- * These registers provide a count of received packets that meet the following conditions:
- * * are not recognized as ERROR packets(any OPCODE).
- * * are not recognized as PAUSE packets.
- * * are dropped due FIFO full status.
- *
- * They do not count any packet that is truncated at the point of overflow and sent
- * on to the NIX. The truncated packet will be marked with error and increment STAT8.
- * These registers count all entire packets dropped by the FIFO for a given LMAC.
+ * CGX Receive Status Register 6 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are dropped due FIFO full status.  They do not count any
+ * packet that is truncated at the point of overflow and sent on to the
+ * NIX. The truncated packet will be marked with error and increment
+ * STAT8. These registers count all entire packets dropped by the FIFO
+ * for a given LMAC.
  */
 union cavm_cgxx_cmrx_rx_stat6 {
 	u64 u;
@@ -1196,9 +1119,9 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat7
  *
- * CGX Receive Status Register 7
- * These registers provide a count of octets of received packets that were dropped due to a full
- * receive FIFO.
+ * CGX Receive Status Register 7 These registers provide a count of
+ * octets of received packets that were dropped due to a full receive
+ * FIFO.
  */
 union cavm_cgxx_cmrx_rx_stat7 {
 	u64 u;
@@ -1219,9 +1142,9 @@ static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
 /**
  * Register (RSL) cgx#_cmr#_rx_stat8
  *
- * CGX Receive Status Register 8
- * These registers provide a count of received packets that meet the following conditions:
- *  * are recognized as ERROR packets(any OPCODE).
+ * CGX Receive Status Register 8 These registers provide a count of
+ * received packets that meet the following conditions:  * are recognized
+ * as ERROR packets(any OPCODE).
  */
 union cavm_cgxx_cmrx_rx_stat8 {
 	u64 u;
@@ -1873,8 +1796,8 @@ static inline u64 CAVM_CGXX_CMR_ECO(void)
 /**
  * Register (RSL) cgx#_cmr_global_config
  *
- * CGX CMR Global Configuration Register
- * These registers configure the global CMR, PCS, and MAC.
+ * CGX CMR Global Configuration Register These registers configure the
+ * global CMR, PCS, and MAC.
  */
 union cavm_cgxx_cmr_global_config {
 	u64 u;
@@ -1926,8 +1849,8 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
 /**
  * Register (RSL) cgx#_cmr_mem_int_ena_w1c
  *
- * CGX CMR Memory Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * CGX CMR Memory Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_cmr_mem_int_ena_w1c {
 	u64 u;
@@ -1949,8 +1872,8 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
 /**
  * Register (RSL) cgx#_cmr_mem_int_ena_w1s
  *
- * CGX CMR Memory Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * CGX CMR Memory Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_cmr_mem_int_ena_w1s {
 	u64 u;
@@ -1972,8 +1895,8 @@ static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
 /**
  * Register (RSL) cgx#_cmr_mem_int_w1s
  *
- * CGX CMR Memory Interrupt Set Register
- * This register sets interrupt bits.
+ * CGX CMR Memory Interrupt Set Register This register sets interrupt
+ * bits.
  */
 union cavm_cgxx_cmr_mem_int_w1s {
 	u64 u;
@@ -2085,9 +2008,8 @@ static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
 /**
  * Register (RSL) cgx#_cmr_rx_dmac#_cam0
  *
- * CGX CMR Receive CAM Registers
- * These registers provide access to the 32 DMAC CAM0 entries in CGX,
- * for use by X2P/NIX bound traffic.
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM0 entries in CGX, for use by X2P/NIX bound traffic.
  */
 union cavm_cgxx_cmr_rx_dmacx_cam0 {
 	u64 u;
@@ -2110,10 +2032,10 @@ static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
 /**
  * Register (RSL) cgx#_cmr_rx_dmac#_cam1
  *
- * CGX CMR Receive CAM Registers
- * These registers provide access to the 32 DMAC CAM entries in CGX for use by NCSI bound
- * traffic. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and
- * CGX()_CMR_RX_STEERING1() registers.
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM entries in CGX for use by NCSI bound traffic. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and CGX()_CMR_RX_STEERING1()
+ * registers.
  */
 union cavm_cgxx_cmr_rx_dmacx_cam1 {
 	u64 u;
@@ -2157,14 +2079,16 @@ static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
 /**
  * Register (RSL) cgx#_cmr_rx_ovr_bp
  *
- * CGX CMR Receive-Ports Backpressure Override Registers
- * Per-LMAC backpressure override register.
- * For SMU, CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set to one and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be
- * cleared to zero (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with
- * the HiGig2 Protocol when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is
- * indicated by CGX()_SMU()_TX_CTL[HG_EN]=1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16).
- * Hardware can only auto-generate backpressure through HiGig2 messages (optionally, when
- * CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2 protocol.
+ * CGX CMR Receive-Ports Backpressure Override Registers Per-LMAC
+ * backpressure override register. For SMU, CGX()_CMR_RX_OVR_BP[EN]\<0\>
+ * must be set to one and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to
+ * zero (to forcibly disable hardware-automatic 802.3 PAUSE packet
+ * generation) with the HiGig2 Protocol when
+ * CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is indicated
+ * by CGX()_SMU()_TX_CTL[HG_EN]=1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16).
+ * Hardware can only auto-generate backpressure through HiGig2 messages
+ * (optionally, when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2
+ * protocol.
  */
 union cavm_cgxx_cmr_rx_ovr_bp {
 	u64 u;
@@ -2187,8 +2111,8 @@ static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
 /**
  * Register (RSL) cgx#_cmr_rx_stat10
  *
- * CGX Receive Status Register 10
- * These registers provide a count of octets of filtered DMAC1 or VLAN STEERING1 packets.
+ * CGX Receive Status Register 10 These registers provide a count of
+ * octets of filtered DMAC1 or VLAN STEERING1 packets.
  */
 union cavm_cgxx_cmr_rx_stat10 {
 	u64 u;
@@ -2209,10 +2133,10 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
 /**
  * Register (RSL) cgx#_cmr_rx_stat11
  *
- * CGX Receive Status Register 11
- * This registers provides a count of packets dropped at the NCSI interface. This
- * includes drops due to CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_DROP] or NCSI FIFO full.
- * The count of dropped NCSI packets is not accounted for in any other stats
+ * CGX Receive Status Register 11 This registers provides a count of
+ * packets dropped at the NCSI interface. This includes drops due to
+ * CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_DROP] or NCSI FIFO full. The count of
+ * dropped NCSI packets is not accounted for in any other stats
  * registers.
  */
 union cavm_cgxx_cmr_rx_stat11 {
@@ -2234,8 +2158,8 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
 /**
  * Register (RSL) cgx#_cmr_rx_stat12
  *
- * CGX Receive Status Register 12
- * This register provide a count of octets of dropped at the NCSI interface.
+ * CGX Receive Status Register 12 This register provide a count of octets
+ * of dropped at the NCSI interface.
  */
 union cavm_cgxx_cmr_rx_stat12 {
 	u64 u;
@@ -2256,17 +2180,16 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
 /**
  * Register (RSL) cgx#_cmr_rx_stat9
  *
- * CGX Receive Status Register 9
- * These registers provide a count of all received packets that were dropped by the DMAC1 or VLAN
- * STEERING1 filter.
- * Packets that are dropped by the DMAC1 or VLAN STEERING1 filters are counted here
- * regardless of whether they were ERR packets, but does not include those reported in
- * CGX()_CMR()_RX_STAT6.
- * 16B packets or smaller (20B in case of FCS strip) as the result of truncation
- * or other means are not dropped by CGX (unless filter and decision is also
- * asserted) and will never appear in this count.
- * Should the MAC signal to the CMR that the packet be filtered upon decision before the end of
- * packet, then STAT9 and STAT10 will not be updated.
+ * CGX Receive Status Register 9 These registers provide a count of all
+ * received packets that were dropped by the DMAC1 or VLAN STEERING1
+ * filter. Packets that are dropped by the DMAC1 or VLAN STEERING1
+ * filters are counted here regardless of whether they were ERR packets,
+ * but does not include those reported in CGX()_CMR()_RX_STAT6. 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation or other means are not dropped by CGX (unless filter and
+ * decision is also asserted) and will never appear in this count. Should
+ * the MAC signal to the CMR that the packet be filtered upon decision
+ * before the end of packet, then STAT9 and STAT10 will not be updated.
  */
 union cavm_cgxx_cmr_rx_stat9 {
 	u64 u;
@@ -2287,35 +2210,24 @@ static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
 /**
  * Register (RSL) cgx#_cmr_rx_steering0#
  *
- * CGX CMR Receive Steering0 Registers
- * These registers, along with CGX()_CMR_RX_STEERING_VETYPE0(), provide eight filters for
- * identifying and steering receive traffic to X2P/NIX.
- * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
- * ACCEPT and STEERING0 filter result is PASS. See also
- * CGX()_CMR()_RX_DMAC_CTL0.
- *
- * Internal:
- * "* ALGORITHM
- * \<pre\>
- * rx_steering(uint48 pkt_dmac, uint16 pkt_etype, uint16 pkt_vlan_id) {
- *    for (int i = 0; i \< 8; i++) {
- *       steer = CGX()_CMR_RX_STEERING0(i);
- *       vetype = CGX()_CMR_RX_STEERING_VETYPE0(i);
- *       if (steer[MCST_EN] || steer[DMAC_EN] || vetype[VLAN_EN] || vetype[VLAN_TAG_EN]) {
- *          // Filter is enabled.
- *          if (   (!steer[MCST_EN] || is_mcst(pkt_dmac))
- *              && (!steer[DMAC_EN] || pkt_dmac == steer[DMAC])
- *              && (!vetype[VLAN_EN] || pkt_vlan_id == vetype[VLAN_ID])
- *              && (!vetype[VLAN_TAG_EN] || pkt_etype == vetype[VLAN_ETYPE]) )
- *          {
- *             // Filter match (all enabled matching criteria are met).
- *             return steer[PASS];
- *          }
- *       }
- *    }
- *    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No match
- * }
- * \</pre\>"
+ * CGX CMR Receive Steering0 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE0(), provide eight filters for identifying
+ * and steering receive traffic to X2P/NIX. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR()_RX_DMAC_CTL0.  Internal:
+ * "* ALGORITHM \<pre\> rx_steering(uint48 pkt_dmac, uint16 pkt_etype,
+ * uint16 pkt_vlan_id) {    for (int i = 0; i \< 8; i++) {       steer =
+ * CGX()_CMR_RX_STEERING0(i);       vetype =
+ * CGX()_CMR_RX_STEERING_VETYPE0(i);       if (steer[MCST_EN] ||
+ * steer[DMAC_EN] || vetype[VLAN_EN] || vetype[VLAN_TAG_EN]) {
+ * // Filter is enabled.          if (   (!steer[MCST_EN] ||
+ * is_mcst(pkt_dmac))              && (!steer[DMAC_EN] || pkt_dmac ==
+ * steer[DMAC])              && (!vetype[VLAN_EN] || pkt_vlan_id ==
+ * vetype[VLAN_ID])              && (!vetype[VLAN_TAG_EN] || pkt_etype ==
+ * vetype[VLAN_ETYPE]) )          {             // Filter match (all
+ * enabled matching criteria are met).             return steer[PASS];
+ * }       }    }    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No
+ * match } \</pre\>"
  */
 union cavm_cgxx_cmr_rx_steering0x {
 	u64 u;
@@ -2339,16 +2251,14 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
 /**
  * Register (RSL) cgx#_cmr_rx_steering1#
  *
- * CGX CMR Receive Steering1 Registers
- * These registers, along with CGX()_CMR_RX_STEERING_VETYPE1(), provide eight filters for
- * identifying and steering NCSI receive traffic.
- * Received packets are only passed to NCSI when the DMAC1 filter result is ACCEPT and
- * STEERING1 filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
- * CGX()_CMR_RX_STEERING1().
- * For use with the LMAC associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
- *
- * Internal:
- * ALGORITHM: See CGX()_CMR_RX_STEERING0().
+ * CGX CMR Receive Steering1 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE1(), provide eight filters for identifying
+ * and steering NCSI receive traffic. Received packets are only passed to
+ * NCSI when the DMAC1 filter result is ACCEPT and STEERING1 filter
+ * result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI.
+ * See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR_RX_STEERING0().
  */
 union cavm_cgxx_cmr_rx_steering1x {
 	u64 u;
@@ -2372,11 +2282,12 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
 /**
  * Register (RSL) cgx#_cmr_rx_steering_default0
  *
- * CGX CMR Receive Steering Default0 Destination Register
- * For determining destination of traffic that does not meet matching algorithm
- * described in registers CGX()_CMR_RX_STEERING0() and CGX()_CMR_RX_STEERING_VETYPE0().
- * All 16B packets or smaller (20B in case of FCS strip) as the result of truncation will steer
- * to default destination
+ * CGX CMR Receive Steering Default0 Destination Register For determining
+ * destination of traffic that does not meet matching algorithm described
+ * in registers CGX()_CMR_RX_STEERING0() and
+ * CGX()_CMR_RX_STEERING_VETYPE0(). All 16B packets or smaller (20B in
+ * case of FCS strip) as the result of truncation will steer to default
+ * destination
  */
 union cavm_cgxx_cmr_rx_steering_default0 {
 	u64 u;
@@ -2397,12 +2308,13 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
 /**
  * Register (RSL) cgx#_cmr_rx_steering_default1
  *
- * CGX CMR Receive Steering Default1 Destination Register
- * For use with the lmac_id associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
- * For determining destination of traffic that does not meet matching algorithm
- * described in registers CGX()_CMR_RX_STEERING1() and CGX()_CMR_RX_STEERING_VETYPE1().
- * All 16B packets or smaller (20B in case of FCS strip) as the result of truncation will steer
- * to default destination
+ * CGX CMR Receive Steering Default1 Destination Register For use with
+ * the lmac_id associated with NCSI. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. For determining destination of
+ * traffic that does not meet matching algorithm described in registers
+ * CGX()_CMR_RX_STEERING1() and CGX()_CMR_RX_STEERING_VETYPE1(). All 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation will steer to default destination
  */
 union cavm_cgxx_cmr_rx_steering_default1 {
 	u64 u;
@@ -2423,9 +2335,9 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
 /**
  * Register (RSL) cgx#_cmr_rx_steering_vetype0#
  *
- * CGX CMR Receive VLAN Ethertype1 Register
- * These registers, along with CGX()_CMR_RX_STEERING0(), provide eight filters for identifying
- * and steering X2P/NIX receive traffic.
+ * CGX CMR Receive VLAN Ethertype1 Register These registers, along with
+ * CGX()_CMR_RX_STEERING0(), provide eight filters for identifying and
+ * steering X2P/NIX receive traffic.
  */
 union cavm_cgxx_cmr_rx_steering_vetype0x {
 	u64 u;
@@ -2449,10 +2361,10 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
 /**
  * Register (RSL) cgx#_cmr_rx_steering_vetype1#
  *
- * CGX CMR Receive VLAN Ethertype1 Register
- * For use with the lmac_id associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].
- * These registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters for identifying
- * and steering NCSI receive traffic.
+ * CGX CMR Receive VLAN Ethertype1 Register For use with the lmac_id
+ * associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. These
+ * registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters
+ * for identifying and steering NCSI receive traffic.
  */
 union cavm_cgxx_cmr_rx_steering_vetype1x {
 	u64 u;
@@ -2476,8 +2388,8 @@ static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
 /**
  * Register (RSL) cgx#_cmr_tx_lmacs
  *
- * CGX CMR Transmit Logical MACs Registers
- * This register sets the number of LMACs allowed on the TX interface. The value is important for
+ * CGX CMR Transmit Logical MACs Registers This register sets the number
+ * of LMACs allowed on the TX interface. The value is important for
  * defining the partitioning of the transmit FIFO.
  */
 union cavm_cgxx_cmr_tx_lmacs {
@@ -2519,8 +2431,8 @@ static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
 /**
  * Register (RSL) cgx#_const
  *
- * CGX CONST Registers
- * This register contains constants for software discovery.
+ * CGX CONST Registers This register contains constants for software
+ * discovery.
  */
 union cavm_cgxx_const {
 	u64 u;
@@ -2543,8 +2455,8 @@ static inline u64 CAVM_CGXX_CONST(void)
 /**
  * Register (RSL) cgx#_const1
  *
- * CGX CONST1 Registers
- * This register contains constants for software discovery.
+ * CGX CONST1 Registers This register contains constants for software
+ * discovery.
  */
 union cavm_cgxx_const1 {
 	u64 u;
@@ -2608,12 +2520,10 @@ static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi#_tx_eee
  *
- * INTERNAL: CGX GMP GMI TX EEE Configure Registers
- *
- * Reserved.
- * Internal:
- * These registers control when GMP GMI TX requests to enter or exist LPI. Those
- * registers take effect only when EEE is supported and enabled for a given LMAC.
+ * INTERNAL: CGX GMP GMI TX EEE Configure Registers  Reserved. Internal:
+ * These registers control when GMP GMI TX requests to enter or exist
+ * LPI. Those registers take effect only when EEE is supported and
+ * enabled for a given LMAC.
  */
 union cavm_cgxx_gmp_gmix_tx_eee {
 	u64 u;
@@ -2643,10 +2553,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
  * Register (RSL) cgx#_gmp_gmi#_tx_eee_cfg1
  *
  * INTERNAL: CGX GMP GMI TX EEE Configure More Configuration Registers
- *
- * Reserved.
- * Internal:
- * Controls the GMP exiting of LPI and starting to send data.
+ * Reserved. Internal: Controls the GMP exiting of LPI and starting to
+ * send data.
  */
 union cavm_cgxx_gmp_gmix_tx_eee_cfg1 {
 	u64 u;
@@ -2679,8 +2587,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi#_wol_int
  *
- * CGX GMP GMI RX WOL Interrupt Registers
- * These registers allow WOL interrupts to be sent to the control processor.
+ * CGX GMP GMI RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
  */
 union cavm_cgxx_gmp_gmix_wol_int {
 	u64 u;
@@ -2701,8 +2609,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1c
  *
- * CGX GMP GMI RX WOL Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX GMP GMI RX WOL Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
  */
 union cavm_cgxx_gmp_gmix_wol_int_ena_w1c {
 	u64 u;
@@ -2723,8 +2631,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1s
  *
- * CGX GMP GMI RX WOL Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX GMP GMI RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_gmix_wol_int_ena_w1s {
 	u64 u;
@@ -2745,8 +2653,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi#_wol_int_w1s
  *
- * CGX GMP GMI RX WOL Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX GMP GMI RX WOL Interrupt Set Registers This register sets
+ * interrupt bits.
  */
 union cavm_cgxx_gmp_gmix_wol_int_w1s {
 	u64 u;
@@ -2767,8 +2675,8 @@ static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_prt#_cfg
  *
- * CGX GMP GMI LMAC Configuration Registers
- * This register controls the configuration of the LMAC.
+ * CGX GMP GMI LMAC Configuration Registers This register controls the
+ * configuration of the LMAC.
  */
 union cavm_cgxx_gmp_gmi_prtx_cfg {
 	u64 u;
@@ -2797,33 +2705,27 @@ static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_decision
  *
- * CGX GMP Packet-Decision Registers
- * This register specifies the byte count used to determine when to accept or to filter a packet.
- * As each byte in a packet is received by GMI, the L2 byte count is compared against
- * [CNT]. In normal operation, the L2 header begins after the
- * PREAMBLE + SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
- * data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
- *
- * Internal:
- * Notes:
- * As each byte in a packet is received by GMI, the L2 byte count is compared
- * against the [CNT].  The L2 byte count is the number of bytes
- * from the beginning of the L2 header (DMAC).  In normal operation, the L2
- * header begins after the PREAMBLE+SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any
- * optional UDD skip data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
- * When CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the
- * packet and would require UDD skip length to account for them.
- *
- * Full Duplex:
- * _   L2 Size \<  [CNT] - Accept packet. No filtering is applied.
- * _   L2 Size \>= [CNT] - Apply filter. Accept packet based on PAUSE packet filter.
- *
- * Half Duplex:
- * _   L2 Size \<  [CNT] - Drop packet. Packet is unconditionally dropped.
- * _   L2 Size \>= [CNT] - Accept packet.
- *
- * where L2_size = MAX(0, total_packet_size - CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
- *                        ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
+ * CGX GMP Packet-Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by GMI, the L2 byte count is compared
+ * against [CNT]. In normal operation, the L2 header begins after the
+ * PREAMBLE + SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).  Internal:
+ * Notes: As each byte in a packet is received by GMI, the L2 byte count
+ * is compared against the [CNT].  The L2 byte count is the number of
+ * bytes from the beginning of the L2 header (DMAC).  In normal
+ * operation, the L2 header begins after the PREAMBLE+SFD
+ * (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any optional UDD skip data
+ * (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]). When
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are
+ * prepended to the packet and would require UDD skip length to account
+ * for them.  Full Duplex: _   L2 Size \<  [CNT] - Accept packet. No
+ * filtering is applied. _   L2 Size \>= [CNT] - Apply filter. Accept
+ * packet based on PAUSE packet filter.  Half Duplex: _   L2 Size \<
+ * [CNT] - Drop packet. Packet is unconditionally dropped. _   L2 Size
+ * \>= [CNT] - Accept packet.  where L2_size = MAX(0, total_packet_size -
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
+ * ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
  */
 union cavm_cgxx_gmp_gmi_rxx_decision {
 	u64 u;
@@ -2872,30 +2774,23 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_frm_ctl
  *
- * CGX GMP Frame Control Registers
- * This register controls the handling of the frames.
- * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
- * most
- * common modes of operation:
- * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything.
- * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames.
- * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored.
- *
- * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
- * PAUSE
- * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
- * which should be handled by the processing cores. PAUSE packets should not be forwarded.
- *
- * Internal:
- * Notes:
- * [PRE_STRP]:
- * When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP]
- * determines if the PREAMBLE+SFD bytes are thrown away or sent to the Octane
- * core as part of the packet.
- * In either mode, the PREAMBLE+SFD bytes are not counted toward the packet
- * size when checking against the MIN and MAX bounds.  Furthermore, the bytes
- * are skipped when locating the start of the L2 header for DMAC and Control
- * frame recognition.
+ * CGX GMP Frame Control Registers This register controls the handling of
+ * the frames. The [CTL_BCK] and [CTL_DRP] bits control how the hardware
+ * handles incoming PAUSE packets. The most common modes of operation: _
+ * [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything. _ [CTL_BCK]
+ * = 0, [CTL_DRP] = 0: software sees all PAUSE frames. _ [CTL_BCK] = 0,
+ * [CTL_DRP] = 1: all PAUSE frames are completely ignored.  These control
+ * bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex
+ * mode. Since PAUSE packets only apply to full duplex operation, any
+ * PAUSE packet would constitute an exception which should be handled by
+ * the processing cores. PAUSE packets should not be forwarded.
+ * Internal: Notes: [PRE_STRP]: When [PRE_CHK] is set (indicating that
+ * the PREAMBLE will be sent), [PRE_STRP] determines if the PREAMBLE+SFD
+ * bytes are thrown away or sent to the Octane core as part of the
+ * packet. In either mode, the PREAMBLE+SFD bytes are not counted toward
+ * the packet size when checking against the MIN and MAX bounds.
+ * Furthermore, the bytes are skipped when locating the start of the L2
+ * header for DMAC and Control frame recognition.
  */
 union cavm_cgxx_gmp_gmi_rxx_frm_ctl {
 	u64 u;
@@ -2944,8 +2839,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_ifg
  *
- * CGX GMI Minimum Interframe-Gap Cycles Registers
- * This register specifies the minimum number of interframe-gap (IFG) cycles between packets.
+ * CGX GMI Minimum Interframe-Gap Cycles Registers This register
+ * specifies the minimum number of interframe-gap (IFG) cycles between
+ * packets.
  */
 union cavm_cgxx_gmp_gmi_rxx_ifg {
 	u64 u;
@@ -2966,67 +2862,50 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_int
  *
- * CGX GMP GMI RX Interrupt Registers
- * These registers allow interrupts to be sent to the control processor.
- * * Exception conditions \<10:0\> can also set the rcv/opcode in the received packet's work-queue
- * entry. CGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which conditions
- * set the error.
- * In half duplex operation, the expectation is that collisions will appear as either MINERR or
- * CAREXT errors.
- *
- * Internal:
- * Notes:
- * (1) exception conditions 10:0 can also set the rcv/opcode in the received
- * packet's workQ entry.  The CGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask
- * for configuring which conditions set the error.
- *
- * (2) in half duplex operation, the expectation is that collisions will appear
- * as either MINERR o r CAREXT errors.
- *
- * (3) JABBER An RX jabber error indicates that a packet was received which
- * is longer than the maximum allowed packet as defined by the
- * system.  GMI will truncate the packet at the JABBER count.
- * Failure to do so could lead to system instabilty.
- *
- * (4) NIBERR This error is illegal at 1000Mbs speeds
- * (CGX()_GMP_GMI_PRT()_CFG[SPEED]==0) and will never assert.
- *
- * (5) MINERR total frame DA+SA+TL+DATA+PAD+FCS \< 64
- *
- * (6) ALNERR Indicates that the packet received was not an integer number of
- * bytes.  If FCS checking is enabled, ALNERR will only assert if
- * the FCS is bad.  If FCS checking is disabled, ALNERR will
- * assert in all non-integer frame cases.
- *
- * (7) Collisions Collisions can only occur in half-duplex mode.  A collision
- * is assumed by the receiver when the slottime
+ * CGX GMP GMI RX Interrupt Registers These registers allow interrupts to
+ * be sent to the control processor. * Exception conditions \<10:0\> can
+ * also set the rcv/opcode in the received packet's work-queue entry.
+ * CGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which
+ * conditions set the error. In half duplex operation, the expectation is
+ * that collisions will appear as either MINERR or CAREXT errors.
+ * Internal: Notes: (1) exception conditions 10:0 can also set the
+ * rcv/opcode in the received packet's workQ entry.  The
+ * CGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask for
+ * configuring which conditions set the error.  (2) in half duplex
+ * operation, the expectation is that collisions will appear as either
+ * MINERR o r CAREXT errors.  (3) JABBER An RX jabber error indicates
+ * that a packet was received which is longer than the maximum allowed
+ * packet as defined by the system.  GMI will truncate the packet at the
+ * JABBER count. Failure to do so could lead to system instabilty.  (4)
+ * NIBERR This error is illegal at 1000Mbs speeds
+ * (CGX()_GMP_GMI_PRT()_CFG[SPEED]==0) and will never assert.  (5) MINERR
+ * total frame DA+SA+TL+DATA+PAD+FCS \< 64  (6) ALNERR Indicates that the
+ * packet received was not an integer number of bytes.  If FCS checking
+ * is enabled, ALNERR will only assert if the FCS is bad.  If FCS
+ * checking is disabled, ALNERR will assert in all non-integer frame
+ * cases.  (7) Collisions Collisions can only occur in half-duplex mode.
+ * A collision is assumed by the receiver when the slottime
  * (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
- * this will result in a frame \< SLOTTIME.  In 1000 mode, it
- * could result either in frame \< SLOTTIME or a carrier extend
- * error with the SLOTTIME.  These conditions are visible by...
- * . transfer ended before slottime COLDET
- * . carrier extend error           CAREXT
- *
- * (A) LENERR Length errors occur when the received packet does not match the
- * length field.  LENERR is only checked for packets between 64
- * and 1500 bytes.  For untagged frames, the length must exact
- * match.  For tagged frames the length or length+4 must match.
- *
- * (B) PCTERR checks that the frame begins with a valid PREAMBLE sequence.
- * Does not check the number of PREAMBLE cycles.
- *
- * (C) OVRERR *DON'T PUT IN HRM*
- * OVRERR is an architectural assertion check internal to GMI to
- * make sure no assumption was violated.  In a correctly operating
- * system, this interrupt can never fire.
- * GMI has an internal arbiter which selects which of four ports to
- * buffer in the main RX FIFO.  If we normally buffer eight bytes,
- * then each port will typically push a tick every eight cycles if
- * the packet interface is going as fast as possible.  If there
- * are four ports, they push every two cycles.  So that's the
- * assumption.  That the inbound module will always be able to
- * consume the tick before another is produced.  If that doesn't
- * happen that's when OVRERR will assert."
+ * this will result in a frame \< SLOTTIME.  In 1000 mode, it could
+ * result either in frame \< SLOTTIME or a carrier extend error with the
+ * SLOTTIME.  These conditions are visible by... . transfer ended before
+ * slottime COLDET . carrier extend error           CAREXT  (A) LENERR
+ * Length errors occur when the received packet does not match the length
+ * field.  LENERR is only checked for packets between 64 and 1500 bytes.
+ * For untagged frames, the length must exact match.  For tagged frames
+ * the length or length+4 must match.  (B) PCTERR checks that the frame
+ * begins with a valid PREAMBLE sequence. Does not check the number of
+ * PREAMBLE cycles.  (C) OVRERR *DON'T PUT IN HRM* OVRERR is an
+ * architectural assertion check internal to GMI to make sure no
+ * assumption was violated.  In a correctly operating system, this
+ * interrupt can never fire. GMI has an internal arbiter which selects
+ * which of four ports to buffer in the main RX FIFO.  If we normally
+ * buffer eight bytes, then each port will typically push a tick every
+ * eight cycles if the packet interface is going as fast as possible.  If
+ * there are four ports, they push every two cycles.  So that's the
+ * assumption.  That the inbound module will always be able to consume
+ * the tick before another is produced.  If that doesn't happen that's
+ * when OVRERR will assert."
  */
 union cavm_cgxx_gmp_gmi_rxx_int {
 	u64 u;
@@ -3073,8 +2952,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1c
  *
- * CGX GMP GMI RX Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX GMP GMI RX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_gmi_rxx_int_ena_w1c {
 	u64 u;
@@ -3121,8 +3000,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1s
  *
- * CGX GMP GMI RX Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX GMP GMI RX Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_gmi_rxx_int_ena_w1s {
 	u64 u;
@@ -3169,8 +3048,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_int_w1s
  *
- * CGX GMP GMI RX Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX GMP GMI RX Interrupt Set Registers This register sets interrupt
+ * bits.
  */
 union cavm_cgxx_gmp_gmi_rxx_int_w1s {
 	u64 u;
@@ -3217,8 +3096,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_jabber
  *
- * CGX GMP Maximum Packet-Size Registers
- * This register specifies the maximum size for packets, beyond which the GMI truncates.
+ * CGX GMP Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the GMI truncates.
  */
 union cavm_cgxx_gmp_gmi_rxx_jabber {
 	u64 u;
@@ -3239,33 +3118,23 @@ static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_rx#_udd_skp
  *
- * CGX GMP GMI User-Defined Data Skip Registers
- * This register specifies the amount of user-defined data (UDD) added before the start of the
- * L2C data.
- *
- * Internal:
- * Notes:
- * (1) The skip bytes are part of the packet and will be handled by NIX.
- *
- * (2) The system can determine if the UDD bytes are included in the FCS check
- * by using the FCSSEL field - if the FCS check is enabled.
- *
- * (3) Assume that the preamble/sfd is always at the start of the frame - even
- * before UDD bytes.  In most cases, there will be no preamble in these
- * cases since it will be packet interface in direct communication to
- * another packet interface (MAC to MAC) without a PHY involved.
- *
- * (4) We can still do address filtering and control packet filtering is the
- * user desires.
- *
- * (5) CGX()_GMP_GMI_RX()_UDD_SKP[LEN] must be 0 in half-duplex operation unless
- * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is
- * clear,
- * then CGX()_GMP_GMI_RX()_UDD_SKP[LEN] will normally be 8.
- *
- * (6) In all cases, the UDD bytes will be sent down the packet interface as
- * part of the packet.  The UDD bytes are never stripped from the actual
- * packet.
+ * CGX GMP GMI User-Defined Data Skip Registers This register specifies
+ * the amount of user-defined data (UDD) added before the start of the
+ * L2C data.  Internal: Notes: (1) The skip bytes are part of the packet
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field - if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame - even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering is the user desires.  (5)
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] must be 0 in half-duplex operation
+ * unless CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, then
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] will normally be 8.  (6) In all cases,
+ * the UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
  */
 union cavm_cgxx_gmp_gmi_rxx_udd_skp {
 	u64 u;
@@ -3412,8 +3281,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1c
  *
- * CGX GMI TX Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX GMI TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_gmi_txx_int_ena_w1c {
 	u64 u;
@@ -3447,8 +3316,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1s
  *
- * CGX GMI TX Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX GMI TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
  */
 union cavm_cgxx_gmp_gmi_txx_int_ena_w1s {
 	u64 u;
@@ -3482,8 +3351,7 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx#_int_w1s
  *
- * CGX GMI TX Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX GMI TX Interrupt Set Registers This register sets interrupt bits.
  */
 union cavm_cgxx_gmp_gmi_txx_int_w1s {
 	u64 u;
@@ -3538,27 +3406,21 @@ static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_interval
  *
- * CGX GMI TX PAUSE-Packet Transmission-Interval Registers
- * This register specifies how often PAUSE packets are sent.
- * Internal:
- * Notes:
- * Choosing proper values of CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME] and
- * CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system
- * designer.  It is suggested that TIME be much greater than INTERVAL and
- * CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE
- * count and then when the backpressure condition is lifted, a PAUSE packet
- * with TIME==0 will be sent indicating that Octane is ready for additional
- * data.
- *
- * If the system chooses to not set CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND], then it is
- * suggested that TIME and INTERVAL are programmed such that they satisify the
- * following rule:
- *
- * _ INTERVAL \<= TIME - (largest_pkt_size + IFG + pause_pkt_size)
- *
- * where largest_pkt_size is that largest packet that the system can send
- * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size
- * of the PAUSE packet (normally 64B).
+ * CGX GMI TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent. Internal: Notes: Choosing
+ * proper values of CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME] and
+ * CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to
+ * the system designer.  It is suggested that TIME be much greater than
+ * INTERVAL and CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] be set.  This allows
+ * a periodic refresh of the PAUSE count and then when the backpressure
+ * condition is lifted, a PAUSE packet with TIME==0 will be sent
+ * indicating that Octane is ready for additional data.  If the system
+ * chooses to not set CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND], then it is
+ * suggested that TIME and INTERVAL are programmed such that they
+ * satisify the following rule:  _ INTERVAL \<= TIME - (largest_pkt_size
+ * + IFG + pause_pkt_size)  where largest_pkt_size is that largest packet
+ * that the system can send (normally 1518B), IFG is the interframe gap
+ * and pause_pkt_size is the size of the PAUSE packet (normally 64B).
  */
 union cavm_cgxx_gmp_gmi_txx_pause_pkt_interval {
 	u64 u;
@@ -3747,14 +3609,15 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx_ifg
  *
- * CGX GMI TX Interframe-Gap Cycles Registers
- * Consider the following when programming IFG1 and IFG2:
- * * For 10/100/1000 Mb/s half-duplex systems that require IEEE 802.3 compatibility, IFG1 must be
- * in the range of 1-8, [IFG2] must be in the range of 4-12, and the [IFG1] + [IFG2] sum must be 12.
- * * For 10/100/1000 Mb/s full-duplex systems that require IEEE 802.3 compatibility, IFG1 must be
- * in the range of 1-11, [IFG2] must be in the range of 1-11, and the [IFG1] + [IFG2] sum must be 12.
- * For all other systems, IFG1 and IFG2 can be any value in the range of 1-15, allowing for a
- * total possible IFG sum of 2-30.
+ * CGX GMI TX Interframe-Gap Cycles Registers Consider the following when
+ * programming IFG1 and IFG2: * For 10/100/1000 Mb/s half-duplex systems
+ * that require IEEE 802.3 compatibility, IFG1 must be in the range of
+ * 1-8, [IFG2] must be in the range of 4-12, and the [IFG1] + [IFG2] sum
+ * must be 12. * For 10/100/1000 Mb/s full-duplex systems that require
+ * IEEE 802.3 compatibility, IFG1 must be in the range of 1-11, [IFG2]
+ * must be in the range of 1-11, and the [IFG1] + [IFG2] sum must be 12.
+ * For all other systems, IFG1 and IFG2 can be any value in the range of
+ * 1-15, allowing for a total possible IFG sum of 2-30.
  */
 union cavm_cgxx_gmp_gmi_tx_ifg {
 	u64 u;
@@ -3776,8 +3639,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx_jam
  *
- * CGX GMI TX JAM Pattern Registers
- * This register provides the pattern used in JAM bytes.
+ * CGX GMI TX JAM Pattern Registers This register provides the pattern
+ * used in JAM bytes.
  */
 union cavm_cgxx_gmp_gmi_tx_jam {
 	u64 u;
@@ -3798,9 +3661,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx_lfsr
  *
- * CGX GMI TX LFSR Registers
- * This register shows the contents of the linear feedback shift register (LFSR), which is used
- * to implement truncated binary exponential backoff.
+ * CGX GMI TX LFSR Registers This register shows the contents of the
+ * linear feedback shift register (LFSR), which is used to implement
+ * truncated binary exponential backoff.
  */
 union cavm_cgxx_gmp_gmi_tx_lfsr {
 	u64 u;
@@ -3842,8 +3705,8 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
 /**
  * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_type
  *
- * CGX GMI TX PAUSE-Packet-PTYPE Field Registers
- * This register provides the PTYPE field that is placed in outbound PAUSE packets.
+ * CGX GMI TX PAUSE-Packet-PTYPE Field Registers This register provides
+ * the PTYPE field that is placed in outbound PAUSE packets.
  */
 union cavm_cgxx_gmp_gmi_tx_pause_pkt_type {
 	u64 u;
@@ -3864,12 +3727,9 @@ static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
 /**
  * Register (RSL) cgx#_gmp_misc#_cfg
  *
- * CGX GMP PCS Miscellaneous Control Registers
- * This register contains general configuration that should not need to be changed from reset
- * settings.
- *
- * Internal:
- * Per lmac diagnostic and chicken bits.
+ * CGX GMP PCS Miscellaneous Control Registers This register contains
+ * general configuration that should not need to be changed from reset
+ * settings.  Internal: Per lmac diagnostic and chicken bits.
  */
 union cavm_cgxx_gmp_miscx_cfg {
 	u64 u;
@@ -3905,8 +3765,7 @@ static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs#_an_expansion
  *
- * CGX GMP PCS AN Expansion register Register 6
- * AN status
+ * CGX GMP PCS AN Expansion register Register 6 AN status
  */
 union cavm_cgxx_gmp_pcsx_an_expansion {
 	u64 u;
@@ -3929,9 +3788,10 @@ static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs#_an_lp_abil_np
  *
- * CGX GMP PCS AN Link Partner Ability Next Page Register 8
- * This register contains the advertised ability of the link partners Next Page. The definition
- * for this register is provided in 32.5.4.2 for changes to 28.2.4.1.4.
+ * CGX GMP PCS AN Link Partner Ability Next Page Register 8 This register
+ * contains the advertised ability of the link partners Next Page. The
+ * definition for this register is provided in 32.5.4.2 for changes to
+ * 28.2.4.1.4.
  */
 union cavm_cgxx_gmp_pcsx_an_lp_abil_np {
 	u64 u;
@@ -3957,13 +3817,14 @@ static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs#_an_np_tx
  *
- * CGX GMP PCS AN Next Page Transmit Register 7
- * Software programs this register with the contents of the AN message next page or unformatted
- * next page link code word to be transmitted during autonegotiation. Next page exchange occurs
- * after the base link code words have been exchanged if either end of the link segment sets the
- * NP bit to 1, indicating that it has at least one next page to send. Once initiated, next page
- * exchange continues until both ends of the link segment set their NP bits to 0.
- * Both sides must be NP capable to use NP exchanges.
+ * CGX GMP PCS AN Next Page Transmit Register 7 Software programs this
+ * register with the contents of the AN message next page or unformatted
+ * next page link code word to be transmitted during autonegotiation.
+ * Next page exchange occurs after the base link code words have been
+ * exchanged if either end of the link segment sets the NP bit to 1,
+ * indicating that it has at least one next page to send. Once initiated,
+ * next page exchange continues until both ends of the link segment set
+ * their NP bits to 0. Both sides must be NP capable to use NP exchanges.
  */
 union cavm_cgxx_gmp_pcsx_an_np_tx {
 	u64 u;
@@ -4010,16 +3871,15 @@ static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs#_rx_eee_wake
  *
- * INTERNAL: CGX GMP PCS  RX EEE Wake Error Counter  Registers
- *
- * Reserved.
- * Internal:
- * This register is used by PHY types that support EEE to count wake time faults where
- * the PHY fails to complete its normal wake sequence within the time required for the
- * specific PHY type. The definition of the fault event to be counted is defined for
- * each PHY and may occur during a refresh or a wake-up as defined by the PHY. This
- * 16-bit counter shall be reset to all zeros upon execution of the PCS reset. This
- * counter shall be held at all ones in the case of overflow.
+ * INTERNAL: CGX GMP PCS  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: This register is used by PHY types that support EEE to count
+ * wake time faults where the PHY fails to complete its normal wake
+ * sequence within the time required for the specific PHY type. The
+ * definition of the fault event to be counted is defined for each PHY
+ * and may occur during a refresh or a wake-up as defined by the PHY.
+ * This 16-bit counter shall be reset to all zeros upon execution of the
+ * PCS reset. This counter shall be held at all ones in the case of
+ * overflow.
  */
 union cavm_cgxx_gmp_pcsx_rx_eee_wake {
 	u64 u;
@@ -4041,10 +3901,7 @@ static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
  * Register (RSL) cgx#_gmp_pcs#_rx_lpi_timing
  *
  * INTERNAL: CGX GMP PCS  RX EEE LPI Timing Parameters Registers
- *
- * Reserved.
- * Internal:
- * Receiver LPI timing parameters Tqr, Twr and Twtf.
+ * Reserved. Internal: Receiver LPI timing parameters Tqr, Twr and Twtf.
  */
 union cavm_cgxx_gmp_pcsx_rx_lpi_timing {
 	u64 u;
@@ -4068,8 +3925,7 @@ static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs#_status1
  *
- * CGX GMP PCS Status 1 Register
- * PCS LPI Status, Link OK.  Register 3.1
+ * CGX GMP PCS Status 1 Register PCS LPI Status, Link OK.  Register 3.1
  */
 union cavm_cgxx_gmp_pcsx_status1 {
 	u64 u;
@@ -4097,10 +3953,8 @@ static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
  * Register (RSL) cgx#_gmp_pcs#_tx_lpi_timing
  *
  * INTERNAL: CGX GMP GMI  TX EEE LPI Timing Parameters Registers
- *
- * Reserved.
- * Internal:
- * Transmitter LPI timing parameters Tsl, Tql and Tul.
+ * Reserved. Internal: Transmitter LPI timing parameters Tsl, Tql and
+ * Tul.
  */
 union cavm_cgxx_gmp_pcsx_tx_lpi_timing {
 	u64 u;
@@ -4178,8 +4032,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_an#_lp_abil
  *
- * CGX GMP PCS Autonegotiation Link Partner Ability Registers
- * This is the autonegotiation link partner ability register 5 as per IEEE 802.3, Clause 37.
+ * CGX GMP PCS Autonegotiation Link Partner Ability Registers This is the
+ * autonegotiation link partner ability register 5 as per IEEE 802.3,
+ * Clause 37.
  */
 union cavm_cgxx_gmp_pcs_anx_lp_abil {
 	u64 u;
@@ -4207,10 +4062,11 @@ static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_an#_results
  *
- * CGX GMP PCS Autonegotiation Results Registers
- * This register is not valid when CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
+ * CGX GMP PCS Autonegotiation Results Registers This register is not
+ * valid when CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
  * CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 0 and
- * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is valid.
+ * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is
+ * valid.
  */
 union cavm_cgxx_gmp_pcs_anx_results {
 	u64 u;
@@ -4275,8 +4131,8 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_int#_ena_w1c
  *
- * CGX GMP PCS Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX GMP PCS Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_pcs_intx_ena_w1c {
 	u64 u;
@@ -4316,8 +4172,8 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_int#_ena_w1s
  *
- * CGX GMP PCS Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX GMP PCS Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_gmp_pcs_intx_ena_w1s {
 	u64 u;
@@ -4357,8 +4213,7 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_int#_w1s
  *
- * CGX GMP PCS Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX GMP PCS Interrupt Set Registers This register sets interrupt bits.
  */
 union cavm_cgxx_gmp_pcs_intx_w1s {
 	u64 u;
@@ -4398,8 +4253,8 @@ static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_link#_timer
  *
- * CGX GMP PCS Link Timer Registers
- * This is the 1.6 ms nominal link timer register.
+ * CGX GMP PCS Link Timer Registers This is the 1.6 ms nominal link timer
+ * register.
  */
 union cavm_cgxx_gmp_pcs_linkx_timer {
 	u64 u;
@@ -4420,15 +4275,14 @@ static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_misc#_ctl
  *
- * CGX GMP SGMII Miscellaneous Control Registers
- * Internal:
- * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or
- * 1000Base-X modes.
- *
- * Note: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if
- * [MAC_PHY] is set (1=PHY mode). If the bit is not set (0=MAC mode), the
- * tx_Config_Reg\<14\> becomes ACK bit and tx_Config_Reg\<0\> is always 1.
- * All other bits in tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation results.
+ * CGX GMP SGMII Miscellaneous Control Registers Internal: SGMII bit [12]
+ * is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate
+ * SGMII or 1000Base-X modes.  Note: The SGMII AN Advertisement Register
+ * above will be sent during Auto Negotiation if [MAC_PHY] is set (1=PHY
+ * mode). If the bit is not set (0=MAC mode), the tx_Config_Reg\<14\>
+ * becomes ACK bit and tx_Config_Reg\<0\> is always 1. All other bits in
+ * tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation
+ * results.
  */
 union cavm_cgxx_gmp_pcs_miscx_ctl {
 	u64 u;
@@ -4505,11 +4359,11 @@ static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_mr#_status
  *
- * CGX GMP PCS Status Registers
- * Bits \<15:9\> in this register indicate the ability to operate when
- * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set to MAC mode. Bits \<15:9\> are always read as
- * 0, indicating that the chip cannot operate in the corresponding modes. The field [RM_FLT] is a
- * 'don't care' when the selected mode is SGMII/QSGMII.
+ * CGX GMP PCS Status Registers Bits \<15:9\> in this register indicate
+ * the ability to operate when CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set
+ * to MAC mode. Bits \<15:9\> are always read as 0, indicating that the
+ * chip cannot operate in the corresponding modes. The field [RM_FLT] is
+ * a 'don't care' when the selected mode is SGMII/QSGMII.
  */
 union cavm_cgxx_gmp_pcs_mrx_status {
 	u64 u;
@@ -4593,12 +4447,14 @@ static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_sgm#_an_adv
  *
- * CGX GMP PCS SGMII Autonegotiation Advertisement Registers
- * This is the SGMII autonegotiation advertisement register (sent out as tx_Config_Reg\<15:0\> as
- * defined in IEEE 802.3 clause 37). This register is sent during autonegotiation if
- * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
- * MAC mode), then tx_Config_Reg\<14\> becomes ACK bit and tx_Config_Reg\<0\> is always 1. All other
- * bits in tx_Config_Reg sent will be 0. The PHY dictates the autonegotiation results.
+ * CGX GMP PCS SGMII Autonegotiation Advertisement Registers This is the
+ * SGMII autonegotiation advertisement register (sent out as
+ * tx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37). This
+ * register is sent during autonegotiation if
+ * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is
+ * not set (0 = MAC mode), then tx_Config_Reg\<14\> becomes ACK bit and
+ * tx_Config_Reg\<0\> is always 1. All other bits in tx_Config_Reg sent
+ * will be 0. The PHY dictates the autonegotiation results.
  */
 union cavm_cgxx_gmp_pcs_sgmx_an_adv {
 	u64 u;
@@ -4625,9 +4481,9 @@ static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
 /**
  * Register (RSL) cgx#_gmp_pcs_sgm#_lp_adv
  *
- * CGX GMP PCS SGMII Link-Partner-Advertisement Registers
- * This is the SGMII link partner advertisement register (received as rx_Config_Reg\<15:0\> as
- * defined in IEEE 802.3 clause 37).
+ * CGX GMP PCS SGMII Link-Partner-Advertisement Registers This is the
+ * SGMII link partner advertisement register (received as
+ * rx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37).
  */
 union cavm_cgxx_gmp_pcs_sgmx_lp_adv {
 	u64 u;
@@ -4686,9 +4542,10 @@ static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
  * Register (RSL) cgx#_gmp_pcs_tx_rx#_polarity
  *
  * CGX GMP PCS TX/RX Polarity Registers
- * CGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed on the link
- * receive path after code group synchronization is achieved.  When LMAC_TYPE=QSGMII, only lane 0
- * polarity data and settings are relevant and settings for lanes 1, 2 and 3 are unused.
+ * CGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed
+ * on the link receive path after code group synchronization is achieved.
+ * When LMAC_TYPE=QSGMII, only lane 0 polarity data and settings are
+ * relevant and settings for lanes 1, 2 and 3 are unused.
  */
 union cavm_cgxx_gmp_pcs_tx_rxx_polarity {
 	u64 u;
@@ -4712,9 +4569,8 @@ static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
 /**
  * Register (RSL) cgx#_msix_pba#
  *
- * CGX MSI-X Pending Bit Array Registers
- * This register is the MSI-X PBA table, the bit number is indexed by the CGX_INT_VEC_E
- * enumeration.
+ * CGX MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table, the bit number is indexed by the CGX_INT_VEC_E enumeration.
  */
 union cavm_cgxx_msix_pbax {
 	u64 u;
@@ -4734,8 +4590,8 @@ static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
 /**
  * Register (RSL) cgx#_msix_vec#_addr
  *
- * CGX MSI-X Vector Table Address Registers
- * This register is the MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
+ * CGX MSI-X Vector Table Address Registers This register is the MSI-X
+ * vector table, indexed by the CGX_INT_VEC_E enumeration.
  */
 union cavm_cgxx_msix_vecx_addr {
 	u64 u;
@@ -4758,8 +4614,8 @@ static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
 /**
  * Register (RSL) cgx#_msix_vec#_ctl
  *
- * CGX MSI-X Vector Table Control and Data Registers
- * This register is the MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
+ * CGX MSI-X Vector Table Control and Data Registers This register is the
+ * MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
  */
 union cavm_cgxx_msix_vecx_ctl {
 	u64 u;
@@ -4806,9 +4662,8 @@ static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
 /**
  * Register (RSL) cgx#_smu#_cbfc_ctl
  *
- * CGX SMU PFC Control Registers
- * Internal:
- * INTERNAL: XOFF for a specific class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
+ * CGX SMU PFC Control Registers Internal: INTERNAL: XOFF for a specific
+ * class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
  * ([LOGL_EN]\<i\> & cmr_rx_logl_xoff\<i\>).
  */
 union cavm_cgxx_smux_cbfc_ctl {
@@ -4857,9 +4712,9 @@ static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
 /**
  * Register (RSL) cgx#_smu#_ext_loopback
  *
- * CGX SMU External Loopback Registers
- * In loopback mode, the IFG1+IFG2 of local and remote parties must match exactly; otherwise
- * loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
+ * CGX SMU External Loopback Registers In loopback mode, the IFG1+IFG2 of
+ * local and remote parties must match exactly; otherwise loopback FIFO
+ * will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
  */
 union cavm_cgxx_smux_ext_loopback {
 	u64 u;
@@ -4884,24 +4739,23 @@ static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
 /**
  * Register (RSL) cgx#_smu#_hg2_control
  *
- * CGX SMU HiGig2 Control Registers
- * HiGig2 TX- and RX-enable are normally set together for HiGig2 messaging. Setting just the TX
- * or RX bit results in only the HG2 message transmit or receive capability.
- *
- * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure to NIX as per the
- * received HiGig2 message. Setting these fields to 0 disables link PAUSE and backpressure to NIX
- * in response to received messages.
- *
- * CGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig) whenever either [HG2TX_EN] or
- * [HG2RX_EN] are set. CGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
+ * CGX SMU HiGig2 Control Registers HiGig2 TX- and RX-enable are normally
+ * set together for HiGig2 messaging. Setting just the TX or RX bit
+ * results in only the HG2 message transmit or receive capability.
+ * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure
+ * to NIX as per the received HiGig2 message. Setting these fields to 0
+ * disables link PAUSE and backpressure to NIX in response to received
+ * messages.  CGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig)
  * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
- *
- * CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared
- * to 0 (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
- * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated
- * by CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16.) Hardware
- * can only autogenerate backpressure via HiGig2 messages (optionally, when [HG2TX_EN] = 1) with
- * the HiGig2 protocol.
+ * CGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
+ * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
+ * CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set and
+ * CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to 0 (to forcibly disable
+ * hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
+ * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated by
+ * CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16.)
+ * Hardware can only autogenerate backpressure via HiGig2 messages
+ * (optionally, when [HG2TX_EN] = 1) with the HiGig2 protocol.
  */
 union cavm_cgxx_smux_hg2_control {
 	u64 u;
@@ -4926,7 +4780,8 @@ static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
  * Register (RSL) cgx#_smu#_mmsi_ctl_sta
  *
  * CGX SMU MAC Merge Service Interface (MMSI) Control/Status Registers
- * MMSI control and status registers for frame preemption mode. Refer to IEEE 802.3br, Clause 99.
+ * MMSI control and status registers for frame preemption mode. Refer to
+ * IEEE 802.3br, Clause 99.
  */
 union cavm_cgxx_smux_mmsi_ctl_sta {
 	u64 u;
@@ -5037,11 +4892,12 @@ static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_decision
  *
- * CGX SMU Packet Decision Registers
- * This register specifies the byte count used to determine when to accept or to filter a packet.
- * As each byte in a packet is received by CGX, the L2 byte count (i.e. the number of bytes from
- * the beginning of the L2 header (DMAC)) is compared against CNT. In normal operation, the L2
- * header begins after the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
+ * CGX SMU Packet Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by CGX, the L2 byte count (i.e. the
+ * number of bytes from the beginning of the L2 header (DMAC)) is
+ * compared against CNT. In normal operation, the L2 header begins after
+ * the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
  * optional UDD skip data (CGX()_SMU()_RX_UDD_SKP[LEN]).
  */
 union cavm_cgxx_smux_rx_decision {
@@ -5063,8 +4919,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_frm_chk
  *
- * CGX SMU RX Frame Check Registers
- * The CSRs provide the enable bits for a subset of errors passed to CMR encoded.
+ * CGX SMU RX Frame Check Registers The CSRs provide the enable bits for
+ * a subset of errors passed to CMR encoded.
  */
 union cavm_cgxx_smux_rx_frm_chk {
 	u64 u;
@@ -5091,19 +4947,17 @@ static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_frm_ctl
  *
- * CGX SMU RX Frame Control Registers
- * This register controls the handling of the frames.
- * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
- * most
- * common modes of operation:
- * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
- * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames
- * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
- *
- * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
- * PAUSE
- * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
- * which should be handled by the processing cores. PAUSE packets should not be forwarded.
+ * CGX SMU RX Frame Control Registers This register controls the handling
+ * of the frames. The [CTL_BCK] and [CTL_DRP] bits control how the
+ * hardware handles incoming PAUSE packets. The most common modes of
+ * operation: _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames _
+ * [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
+ * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in
+ * half-duplex mode. Since PAUSE packets only apply to full duplex
+ * operation, any PAUSE packet would constitute an exception which should
+ * be handled by the processing cores. PAUSE packets should not be
+ * forwarded.
  */
 union cavm_cgxx_smux_rx_frm_ctl {
 	u64 u;
@@ -5131,12 +4985,10 @@ static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_int
  *
- * CGX SMU Receive Interrupt Registers
- * SMU Interrupt Register.
- * Internal:
- * Exception conditions \<9\> and \<4:0\> can also set the rcv/opcode in the received packet's work
- * queue entry. CGX()_SMU()_RX_FRM_CHK provides a bit mask for configuring which
- * conditions set the error.
+ * CGX SMU Receive Interrupt Registers SMU Interrupt Register. Internal:
+ * Exception conditions \<9\> and \<4:0\> can also set the rcv/opcode in
+ * the received packet's work queue entry. CGX()_SMU()_RX_FRM_CHK
+ * provides a bit mask for configuring which conditions set the error.
  */
 union cavm_cgxx_smux_rx_int {
 	u64 u;
@@ -5170,8 +5022,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_int_ena_w1c
  *
- * CGX SMU Receive Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX SMU Receive Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_smux_rx_int_ena_w1c {
 	u64 u;
@@ -5205,8 +5057,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_int_ena_w1s
  *
- * CGX SMU Receive Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX SMU Receive Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_smux_rx_int_ena_w1s {
 	u64 u;
@@ -5240,8 +5092,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_int_w1s
  *
- * CGX SMU Receive Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX SMU Receive Interrupt Set Registers This register sets interrupt
+ * bits.
  */
 union cavm_cgxx_smux_rx_int_w1s {
 	u64 u;
@@ -5275,12 +5127,11 @@ static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_jabber
  *
- * CGX SMU Maximum Packet-Size Registers
- * This register specifies the maximum size for packets, beyond which the SMU truncates.
- * Internal:
- * JABBER[CNT] is checked against the packet that arrives from SPU.  The checking
- * is performed before preamble is stripped or PTP is inserted.  If present, preamble is
- * counted as eight bytes of the incoming packet.
+ * CGX SMU Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the SMU truncates. Internal:
+ * JABBER[CNT] is checked against the packet that arrives from SPU.  The
+ * checking is performed before preamble is stripped or PTP is inserted.
+ * If present, preamble is counted as eight bytes of the incoming packet.
  */
 union cavm_cgxx_smux_rx_jabber {
 	u64 u;
@@ -5301,25 +5152,18 @@ static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_udd_skp
  *
- * CGX SMU User-Defined Data Skip Registers
- * Internal:
- * (1) The skip bytes are part of the packet and will be sent down the NCB
- * packet interface and will be handled by NIX.
- *
- * (2) The system can determine if the UDD bytes are included in the FCS check
- * by using the FCSSEL field if the FCS check is enabled.
- *
- * (3) Assume that the preamble/sfd is always at the start of the frame even
- * before UDD bytes.  In most cases, there will be no preamble in these
- * cases since it will be packet interface in direct communication to
- * another packet interface (MAC to MAC) without a PHY involved.
- *
- * (4) We can still do address filtering and control packet filtering if the
- * user desires.
- *
- * (5) In all cases, the UDD bytes will be sent down the packet interface as
- * part of the packet.  The UDD bytes are never stripped from the actual
- * packet.
+ * CGX SMU User-Defined Data Skip Registers Internal: (1) The skip bytes
+ * are part of the packet and will be sent down the NCB packet interface
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering if the user desires.  (5) In all cases, the
+ * UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
  */
 union cavm_cgxx_smux_rx_udd_skp {
 	u64 u;
@@ -5384,8 +5228,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_wol_int
  *
- * CGX SMU RX WOL Interrupt Registers
- * These registers allow WOL interrupts to be sent to the control processor.
+ * CGX SMU RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
  */
 union cavm_cgxx_smux_rx_wol_int {
 	u64 u;
@@ -5406,8 +5250,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1c
  *
- * CGX SMU RX WOL Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX SMU RX WOL Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_smux_rx_wol_int_ena_w1c {
 	u64 u;
@@ -5428,8 +5272,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1s
  *
- * CGX SMU RX WOL Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX SMU RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_cgxx_smux_rx_wol_int_ena_w1s {
 	u64 u;
@@ -5450,8 +5294,8 @@ static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_smu#_rx_wol_int_w1s
  *
- * CGX SMU RX WOL Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX SMU RX WOL Interrupt Set Registers This register sets interrupt
+ * bits.
  */
 union cavm_cgxx_smux_rx_wol_int_w1s {
 	u64 u;
@@ -5493,8 +5337,8 @@ static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_append
  *
- * CGX SMU TX Append Control Registers
- * For more details on the interactions between FCS and PAD, see also the description of
+ * CGX SMU TX Append Control Registers For more details on the
+ * interactions between FCS and PAD, see also the description of
  * CGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
  */
 union cavm_cgxx_smux_tx_append {
@@ -5590,12 +5434,10 @@ static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_eee
  *
- * INTERNAL: CGX SMU TX EEE Configure Registers
- *
- * Resvered.
- * Internal:
- * These registers control when SMU TX requests to enter or exist LPI. Those registers
- * take effect only when EEE is supported and enabled for a given LMAC.
+ * INTERNAL: CGX SMU TX EEE Configure Registers  Resvered. Internal:
+ * These registers control when SMU TX requests to enter or exist LPI.
+ * Those registers take effect only when EEE is supported and enabled for
+ * a given LMAC.
  */
 union cavm_cgxx_smux_tx_eee {
 	u64 u;
@@ -5623,10 +5465,7 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_eee_timer_status
  *
- * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers
- *
- * Reserved.
- * Internal:
+ * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers  Reserved. Internal:
  * These registers configure SMU TX EEE timing parameters.
  */
 union cavm_cgxx_smux_tx_eee_timer_status {
@@ -5652,11 +5491,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_eee_timing
  *
- * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers
- *
- * Reserved.
- * Internal:
- * These registers configure SMU TX EEE timing parameters.
+ * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers  Reserved.
+ * Internal: These registers configure SMU TX EEE timing parameters.
  */
 union cavm_cgxx_smux_tx_eee_timing {
 	u64 u;
@@ -5679,23 +5515,20 @@ static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_ifg
  *
- * CGX SMU TX Interframe-Gap Cycles Registers
- * Programming IFG1 and IFG2:
+ * CGX SMU TX Interframe-Gap Cycles Registers Programming IFG1 and IFG2:
  * * For XAUI/RXAUI/10G/25G/40G/50G/100G systems that require IEEE 802.3
- * compatibility, the [IFG1]+[IFG2] sum must be 12.
- * * In loopback mode, the [IFG1]+[IFG2] of local and remote parties must match exactly;
- * otherwise loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
- * * When CGX()_SMU()_TX_CTL[DIC_EN] is set, [IFG1]+[IFG2] sum must be at least 8.
- * The behavior of smaller values is un-determined.
- * * When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, the minimum value of [IFG1]+[IFG2] is 1
- * for 40G/50G/100G LMAC_TYPE configurations and 5 for all other values. The behavior
- * of smaller values is un-determined.
- *
- * Internal:
- * When CGX()_SMU()_TX_CTL[DIC_EN] is set, SMU TX treats ([IFG1]+[IFG2]) \< 8 as 8 for
- * 40G/50G/100G MACs and ([IFG1]+[IFG2]) \< 8 as 8 for other MACs. When
- * CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU TX can work correctly with any IFG1 and
- * IFG2.
+ * compatibility, the [IFG1]+[IFG2] sum must be 12. * In loopback mode,
+ * the [IFG1]+[IFG2] of local and remote parties must match exactly;
+ * otherwise loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW]. *
+ * When CGX()_SMU()_TX_CTL[DIC_EN] is set, [IFG1]+[IFG2] sum must be at
+ * least 8. The behavior of smaller values is un-determined. * When
+ * CGX()_SMU()_TX_CTL[DIC_EN] is cleared, the minimum value of
+ * [IFG1]+[IFG2] is 1 for 40G/50G/100G LMAC_TYPE configurations and 5 for
+ * all other values. The behavior of smaller values is un-determined.
+ * Internal: When CGX()_SMU()_TX_CTL[DIC_EN] is set, SMU TX treats
+ * ([IFG1]+[IFG2]) \< 8 as 8 for 40G/50G/100G MACs and ([IFG1]+[IFG2]) \<
+ * 8 as 8 for other MACs. When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU
+ * TX can work correctly with any IFG1 and IFG2.
  */
 union cavm_cgxx_smux_tx_ifg {
 	u64 u;
@@ -5746,8 +5579,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_int_ena_w1c
  *
- * CGX SMU TX Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX SMU TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_smux_tx_int_ena_w1c {
 	u64 u;
@@ -5773,8 +5606,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_int_ena_w1s
  *
- * CGX SMU TX Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX SMU TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
  */
 union cavm_cgxx_smux_tx_int_ena_w1s {
 	u64 u;
@@ -5800,8 +5633,7 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_int_w1s
  *
- * CGX SMU TX Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX SMU TX Interrupt Set Registers This register sets interrupt bits.
  */
 union cavm_cgxx_smux_tx_int_w1s {
 	u64 u;
@@ -5827,9 +5659,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_min_pkt
  *
- * CGX SMU TX Minimum-Size-Packet Registers
- * Internal:
- * [MIN_SIZE] less than 16 will be ignored by hardware which will use 16 instead.
+ * CGX SMU TX Minimum-Size-Packet Registers Internal: [MIN_SIZE] less
+ * than 16 will be ignored by hardware which will use 16 instead.
  */
 union cavm_cgxx_smux_tx_min_pkt {
 	u64 u;
@@ -5850,8 +5681,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_pause_pkt_dmac
  *
- * CGX SMU TX PAUSE-Packet DMAC-Field Registers
- * This register provides the DMAC value that is placed in outbound PAUSE packets.
+ * CGX SMU TX PAUSE-Packet DMAC-Field Registers This register provides
+ * the DMAC value that is placed in outbound PAUSE packets.
  */
 union cavm_cgxx_smux_tx_pause_pkt_dmac {
 	u64 u;
@@ -5872,8 +5703,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_pause_pkt_interval
  *
- * CGX SMU TX PAUSE-Packet Transmission-Interval Registers
- * This register specifies how often PAUSE packets are sent.
+ * CGX SMU TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent.
  */
 union cavm_cgxx_smux_tx_pause_pkt_interval {
 	u64 u;
@@ -5917,8 +5748,8 @@ static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
 /**
  * Register (RSL) cgx#_smu#_tx_pause_pkt_type
  *
- * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers
- * This register provides the P_TYPE field that is placed in outbound PAUSE packets.
+ * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers This register provides
+ * the P_TYPE field that is placed in outbound PAUSE packets.
  */
 union cavm_cgxx_smux_tx_pause_pkt_type {
 	u64 u;
@@ -6030,15 +5861,17 @@ static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
 /**
  * Register (RSL) cgx#_spu#_an_adv
  *
- * CGX SPU Autonegotiation Advertisement Registers
- * Software programs this register with the contents of the AN-link code word base page to be
- * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for details.) Any write
- * operations to this register prior to completion of autonegotiation, as indicated by
- * CGX()_SPU()_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
- * the new values to take effect. Renegotiation is initiated by setting
- * CGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has completed, software can
- * examine this register along with CGX()_SPU()_AN_LP_BASE to determine the highest
- * common denominator technology.
+ * CGX SPU Autonegotiation Advertisement Registers Software programs this
+ * register with the contents of the AN-link code word base page to be
+ * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for
+ * details.) Any write operations to this register prior to completion of
+ * autonegotiation, as indicated by CGX()_SPU()_AN_STATUS[AN_COMPLETE],
+ * should be followed by a renegotiation in order for the new values to
+ * take effect. Renegotiation is initiated by setting
+ * CGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has
+ * completed, software can examine this register along with
+ * CGX()_SPU()_AN_LP_BASE to determine the highest common denominator
+ * technology.
  */
 union cavm_cgxx_spux_an_adv {
 	u64 u;
@@ -6083,12 +5916,14 @@ static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
 /**
  * Register (RSL) cgx#_spu#_an_bp_status
  *
- * CGX SPU Autonegotiation Backplane Ethernet & BASE-R Copper Status Registers
- * The contents of this register are updated during autonegotiation and are valid when
- * CGX()_SPU()_AN_STATUS[AN_COMPLETE] is set. At that time, one of the port type bits will be
- * set depending on the AN priority resolution. The port types are listed in order of decreasing
- * priority. If a BASE-R type is negotiated then [FEC] or [RS_FEC] will be set to indicate
- * whether/which FEC operation has been negotiated and will be clear otherwise.
+ * CGX SPU Autonegotiation Backplane Ethernet & BASE-R Copper Status
+ * Registers The contents of this register are updated during
+ * autonegotiation and are valid when CGX()_SPU()_AN_STATUS[AN_COMPLETE]
+ * is set. At that time, one of the port type bits will be set depending
+ * on the AN priority resolution. The port types are listed in order of
+ * decreasing priority. If a BASE-R type is negotiated then [FEC] or
+ * [RS_FEC] will be set to indicate whether/which FEC operation has been
+ * negotiated and will be clear otherwise.
  */
 union cavm_cgxx_spux_an_bp_status {
 	u64 u;
@@ -6155,10 +5990,11 @@ static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_an_lp_base
  *
- * CGX SPU Autonegotiation Link-Partner Base-Page Ability Registers
- * This register captures the contents of the latest AN link code word base page received from
- * the link partner during autonegotiation. (See IEEE 802.3 section 73.6 for details.)
- * CGX()_SPU()_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
+ * CGX SPU Autonegotiation Link-Partner Base-Page Ability Registers This
+ * register captures the contents of the latest AN link code word base
+ * page received from the link partner during autonegotiation. (See IEEE
+ * 802.3 section 73.6 for details.) CGX()_SPU()_AN_STATUS[PAGE_RX] is set
+ * when this register is updated by hardware.
  */
 union cavm_cgxx_spux_an_lp_base {
 	u64 u;
@@ -6203,9 +6039,10 @@ static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
 /**
  * Register (RSL) cgx#_spu#_an_lp_xnp
  *
- * CGX SPU Autonegotiation Link Partner Extended Next Page Ability Registers
- * This register captures the contents of the latest next page code word received from the link
- * partner during autonegotiation, if any. See IEEE 802.3 section 73.7.7 for details.
+ * CGX SPU Autonegotiation Link Partner Extended Next Page Ability
+ * Registers This register captures the contents of the latest next page
+ * code word received from the link partner during autonegotiation, if
+ * any. See IEEE 802.3 section 73.7.7 for details.
  */
 union cavm_cgxx_spux_an_lp_xnp {
 	u64 u;
@@ -6262,13 +6099,15 @@ static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_spu#_an_xnp_tx
  *
- * CGX SPU Autonegotiation Extended Next Page Transmit Registers
- * Software programs this register with the contents of the AN message next page or unformatted
- * next page link code word to be transmitted during autonegotiation. Next page exchange occurs
- * after the base link code words have been exchanged if either end of the link segment sets the
- * NP bit to 1, indicating that it has at least one next page to send. Once initiated, next page
- * exchange continues until both ends of the link segment set their NP bits to 0. See IEEE
- * 802.3 section 73.7.7 for details.
+ * CGX SPU Autonegotiation Extended Next Page Transmit Registers Software
+ * programs this register with the contents of the AN message next page
+ * or unformatted next page link code word to be transmitted during
+ * autonegotiation. Next page exchange occurs after the base link code
+ * words have been exchanged if either end of the link segment sets the
+ * NP bit to 1, indicating that it has at least one next page to send.
+ * Once initiated, next page exchange continues until both ends of the
+ * link segment set their NP bits to 0. See IEEE 802.3 section 73.7.7 for
+ * details.
  */
 union cavm_cgxx_spux_an_xnp_tx {
 	u64 u;
@@ -6295,16 +6134,18 @@ static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_algn_status
  *
- * CGX SPU Multilane BASE-R PCS Alignment-Status Registers
- * This register implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4 registers
- * (3.50-3.53). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R, 100GBASE-R,
- * (CGX()_CMR()_CONFIG[LMAC_TYPE] = CGX_LMAC_TYPES_E::FORTYG_R,FIFTYG_R,HUNDREDG_R), and always
- * returns 0x0 for all other LPCS
- * types. Service interfaces (lanes) 19-0 (100G) and 3-0 (all others) are mapped to PCS lanes
- * 19-0 or 3-0 via CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. For 100G, logical lane 0 fans out to
- * service interfaces 0-4, logical lane 1 fans out to service interfaces 5-9, ... etc. For all
- * other modes, logical lanes and service interfaces are identical. Logical interfaces (lanes)
- * map to SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
+ * CGX SPU Multilane BASE-R PCS Alignment-Status Registers This register
+ * implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4
+ * registers (3.50-3.53). It is valid only when the LPCS type is
+ * 40GBASE-R, 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE] =
+ * CGX_LMAC_TYPES_E::FORTYG_R,FIFTYG_R,HUNDREDG_R), and always returns
+ * 0x0 for all other LPCS types. Service interfaces (lanes) 19-0 (100G)
+ * and 3-0 (all others) are mapped to PCS lanes 19-0 or 3-0 via
+ * CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. For 100G, logical lane 0 fans
+ * out to service interfaces 0-4, logical lane 1 fans out to service
+ * interfaces 5-9, ... etc. For all other modes, logical lanes and
+ * service interfaces are identical. Logical interfaces (lanes) map to
+ * SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
  */
 union cavm_cgxx_spux_br_algn_status {
 	u64 u;
@@ -6329,31 +6170,30 @@ static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_lane_map#
  *
- * CGX SPU 40,50,100GBASE-R Lane-Mapping Registers
- * This register implements the IEEE 802.3 lane 0-19 mapping registers
- * (3.400-3.403). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
+ * CGX SPU 40,50,100GBASE-R Lane-Mapping Registers This register
+ * implements the IEEE 802.3 lane 0-19 mapping registers (3.400-3.403).
+ * It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
  * 100GBASE-R, USXGMII (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
- * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each programmed PCS
- * lane (called service interface in 802.3) is valid when that lane has achieved
- * alignment marker lock on the receive side (i.e. the associated
- * CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is invalid otherwise. When valid,
- * it returns the actual detected receive PCS lane number based on the received
- * alignment marker contents received on that service interface.
- *
- * In RS-FEC mode the LNx_MAPPING field is valid when that lane has achieved alignment
- * marker lock on the receive side (i.e. the associated
- * CGX(0..2)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid otherwise. When valid,
- * it returns the actual detected receive FEC lane number based on the received
- * alignment marker contents received on that logical lane therefore expect for RS-FEC
- * that LNx_MAPPING = x.
- *
- * The mapping is flexible because IEEE 802.3 allows multilane BASE-R receive lanes to
- * be re-ordered. Note that for the transmit side, each logical lane is mapped to a
- * physical SerDes lane based on the programming of
- * CGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
- * CGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the logical lane to physical SerDes
- * lane mapping, and this register specifies the service interface (or lane) to PCS
- * lane mapping.
+ * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each
+ * programmed PCS lane (called service interface in 802.3) is valid when
+ * that lane has achieved alignment marker lock on the receive side (i.e.
+ * the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is
+ * invalid otherwise. When valid, it returns the actual detected receive
+ * PCS lane number based on the received alignment marker contents
+ * received on that service interface.  In RS-FEC mode the LNx_MAPPING
+ * field is valid when that lane has achieved alignment marker lock on
+ * the receive side (i.e. the associated
+ * CGX(0..2)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid
+ * otherwise. When valid, it returns the actual detected receive FEC lane
+ * number based on the received alignment marker contents received on
+ * that logical lane therefore expect for RS-FEC that LNx_MAPPING = x.
+ * The mapping is flexible because IEEE 802.3 allows multilane BASE-R
+ * receive lanes to be re-ordered. Note that for the transmit side, each
+ * logical lane is mapped to a physical SerDes lane based on the
+ * programming of CGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
+ * CGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the logical lane to physical
+ * SerDes lane mapping, and this register specifies the service interface
+ * (or lane) to PCS lane mapping.
  */
 union cavm_cgxx_spux_br_lane_mapx {
 	u64 u;
@@ -6397,24 +6237,23 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_pmd_ld_cup
  *
- * CGX SPU BASE-R PMD Local Device Coefficient Update Registers
- * This register implements MDIO register 1.154 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
- * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
- *
- * It implements  MDIO registers 1.1300-1.1303 for all other BASE-R modes (40G, 50G, 100G) per
- * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
- *
- * The fields in this register are read/write even though they are specified as read-only in 802.3.
- *
- * The register is automatically cleared at the start of training. When link training
- * is in progress, each field reflects the contents of the coefficient update field in the
- * associated lane's outgoing training frame.
- *
- * If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must be updated
- * by software during link training and hardware updates are disabled. If
- * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
- * updated by hardware, and it should not be written by software. The lane fields in this
- * register are indexed by logical PCS lane ID.
+ * CGX SPU BASE-R PMD Local Device Coefficient Update Registers This
+ * register implements MDIO register 1.154 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1300-1.1303 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. When link training is in progress, each field
+ * reflects the contents of the coefficient update field in the
+ * associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
  */
 union cavm_cgxx_spux_br_pmd_ld_cup {
 	u64 u;
@@ -6437,24 +6276,22 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_pmd_ld_rep
  *
- * CGX SPU BASE-R PMD Local Device Status Report Registers
- * This register implements MDIO register 1.155 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
- * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
- *
- * It implements  MDIO registers 1.1400-1.1403 for all other BASE-R modes (40G, 50G, 100G) per
- * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
- *
- * The fields in this register are read/write even though they are specified as read-only in 802.3.
- *
- * The register is automatically cleared at the start of training. Each field
- * reflects the contents of the status report field in the associated lane's outgoing training
- * frame.
- *
- * If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must
- * be updated by software during link training and hardware updates are disabled. If
- * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
- * updated by hardware, and it should not be written by software. The lane fields in this
- * register are indexed by logical PCS lane ID.
+ * CGX SPU BASE-R PMD Local Device Status Report Registers This register
+ * implements MDIO register 1.155 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1400-1.1403 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. Each field reflects the contents of the status
+ * report field in the associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
  */
 union cavm_cgxx_spux_br_pmd_ld_rep {
 	u64 u;
@@ -6477,18 +6314,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_pmd_lp_cup
  *
- * CGX SPU BASE-R PMD Link Partner Coefficient Update Registers
- * This register implements MDIO register 1.152 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
- * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
- *
- * It implements  MDIO registers 1.1100-1.1103 for all other BASE-R modes (40G, 50G, 100G) per
- * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
- *
- * The register is automatically cleared at the start of training. Each field reflects
- * the contents of the coefficient update field in the lane's most recently received training
- * frame. This register should not be written when link training is enabled, i.e. when
- * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this register are indexed by
- * logical PCS lane ID.
+ * CGX SPU BASE-R PMD Link Partner Coefficient Update Registers This
+ * register implements MDIO register 1.152 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1100-1.1103 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
  */
 union cavm_cgxx_spux_br_pmd_lp_cup {
 	u64 u;
@@ -6511,18 +6348,18 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_pmd_lp_rep
  *
- * CGX SPU BASE-R PMD Link Partner Status Report Registers
- * This register implements MDIO register 1.153 of 802.3-2012 Section 5 CL45 for 10GBASE-R and
- * and of 802.3by-2016 CL45 for 25GBASE-R. Note that for 10G, 25G LN0_ only is used.
- *
- * It implements  MDIO registers 1.1200-1.1203 for all other BASE-R modes (40G, 50G, 100G) per
- * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.
- *
- * The register is automatically cleared at the start of training. Each field reflects
- * the contents of the coefficient update field in the lane's most recently received training
- * frame. This register should not be written when link training is enabled, i.e. when
- * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this register are indexed by
- * logical PCS lane ID.
+ * CGX SPU BASE-R PMD Link Partner Status Report Registers This register
+ * implements MDIO register 1.153 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1200-1.1203 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
  */
 union cavm_cgxx_spux_br_pmd_lp_rep {
 	u64 u;
@@ -6545,11 +6382,12 @@ static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_pmd_status
  *
- * CGX SPU BASE-R PMD Status Registers
- * The lane fields in this register are indexed by logical PCS lane ID. The lane 0 field (LN0_*)
- * is valid for 10GBASE-R, 25GBASE-R, 40GBASE-R, 50GBASE-R and 100GBASE-R. The lane 1 field
- * (LN1_*) is valid for 40GBASE-R, 50GBASE-R and 100GBASE-R. The remaining fields (LN2_*, LN3_*)
- * are only valid for 40GBASE-R and 100GBASE-R.
+ * CGX SPU BASE-R PMD Status Registers The lane fields in this register
+ * are indexed by logical PCS lane ID. The lane 0 field (LN0_*) is valid
+ * for 10GBASE-R, 25GBASE-R, 40GBASE-R, 50GBASE-R and 100GBASE-R. The
+ * lane 1 field (LN1_*) is valid for 40GBASE-R, 50GBASE-R and 100GBASE-R.
+ * The remaining fields (LN2_*, LN3_*) are only valid for 40GBASE-R and
+ * 100GBASE-R.
  */
 union cavm_cgxx_spux_br_pmd_status {
 	u64 u;
@@ -6599,17 +6437,17 @@ static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_status2
  *
- * CGX SPU BASE-R Status 2 Registers
- * This register implements a combination of the following IEEE 802.3 registers:
- * * BASE-R PCS status 2 (MDIO address 3.33).
- * * BASE-R BER high-order counter (MDIO address 3.44).
- * * Errored-blocks high-order counter (MDIO address 3.45).
- *
- * Note that the relative locations of some fields have been moved from IEEE 802.3 in order to
- * make the register layout more software friendly: the BER counter high-order and low-order bits
- * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit [BER_CNT] field;
- * likewise, the errored-blocks counter high-order and low-order bits from section 3.45 have been
- * combined into the contiguous, 22-bit [ERR_BLKS] field.
+ * CGX SPU BASE-R Status 2 Registers This register implements a
+ * combination of the following IEEE 802.3 registers: * BASE-R PCS status
+ * 2 (MDIO address 3.33). * BASE-R BER high-order counter (MDIO address
+ * 3.44). * Errored-blocks high-order counter (MDIO address 3.45).  Note
+ * that the relative locations of some fields have been moved from IEEE
+ * 802.3 in order to make the register layout more software friendly: the
+ * BER counter high-order and low-order bits from sections 3.44 and 3.33
+ * have been combined into the contiguous, 22-bit [BER_CNT] field;
+ * likewise, the errored-blocks counter high-order and low-order bits
+ * from section 3.45 have been combined into the contiguous, 22-bit
+ * [ERR_BLKS] field.
  */
 union cavm_cgxx_spux_br_status2 {
 	u64 u;
@@ -6635,8 +6473,8 @@ static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_tp_control
  *
- * CGX SPU BASE-R Test-Pattern Control Registers
- * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ * CGX SPU BASE-R Test-Pattern Control Registers Refer to the test
+ * pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
 union cavm_cgxx_spux_br_tp_control {
 	u64 u;
@@ -6665,8 +6503,8 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_tp_err_cnt
  *
- * CGX SPU BASE-R Test-Pattern Error-Count Registers
- * This register provides the BASE-R PCS test-pattern error counter.
+ * CGX SPU BASE-R Test-Pattern Error-Count Registers This register
+ * provides the BASE-R PCS test-pattern error counter.
  */
 union cavm_cgxx_spux_br_tp_err_cnt {
 	u64 u;
@@ -6687,8 +6525,8 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_tp_seed_a
  *
- * CGX SPU BASE-R Test-Pattern Seed A Registers
- * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ * CGX SPU BASE-R Test-Pattern Seed A Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
 union cavm_cgxx_spux_br_tp_seed_a {
 	u64 u;
@@ -6709,8 +6547,8 @@ static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
 /**
  * Register (RSL) cgx#_spu#_br_tp_seed_b
  *
- * CGX SPU BASE-R Test-Pattern Seed B Registers
- * Refer to the test pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ * CGX SPU BASE-R Test-Pattern Seed B Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
  */
 union cavm_cgxx_spux_br_tp_seed_b {
 	u64 u;
@@ -6853,16 +6691,16 @@ static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_fec_ln#_rsfec_err
  *
- * CGX SPU Reed-Solomon FEC Symbol Error Counter for FEC Lanes 0-3 Registers
- * This register is valid only when Reed-Solomon FEC is enabled.
- * The symbol error counters are defined in 802.3 section 91.6.11 (for 100G
- * and extended to 50G) and 802.3by-2016 section 108.6.9 (for 25G and extended to USXGMII).
- * The counter is reset to all zeros when the register is read, and held at all ones in case
- * of overflow.
- *
- * The reset operation takes precedence over the increment operation; if the register
- * is read on the same clock cycle as an increment operation, the counter is reset to
- * all zeros and the increment operation is lost. The counters are writable for test
+ * CGX SPU Reed-Solomon FEC Symbol Error Counter for FEC Lanes 0-3
+ * Registers This register is valid only when Reed-Solomon FEC is
+ * enabled. The symbol error counters are defined in 802.3 section
+ * 91.6.11 (for 100G and extended to 50G) and 802.3by-2016 section
+ * 108.6.9 (for 25G and extended to USXGMII). The counter is reset to all
+ * zeros when the register is read, and held at all ones in case of
+ * overflow.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
  * purposes, rather than read-only as specified in IEEE 802.3.
  */
 union cavm_cgxx_spux_fec_lnx_rsfec_err {
@@ -6925,8 +6763,8 @@ static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
 /**
  * Register (RSL) cgx#_spu#_int_ena_w1c
  *
- * CGX SPU Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * CGX SPU Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_cgxx_spux_int_ena_w1c {
 	u64 u;
@@ -6967,8 +6805,8 @@ static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
 /**
  * Register (RSL) cgx#_spu#_int_ena_w1s
  *
- * CGX SPU Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * CGX SPU Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
  */
 union cavm_cgxx_spux_int_ena_w1s {
 	u64 u;
@@ -7009,8 +6847,7 @@ static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
 /**
  * Register (RSL) cgx#_spu#_int_w1s
  *
- * CGX SPU Interrupt Set Registers
- * This register sets interrupt bits.
+ * CGX SPU Interrupt Set Registers This register sets interrupt bits.
  */
 union cavm_cgxx_spux_int_w1s {
 	u64 u;
@@ -7051,19 +6888,19 @@ static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
 /**
  * Register (RSL) cgx#_spu#_ln#_br_bip_err_cnt
  *
- * CGX SPU 40,50,100GBASE-R BIP Error-Counter Registers
- * This register implements the IEEE 802.3 BIP error-counter registers for PCS lanes
- * 0-19 (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
- * 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always returns 0x0
- * for all other LPCS types. The counters are indexed by the RX PCS lane number based
- * on the alignment marker detected on each lane and captured in
- * CGX()_SPU()_BR_LANE_MAP(). Each counter counts the BIP errors for its PCS lane, and is
- * held at all ones in case of overflow. The counters are reset to all zeros when this
- * register is read by software.
- *
- * The reset operation takes precedence over the increment operation; if the register
- * is read on the same clock cycle as an increment operation, the counter is reset to
- * all zeros and the increment operation is lost. The counters are writable for test
+ * CGX SPU 40,50,100GBASE-R BIP Error-Counter Registers This register
+ * implements the IEEE 802.3 BIP error-counter registers for PCS lanes
+ * 0-19 (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R,
+ * 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
+ * returns 0x0 for all other LPCS types. The counters are indexed by the
+ * RX PCS lane number based on the alignment marker detected on each lane
+ * and captured in CGX()_SPU()_BR_LANE_MAP(). Each counter counts the BIP
+ * errors for its PCS lane, and is held at all ones in case of overflow.
+ * The counters are reset to all zeros when this register is read by
+ * software.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
  * purposes, rather than read-only as specified in IEEE 802.3.
  */
 union cavm_cgxx_spux_lnx_br_bip_err_cnt {
@@ -7085,20 +6922,20 @@ static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
 /**
  * Register (RSL) cgx#_spu#_ln#_fec_corr_blks
  *
- * CGX SPU FEC Corrected-Blocks Counters 0-19 Registers
- * This register is valid only when the LPCS type is BASE-R
- * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies
- * to BASE-R FEC and Reed-Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC
- * corrected-block counters are defined in IEEE 802.3 section 74.8.4.1. Each
- * corrected-blocks counter increments by one for a corrected FEC block, i.e. an FEC
- * block that has been received with invalid parity on the associated PCS lane and has
- * been corrected by the FEC decoder. The counter is reset to all zeros when the register
- * is read, and held at all ones in case of overflow.
- *
- * The reset operation takes precedence over the increment operation; if the register
- * is read on the same clock cycle as an increment operation, the counter is reset to
- * all zeros and the increment operation is lost. The counters are writable for test
- * purposes, rather than read-only as specified in IEEE 802.3.
+ * CGX SPU FEC Corrected-Blocks Counters 0-19 Registers This register is
+ * valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.1. Each
+ * corrected-blocks counter increments by one for a corrected FEC block,
+ * i.e. an FEC block that has been received with invalid parity on the
+ * associated PCS lane and has been corrected by the FEC decoder. The
+ * counter is reset to all zeros when the register is read, and held at
+ * all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
  */
 union cavm_cgxx_spux_lnx_fec_corr_blks {
 	u64 u;
@@ -7119,20 +6956,20 @@ static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
 /**
  * Register (RSL) cgx#_spu#_ln#_fec_uncorr_blks
  *
- * CGX SPU FEC Uncorrected-Blocks Counters 0-19 Registers
- * This register is valid only when the LPCS type is BASE-R
- * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies
- * to BASE-R FEC and Reed-Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC
- * corrected-block counters are defined in IEEE 802.3 section 74.8.4.2. Each
- * uncorrected-blocks counter increments by one for an uncorrected FEC block, i.e. an FEC
- * block that has been received with invalid parity on the associated PCS lane and has
- * not been corrected by the FEC decoder. The counter is reset to all zeros when the
- * register is read, and held at all ones in case of overflow.
- *
- * The reset operation takes precedence over the increment operation; if the register
- * is read on the same clock cycle as an increment operation, the counter is reset to
- * all zeros and the increment operation is lost. The counters are writable for test
- * purposes, rather than read-only as specified in IEEE 802.3.
+ * CGX SPU FEC Uncorrected-Blocks Counters 0-19 Registers This register
+ * is valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.2. Each
+ * uncorrected-blocks counter increments by one for an uncorrected FEC
+ * block, i.e. an FEC block that has been received with invalid parity on
+ * the associated PCS lane and has not been corrected by the FEC decoder.
+ * The counter is reset to all zeros when the register is read, and held
+ * at all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
  */
 union cavm_cgxx_spux_lnx_fec_uncorr_blks {
 	u64 u;
@@ -7179,13 +7016,13 @@ static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
 /**
  * Register (RSL) cgx#_spu#_misc_control
  *
- * CGX SPU Miscellaneous Control Registers
- * "* RX logical PCS lane polarity vector \<3:0\> = [XOR_RXPLRT]\<3:0\> ^ {4{[RXPLRT]}}.
- * * TX logical PCS lane polarity vector \<3:0\> = [XOR_TXPLRT]\<3:0\> ^ {4{[TXPLRT]}}.
- *
- * In short, keep [RXPLRT] and [TXPLRT] cleared, and use [XOR_RXPLRT] and [XOR_TXPLRT] fields to
- * define the polarity per logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and
- * only bits 1:0 of vector are used for RXAUI."
+ * CGX SPU Miscellaneous Control Registers "* RX logical PCS lane
+ * polarity vector \<3:0\> = [XOR_RXPLRT]\<3:0\> ^ {4{[RXPLRT]}}. * TX
+ * logical PCS lane polarity vector \<3:0\> = [XOR_TXPLRT]\<3:0\> ^
+ * {4{[TXPLRT]}}.  In short, keep [RXPLRT] and [TXPLRT] cleared, and use
+ * [XOR_RXPLRT] and [XOR_TXPLRT] fields to define the polarity per
+ * logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only
+ * bits 1:0 of vector are used for RXAUI."
  */
 union cavm_cgxx_spux_misc_control {
 	u64 u;
@@ -7213,10 +7050,10 @@ static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rsfec_corr
  *
- * CGX SPU Reed-Solomon FEC Corrected Codeword Counter Register
- * This register implements the IEEE 802.3 RS-FEC corrected codewords counter
- * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and 802.3by-2016
- * section 108.6.7 (for 25G and extended to USXGMII).
+ * CGX SPU Reed-Solomon FEC Corrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC corrected codewords counter
+ * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and
+ * 802.3by-2016 section 108.6.7 (for 25G and extended to USXGMII).
  */
 union cavm_cgxx_spux_rsfec_corr {
 	u64 u;
@@ -7237,9 +7074,9 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rsfec_status
  *
- * CGX SPU Reed-Solomon FEC Status Registers
- * This register implements the IEEE 802.3 RS-FEC status and lane mapping registers as
- * described in 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
+ * CGX SPU Reed-Solomon FEC Status Registers This register implements the
+ * IEEE 802.3 RS-FEC status and lane mapping registers as described in
+ * 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
  * section 108-6 (for 25G and extended to USXGMII).
  */
 union cavm_cgxx_spux_rsfec_status {
@@ -7266,10 +7103,11 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rsfec_uncorr
  *
- * CGX SPU Reed-Solomon FEC Uncorrected Codeword Counter Register
- * This register implements the IEEE 802.3 RS-FEC uncorrected codewords counter
- * described in 802.3 section 91.6.9 (for 100G and extended to 50G) and 802.3by-2016
- * section 108.6.8 (for 25G and extended to USXGMII).
+ * CGX SPU Reed-Solomon FEC Uncorrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC uncorrected codewords
+ * counter described in 802.3 section 91.6.9 (for 100G and extended to
+ * 50G) and 802.3by-2016 section 108.6.8 (for 25G and extended to
+ * USXGMII).
  */
 union cavm_cgxx_spux_rsfec_uncorr {
 	u64 u;
@@ -7290,12 +7128,10 @@ static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rx_eee_wake
  *
- * INTERNAL: CGX SPU  RX EEE Wake Error Counter  Registers
- *
- * Reserved.
- * Internal:
- * A counter that is incremented each time that the LPI receive state diagram enters
- * the RX_WTF state indicating that a wake time fault has been detected.
+ * INTERNAL: CGX SPU  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: A counter that is incremented each time that the LPI receive
+ * state diagram enters the RX_WTF state indicating that a wake time
+ * fault has been detected.
  */
 union cavm_cgxx_spux_rx_eee_wake {
 	u64 u;
@@ -7316,11 +7152,9 @@ static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rx_lpi_timing
  *
- * INTERNAL: CGX SPU RX EEE LPI Timing Parameters Registers
- *
- * Reserved.
- * Internal:
- * This register specifies receiver LPI timing parameters Tqr, Twr and Twtf.
+ * INTERNAL: CGX SPU RX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters Tqr,
+ * Twr and Twtf.
  */
 union cavm_cgxx_spux_rx_lpi_timing {
 	u64 u;
@@ -7345,11 +7179,9 @@ static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
 /**
  * Register (RSL) cgx#_spu#_rx_lpi_timing2
  *
- * INTERNAL: CGX SPU RX EEE LPI Timing2 Parameters Registers
- *
- * Reserved.
- * Internal:
- * This register specifies receiver LPI timing parameters hold_off_timer.
+ * INTERNAL: CGX SPU RX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters
+ * hold_off_timer.
  */
 union cavm_cgxx_spux_rx_lpi_timing2 {
 	u64 u;
@@ -7485,11 +7317,8 @@ static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
 /**
  * Register (RSL) cgx#_spu#_tx_lpi_timing
  *
- * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers
- *
- * Reserved.
- * Internal:
- * Transmit LPI timing parameters Tsl, Tql and Tul
+ * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: Transmit LPI timing parameters Tsl, Tql and Tul
  */
 union cavm_cgxx_spux_tx_lpi_timing {
 	u64 u;
@@ -7517,11 +7346,8 @@ static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
 /**
  * Register (RSL) cgx#_spu#_tx_lpi_timing2
  *
- * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers
- *
- * Reserved.
- * Internal:
- * This register specifies transmit LPI timer parameters.
+ * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies transmit LPI timer parameters.
  */
 union cavm_cgxx_spux_tx_lpi_timing2 {
 	u64 u;
@@ -7573,13 +7399,15 @@ static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
 /**
  * Register (RSL) cgx#_spu#_usx_an_adv
  *
- * CGX SPU USXGMII Autonegotiation Advertisement Registers
- * Software programs this register with the contents of the AN-link code word base page to be
- * transmitted during autonegotiation. Any write operations to this register prior to completion
- * of autonegotiation should be followed by a renegotiation in order for the new values to take
- * effect. Once autonegotiation has completed, software can examine this register along with
- * CGX()_SPU()_USX_AN_ADV to determine the highest common denominator technology.
- * The format for this register is from USXGMII Multiport specification section 1.1.2 Table 2.
+ * CGX SPU USXGMII Autonegotiation Advertisement Registers Software
+ * programs this register with the contents of the AN-link code word base
+ * page to be transmitted during autonegotiation. Any write operations to
+ * this register prior to completion of autonegotiation should be
+ * followed by a renegotiation in order for the new values to take
+ * effect. Once autonegotiation has completed, software can examine this
+ * register along with CGX()_SPU()_USX_AN_ADV to determine the highest
+ * common denominator technology. The format for this register is from
+ * USXGMII Multiport specification section 1.1.2 Table 2.
  */
 union cavm_cgxx_spux_usx_an_adv {
 	u64 u;
@@ -7633,8 +7461,8 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_usx_an_expansion
  *
- * CGX SPU USXGMII Autonegotiation Expansion Register
- * This register is only used to signal page reception.
+ * CGX SPU USXGMII Autonegotiation Expansion Register This register is
+ * only used to signal page reception.
  */
 union cavm_cgxx_spux_usx_an_expansion {
 	u64 u;
@@ -7657,8 +7485,8 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
 /**
  * Register (RSL) cgx#_spu#_usx_an_flow_ctrl
  *
- * CGX SPU USXGMII Flow Control Registers
- * This register is used by software to affect USXGMII AN hardware behavior.
+ * CGX SPU USXGMII Flow Control Registers This register is used by
+ * software to affect USXGMII AN hardware behavior.
  */
 union cavm_cgxx_spux_usx_an_flow_ctrl {
 	u64 u;
@@ -7679,8 +7507,7 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
 /**
  * Register (RSL) cgx#_spu#_usx_an_link_timer
  *
- * CGX SPU USXGMII Link Timer Registers
- * This is the link timer register.
+ * CGX SPU USXGMII Link Timer Registers This is the link timer register.
  */
 union cavm_cgxx_spux_usx_an_link_timer {
 	u64 u;
@@ -7702,9 +7529,11 @@ static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
  * Register (RSL) cgx#_spu#_usx_an_lp_abil
  *
  * CGX SPU USXGMII Autonegotiation Link-Partner Advertisement Registers
- * This register captures the contents of the latest AN link code word base page received from
- * the link partner during autonegotiation. This is register 5 per IEEE 802.3, Clause 37.
- * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this register is updated by hardware.
+ * This register captures the contents of the latest AN link code word
+ * base page received from the link partner during autonegotiation. This
+ * is register 5 per IEEE 802.3, Clause 37.
+ * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this
+ * register is updated by hardware.
  */
 union cavm_cgxx_spux_usx_an_lp_abil {
 	u64 u;
@@ -7790,8 +7619,8 @@ static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
 /**
  * Register (RSL) cgx#_spu_sds#_skew_status
  *
- * CGX SPU SerDes Lane Skew Status Registers
- * This register provides SerDes lane skew status. One register per physical SerDes lane.
+ * CGX SPU SerDes Lane Skew Status Registers This register provides
+ * SerDes lane skew status. One register per physical SerDes lane.
  */
 union cavm_cgxx_spu_sdsx_skew_status {
 	u64 u;
@@ -7812,8 +7641,8 @@ static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
 /**
  * Register (RSL) cgx#_spu_sds#_states
  *
- * CGX SPU SerDes States Registers
- * This register provides SerDes lane states. One register per physical SerDes lane.
+ * CGX SPU SerDes States Registers This register provides SerDes lane
+ * states. One register per physical SerDes lane.
  */
 union cavm_cgxx_spu_sdsx_states {
 	u64 u;
@@ -7852,10 +7681,11 @@ static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
 /**
  * Register (RSL) cgx#_spu_usxgmii_control
  *
- * CGX SPU Common USXGMII Control Register
- * This register is the common control register that enables USXGMII Mode. The fields
- * in this register are preserved across any LMAC soft-resets. For an LMAC in soft-
- * reset state in USXGMII mode, the CGX will transmit Remote Fault BASE-R blocks.
+ * CGX SPU Common USXGMII Control Register This register is the common
+ * control register that enables USXGMII Mode. The fields in this
+ * register are preserved across any LMAC soft-resets. For an LMAC in
+ * soft- reset state in USXGMII mode, the CGX will transmit Remote Fault
+ * BASE-R blocks.
  */
 union cavm_cgxx_spu_usxgmii_control {
 	u64 u;
diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-lmt.h b/drivers/net/cavium/octeontx2/cavm-csrs-lmt.h
index 9c4451530e..948606f8b8 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-lmt.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-lmt.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_LMT_H__
 #define __CAVM_CSRS_LMT_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,7 +14,7 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium LMT.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-nix.h b/drivers/net/cavium/octeontx2/cavm-csrs-nix.h
index a8e0a52fe3..a93e033664 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-nix.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-nix.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_NIX_H__
 #define __CAVM_CSRS_NIX_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,15 +14,15 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium NIX.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
 /**
  * Enumeration nix_af_int_vec_e
  *
- * NIX Admin Function Interrupt Vector Enumeration
- * Enumerates the NIX AF MSI-X interrupt vectors.
+ * NIX Admin Function Interrupt Vector Enumeration Enumerates the NIX AF
+ * MSI-X interrupt vectors.
  */
 #define CAVM_NIX_AF_INT_VEC_E_AF_ERR (3)
 #define CAVM_NIX_AF_INT_VEC_E_AQ_DONE (2)
@@ -66,8 +33,8 @@
 /**
  * Enumeration nix_aq_comp_e
  *
- * NIX Completion Enumeration
- * Enumerates the values of NIX_AQ_RES_S[COMPCODE].
+ * NIX Completion Enumeration Enumerates the values of
+ * NIX_AQ_RES_S[COMPCODE].
  */
 #define CAVM_NIX_AQ_COMP_E_CTX_FAULT (4)
 #define CAVM_NIX_AQ_COMP_E_CTX_POISON (3)
@@ -80,8 +47,7 @@
 /**
  * Enumeration nix_aq_ctype_e
  *
- * NIX Context Type Enumeration
- * Enumerates NIX_AQ_INST_S[CTYPE] values.
+ * NIX Context Type Enumeration Enumerates NIX_AQ_INST_S[CTYPE] values.
  */
 #define CAVM_NIX_AQ_CTYPE_E_CQ (2)
 #define CAVM_NIX_AQ_CTYPE_E_DYNO (5)
@@ -93,8 +59,8 @@
 /**
  * Enumeration nix_aq_instop_e
  *
- * NIX Admin Queue Opcode Enumeration
- * Enumerates NIX_AQ_INST_S[OP] values.
+ * NIX Admin Queue Opcode Enumeration Enumerates NIX_AQ_INST_S[OP]
+ * values.
  */
 #define CAVM_NIX_AQ_INSTOP_E_INIT (1)
 #define CAVM_NIX_AQ_INSTOP_E_LOCK (4)
@@ -106,14 +72,12 @@
 /**
  * Enumeration nix_chan_e
  *
- * NIX Channel Number Enumeration
- * Enumerates the receive and transmit channels, and values of
- * NIX_RX_PARSE_S[CHAN], NIX_SQ_CTX_S[DEFAULT_CHAN]. CNXXXX implements a subset of
- * these channels. Specifically, only channels for links enumerated by NIX_LINK_E
- * are implemented.
- *
- * Internal:
- * P2X/X2P channel enumeration for t9x.
+ * NIX Channel Number Enumeration Enumerates the receive and transmit
+ * channels, and values of NIX_RX_PARSE_S[CHAN],
+ * NIX_SQ_CTX_S[DEFAULT_CHAN]. CNXXXX implements a subset of these
+ * channels. Specifically, only channels for links enumerated by
+ * NIX_LINK_E are implemented.  Internal: P2X/X2P channel enumeration for
+ * t9x.
  */
 #define CAVM_NIX_CHAN_E_CGXX_LMACX_CHX(a, b, c)	\
 	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
@@ -124,9 +88,9 @@
 /**
  * Enumeration nix_colorresult_e
  *
- * NIX Color Result Enumeration
- * Enumerates the values of NIX_MEM_RESULT_S[COLOR], NIX_AF_TL1()_MD_DEBUG1[COLOR]
- * and NIX_AF_TL1()_MD_DEBUG1[COLOR].
+ * NIX Color Result Enumeration Enumerates the values of
+ * NIX_MEM_RESULT_S[COLOR], NIX_AF_TL1()_MD_DEBUG1[COLOR] and
+ * NIX_AF_TL1()_MD_DEBUG1[COLOR].
  */
 #define CAVM_NIX_COLORRESULT_E_GREEN (0)
 #define CAVM_NIX_COLORRESULT_E_RED_DROP (3)
@@ -136,8 +100,8 @@
 /**
  * Enumeration nix_cqerrint_e
  *
- * NIX Completion Queue Interrupt Enumeration
- * Enumerates the bit index of NIX_CQ_CTX_S[CQ_ERR_INT,CQ_ERR_INT_ENA].
+ * NIX Completion Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_CQ_CTX_S[CQ_ERR_INT,CQ_ERR_INT_ENA].
  */
 #define CAVM_NIX_CQERRINT_E_CQE_FAULT (2)
 #define CAVM_NIX_CQERRINT_E_DOOR_ERR (0)
@@ -146,8 +110,8 @@
 /**
  * Enumeration nix_intf_e
  *
- * NIX Interface Number Enumeration
- * Enumerates the bit index of NIX_AF_STATUS[CALIBRATE_STATUS].
+ * NIX Interface Number Enumeration Enumerates the bit index of
+ * NIX_AF_STATUS[CALIBRATE_STATUS].
  */
 #define CAVM_NIX_INTF_E_CGXX(a) (0 + (a))
 #define CAVM_NIX_INTF_E_LBKX(a) (3 + (a))
@@ -156,8 +120,8 @@
 /**
  * Enumeration nix_lf_int_vec_e
  *
- * NIX Local Function Interrupt Vector Enumeration
- * Enumerates the NIX MSI-X interrupt vectors per LF.
+ * NIX Local Function Interrupt Vector Enumeration Enumerates the NIX
+ * MSI-X interrupt vectors per LF.
  */
 #define CAVM_NIX_LF_INT_VEC_E_CINTX(a) (0x40 + (a))
 #define CAVM_NIX_LF_INT_VEC_E_ERR_INT (0x81)
@@ -168,9 +132,8 @@
 /**
  * Enumeration nix_link_e
  *
- * NIX Link Number Enumeration
- * Enumerates the receive and transmit links, and LINK index of
- * NIX_AF_RX_LINK()_CFG, NIX_AF_RX_LINK()_WRR_CFG,
+ * NIX Link Number Enumeration Enumerates the receive and transmit links,
+ * and LINK index of NIX_AF_RX_LINK()_CFG, NIX_AF_RX_LINK()_WRR_CFG,
  * NIX_AF_TX_LINK()_NORM_CREDIT, NIX_AF_TX_LINK()_EXPR_CREDIT,
  * NIX_AF_TX_LINK()_HW_XOFF and NIX_AF_TX_LINK()_SW_XOFF,
  * NIX_AF_TL3_TL2()_LINK()_CFG.
@@ -183,8 +146,8 @@
 /**
  * Enumeration nix_lsoalg_e
  *
- * NIX Large Send Offload Algorithm Enumeration
- * Enumerates NIX_AF_LSO_FORMAT()_FIELD()[ALG] values. Specifies algorithm for
+ * NIX Large Send Offload Algorithm Enumeration Enumerates
+ * NIX_AF_LSO_FORMAT()_FIELD()[ALG] values. Specifies algorithm for
  * modifying the associated LSO packet field.
  */
 #define CAVM_NIX_LSOALG_E_ADD_OFFSET (3)
@@ -196,8 +159,8 @@
 /**
  * Enumeration nix_maxsqesz_e
  *
- * NIX Maximum SQE Size Enumeration
- * Enumerates the values of NIX_SQ_CTX_S[MAX_SQE_SIZE].
+ * NIX Maximum SQE Size Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[MAX_SQE_SIZE].
  */
 #define CAVM_NIX_MAXSQESZ_E_W16 (0)
 #define CAVM_NIX_MAXSQESZ_E_W8 (1)
@@ -205,8 +168,8 @@
 /**
  * Enumeration nix_mdtype_e
  *
- * NIX Meta Descriptor Type Enumeration
- * Enumerates values of NIX_AF_MDQ()_MD_DEBUG[MD_TYPE].
+ * NIX Meta Descriptor Type Enumeration Enumerates values of
+ * NIX_AF_MDQ()_MD_DEBUG[MD_TYPE].
  */
 #define CAVM_NIX_MDTYPE_E_FLUSH (1)
 #define CAVM_NIX_MDTYPE_E_PMD (2)
@@ -215,8 +178,8 @@
 /**
  * Enumeration nix_mnqerr_e
  *
- * NIX Meta-Descriptor Enqueue Error Enumeration
- * Enumerates NIX_LF_MNQ_ERR_DBG[ERRCODE] values.
+ * NIX Meta-Descriptor Enqueue Error Enumeration Enumerates
+ * NIX_LF_MNQ_ERR_DBG[ERRCODE] values.
  */
 #define CAVM_NIX_MNQERR_E_CQ_QUERY_ERR (6)
 #define CAVM_NIX_MNQERR_E_LSO_ERR (5)
@@ -232,8 +195,8 @@
 /**
  * Enumeration nix_ndc_rx_port_e
  *
- * NIX Receive NDC Port Enumeration
- * Enumerates NIX receive NDC (NDC_IDX_E::NIX()_RX) ports and the PORT index of
+ * NIX Receive NDC Port Enumeration Enumerates NIX receive NDC
+ * (NDC_IDX_E::NIX()_RX) ports and the PORT index of
  * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
 #define CAVM_NIX_NDC_RX_PORT_E_AQ (0)
@@ -246,8 +209,8 @@
 /**
  * Enumeration nix_ndc_tx_port_e
  *
- * NIX Transmit NDC Port Enumeration
- * Enumerates NIX transmit NDC (NDC_IDX_E::NIX()_TX) ports and the PORT index of
+ * NIX Transmit NDC Port Enumeration Enumerates NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX) ports and the PORT index of
  * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
 #define CAVM_NIX_NDC_TX_PORT_E_DEQ (3)
@@ -260,8 +223,8 @@
 /**
  * Enumeration nix_re_opcode_e
  *
- * NIX Receive Error Opcode Enumeration
- * Enumerates NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NIX Receive Error Opcode Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
  * NPC_ERRLEV_E::RE.
  */
 #define CAVM_NIX_RE_OPCODE_E_OL2_LENMISM (0x12)
@@ -280,8 +243,8 @@
 /**
  * Enumeration nix_redalg_e
  *
- * NIX Red Algorithm Enumeration
- * Enumerates the different algorithms of NIX_SEND_EXT_S[SHP_RA].
+ * NIX Red Algorithm Enumeration Enumerates the different algorithms of
+ * NIX_SEND_EXT_S[SHP_RA].
  */
 #define CAVM_NIX_REDALG_E_DISCARD (3)
 #define CAVM_NIX_REDALG_E_SEND (1)
@@ -291,8 +254,8 @@
 /**
  * Enumeration nix_rqint_e
  *
- * NIX Receive Queue Interrupt Enumeration
- * Enumerates the bit index of NIX_RQ_CTX_S[RQ_INT,RQ_INT_ENA].
+ * NIX Receive Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_RQ_CTX_S[RQ_INT,RQ_INT_ENA].
  */
 #define CAVM_NIX_RQINT_E_DROP (0)
 #define CAVM_NIX_RQINT_E_RX(a) (0 + (a))
@@ -301,8 +264,8 @@
 /**
  * Enumeration nix_rx_actionop_e
  *
- * NIX Receive Action Opcode Enumeration
- * Enumerates the values of NIX_RX_ACTION_S[OP].
+ * NIX Receive Action Opcode Enumeration Enumerates the values of
+ * NIX_RX_ACTION_S[OP].
  */
 #define CAVM_NIX_RX_ACTIONOP_E_DROP (0)
 #define CAVM_NIX_RX_ACTIONOP_E_MCAST (3)
@@ -315,8 +278,8 @@
 /**
  * Enumeration nix_rx_mcop_e
  *
- * NIX Receive Multicast/Mirror Opcode Enumeration
- * Enumerates the values of NIX_RX_MCE_S[OP].
+ * NIX Receive Multicast/Mirror Opcode Enumeration Enumerates the values
+ * of NIX_RX_MCE_S[OP].
  */
 #define CAVM_NIX_RX_MCOP_E_RQ (0)
 #define CAVM_NIX_RX_MCOP_E_RSS (1)
@@ -324,8 +287,8 @@
 /**
  * Enumeration nix_rx_perrcode_e
  *
- * NIX Receive Protocol Error Code Enumeration
- * Enumerates NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NIX Receive Protocol Error Code Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
  * NPC_ERRLEV_E::NIX.
  */
 #define CAVM_NIX_RX_PERRCODE_E_BUFS_OFLOW (0xa)
@@ -348,8 +311,8 @@
 /**
  * Enumeration nix_send_status_e
  *
- * NIX Send Completion Status Enumeration
- * Enumerates values of NIX_SEND_COMP_S[STATUS] and NIX_LF_SEND_ERR_DBG[ERRCODE].
+ * NIX Send Completion Status Enumeration Enumerates values of
+ * NIX_SEND_COMP_S[STATUS] and NIX_LF_SEND_ERR_DBG[ERRCODE].
  */
 #define CAVM_NIX_SEND_STATUS_E_DATA_FAULT (0x16)
 #define CAVM_NIX_SEND_STATUS_E_DATA_POISON (0x17)
@@ -380,8 +343,8 @@
 /**
  * Enumeration nix_sendcrcalg_e
  *
- * NIX Send CRC Algorithm Enumeration
- * Enumerates the CRC algorithm used, see NIX_SEND_CRC_S[ALG].
+ * NIX Send CRC Algorithm Enumeration Enumerates the CRC algorithm used,
+ * see NIX_SEND_CRC_S[ALG].
  */
 #define CAVM_NIX_SENDCRCALG_E_CRC32 (0)
 #define CAVM_NIX_SENDCRCALG_E_CRC32C (1)
@@ -390,19 +353,12 @@
 /**
  * Enumeration nix_sendl3type_e
  *
- * NIX Send Layer 3 Header Type Enumeration
- * Enumerates values of NIX_SEND_HDR_S[OL3TYPE], NIX_SEND_HDR_S[IL3TYPE].
- * Internal:
- * Encoding matches DPDK TX IP types:
- * \<pre\>
- * PKT_TX_IP_CKSUM      (1ULL \<\< 54)
- * PKT_TX_IPV4          (1ULL \<\< 55)
- * PKT_TX_IPV6          (1ULL \<\< 56)
- *
- * PKT_TX_OUTER_IP_CKSUM(1ULL \<\< 58)
- * PKT_TX_OUTER_IPV4    (1ULL \<\< 59)
- * PKT_TX_OUTER_IPV6    (1ULL \<\< 60)
- * \</pre\>
+ * NIX Send Layer 3 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL3TYPE], NIX_SEND_HDR_S[IL3TYPE]. Internal: Encoding
+ * matches DPDK TX IP types: \<pre\> PKT_TX_IP_CKSUM      (1ULL \<\< 54)
+ * PKT_TX_IPV4          (1ULL \<\< 55) PKT_TX_IPV6          (1ULL \<\<
+ * 56)  PKT_TX_OUTER_IP_CKSUM(1ULL \<\< 58) PKT_TX_OUTER_IPV4    (1ULL
+ * \<\< 59) PKT_TX_OUTER_IPV6    (1ULL \<\< 60) \</pre\>
  */
 #define CAVM_NIX_SENDL3TYPE_E_IP4 (2)
 #define CAVM_NIX_SENDL3TYPE_E_IP4_CKSUM (3)
@@ -412,16 +368,13 @@
 /**
  * Enumeration nix_sendl4type_e
  *
- * NIX Send Layer 4 Header Type Enumeration
- * Enumerates values of NIX_SEND_HDR_S[OL4TYPE], NIX_SEND_HDR_S[IL4TYPE].
- * Internal:
- * Encoding matches DPDK TX L4 types.
- * \<pre\>
- * PKT_TX_L4_NO_CKSUM   (0ULL \<\< 52)  // Disable L4 cksum of TX pkt.
- * PKT_TX_TCP_CKSUM     (1ULL \<\< 52)  // TCP cksum of TX pkt. computed by nic.
- * PKT_TX_SCTP_CKSUM    (2ULL \<\< 52)  // SCTP cksum of TX pkt. computed by nic.
- * PKT_TX_UDP_CKSUM     (3ULL \<\< 52)  // UDP cksum of TX pkt. computed by nic.
- * \</pre\>
+ * NIX Send Layer 4 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL4TYPE], NIX_SEND_HDR_S[IL4TYPE]. Internal: Encoding
+ * matches DPDK TX L4 types. \<pre\> PKT_TX_L4_NO_CKSUM   (0ULL \<\< 52)
+ * // Disable L4 cksum of TX pkt. PKT_TX_TCP_CKSUM     (1ULL \<\< 52)  //
+ * TCP cksum of TX pkt. computed by nic. PKT_TX_SCTP_CKSUM    (2ULL \<\<
+ * 52)  // SCTP cksum of TX pkt. computed by nic. PKT_TX_UDP_CKSUM
+ * (3ULL \<\< 52)  // UDP cksum of TX pkt. computed by nic. \</pre\>
  */
 #define CAVM_NIX_SENDL4TYPE_E_NONE (0)
 #define CAVM_NIX_SENDL4TYPE_E_SCTP_CKSUM (2)
@@ -431,12 +384,10 @@
 /**
  * Enumeration nix_sendldtype_e
  *
- * NIX Send Load Type Enumeration
- * Enumerates the load transaction types for reading segment bytes specified by
- * NIX_SEND_SG_S[LD_TYPE] and NIX_SEND_JUMP_S[LD_TYPE].
- *
- * Internal:
- * The hardware implementation treats undefined encodings as LDD load type.
+ * NIX Send Load Type Enumeration Enumerates the load transaction types
+ * for reading segment bytes specified by NIX_SEND_SG_S[LD_TYPE] and
+ * NIX_SEND_JUMP_S[LD_TYPE].  Internal: The hardware implementation
+ * treats undefined encodings as LDD load type.
  */
 #define CAVM_NIX_SENDLDTYPE_E_LDD (0)
 #define CAVM_NIX_SENDLDTYPE_E_LDT (1)
@@ -445,10 +396,10 @@
 /**
  * Enumeration nix_sendmemalg_e
  *
- * NIX Memory Modify Algorithm Enumeration
- * Enumerates the different algorithms for modifying memory; see
- * NIX_SEND_MEM_S[ALG]. mbufs_freed is the number of gather buffers freed to NPA
- * for the send descriptor. See NIX_SEND_HDR_S[DF] and NIX_SEND_SG_S[I*].
+ * NIX Memory Modify Algorithm Enumeration Enumerates the different
+ * algorithms for modifying memory; see NIX_SEND_MEM_S[ALG]. mbufs_freed
+ * is the number of gather buffers freed to NPA for the send descriptor.
+ * See NIX_SEND_HDR_S[DF] and NIX_SEND_SG_S[I*].
  */
 #define CAVM_NIX_SENDMEMALG_E_ADD (8)
 #define CAVM_NIX_SENDMEMALG_E_ADDLEN (0xa)
@@ -463,8 +414,8 @@
 /**
  * Enumeration nix_sendmemdsz_e
  *
- * NIX Memory Data Size Enumeration
- * Enumerates the datum size for modifying memory; see NIX_SEND_MEM_S[DSZ].
+ * NIX Memory Data Size Enumeration Enumerates the datum size for
+ * modifying memory; see NIX_SEND_MEM_S[DSZ].
  */
 #define CAVM_NIX_SENDMEMDSZ_E_B16 (2)
 #define CAVM_NIX_SENDMEMDSZ_E_B32 (1)
@@ -474,8 +425,8 @@
 /**
  * Enumeration nix_sqint_e
  *
- * NIX Send Queue Interrupt Enumeration
- * Enumerates the bit index of NIX_SQ_CTX_S[SQ_INT,SQ_INT_ENA].
+ * NIX Send Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_SQ_CTX_S[SQ_INT,SQ_INT_ENA].
  */
 #define CAVM_NIX_SQINT_E_LMT_ERR (0)
 #define CAVM_NIX_SQINT_E_MNQ_ERR (1)
@@ -485,8 +436,8 @@
 /**
  * Enumeration nix_sqoperr_e
  *
- * NIX SQ Operation Error Enumeration
- * Enumerates NIX_LF_SQ_OP_ERR_DBG[ERRCODE] values.
+ * NIX SQ Operation Error Enumeration Enumerates
+ * NIX_LF_SQ_OP_ERR_DBG[ERRCODE] values.
  */
 #define CAVM_NIX_SQOPERR_E_MAX_SQE_SIZE_ERR (4)
 #define CAVM_NIX_SQOPERR_E_SQB_FAULT (7)
@@ -501,8 +452,8 @@
 /**
  * Enumeration nix_stat_lf_rx_e
  *
- * NIX Local Function Receive Statistics Enumeration
- * Enumerates the last index of NIX_AF_LF()_RX_STAT() and NIX_LF_RX_STAT().
+ * NIX Local Function Receive Statistics Enumeration Enumerates the last
+ * index of NIX_AF_LF()_RX_STAT() and NIX_LF_RX_STAT().
  */
 #define CAVM_NIX_STAT_LF_RX_E_RX_BCAST (2)
 #define CAVM_NIX_STAT_LF_RX_E_RX_DROP (4)
@@ -520,10 +471,10 @@
 /**
  * Enumeration nix_stat_lf_tx_e
  *
- * NIX Local Function Transmit Statistics Enumeration
- * Enumerates the index of NIX_AF_LF()_TX_STAT() and NIX_LF_TX_STAT().
- * These statistics do not account for packet replication due to
- * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ * NIX Local Function Transmit Statistics Enumeration Enumerates the
+ * index of NIX_AF_LF()_TX_STAT() and NIX_LF_TX_STAT(). These statistics
+ * do not account for packet replication due to NIX_TX_ACTION_S[OP] =
+ * NIX_TX_ACTIONOP_E::MCAST.
  */
 #define CAVM_NIX_STAT_LF_TX_E_TX_BCAST (1)
 #define CAVM_NIX_STAT_LF_TX_E_TX_DROP (3)
@@ -534,8 +485,8 @@
 /**
  * Enumeration nix_stype_e
  *
- * NIX SQB Caching Type Enumeration
- * Enumerates the values of NIX_SQ_CTX_S[SQE_STYPE].
+ * NIX SQB Caching Type Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[SQE_STYPE].
  */
 #define CAVM_NIX_STYPE_E_STF (0)
 #define CAVM_NIX_STYPE_E_STP (2)
@@ -544,12 +495,12 @@
 /**
  * Enumeration nix_subdc_e
  *
- * NIX Subdescriptor Operation Enumeration
- * Enumerates send and receive subdescriptor codes. The codes differentiate
- * subdescriptors within a NIX send or receive descriptor, excluding NIX_SEND_HDR_S for
- * send and NIX_CQE_HDR_S/NIX_WQE_HDR_S for receive, which are determined by their
- * position as the first subdescriptor, and NIX_RX_PARSE_S, which is determined by its
- * position as the second subdescriptor.
+ * NIX Subdescriptor Operation Enumeration Enumerates send and receive
+ * subdescriptor codes. The codes differentiate subdescriptors within a
+ * NIX send or receive descriptor, excluding NIX_SEND_HDR_S for send and
+ * NIX_CQE_HDR_S/NIX_WQE_HDR_S for receive, which are determined by their
+ * position as the first subdescriptor, and NIX_RX_PARSE_S, which is
+ * determined by its position as the second subdescriptor.
  */
 #define CAVM_NIX_SUBDC_E_CRC (2)
 #define CAVM_NIX_SUBDC_E_EXT (1)
@@ -564,8 +515,8 @@
 /**
  * Enumeration nix_tx_actionop_e
  *
- * NIX Transmit Action Opcode Enumeration
- * Enumerates the values of NIX_TX_ACTION_S[OP].
+ * NIX Transmit Action Opcode Enumeration Enumerates the values of
+ * NIX_TX_ACTION_S[OP].
  */
 #define CAVM_NIX_TX_ACTIONOP_E_DROP (0)
 #define CAVM_NIX_TX_ACTIONOP_E_DROP_VIOL (5)
@@ -576,8 +527,8 @@
 /**
  * Enumeration nix_tx_vtagop_e
  *
- * NIX Transmit Vtag Opcode Enumeration
- * Enumerates the values of NIX_TX_VTAG_ACTION_S[VTAG0_OP,VTAG1_OP].
+ * NIX Transmit Vtag Opcode Enumeration Enumerates the values of
+ * NIX_TX_VTAG_ACTION_S[VTAG0_OP,VTAG1_OP].
  */
 #define CAVM_NIX_TX_VTAGOP_E_INSERT (1)
 #define CAVM_NIX_TX_VTAGOP_E_NOP (0)
@@ -586,8 +537,8 @@
 /**
  * Enumeration nix_txlayer_e
  *
- * NIX Transmit Layer Enumeration
- * Enumerates the values of NIX_AF_LSO_FORMAT()_FIELD()[LAYER].
+ * NIX Transmit Layer Enumeration Enumerates the values of
+ * NIX_AF_LSO_FORMAT()_FIELD()[LAYER].
  */
 #define CAVM_NIX_TXLAYER_E_IL3 (2)
 #define CAVM_NIX_TXLAYER_E_IL4 (3)
@@ -597,8 +548,8 @@
 /**
  * Enumeration nix_vtagsize_e
  *
- * NIX Vtag Size Enumeration
- * Enumerates the values of NIX_AF_TX_VTAG_DEF()_CTL[SIZE] and NIX_AF_LF()_RX_VTAG_TYPE()[SIZE].
+ * NIX Vtag Size Enumeration Enumerates the values of
+ * NIX_AF_TX_VTAG_DEF()_CTL[SIZE] and NIX_AF_LF()_RX_VTAG_TYPE()[SIZE].
  */
 #define CAVM_NIX_VTAGSIZE_E_T4 (0)
 #define CAVM_NIX_VTAGSIZE_E_T8 (1)
@@ -606,8 +557,8 @@
 /**
  * Enumeration nix_xqe_type_e
  *
- * NIX WQE/CQE Type Enumeration
- * Enumerates the values of NIX_WQE_HDR_S[WQE_TYPE], NIX_CQE_HDR_S[CQE_TYPE].
+ * NIX WQE/CQE Type Enumeration Enumerates the values of
+ * NIX_WQE_HDR_S[WQE_TYPE], NIX_CQE_HDR_S[CQE_TYPE].
  */
 #define CAVM_NIX_XQE_TYPE_E_INVALID (0)
 #define CAVM_NIX_XQE_TYPE_E_RX (1)
@@ -619,8 +570,8 @@
 /**
  * Enumeration nix_xqesz_e
  *
- * NIX WQE/CQE Size Enumeration
- * Enumerates the values of NIX_AF_LF()_CFG[XQE_SIZE].
+ * NIX WQE/CQE Size Enumeration Enumerates the values of
+ * NIX_AF_LF()_CFG[XQE_SIZE].
  */
 #define CAVM_NIX_XQESZ_E_W16 (1)
 #define CAVM_NIX_XQESZ_E_W64 (0)
@@ -628,19 +579,15 @@
 /**
  * Structure nix_aq_inst_s
  *
- * NIX Admin Queue Instruction Structure
- * This structure specifies the AQ instruction.
- * Instructions and associated software structures are stored in memory as
- * little-endian unless NIX_AF_CFG[AF_BE] is set.
- *
- * Hardware reads of NIX_AQ_INST_S do not allocate into LLC.
- *
- * Hardware reads and writes of the context structure selected by [CTYPE], [LF]
- * and [CINDEX] use the NDC and LLC caching style configured for that context. For
- * example:
- * * When [CTYPE] = NIX_AQ_CTYPE_E::RQ: use NIX_AF_LF()_RSS_CFG[CACHING] and
- * NIX_AF_LF()_RSS_CFG[WAY_MASK].
- * * When [CTYPE] = NIX_AQ_CTYPE_E::MCE: use NIX_AF_RX_MCAST_CFG[CACHING] and
+ * NIX Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
+ * Hardware reads of NIX_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context. For example: * When [CTYPE] = NIX_AQ_CTYPE_E::RQ: use
+ * NIX_AF_LF()_RSS_CFG[CACHING] and NIX_AF_LF()_RSS_CFG[WAY_MASK]. * When
+ * [CTYPE] = NIX_AQ_CTYPE_E::MCE: use NIX_AF_RX_MCAST_CFG[CACHING] and
  * NIX_AF_RX_MCAST_CFG[WAY_MASK].
  */
 union cavm_nix_aq_inst_s {
@@ -661,19 +608,16 @@ union cavm_nix_aq_inst_s {
 /**
  * Structure nix_aq_res_s
  *
- * NIX Admin Queue Result Structure
- * NIX writes this structure after it completes the NIX_AQ_INST_S instruction.
- * The result structure is exactly 16 bytes, and each instruction completion produces
- * exactly one result structure.
- *
- * Results and associated software structures are stored in memory as
- * little-endian unless NIX_AF_CFG[AF_BE] is set.
- *
+ * NIX Admin Queue Result Structure NIX writes this structure after it
+ * completes the NIX_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
  * When [OP] = NIX_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
- * immediately followed by context read or write data. See NIX_AQ_INSTOP_E.
- *
- * Hardware writes of NIX_AQ_RES_S and context data always allocate into LLC.
- * Hardware reads of context data do not allocate into LLC.
+ * immediately followed by context read or write data. See
+ * NIX_AQ_INSTOP_E.  Hardware writes of NIX_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
  */
 union cavm_nix_aq_res_s {
 	u64 u[2];
@@ -691,13 +635,13 @@ union cavm_nix_aq_res_s {
 /**
  * Structure nix_cint_hw_s
  *
- * NIX Completion Interrupt Context Hardware Structure
- * This structure contains context state maintained by hardware for each
- * completion interrupt (CINT) in NDC/LLC/DRAM. Software accesses this structure
- * with the NIX_LF_CINT()* registers.
- * Hardware maintains a table of NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S
- * structures per LF starting at AF IOVA NIX_AF_LF()_CINTS_BASE.
- * Always stored in byte invariant little-endian format (LE8).
+ * NIX Completion Interrupt Context Hardware Structure This structure
+ * contains context state maintained by hardware for each completion
+ * interrupt (CINT) in NDC/LLC/DRAM. Software accesses this structure
+ * with the NIX_LF_CINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures per LF
+ * starting at AF IOVA NIX_AF_LF()_CINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
  */
 union cavm_nix_cint_hw_s {
 	u64 u[2];
@@ -719,10 +663,9 @@ union cavm_nix_cint_hw_s {
 /**
  * Structure nix_cq_ctx_s
  *
- * NIX Completion Queue Context Structure
- * This structure contains context state maintained by hardware for each CQ in
- * NDC/LLC/DRAM.
- * Software uses the same structure format to read and write an CQ context with
+ * NIX Completion Queue Context Structure This structure contains context
+ * state maintained by hardware for each CQ in NDC/LLC/DRAM. Software
+ * uses the same structure format to read and write an CQ context with
  * the NIX admin queue.
  */
 union cavm_nix_cq_ctx_s {
@@ -761,11 +704,11 @@ union cavm_nix_cq_ctx_s {
 /**
  * Structure nix_cqe_hdr_s
  *
- * NIX Completion Queue Entry Header Structure
- * This 64-bit structure defines the first word of every CQE. It is immediately
- * followed by NIX_RX_PARSE_S in a receive CQE, and by NIX_SEND_COMP_S in a send
- * completion CQE.
- * Stored in memory as little-endian unless NIX_AF_LF()_CFG[BE] is set.
+ * NIX Completion Queue Entry Header Structure This 64-bit structure
+ * defines the first word of every CQE. It is immediately followed by
+ * NIX_RX_PARSE_S in a receive CQE, and by NIX_SEND_COMP_S in a send
+ * completion CQE. Stored in memory as little-endian unless
+ * NIX_AF_LF()_CFG[BE] is set.
  */
 union cavm_nix_cqe_hdr_s {
 	u64 u;
@@ -782,9 +725,9 @@ union cavm_nix_cqe_hdr_s {
 /**
  * Structure nix_inst_hdr_s
  *
- * NIX Instruction Header Structure
- * This structure defines the instruction header that precedes the packet header
- * supplied to NPC for packets to be transmitted by NIX.
+ * NIX Instruction Header Structure This structure defines the
+ * instruction header that precedes the packet header supplied to NPC for
+ * packets to be transmitted by NIX.
  */
 union cavm_nix_inst_hdr_s {
 	u64 u;
@@ -812,10 +755,10 @@ union cavm_nix_iova_s {
 /**
  * Structure nix_ipsec_dyno_s
  *
- * NIX IPSEC Dynamic Ordering Counter Structure
- * This structure specifies the format of an IPSEC dynamic ordering (DYNO) counter
- * in NDC/LLC/DRAM. See NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA].
- * Software uses the same structure format to read and write a DYNO counter with
+ * NIX IPSEC Dynamic Ordering Counter Structure This structure specifies
+ * the format of an IPSEC dynamic ordering (DYNO) counter in
+ * NDC/LLC/DRAM. See NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA]. Software
+ * uses the same structure format to read and write a DYNO counter with
  * the NIX admin queue.
  */
 union cavm_nix_ipsec_dyno_s {
@@ -829,9 +772,9 @@ union cavm_nix_ipsec_dyno_s {
 /**
  * Structure nix_mem_result_s
  *
- * NIX Memory Value Structure
- * When NIX_SEND_MEM_S[ALG]=NIX_SENDMEMALG_E::SETRSLT, the value written to memory is formed with
- * this structure.
+ * NIX Memory Value Structure When
+ * NIX_SEND_MEM_S[ALG]=NIX_SENDMEMALG_E::SETRSLT, the value written to
+ * memory is formed with this structure.
  */
 union cavm_nix_mem_result_s {
 	u64 u;
@@ -846,9 +789,9 @@ union cavm_nix_mem_result_s {
 /**
  * Structure nix_op_q_wdata_s
  *
- * NIX Statistics Operation Write Data Structure
- * This structure specifies the write data format of an atomic 64-bit load-and-add
- * of some NIX_LF_RQ_OP_*, NIX_LF_SQ_OP* and NIX_LF_CQ_OP* registers.
+ * NIX Statistics Operation Write Data Structure This structure specifies
+ * the write data format of an atomic 64-bit load-and-add of some
+ * NIX_LF_RQ_OP_*, NIX_LF_SQ_OP* and NIX_LF_CQ_OP* registers.
  */
 union cavm_nix_op_q_wdata_s {
 	u64 u;
@@ -863,13 +806,13 @@ union cavm_nix_op_q_wdata_s {
 /**
  * Structure nix_qint_hw_s
  *
- * NIX Queue Interrupt Context Hardware Structure
- * This structure contains context state maintained by hardware for each queue
- * interrupt (QINT) in NDC/LLC/DRAM. Software accesses this structure with the
- * NIX_LF_QINT()* registers.
- * Hardware maintains a table of NIX_AF_CONST2[QINTS] contiguous NIX_QINT_HW_S
- * structures per LF starting at IOVA NIX_AF_LF()_QINTS_BASE.
- * Always stored in byte invariant little-endian format (LE8).
+ * NIX Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NIX_LF_QINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[QINTS] contiguous NIX_QINT_HW_S structures per LF
+ * starting at IOVA NIX_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
  */
 union cavm_nix_qint_hw_s {
 	u32 u;
@@ -884,11 +827,11 @@ union cavm_nix_qint_hw_s {
 /**
  * Structure nix_rq_ctx_hw_s
  *
- * NIX Receive Queue Context Structure
- * This structure contains context state maintained by hardware for each RQ in
- * NDC/LLC/DRAM. Software uses the equivalent NIX_RQ_CTX_S structure format to
- * read and write an RQ context with the NIX admin queue.
- * Always stored in byte invariant little-endian format (LE8).
+ * NIX Receive Queue Context Structure This structure contains context
+ * state maintained by hardware for each RQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_RQ_CTX_S structure format to read and write an
+ * RQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
  */
 union cavm_nix_rq_ctx_hw_s {
 	u64 u[16];
@@ -968,9 +911,9 @@ union cavm_nix_rq_ctx_hw_s {
 /**
  * Structure nix_rq_ctx_s
  *
- * NIX Receive Queue Context Structure
- * This structure specifies the format used by software to read and write an RQ context with
- * the NIX admin queue.
+ * NIX Receive Queue Context Structure This structure specifies the
+ * format used by software to read and write an RQ context with the NIX
+ * admin queue.
  */
 union cavm_nix_rq_ctx_s {
 	u64 u[16];
@@ -1049,11 +992,11 @@ union cavm_nix_rq_ctx_s {
 /**
  * Structure nix_rsse_s
  *
- * NIX Receive Side Scaling Entry Structure
- * This structure specifies the format of each hardware entry in the NIX RSS
- * tables in NDC/LLC/DRAM. See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
- * Software uses the same structure format to read and write an RSS table entry
- * with the NIX admin queue.
+ * NIX Receive Side Scaling Entry Structure This structure specifies the
+ * format of each hardware entry in the NIX RSS tables in NDC/LLC/DRAM.
+ * See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP(). Software uses the
+ * same structure format to read and write an RSS table entry with the
+ * NIX admin queue.
  */
 union cavm_nix_rsse_s {
 	u32 u;
@@ -1067,8 +1010,8 @@ union cavm_nix_rsse_s {
 /**
  * Structure nix_rx_action_s
  *
- * NIX Receive Action Structure
- * This structure defines the format of NPC_RESULT_S[ACTION] for a receive packet.
+ * NIX Receive Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a receive packet.
  */
 union cavm_nix_rx_action_s {
 	u64 u;
@@ -1086,11 +1029,12 @@ union cavm_nix_rx_action_s {
 /**
  * Structure nix_rx_imm_s
  *
- * NIX Receive Immediate Subdescriptor Structure
- * The receive immediate subdescriptor indicates that bytes immediately following this
- * NIX_RX_IMM_S (after skipping [APAD] bytes) were saved from the received packet. The
- * next subdescriptor following this NIX_RX_IMM_S (when one exists) will follow the
- * immediate bytes, after rounding up the address to a multiple of 16 bytes.
+ * NIX Receive Immediate Subdescriptor Structure The receive immediate
+ * subdescriptor indicates that bytes immediately following this
+ * NIX_RX_IMM_S (after skipping [APAD] bytes) were saved from the
+ * received packet. The next subdescriptor following this NIX_RX_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.
  */
 union cavm_nix_rx_imm_s {
 	u64 u;
@@ -1106,13 +1050,13 @@ union cavm_nix_rx_imm_s {
 /**
  * Structure nix_rx_mce_s
  *
- * NIX Receive Multicast/Mirror Entry Structure
- * This structure specifies the format of entries in the NIX receive
- * multicast/mirror table maintained by hardware in NDC/LLC/DRAM. See
- * NIX_AF_RX_MCAST_BASE and NIX_AF_RX_MCAST_CFG. Note the table may contain both
- * multicast and mirror replication lists.
- * Software uses the same structure format to read and write a multicast/mirror
- * table entry with the NIX admin queue.
+ * NIX Receive Multicast/Mirror Entry Structure This structure specifies
+ * the format of entries in the NIX receive multicast/mirror table
+ * maintained by hardware in NDC/LLC/DRAM. See NIX_AF_RX_MCAST_BASE and
+ * NIX_AF_RX_MCAST_CFG. Note the table may contain both multicast and
+ * mirror replication lists. Software uses the same structure format to
+ * read and write a multicast/mirror table entry with the NIX admin
+ * queue.
  */
 union cavm_nix_rx_mce_s {
 	u64 u;
@@ -1131,13 +1075,12 @@ union cavm_nix_rx_mce_s {
 /**
  * Structure nix_rx_parse_s
  *
- * NIX Receive Parse Structure
- * This structure contains the receive packet parse result. It immediately follows
- * NIX_CQE_HDR_S in a receive CQE, or NIX_WQE_HDR_S in a receive WQE.
- * Stored in memory as little-endian unless NIX_AF_LF()_CFG[BE] is set.
- *
- * Header layers are always 2-byte aligned, so all header pointers in this
- * structure ([EOH_PTR], [LAPTR] through [LHPTR], [VTAG*_PTR]) are even.
+ * NIX Receive Parse Structure This structure contains the receive packet
+ * parse result. It immediately follows NIX_CQE_HDR_S in a receive CQE,
+ * or NIX_WQE_HDR_S in a receive WQE. Stored in memory as little-endian
+ * unless NIX_AF_LF()_CFG[BE] is set.  Header layers are always 2-byte
+ * aligned, so all header pointers in this structure ([EOH_PTR], [LAPTR]
+ * through [LHPTR], [VTAG*_PTR]) are even.
  */
 union cavm_nix_rx_parse_s {
 	u64 u[7];
@@ -1202,15 +1145,15 @@ union cavm_nix_rx_parse_s {
 /**
  * Structure nix_rx_sg_s
  *
- * NIX Receive Scatter/Gather Subdescriptor Structure
- * The receive scatter/gather subdescriptor specifies one to three segments of packet data bytes.
- * There may be multiple NIX_RX_SG_Ss in each NIX receive descriptor.
- *
- * NIX_RX_SG_S is immediately followed by one NIX_IOVA_S word when [SEGS] = 1,
- * three NIX_IOVA_S words when [SEGS] \>= 2. Each NIX_IOVA_S word specifies the
- * LF IOVA of first packet data byte in the corresponding segment; first NIX_IOVA_S
- * word for segment 1, second word for segment 2, third word for segment 3. Note
- * the third word is present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
+ * NIX Receive Scatter/Gather Subdescriptor Structure The receive
+ * scatter/gather subdescriptor specifies one to three segments of packet
+ * data bytes. There may be multiple NIX_RX_SG_Ss in each NIX receive
+ * descriptor.  NIX_RX_SG_S is immediately followed by one NIX_IOVA_S
+ * word when [SEGS] = 1, three NIX_IOVA_S words when [SEGS] \>= 2. Each
+ * NIX_IOVA_S word specifies the LF IOVA of first packet data byte in the
+ * corresponding segment; first NIX_IOVA_S word for segment 1, second
+ * word for segment 2, third word for segment 3. Note the third word is
+ * present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
  */
 union cavm_nix_rx_sg_s {
 	u64 u;
@@ -1228,10 +1171,10 @@ union cavm_nix_rx_sg_s {
 /**
  * Structure nix_rx_vtag_action_s
  *
- * NIX Receive Vtag Action Structure
- * This structure defines the format of NPC_RESULT_S[VTAG_ACTION] for a receive packet.
- * It specifies up to two Vtags (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG) for optional
- * capture and/or stripping.
+ * NIX Receive Vtag Action Structure This structure defines the format of
+ * NPC_RESULT_S[VTAG_ACTION] for a receive packet. It specifies up to two
+ * Vtags (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG) for optional capture
+ * and/or stripping.
  */
 union cavm_nix_rx_vtag_action_s {
 	u64 u;
@@ -1255,8 +1198,8 @@ union cavm_nix_rx_vtag_action_s {
 /**
  * Structure nix_send_comp_s
  *
- * NIX Send Completion Structure
- * This structure immediately follows NIX_CQE_HDR_S in a send completion CQE.
+ * NIX Send Completion Structure This structure immediately follows
+ * NIX_CQE_HDR_S in a send completion CQE.
  */
 union cavm_nix_send_comp_s {
 	u64 u;
@@ -1271,31 +1214,29 @@ union cavm_nix_send_comp_s {
 /**
  * Structure nix_send_crc_s
  *
- * NIX Send CRC Subdescriptor Structure
- * The send CRC subdescriptor specifies a CRC calculation be performed during
- * transmission.
- * Ignored when present in a send descriptor with NIX_SEND_EXT_S[LSO] set.
- * There may be up to two NIX_SEND_CRC_Ss per send descriptor.
- *
- * NIX_SEND_CRC_S constraints:
- * * When present, NIX_SEND_CRC_S subdescriptors must precede all NIX_SEND_SG_S,
- * NIX_SEND_IMM_S and NIX_SEND_MEM_S subdescriptors in the send descriptor.
- * * NIX_SEND_CRC_S subdescriptors must follow the same order as their checksum
- * and insert regions in the packet, i.e. the checksum and insert regions of a
- * NIX_SEND_CRC_S must come after the checksum and insert regions of a preceding
- * NIX_SEND_CRC_S. There must be no overlap between any NIX_SEND_CRC_S checksum
- * and insert regions.
- * * If either NIX_SEND_HDR_S[OL4TYPE,IL4TYPE] = NIX_SENDL4TYPE_E::SCTP_CKSUM, the
- * SCTP checksum region and NIX_SEND_CRC_S insert region must not overlap, and
- * likewise the NIX_SEND_CRC_S checksum region and SCTP insert region must not
- * overlap.
- * * If either NIX_SEND_HDR_S[OL3TYPE,IL3TYPE] = NIX_SENDL3TYPE_E::IP4_CKSUM, the
- * IPv4 header checksum region and NIX_SEND_CRC_S insert region must not overlap.
- * * Any checksums inserted by NIX_SEND_HDR_S[OL3TYPE,OL4TYPE,IL3TYPE,IL4TYPE]
- * must be outside of the NIX_SEND_CRC_S checksum and insert regions.
- *
- * Hardware adjusts [START], [SIZE] and [INSERT] as needed to account for any VLAN
- * inserted by NIX_SEND_EXT_S[VLAN*] or Vtag inserted by NIX_TX_VTAG_ACTION_S.
+ * NIX Send CRC Subdescriptor Structure The send CRC subdescriptor
+ * specifies a CRC calculation be performed during transmission. Ignored
+ * when present in a send descriptor with NIX_SEND_EXT_S[LSO] set. There
+ * may be up to two NIX_SEND_CRC_Ss per send descriptor.  NIX_SEND_CRC_S
+ * constraints: * When present, NIX_SEND_CRC_S subdescriptors must
+ * precede all NIX_SEND_SG_S, NIX_SEND_IMM_S and NIX_SEND_MEM_S
+ * subdescriptors in the send descriptor. * NIX_SEND_CRC_S subdescriptors
+ * must follow the same order as their checksum and insert regions in the
+ * packet, i.e. the checksum and insert regions of a NIX_SEND_CRC_S must
+ * come after the checksum and insert regions of a preceding
+ * NIX_SEND_CRC_S. There must be no overlap between any NIX_SEND_CRC_S
+ * checksum and insert regions. * If either
+ * NIX_SEND_HDR_S[OL4TYPE,IL4TYPE] = NIX_SENDL4TYPE_E::SCTP_CKSUM, the
+ * SCTP checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap, and likewise the NIX_SEND_CRC_S checksum region and SCTP
+ * insert region must not overlap. * If either
+ * NIX_SEND_HDR_S[OL3TYPE,IL3TYPE] = NIX_SENDL3TYPE_E::IP4_CKSUM, the
+ * IPv4 header checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap. * Any checksums inserted by
+ * NIX_SEND_HDR_S[OL3TYPE,OL4TYPE,IL3TYPE,IL4TYPE] must be outside of the
+ * NIX_SEND_CRC_S checksum and insert regions.  Hardware adjusts [START],
+ * [SIZE] and [INSERT] as needed to account for any VLAN inserted by
+ * NIX_SEND_EXT_S[VLAN*] or Vtag inserted by NIX_TX_VTAG_ACTION_S.
  */
 union cavm_nix_send_crc_s {
 	u64 u[2];
@@ -1315,11 +1256,11 @@ union cavm_nix_send_crc_s {
 /**
  * Structure nix_send_ext_s
  *
- * NIX Send Extended Header Subdescriptor Structure
- * The send extended header specifies LSO, VLAN insertion, timestamp and/or
- * scheduling services on the packet. If present, it must immediately follow
- * NIX_SEND_HDR_S. All fields are assumed to be zero when this subdescriptor is not
- * present.
+ * NIX Send Extended Header Subdescriptor Structure The send extended
+ * header specifies LSO, VLAN insertion, timestamp and/or scheduling
+ * services on the packet. If present, it must immediately follow
+ * NIX_SEND_HDR_S. All fields are assumed to be zero when this
+ * subdescriptor is not present.
  */
 union cavm_nix_send_ext_s {
 	u64 u[2];
@@ -1351,8 +1292,8 @@ union cavm_nix_send_ext_s {
 /**
  * Structure nix_send_hdr_s
  *
- * NIX Send Header Subdescriptor Structure
- * The send header is the first subdescriptor of every send descriptor.
+ * NIX Send Header Subdescriptor Structure The send header is the first
+ * subdescriptor of every send descriptor.
  */
 union cavm_nix_send_hdr_s {
 	u64 u[2];
@@ -1380,20 +1321,18 @@ union cavm_nix_send_hdr_s {
 /**
  * Structure nix_send_imm_s
  *
- * NIX Send Immediate Subdescriptor Structure
- * The send immediate subdescriptor requests that bytes immediately following this
- * NIX_SEND_IMM_S (after skipping [APAD] bytes) are to be included in the packet data.
- * The next subdescriptor following this NIX_SEND_IMM_S (when one exists) will
- * follow the immediate bytes, after rounding up the address to a multiple of 16 bytes.
- *
- * There may be multiple NIX_SEND_IMM_S in one NIX send descriptor. A
- * NIX_SEND_IMM_S is ignored in a NIX send descriptor if the sum of all prior
+ * NIX Send Immediate Subdescriptor Structure The send immediate
+ * subdescriptor requests that bytes immediately following this
+ * NIX_SEND_IMM_S (after skipping [APAD] bytes) are to be included in the
+ * packet data. The next subdescriptor following this NIX_SEND_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.  There may be multiple
+ * NIX_SEND_IMM_S in one NIX send descriptor. A NIX_SEND_IMM_S is ignored
+ * in a NIX send descriptor if the sum of all prior
  * NIX_SEND_SG_S[SEG*_SIZE]s and NIX_SEND_IMM_S[SIZE]s meets or exceeds
- * NIX_SEND_HDR_S[TOTAL].
- *
- * When NIX_SEND_EXT_S[LSO] is set in the descriptor, all NIX_SEND_IMM_S
- * bytes must be included in the first NIX_SEND_EXT_S[LSO_SB] bytes of the
- * source packet.
+ * NIX_SEND_HDR_S[TOTAL].  When NIX_SEND_EXT_S[LSO] is set in the
+ * descriptor, all NIX_SEND_IMM_S bytes must be included in the first
+ * NIX_SEND_EXT_S[LSO_SB] bytes of the source packet.
  */
 union cavm_nix_send_imm_s {
 	u64 u;
@@ -1409,15 +1348,14 @@ union cavm_nix_send_imm_s {
 /**
  * Structure nix_send_jump_s
  *
- * NIX Send Jump Subdescriptor Structure
- * The send jump subdescriptor selects a new address for fetching the remaining
- * subdescriptors of a send descriptor. This allows software to create a send
- * descriptor longer than SQE size selected by NIX_SQ_CTX_S[MAX_SQE_SIZE].
- *
- * There can be only one NIX_SEND_JUMP_S subdescriptor in a send descriptor. If
- * present, it must immediately follow NIX_SEND_HDR_S if NIX_SEND_EXT_S is not
- * present, else it must immediately follow NIX_SEND_EXT_S. In either case, it
- * must terminate the SQE enqueued by software.
+ * NIX Send Jump Subdescriptor Structure The send jump subdescriptor
+ * selects a new address for fetching the remaining subdescriptors of a
+ * send descriptor. This allows software to create a send descriptor
+ * longer than SQE size selected by NIX_SQ_CTX_S[MAX_SQE_SIZE].  There
+ * can be only one NIX_SEND_JUMP_S subdescriptor in a send descriptor. If
+ * present, it must immediately follow NIX_SEND_HDR_S if NIX_SEND_EXT_S
+ * is not present, else it must immediately follow NIX_SEND_EXT_S. In
+ * either case, it must terminate the SQE enqueued by software.
  */
 union cavm_nix_send_jump_s {
 	u64 u[2];
@@ -1437,22 +1375,19 @@ union cavm_nix_send_jump_s {
 /**
  * Structure nix_send_mem_s
  *
- * NIX Send Memory Subdescriptor Structure
- * The send memory subdescriptor atomically sets, increments or decrements a memory location.
- *
- * NIX_SEND_MEM_S subdescriptors must follow all NIX_SEND_SG_S and NIX_SEND_IMM_S
- * subdescriptors in the NIX send descriptor. NIX will not initiate the memory
- * update for this subdescriptor until after it has completed all LLC/DRAM fetches
- * that service all prior NIX_SEND_SG_S subdescriptors. The memory update is
- * executed once, even if the packet is replicated due to NIX_TX_ACTION_S[OP] =
- * NIX_TX_ACTIONOP_E::MCAST.
- *
- * Performance is best if a memory decrement by one is used rather than any other memory
- * set/increment/decrement. (Less internal bus bandwidth is used with memory decrements by one.)
- *
- * When NIX_SEND_EXT_S[LSO] is set in the descriptor, NIX executes the
- * memory update only while processing the last LSO segment, after
- * processing prior segments.
+ * NIX Send Memory Subdescriptor Structure The send memory subdescriptor
+ * atomically sets, increments or decrements a memory location.
+ * NIX_SEND_MEM_S subdescriptors must follow all NIX_SEND_SG_S and
+ * NIX_SEND_IMM_S subdescriptors in the NIX send descriptor. NIX will not
+ * initiate the memory update for this subdescriptor until after it has
+ * completed all LLC/DRAM fetches that service all prior NIX_SEND_SG_S
+ * subdescriptors. The memory update is executed once, even if the packet
+ * is replicated due to NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ * Performance is best if a memory decrement by one is used rather than
+ * any other memory set/increment/decrement. (Less internal bus bandwidth
+ * is used with memory decrements by one.)  When NIX_SEND_EXT_S[LSO] is
+ * set in the descriptor, NIX executes the memory update only while
+ * processing the last LSO segment, after processing prior segments.
  */
 union cavm_nix_send_mem_s {
 	u64 u[2];
@@ -1471,19 +1406,19 @@ union cavm_nix_send_mem_s {
 /**
  * Structure nix_send_sg_s
  *
- * NIX Send Scatter/Gather Subdescriptor Structure
- * The send scatter/gather subdescriptor requests one to three segments of packet
- * data bytes to be transmitted. There may be multiple NIX_SEND_SG_Ss in each NIX send descriptor.
- *
- * NIX_SEND_SG_S is immediately followed by one NIX_IOVA_S word when [SEGS] = 1,
- * three NIX_IOVA_S words when [SEGS] \>= 2. Each NIX_IOVA_S word specifies the
- * LF IOVA of first packet data byte in the corresponding segment; first NIX_IOVA_S
- * word for segment 1, second word for segment 2, third word for segment 3. Note
- * the third word is present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
- *
- * If the sum of all prior NIX_SEND_SG_S[SEG*_SIZE]s and NIX_SEND_IMM_S[SIZE]s
- * meets or exceeds NIX_SEND_HDR_S[TOTAL], this subdescriptor will not contribute
- * any packet data but may free buffers to NPA (see [I1]).
+ * NIX Send Scatter/Gather Subdescriptor Structure The send
+ * scatter/gather subdescriptor requests one to three segments of packet
+ * data bytes to be transmitted. There may be multiple NIX_SEND_SG_Ss in
+ * each NIX send descriptor.  NIX_SEND_SG_S is immediately followed by
+ * one NIX_IOVA_S word when [SEGS] = 1, three NIX_IOVA_S words when
+ * [SEGS] \>= 2. Each NIX_IOVA_S word specifies the LF IOVA of first
+ * packet data byte in the corresponding segment; first NIX_IOVA_S word
+ * for segment 1, second word for segment 2, third word for segment 3.
+ * Note the third word is present when [SEGS] \>= 2 but only valid when
+ * [SEGS] = 3.  If the sum of all prior NIX_SEND_SG_S[SEG*_SIZE]s and
+ * NIX_SEND_IMM_S[SIZE]s meets or exceeds NIX_SEND_HDR_S[TOTAL], this
+ * subdescriptor will not contribute any packet data but may free buffers
+ * to NPA (see [I1]).
  */
 union cavm_nix_send_sg_s {
 	u64 u;
@@ -1505,29 +1440,26 @@ union cavm_nix_send_sg_s {
 /**
  * Structure nix_send_work_s
  *
- * NIX Send Work Subdescriptor Structure
- * This subdescriptor adds work to the SSO. At most one NIX_SEND_WORK_S subdescriptor
- * can exist in the NIX send descriptor. If a NIX_SEND_WORK_S exists in the
- * descriptor, it must be the last subdescriptor. NIX will not initiate the work add
- * for this subdescriptor until after (1) it has completed all LLC/DRAM fetches that
- * service all prior NIX_SEND_SG_S subdescriptors, (2) it has
- * fetched all subdescriptors in the descriptor, and (3) all NIX_SEND_MEM_S[WMEM]=1
- * LLC/DRAM updates have completed.
- *
- * Provided the path of descriptors from the SQ through NIX to an output FIFO is
- * unmodified between the descriptors (as should normally be the case, but it is
- * possible for software to change the path), NIX also (1) will submit
- * the SSO add works from all descriptors in the SQ in order, and
+ * NIX Send Work Subdescriptor Structure This subdescriptor adds work to
+ * the SSO. At most one NIX_SEND_WORK_S subdescriptor can exist in the
+ * NIX send descriptor. If a NIX_SEND_WORK_S exists in the descriptor, it
+ * must be the last subdescriptor. NIX will not initiate the work add for
+ * this subdescriptor until after (1) it has completed all LLC/DRAM
+ * fetches that service all prior NIX_SEND_SG_S subdescriptors, (2) it
+ * has fetched all subdescriptors in the descriptor, and (3) all
+ * NIX_SEND_MEM_S[WMEM]=1 LLC/DRAM updates have completed.  Provided the
+ * path of descriptors from the SQ through NIX to an output FIFO is
+ * unmodified between the descriptors (as should normally be the case,
+ * but it is possible for software to change the path), NIX also (1) will
+ * submit the SSO add works from all descriptors in the SQ in order, and
  * (2) will not submit an SSO work add until after all prior descriptors
- * in the SQ have completed their NIX_SEND_SG_S
- * processing, and (3) will not submit an SSO work add until after
- * it has fetched all subdescriptors from prior descriptors in the SQ.
- *
- * When NIX_SEND_EXT_S[LSO] is set in the descriptor, NIX executes the
- * NIX_SEND_WORK_S work add only while processing the last LSO segment, after
- * processing prior segments.
- *
- * Hardware ignores NIX_SEND_WORK_S when NIX_SQ_CTX_S[SSO_ENA] is clear.
+ * in the SQ have completed their NIX_SEND_SG_S processing, and (3) will
+ * not submit an SSO work add until after it has fetched all
+ * subdescriptors from prior descriptors in the SQ.  When
+ * NIX_SEND_EXT_S[LSO] is set in the descriptor, NIX executes the
+ * NIX_SEND_WORK_S work add only while processing the last LSO segment,
+ * after processing prior segments.  Hardware ignores NIX_SEND_WORK_S
+ * when NIX_SQ_CTX_S[SSO_ENA] is clear.
  */
 union cavm_nix_send_work_s {
 	u64 u[2];
@@ -1545,12 +1477,11 @@ union cavm_nix_send_work_s {
 /**
  * Structure nix_sq_ctx_hw_s
  *
- * NIX SQ Context Hardware Structure
- * This structure contains context state maintained by hardware for each SQ in
- * NDC/LLC/DRAM.
- * Software uses the equivalent NIX_SQ_CTX_S structure format to read and write an
- * SQ context with the NIX admin queue.
- * Always stored in byte invariant little-endian format (LE8).
+ * NIX SQ Context Hardware Structure This structure contains context
+ * state maintained by hardware for each SQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_SQ_CTX_S structure format to read and write an
+ * SQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
  */
 union cavm_nix_sq_ctx_hw_s {
 	u64 u[16];
@@ -1621,13 +1552,12 @@ union cavm_nix_sq_ctx_hw_s {
 /**
  * Structure nix_sq_ctx_s
  *
- * NIX Send Queue Context Structure
- * This structure specifies the format used by software with the NIX admin queue
- * to read and write a send queue's NIX_SQ_CTX_HW_S structure maintained by
- * hardware in NDC/LLC/DRAM.
- *
- * The SQ statistics ([OCTS], [PKTS], [DROP_OCTS], [DROP_PKTS]) do not account for
- * packet replication due to NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ * NIX Send Queue Context Structure This structure specifies the format
+ * used by software with the NIX admin queue to read and write a send
+ * queue's NIX_SQ_CTX_HW_S structure maintained by hardware in
+ * NDC/LLC/DRAM.  The SQ statistics ([OCTS], [PKTS], [DROP_OCTS],
+ * [DROP_PKTS]) do not account for packet replication due to
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
  */
 union cavm_nix_sq_ctx_s {
 	u64 u[16];
@@ -1696,8 +1626,8 @@ union cavm_nix_sq_ctx_s {
 /**
  * Structure nix_tx_action_s
  *
- * NIX Transmit Action Structure
- * This structure defines the format of NPC_RESULT_S[ACTION] for a transmit packet.
+ * NIX Transmit Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a transmit packet.
  */
 union cavm_nix_tx_action_s {
 	u64 u;
@@ -1714,21 +1644,18 @@ union cavm_nix_tx_action_s {
 /**
  * Structure nix_tx_vtag_action_s
  *
- * NIX Transmit Vtag Action Structure
- * This structure defines the format of NPC_RESULT_S[VTAG_ACTION] for a transmit
- * packet. It specifies the optional insertion or replacement of up to two Vtags
- * (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG).
- *
- * If two Vtags are specified:
- * * The Vtag 0 byte offset from packet start (see [VTAG0_RELPTR]) must be less
- * than or equal to the Vtag 1 byte offset.
- * * Hardware executes the Vtag 0 action first, Vtag 1 action second.
- * * If Vtag 0 is inserted, hardware adjusts the Vtag 1 byte offset accordingly.
- * Thus, if the two offsets are equal in the structure, hardware inserts Vtag 1
- * immediately after Vtag 0 in the packet.
- *
- * A Vtag must not be inserted or replaced within an outer or inner L3/L4 header,
- * but may be inserted or replaced within an outer L4 payload.
+ * NIX Transmit Vtag Action Structure This structure defines the format
+ * of NPC_RESULT_S[VTAG_ACTION] for a transmit packet. It specifies the
+ * optional insertion or replacement of up to two Vtags (e.g.
+ * C-VLAN/S-VLAN tags, 802.1BR E-TAG).  If two Vtags are specified: * The
+ * Vtag 0 byte offset from packet start (see [VTAG0_RELPTR]) must be less
+ * than or equal to the Vtag 1 byte offset. * Hardware executes the Vtag
+ * 0 action first, Vtag 1 action second. * If Vtag 0 is inserted,
+ * hardware adjusts the Vtag 1 byte offset accordingly. Thus, if the two
+ * offsets are equal in the structure, hardware inserts Vtag 1
+ * immediately after Vtag 0 in the packet.  A Vtag must not be inserted
+ * or replaced within an outer or inner L3/L4 header, but may be inserted
+ * or replaced within an outer L4 payload.
  */
 union cavm_nix_tx_vtag_action_s {
 	u64 u;
@@ -1754,10 +1681,10 @@ union cavm_nix_tx_vtag_action_s {
 /**
  * Structure nix_wqe_hdr_s
  *
- * NIX Work Queue Entry Header Structure
- * This 64-bit structure defines the first word of every receive WQE generated by
- * NIX. It is immediately followed by NIX_RX_PARSE_S.
- * Stored in memory as little-endian unless NIX_AF_LF()_CFG[BE] is set.
+ * NIX Work Queue Entry Header Structure This 64-bit structure defines
+ * the first word of every receive WQE generated by NIX. It is
+ * immediately followed by NIX_RX_PARSE_S. Stored in memory as little-
+ * endian unless NIX_AF_LF()_CFG[BE] is set.
  */
 union cavm_nix_wqe_hdr_s {
 	u64 u;
@@ -1839,8 +1766,8 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_aq_done_ack
  *
- * NIX AF Admin Queue Done Count Ack Register
- * This register is written by software to acknowledge interrupts.
+ * NIX AF Admin Queue Done Count Ack Register This register is written by
+ * software to acknowledge interrupts.
  */
 union cavm_nixx_af_aq_done_ack {
 	u64 u;
@@ -1966,8 +1893,8 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_aq_done_wait
  *
- * NIX AF Admin Queue Done Interrupt Coalescing Wait Register
- * Specifies the queue interrupt coalescing settings.
+ * NIX AF Admin Queue Done Interrupt Coalescing Wait Register Specifies
+ * the queue interrupt coalescing settings.
  */
 union cavm_nixx_af_aq_done_wait {
 	u64 u;
@@ -1990,8 +1917,8 @@ static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_aq_door
  *
- * NIX AF Admin Queue Doorbell Register
- * Software writes to this register to enqueue entries to AQ.
+ * NIX AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue entries to AQ.
  */
 union cavm_nixx_af_aq_door {
 	u64 u;
@@ -2070,13 +1997,10 @@ static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_bar2_alias#
  *
- * INTERNAL: NIX Admin Function  BAR2 Alias Registers
- *
- * These registers alias to the NIX BAR2 registers for the PF and function
- * selected by NIX_AF_BAR2_SEL[PF_FUNC].
- *
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: NIX Admin Function  BAR2 Alias Registers  These registers
+ * alias to the NIX BAR2 registers for the PF and function selected by
+ * NIX_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
  */
 union cavm_nixx_af_bar2_aliasx {
 	u64 u;
@@ -2096,11 +2020,9 @@ static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_bar2_sel
  *
- * INTERNAL: NIX Admin Function BAR2 Select Register
- *
- * This register configures BAR2 accesses from the NIX_AF_BAR2_ALIAS() registers in BAR0.
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: NIX Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the NIX_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
  */
 union cavm_nixx_af_bar2_sel {
 	u64 u;
@@ -2223,8 +2145,8 @@ static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_const
  *
- * NIX AF Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_const {
 	u64 u;
@@ -2254,8 +2176,8 @@ static inline u64 CAVM_NIXX_AF_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_const1
  *
- * NIX AF Constants 1 Register
- * This register contains constants for software discovery.
+ * NIX AF Constants 1 Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_const1 {
 	u64 u;
@@ -2281,8 +2203,8 @@ static inline u64 CAVM_NIXX_AF_CONST1(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_const2
  *
- * NIX AF Constants 2 Register
- * This register contains constants for software discovery.
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_const2 {
 	u64 u;
@@ -2305,8 +2227,8 @@ static inline u64 CAVM_NIXX_AF_CONST2(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_const3
  *
- * NIX AF Constants 2 Register
- * This register contains constants for software discovery.
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_const3 {
 	u64 u;
@@ -2334,8 +2256,8 @@ static inline u64 CAVM_NIXX_AF_CONST3(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_cq_const
  *
- * NIX AF CQ Constants Register
- * This register contains constants for software discovery.
+ * NIX AF CQ Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_cq_const {
 	u64 u;
@@ -2451,8 +2373,8 @@ static inline u64 CAVM_NIXX_AF_ERR_INT(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1c
  *
- * NIX Admin Function Error Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
  */
 union cavm_nixx_af_err_int_ena_w1c {
 	u64 u;
@@ -2483,8 +2405,8 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1s
  *
- * NIX Admin Function Error Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
  */
 union cavm_nixx_af_err_int_ena_w1s {
 	u64 u;
@@ -2515,8 +2437,8 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_err_int_w1s
  *
- * NIX Admin Function Error Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
  */
 union cavm_nixx_af_err_int_w1s {
 	u64 u;
@@ -2547,8 +2469,8 @@ static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_expr_tx_fifo_status
  *
- * NIX AF Express Transmit FIFO Status Register
- * Status of FIFO which transmits express packets to CGX and LBK.
+ * NIX AF Express Transmit FIFO Status Register Status of FIFO which
+ * transmits express packets to CGX and LBK.
  */
 union cavm_nixx_af_expr_tx_fifo_status {
 	u64 u;
@@ -2594,8 +2516,8 @@ static inline u64 CAVM_NIXX_AF_GEN_INT(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1c
  *
- * NIX AF General Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_af_gen_int_ena_w1c {
 	u64 u;
@@ -2620,8 +2542,8 @@ static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1s
  *
- * NIX AF General Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_nixx_af_gen_int_ena_w1s {
 	u64 u;
@@ -2646,8 +2568,8 @@ static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_gen_int_w1s
  *
- * NIX AF General Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX AF General Interrupt Set Register This register sets interrupt
+ * bits.
  */
 union cavm_nixx_af_gen_int_w1s {
 	u64 u;
@@ -2698,8 +2620,8 @@ static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
  *
  * NIX AF Local Function Completion Interrupts Base Address Registers
  * This register specifies the base AF IOVA of LF's completion interrupt
- * context table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[CINTS]
- * contiguous NIX_CINT_HW_S structures.
+ * context table in NDC/LLC/DRAM. The table consists of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures.
  */
 union cavm_nixx_af_lfx_cints_base {
 	u64 u;
@@ -2722,9 +2644,10 @@ static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_lf#_cints_cfg
  *
  * NIX AF Local Function Completion Interrupts Configuration Registers
- * This register controls access to the LF's completion interrupt context table in
- * NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S
- * structures. The size of each structure is 1 \<\< NIX_AF_CONST3[CINT_LOG2BYTES].
+ * This register controls access to the LF's completion interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[CINTS]
+ * contiguous NIX_CINT_HW_S structures. The size of each structure is 1
+ * \<\< NIX_AF_CONST3[CINT_LOG2BYTES].
  */
 union cavm_nixx_af_lfx_cints_cfg {
 	u64 u;
@@ -2747,9 +2670,9 @@ static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_base
  *
- * NIX AF Local Function Completion Queues Base Address Register
- * This register specifies the base AF IOVA of the LF's CQ context table.
- * The table consists of NIX_AF_LF()_CQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX AF Local Function Completion Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's CQ context table. The
+ * table consists of NIX_AF_LF()_CQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_CQ_CTX_S structures.
  */
 union cavm_nixx_af_lfx_cqs_base {
@@ -2772,8 +2695,8 @@ static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_cfg
  *
- * NIX AF Local Function Completion Queues Configuration Register
- * This register configures completion queues in the LF.
+ * NIX AF Local Function Completion Queues Configuration Register This
+ * register configures completion queues in the LF.
  */
 union cavm_nixx_af_lfx_cqs_cfg {
 	u64 u;
@@ -2796,11 +2719,11 @@ static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_lock#
  *
- * NIX AF Local Function Lockdown Registers
- * Internal:
- * The NIX lockdown depth of 32 bytes is shallow compared to 96 bytes for NIC and meant for outer
- * MAC and/or VLAN (optionally preceded by a small number of skip bytes). NPC's MCAM can be used
- * for deeper protocol-aware lockdown.
+ * NIX AF Local Function Lockdown Registers Internal: The NIX lockdown
+ * depth of 32 bytes is shallow compared to 96 bytes for NIC and meant
+ * for outer MAC and/or VLAN (optionally preceded by a small number of
+ * skip bytes). NPC's MCAM can be used for deeper protocol-aware
+ * lockdown.
  */
 union cavm_nixx_af_lfx_lockx {
 	u64 u;
@@ -2821,10 +2744,10 @@ static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_qints_base
  *
- * NIX AF Local Function Queue Interrupts Base Address Registers
- * This register specifies the base AF IOVA of LF's queue interrupt context
- * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS] contiguous
- * NIX_QINT_HW_S structures.
+ * NIX AF Local Function Queue Interrupts Base Address Registers This
+ * register specifies the base AF IOVA of LF's queue interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS]
+ * contiguous NIX_QINT_HW_S structures.
  */
 union cavm_nixx_af_lfx_qints_base {
 	u64 u;
@@ -2846,10 +2769,11 @@ static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_qints_cfg
  *
- * NIX AF Local Function Queue Interrupts Configuration Registers
- * This register controls access to the LF's queue interrupt context table in
- * NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS] contiguous NIX_QINT_HW_S
- * structures. The size of each structure is 1 \<\< NIX_AF_CONST3[QINT_LOG2BYTES].
+ * NIX AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS] contiguous
+ * NIX_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NIX_AF_CONST3[QINT_LOG2BYTES].
  */
 union cavm_nixx_af_lfx_qints_cfg {
 	u64 u;
@@ -2872,9 +2796,9 @@ static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_base
  *
- * NIX AF Local Function Receive Queues Base Address Register
- * This register specifies the base AF IOVA of the LF's RQ context table.
- * The table consists of NIX_AF_LF()_RQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX AF Local Function Receive Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's RQ context table. The
+ * table consists of NIX_AF_LF()_RQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_RQ_CTX_S structures.
  */
 union cavm_nixx_af_lfx_rqs_base {
@@ -2897,8 +2821,8 @@ static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_cfg
  *
- * NIX AF Local Function Receive Queues Configuration Register
- * This register configures receive queues in the LF.
+ * NIX AF Local Function Receive Queues Configuration Register This
+ * register configures receive queues in the LF.
  */
 union cavm_nixx_af_lfx_rqs_cfg {
 	u64 u;
@@ -2924,9 +2848,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
  * NIX AF Local Function Receive Size Scaling Table Base Address Register
  * This register specifies the base AF IOVA of the RSS table per LF. The
  * table is present when NIX_AF_LF()_RSS_CFG[ENA] is set and consists of
- * 2^(NIX_AF_LF()_RSS_CFG[SIZE]+8) contiguous NIX_RSSE_S structures, where the
- * size of each structure is 1 \<\< NIX_AF_CONST3[RSSE_LOG2BYTES].
- * See NIX_AF_LF()_RSS_GRP().
+ * 2^(NIX_AF_LF()_RSS_CFG[SIZE]+8) contiguous NIX_RSSE_S structures,
+ * where the size of each structure is 1 \<\<
+ * NIX_AF_CONST3[RSSE_LOG2BYTES]. See NIX_AF_LF()_RSS_GRP().
  */
 union cavm_nixx_af_lfx_rss_base {
 	u64 u;
@@ -2948,8 +2872,8 @@ static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rss_cfg
  *
- * NIX AF Local Function Receive Size Scaling Table Configuration Register
- * See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
+ * NIX AF Local Function Receive Size Scaling Table Configuration
+ * Register See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
  */
 union cavm_nixx_af_lfx_rss_cfg {
 	u64 u;
@@ -2974,16 +2898,15 @@ static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rss_grp#
  *
- * NIX AF Local Function Receive Side Scaling Group Registers
- * A receive packet targets a LF's RSS group when its NIX_RX_ACTION_S[OP] =
+ * NIX AF Local Function Receive Side Scaling Group Registers A receive
+ * packet targets a LF's RSS group when its NIX_RX_ACTION_S[OP] =
  * NIX_RX_ACTIONOP_E::RSS, or its target multicast list has an entry with
- * NIX_RX_MCE_S[OP] = NIX_RX_MCOP_E::RSS. The RSS group index (this register's last
- * index) is NIX_RX_ACTION_S[INDEX] or NIX_RX_MCE_S[INDEX].
- *
- * The RSS computation is as follows:
- * * The packet's flow_tag (see NIX_LF_RX_SECRET()) and RSS group are used to
- * select a NIX_RSSE_S entry in the LF's RSS table (see [SIZEM1]).
- * * NIX_RSSE_S selects the packet's destination RQ.
+ * NIX_RX_MCE_S[OP] = NIX_RX_MCOP_E::RSS. The RSS group index (this
+ * register's last index) is NIX_RX_ACTION_S[INDEX] or
+ * NIX_RX_MCE_S[INDEX].  The RSS computation is as follows: * The
+ * packet's flow_tag (see NIX_LF_RX_SECRET()) and RSS group are used to
+ * select a NIX_RSSE_S entry in the LF's RSS table (see [SIZEM1]). *
+ * NIX_RSSE_S selects the packet's destination RQ.
  */
 union cavm_nixx_af_lfx_rss_grpx {
 	u64 u;
@@ -3085,11 +3008,11 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_dyno_base
  *
- * NIX AF LF Receive IPSEC Dynamic Ordering Base Address Registers
- * This register specifies the base AF IOVA of the LF's IPSEC dynamic ordering
+ * NIX AF LF Receive IPSEC Dynamic Ordering Base Address Registers This
+ * register specifies the base AF IOVA of the LF's IPSEC dynamic ordering
  * counter table in NDC/LLC/DRAM. The table consists of 1 \<\<
- * (NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_IDX_W]) NIX_IPSEC_DYNO_S structures.
- * See NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA].
+ * (NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_IDX_W]) NIX_IPSEC_DYNO_S
+ * structures. See NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA].
  */
 union cavm_nixx_af_lfx_rx_ipsec_dyno_base {
 	u64 u;
@@ -3137,7 +3060,8 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_sa_base
  *
  * NIX AF LF Receive IPSEC Security Association Base Address Register
- * This register specifies the base IOVA of CPT's IPSEC SA table in LLC/DRAM.
+ * This register specifies the base IOVA of CPT's IPSEC SA table in
+ * LLC/DRAM.
  */
 union cavm_nixx_af_lfx_rx_ipsec_sa_base {
 	u64 u;
@@ -3159,8 +3083,8 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rx_stat#
  *
- * NIX AF Local Function Receive Statistics Registers
- * The last dimension indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ * NIX AF Local Function Receive Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
  */
 union cavm_nixx_af_lfx_rx_statx {
 	u64 u;
@@ -3181,9 +3105,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_rx_vtag_type#
  *
- * NIX AF Local Function Receive Vtag Type Registers
- * These registers specify optional Vtag (e.g. VLAN, E-TAG) actions for received
- * packets. Indexed by NIX_RX_VTAG_ACTION_S[VTAG*_TYPE].
+ * NIX AF Local Function Receive Vtag Type Registers These registers
+ * specify optional Vtag (e.g. VLAN, E-TAG) actions for received packets.
+ * Indexed by NIX_RX_VTAG_ACTION_S[VTAG*_TYPE].
  */
 union cavm_nixx_af_lfx_rx_vtag_typex {
 	u64 u;
@@ -3207,9 +3131,9 @@ static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_base
  *
- * NIX AF Local Function Send Queues Base Address Register
- * This register specifies the base AF IOVA of the LF's SQ context table.
- * The table consists of NIX_AF_LF()_SQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX AF Local Function Send Queues Base Address Register This register
+ * specifies the base AF IOVA of the LF's SQ context table. The table
+ * consists of NIX_AF_LF()_SQS_CFG[MAX_QUEUESM1]+1 contiguous
  * NIX_SQ_CTX_HW_S structures.
  */
 union cavm_nixx_af_lfx_sqs_base {
@@ -3232,8 +3156,8 @@ static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_cfg
  *
- * NIX AF Local Function Send Queues Configuration Register
- * This register configures send queues in the LF.
+ * NIX AF Local Function Send Queues Configuration Register This register
+ * configures send queues in the LF.
  */
 union cavm_nixx_af_lfx_sqs_cfg {
 	u64 u;
@@ -3323,8 +3247,8 @@ static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lf#_tx_stat#
  *
- * NIX AF Local Function Transmit Statistics Registers
- * The last dimension indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ * NIX AF Local Function Transmit Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
  */
 union cavm_nixx_af_lfx_tx_statx {
 	u64 u;
@@ -3413,17 +3337,15 @@ static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_lso_format#_field#
  *
- * NIX AF Large Send Offload Format Field Registers
- * These registers specify LSO packet modification formats. Each format may modify
- * up to eight packet fields with the following constraints:
- * * If fewer than eight fields are modified, [ALG] must be NIX_LSOALG_E::NOP in the
- * unused field registers.
- * * Modified fields must be specified in contiguous field registers starting with
- * NIX_AF_LSO_FORMAT()_FIELD(0).
- * * Modified fields cannot overlap.
- * * Multiple fields with the same [LAYER] value must be specified in
- * ascending [OFFSET] order.
- * * Fields in different layers must be specified in ascending [LAYER] order.
+ * NIX AF Large Send Offload Format Field Registers These registers
+ * specify LSO packet modification formats. Each format may modify up to
+ * eight packet fields with the following constraints: * If fewer than
+ * eight fields are modified, [ALG] must be NIX_LSOALG_E::NOP in the
+ * unused field registers. * Modified fields must be specified in
+ * contiguous field registers starting with NIX_AF_LSO_FORMAT()_FIELD(0).
+ * * Modified fields cannot overlap. * Multiple fields with the same
+ * [LAYER] value must be specified in ascending [OFFSET] order. * Fields
+ * in different layers must be specified in ascending [LAYER] order.
  */
 union cavm_nixx_af_lso_formatx_fieldx {
 	u64 u;
@@ -3449,28 +3371,19 @@ static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mark_format#_ctl
  *
- * NIX AF Packet Marking Format Registers
- * Describes packet marking calculations for YELLOW and for
- * NIX_COLORRESULT_E::RED_SEND packets. NIX_SEND_EXT_S[MARKFORM] selects the CSR
- * used for the packet descriptor.
- *
- * All the packet marking offset calculations assume big-endian bits within a byte.
- *
- * For example, if NIX_SEND_EXT_S[MARKPTR] is 3 and [OFFSET] is 5 and the packet is YELLOW,
- * the NIX marking hardware would do this:
- *
- * _  byte[3]\<2:0\> |=   [Y_VAL]\<3:1\>
- * _  byte[3]\<2:0\> &= ~[Y_MASK]\<3:1\>
- * _  byte[4]\<7\>   |=   [Y_VAL]\<0\>
- * _  byte[4]\<7\>   &= ~[Y_MASK]\<0\>
- *
- * where byte[3] is the third byte in the packet, and byte[4] the fourth.
- *
- * For another example, if NIX_SEND_EXT_S[MARKPTR] is 3 and [OFFSET] is 0 and the
- * packet is NIX_COLORRESULT_E::RED_SEND,
- *
- * _   byte[3]\<7:4\> |=   [R_VAL]\<3:0\>
- * _   byte[3]\<7:4\> &= ~[R_MASK]\<3:0\>
+ * NIX AF Packet Marking Format Registers Describes packet marking
+ * calculations for YELLOW and for NIX_COLORRESULT_E::RED_SEND packets.
+ * NIX_SEND_EXT_S[MARKFORM] selects the CSR used for the packet
+ * descriptor.  All the packet marking offset calculations assume big-
+ * endian bits within a byte.  For example, if NIX_SEND_EXT_S[MARKPTR] is
+ * 3 and [OFFSET] is 5 and the packet is YELLOW, the NIX marking hardware
+ * would do this:  _  byte[3]\<2:0\> |=   [Y_VAL]\<3:1\> _
+ * byte[3]\<2:0\> &= ~[Y_MASK]\<3:1\> _  byte[4]\<7\>   |=   [Y_VAL]\<0\>
+ * _  byte[4]\<7\>   &= ~[Y_MASK]\<0\>  where byte[3] is the third byte
+ * in the packet, and byte[4] the fourth.  For another example, if
+ * NIX_SEND_EXT_S[MARKPTR] is 3 and [OFFSET] is 0 and the packet is
+ * NIX_COLORRESULT_E::RED_SEND,  _   byte[3]\<7:4\> |=   [R_VAL]\<3:0\> _
+ * byte[3]\<7:4\> &= ~[R_MASK]\<3:0\>
  */
 union cavm_nixx_af_mark_formatx_ctl {
 	u64 u;
@@ -3495,8 +3408,8 @@ static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mc_mirror_const
  *
- * NIX AF Multicast/Mirror Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Multicast/Mirror Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_mc_mirror_const {
 	u64 u;
@@ -3517,8 +3430,8 @@ static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_cir
  *
- * NIX AF Meta Descriptor Queue Committed Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Meta Descriptor Queue Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_mdqx_cir {
 	u64 u;
@@ -3546,8 +3459,9 @@ static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_mdq#_md_debug
  *
  * NIX AF Meta Descriptor Queue Meta Descriptor State Debug Registers
- * This register provides access to the meta descriptor at the front of the MDQ. An MDQ can
- * hold up to 8 packet meta descriptors (PMD) and one flush meta descriptor (FMD).
+ * This register provides access to the meta descriptor at the front of
+ * the MDQ. An MDQ can hold up to 8 packet meta descriptors (PMD) and one
+ * flush meta descriptor (FMD).
  */
 union cavm_nixx_af_mdqx_md_debug {
 	u64 u;
@@ -3598,8 +3512,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_pir
  *
- * NIX AF Meta Descriptor Queue Peak Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Meta Descriptor Queue Peak Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_mdqx_pir {
 	u64 u;
@@ -3627,7 +3541,6 @@ static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_mdq#_pointers
  *
  * INTERNAL: NIX AF Meta Descriptor 4 Linked List Pointers Debug Register
- *
  * This register has the same bit fields as NIX_AF_TL4()_POINTERS.
  */
 union cavm_nixx_af_mdqx_pointers {
@@ -3674,8 +3587,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_sched_state
  *
- * NIX AF Meta Descriptor Queue Scheduling Control State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ * NIX AF Meta Descriptor Queue Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
 union cavm_nixx_af_mdqx_sched_state {
 	u64 u;
@@ -3696,8 +3609,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_schedule
  *
- * NIX AF Meta Descriptor Queue Scheduling Control Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ * NIX AF Meta Descriptor Queue Scheduling Control Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
 union cavm_nixx_af_mdqx_schedule {
 	u64 u;
@@ -3719,8 +3632,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_shape
  *
- * NIX AF Meta Descriptor Queue Shaping Control Registers
- * This register has the same bit fields as NIX_AF_TL3()_SHAPE.
+ * NIX AF Meta Descriptor Queue Shaping Control Registers This register
+ * has the same bit fields as NIX_AF_TL3()_SHAPE.
  */
 union cavm_nixx_af_mdqx_shape {
 	u64 u;
@@ -3747,9 +3660,9 @@ static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_shape_state
  *
- * NIX AF Meta Descriptor Queue Shaping State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SHAPE_STATE.
- * This register must not be written during normal operation.
+ * NIX AF Meta Descriptor Queue Shaping State Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must
+ * not be written during normal operation.
  */
 union cavm_nixx_af_mdqx_shape_state {
 	u64 u;
@@ -3772,8 +3685,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq#_sw_xoff
  *
- * NIX AF Meta Descriptor Controlled XOFF Registers
- * This register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ * NIX AF Meta Descriptor Controlled XOFF Registers This register has the
+ * same bit fields as NIX_AF_TL1()_SW_XOFF
  */
 union cavm_nixx_af_mdqx_sw_xoff {
 	u64 u;
@@ -3797,8 +3710,8 @@ static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_mdq_const
  *
- * NIX AF Meta Descriptor Queue Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Meta Descriptor Queue Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_mdq_const {
 	u64 u;
@@ -3853,8 +3766,8 @@ static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ndc_rx_sync
  *
- * NIX AF Receive NDC Sync Register
- * Used to synchronize the NIX receive NDC (NDC_IDX_E::NIX()_RX).
+ * NIX AF Receive NDC Sync Register Used to synchronize the NIX receive
+ * NDC (NDC_IDX_E::NIX()_RX).
  */
 union cavm_nixx_af_ndc_rx_sync {
 	u64 u;
@@ -3877,8 +3790,8 @@ static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ndc_tx_sync
  *
- * NIX AF NDC_TX Sync Register
- * Used to synchronize the NIX transmit NDC (NDC_IDX_E::NIX()_TX).
+ * NIX AF NDC_TX Sync Register Used to synchronize the NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX).
  */
 union cavm_nixx_af_ndc_tx_sync {
 	u64 u;
@@ -3901,8 +3814,8 @@ static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_norm_tx_fifo_status
  *
- * NIX AF Normal Transmit FIFO Status Register
- * Status of FIFO which transmits normal (potentially preemptable) packets to CGX and LBK.
+ * NIX AF Normal Transmit FIFO Status Register Status of FIFO which
+ * transmits normal (potentially preemptable) packets to CGX and LBK.
  */
 union cavm_nixx_af_norm_tx_fifo_status {
 	u64 u;
@@ -3944,8 +3857,8 @@ static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_pse_active_cycles_pc
  *
- * NIX AF Active Cycles Register
- * These registers are indexed by the conditional clock domain number.
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
  */
 union cavm_nixx_af_pse_active_cycles_pc {
 	u64 u;
@@ -4082,8 +3995,8 @@ static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_pse_const
  *
- * NIX AF PSE Constants Register
- * This register contains constants for software discovery.
+ * NIX AF PSE Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_pse_const {
 	u64 u;
@@ -4194,9 +4107,8 @@ static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ras
  *
- * NIX AF RAS Interrupt Register
- * This register is intended for delivery of RAS events to the SCP, so should be
- * ignored by OS drivers.
+ * NIX AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
  */
 union cavm_nixx_af_ras {
 	u64 u;
@@ -4225,8 +4137,8 @@ static inline u64 CAVM_NIXX_AF_RAS(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1c
  *
- * NIX AF RAS Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_af_ras_ena_w1c {
 	u64 u;
@@ -4255,8 +4167,8 @@ static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1s
  *
- * NIX AF RAS Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_nixx_af_ras_ena_w1s {
 	u64 u;
@@ -4285,8 +4197,7 @@ static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_ras_w1s
  *
- * NIX AF RAS Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX AF RAS Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_nixx_af_ras_w1s {
 	u64 u;
@@ -4340,8 +4251,8 @@ static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rq_const
  *
- * NIX AF RQ Constants Register
- * This register contains constants for software discovery.
+ * NIX AF RQ Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_rq_const {
 	u64 u;
@@ -4407,8 +4318,8 @@ static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rvu_int
  *
- * NIX AF RVU Interrupt Register
- * This register contains RVU error interrupt summary bits.
+ * NIX AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
  */
 union cavm_nixx_af_rvu_int {
 	u64 u;
@@ -4429,8 +4340,8 @@ static inline u64 CAVM_NIXX_AF_RVU_INT(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1c
  *
- * NIX AF RVU Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_af_rvu_int_ena_w1c {
 	u64 u;
@@ -4451,8 +4362,8 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1s
  *
- * NIX AF RVU Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_nixx_af_rvu_int_ena_w1s {
 	u64 u;
@@ -4473,8 +4384,7 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rvu_int_w1s
  *
- * NIX AF RVU Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX AF RVU Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_nixx_af_rvu_int_w1s {
 	u64 u;
@@ -4495,9 +4405,9 @@ static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rvu_lf_cfg_debug
  *
- * NIX Privileged LF Configuration Debug Register
- * This debug register allows software to lookup the reverse mapping from VF/PF
- * slot to LF. The forward mapping is programmed with NIX_PRIV_LF()_CFG.
+ * NIX Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NIX_PRIV_LF()_CFG.
  */
 union cavm_nixx_af_rvu_lf_cfg_debug {
 	u64 u;
@@ -4523,8 +4433,8 @@ static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_active_cycles_pc#
  *
- * NIX AF Active Cycles Register
- * These registers are indexed by the conditional clock domain number.
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
  */
 union cavm_nixx_af_rx_active_cycles_pcx {
 	u64 u;
@@ -4632,21 +4542,15 @@ static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_cpt#_inst_qsel
  *
- * NIX AF Receive CPT Instruction Queue Select Register
- * Selects the CPT queue to which instructions (CPT_INST_S) are sent.
- * Internal:
- * NIX sends CPT_INST_S to the CPT_LF_NQ() physical address for [PF_FUNC] and [SLOT]:
- * \<pre\>
- * // CPT_LF_NQ() physical address:
- * chip_pa_defs::io_rvu2a_t cpt_addr;
- * cpt_addr = RVU_BAR_E::RVU_PF()_FUNC()_BAR2(pf, func);
- * cpt_addr.block = RVU_BLOCK_ADDR_E::CPT()({a}); // {a} = CPT index
- * cpt_addr.slot = [SLOT];
- * cpt_addr.offset = `CPT_LF_NQX__BASE;
- *
- * // NDC/NCBI command:
- * ncbi_cmd.paddr = 1; // Physical address
- * ncbi_cmd.addr = cpt_addr;
+ * NIX AF Receive CPT Instruction Queue Select Register Selects the CPT
+ * queue to which instructions (CPT_INST_S) are sent. Internal: NIX sends
+ * CPT_INST_S to the CPT_LF_NQ() physical address for [PF_FUNC] and
+ * [SLOT]: \<pre\> // CPT_LF_NQ() physical address:
+ * chip_pa_defs::io_rvu2a_t cpt_addr; cpt_addr =
+ * RVU_BAR_E::RVU_PF()_FUNC()_BAR2(pf, func); cpt_addr.block =
+ * RVU_BLOCK_ADDR_E::CPT()({a}); // {a} = CPT index cpt_addr.slot =
+ * [SLOT]; cpt_addr.offset = `CPT_LF_NQX__BASE;  // NDC/NCBI command:
+ * ncbi_cmd.paddr = 1; // Physical address ncbi_cmd.addr = cpt_addr;
  * \</pre\>
  */
 union cavm_nixx_af_rx_cptx_inst_qsel {
@@ -4669,8 +4573,8 @@ static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_iip4
  *
- * NIX AF Receive Inner IPv4 Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an inner IPv4 header.
+ * NIX AF Receive Inner IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv4 header.
  * Typically the same as NPC_PCK_DEF_IIP4.
  */
 union cavm_nixx_af_rx_def_iip4 {
@@ -4694,8 +4598,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_iip6
  *
- * NIX AF Receive Inner IPv6 Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an inner IPv6 header.
+ * NIX AF Receive Inner IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv6 header.
  */
 union cavm_nixx_af_rx_def_iip6 {
 	u64 u;
@@ -4718,9 +4622,9 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_ipsec#
  *
- * NIX AF Receive IPSEC Header Definition Registers
- * These two registers define layer information in NPC_RESULT_S to identify an
- * IPSEC header for up to two IPSEC packet formats. The two formats are typically
+ * NIX AF Receive IPSEC Header Definition Registers These two registers
+ * define layer information in NPC_RESULT_S to identify an IPSEC header
+ * for up to two IPSEC packet formats. The two formats are typically
  * IPSEC ESP (RFC 4303) and UDP-encapsulated IPSEC ESP (RFC 3948).
  */
 union cavm_nixx_af_rx_def_ipsecx {
@@ -4747,8 +4651,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_isctp
  *
- * NIX AF Receive Inner SCTP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an inner SCTP header.
+ * NIX AF Receive Inner SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner SCTP header.
  */
 union cavm_nixx_af_rx_def_isctp {
 	u64 u;
@@ -4771,8 +4675,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_itcp
  *
- * NIX AF Receive Inner TCP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an inner TCP header.
+ * NIX AF Receive Inner TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner TCP header.
  */
 union cavm_nixx_af_rx_def_itcp {
 	u64 u;
@@ -4795,8 +4699,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_iudp
  *
- * NIX AF Receive Inner UDP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an inner UDP header.
+ * NIX AF Receive Inner UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner UDP header.
  */
 union cavm_nixx_af_rx_def_iudp {
 	u64 u;
@@ -4819,8 +4723,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_oip4
  *
- * NIX AF Receive Outer IPv4 Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer IPv4 L3 header.
+ * NIX AF Receive Outer IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv4 L3 header.
  * Typically the same as NPC_PCK_DEF_OIP4.
  */
 union cavm_nixx_af_rx_def_oip4 {
@@ -4844,8 +4748,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_oip6
  *
- * NIX AF Receive Outer IPv6 Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer IPv6 header.
+ * NIX AF Receive Outer IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv6 header.
  * Typically the same as NPC_PCK_DEF_OIP6.
  */
 union cavm_nixx_af_rx_def_oip6 {
@@ -4869,9 +4773,9 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_ol2
  *
- * NIX AF Receive Outer L2 Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer L2/Ethernet
- * header. Typically the same as NPC_PCK_DEF_OL2.
+ * NIX AF Receive Outer L2 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer L2/Ethernet header.
+ * Typically the same as NPC_PCK_DEF_OL2.
  */
 union cavm_nixx_af_rx_def_ol2 {
 	u64 u;
@@ -4894,8 +4798,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_osctp
  *
- * NIX AF Receive Outer SCTP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer SCTP header.
+ * NIX AF Receive Outer SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer SCTP header.
  */
 union cavm_nixx_af_rx_def_osctp {
 	u64 u;
@@ -4918,8 +4822,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_otcp
  *
- * NIX AF Receive Outer TCP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer TCP header.
+ * NIX AF Receive Outer TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer TCP header.
  */
 union cavm_nixx_af_rx_def_otcp {
 	u64 u;
@@ -4942,8 +4846,8 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_def_oudp
  *
- * NIX AF Receive Outer UDP Header Definition Register
- * Defines layer information in NPC_RESULT_S to identify an outer UDP header.
+ * NIX AF Receive Outer UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer UDP header.
  */
 union cavm_nixx_af_rx_def_oudp {
 	u64 u;
@@ -4966,23 +4870,16 @@ static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_flow_key_alg#_field#
  *
- * NIX AF Receive Flow Key Algorithm Field Registers
- * A flow key algorithm defines how the 40-byte FLOW_KEY is formed from the received
- * packet header. FLOW_KEY is formed using up to five header fields (this register's
- * last index) with up to 16 bytes per field.
- *
- * The algorithm (index {a} (ALG) of these registers) is selected by
+ * NIX AF Receive Flow Key Algorithm Field Registers A flow key algorithm
+ * defines how the 40-byte FLOW_KEY is formed from the received packet
+ * header. FLOW_KEY is formed using up to five header fields (this
+ * register's last index) with up to 16 bytes per field.  The algorithm
+ * (index {a} (ALG) of these registers) is selected by
  * NIX_RX_ACTION_S[FLOW_KEY_ALG] from the packet's NPC_RESULT_S[ACTION].
- *
- * Internal:
- * 40-byte FLOW_KEY is wide enough to support an IPv6 5-tuple that includes a
- * VXLAN/GENEVE/NVGRE tunnel ID, e.g:
- * _ Source IP: 16B.
- * _ Dest IP: 16B.
- * _ Source port: 2B.
- * _ Dest port: 2B.
- * _ Tunnel VNI/VSI: 3B.
- * _ Total: 39B.
+ * Internal: 40-byte FLOW_KEY is wide enough to support an IPv6 5-tuple
+ * that includes a VXLAN/GENEVE/NVGRE tunnel ID, e.g: _ Source IP: 16B. _
+ * Dest IP: 16B. _ Source port: 2B. _ Dest port: 2B. _ Tunnel VNI/VSI:
+ * 3B. _ Total: 39B.
  */
 union cavm_nixx_af_rx_flow_key_algx_fieldx {
 	u64 u;
@@ -5013,8 +4910,8 @@ static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_ipsec_gen_cfg
  *
- * NIX AF Receive IPSEC General Configuration Register
- * This register specifies the values of certain fields in CPT instructions
+ * NIX AF Receive IPSEC General Configuration Register This register
+ * specifies the values of certain fields in CPT instructions
  * (CPT_INST_S) generated by NIX for IPSEC hardware fast-path packets.
  */
 union cavm_nixx_af_rx_ipsec_gen_cfg {
@@ -5039,8 +4936,8 @@ static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_link#_cfg
  *
- * NIX AF Receive Link Configuration Registers
- * Index enumerated by NIX_LINK_E.
+ * NIX AF Receive Link Configuration Registers Index enumerated by
+ * NIX_LINK_E.
  */
 union cavm_nixx_af_rx_linkx_cfg {
 	u64 u;
@@ -5062,12 +4959,11 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_link#_sl#_spkt_cnt
  *
- * INTERNAL: NIX Receive Software Sync Link Packet Count Registers
- *
- * For diagnostic use only for debug of NIX_AF_RX_SW_SYNC[ENA] function. LINK
- * index is enumerated by NIX_LINK_E. SL index is zero for non-express packets,
- * one for express packets. For the internal NIX_LINK_E::MC, SL index is zero for
- * multicast replay, one for mirror replay.
+ * INTERNAL: NIX Receive Software Sync Link Packet Count Registers  For
+ * diagnostic use only for debug of NIX_AF_RX_SW_SYNC[ENA] function. LINK
+ * index is enumerated by NIX_LINK_E. SL index is zero for non-express
+ * packets, one for express packets. For the internal NIX_LINK_E::MC, SL
+ * index is zero for multicast replay, one for mirror replay.
  */
 union cavm_nixx_af_rx_linkx_slx_spkt_cnt {
 	u64 u;
@@ -5090,8 +4986,8 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_link#_wrr_cfg
  *
- * NIX AF Receive Link Weighted Round Robin Configuration Registers
- * Index enumerated by NIX_LINK_E.
+ * NIX AF Receive Link Weighted Round Robin Configuration Registers Index
+ * enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_rx_linkx_wrr_cfg {
 	u64 u;
@@ -5112,32 +5008,26 @@ static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mcast_base
  *
- * NIX AF Receive Multicast/Mirror Table Base Address Register
- * This register specifies the base AF IOVA of the receive multicast/mirror
- * table in NDC/LLC/DRAM. The table consists of 1 \<\< (NIX_AF_RX_MCAST_CFG[SIZE]+8)
- * contiguous NIX_RX_MCE_S structures. The size of each structure is
- * 1 \<\< NIX_AF_CONST3[MCE_LOG2BYTES].
- *
- * The table contains multicast/mirror replication lists. Each list consists of
- * linked entries with NIX_RX_MCE_S[EOL] = 1 in the last entry. All lists
- * must reside within the table size specified by NIX_AF_RX_MCAST_CFG[SIZE]. A
- * mirror replication list will typically consist of two entries, but that is not
- * checked or enforced by hardware.
- *
- * A receive packet is multicast when the action returned by NPC has
- * NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MCAST.
- * A receive packet is mirrored when the action returned by NPC has
- * NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MIRROR.
- * In both cases, NIX_RX_ACTION_S[INDEX] specifies the index of the replication
- * list's first NIX_RX_MCE_S in the table, and a linked entry with
- * NIX_RX_MCE_S[EOL] = 1 indicates the end of list.
- *
- * If a mirrored flow is part of a multicast replication list, software should
- * include the two mirror entries in that list.
- *
- * Internal:
- * A multicast list may have multiple entries for the same LF (e.g. for future
- * RoCE/IB multicast).
+ * NIX AF Receive Multicast/Mirror Table Base Address Register This
+ * register specifies the base AF IOVA of the receive multicast/mirror
+ * table in NDC/LLC/DRAM. The table consists of 1 \<\<
+ * (NIX_AF_RX_MCAST_CFG[SIZE]+8) contiguous NIX_RX_MCE_S structures. The
+ * size of each structure is 1 \<\< NIX_AF_CONST3[MCE_LOG2BYTES].  The
+ * table contains multicast/mirror replication lists. Each list consists
+ * of linked entries with NIX_RX_MCE_S[EOL] = 1 in the last entry. All
+ * lists must reside within the table size specified by
+ * NIX_AF_RX_MCAST_CFG[SIZE]. A mirror replication list will typically
+ * consist of two entries, but that is not checked or enforced by
+ * hardware.  A receive packet is multicast when the action returned by
+ * NPC has NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MCAST. A receive
+ * packet is mirrored when the action returned by NPC has
+ * NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MIRROR. In both cases,
+ * NIX_RX_ACTION_S[INDEX] specifies the index of the replication list's
+ * first NIX_RX_MCE_S in the table, and a linked entry with
+ * NIX_RX_MCE_S[EOL] = 1 indicates the end of list.  If a mirrored flow
+ * is part of a multicast replication list, software should include the
+ * two mirror entries in that list.  Internal: A multicast list may have
+ * multiple entries for the same LF (e.g. for future RoCE/IB multicast).
  */
 union cavm_nixx_af_rx_mcast_base {
 	u64 u;
@@ -5159,18 +5049,15 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_base
  *
- * NIX AF Receive Multicast Buffer Base Address Register
- * This register specifies the base AF IOVA of the receive multicast
- * buffers in NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * NIX AF Receive Multicast Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive multicast buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
  * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
  * NIX_RX_ACTIONOP_E::MCAST. The number of buffers is configured by
- * NIX_AF_RX_MCAST_BUF_CFG[SIZE].
- *
- * If the number of free buffers is insufficient for a received multicast packet,
- * hardware tail drops the packet and sets NIX_AF_GEN_INT[RX_MCAST_DROP].
- *
- * Hardware prioritizes the processing of RX mirror packets over RX multicast
- * packets.
+ * NIX_AF_RX_MCAST_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MCAST_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
  */
 union cavm_nixx_af_rx_mcast_buf_base {
 	u64 u;
@@ -5192,8 +5079,8 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_cfg
  *
- * NIX AF Receive Multicast Buffer Configuration Register
- * See NIX_AF_RX_MCAST_BUF_BASE.
+ * NIX AF Receive Multicast Buffer Configuration Register See
+ * NIX_AF_RX_MCAST_BUF_BASE.
  */
 union cavm_nixx_af_rx_mcast_buf_cfg {
 	u64 u;
@@ -5221,8 +5108,8 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mcast_cfg
  *
- * NIX AF Receive Multicast/Mirror Table Configuration Register
- * See NIX_AF_RX_MCAST_BASE.
+ * NIX AF Receive Multicast/Mirror Table Configuration Register See
+ * NIX_AF_RX_MCAST_BASE.
  */
 union cavm_nixx_af_rx_mcast_cfg {
 	u64 u;
@@ -5247,17 +5134,15 @@ static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_base
  *
- * NIX AF Receive Mirror Buffer Base Address Register
- * This register specifies the base AF IOVA of the receive mirror buffers
- * in NDC/LLC/DRAM. These buffers are used to temporarily store packets whose
- * action returned by NPC has NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MIRROR. The
- * number of buffers is configured by NIX_AF_RX_MIRROR_BUF_CFG[SIZE].
- *
- * If the number of free buffers is insufficient for a received multicast packet,
- * hardware tail drops the packet and sets NIX_AF_GEN_INT[RX_MIRROR_DROP].
- *
- * Hardware prioritizes the processing of RX mirror packets over RX multicast
- * packets.
+ * NIX AF Receive Mirror Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive mirror buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::MIRROR. The number of buffers is configured by
+ * NIX_AF_RX_MIRROR_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MIRROR_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
  */
 union cavm_nixx_af_rx_mirror_buf_base {
 	u64 u;
@@ -5279,8 +5164,8 @@ static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_cfg
  *
- * NIX AF Receive Mirror Buffer Configuration Register
- * See NIX_AF_RX_MIRROR_BUF_BASE.
+ * NIX AF Receive Mirror Buffer Configuration Register See
+ * NIX_AF_RX_MIRROR_BUF_BASE.
  */
 union cavm_nixx_af_rx_mirror_buf_cfg {
 	u64 u;
@@ -5308,8 +5193,8 @@ static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_drop
  *
- * NIX AF Multicast Drop Statistics Register
- * The counter increments for every dropped MC packet marked by the NPC.
+ * NIX AF Multicast Drop Statistics Register The counter increments for
+ * every dropped MC packet marked by the NPC.
  */
 union cavm_nixx_af_rx_npc_mc_drop {
 	u64 u;
@@ -5330,8 +5215,8 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_rcv
  *
- * NIX AF Multicast Receive Statistics Register
- * The counter increments for every received MC packet marked by the NPC.
+ * NIX AF Multicast Receive Statistics Register The counter increments
+ * for every received MC packet marked by the NPC.
  */
 union cavm_nixx_af_rx_npc_mc_rcv {
 	u64 u;
@@ -5352,8 +5237,8 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_drop
  *
- * NIX AF Mirror Drop Statistics Register
- * The counter increments for every dropped MIRROR packet marked by the NPC.
+ * NIX AF Mirror Drop Statistics Register The counter increments for
+ * every dropped MIRROR packet marked by the NPC.
  */
 union cavm_nixx_af_rx_npc_mirror_drop {
 	u64 u;
@@ -5374,8 +5259,8 @@ static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_rcv
  *
- * NIX AF Mirror Receive Statistics Register
- * The counter increments for every received MIRROR packet marked by the NPC.
+ * NIX AF Mirror Receive Statistics Register The counter increments for
+ * every received MIRROR packet marked by the NPC.
  */
 union cavm_nixx_af_rx_npc_mirror_rcv {
 	u64 u;
@@ -5417,8 +5302,7 @@ static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sdp_hw_xoff#
  *
- * NIX AF SDP Transmit Link Hardware Controlled XOFF Registers
- * .
+ * NIX AF SDP Transmit Link Hardware Controlled XOFF Registers .
  */
 union cavm_nixx_af_sdp_hw_xoffx {
 	u64 u;
@@ -5438,8 +5322,8 @@ static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sdp_link_credit
  *
- * NIX AF Transmit Link SDP Credit Register
- * This register tracks SDP link credits.
+ * NIX AF Transmit Link SDP Credit Register This register tracks SDP link
+ * credits.
  */
 union cavm_nixx_af_sdp_link_credit {
 	u64 u;
@@ -5483,8 +5367,8 @@ static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sdp_tx_fifo_status
  *
- * NIX AF SDP Transmit FIFO Status Register
- * Status of FIFO which transmits packets to SDP.
+ * NIX AF SDP Transmit FIFO Status Register Status of FIFO which
+ * transmits packets to SDP.
  */
 union cavm_nixx_af_sdp_tx_fifo_status {
 	u64 u;
@@ -5505,8 +5389,8 @@ static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_seb_active_cycles_pc#
  *
- * NIX AF Active Cycles Register
- * These registers are indexed by the conditional clock domain number.
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
  */
 union cavm_nixx_af_seb_active_cycles_pcx {
 	u64 u;
@@ -5673,8 +5557,8 @@ static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_smq#_head
  *
- * NIX AF SQM SMQ Head Register
- * These registers track the head of the SMQ linked list.
+ * NIX AF SQM SMQ Head Register These registers track the head of the SMQ
+ * linked list.
  */
 union cavm_nixx_af_smqx_head {
 	u64 u;
@@ -5696,8 +5580,8 @@ static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_smq#_nxt_head
  *
- * NIX AF SQM SMQ Next Head Register
- * These registers track the next head of the SMQ linked list.
+ * NIX AF SQM SMQ Next Head Register These registers track the next head
+ * of the SMQ linked list.
  */
 union cavm_nixx_af_smqx_nxt_head {
 	u64 u;
@@ -5719,8 +5603,8 @@ static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_smq#_status
  *
- * NIX AF SQM SMQ Status Register
- * These registers track the status of the SMQ FIFO.
+ * NIX AF SQM SMQ Status Register These registers track the status of the
+ * SMQ FIFO.
  */
 union cavm_nixx_af_smqx_status {
 	u64 u;
@@ -5741,8 +5625,8 @@ static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_smq#_tail
  *
- * NIX AF SQM SMQ Head Register
- * These registers track the tail of SMQ linked list.
+ * NIX AF SQM SMQ Head Register These registers track the tail of SMQ
+ * linked list.
  */
 union cavm_nixx_af_smqx_tail {
 	u64 u;
@@ -5764,8 +5648,8 @@ static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sq_const
  *
- * NIX AF SQ Constants Register
- * This register contains constants for software discovery.
+ * NIX AF SQ Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_nixx_af_sq_const {
 	u64 u;
@@ -5788,8 +5672,8 @@ static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sqm_active_cycles_pc
  *
- * NIX AF SQM Active Cycles Register
- * These registers are indexed by the conditional clock domain number.
+ * NIX AF SQM Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
  */
 union cavm_nixx_af_sqm_active_cycles_pc {
 	u64 u;
@@ -5833,9 +5717,8 @@ static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_sqm_dbg_ctl_status
  *
- * INTERNAL: NIX AF SQM Debug Register
- *
- * This register is for SQM diagnostic use only.
+ * INTERNAL: NIX AF SQM Debug Register  This register is for SQM
+ * diagnostic use only.
  */
 union cavm_nixx_af_sqm_dbg_ctl_status {
 	u64 u;
@@ -5960,8 +5843,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_bytes
  *
- * NIX AF Transmit Level 1 Dropped Bytes Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ * NIX AF Transmit Level 1 Dropped Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
 union cavm_nixx_af_tl1x_dropped_bytes {
 	u64 u;
@@ -5982,8 +5865,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_packets
  *
- * NIX AF Transmit Level 1 Dropped Packets Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ * NIX AF Transmit Level 1 Dropped Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
 union cavm_nixx_af_tl1x_dropped_packets {
 	u64 u;
@@ -6073,13 +5956,13 @@ static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug0
  *
  * NIX AF Transmit Level 1 Meta Descriptor Debug 0 Registers
- * NIX_AF_TL1()_MD_DEBUG0, NIX_AF_TL1()_MD_DEBUG1, NIX_AF_TL1()_MD_DEBUG2 and
- * NIX_AF_TL1()_MD_DEBUG3 provide access to the TLn queue meta descriptor. A TLn
- * queue can hold up to two packet meta descriptors (PMD) and one flush meta
- * descriptor (FMD):
- * * PMD0 state is accessed with [PMD0_VLD], [PMD0_LENGTH] and NIX_AF_TL1()_MD_DEBUG1.
- * * PMD1 is accessed with [PMD1_VLD], [PMD1_LENGTH] and NIX_AF_TL1()_MD_DEBUG2.
- * * FMD is accessed with NIX_AF_TL1()_MD_DEBUG3.
+ * NIX_AF_TL1()_MD_DEBUG0, NIX_AF_TL1()_MD_DEBUG1, NIX_AF_TL1()_MD_DEBUG2
+ * and NIX_AF_TL1()_MD_DEBUG3 provide access to the TLn queue meta
+ * descriptor. A TLn queue can hold up to two packet meta descriptors
+ * (PMD) and one flush meta descriptor (FMD): * PMD0 state is accessed
+ * with [PMD0_VLD], [PMD0_LENGTH] and NIX_AF_TL1()_MD_DEBUG1. * PMD1 is
+ * accessed with [PMD1_VLD], [PMD1_LENGTH] and NIX_AF_TL1()_MD_DEBUG2. *
+ * FMD is accessed with NIX_AF_TL1()_MD_DEBUG3.
  */
 union cavm_nixx_af_tl1x_md_debug0 {
 	u64 u;
@@ -6111,8 +5994,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug1
  *
- * NIX AF Transmit Level 1 Meta Descriptor Debug 1 Registers
- * Packet meta descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl1x_md_debug1 {
 	u64 u;
@@ -6147,8 +6030,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug2
  *
- * NIX AF Transmit Level 1 Meta Descriptor Debug 2 Registers
- * Packet meta descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl1x_md_debug2 {
 	u64 u;
@@ -6183,8 +6066,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug3
  *
- * NIX AF Transmit Level 1 Meta Descriptor Debug 3 Registers
- * Flush meta descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl1x_md_debug3 {
 	u64 u;
@@ -6209,9 +6092,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_red
  *
- * INTERNAL: NIX Transmit Level 1 Red State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL1()_YELLOW.
+ * INTERNAL: NIX Transmit Level 1 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_YELLOW.
  */
 union cavm_nixx_af_tl1x_red {
 	u64 u;
@@ -6234,8 +6116,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_red_bytes
  *
- * NIX AF Transmit Level 1 Red Sent Bytes Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ * NIX AF Transmit Level 1 Red Sent Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
 union cavm_nixx_af_tl1x_red_bytes {
 	u64 u;
@@ -6256,8 +6138,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_red_packets
  *
- * NIX AF Transmit Level 1 Red Sent Packets Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ * NIX AF Transmit Level 1 Red Sent Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
 union cavm_nixx_af_tl1x_red_packets {
 	u64 u;
@@ -6328,8 +6210,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_shape_state
  *
- * NIX AF Transmit Level 1 Shape State Register
- * This register must not be written during normal operation.
+ * NIX AF Transmit Level 1 Shape State Register This register must not be
+ * written during normal operation.
  */
 union cavm_nixx_af_tl1x_shape_state {
 	u64 u;
@@ -6423,8 +6305,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_bytes
  *
- * NIX AF Transmit Level 1 Yellow Sent Bytes Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ * NIX AF Transmit Level 1 Yellow Sent Bytes Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
  */
 union cavm_nixx_af_tl1x_yellow_bytes {
 	u64 u;
@@ -6445,8 +6327,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_packets
  *
- * NIX AF Transmit Level 1 Yellow Sent Packets Registers
- * This register has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ * NIX AF Transmit Level 1 Yellow Sent Packets Registers This register
+ * has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
  */
 union cavm_nixx_af_tl1x_yellow_packets {
 	u64 u;
@@ -6467,8 +6349,8 @@ static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl1_const
  *
- * NIX AF Transmit Level 1 Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Transmit Level 1 Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_tl1_const {
 	u64 u;
@@ -6489,8 +6371,8 @@ static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_cir
  *
- * NIX AF Transmit Level 2 Committed Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 2 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl2x_cir {
 	u64 u;
@@ -6517,9 +6399,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_green
  *
- * INTERNAL: NIX Transmit Level 2 Green State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL1()_GREEN.
+ * INTERNAL: NIX Transmit Level 2 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_GREEN.
  */
 union cavm_nixx_af_tl2x_green {
 	u64 u;
@@ -6545,8 +6426,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug0
  *
- * NIX AF Transmit Level 2 Meta Descriptor Debug 0 Registers
- * See NIX_AF_TL1()_MD_DEBUG0
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0
  */
 union cavm_nixx_af_tl2x_md_debug0 {
 	u64 u;
@@ -6578,8 +6459,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug1
  *
- * NIX AF Transmit Level 2 Meta Descriptor Debug 1 Registers
- * Packet meta descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl2x_md_debug1 {
 	u64 u;
@@ -6614,8 +6495,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug2
  *
- * NIX AF Transmit Level 2 Meta Descriptor Debug 2 Registers
- * Packet meta descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl2x_md_debug2 {
 	u64 u;
@@ -6650,8 +6531,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug3
  *
- * NIX AF Transmit Level 2 Meta Descriptor Debug 3 Registers
- * Flush meta descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl2x_md_debug3 {
 	u64 u;
@@ -6698,8 +6579,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_pir
  *
- * NIX AF Transmit Level 2 Peak Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 2 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl2x_pir {
 	u64 u;
@@ -6749,9 +6630,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_red
  *
- * INTERNAL: NIX Transmit Level 2 Red State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL1()_RED.
+ * INTERNAL: NIX Transmit Level 2 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_RED.
  */
 union cavm_nixx_af_tl2x_red {
 	u64 u;
@@ -6844,8 +6724,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_shape_state
  *
- * NIX AF Transmit Level 2 Shape State Registers
- * This register must not be written during normal operation.
+ * NIX AF Transmit Level 2 Shape State Registers This register must not
+ * be written during normal operation.
  */
 union cavm_nixx_af_tl2x_shape_state {
 	u64 u;
@@ -6868,8 +6748,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_sw_xoff
  *
- * NIX AF Transmit Level 2 Software Controlled XOFF Registers
- * This register has the same bit fields as NIX_AF_TL1()_SW_XOFF.
+ * NIX AF Transmit Level 2 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF.
  */
 union cavm_nixx_af_tl2x_sw_xoff {
 	u64 u;
@@ -6917,9 +6797,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2#_yellow
  *
- * INTERNAL: NIX Transmit Level 2 Yellow State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL1()_YELLOW.
+ * INTERNAL: NIX Transmit Level 2 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_YELLOW.
  */
 union cavm_nixx_af_tl2x_yellow {
 	u64 u;
@@ -6942,8 +6821,8 @@ static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl2_const
  *
- * NIX AF Transmit Level 2 Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Transmit Level 2 Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_tl2_const {
 	u64 u;
@@ -6964,8 +6843,8 @@ static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_cir
  *
- * NIX AF Transmit Level 3 Committed Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 3 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl3x_cir {
 	u64 u;
@@ -7018,8 +6897,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug0
  *
- * NIX AF Transmit Level 3 Meta Descriptor Debug 0 Registers
- * See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl3x_md_debug0 {
 	u64 u;
@@ -7051,8 +6930,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug1
  *
- * NIX AF Transmit Level 3 Meta Descriptor Debug 1 Registers
- * Packet meta descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl3x_md_debug1 {
 	u64 u;
@@ -7087,8 +6966,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug2
  *
- * NIX AF Transmit Level 3 Meta Descriptor Debug 2 Registers
- * Packet meta descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl3x_md_debug2 {
 	u64 u;
@@ -7123,8 +7002,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug3
  *
- * NIX AF Transmit Level 3 Meta Descriptor Debug 3 Registers
- * Flush meta descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl3x_md_debug3 {
 	u64 u;
@@ -7171,8 +7050,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_pir
  *
- * NIX AF Transmit Level 3 Peak Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 3 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl3x_pir {
 	u64 u;
@@ -7200,7 +7079,6 @@ static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_tl3#_pointers
  *
  * INTERNAL: NIX Transmit Level 3 Linked List Pointers Debug Register
- *
  * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
  */
 union cavm_nixx_af_tl3x_pointers {
@@ -7224,9 +7102,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_red
  *
- * INTERNAL: NIX Transmit Level 3 Red State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL3()_YELLOW.
+ * INTERNAL: NIX Transmit Level 3 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
  */
 union cavm_nixx_af_tl3x_red {
 	u64 u;
@@ -7249,8 +7126,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_sched_state
  *
- * NIX AF Transmit Level 3 Scheduling Control State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ * NIX AF Transmit Level 3 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
 union cavm_nixx_af_tl3x_sched_state {
 	u64 u;
@@ -7271,8 +7148,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_schedule
  *
- * NIX AF Transmit Level 3 Scheduling Control Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ * NIX AF Transmit Level 3 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
 union cavm_nixx_af_tl3x_schedule {
 	u64 u;
@@ -7321,9 +7198,9 @@ static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_shape_state
  *
- * NIX AF Transmit Level 3 Shaping State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SHAPE_STATE.
- * This register must not be written during normal operation.
+ * NIX AF Transmit Level 3 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
  */
 union cavm_nixx_af_tl3x_shape_state {
 	u64 u;
@@ -7346,8 +7223,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3#_sw_xoff
  *
- * NIX AF Transmit Level 3 Software Controlled XOFF Registers
- * This register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ * NIX AF Transmit Level 3 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
  */
 union cavm_nixx_af_tl3x_sw_xoff {
 	u64 u;
@@ -7418,8 +7295,8 @@ static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3_const
  *
- * NIX AF Transmit Level 3 Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Transmit Level 3 Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_tl3_const {
 	u64 u;
@@ -7482,12 +7359,12 @@ static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_link#_cfg
  *
- * NIX AF Transmit Level 3/2 Link Configuration Registers
- * These registers specify the links and associated channels that a given TL3 or
- * TL2 queue (depending on NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL]) can transmit on.
- * Each TL3/TL2 queue can be enabled to transmit on and be backpressured by one or
- * more links and associated channels. The last index (LINK) is enumerated by
- * NIX_LINK_E.
+ * NIX AF Transmit Level 3/2 Link Configuration Registers These registers
+ * specify the links and associated channels that a given TL3 or TL2
+ * queue (depending on NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL]) can transmit
+ * on. Each TL3/TL2 queue can be enabled to transmit on and be
+ * backpressured by one or more links and associated channels. The last
+ * index (LINK) is enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_tl3_tl2x_linkx_cfg {
 	u64 u;
@@ -7532,8 +7409,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_cir
  *
- * NIX AF Transmit Level 4 Committed Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 4 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl4x_cir {
 	u64 u;
@@ -7560,9 +7437,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_green
  *
- * INTERNAL: NIX Transmit Level 4 Green State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL3()_GREEN.
+ * INTERNAL: NIX Transmit Level 4 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_GREEN.
  */
 union cavm_nixx_af_tl4x_green {
 	u64 u;
@@ -7588,8 +7464,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug0
  *
- * NIX AF Transmit Level 4 Meta Descriptor Debug 0 Registers
- * See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl4x_md_debug0 {
 	u64 u;
@@ -7621,8 +7497,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug1
  *
- * NIX AF Transmit Level 4 Meta Descriptor Debug 1 Registers
- * Packet meta descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl4x_md_debug1 {
 	u64 u;
@@ -7657,8 +7533,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug2
  *
- * NIX AF Transmit Level 4 Meta Descriptor Debug 2 Registers
- * Packet meta descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl4x_md_debug2 {
 	u64 u;
@@ -7693,8 +7569,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug3
  *
- * NIX AF Transmit Level 4 Meta Descriptor Debug 3 Registers
- * Flush meta descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
  */
 union cavm_nixx_af_tl4x_md_debug3 {
 	u64 u;
@@ -7741,8 +7617,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_pir
  *
- * NIX AF Transmit Level 4 Peak Information Rate Registers
- * This register has the same bit fields as NIX_AF_TL1()_CIR.
+ * NIX AF Transmit Level 4 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
  */
 union cavm_nixx_af_tl4x_pir {
 	u64 u;
@@ -7770,7 +7646,6 @@ static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
  * Register (RVU_PF_BAR0) nix#_af_tl4#_pointers
  *
  * INTERNAL: NIX Transmit Level 4 Linked List Pointers Debug Register
- *
  * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
  */
 union cavm_nixx_af_tl4x_pointers {
@@ -7794,9 +7669,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_red
  *
- * INTERNAL: NIX Transmit Level 4 Red State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL3()_YELLOW.
+ * INTERNAL: NIX Transmit Level 4 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
  */
 union cavm_nixx_af_tl4x_red {
 	u64 u;
@@ -7819,8 +7693,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_sched_state
  *
- * NIX AF Transmit Level 4 Scheduling Control State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ * NIX AF Transmit Level 4 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
  */
 union cavm_nixx_af_tl4x_sched_state {
 	u64 u;
@@ -7841,8 +7715,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_schedule
  *
- * NIX AF Transmit Level 4 Scheduling Control Registers
- * This register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ * NIX AF Transmit Level 4 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
  */
 union cavm_nixx_af_tl4x_schedule {
 	u64 u;
@@ -7864,9 +7738,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_sdp_link_cfg
  *
- * NIX AF Transmit Level 4 Link Configuration Registers
- * These registers specify which TL4 queues transmit to and are optionally
- * backpressured by SDP.
+ * NIX AF Transmit Level 4 Link Configuration Registers These registers
+ * specify which TL4 queues transmit to and are optionally backpressured
+ * by SDP.
  */
 union cavm_nixx_af_tl4x_sdp_link_cfg {
 	u64 u;
@@ -7890,8 +7764,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_shape
  *
- * NIX AF Transmit Level 4 Shaping Control Registers
- * This register has the same bit fields as NIX_AF_TL2()_SHAPE.
+ * NIX AF Transmit Level 4 Shaping Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE.
  */
 union cavm_nixx_af_tl4x_shape {
 	u64 u;
@@ -7918,9 +7792,9 @@ static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_shape_state
  *
- * NIX AF Transmit Level 4 Shaping State Registers
- * This register has the same bit fields as NIX_AF_TL2()_SHAPE_STATE.
- * This register must not be written during normal operation.
+ * NIX AF Transmit Level 4 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
  */
 union cavm_nixx_af_tl4x_shape_state {
 	u64 u;
@@ -7943,8 +7817,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_sw_xoff
  *
- * NIX AF Transmit Level 4 Software Controlled XOFF Registers
- * This register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ * NIX AF Transmit Level 4 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
  */
 union cavm_nixx_af_tl4x_sw_xoff {
 	u64 u;
@@ -7992,9 +7866,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4#_yellow
  *
- * INTERNAL: NIX Transmit Level 4 Yellow State Debug Register
- *
- * This register has the same bit fields as NIX_AF_TL3()_YELLOW
+ * INTERNAL: NIX Transmit Level 4 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_YELLOW
  */
 union cavm_nixx_af_tl4x_yellow {
 	u64 u;
@@ -8017,8 +7890,8 @@ static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tl4_const
  *
- * NIX AF Transmit Level 4 Constants Register
- * This register contains constants for software discovery.
+ * NIX AF Transmit Level 4 Constants Register This register contains
+ * constants for software discovery.
  */
 union cavm_nixx_af_tl4_const {
 	u64 u;
@@ -8039,9 +7912,9 @@ static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_expr_credit
  *
- * NIX AF Transmit Link Express Credit Registers
- * These registers track credits per link for express packets that may potentially
- * preempt normal packets. Link index enumerated by NIX_LINK_E.
+ * NIX AF Transmit Link Express Credit Registers These registers track
+ * credits per link for express packets that may potentially preempt
+ * normal packets. Link index enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_tx_linkx_expr_credit {
 	u64 u;
@@ -8065,8 +7938,8 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_hw_xoff
  *
- * NIX AF Transmit Link Hardware Controlled XOFF Registers
- * Link index enumerated by NIX_LINK_E.
+ * NIX AF Transmit Link Hardware Controlled XOFF Registers Link index
+ * enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_tx_linkx_hw_xoff {
 	u64 u;
@@ -8086,9 +7959,9 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_norm_credit
  *
- * NIX AF Transmit Link Normal Credit Registers
- * These registers track credits per link for normal (potentially preemptable)
- * packets sent to CGX and LBK. Link index enumerated by NIX_LINK_E.
+ * NIX AF Transmit Link Normal Credit Registers These registers track
+ * credits per link for normal (potentially preemptable) packets sent to
+ * CGX and LBK. Link index enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_tx_linkx_norm_credit {
 	u64 u;
@@ -8112,8 +7985,8 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_link#_sw_xoff
  *
- * NIX AF Transmit Link Software Controlled XOFF Registers
- * Link index enumerated by NIX_LINK_E.
+ * NIX AF Transmit Link Software Controlled XOFF Registers Link index
+ * enumerated by NIX_LINK_E.
  */
 union cavm_nixx_af_tx_linkx_sw_xoff {
 	u64 u;
@@ -8133,13 +8006,13 @@ static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_mcast#
  *
- * NIX AF Transmit Multicast Registers
- * These registers access transmit multicast table entries used to specify multicast replication
- * lists. Each list consists of linked entries with [EOL] = 1 in the last entry.
- *
- * A transmit packet is multicast when the action returned by NPC has NIX_TX_ACTION_S[OP] =
- * NIX_TX_ACTIONOP_E::MCAST. NIX_TX_ACTION_S[INDEX] points to the start of the multicast
- * replication list, and [EOL] = 1 indicates the end of list.
+ * NIX AF Transmit Multicast Registers These registers access transmit
+ * multicast table entries used to specify multicast replication lists.
+ * Each list consists of linked entries with [EOL] = 1 in the last entry.
+ * A transmit packet is multicast when the action returned by NPC has
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST. NIX_TX_ACTION_S[INDEX]
+ * points to the start of the multicast replication list, and [EOL] = 1
+ * indicates the end of list.
  */
 union cavm_nixx_af_tx_mcastx {
 	u64 u;
@@ -8163,8 +8036,8 @@ static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_config
  *
- * NIX AF Transmit NPC Response Capture Configuration Register
- * Configures the NPC response capture logic for transmit packets. When enabled,
+ * NIX AF Transmit NPC Response Capture Configuration Register Configures
+ * the NPC response capture logic for transmit packets. When enabled,
  * allows NPC responses for selected packets to be captured in
  * NIX_AF_TX_NPC_CAPTURE_INFO and NIX_AF_TX_NPC_CAPTURE_RESP().
  */
@@ -8196,9 +8069,9 @@ static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_info
  *
- * NIX AF Transmit NPC Response Capture Information Register
- * This register contains captured NPC response information for a transmit packet.
- * See NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ * NIX AF Transmit NPC Response Capture Information Register This
+ * register contains captured NPC response information for a transmit
+ * packet. See NIX_AF_TX_NPC_CAPTURE_CONFIG.
  */
 union cavm_nixx_af_tx_npc_capture_info {
 	u64 u;
@@ -8223,9 +8096,10 @@ static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_resp#
  *
- * NIX AF Transmit NPC Capture Response Registers
- * These registers contain the captured NPC response for a transmit packet when
- * NIX_AF_TX_NPC_CAPTURE_INFO[VLD] is set. See also NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ * NIX AF Transmit NPC Capture Response Registers These registers contain
+ * the captured NPC response for a transmit packet when
+ * NIX_AF_TX_NPC_CAPTURE_INFO[VLD] is set. See also
+ * NIX_AF_TX_NPC_CAPTURE_CONFIG.
  */
 union cavm_nixx_af_tx_npc_capture_respx {
 	u64 u;
@@ -8268,8 +8142,8 @@ static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_ctl
  *
- * NIX AF Transmit Vtag Definition Control Registers
- * The transmit Vtag definition table specifies Vtag layers (e.g. VLAN, E-TAG) to
+ * NIX AF Transmit Vtag Definition Control Registers The transmit Vtag
+ * definition table specifies Vtag layers (e.g. VLAN, E-TAG) to
  * optionally insert or replace in the TX packet header. Indexed by
  * NIX_TX_VTAG_ACTION_S[VTAG*_DEF].
  */
@@ -8292,8 +8166,8 @@ static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
 /**
  * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_data
  *
- * NIX AF Transmit Vtag Definition Data Registers
- * See NIX_AF_TX_VTAG_DEF()_CTL.
+ * NIX AF Transmit Vtag Definition Data Registers See
+ * NIX_AF_TX_VTAG_DEF()_CTL.
  */
 union cavm_nixx_af_tx_vtag_defx_data {
 	u64 u;
@@ -8356,8 +8230,8 @@ static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1c
  *
- * NIX LF Completion Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * NIX LF Completion Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
  */
 union cavm_nixx_lf_cintx_ena_w1c {
 	u64 u;
@@ -8378,8 +8252,8 @@ static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1s
  *
- * NIX LF Completion Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * NIX LF Completion Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_cintx_ena_w1s {
 	u64 u;
@@ -8421,8 +8295,8 @@ static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cint#_int_w1s
  *
- * NIX LF Completion Interrupt Set Registers
- * This register sets interrupt bits.
+ * NIX LF Completion Interrupt Set Registers This register sets interrupt
+ * bits.
  */
 union cavm_nixx_lf_cintx_int_w1s {
 	u64 u;
@@ -8466,11 +8340,9 @@ static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_door
  *
- * NIX LF CQ Doorbell Operation Register
- * A write to this register dequeues CQEs from a CQ ring within the LF.
- * A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF CQ Doorbell Operation Register A write to this register
+ * dequeues CQEs from a CQ ring within the LF. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_cq_op_door {
 	u64 u;
@@ -8493,13 +8365,10 @@ static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_int
  *
- * NIX LF Completion Queue Interrupt Operation Register
- * A 64-bit atomic load-and-add to this register reads CQ interrupts and
- * interrupt enables.
- * A write optionally sets or clears interrupts and interrupt enables.
- * A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Completion Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads CQ interrupts and interrupt
+ * enables. A write optionally sets or clears interrupts and interrupt
+ * enables. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_cq_op_int {
 	u64 u;
@@ -8524,13 +8393,11 @@ static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_status
  *
- * NIX LF Completion Queue Status Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_CQ_CTX_S[HEAD,TAIL].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the CQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Completion Queue Status Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_CQ_CTX_S[HEAD,TAIL]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the CQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_cq_op_status {
 	u64 u;
@@ -8598,8 +8465,8 @@ static inline u64 CAVM_NIXX_LF_ERR_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1c
  *
- * NIX LF Error Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_err_int_ena_w1c {
 	u64 u;
@@ -8642,8 +8509,8 @@ static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1s
  *
- * NIX LF Error Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_err_int_ena_w1s {
 	u64 u;
@@ -8686,8 +8553,7 @@ static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_err_int_w1s
  *
- * NIX LF Error Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX LF Error Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_nixx_lf_err_int_w1s {
 	u64 u;
@@ -8752,8 +8618,8 @@ static inline u64 CAVM_NIXX_LF_GINT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1c
  *
- * NIX LF General Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX LF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_gint_ena_w1c {
 	u64 u;
@@ -8775,8 +8641,8 @@ static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1s
  *
- * NIX LF General Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX LF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_gint_ena_w1s {
 	u64 u;
@@ -8798,8 +8664,8 @@ static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_gint_w1s
  *
- * NIX LF General Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX LF General Interrupt Set Register This register sets interrupt
+ * bits.
  */
 union cavm_nixx_lf_gint_w1s {
 	u64 u;
@@ -8821,11 +8687,11 @@ static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_mnq_err_dbg
  *
- * NIX LF Meta-descriptor Enqueue Error Debug Register
- * This register captures debug info for an error detected during send
- * meta-descriptor enqueue from an SQ to an SMQ.
- * Hardware sets [VALID] when the debug info is captured, and subsequent errors
- * are not captured until software clears [VALID] by writing a one to it.
+ * NIX LF Meta-descriptor Enqueue Error Debug Register This register
+ * captures debug info for an error detected during send meta-descriptor
+ * enqueue from an SQ to an SMQ. Hardware sets [VALID] when the debug
+ * info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
  */
 union cavm_nixx_lf_mnq_err_dbg {
 	u64 u;
@@ -8849,12 +8715,12 @@ static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_op_ipsec_dyno_cnt
  *
- * NIX LF IPSEC Dynamic Ordering Counter Operation Register
- * A 64-bit atomic load-and-add to this register reads an IPSEC dynamic ordering
- * counter (NIX_IPSEC_DYNO_S). A write decrements NIX_IPSEC_DYNO_S[COUNT]. A read
- * is RAZ. See NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA].
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF IPSEC Dynamic Ordering Counter Operation Register A 64-bit
+ * atomic load-and-add to this register reads an IPSEC dynamic ordering
+ * counter (NIX_IPSEC_DYNO_S). A write decrements
+ * NIX_IPSEC_DYNO_S[COUNT]. A read is RAZ. See
+ * NIX_AF_LF()_RX_IPSEC_DYNO_CFG[DYNO_ENA].  RSL accesses to this
+ * register are RAZ/WI.
  */
 union cavm_nixx_lf_op_ipsec_dyno_cnt {
 	u64 u;
@@ -8878,30 +8744,25 @@ static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_op_send#
  *
- * NIX LF Send Operation Registers
- * An LMTST (or large store from CPT) to this address enqueues one or more SQEs to
- * a send queue. NIX_SEND_HDR_S[SQ] in the first SQE selects the send queue.The
- * maximum size of each SQE is specified by NIX_SQ_CTX_S[MAX_SQE_SIZE].
- *
- * A read to this address is RAZ.
- *
- * An RSL access to this address will fault.
- *
- * The endianness of the instruction write data is controlled by NIX_AF_LF()_CFG[BE].
- *
- * When a NIX_SEND_JUMP_S is not present in the SQE, the SQE consists of the
- * entire send descriptor.
- *
- * When a NIX_SEND_JUMP_S is present in the SQE, the SQE must contain exactly the
- * portion of the send descriptor up to and including the NIX_SEND_JUMP_S, and the
- * remainder of the send descriptor must be at LF IOVA NIX_SEND_JUMP_S[ADDR] in
- * LLC/DRAM.
- *
- * Software must ensure that all LLC/DRAM locations that will be referenced by NIX while
- * processing this descriptor, including all packet data and post-jump subdescriptors
- * contain the latest updates before issuing the LMTST. A DMB instruction may be required prior
- * to the LMTST to ensure this. A DMB following the LMTST may be useful if SQ descriptor ordering
- * matters and more than one CPU core is simultaneously enqueueing to the same SQ.
+ * NIX LF Send Operation Registers An LMTST (or large store from CPT) to
+ * this address enqueues one or more SQEs to a send queue.
+ * NIX_SEND_HDR_S[SQ] in the first SQE selects the send queue.The maximum
+ * size of each SQE is specified by NIX_SQ_CTX_S[MAX_SQE_SIZE].  A read
+ * to this address is RAZ.  An RSL access to this address will fault.
+ * The endianness of the instruction write data is controlled by
+ * NIX_AF_LF()_CFG[BE].  When a NIX_SEND_JUMP_S is not present in the
+ * SQE, the SQE consists of the entire send descriptor.  When a
+ * NIX_SEND_JUMP_S is present in the SQE, the SQE must contain exactly
+ * the portion of the send descriptor up to and including the
+ * NIX_SEND_JUMP_S, and the remainder of the send descriptor must be at
+ * LF IOVA NIX_SEND_JUMP_S[ADDR] in LLC/DRAM.  Software must ensure that
+ * all LLC/DRAM locations that will be referenced by NIX while processing
+ * this descriptor, including all packet data and post-jump
+ * subdescriptors contain the latest updates before issuing the LMTST. A
+ * DMB instruction may be required prior to the LMTST to ensure this. A
+ * DMB following the LMTST may be useful if SQ descriptor ordering
+ * matters and more than one CPU core is simultaneously enqueueing to the
+ * same SQ.
  */
 union cavm_nixx_lf_op_sendx {
 	u64 u;
@@ -8942,8 +8803,8 @@ static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1c
  *
- * NIX LF Queue Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * NIX LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_qintx_ena_w1c {
 	u64 u;
@@ -8964,8 +8825,8 @@ static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1s
  *
- * NIX LF Queue Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * NIX LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_qintx_ena_w1s {
 	u64 u;
@@ -9059,8 +8920,8 @@ static inline u64 CAVM_NIXX_LF_RAS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1c
  *
- * NIX LF RAS Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NIX LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_nixx_lf_ras_ena_w1c {
 	u64 u;
@@ -9091,8 +8952,8 @@ static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1s
  *
- * NIX LF RAS Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NIX LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_nixx_lf_ras_ena_w1s {
 	u64 u;
@@ -9123,8 +8984,7 @@ static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_ras_w1s
  *
- * NIX LF RAS Interrupt Set Register
- * This register sets interrupt bits.
+ * NIX LF RAS Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_nixx_lf_ras_w1s {
 	u64 u;
@@ -9155,13 +9015,11 @@ static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_octs
  *
- * NIX LF Receive Queue Dropped Octets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_RQ_CTX_S[DROP_OCTS].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Receive Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_RQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_drop_octs {
 	u64 u;
@@ -9183,13 +9041,11 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_pkts
  *
- * NIX LF Receive Queue Dropped Packets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_RQ_CTX_S[DROP_PKTS].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Receive Queue Dropped Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[DROP_PKTS].
+ * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_drop_pkts {
 	u64 u;
@@ -9211,14 +9067,12 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_int
  *
- * NIX LF Receive Queue Interrupt Operation Register
- * A 64-bit atomic load-and-add to this register reads RQ interrupts and
- * interrupt enables.
- * A 64-bit write optionally sets or clears interrupts and interrupt enables.
- *
- * All other accesses to this register (e.g. reads, 128-bit accesses) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Receive Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads RQ interrupts and interrupt
+ * enables. A 64-bit write optionally sets or clears interrupts and
+ * interrupt enables.  All other accesses to this register (e.g. reads,
+ * 128-bit accesses) are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_int {
 	u64 u;
@@ -9243,12 +9097,10 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_octs
  *
- * NIX LF Receive Queue Octets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_RQ_CTX_S[OCTS]. The atomic
- * write data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
+ * NIX LF Receive Queue Octets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[OCTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_octs {
@@ -9271,12 +9123,10 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_pkts
  *
- * NIX LF Receive Queue Packets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_RQ_CTX_S[PKTS]. The atomic
- * write data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
+ * NIX LF Receive Queue Packets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[PKTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_pkts {
@@ -9299,13 +9149,11 @@ static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_re_pkts
  *
- * NIX LF Receive Queue Errored Packets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_RQ_CTX_S[RE_PKTS].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Receive Queue Errored Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[RE_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_rq_op_re_pkts {
 	u64 u;
@@ -9347,8 +9195,8 @@ static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_rx_stat#
  *
- * NIX LF Receive Statistics Registers
- * The last dimension indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ * NIX LF Receive Statistics Registers The last dimension indicates which
+ * statistic, and is enumerated by NIX_STAT_LF_RX_E.
  */
 union cavm_nixx_lf_rx_statx {
 	u64 u;
@@ -9369,11 +9217,11 @@ static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_send_err_dbg
  *
- * NIX LF Send Error Debug Register
- * This register captures debug info an error detected on packet send after a
- * meta-descriptor is granted by PSE.
- * Hardware sets [VALID] when the debug info is captured, and subsequent errors
- * are not captured until software clears [VALID] by writing a one to it.
+ * NIX LF Send Error Debug Register This register captures debug info an
+ * error detected on packet send after a meta-descriptor is granted by
+ * PSE. Hardware sets [VALID] when the debug info is captured, and
+ * subsequent errors are not captured until software clears [VALID] by
+ * writing a one to it.
  */
 union cavm_nixx_lf_send_err_dbg {
 	u64 u;
@@ -9397,13 +9245,11 @@ static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_octs
  *
- * NIX LF Send Queue Dropped Octets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_SQ_CTX_S[DROP_OCTS].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Send Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_drop_octs {
 	u64 u;
@@ -9425,13 +9271,11 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_pkts
  *
- * NIX LF Send Queue Dropped Packets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_SQ_CTX_S[DROP_PKTS].
- * The atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Send Queue Dropped Packets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_drop_pkts {
 	u64 u;
@@ -9453,11 +9297,11 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_err_dbg
  *
- * NIX LF SQ Operation Error Debug Register
- * This register captures debug info for an error detected on LMT store to
- * NIX_LF_OP_SEND() or when a NIX_LF_SQ_OP_* register is accessed.
- * Hardware sets [VALID] when the debug info is captured, and subsequent errors
- * are not captured until software clears [VALID] by writing a one to it.
+ * NIX LF SQ Operation Error Debug Register This register captures debug
+ * info for an error detected on LMT store to NIX_LF_OP_SEND() or when a
+ * NIX_LF_SQ_OP_* register is accessed. Hardware sets [VALID] when the
+ * debug info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
  */
 union cavm_nixx_lf_sq_op_err_dbg {
 	u64 u;
@@ -9481,13 +9325,11 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_int
  *
- * NIX LF Send Queue Interrupt Operation Register
- * A 64-bit atomic load-and-add to this register reads SQ interrupts,
- * interrupt enables and XOFF status.
- * A write optionally sets or clears interrupts, interrupt enables and XOFF
- * status. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Send Queue Interrupt Operation Register A 64-bit atomic load-
+ * and-add to this register reads SQ interrupts, interrupt enables and
+ * XOFF status. A write optionally sets or clears interrupts, interrupt
+ * enables and XOFF status. A read is RAZ.  RSL accesses to this register
+ * are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_int {
 	u64 u;
@@ -9513,13 +9355,11 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_octs
  *
- * NIX LF Send Queue Octets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_SQ_CTX_S[OCTS]. The atomic
- * write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Send Queue Octets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[OCTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_octs {
 	u64 u;
@@ -9541,13 +9381,11 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_pkts
  *
- * NIX LF Send Queue Packets Operation Register
- * A 64-bit atomic load-and-add to this register reads NIX_SQ_CTX_S[PKTS]. The atomic
- * write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NIX LF Send Queue Packets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[PKTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_pkts {
 	u64 u;
@@ -9569,15 +9407,12 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_status
  *
- * NIX LF Send Queue Status Operation Register
- * A 64-bit atomic load-and-add to this register reads status fields in
- * NIX_SQ_CTX_S. The atomic write data has format NIX_OP_Q_WDATA_S and
- * selects the SQ within LF.
- * Completion of the load-and-add operation also ensures that all previously
- * issued LMT stores to NIX_LF_OP_SEND() have completed.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
+ * NIX LF Send Queue Status Operation Register A 64-bit atomic load-and-
+ * add to this register reads status fields in NIX_SQ_CTX_S. The atomic
+ * write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
+ * Completion of the load-and-add operation also ensures that all
+ * previously issued LMT stores to NIX_LF_OP_SEND() have completed.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
  * RSL accesses to this register are RAZ/WI.
  */
 union cavm_nixx_lf_sq_op_status {
@@ -9613,8 +9448,8 @@ static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
 /**
  * Register (RVU_PFVF_BAR2) nix#_lf_tx_stat#
  *
- * NIX LF Transmit Statistics Registers
- * The last dimension indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ * NIX LF Transmit Statistics Registers The last dimension indicates
+ * which statistic, and is enumerated by NIX_STAT_LF_TX_E.
  */
 union cavm_nixx_lf_tx_statx {
 	u64 u;
@@ -9658,17 +9493,13 @@ static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
 /**
  * Register (RVU_PF_BAR0) nix#_priv_lf#_cfg
  *
- * NIX Privileged Local Function Configuration Registers
- * These registers allow each NIX local function (LF) to be provisioned to a VF/PF
- * for RVU. See also NIX_AF_RVU_LF_CFG_DEBUG.
- *
- * Software should read this register after write to ensure that the LF is mapped to
- * [PF_FUNC] before issuing transactions to the mapped PF and function.
- *
- * [SLOT] must be zero.
- *
- * Internal:
- * Hardware ignores [SLOT] and always assumes 0x0.
+ * NIX Privileged Local Function Configuration Registers These registers
+ * allow each NIX local function (LF) to be provisioned to a VF/PF for
+ * RVU. See also NIX_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
  */
 union cavm_nixx_priv_lfx_cfg {
 	u64 u;
diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-npa.h b/drivers/net/cavium/octeontx2/cavm-csrs-npa.h
index 9d9e1d3ba0..6bacddd830 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-npa.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-npa.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_NPA_H__
 #define __CAVM_CSRS_NPA_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,15 +14,15 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium NPA.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
 /**
  * Enumeration npa_af_int_vec_e
  *
- * NPA Admin Function Interrupt Vector Enumeration
- * Enumerates the NPA AF MSI-X interrupt vectors.
+ * NPA Admin Function Interrupt Vector Enumeration Enumerates the NPA AF
+ * MSI-X interrupt vectors.
  */
 #define CAVM_NPA_AF_INT_VEC_E_AF_ERR (3)
 #define CAVM_NPA_AF_INT_VEC_E_AQ_DONE (2)
@@ -66,8 +33,8 @@
 /**
  * Enumeration npa_aq_comp_e
  *
- * NPA Admin Queue Completion Enumeration
- * Enumerates the values of NPA_AQ_RES_S[COMPCODE].
+ * NPA Admin Queue Completion Enumeration Enumerates the values of
+ * NPA_AQ_RES_S[COMPCODE].
  */
 #define CAVM_NPA_AQ_COMP_E_CTX_FAULT (4)
 #define CAVM_NPA_AQ_COMP_E_CTX_POISON (3)
@@ -79,8 +46,8 @@
 /**
  * Enumeration npa_aq_ctype_e
  *
- * NPA Admin Queue Context Type Enumeration
- * Enumerates NPA_AQ_INST_S[CTYPE] values.
+ * NPA Admin Queue Context Type Enumeration Enumerates
+ * NPA_AQ_INST_S[CTYPE] values.
  */
 #define CAVM_NPA_AQ_CTYPE_E_AURA (0)
 #define CAVM_NPA_AQ_CTYPE_E_POOL (1)
@@ -88,8 +55,8 @@
 /**
  * Enumeration npa_aq_instop_e
  *
- * NPA Admin Queue Opcode Enumeration
- * Enumerates NPA_AQ_INST_S[OP] values.
+ * NPA Admin Queue Opcode Enumeration Enumerates NPA_AQ_INST_S[OP]
+ * values.
  */
 #define CAVM_NPA_AQ_INSTOP_E_INIT (1)
 #define CAVM_NPA_AQ_INSTOP_E_LOCK (4)
@@ -101,8 +68,8 @@
 /**
  * Enumeration npa_aura_err_int_e
  *
- * NPA Aura Error Interrupt Enumeration
- * Enumerates the bit index of NPA_AURA_S[ERR_INT], and NPA_AURA_S[ERR_INT_ENA].
+ * NPA Aura Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_AURA_S[ERR_INT], and NPA_AURA_S[ERR_INT_ENA].
  */
 #define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_OVER (1)
 #define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_UNDER (2)
@@ -113,18 +80,19 @@
 /**
  * Enumeration npa_bpintf_e
  *
- * NPA Backpressure Interface Enumeration
- * Enumerates index of NPA_AURA_S[BP_ENA].
+ * NPA Backpressure Interface Enumeration Enumerates index of
+ * NPA_AURA_S[BP_ENA].
  */
 #define CAVM_NPA_BPINTF_E_NIXX_RX(a) (0 + (a))
 
 /**
  * Enumeration npa_inpq_e
  *
- * NPA Input Queue Enumeration
- * Enumerates ALLOC/FREE input queues from coprocessors.
+ * NPA Input Queue Enumeration Enumerates ALLOC/FREE input queues from
+ * coprocessors.
  */
 #define CAVM_NPA_INPQ_E_AURA_OP (0xe)
+#define CAVM_NPA_INPQ_E_BPHY (7)
 #define CAVM_NPA_INPQ_E_DPI (6)
 #define CAVM_NPA_INPQ_E_INTERNAL_RSV (0xf)
 #define CAVM_NPA_INPQ_E_NIXX_RX(a) (0 + 2 * (a))
@@ -136,8 +104,8 @@
 /**
  * Enumeration npa_lf_int_vec_e
  *
- * NPA Local Function Interrupt Vector Enumeration
- * Enumerates the NPA MSI-X interrupt vectors per LF.
+ * NPA Local Function Interrupt Vector Enumeration Enumerates the NPA
+ * MSI-X interrupt vectors per LF.
  */
 #define CAVM_NPA_LF_INT_VEC_E_ERR_INT (0x40)
 #define CAVM_NPA_LF_INT_VEC_E_POISON (0x41)
@@ -146,9 +114,9 @@
 /**
  * Enumeration npa_ndc0_port_e
  *
- * NPA NDC0 Port Enumeration
- * Enumerates NPA NDC0 (NDC_IDX_E::NPA_U(0)) ports and the PORT index of
- * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ * NPA NDC0 Port Enumeration Enumerates NPA NDC0 (NDC_IDX_E::NPA_U(0))
+ * ports and the PORT index of NDC_AF_PORT()_RT()_RW()_REQ_PC and
+ * NDC_AF_PORT()_RT()_RW()_LAT_PC.
  */
 #define CAVM_NPA_NDC0_PORT_E_AURA0 (0)
 #define CAVM_NPA_NDC0_PORT_E_AURA1 (1)
@@ -160,8 +128,8 @@
 /**
  * Enumeration npa_pool_err_int_e
  *
- * NPA Pool Error Interrupt Enumeration
- * Enumerates the bit index of NPA_POOL_S[ERR_INT] and NPA_POOL_S[ERR_INT_ENA].
+ * NPA Pool Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_POOL_S[ERR_INT] and NPA_POOL_S[ERR_INT_ENA].
  */
 #define CAVM_NPA_POOL_ERR_INT_E_OVFLS (0)
 #define CAVM_NPA_POOL_ERR_INT_E_PERR (2)
@@ -171,19 +139,15 @@
 /**
  * Structure npa_aq_inst_s
  *
- * NPA Admin Queue Instruction Structure
- * This structure specifies the AQ instruction.
- * Instructions and associated software structures are stored in memory as
- * little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
- *
- * Hardware reads of NPA_AQ_INST_S do not allocate into LLC.
- *
- * Hardware reads and writes of the context structure selected by [CTYPE], [LF]
- * and [CINDEX] use the NDC and LLC caching style configured for that context,
- * i.e.:
- * * NPA_AURA_HW_S reads and writes use NPA_AF_LF()_AURAS_CFG[CACHING] and
- * NPA_AF_LF()_AURAS_CFG[WAY_MASK].
- * * NPA_POOL_HW_S reads and writes use NPA_AURA_HW_S[POOL_CACHING] and
+ * NPA Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
+ * Hardware reads of NPA_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context, i.e.: * NPA_AURA_HW_S reads and writes use
+ * NPA_AF_LF()_AURAS_CFG[CACHING] and NPA_AF_LF()_AURAS_CFG[WAY_MASK]. *
+ * NPA_POOL_HW_S reads and writes use NPA_AURA_HW_S[POOL_CACHING] and
  * NPA_AURA_HW_S[POOL_WAY_MASK].
  */
 union cavm_npa_aq_inst_s {
@@ -204,19 +168,16 @@ union cavm_npa_aq_inst_s {
 /**
  * Structure npa_aq_res_s
  *
- * NPA Admin Queue Result Structure
- * NPA writes this structure after it completes the NPA_AQ_INST_S instruction.
- * The result structure is exactly 16 bytes, and each instruction completion produces
- * exactly one result structure.
- *
- * Results and associated software structures are stored in memory as
- * little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
- *
+ * NPA Admin Queue Result Structure NPA writes this structure after it
+ * completes the NPA_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
  * When [OP] = NPA_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
- * immediately followed by context read or write data. See NPA_AQ_INSTOP_E.
- *
- * Hardware writes of NPA_AQ_RES_S and context data always allocate into LLC.
- * Hardware reads of context data do not allocate into LLC.
+ * immediately followed by context read or write data. See
+ * NPA_AQ_INSTOP_E.  Hardware writes of NPA_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
  */
 union cavm_npa_aq_res_s {
 	u64 u[2];
@@ -234,10 +195,10 @@ union cavm_npa_aq_res_s {
 /**
  * Structure npa_aura_op_wdata_s
  *
- * NPA Aura Operation Write Data Structure
- * This structure specifies the write data format of a 64-bit atomic load-and-add
- * to NPA_LF_AURA_OP_ALLOC() and NPA_LF_POOL_OP_PC, and a 128-bit atomic CASP
- * operation to NPA_LF_AURA_OP_ALLOC().
+ * NPA Aura Operation Write Data Structure This structure specifies the
+ * write data format of a 64-bit atomic load-and-add to
+ * NPA_LF_AURA_OP_ALLOC() and NPA_LF_POOL_OP_PC, and a 128-bit atomic
+ * CASP operation to NPA_LF_AURA_OP_ALLOC().
  */
 union cavm_npa_aura_op_wdata_s {
 	u64 u;
@@ -252,10 +213,9 @@ union cavm_npa_aura_op_wdata_s {
 /**
  * Structure npa_aura_s
  *
- * NPA Aura Context Structure
- * This structure specifies the format used by software with the NPA admin queue
- * to read and write an aura's NPA_AURA_HW_S structure maintained by hardware in
- * LLC/DRAM.
+ * NPA Aura Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write an aura's
+ * NPA_AURA_HW_S structure maintained by hardware in LLC/DRAM.
  */
 union cavm_npa_aura_s {
 	u64 u[8];
@@ -313,10 +273,9 @@ union cavm_npa_aura_s {
 /**
  * Structure npa_pool_s
  *
- * NPA Pool Context Structure
- * This structure specifies the format used by software with the NPA admin queue
- * to read and write a pool's NPA_POOL_HW_S structure maintained by hardware in
- * LLC/DRAM.
+ * NPA Pool Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write a pool's
+ * NPA_POOL_HW_S structure maintained by hardware in LLC/DRAM.
  */
 union cavm_npa_pool_s {
 	u64 u[16];
@@ -378,13 +337,13 @@ union cavm_npa_pool_s {
 /**
  * Structure npa_qint_hw_s
  *
- * NPA Queue Interrupt Context Hardware Structure
- * This structure contains context state maintained by hardware for each queue
- * interrupt (QINT) in NDC/LLC/DRAM. Software accesses this structure with the
- * NPA_LF_QINT()_* registers.
- * Hardware maintains a table of NPA_AF_CONST[QINTS] contiguous NPA_QINT_HW_S
- * structures per LF starting at IOVA NPA_AF_LF()_QINTS_BASE.
- * Always stored in byte invariant little-endian format (LE8).
+ * NPA Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NPA_LF_QINT()_* registers. Hardware maintains a table of
+ * NPA_AF_CONST[QINTS] contiguous NPA_QINT_HW_S structures per LF
+ * starting at IOVA NPA_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
  */
 union cavm_npa_qint_hw_s {
 	u32 u;
@@ -483,8 +442,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_done_ack
  *
- * NPA AF AQ Done Count Ack Register
- * This register is written by software to acknowledge interrupts.
+ * NPA AF AQ Done Count Ack Register This register is written by software
+ * to acknowledge interrupts.
  */
 union cavm_npa_af_aq_done_ack {
 	u64 u;
@@ -505,8 +464,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1c
  *
- * NPA AF AQ Done Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA AF AQ Done Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_af_aq_done_ena_w1c {
 	u64 u;
@@ -527,8 +486,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1s
  *
- * NPA AF AQ Done Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA AF AQ Done Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_npa_af_aq_done_ena_w1s {
 	u64 u;
@@ -591,8 +550,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_done_timer
  *
- * NPA AF Admin Queue Done Interrupt Timer Register
- * Used to debug the queue interrupt coalescing timer.
+ * NPA AF Admin Queue Done Interrupt Timer Register Used to debug the
+ * queue interrupt coalescing timer.
  */
 union cavm_npa_af_aq_done_timer {
 	u64 u;
@@ -613,8 +572,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_done_wait
  *
- * NPA AF AQ Done Interrupt Coalescing Wait Register
- * Specifies the queue interrupt coalescing settings.
+ * NPA AF AQ Done Interrupt Coalescing Wait Register Specifies the queue
+ * interrupt coalescing settings.
  */
 union cavm_npa_af_aq_done_wait {
 	u64 u;
@@ -637,8 +596,8 @@ static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_aq_door
  *
- * NPA AF Admin Queue Doorbell Register
- * Software writes to this register to enqueue one or more entries to AQ.
+ * NPA AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue one or more entries to AQ.
  */
 union cavm_npa_af_aq_door {
 	u64 u;
@@ -718,13 +677,10 @@ static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_bar2_alias#
  *
- * INTERNAL: NPA Admin Function  BAR2 Alias Registers
- *
- * These registers alias to the NPA BAR2 registers for the PF and function
- * selected by NPA_AF_BAR2_SEL[PF_FUNC].
- *
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: NPA Admin Function  BAR2 Alias Registers  These registers
+ * alias to the NPA BAR2 registers for the PF and function selected by
+ * NPA_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
  */
 union cavm_npa_af_bar2_aliasx {
 	u64 u;
@@ -744,11 +700,9 @@ static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
 /**
  * Register (RVU_PF_BAR0) npa_af_bar2_sel
  *
- * INTERNAL: NPA Admin Function BAR2 Select Register
- *
- * This register configures BAR2 accesses from the NPA_AF_BAR2_ALIAS() registers in BAR0.
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: NPA Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the NPA_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
  */
 union cavm_npa_af_bar2_sel {
 	u64 u;
@@ -815,8 +769,8 @@ static inline u64 CAVM_NPA_AF_BP_TEST(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_const
  *
- * NPA AF Constants Register
- * This register contains constants for software discovery.
+ * NPA AF Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_npa_af_const {
 	u64 u;
@@ -841,8 +795,8 @@ static inline u64 CAVM_NPA_AF_CONST(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_const1
  *
- * NPA AF Constants Register 1
- * This register contains constants for software discovery.
+ * NPA AF Constants Register 1 This register contains constants for
+ * software discovery.
  */
 union cavm_npa_af_const1 {
 	u64 u;
@@ -933,8 +887,8 @@ static inline u64 CAVM_NPA_AF_ERR_INT(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1c
  *
- * NPA Admin Function Error Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
  */
 union cavm_npa_af_err_int_ena_w1c {
 	u64 u;
@@ -958,8 +912,8 @@ static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1s
  *
- * NPA Admin Function Error Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
  */
 union cavm_npa_af_err_int_ena_w1s {
 	u64 u;
@@ -983,8 +937,8 @@ static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_err_int_w1s
  *
- * NPA Admin Function Error Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
  */
 union cavm_npa_af_err_int_w1s {
 	u64 u;
@@ -1008,8 +962,8 @@ static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_gen_cfg
  *
- * NPA AF General Configuration Register
- * This register provides NPA control and status information.
+ * NPA AF General Configuration Register This register provides NPA
+ * control and status information.
  */
 union cavm_npa_af_gen_cfg {
 	u64 u;
@@ -1038,8 +992,8 @@ static inline u64 CAVM_NPA_AF_GEN_CFG(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_gen_int
  *
- * NPA AF General Interrupt Register
- * This register contains general error interrupt summary bits.
+ * NPA AF General Interrupt Register This register contains general error
+ * interrupt summary bits.
  */
 union cavm_npa_af_gen_int {
 	u64 u;
@@ -1062,8 +1016,8 @@ static inline u64 CAVM_NPA_AF_GEN_INT(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1c
  *
- * NPA AF General Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_af_gen_int_ena_w1c {
 	u64 u;
@@ -1086,8 +1040,8 @@ static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1s
  *
- * NPA AF General Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_npa_af_gen_int_ena_w1s {
 	u64 u;
@@ -1110,8 +1064,8 @@ static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_gen_int_w1s
  *
- * NPA AF General Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA AF General Interrupt Set Register This register sets interrupt
+ * bits.
  */
 union cavm_npa_af_gen_int_w1s {
 	u64 u;
@@ -1165,13 +1119,24 @@ union cavm_npa_af_lfx_auras_cfg {
 		u64 loc_aura_size                    : 4;
 		u64 loc_aura_offset                  : 14;
 		u64 caching                          : 1;
-		u64 reserved_35                      : 1;
+		u64 be                               : 1;
 		u64 rmt_aura_size                    : 4;
 		u64 rmt_aura_offset                  : 14;
 		u64 rmt_lf                           : 7;
 		u64 reserved_61_63                   : 3;
 	} s;
-	/* struct cavm_npa_af_lfx_auras_cfg_s cn; */
+	struct cavm_npa_af_lfx_auras_cfg_cn96xx {
+		u64 way_mask                         : 16;
+		u64 loc_aura_size                    : 4;
+		u64 loc_aura_offset                  : 14;
+		u64 caching                          : 1;
+		u64 reserved_35                      : 1;
+		u64 rmt_aura_size                    : 4;
+		u64 rmt_aura_offset                  : 14;
+		u64 rmt_lf                           : 7;
+		u64 reserved_61_63                   : 3;
+	} cn96xx;
+	/* struct cavm_npa_af_lfx_auras_cfg_s cnf95xx; */
 };
 
 static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
@@ -1228,11 +1193,11 @@ static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
 /**
  * Register (RVU_PF_BAR0) npa_af_lf#_qints_cfg
  *
- * NPA AF Local Function Queue Interrupts Configuration Registers
- * This register controls access to the LF's queue interrupt context table in
- * LLC/DRAM. The table consists of NPA_AF_CONST[QINTS] contiguous NPA_QINT_HW_S
- * structures. The size of each structure is 1 \<\< NPA_AF_CONST1[QINT_LOG2BYTES]
- * bytes.
+ * NPA AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * LLC/DRAM. The table consists of NPA_AF_CONST[QINTS] contiguous
+ * NPA_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NPA_AF_CONST1[QINT_LOG2BYTES] bytes.
  */
 union cavm_npa_af_lfx_qints_cfg {
 	u64 u;
@@ -1278,8 +1243,8 @@ static inline u64 CAVM_NPA_AF_LF_RST(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ndc_cfg
  *
- * NDC AF General Configuration Register
- * This register provides NDC control.
+ * NDC AF General Configuration Register This register provides NDC
+ * control.
  */
 union cavm_npa_af_ndc_cfg {
 	u64 u;
@@ -1305,8 +1270,7 @@ static inline u64 CAVM_NPA_AF_NDC_CFG(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ndc_sync
  *
- * NPA AF NDC Sync Register
- * Used to synchronize the NPA NDC.
+ * NPA AF NDC Sync Register Used to synchronize the NPA NDC.
  */
 union cavm_npa_af_ndc_sync {
 	u64 u;
@@ -1329,9 +1293,8 @@ static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ras
  *
- * NPA AF RAS Interrupt Register
- * This register is intended for delivery of RAS events to the SCP, so should be
- * ignored by OS drivers.
+ * NPA AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
  */
 union cavm_npa_af_ras {
 	u64 u;
@@ -1355,8 +1318,8 @@ static inline u64 CAVM_NPA_AF_RAS(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ras_ena_w1c
  *
- * NPA AF RAS Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_af_ras_ena_w1c {
 	u64 u;
@@ -1380,8 +1343,8 @@ static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ras_ena_w1s
  *
- * NPA AF RAS Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_npa_af_ras_ena_w1s {
 	u64 u;
@@ -1405,8 +1368,7 @@ static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_ras_w1s
  *
- * NPA AF RAS Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA AF RAS Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_npa_af_ras_w1s {
 	u64 u;
@@ -1430,8 +1392,8 @@ static inline u64 CAVM_NPA_AF_RAS_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_rvu_int
  *
- * NPA AF RVU Interrupt Register
- * This register contains RVU error interrupt summary bits.
+ * NPA AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
  */
 union cavm_npa_af_rvu_int {
 	u64 u;
@@ -1452,8 +1414,8 @@ static inline u64 CAVM_NPA_AF_RVU_INT(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1c
  *
- * NPA AF RVU Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_af_rvu_int_ena_w1c {
 	u64 u;
@@ -1474,8 +1436,8 @@ static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1s
  *
- * NPA AF RVU Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_npa_af_rvu_int_ena_w1s {
 	u64 u;
@@ -1496,8 +1458,7 @@ static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_rvu_int_w1s
  *
- * NPA AF RVU Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA AF RVU Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_npa_af_rvu_int_w1s {
 	u64 u;
@@ -1518,9 +1479,9 @@ static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR0) npa_af_rvu_lf_cfg_debug
  *
- * NPA Privileged LF Configuration Debug Register
- * This debug register allows software to lookup the reverse mapping from VF/PF
- * slot to LF. The forward mapping is programmed with NPA_PRIV_LF()_CFG.
+ * NPA Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NPA_PRIV_LF()_CFG.
  */
 union cavm_npa_af_rvu_lf_cfg_debug {
 	u64 u;
@@ -1546,17 +1507,15 @@ static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_alloc#
  *
- * NPA Aura Allocate Operation Registers
- * These registers are used to allocate one or two pointers from a given aura's pool.
- * A 64-bit atomic load-and-add to NPA_LF_AURA_OP_ALLOC(0) allocates a single pointer.
- * A 128-bit atomic CASP operation to NPA_LF_AURA_OP_ALLOC(0..1) allocates two pointers.
- * The atomic write data format is NPA_AURA_OP_WDATA_S.
- * For CASP, the first SWAP word in the write data contains NPA_AURA_OP_WDATA_S
- * and the remaining write data words are ignored.
- *
- * All other accesses to this register (e.g. reads and writes) are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA Aura Allocate Operation Registers These registers are used to
+ * allocate one or two pointers from a given aura's pool. A 64-bit atomic
+ * load-and-add to NPA_LF_AURA_OP_ALLOC(0) allocates a single pointer. A
+ * 128-bit atomic CASP operation to NPA_LF_AURA_OP_ALLOC(0..1) allocates
+ * two pointers. The atomic write data format is NPA_AURA_OP_WDATA_S. For
+ * CASP, the first SWAP word in the write data contains
+ * NPA_AURA_OP_WDATA_S and the remaining write data words are ignored.
+ * All other accesses to this register (e.g. reads and writes) are
+ * RAZ/WI.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_allocx {
 	u64 u;
@@ -1576,11 +1535,9 @@ static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_cnt
  *
- * NPA LF Aura Count Register
- * A 64-bit atomic load-and-add to this register returns a given aura's
- * count. A write sets or adds the aura's count. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Aura Count Register A 64-bit atomic load-and-add to this
+ * register returns a given aura's count. A write sets or adds the aura's
+ * count. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_cnt {
 	u64 u;
@@ -1604,13 +1561,11 @@ static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free0
  *
- * NPA LF Aura Free Operation Register 0
- * A 128-bit write to NPA_LF_AURA_OP_FREE0 and NPA_LF_AURA_OP_FREE1
- * frees a pointer into a given aura's pool.
- * All other accesses to these registers (e.g. reads and 64-bit writes) are
+ * NPA LF Aura Free Operation Register 0 A 128-bit write to
+ * NPA_LF_AURA_OP_FREE0 and NPA_LF_AURA_OP_FREE1 frees a pointer into a
+ * given aura's pool. All other accesses to these registers (e.g. reads
+ * and 64-bit writes) are RAZ/WI.  RSL accesses to this register are
  * RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_free0 {
 	u64 u;
@@ -1630,10 +1585,8 @@ static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free1
  *
- * NPA LF Aura Free Operation Register 1
- * See NPA_LF_AURA_OP_FREE0.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Aura Free Operation Register 1 See NPA_LF_AURA_OP_FREE0.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_free1 {
 	u64 u;
@@ -1655,12 +1608,11 @@ static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_int
  *
- * NPA LF Aura Interrupt Operation Register
- * A 64-bit atomic load-and-add to this register reads
+ * NPA LF Aura Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
  * NPA_AURA_HW_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
- * optionally sets or clears these fields. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_int {
 	u64 u;
@@ -1687,11 +1639,9 @@ static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_limit
  *
- * NPA LF Aura Allocation Limit Register
- * A 64-bit atomic load-and-add to this register returns a given aura's
- * limit. A write sets the aura's limit. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Aura Allocation Limit Register A 64-bit atomic load-and-add to
+ * this register returns a given aura's limit. A write sets the aura's
+ * limit. A read is RAZ.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_limit {
 	u64 u;
@@ -1715,13 +1665,11 @@ static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_aura_op_thresh
  *
- * NPA LF Aura Threshold Operation Register
- * A 64-bit atomic load-and-add to this register reads
- * NPA_AURA_HW_S[THRESH_UP,THRESH]. A write to the register writes
- * NPA_AURA_HW_S[THRESH_UP,THRESH] and recomputes NPA_AURA_HW_S[THRESH_INT].
- * A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Aura Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_AURA_HW_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_AURA_HW_S[THRESH_UP,THRESH] and recomputes
+ * NPA_AURA_HW_S[THRESH_INT]. A read is RAZ.  RSL accesses to this
+ * register are RAZ/WI.
  */
 union cavm_npa_lf_aura_op_thresh {
 	u64 u;
@@ -1774,8 +1722,8 @@ static inline u64 CAVM_NPA_LF_ERR_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1c
  *
- * NPA LF Error Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_lf_err_int_ena_w1c {
 	u64 u;
@@ -1804,8 +1752,8 @@ static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1s
  *
- * NPA LF Error Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
  */
 union cavm_npa_lf_err_int_ena_w1s {
 	u64 u;
@@ -1834,8 +1782,7 @@ static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_err_int_w1s
  *
- * NPA LF Error Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA LF Error Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_npa_lf_err_int_w1s {
 	u64 u;
@@ -1864,11 +1811,10 @@ static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_available
  *
- * NPA LF Pool Available Count Operation Register
- * A 64-bit atomic load-and-add to this register returns a given pool's free
- * pointer count. Reads and writes are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Available Count Operation Register A 64-bit atomic load-
+ * and-add to this register returns a given pool's free pointer count.
+ * Reads and writes are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
  */
 union cavm_npa_lf_pool_op_available {
 	u64 u;
@@ -1892,12 +1838,11 @@ static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_int
  *
- * NPA LF Pool Interrupt Operation Register
- * A 64-bit atomic load-and-add to this register reads
- * NPA_POOL_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write optionally
- * sets or clears these fields. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
+ * NPA_POOL_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_int {
 	u64 u;
@@ -1924,12 +1869,11 @@ static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_pc
  *
- * NPA LF Pool Performance Count Register
- * A 64-bit atomic load-and-add to this register reads NPA_POOL_S[OP_PC] from a
- * given aura's pool. The aura is selected by the atomic write data, whose format
- * is NPA_AURA_OP_WDATA_S. Reads and writes are RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Performance Count Register A 64-bit atomic load-and-add to
+ * this register reads NPA_POOL_S[OP_PC] from a given aura's pool. The
+ * aura is selected by the atomic write data, whose format is
+ * NPA_AURA_OP_WDATA_S. Reads and writes are RAZ/WI.  RSL accesses to
+ * this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_pc {
 	u64 u;
@@ -1951,13 +1895,11 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end0
  *
- * NPA LF Pool Pointer End Operation Register 0
- * A 128-bit write to the NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1
- * registers writes to a given pool's pointer end value.
- * All other accesses to these registers (e.g. reads and 64-bit writes) are
- * RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Pointer End Operation Register 0 A 128-bit write to the
+ * NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1 registers writes
+ * to a given pool's pointer end value. All other accesses to these
+ * registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL accesses to
+ * this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_ptr_end0 {
 	u64 u;
@@ -1977,10 +1919,8 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end1
  *
- * NPA LF Pool Pointer End Operation Register 1
- * See NPA_LF_POOL_OP_PTR_END0.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Pointer End Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_END0.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_ptr_end1 {
 	u64 u;
@@ -2001,13 +1941,11 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start0
  *
- * NPA LF Pool Pointer Start Operation Register 0
- * A 128-bit write to the NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1
- * registers writes to a given pool's pointer start value.
- * All other accesses to these registers (e.g. reads and 64-bit writes) are
- * RAZ/WI.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Pointer Start Operation Register 0 A 128-bit write to the
+ * NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1 registers
+ * writes to a given pool's pointer start value. All other accesses to
+ * these registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_ptr_start0 {
 	u64 u;
@@ -2027,10 +1965,8 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start1
  *
- * NPA LF Pool Pointer Start Operation Register 1
- * See NPA_LF_POOL_OP_PTR_START0.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Pointer Start Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_START0.  RSL accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_ptr_start1 {
 	u64 u;
@@ -2051,12 +1987,10 @@ static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_pool_op_thresh
  *
- * NPA LF Pool Threshold Operation Register
- * A 64-bit atomic load-and-add to this register reads
- * NPA_POOL_S[THRESH_UP,THRESH]. A write to the register writes
- * NPA_POOL_S[THRESH_UP,THRESH]. A read is RAZ.
- *
- * RSL accesses to this register are RAZ/WI.
+ * NPA LF Pool Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_POOL_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_POOL_S[THRESH_UP,THRESH]. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
  */
 union cavm_npa_lf_pool_op_thresh {
 	u64 u;
@@ -2101,8 +2035,8 @@ static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1c
  *
- * NPA LF Queue Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * NPA LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_lf_qintx_ena_w1c {
 	u64 u;
@@ -2123,8 +2057,8 @@ static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1s
  *
- * NPA LF Queue Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * NPA LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_npa_lf_qintx_ena_w1s {
 	u64 u;
@@ -2211,8 +2145,8 @@ static inline u64 CAVM_NPA_LF_RAS(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1c
  *
- * NPA LF RAS Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * NPA LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
  */
 union cavm_npa_lf_ras_ena_w1c {
 	u64 u;
@@ -2236,8 +2170,8 @@ static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1s
  *
- * NPA LF RAS Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * NPA LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_npa_lf_ras_ena_w1s {
 	u64 u;
@@ -2261,8 +2195,7 @@ static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
 /**
  * Register (RVU_PFVF_BAR2) npa_lf_ras_w1s
  *
- * NPA LF RAS Interrupt Set Register
- * This register sets interrupt bits.
+ * NPA LF RAS Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_npa_lf_ras_w1s {
 	u64 u;
@@ -2309,17 +2242,13 @@ static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
 /**
  * Register (RVU_PF_BAR0) npa_priv_lf#_cfg
  *
- * NPA Privileged Local Function Configuration Registers
- * These registers allow each NPA local function (LF) to be provisioned to a VF/PF
- * slot for RVU. See also NPA_AF_RVU_LF_CFG_DEBUG.
- *
- * Software should read this register after write to ensure that the LF is mapped to
- * [PF_FUNC] before issuing transactions to the mapped PF and function.
- *
- * [SLOT] must be zero.
- *
- * Internal:
- * Hardware ignores [SLOT] and always assumes 0x0.
+ * NPA Privileged Local Function Configuration Registers These registers
+ * allow each NPA local function (LF) to be provisioned to a VF/PF slot
+ * for RVU. See also NPA_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
  */
 union cavm_npa_priv_lfx_cfg {
 	u64 u;
diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-npc.h b/drivers/net/cavium/octeontx2/cavm-csrs-npc.h
index 490ab5c9a3..3f69d9d7c3 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-npc.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-npc.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_NPC_H__
 #define __CAVM_CSRS_NPC_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,15 +14,15 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium NPC.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
 /**
  * Enumeration npc_errlev_e
  *
- * NPC Error Level Enumeration
- * Enumerates the lowest protocol layer containing an error.
+ * NPC Error Level Enumeration Enumerates the lowest protocol layer
+ * containing an error.
  */
 #define CAVM_NPC_ERRLEV_E_LA (1)
 #define CAVM_NPC_ERRLEV_E_LB (2)
@@ -72,8 +39,7 @@
 /**
  * Enumeration npc_intf_e
  *
- * NPC Interface Enumeration
- * Enumerates the NPC interfaces.
+ * NPC Interface Enumeration Enumerates the NPC interfaces.
  */
 #define CAVM_NPC_INTF_E_NIXX_RX(a) (0 + 2 * (a))
 #define CAVM_NPC_INTF_E_NIXX_TX(a) (1 + 2 * (a))
@@ -81,8 +47,7 @@
 /**
  * Enumeration npc_lid_e
  *
- * NPC Layer ID Enumeration
- * Enumerates layers parsed by NPC.
+ * NPC Layer ID Enumeration Enumerates layers parsed by NPC.
  */
 #define CAVM_NPC_LID_E_LA (0)
 #define CAVM_NPC_LID_E_LB (1)
@@ -96,8 +61,8 @@
 /**
  * Enumeration npc_lkupop_e
  *
- * NPC Lookup Operation Enumeration
- * Enumerates the lookup operation for NPC_AF_LKUP_CTL[OP].
+ * NPC Lookup Operation Enumeration Enumerates the lookup operation for
+ * NPC_AF_LKUP_CTL[OP].
  */
 #define CAVM_NPC_LKUPOP_E_KEY (1)
 #define CAVM_NPC_LKUPOP_E_PKT (0)
@@ -114,8 +79,8 @@
 /**
  * Structure npc_layer_info_s
  *
- * NPC Layer Parse Information Structure
- * This structure specifies the format of NPC_RESULT_S[LA,LB,...,LH].
+ * NPC Layer Parse Information Structure This structure specifies the
+ * format of NPC_RESULT_S[LA,LB,...,LH].
  */
 union cavm_npc_layer_info_s {
 	u32 u;
@@ -131,11 +96,10 @@ union cavm_npc_layer_info_s {
 /**
  * Structure npc_layer_kex_s
  *
- * NPC Layer MCAM Search Key Extract Structure
- * This structure specifies the format of each of the
- * NPC_PARSE_KEX_S[LA,LB,...,LH] fields. It contains the subset of
- * NPC_LAYER_INFO_S fields that can be included in the MCAM search key.
- * See NPC_PARSE_KEX_S and NPC_AF_INTF()_KEX_CFG.
+ * NPC Layer MCAM Search Key Extract Structure This structure specifies
+ * the format of each of the NPC_PARSE_KEX_S[LA,LB,...,LH] fields. It
+ * contains the subset of NPC_LAYER_INFO_S fields that can be included in
+ * the MCAM search key. See NPC_PARSE_KEX_S and NPC_AF_INTF()_KEX_CFG.
  */
 union cavm_npc_layer_kex_s {
 	u32 u;
@@ -150,9 +114,9 @@ union cavm_npc_layer_kex_s {
 /**
  * Structure npc_mcam_key_x1_s
  *
- * NPC MCAM Search Key X1 Structure
- * This structure specifies the MCAM search key format used by an interface
- * when NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1.
+ * NPC MCAM Search Key X1 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1.
  */
 union cavm_npc_mcam_key_x1_s {
 	u64 u[3];
@@ -169,9 +133,9 @@ union cavm_npc_mcam_key_x1_s {
 /**
  * Structure npc_mcam_key_x2_s
  *
- * NPC MCAM Search Key X2 Structure
- * This structure specifies the MCAM search key format used by an interface
- * when NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2.
+ * NPC MCAM Search Key X2 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2.
  */
 union cavm_npc_mcam_key_x2_s {
 	u64 u[5];
@@ -190,9 +154,9 @@ union cavm_npc_mcam_key_x2_s {
 /**
  * Structure npc_mcam_key_x4_s
  *
- * NPC MCAM Search Key X4 Structure
- * This structure specifies the MCAM search key format used by an interface
- * when NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4.
+ * NPC MCAM Search Key X4 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4.
  */
 union cavm_npc_mcam_key_x4_s {
 	u64 u[8];
@@ -213,9 +177,9 @@ union cavm_npc_mcam_key_x4_s {
 /**
  * Structure npc_parse_kex_s
  *
- * NPC Parse Key Extract Structure
- * This structure contains the subset of NPC_RESULT_S fields that can be included
- * in the MCAM search key. See NPC_AF_INTF()_KEX_CFG.
+ * NPC Parse Key Extract Structure This structure contains the subset of
+ * NPC_RESULT_S fields that can be included in the MCAM search key. See
+ * NPC_AF_INTF()_KEX_CFG.
  */
 union cavm_npc_parse_kex_s {
 	u64 u[2];
@@ -243,8 +207,8 @@ union cavm_npc_parse_kex_s {
 /**
  * Structure npc_result_s
  *
- * NPC Result Structure
- * This structure contains a packet's parse and flow identification information.
+ * NPC Result Structure This structure contains a packet's parse and flow
+ * identification information.
  */
 union cavm_npc_result_s {
 	u64 u[6];
@@ -345,8 +309,8 @@ static inline u64 CAVM_NPC_AF_CFG(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_const
  *
- * NPC AF Constants Register
- * This register contains constants for software discovery.
+ * NPC AF Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_npc_af_const {
 	u64 u;
@@ -374,8 +338,8 @@ static inline u64 CAVM_NPC_AF_CONST(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_const1
  *
- * NPC AF Constants 1 Register
- * This register contains constants for software discovery.
+ * NPC AF Constants 1 Register This register contains constants for
+ * software discovery.
  */
 union cavm_npc_af_const1 {
 	u64 u;
@@ -419,9 +383,9 @@ static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_dbg_ctl
  *
- * NPC AF Debug Control Register
- * This register controls the capture of debug information in NPC_AF_KPU()_DBG,
- * NPC_AF_MCAM_DBG, NPC_AF_DBG_DATA() and NPC_AF_DBG_RESULT().
+ * NPC AF Debug Control Register This register controls the capture of
+ * debug information in NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG,
+ * NPC_AF_DBG_DATA() and NPC_AF_DBG_RESULT().
  */
 union cavm_npc_af_dbg_ctl {
 	u64 u;
@@ -444,9 +408,9 @@ static inline u64 CAVM_NPC_AF_DBG_CTL(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_dbg_data#
  *
- * NPC AF Debug Data Registers
- * These registers contain the packet header data of the last packet/lookup whose
- * debug information is captured by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ * NPC AF Debug Data Registers These registers contain the packet header
+ * data of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
 union cavm_npc_af_dbg_datax {
 	u64 u;
@@ -466,9 +430,9 @@ static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_dbg_result#
  *
- * NPC AF Debug Result Registers
- * These registers contain the result data of the last packet/lookup whose debug
- * information is captured by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ * NPC AF Debug Result Registers These registers contain the result data
+ * of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
 union cavm_npc_af_dbg_resultx {
 	u64 u;
@@ -509,10 +473,8 @@ static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_dv_fc_scratch
  *
- * INTERNAL: NPC AF Scratch Register
- *
- * Internal:
- * This register is for internal DV purpose.
+ * INTERNAL: NPC AF Scratch Register  Internal: This register is for
+ * internal DV purpose.
  */
 union cavm_npc_af_dv_fc_scratch {
 	u64 u;
@@ -553,11 +515,12 @@ static inline u64 CAVM_NPC_AF_ECO0(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_ikpu_err_ctl
  *
- * NPC AF Initial KPU Error Control Registers
- * Similar to NPC_AF_KPU()_ERR_CTL, but specifies values captured in
- * NPC_RESULT_S[ERRLEV,ERRCODE] for errors detected by the PKIND-based initial
- * actions from NPC_AF_PKIND()_ACTION0 and NPC_AF_PKIND()_ACTION1.
- * [DP_OFFSET_ERRCODE] from this register is never used.
+ * NPC AF Initial KPU Error Control Registers Similar to
+ * NPC_AF_KPU()_ERR_CTL, but specifies values captured in
+ * NPC_RESULT_S[ERRLEV,ERRCODE] for errors detected by the PKIND-based
+ * initial actions from NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1. [DP_OFFSET_ERRCODE] from this register is
+ * never used.
  */
 union cavm_npc_af_ikpu_err_ctl {
 	u64 u;
@@ -604,9 +567,10 @@ static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_ldata#_flags#_cfg
  *
- * NPC AF Interface Layer Data Flags Configuration Registers
- * These registers control the extraction of layer data (LDATA) into the MCAM search key for each
- * interface based on the FLAGS\<3:0\> bits of two layers selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
+ * NPC AF Interface Layer Data Flags Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface based on the FLAGS\<3:0\> bits of two
+ * layers selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
  */
 union cavm_npc_af_intfx_ldatax_flagsx_cfg {
 	u64 u;
@@ -631,15 +595,15 @@ static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_lid#_lt#_ld#_cfg
  *
- * NPC AF Interface Layer Data Extract Configuration Registers
- * These registers control the extraction of layer data (LDATA) into the MCAM search key for each
- * interface. Up to two LDATA fields can be extracted per layer (LID(0..7) indexed by NPC_LID_E),
- * with up to 16 bytes per LDATA field. For each layer, the corresponding
- * NPC_LAYER_INFO_S[LTYPE] value in NPC_RESULT_S is used as the LTYPE(0..15) index and select the
- * associated LDATA(0..1) registers.
- *
- * NPC_LAYER_INFO_S[LTYPE]=0x0 means the corresponding layer not parsed (invalid), so
- * software should keep NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction
+ * NPC AF Interface Layer Data Extract Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface. Up to two LDATA fields can be extracted
+ * per layer (LID(0..7) indexed by NPC_LID_E), with up to 16 bytes per
+ * LDATA field. For each layer, the corresponding NPC_LAYER_INFO_S[LTYPE]
+ * value in NPC_RESULT_S is used as the LTYPE(0..15) index and select the
+ * associated LDATA(0..1) registers.  NPC_LAYER_INFO_S[LTYPE]=0x0 means
+ * the corresponding layer not parsed (invalid), so software should keep
+ * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction
  * when LTYPE is zero.
  */
 union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
@@ -665,10 +629,10 @@ static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_miss_act
  *
- * NPC AF Interface MCAM Miss Action Data Registers
- * When a combination of NPC_AF_MCAME()_BANK()_CAM()_* and
- * NPC_AF_MCAME()_BANK()_CFG[ENA] yields an MCAM miss for a packet, this
- * register specifies the packet's match action captured in NPC_RESULT_S[ACTION].
+ * NPC AF Interface MCAM Miss Action Data Registers When a combination of
+ * NPC_AF_MCAME()_BANK()_CAM()_* and NPC_AF_MCAME()_BANK()_CFG[ENA]
+ * yields an MCAM miss for a packet, this register specifies the packet's
+ * match action captured in NPC_RESULT_S[ACTION].
  */
 union cavm_npc_af_intfx_miss_act {
 	u64 u;
@@ -688,8 +652,8 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_miss_stat_act
  *
- * NPC AF Interface MCAM Miss Stat Action Data Registers
- * Used to optionally increment a NPC_AF_MATCH_STAT() counter when a packet
+ * NPC AF Interface MCAM Miss Stat Action Data Registers Used to
+ * optionally increment a NPC_AF_MATCH_STAT() counter when a packet
  * misses an MCAM entry.
  */
 union cavm_npc_af_intfx_miss_stat_act {
@@ -712,8 +676,8 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_miss_tag_act
  *
- * NPC AF Interface MCAM Miss VTag Action Data Registers
- * When a combination of NPC_AF_MCAME()_BANK()_CAM()_* and
+ * NPC AF Interface MCAM Miss VTag Action Data Registers When a
+ * combination of NPC_AF_MCAME()_BANK()_CAM()_* and
  * NPC_AF_MCAME()_BANK()_CFG[ENA] yields an MCAM miss for a packet, this
  * register specifies the packet's match Vtag action captured in
  * NPC_RESULT_S[VTAG_ACTION].
@@ -736,8 +700,8 @@ static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_intf#_stat
  *
- * NPC AF Interface Statistics Registers
- * Statistics per interface. Index enumerated by NPC_INTF_E.
+ * NPC AF Interface Statistics Registers Statistics per interface. Index
+ * enumerated by NPC_INTF_E.
  */
 union cavm_npc_af_intfx_stat {
 	u64 u;
@@ -825,9 +789,9 @@ static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_dbg
  *
- * NPC AF KPU Debug Registers
- * This register contains information for the last packet/lookup for which debug
- * is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ * NPC AF KPU Debug Registers This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
 union cavm_npc_af_kpux_dbg {
 	u64 u;
@@ -849,11 +813,11 @@ static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action0
  *
- * NPC AF KPU Entry Action Data 0 Registers
- * When a KPU's search data matches a KPU CAM entry in
- * NPC_AF_KPU()_ENTRY()_CAM(), the corresponding entry action in
- * NPC_AF_KPU()_ENTRY()_ACTION0 and NPC_AF_KPU()_ENTRY()_ACTION1 specifies the
- * next state and operations to perform before exiting the KPU.
+ * NPC AF KPU Entry Action Data 0 Registers When a KPU's search data
+ * matches a KPU CAM entry in NPC_AF_KPU()_ENTRY()_CAM(), the
+ * corresponding entry action in NPC_AF_KPU()_ENTRY()_ACTION0 and
+ * NPC_AF_KPU()_ENTRY()_ACTION1 specifies the next state and operations
+ * to perform before exiting the KPU.
  */
 union cavm_npc_af_kpux_entryx_action0 {
 	u64 u;
@@ -886,8 +850,8 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action1
  *
- * NPC AF KPU Entry Action Data 0 Registers
- * See NPC_AF_KPU()_ENTRY()_ACTION0.
+ * NPC AF KPU Entry Action Data 0 Registers See
+ * NPC_AF_KPU()_ENTRY()_ACTION0.
  */
 union cavm_npc_af_kpux_entryx_action1 {
 	u64 u;
@@ -912,21 +876,18 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_cam#
  *
- * NPC AF KPU Entry CAM Registers
- * KPU comparison ternary data. The field values in
- * NPC_AF_KPU()_ENTRY()_CAM() are ternary, where  each data bit of the
- * search key matches as follows:
- * _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=0: Always match; search key data\<n\> don't care.
- * _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=1: Match when search key data\<n\> == 0.
- * _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\> == 1.
- * _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.
- *
- * The reserved combination is not allowed. Hardware suppresses any write to
- * CAM(0) or CAM(1) that would result in the reserved combination for any CAM bit.
- *
- * Software must program a default entry for each KPU, e.g. by programming each
- * KPU's last entry {b} (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match all
- * bits.
+ * NPC AF KPU Entry CAM Registers KPU comparison ternary data. The field
+ * values in NPC_AF_KPU()_ENTRY()_CAM() are ternary, where  each data bit
+ * of the search key matches as follows: _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=0: Always match; search key data\<n\> don't care. _
+ * [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=1: Match when search key data\<n\> ==
+ * 0. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\>
+ * == 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * Software must program a default entry for each KPU, e.g. by
+ * programming each KPU's last entry {b} (NPC_AF_KPU()_ENTRY({b})_CAM())
+ * to always match all bits.
  */
 union cavm_npc_af_kpux_entryx_camx {
 	u64 u;
@@ -950,8 +911,7 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_entry_dis#
  *
- * NPC AF KPU Entry Disable Registers
- * See NPC_AF_KPU()_ENTRY()_ACTION0.
+ * NPC AF KPU Entry Disable Registers See NPC_AF_KPU()_ENTRY()_ACTION0.
  */
 union cavm_npc_af_kpux_entry_disx {
 	u64 u;
@@ -971,9 +931,9 @@ static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_kpu#_err_ctl
  *
- * NPC AF KPU Error Control Registers
- * This register specifies values captured in NPC_RESULT_S[ERRLEV,ERRCODE] when errors
- * are detected by a KPU.
+ * NPC AF KPU Error Control Registers This register specifies values
+ * captured in NPC_RESULT_S[ERRLEV,ERRCODE] when errors are detected by a
+ * KPU.
  */
 union cavm_npc_af_kpux_err_ctl {
 	u64 u;
@@ -1104,9 +1064,9 @@ static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcam_dbg
  *
- * NPC AF MCAM Debug Register
- * This register contains information for the last packet/lookup for which debug
- * is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ * NPC AF MCAM Debug Register This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
  */
 union cavm_npc_af_mcam_dbg {
 	u64 u;
@@ -1156,22 +1116,20 @@ static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_action
  *
- * NPC AF MCAM Entry Bank Action Data Registers
- * Specifies a packet's match action captured in NPC_RESULT_S[ACTION].
- *
- * When an interface is configured to use the NPC_MCAM_KEY_X2_S search key
- * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2),
- * * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*.
- * * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*.
- * * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
- *
- * When an interface is configured to use the NPC_MCAM_KEY_X4_S search key
- * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4):
- * * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
- * matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*.
- * * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
+ * NPC AF MCAM Entry Bank Action Data Registers Specifies a packet's
+ * match action captured in NPC_RESULT_S[ACTION].  When an interface is
+ * configured to use the NPC_MCAM_KEY_X2_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used.  When
+ * an interface is configured to use the NPC_MCAM_KEY_X4_S search key
+ * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4): *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
  */
 union cavm_npc_af_mcamex_bankx_action {
 	u64 u;
@@ -1191,69 +1149,84 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf
  *
- * NPC AF MCAM Entry Bank CAM Data Interface Registers
- * MCAM comparison ternary data interface word. The field values in
+ * NPC AF MCAM Entry Bank CAM Data Interface Registers MCAM comparison
+ * ternary data interface word. The field values in
  * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
- * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where  each data bit of the
- * search key matches as follows:
- * _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=0: Always match; search key data\<n\> don't care.
- * _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=1: Match when search key data\<n\> == 0.
- * _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\> == 1.
- * _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.
- *
- * The reserved combination is not allowed. Hardware suppresses any write to
- * CAM(0) or CAM(1) that would result in the reserved combination for any CAM bit.
- *
- * When an interface is configured to use the NPC_MCAM_KEY_X1_S search key
- * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the four banks
- * of every MCAM entry are used as individual entries, each of which is
- * independently compared with the search key as follows:
- * _ NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X1_S[INTF].
- * _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD] corresponds to NPC_MCAM_KEY_X1_S[KW0].
- * _ NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds to NPC_MCAM_KEY_X1_S[KW1].
- *
- * When an interface is configured to use the NPC_MCAM_KEY_X2_S search key
- * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), banks 0-1 of
- * every MCAM entry are used as one double-wide entry, banks 2-3 as a second
- * double-wide entry, and each double-wide entry is independently compared
- * with the search key as follows:
- * _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X2_S[INTF].
- * _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD] corresponds to NPC_MCAM_KEY_X2_S[KW0].
- * _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to NPC_MCAM_KEY_X2_S[KW1]\<47:0\>.
- * _ NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X2_S[INTF].
- * _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<15:0\> corresponds to NPC_MCAM_KEY_X2_S[KW1]\<63:48\>.
- * _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<63:16\> corresponds to NPC_MCAM_KEY_X2_S[KW2]\<47:0\>.
- * _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<15:0\> corresponds to NPC_MCAM_KEY_X2_S[KW2]\<63:48\>.
- * _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<47:16\> corresponds to NPC_MCAM_KEY_X2_S[KW3]\<31:0\>.
- *
- * When an interface is configured to use the NPC_MCAM_KEY_X4_S search key
- * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4), the four banks of every MCAM entry
- * are used as a single quad-wide entry that is compared with the search key as follows:
- * _ NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X4_S[INTF].
- * _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD] corresponds to NPC_MCAM_KEY_X4_S[KW0].
- * _ NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD] corresponds to NPC_MCAM_KEY_X4_S[KW1]\<47:0\>.
- * _ NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X4_S[INTF].
- * _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<15:0\> corresponds to NPC_MCAM_KEY_X4_S[KW1]\<63:48\>.
- * _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<63:16\> corresponds to NPC_MCAM_KEY_X4_S[KW2]\<47:0\>.
- * _ NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<15:0\> corresponds to NPC_MCAM_KEY_X4_S[KW2]\<63:48\>.
- * _ NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<47:16\> corresponds to NPC_MCAM_KEY_X4_S[KW3]\<31:0\>.
- * _ NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X4_S[INTF].
- * _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<31:0\> corresponds to NPC_MCAM_KEY_X4_S[KW3]\<63:32\>.
- * _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<63:32\> corresponds to NPC_MCAM_KEY_X4_S[KW4]\<31:0\>.
- * _ NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<31:0\> corresponds to NPC_MCAM_KEY_X4_S[KW4]\<63:32\>.
- * _ NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<47:32\> corresponds to NPC_MCAM_KEY_X4_S[KW5]\<15:0\>.
- * _ NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to NPC_MCAM_KEY_X4_S[INTF].
- * _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<47:0\> corresponds to NPC_MCAM_KEY_X4_S[KW5]\<63:16\>.
- * _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<63:48\> corresponds to NPC_MCAM_KEY_X4_S[KW6]\<15:0\>.
- * _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD] corresponds to NPC_MCAM_KEY_X4_S[KW6]\<63:16\>.
- *
- * Note that for the X2 and X4 formats, a wide entry will not match unless
- * the INTF fields from the associated two or four banks match the INTF
- * value from the search key.
- *
- * For the X1 and X2 formats, a match in a lower-numbered bank takes priority over
- * a match in any higher numbered banks. Within each bank, the lowest numbered
- * matching entry takes priority over any higher numbered entry.
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where  each data bit of
+ * the search key matches as follows: _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=0:
+ * Always match; search key data\<n\> don't care. _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=1: Match when search key data\<n\> == 0. _
+ * [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\> ==
+ * 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * When an interface is configured to use the NPC_MCAM_KEY_X1_S search
+ * key format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the
+ * four banks of every MCAM entry are used as individual entries, each of
+ * which is independently compared with the search key as follows: _
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X1_S[INTF]. _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X1_S[KW0]. _
+ * NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X1_S[KW1].  When an interface is configured to use the
+ * NPC_MCAM_KEY_X2_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
+ * NPC_MCAMKEYW_E::X2), banks 0-1 of every MCAM entry are used as one
+ * double-wide entry, banks 2-3 as a second double-wide entry, and each
+ * double-wide entry is independently compared with the search key as
+ * follows: _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X2_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW3]\<31:0\>.  When an interface is configured to
+ * use the NPC_MCAM_KEY_X4_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4), the four banks of
+ * every MCAM entry are used as a single quad-wide entry that is compared
+ * with the search key as follows: _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X4_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<15:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW3]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<31:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW3]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<63:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<31:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<47:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW5]\<15:0\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<47:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW5]\<63:16\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<63:48\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW6]\<15:0\>. _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW6]\<63:16\>.  Note that for the X2
+ * and X4 formats, a wide entry will not match unless the INTF fields
+ * from the associated two or four banks match the INTF value from the
+ * search key.  For the X1 and X2 formats, a match in a lower-numbered
+ * bank takes priority over a match in any higher numbered banks. Within
+ * each bank, the lowest numbered matching entry takes priority over any
+ * higher numbered entry.
  */
 union cavm_npc_af_mcamex_bankx_camx_intf {
 	u64 u;
@@ -1274,8 +1247,8 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0
  *
- * NPC AF MCAM Entry Bank CAM Data Word 0 Registers
- * MCAM comparison ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers MCAM comparison
+ * ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
  */
 union cavm_npc_af_mcamex_bankx_camx_w0 {
 	u64 u;
@@ -1295,8 +1268,8 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1
  *
- * NPC AF MCAM Entry Bank Data Word 1 Registers
- * MCAM comparison ternary data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ * NPC AF MCAM Entry Bank Data Word 1 Registers MCAM comparison ternary
+ * data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
  */
 union cavm_npc_af_mcamex_bankx_camx_w1 {
 	u64 u;
@@ -1338,9 +1311,9 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act
  *
- * NPC AF MCAM Entry Bank Statistics Action Registers
- * Used to optionally increment a NPC_AF_MATCH_STAT() counter when a packet
- * matches an MCAM entry. See also NPC_AF_MCAME()_BANK()_ACTION.
+ * NPC AF MCAM Entry Bank Statistics Action Registers Used to optionally
+ * increment a NPC_AF_MATCH_STAT() counter when a packet matches an MCAM
+ * entry. See also NPC_AF_MCAME()_BANK()_ACTION.
  */
 union cavm_npc_af_mcamex_bankx_stat_act {
 	u64 u;
@@ -1362,9 +1335,9 @@ static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act
  *
- * NPC AF MCAM Entry Bank VTag Action Data Registers
- * Specifies a packet's match Vtag action captured in NPC_RESULT_S[VTAG_ACTION].
- * See also NPC_AF_MCAME()_BANK()_ACTION.
+ * NPC AF MCAM Entry Bank VTag Action Data Registers Specifies a packet's
+ * match Vtag action captured in NPC_RESULT_S[VTAG_ACTION]. See also
+ * NPC_AF_MCAME()_BANK()_ACTION.
  */
 union cavm_npc_af_mcamex_bankx_tag_act {
 	u64 u;
@@ -1415,8 +1388,9 @@ static inline u64 CAVM_NPC_AF_PCK_CFG(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_pck_def_iip4
  *
- * NPC AF Protocol Check Inner IPv4 Definition Register
- * Provides layer information used by the protocol checker to identify an inner IPv4 header.
+ * NPC AF Protocol Check Inner IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an inner IPv4
+ * header.
  */
 union cavm_npc_af_pck_def_iip4 {
 	u64 u;
@@ -1439,8 +1413,9 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_pck_def_oip4
  *
- * NPC AF Protocol Check Outer IPv4 Definition Register
- * Provides layer information used by the protocol checker to identify an outer IPv4 header.
+ * NPC AF Protocol Check Outer IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv4
+ * header.
  */
 union cavm_npc_af_pck_def_oip4 {
 	u64 u;
@@ -1463,9 +1438,9 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_pck_def_oip6
  *
- * NPC AF Protocol Check Outer IPv6 Definition Register
- * Provides layer information used by the protocol checker to identify an outer
- * IPv6 header. [LID] must have the same value as NPC_AF_PCK_DEF_OIP4[LID].
+ * NPC AF Protocol Check Outer IPv6 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv6
+ * header. [LID] must have the same value as NPC_AF_PCK_DEF_OIP4[LID].
  */
 union cavm_npc_af_pck_def_oip6 {
 	u64 u;
@@ -1488,8 +1463,9 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_pck_def_ol2
  *
- * NPC AF Protocol Check Outer L2 Definition Register
- * Provides layer information used by the protocol checker to identify an outer L2 header.
+ * NPC AF Protocol Check Outer L2 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer L2
+ * header.
  */
 union cavm_npc_af_pck_def_ol2 {
 	u64 u;
@@ -1512,9 +1488,9 @@ static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
 /**
  * Register (RVU_PF_BAR0) npc_af_pkind#_action0
  *
- * NPC AF Port Kind Action Data 0 Registers
- * NPC_AF_PKIND()_ACTION0 and NPC_AF_PKIND()_ACTION1 specify the initial parse state and
- * operations to perform before entering KPU 0.
+ * NPC AF Port Kind Action Data 0 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
  */
 union cavm_npc_af_pkindx_action0 {
 	u64 u;
@@ -1547,9 +1523,9 @@ static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_pkind#_action1
  *
- * NPC AF Port Kind Action Data 1 Registers
- * NPC_AF_PKIND()_ACTION0 and NPC_AF_PKIND()_ACTION1 specify the initial parse state and
- * operations to perform before entering KPU 0.
+ * NPC AF Port Kind Action Data 1 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
  */
 union cavm_npc_af_pkindx_action1 {
 	u64 u;
@@ -1574,36 +1550,24 @@ static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
 /**
  * Register (RVU_PF_BAR0) npc_af_pkind#_cpi_def#
  *
- * NPC AF Port Kind Channel Parse Index Definition Registers
- * These registers specify the layer information and algorithm to compute a
- * packet's channel parse index (CPI), which provides a port to channel adder for
- * calculating NPC_RESULT_S[CHAN].
- *
- * There are two CPI definitions per port kind, allowing the CPI computation to
- * use two possible layer definitions in the parsed packet, e.g. DiffServ DSCP
- * from either IPv4 or IPv6 header.
- *
- * CPI pseudocode:
- * \<pre\>
- * for (i = 0; i \< 2; i++) {
- *    cpi_def = NPC_AF_PKIND()_CPI_DEF(i);
- *    LX = LA, LB, ..., or LH as selected by cpi_def[LID];
- *
- *    if (cpi_def[VALID]
- *        && ((cpi_def[LTYPE_MATCH] & cpi_def[LTYPE_MASK])
- *             == (NPC_RESULT_S[LX[LTYPE]] & cpi_def[LTYPE_MASK]))
- *        && ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])
- *             == (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))
- *    {
- *       // Found matching layer
- *       nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) + cpi_def[ADD_OFFSET];
- *       add_byte = byte at nibble_offset from start of packet;
- *       cpi_add = (add_byte & cpi_def[ADD_MASK]) \>\> cpi_def[ADD_SHIFT];
- *       cpi = cpi_def[CPI_BASE] + cpi_add;
- *       NPC_RESULT_S[CHAN] += NPC_AF_CPI(cpi)_CFG[PADD];
- *       break;
- *    }
- * }
+ * NPC AF Port Kind Channel Parse Index Definition Registers These
+ * registers specify the layer information and algorithm to compute a
+ * packet's channel parse index (CPI), which provides a port to channel
+ * adder for calculating NPC_RESULT_S[CHAN].  There are two CPI
+ * definitions per port kind, allowing the CPI computation to use two
+ * possible layer definitions in the parsed packet, e.g. DiffServ DSCP
+ * from either IPv4 or IPv6 header.  CPI pseudocode: \<pre\> for (i = 0;
+ * i \< 2; i++) {    cpi_def = NPC_AF_PKIND()_CPI_DEF(i);    LX = LA, LB,
+ * ..., or LH as selected by cpi_def[LID];     if (cpi_def[VALID]
+ * && ((cpi_def[LTYPE_MATCH] & cpi_def[LTYPE_MASK])             ==
+ * (NPC_RESULT_S[LX[LTYPE]] & cpi_def[LTYPE_MASK]))        &&
+ * ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])             ==
+ * (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))    {       // Found
+ * matching layer       nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) +
+ * cpi_def[ADD_OFFSET];       add_byte = byte at nibble_offset from start
+ * of packet;       cpi_add = (add_byte & cpi_def[ADD_MASK]) \>\>
+ * cpi_def[ADD_SHIFT];       cpi = cpi_def[CPI_BASE] + cpi_add;
+ * NPC_RESULT_S[CHAN] += NPC_AF_CPI(cpi)_CFG[PADD];       break;    } }
  * \</pre\>
  */
 union cavm_npc_af_pkindx_cpi_defx {
diff --git a/drivers/net/cavium/octeontx2/cavm-csrs-rvu.h b/drivers/net/cavium/octeontx2/cavm-csrs-rvu.h
index cb796bc351..813c0fef88 100644
--- a/drivers/net/cavium/octeontx2/cavm-csrs-rvu.h
+++ b/drivers/net/cavium/octeontx2/cavm-csrs-rvu.h
@@ -1,45 +1,12 @@
 #ifndef __CAVM_CSRS_RVU_H__
 #define __CAVM_CSRS_RVU_H__
-/* This file is auto-generated. Do not edit */
+/* This file is auto-generated.  Do not edit */
 
-/***********************license start***************
- * Copyright (c) 2003-2018  Cavium Inc. (support@cavium.com). All rights
- * reserved.
- *
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
-
- *   * Neither the name of Cavium Inc. nor the names of
- *     its contributors may be used to endorse or promote products
- *     derived from this software without specific prior written
- *     permission.
-
- * This Software, including technical data, may be subject to U.S. export  control
- * laws, including the U.S. Export Administration Act and its  associated
- * regulations, and may be subject to export or import  regulations in other
- * countries.
-
- * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
- * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
- * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
- * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
- * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
- * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
- * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
- * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
- * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
- ***********************license end**************************************/
+/***********************license start***********************************
+* Copyright (C) 2018 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
 
 /**
  * @file
@@ -47,18 +14,17 @@
  * Configuration and status register (CSR) address and type definitions for
  * Cavium RVU.
  *
- * This file is auto generated. Do not edit.
+ * This file is auto generated.  Do not edit.
  *
  */
 
 /**
  * Enumeration rvu_af_int_vec_e
  *
- * RVU Admin Function Interrupt Vector Enumeration
- * Enumerates the MSI-X interrupt vectors.
- * Internal:
- * RVU maintains the state of these vectors internally, and generates GIB
- * messages for it without accessing the MSI-X table region in LLC/DRAM.
+ * RVU Admin Function Interrupt Vector Enumeration Enumerates the MSI-X
+ * interrupt vectors. Internal: RVU maintains the state of these vectors
+ * internally, and generates GIB messages for it without accessing the
+ * MSI-X table region in LLC/DRAM.
  */
 #define CAVM_RVU_AF_INT_VEC_E_GEN (3)
 #define CAVM_RVU_AF_INT_VEC_E_MBOX (4)
@@ -69,10 +35,8 @@
 /**
  * Enumeration rvu_bar_e
  *
- * RVU Base Address Register Enumeration
- * Enumerates the base address registers.
- * Internal:
- * For documentation only.
+ * RVU Base Address Register Enumeration Enumerates the base address
+ * registers. Internal: For documentation only.
  */
 #define CAVM_RVU_BAR_E_RVU_PFX_BAR0(a) (0x840000000000ll + 0x1000000000ll * (a))
 #define CAVM_RVU_BAR_E_RVU_PFX_BAR0_SIZE 0x10000000ull
@@ -83,9 +47,9 @@
 /**
  * Enumeration rvu_block_addr_e
  *
- * RVU Block Address Enumeration
- * Enumerates addressing of RVU resource blocks within each RVU BAR, i.e. values
- * of RVU_FUNC_ADDR_S[BLOCK] and RVU_AF_ADDR_S[BLOCK].
+ * RVU Block Address Enumeration Enumerates addressing of RVU resource
+ * blocks within each RVU BAR, i.e. values of RVU_FUNC_ADDR_S[BLOCK] and
+ * RVU_AF_ADDR_S[BLOCK].
  */
 #define CAVM_RVU_BLOCK_ADDR_E_CPTX(a) (0xa + (a))
 #define CAVM_RVU_BLOCK_ADDR_E_LMT (1)
@@ -102,8 +66,8 @@
 /**
  * Enumeration rvu_block_type_e
  *
- * RVU Block Type Enumeration
- * Enumerates values of RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[BTYPE].
+ * RVU Block Type Enumeration Enumerates values of
+ * RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[BTYPE].
  */
 #define CAVM_RVU_BLOCK_TYPE_E_CPT (9)
 #define CAVM_RVU_BLOCK_TYPE_E_DDF (0xb)
@@ -124,22 +88,17 @@
 /**
  * Enumeration rvu_bus_lf_e
  *
- * INTERNAL: RVU Bus LF Range Enumeration
- *
- * Enumerates the LF range for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus LF Range Enumeration  Enumerates the LF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
 #define CAVM_RVU_BUS_LF_E_RVU_BUS_LFX(a) (0 + 0x2000000 * (a))
 
 /**
  * Enumeration rvu_bus_lf_slot_e
  *
- * INTERNAL: RVU Bus LF Slot Range Enumeration
- *
- * Enumerates the LF and Slot range for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus LF Slot Range Enumeration  Enumerates the LF and
+ * Slot range for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
  */
 #define CAVM_RVU_BUS_LF_SLOT_E_RVU_BUS_LFX_SLOTX(a, b)	\
 	(0 + 0x2000000 * (a) + 0x1000 * (b))
@@ -147,22 +106,17 @@
 /**
  * Enumeration rvu_bus_pf_e
  *
- * INTERNAL: RVU Bus PF Range Enumeration
- *
- * Enumerates the PF range for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus PF Range Enumeration  Enumerates the PF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
 #define CAVM_RVU_BUS_PF_E_RVU_BUS_PFX(a) (0ll + 0x1000000000ll * (a))
 
 /**
  * Enumeration rvu_bus_pfvf_e
  *
- * INTERNAL: RVU Bus PFVF Range Enumeration
- *
- * Enumerates the PF and VF ranges for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus PFVF Range Enumeration  Enumerates the PF and VF
+ * ranges for the RVU bus. Internal: This is an enum used in csr3 virtual
+ * equations.
  */
 #define CAVM_RVU_BUS_PFVF_E_RVU_BUS_PFX(a) (0 + 0x2000000 * (a))
 #define CAVM_RVU_BUS_PFVF_E_RVU_BUS_VFX(a) (0 + 0x2000000 * (a))
@@ -170,11 +124,9 @@
 /**
  * Enumeration rvu_busbar_e
  *
- * INTERNAL: RVU Bus Base Address Region Enumeration
- *
- * Enumerates the base address region for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus Base Address Region Enumeration  Enumerates the base
+ * address region for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
  */
 #define CAVM_RVU_BUSBAR_E_RVU_BUSBAR0 (0)
 #define CAVM_RVU_BUSBAR_E_RVU_BUSBAR2 (0x200000000ll)
@@ -182,19 +134,16 @@
 /**
  * Enumeration rvu_busdid_e
  *
- * INTERNAL: RVU Bus DID Enumeration
- *
- * Enumerates the DID offset for the RVU bus.
- * Internal:
- * This is an enum used in csr3 virtual equations.
+ * INTERNAL: RVU Bus DID Enumeration  Enumerates the DID offset for the
+ * RVU bus. Internal: This is an enum used in csr3 virtual equations.
  */
 #define CAVM_RVU_BUSDID_E_RVU_BUSDID (0x840000000000ll)
 
 /**
  * Enumeration rvu_pf_int_vec_e
  *
- * RVU PF Interrupt Vector Enumeration
- * Enumerates the MSI-X interrupt vectors.
+ * RVU PF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
  */
 #define CAVM_RVU_PF_INT_VEC_E_AFPF_MBOX (6)
 #define CAVM_RVU_PF_INT_VEC_E_VFFLRX(a) (0 + (a))
@@ -204,17 +153,17 @@
 /**
  * Enumeration rvu_vf_int_vec_e
  *
- * RVU VF Interrupt Vector Enumeration
- * Enumerates the MSI-X interrupt vectors.
+ * RVU VF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
  */
 #define CAVM_RVU_VF_INT_VEC_E_MBOX (0)
 
 /**
  * Structure rvu_af_addr_s
  *
- * RVU Admin Function Register Address Structure
- * Address format for accessing shared Admin Function (AF) registers in
- * RVU PF BAR0. These registers may be accessed by all RVU PFs whose
+ * RVU Admin Function Register Address Structure Address format for
+ * accessing shared Admin Function (AF) registers in RVU PF BAR0. These
+ * registers may be accessed by all RVU PFs whose
  * RVU_PRIV_PF()_CFG[AF_ENA] bit is set.
  */
 union cavm_rvu_af_addr_s {
@@ -230,8 +179,8 @@ union cavm_rvu_af_addr_s {
 /**
  * Structure rvu_func_addr_s
  *
- * RVU Function-unique Address Structure
- * Address format for accessing function-unique registers in RVU PF/FUNC BAR2.
+ * RVU Function-unique Address Structure Address format for accessing
+ * function-unique registers in RVU PF/FUNC BAR2.
  */
 union cavm_rvu_func_addr_s {
 	u32 u;
@@ -247,9 +196,8 @@ union cavm_rvu_func_addr_s {
 /**
  * Structure rvu_msix_vec_s
  *
- * RVU MSI-X Vector Structure
- * Format of entries in the RVU MSI-X table region in LLC/DRAM. See
- * RVU_PRIV_PF()_MSIX_CFG.
+ * RVU MSI-X Vector Structure Format of entries in the RVU MSI-X table
+ * region in LLC/DRAM. See RVU_PRIV_PF()_MSIX_CFG.
  */
 union cavm_rvu_msix_vec_s {
 	u64 u[2];
@@ -266,13 +214,11 @@ union cavm_rvu_msix_vec_s {
 /**
  * Structure rvu_pf_func_s
  *
- * RVU PF Function Identification Structure
- * Identifies an RVU PF/VF, and format of *_PRIV_LF()_CFG[PF_FUNC] in RVU
- * resource blocks, e.g. NPA_PRIV_LF()_CFG[PF_FUNC].
- *
- * Internal:
- * Also used for PF/VF identification on inter-coprocessor hardware
- * interfaces (NPA, SSO, CPT, ...).
+ * RVU PF Function Identification Structure Identifies an RVU PF/VF, and
+ * format of *_PRIV_LF()_CFG[PF_FUNC] in RVU resource blocks, e.g.
+ * NPA_PRIV_LF()_CFG[PF_FUNC].  Internal: Also used for PF/VF
+ * identification on inter-coprocessor hardware interfaces (NPA, SSO,
+ * CPT, ...).
  */
 union cavm_rvu_pf_func_s {
 	u32 u;
@@ -307,13 +253,10 @@ static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) rvu_af_bar2_alias#
  *
- * INTERNAL: RVU Admin Function  BAR2 Alias Registers
- *
- * These registers alias to the RVU BAR2 registers for the PF and function
- * selected by RVU_AF_BAR2_SEL[PF_FUNC].
- *
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: RVU Admin Function  BAR2 Alias Registers  These registers
+ * alias to the RVU BAR2 registers for the PF and function selected by
+ * RVU_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
  */
 union cavm_rvu_af_bar2_aliasx {
 	u64 u;
@@ -333,11 +276,9 @@ static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_af_bar2_sel
  *
- * INTERNAL: RVU Admin Function BAR2 Select Register
- *
- * This register configures BAR2 accesses from the RVU_AF_BAR2_ALIAS() registers in BAR0.
- * Internal:
- * Not implemented. Placeholder for bug33464.
+ * INTERNAL: RVU Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the RVU_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
  */
 union cavm_rvu_af_bar2_sel {
 	u64 u;
@@ -426,8 +367,8 @@ static inline u64 CAVM_RVU_AF_ECO(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_gen_int
  *
- * RVU Admin Function General Interrupt Register
- * This register contains General interrupt summary bits.
+ * RVU Admin Function General Interrupt Register This register contains
+ * General interrupt summary bits.
  */
 union cavm_rvu_af_gen_int {
 	u64 u;
@@ -449,8 +390,8 @@ static inline u64 CAVM_RVU_AF_GEN_INT(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1c
  *
- * RVU Admin Function General Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * RVU Admin Function General Interrupt Enable Clear Register This
+ * register clears interrupt enable bits.
  */
 union cavm_rvu_af_gen_int_ena_w1c {
 	u64 u;
@@ -472,8 +413,8 @@ static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1s
  *
- * RVU Admin Function General Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * RVU Admin Function General Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
  */
 union cavm_rvu_af_gen_int_ena_w1s {
 	u64 u;
@@ -495,8 +436,8 @@ static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_gen_int_w1s
  *
- * RVU Admin Function General Interrupt Set Register
- * This register sets interrupt bits.
+ * RVU Admin Function General Interrupt Set Register This register sets
+ * interrupt bits.
  */
 union cavm_rvu_af_gen_int_w1s {
 	u64 u;
@@ -672,8 +613,8 @@ static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_w1s
  *
- * RVU Admin Function PF to AF Mailbox Interrupt Set Registers
- * This register sets interrupt bits.
+ * RVU Admin Function PF to AF Mailbox Interrupt Set Registers This
+ * register sets interrupt bits.
  */
 union cavm_rvu_af_pfaf_mbox_int_w1s {
 	u64 u;
@@ -715,8 +656,8 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1c
  *
- * RVU Admin Function PF Function Level Reset Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
  */
 union cavm_rvu_af_pfflr_int_ena_w1c {
 	u64 u;
@@ -737,8 +678,8 @@ static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1s
  *
- * RVU Admin Function PF Function Level Reset Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Set
+ * Registers This register sets interrupt enable bits.
  */
 union cavm_rvu_af_pfflr_int_ena_w1s {
 	u64 u;
@@ -802,8 +743,8 @@ static inline u64 CAVM_RVU_AF_PFME_INT(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pfme_int_ena_w1c
  *
- * RVU Admin Function PF Bus Master Enable Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * RVU Admin Function PF Bus Master Enable Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
  */
 union cavm_rvu_af_pfme_int_ena_w1c {
 	u64 u;
@@ -846,8 +787,8 @@ static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pfme_int_w1s
  *
- * RVU Admin Function PF Bus Master Enable Interrupt Set Registers
- * This register sets interrupt bits.
+ * RVU Admin Function PF Bus Master Enable Interrupt Set Registers This
+ * register sets interrupt bits.
  */
 union cavm_rvu_af_pfme_int_w1s {
 	u64 u;
@@ -910,8 +851,8 @@ static inline u64 CAVM_RVU_AF_PFTRPEND(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_pftrpend_w1s
  *
- * RVU Admin Function PF Transaction Pending Set Registers
- * This register reads or sets bits.
+ * RVU Admin Function PF Transaction Pending Set Registers This register
+ * reads or sets bits.
  */
 union cavm_rvu_af_pftrpend_w1s {
 	u64 u;
@@ -932,9 +873,9 @@ static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_ras
  *
- * RVU Admin Function RAS Interrupt Register
- * This register is intended for delivery of RAS events to the SCP, so should be
- * ignored by OS drivers.
+ * RVU Admin Function RAS Interrupt Register This register is intended
+ * for delivery of RAS events to the SCP, so should be ignored by OS
+ * drivers.
  */
 union cavm_rvu_af_ras {
 	u64 u;
@@ -955,8 +896,8 @@ static inline u64 CAVM_RVU_AF_RAS(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1c
  *
- * RVU Admin Function RAS Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * RVU Admin Function RAS Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
  */
 union cavm_rvu_af_ras_ena_w1c {
 	u64 u;
@@ -977,8 +918,8 @@ static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1s
  *
- * RVU Admin Function RAS Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * RVU Admin Function RAS Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
  */
 union cavm_rvu_af_ras_ena_w1s {
 	u64 u;
@@ -999,8 +940,8 @@ static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR0) rvu_af_ras_w1s
  *
- * RVU Admin Function RAS Interrupt Set Register
- * This register sets interrupt bits.
+ * RVU Admin Function RAS Interrupt Set Register This register sets
+ * interrupt bits.
  */
 union cavm_rvu_af_ras_w1s {
 	u64 u;
@@ -1021,10 +962,9 @@ static inline u64 CAVM_RVU_AF_RAS_W1S(void)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_block_addr#_disc
  *
- * RVU PF Block Address Discovery Registers
- * These registers allow each PF driver to discover block resources that are
- * provisioned to its PF. The register's block address index is enumerated by
- * RVU_BLOCK_ADDR_E.
+ * RVU PF Block Address Discovery Registers These registers allow each PF
+ * driver to discover block resources that are provisioned to its PF. The
+ * register's block address index is enumerated by RVU_BLOCK_ADDR_E.
  */
 union cavm_rvu_pf_block_addrx_disc {
 	u64 u;
@@ -1070,8 +1010,8 @@ static inline u64 CAVM_RVU_PF_INT(void)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1c
  *
- * RVU PF Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * RVU PF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
  */
 union cavm_rvu_pf_int_ena_w1c {
 	u64 u;
@@ -1092,8 +1032,8 @@ static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1s
  *
- * RVU PF Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * RVU PF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_rvu_pf_int_ena_w1s {
 	u64 u;
@@ -1114,8 +1054,7 @@ static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_int_w1s
  *
- * RVU PF Interrupt Set Register
- * This register sets interrupt bits.
+ * RVU PF Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_rvu_pf_int_w1s {
 	u64 u;
@@ -1136,8 +1075,8 @@ static inline u64 CAVM_RVU_PF_INT_W1S(void)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_msix_pba#
  *
- * RVU PF MSI-X Pending-Bit-Array Registers
- * This register is the MSI-X PF PBA table.
+ * RVU PF MSI-X Pending-Bit-Array Registers This register is the MSI-X PF
+ * PBA table.
  */
 union cavm_rvu_pf_msix_pbax {
 	u64 u;
@@ -1157,13 +1096,12 @@ static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_addr
  *
- * RVU PF MSI-X Vector-Table Address Registers
- * These registers and RVU_PF_MSIX_VEC()_CTL form the PF MSI-X vector table.
- * The number of MSI-X vectors for a given PF is specified by
- * RVU_PRIV_PF()_MSIX_CFG[PF_MSIXT_SIZEM1] (plus 1).
- *
- * Software must do a read after any writes to the MSI-X vector table to ensure
- * that the writes have completed before interrupts are generated to the modified
+ * RVU PF MSI-X Vector-Table Address Registers These registers and
+ * RVU_PF_MSIX_VEC()_CTL form the PF MSI-X vector table. The number of
+ * MSI-X vectors for a given PF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[PF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
  * vectors.
  */
 union cavm_rvu_pf_msix_vecx_addr {
@@ -1187,8 +1125,8 @@ static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_ctl
  *
- * RVU PF MSI-X Vector-Table Control and Data Registers
- * These registers and RVU_PF_MSIX_VEC()_ADDR form the PF MSI-X vector table.
+ * RVU PF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_PF_MSIX_VEC()_ADDR form the PF MSI-X vector table.
  */
 union cavm_rvu_pf_msix_vecx_ctl {
 	u64 u;
@@ -1291,8 +1229,8 @@ static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1c#
  *
- * RVU PF VF Function Level Reset Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * RVU PF VF Function Level Reset Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
  */
 union cavm_rvu_pf_vfflr_int_ena_w1cx {
 	u64 u;
@@ -1312,8 +1250,8 @@ static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1s#
  *
- * RVU PF VF Function Level Reset Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * RVU PF VF Function Level Reset Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
  */
 union cavm_rvu_pf_vfflr_int_ena_w1sx {
 	u64 u;
@@ -1333,8 +1271,8 @@ static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_w1s#
  *
- * RVU PF VF Function Level Reset Interrupt Set Registers
- * This register sets interrupt bits.
+ * RVU PF VF Function Level Reset Interrupt Set Registers This register
+ * sets interrupt bits.
  */
 union cavm_rvu_pf_vfflr_int_w1sx {
 	u64 u;
@@ -1374,8 +1312,8 @@ static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1c#
  *
- * RVU PF VF Bus Master Enable Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * RVU PF VF Bus Master Enable Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
  */
 union cavm_rvu_pf_vfme_int_ena_w1cx {
 	u64 u;
@@ -1395,8 +1333,8 @@ static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1s#
  *
- * RVU PF VF Bus Master Enable Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * RVU PF VF Bus Master Enable Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
  */
 union cavm_rvu_pf_vfme_int_ena_w1sx {
 	u64 u;
@@ -1416,8 +1354,8 @@ static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfme_int_w1s#
  *
- * RVU PF VF Bus Master Enable Interrupt Set Registers
- * This register sets interrupt bits.
+ * RVU PF VF Bus Master Enable Interrupt Set Registers This register sets
+ * interrupt bits.
  */
 union cavm_rvu_pf_vfme_int_w1sx {
 	u64 u;
@@ -1477,8 +1415,8 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1c#
  *
- * RVU VF to PF Mailbox Interrupt Enable Clear Registers
- * This register clears interrupt enable bits.
+ * RVU VF to PF Mailbox Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
  */
 union cavm_rvu_pf_vfpf_mbox_int_ena_w1cx {
 	u64 u;
@@ -1498,8 +1436,8 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1s#
  *
- * RVU VF to PF Mailbox Interrupt Enable Set Registers
- * This register sets interrupt enable bits.
+ * RVU VF to PF Mailbox Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
  */
 union cavm_rvu_pf_vfpf_mbox_int_ena_w1sx {
 	u64 u;
@@ -1519,8 +1457,8 @@ static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_w1s#
  *
- * RVU VF to PF Mailbox Interrupt Set Registers
- * This register sets interrupt bits.
+ * RVU VF to PF Mailbox Interrupt Set Registers This register sets
+ * interrupt bits.
  */
 union cavm_rvu_pf_vfpf_mbox_int_w1sx {
 	u64 u;
@@ -1560,8 +1498,8 @@ static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
 /**
  * Register (RVU_PF_BAR2) rvu_pf_vftrpend_w1s#
  *
- * RVU PF VF Transaction Pending Set Registers
- * This register reads or sets bits.
+ * RVU PF VF Transaction Pending Set Registers This register reads or
+ * sets bits.
  */
 union cavm_rvu_pf_vftrpend_w1sx {
 	u64 u;
@@ -1601,9 +1539,9 @@ static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_block_type#_rev
  *
- * RVU Privileged Block Type Revision Registers
- * These registers are used by configuration software to specify the revision ID
- * of each block type enumerated by RVU_BLOCK_TYPE_E, to assist VF/PF software
+ * RVU Privileged Block Type Revision Registers These registers are used
+ * by configuration software to specify the revision ID of each block
+ * type enumerated by RVU_BLOCK_TYPE_E, to assist VF/PF software
  * discovery.
  */
 union cavm_rvu_priv_block_typex_rev {
@@ -1647,8 +1585,8 @@ static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_const
  *
- * RVU Privileged Constants Register
- * This register contains constants for software discovery.
+ * RVU Privileged Constants Register This register contains constants for
+ * software discovery.
  */
 union cavm_rvu_priv_const {
 	u64 u;
@@ -1693,8 +1631,8 @@ static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_hwvf#_cpt#_cfg
  *
- * RVU Privileged Hardware VF CPT Configuration Registers
- * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for CPT({a}) block.
+ * RVU Privileged Hardware VF CPT Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for CPT({a}) block.
  */
 union cavm_rvu_priv_hwvfx_cptx_cfg {
 	u64 u;
@@ -1738,11 +1676,12 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_hwvf#_nix#_cfg
  *
- * RVU Privileged Hardware VF NIX Configuration Registers
- * These registers are used to assist VF software discovery. For each HWVF, if the
- * HWVF is mapped to a VF by RVU_PRIV_PF()_CFG[FIRST_HWVF,NVF], software
- * writes NIX block's resource configuration for the VF in this register. The VF
- * driver can read RVU_VF_BLOCK_ADDR()_DISC to discover the configuration.
+ * RVU Privileged Hardware VF NIX Configuration Registers These registers
+ * are used to assist VF software discovery. For each HWVF, if the HWVF
+ * is mapped to a VF by RVU_PRIV_PF()_CFG[FIRST_HWVF,NVF], software
+ * writes NIX block's resource configuration for the VF in this register.
+ * The VF driver can read RVU_VF_BLOCK_ADDR()_DISC to discover the
+ * configuration.
  */
 union cavm_rvu_priv_hwvfx_nixx_cfg {
 	u64 u;
@@ -1763,8 +1702,8 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_hwvf#_npa_cfg
  *
- * RVU Privileged Hardware VF NPA Configuration Registers
- * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for NPA block.
+ * RVU Privileged Hardware VF NPA Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for NPA block.
  */
 union cavm_rvu_priv_hwvfx_npa_cfg {
 	u64 u;
@@ -1785,8 +1724,8 @@ static inline u64 CAVM_RVU_PRIV_HWVFX_NPA_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_hwvf#_sso_cfg
  *
- * RVU Privileged Hardware VF SSO Configuration Registers
- * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for SSO block.
+ * RVU Privileged Hardware VF SSO Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for SSO block.
  */
 union cavm_rvu_priv_hwvfx_sso_cfg {
 	u64 u;
@@ -1876,8 +1815,8 @@ static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_cpt#_cfg
  *
- * RVU Privileged PF CPT Configuration Registers
- * Similar to RVU_PRIV_PF()_NIX()_CFG, but for CPT({a}) block.
+ * RVU Privileged PF CPT Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for CPT({a}) block.
  */
 union cavm_rvu_priv_pfx_cptx_cfg {
 	u64 u;
@@ -1944,28 +1883,23 @@ static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_msix_cfg
  *
- * RVU Privileged PF MSI-X Configuration Registers
- * These registers specify MSI-X table sizes and locations for RVU PFs and
- * associated VFs. Hardware maintains all RVU MSI-X tables in a contiguous memory
- * region in LLC/DRAM called the MSI-X table region. The table region's base AF IOVA
- * is specified by RVU_AF_MSIXTR_BASE, and its size as a multiple of
- * 16-byte RVU_MSIX_VEC_S structures must be less than or equal to
- * RVU_PRIV_CONST[MAX_MSIX].
- *
- * A PF's MSI-X table consists of the following range of RVU_MSIX_VEC_S structures
- * in the table region:
- * * First index: [PF_MSIXT_OFFSET].
- * * Last index: [PF_MSIXT_OFFSET] + [PF_MSIXT_SIZEM1].
- *
- * If a PF has enabled VFs (associated RVU_PRIV_PF()_CFG[NVF] is nonzero),
- * then each VF's MSI-X table consumes the following range of RVU_MSIX_VEC_S structures:
- * * First index: [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1).
- * * Last index: [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1) + [VF_MSIXT_SIZEM1].
- *
- * N=0 for the first VF, N=1 for the second VF, etc.
- *
- * Different PFs and VFs must have non-overlapping vector ranges, and the last
- * index of any range must be less than RVU_PRIV_CONST[MAX_MSIX].
+ * RVU Privileged PF MSI-X Configuration Registers These registers
+ * specify MSI-X table sizes and locations for RVU PFs and associated
+ * VFs. Hardware maintains all RVU MSI-X tables in a contiguous memory
+ * region in LLC/DRAM called the MSI-X table region. The table region's
+ * base AF IOVA is specified by RVU_AF_MSIXTR_BASE, and its size as a
+ * multiple of 16-byte RVU_MSIX_VEC_S structures must be less than or
+ * equal to RVU_PRIV_CONST[MAX_MSIX].  A PF's MSI-X table consists of the
+ * following range of RVU_MSIX_VEC_S structures in the table region: *
+ * First index: [PF_MSIXT_OFFSET]. * Last index: [PF_MSIXT_OFFSET] +
+ * [PF_MSIXT_SIZEM1].  If a PF has enabled VFs (associated
+ * RVU_PRIV_PF()_CFG[NVF] is nonzero), then each VF's MSI-X table
+ * consumes the following range of RVU_MSIX_VEC_S structures: * First
+ * index: [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1). * Last index:
+ * [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1) + [VF_MSIXT_SIZEM1].
+ * N=0 for the first VF, N=1 for the second VF, etc.  Different PFs and
+ * VFs must have non-overlapping vector ranges, and the last index of any
+ * range must be less than RVU_PRIV_CONST[MAX_MSIX].
  */
 union cavm_rvu_priv_pfx_msix_cfg {
 	u64 u;
@@ -1988,10 +1922,10 @@ static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_nix#_cfg
  *
- * RVU Privileged PF NIX Configuration Registers
- * These registers are used to assist PF software discovery. For each enabled RVU
- * PF, software writes the block's resource configuration for the PF in this
- * register. The PF driver can read RVU_PF_BLOCK_ADDR()_DISC to discover the
+ * RVU Privileged PF NIX Configuration Registers These registers are used
+ * to assist PF software discovery. For each enabled RVU PF, software
+ * writes the block's resource configuration for the PF in this register.
+ * The PF driver can read RVU_PF_BLOCK_ADDR()_DISC to discover the
  * configuration.
  */
 union cavm_rvu_priv_pfx_nixx_cfg {
@@ -2013,8 +1947,8 @@ static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_npa_cfg
  *
- * RVU Privileged PF NPA Configuration Registers
- * Similar to RVU_PRIV_PF()_NIX()_CFG, but for NPA block.
+ * RVU Privileged PF NPA Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for NPA block.
  */
 union cavm_rvu_priv_pfx_npa_cfg {
 	u64 u;
@@ -2035,8 +1969,8 @@ static inline u64 CAVM_RVU_PRIV_PFX_NPA_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_sso_cfg
  *
- * RVU Privileged PF SSO Configuration Registers
- * Similar to RVU_PRIV_PF()_NIX()_CFG, but for SSO block.
+ * RVU Privileged PF SSO Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSO block.
  */
 union cavm_rvu_priv_pfx_sso_cfg {
 	u64 u;
@@ -2057,8 +1991,8 @@ static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_ssow_cfg
  *
- * RVU Privileged PF SSO Work Slot Configuration Registers
- * Similar to RVU_PRIV_PF()_NIX()_CFG, but for SSOW block.
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSOW block.
  */
 union cavm_rvu_priv_pfx_ssow_cfg {
 	u64 u;
@@ -2079,8 +2013,8 @@ static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
 /**
  * Register (RVU_PF_BAR0) rvu_priv_pf#_tim_cfg
  *
- * RVU Privileged PF SSO Work Slot Configuration Registers
- * Similar to RVU_PRIV_PF()_NIX()_CFG, but for TIM block.
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for TIM block.
  */
 union cavm_rvu_priv_pfx_tim_cfg {
 	u64 u;
@@ -2101,10 +2035,9 @@ static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_block_addr#_disc
  *
- * RVU VF Block Address Discovery Registers
- * These registers allow each VF driver to discover block resources that are
- * provisioned to its VF. The register's block address index is enumerated by
- * RVU_BLOCK_ADDR_E.
+ * RVU VF Block Address Discovery Registers These registers allow each VF
+ * driver to discover block resources that are provisioned to its VF. The
+ * register's block address index is enumerated by RVU_BLOCK_ADDR_E.
  */
 union cavm_rvu_vf_block_addrx_disc {
 	u64 u;
@@ -2150,8 +2083,8 @@ static inline u64 CAVM_RVU_VF_INT(void)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1c
  *
- * RVU VF Interrupt Enable Clear Register
- * This register clears interrupt enable bits.
+ * RVU VF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
  */
 union cavm_rvu_vf_int_ena_w1c {
 	u64 u;
@@ -2172,8 +2105,8 @@ static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1s
  *
- * RVU VF Interrupt Enable Set Register
- * This register sets interrupt enable bits.
+ * RVU VF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
  */
 union cavm_rvu_vf_int_ena_w1s {
 	u64 u;
@@ -2194,8 +2127,7 @@ static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_int_w1s
  *
- * RVU VF Interrupt Set Register
- * This register sets interrupt bits.
+ * RVU VF Interrupt Set Register This register sets interrupt bits.
  */
 union cavm_rvu_vf_int_w1s {
 	u64 u;
@@ -2216,8 +2148,8 @@ static inline u64 CAVM_RVU_VF_INT_W1S(void)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_msix_pba#
  *
- * RVU VF MSI-X Pending-Bit-Array Registers
- * This register is the MSI-X VF PBA table.
+ * RVU VF MSI-X Pending-Bit-Array Registers This register is the MSI-X VF
+ * PBA table.
  */
 union cavm_rvu_vf_msix_pbax {
 	u64 u;
@@ -2237,13 +2169,12 @@ static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_addr
  *
- * RVU VF MSI-X Vector-Table Address Registers
- * These registers and RVU_VF_MSIX_VEC()_CTL form the VF MSI-X vector table.
- * The number of MSI-X vectors for a given VF is specified by
- * RVU_PRIV_PF()_MSIX_CFG[VF_MSIXT_SIZEM1] (plus 1).
- *
- * Software must do a read after any writes to the MSI-X vector table to ensure
- * that the writes have completed before interrupts are generated to the modified
+ * RVU VF MSI-X Vector-Table Address Registers These registers and
+ * RVU_VF_MSIX_VEC()_CTL form the VF MSI-X vector table. The number of
+ * MSI-X vectors for a given VF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[VF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
  * vectors.
  */
 union cavm_rvu_vf_msix_vecx_addr {
@@ -2267,8 +2198,8 @@ static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
 /**
  * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_ctl
  *
- * RVU VF MSI-X Vector-Table Control and Data Registers
- * These registers and RVU_VF_MSIX_VEC()_ADDR form the VF MSI-X vector table.
+ * RVU VF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_VF_MSIX_VEC()_ADDR form the VF MSI-X vector table.
  */
 union cavm_rvu_vf_msix_vecx_ctl {
 	u64 u;
-- 
2.29.0

