From a91085a47fccbbcbfccd050c2bf9aa4d82c4ee6e Mon Sep 17 00:00:00 2001
From: Rick Farrington <rfarrington@marvell.com>
Date: Sun, 24 May 2020 00:50:14 -0400
Subject: [PATCH 1166/1239] drivers: net: octeontx: otx3: add initial support
 for t106 RVU AF

Change-Id: I3bbbdb0b8f86872b241745f6cbaf2b07c58fb39b
Signed-off-by: Rick Farrington <rfarrington@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/boot/u-boot/+/29004
Reviewed-by: Chandrakala Chavva <cchavva@marvell.com>
Tested-by: Chandrakala Chavva <cchavva@marvell.com>
Reviewed-on: https://sj1git1.cavium.com/c/IP/SW/boot/u-boot/+/29494
Tested-by: sa_ip-sw-jenkins <sa_ip-sw-jenkins@marvell.com>
---
 board/Marvell/octeontx3/board.c    |   18 +
 cmd/marvell/Kconfig                |    4 +-
 configs/octeontx3_106xx_defconfig  |    1 +
 drivers/net/Kconfig                |    9 +
 drivers/net/Makefile               |    1 +
 drivers/net/octeontx3/Makefile     |   10 +
 drivers/net/octeontx3/lmt.h        |   51 ++
 drivers/net/octeontx3/nix.h        |  355 +++++++++
 drivers/net/octeontx3/nix_af.c     | 1108 ++++++++++++++++++++++++++++
 drivers/net/octeontx3/rvu.h        |  127 ++++
 drivers/net/octeontx3/rvu_af.c     |  172 +++++
 drivers/net/octeontx3/rvu_common.c |   74 ++
 12 files changed, 1928 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/octeontx3/Makefile
 create mode 100644 drivers/net/octeontx3/lmt.h
 create mode 100644 drivers/net/octeontx3/nix.h
 create mode 100644 drivers/net/octeontx3/nix_af.c
 create mode 100644 drivers/net/octeontx3/rvu.h
 create mode 100644 drivers/net/octeontx3/rvu_af.c
 create mode 100644 drivers/net/octeontx3/rvu_common.c

diff --git a/board/Marvell/octeontx3/board.c b/board/Marvell/octeontx3/board.c
index 47bb74bcfd..af131265f2 100644
--- a/board/Marvell/octeontx3/board.c
+++ b/board/Marvell/octeontx3/board.c
@@ -100,6 +100,20 @@ int dram_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_NET_OCTEONTX3
+#define	PCI_DEVID_OCTEONTX2_RVU_AF		0xA065
+#define	PCI_DEVID_OCTEONTX2_RVU_PF		0xA063
+void board_late_probe_devices(void)
+{
+	struct udevice *dev;
+	int err;
+
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM,
+				 PCI_DEVID_OCTEONTX2_RVU_AF, 0, &dev);
+	if (err)
+		debug("RVU AF device not found\n");
+}
+#endif
 /**
  * Board late initialization routine.
  */
@@ -141,6 +155,10 @@ int board_late_init(void)
 		env_set("serial#", boardserial);
 	}
 
+#ifdef CONFIG_NET_OCTEONTX3
+	board_late_probe_devices();
+#endif
+
 	if (save_env)
 		env_save();
 
diff --git a/cmd/marvell/Kconfig b/cmd/marvell/Kconfig
index 27d1293d6c..c280352849 100644
--- a/cmd/marvell/Kconfig
+++ b/cmd/marvell/Kconfig
@@ -9,12 +9,12 @@ config CMD_FAILSAFE
 	   primary device was successful.
 
 config CMD_ETH
-	depends on NET_OCTEONTX2
+	depends on NET_OCTEONTX2 || NET_OCTEONTX3
 	bool "Command to change fec and phy-mod type"
 	help
 	   Support for change of fec and phy-mod type for some specific
 	   LMAC modes on RVU PF [CGX] network interfaces on Marvell
-	   OcteonTX2 platforms.
+	   OcteonTX2/TX3 platforms.
 
 config CMD_MDIO_DBG
 	depends on ARCH_OCTEONTX2
diff --git a/configs/octeontx3_106xx_defconfig b/configs/octeontx3_106xx_defconfig
index 7cd24ab294..27f4b0ac4c 100644
--- a/configs/octeontx3_106xx_defconfig
+++ b/configs/octeontx3_106xx_defconfig
@@ -86,6 +86,7 @@ CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_NET_OCTEONTX3=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
 CONFIG_DM_PCI_COMPAT=y
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 5ffac849d8..1f753dcee2 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -343,6 +343,15 @@ config NET_OCTEONTX2
 	  You must select Y to enable network device support for
 	  OcteonTX2 SoCs. If unsure, say n
 
+config NET_OCTEONTX3
+	bool "OcteonTX3 Ethernet support"
+	depends on ARCH_OCTEONTX3
+	help
+	  This will enable all necessary modules for OcteonTX3 network support.
+	  You must select Y to enable network device support for
+	  OcteonTX3 SoCs.
+	  If unsure, say n.
+
 config OCTEONTX_SMI
 	bool "OcteonTX SMI Device support"
 	depends on ARCH_OCTEONTX || ARCH_OCTEONTX2
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 5555594ce4..dacbbe08a9 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -64,6 +64,7 @@ obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_TSEC_ENET) += tsec.o fsl_mdio.o
 obj-$(CONFIG_NET_OCTEONTX) += octeontx/
 obj-$(CONFIG_NET_OCTEONTX2) += octeontx2/
+obj-$(CONFIG_NET_OCTEONTX3) += octeontx3/
 obj-$(CONFIG_OCTEONTX_SMI) += octeontx/smi.o
 obj-$(CONFIG_OCTEONTX2_CGX_INTF) += octeontx2/cgx_intf.o
 obj-$(CONFIG_FMAN_ENET) += fsl_mdio.o
diff --git a/drivers/net/octeontx3/Makefile b/drivers/net/octeontx3/Makefile
new file mode 100644
index 0000000000..084bb3d942
--- /dev/null
+++ b/drivers/net/octeontx3/Makefile
@@ -0,0 +1,10 @@
+#/*
+# * Copyright (C) 2020 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+
+obj-$(CONFIG_NET_OCTEONTX3) += nix_af.o rvu_af.o rvu_common.o
+
diff --git a/drivers/net/octeontx3/lmt.h b/drivers/net/octeontx3/lmt.h
new file mode 100644
index 0000000000..97777eab00
--- /dev/null
+++ b/drivers/net/octeontx3/lmt.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+/**
+ * Atomically adds a signed value to a 64 bit (aligned) memory location,
+ * and returns previous value.
+ *
+ * This version does not perform 'sync' operations to enforce memory
+ * operations.  This should only be used when there are no memory operation
+ * ordering constraints.  (This should NOT be used for reference counting -
+ * use the standard version instead.)
+ *
+ * @param ptr    address in memory to add incr to
+ * @param incr   amount to increment memory location by (signed)
+ *
+ * @return Value of memory location before increment
+ */
+static inline s64 atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
+{
+	s64 result;
+	/* Atomic add with no ordering */
+	asm volatile("ldadd %x[i], %x[r], [%[b]]"
+		     : [r] "=r" (result), "+m" (*ptr)
+		     : [i] "r" (incr), [b] "r" (ptr)
+		     : "memory");
+	return result;
+}
+
+static inline void lmt_cancel(const struct nix *nix)
+{
+	writeq(0, nix->lmt_base + LMT_LF_LMTCANCEL());
+}
+
+static inline u64 *lmt_store_ptr(struct nix *nix)
+{
+	return (u64 *)((u8 *)(nix->lmt_base) +
+				       LMT_LF_LMTLINEX(0));
+}
+
+static inline s64 lmt_submit(u64 io_address)
+{
+	s64 result = 0;
+
+	asm volatile("ldeor xzr, %x[rf],[%[rs]]"
+			: [rf] "=r"(result) : [rs] "r"(io_address));
+	return result;
+}
diff --git a/drivers/net/octeontx3/nix.h b/drivers/net/octeontx3/nix.h
new file mode 100644
index 0000000000..e26ac2789b
--- /dev/null
+++ b/drivers/net/octeontx3/nix.h
@@ -0,0 +1,355 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __NIX_H__
+#define	__NIX_H__
+
+#include <asm/arch/csrs/csrs-npa.h>
+#include <asm/arch/csrs/csrs-nix.h>
+#include "rvu.h"
+
+/** Maximum number of LMACs supported */
+#define MAX_LMAC			12
+
+/* NIX RX action operation*/
+#define NIX_RX_ACTIONOP_DROP		(0x0ull)
+#define NIX_RX_ACTIONOP_UCAST		(0x1ull)
+#define NIX_RX_ACTIONOP_UCAST_IPSEC	(0x2ull)
+#define NIX_RX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_RX_ACTIONOP_RSS		(0x4ull)
+
+/* NIX TX action operation*/
+#define NIX_TX_ACTIONOP_DROP		(0x0ull)
+#define NIX_TX_ACTIONOP_UCAST_DEFAULT	(0x1ull)
+#define NIX_TX_ACTIONOP_UCAST_CHAN	(0x2ull)
+#define NIX_TX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_TX_ACTIONOP_DROP_VIOL	(0x5ull)
+
+#define NIX_INTF_RX			0
+#define NIX_INTF_TX			1
+
+#define NIX_INTF_TYPE_CGX		0
+#define NIX_INTF_TYPE_LBK		1
+#define NIX_MAX_HW_MTU			9212
+#define NIX_MIN_HW_MTU			40
+#define MAX_MTU				1536
+
+#define NPA_POOL_COUNT			3
+#define NPA_AURA_COUNT(x)		(1ULL << ((x) + 6))
+#define NPA_POOL_RX			0ULL
+#define NPA_POOL_TX			1ULL
+#define NPA_POOL_SQB			2ULL
+#define RQ_QLEN				Q_COUNT(Q_SIZE_1K)
+#define SQ_QLEN				Q_COUNT(Q_SIZE_1K)
+#define SQB_QLEN			Q_COUNT(Q_SIZE_16)
+
+#define NIX_CQ_RX			0ULL
+#define NIX_CQ_TX			1ULL
+#define NIX_CQ_COUNT			2ULL
+#define NIX_CQE_SIZE_W16		(16 * sizeof(u64))
+#define NIX_CQE_SIZE_W64		(64 * sizeof(u64))
+
+/** Size of aura hardware context */
+#define NPA_AURA_HW_CTX_SIZE		48
+/** Size of pool hardware context */
+#define NPA_POOL_HW_CTX_SIZE		64
+
+#define NPA_DEFAULT_PF_FUNC		0xffff
+
+#define NIX_CHAN_CGX_LMAC_CHX(a, b, c)	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
+#define NIX_LINK_CGX_LMAC(a, b)		(0 + 4 * (a) + (b))
+#define NIX_LINK_LBK(a)			(12 + (a))
+#define NIX_CHAN_LBK_CHX(a, b)		(0 + 0x100 * (a) + (b))
+#define MAX_LMAC_PKIND			12
+
+/** Number of Admin queue entries */
+#define AQ_RING_SIZE	Q_COUNT(Q_SIZE_16)
+
+/** Each completion queue contains 256 entries, see NIC_CQ_CTX_S[qsize] */
+#define CQS_QSIZE			Q_SIZE_256
+#define CQ_ENTRIES			Q_COUNT(CQS_QSIZE)
+/**
+ * Each completion queue entry contains 128 bytes, see
+ * NIXX_AF_LFX_CFG[xqe_size]
+ */
+#define CQ_ENTRY_SIZE			NIX_CQE_SIZE_W16
+
+enum npa_aura_size {
+	NPA_AURA_SZ_0,
+	NPA_AURA_SZ_128,
+	NPA_AURA_SZ_256,
+	NPA_AURA_SZ_512,
+	NPA_AURA_SZ_1K,
+	NPA_AURA_SZ_2K,
+	NPA_AURA_SZ_4K,
+	NPA_AURA_SZ_8K,
+	NPA_AURA_SZ_16K,
+	NPA_AURA_SZ_32K,
+	NPA_AURA_SZ_64K,
+	NPA_AURA_SZ_128K,
+	NPA_AURA_SZ_256K,
+	NPA_AURA_SZ_512K,
+	NPA_AURA_SZ_1M,
+	NPA_AURA_SZ_MAX,
+};
+
+#define NPA_AURA_SIZE_DEFAULT		NPA_AURA_SZ_128
+
+/* NIX Transmit schedulers */
+enum nix_scheduler {
+	NIX_TXSCH_LVL_SMQ = 0x0,
+	NIX_TXSCH_LVL_MDQ = 0x0,
+	NIX_TXSCH_LVL_TL4 = 0x1,
+	NIX_TXSCH_LVL_TL3 = 0x2,
+	NIX_TXSCH_LVL_TL2 = 0x3,
+	NIX_TXSCH_LVL_TL1 = 0x4,
+	NIX_TXSCH_LVL_CNT = 0x5,
+};
+
+struct cgx;
+
+struct nix_stats {
+	u64	num_packets;
+	u64	num_bytes;
+};
+
+struct nix;
+struct lmac;
+
+struct npa_af {
+	void __iomem		*npa_af_base;
+	struct admin_queue	aq;
+	u32			aura;
+};
+
+struct npa {
+	struct npa_af		*npa_af;
+	void __iomem		*npa_base;
+	void __iomem		*npc_base;
+	void __iomem		*lmt_base;
+	/** Hardware aura context */
+	void			*aura_ctx;
+	/** Hardware pool context */
+	void			*pool_ctx[NPA_POOL_COUNT];
+	void			*pool_stack[NPA_POOL_COUNT];
+	void                    **buffers[NPA_POOL_COUNT];
+	u32                     pool_stack_pages[NPA_POOL_COUNT];
+	u32			pool_stack_pointers;
+	u32			q_len[NPA_POOL_COUNT];
+	u32			buf_size[NPA_POOL_COUNT];
+	u32			stack_pages[NPA_POOL_COUNT];
+};
+
+struct nix_af {
+	struct udevice			*dev;
+	struct nix			*lmacs[MAX_LMAC];
+	struct npa_af			*npa_af;
+	void __iomem			*nix_af_base;
+	void __iomem			*npc_af_base;
+	struct admin_queue		aq;
+	u8				num_lmacs;
+	s8				index;
+	u8				xqe_size;
+	u32				sqb_size;
+	u32				qints;
+	u32				cints;
+	u32				sq_ctx_sz;
+	u32				rq_ctx_sz;
+	u32				cq_ctx_sz;
+	u32				rsse_ctx_sz;
+	u32				cint_ctx_sz;
+	u32				qint_ctx_sz;
+};
+
+struct nix_tx_dr {
+	union nix_send_hdr_s	hdr;
+	union nix_send_sg_s	tx_sg;
+	dma_addr_t			sg1_addr;
+	dma_addr_t			sg2_addr;
+	dma_addr_t			sg3_addr;
+	u64				in_use;
+};
+
+struct nix_rx_dr {
+	union nix_cqe_hdr_s hdr;
+	union nix_rx_parse_s rx_parse;
+	union nix_rx_sg_s rx_sg;
+};
+
+struct nix {
+	struct udevice			*dev;
+	struct eth_device		*netdev;
+	struct nix_af			*nix_af;
+	struct npa			*npa;
+	struct lmac			*lmac;
+	union nix_cint_hw_s	*cint_base;
+	union nix_cq_ctx_s		*cq_ctx_base;
+	union nix_qint_hw_s	*qint_base;
+	union nix_rq_ctx_s		*rq_ctx_base;
+	union nix_rsse_s		*rss_base;
+	union nix_sq_ctx_s		*sq_ctx_base;
+	void				*cqe_base;
+	struct qmem			sq;
+	struct qmem			cq[NIX_CQ_COUNT];
+	struct qmem			rq;
+	struct qmem			rss;
+	struct qmem			cq_ints;
+	struct qmem			qints;
+	char				name[16];
+	void __iomem			*nix_base;	/** PF reg base */
+	void __iomem			*npc_base;
+	void __iomem			*lmt_base;
+	struct nix_stats		tx_stats;
+	struct nix_stats		rx_stats;
+	u32				aura;
+	int				pknd;
+	int				lf;
+	int				pf;
+	u16				pf_func;
+	u32				rq_cnt;	/** receive queues count */
+	u32				sq_cnt;	/** send queues count */
+	u32				cq_cnt;	/** completion queues count */
+	u16				rss_sz;
+	u16				sqb_size;
+	u8				rss_grps;
+	u8				xqe_sz;
+};
+
+struct nix_aq_cq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_cq_ctx_s	cq ALIGNED;
+	union nix_cq_ctx_s	mcq ALIGNED;
+};
+
+struct nix_aq_rq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_rq_ctx_s	rq ALIGNED;
+	union nix_rq_ctx_s	mrq ALIGNED;
+};
+
+struct nix_aq_sq_dis {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_sq_ctx_s	sq ALIGNED;
+	union nix_sq_ctx_s	msq ALIGNED;
+};
+
+struct nix_aq_cq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_cq_ctx_s	cq ALIGNED;
+};
+
+struct nix_aq_rq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_rq_ctx_s	rq ALIGNED;
+};
+
+struct nix_aq_sq_request {
+	union nix_aq_res_s	resp ALIGNED;
+	union nix_sq_ctx_s	sq ALIGNED;
+};
+
+static inline u64 nix_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->nix_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void nix_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+	      val);
+	writeq(val, nix_af->nix_af_base + offset);
+}
+
+static inline u64 nix_pf_reg_read(struct nix *nix, u64 offset)
+{
+	u64 val = readq(nix->nix_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+	      val);
+	return val;
+}
+
+static inline void nix_pf_reg_write(struct nix *nix, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+	      val);
+	writeq(val, nix->nix_base + offset);
+}
+
+static inline u64 npa_af_reg_read(struct npa_af *npa_af, u64 offset)
+{
+	u64 val = readq(npa_af->npa_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void npa_af_reg_write(struct npa_af *npa_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+	      val);
+	writeq(val, npa_af->npa_af_base + offset);
+}
+
+static inline u64 npc_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->npc_af_base + offset);
+
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+	      val);
+	return val;
+}
+
+static inline void npc_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+	      val);
+	writeq(val, nix_af->npc_af_base + offset);
+}
+
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+		    const union npa_aura_s *desc, u32 aura_id);
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+		    const union npa_pool_s *desc, u32 pool_id);
+int npa_af_setup(struct npa_af *npa_af);
+int npa_af_shutdown(struct npa_af *npa_af);
+int npa_lf_setup(struct nix *nix);
+int npa_lf_shutdown(struct nix *nix);
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base);
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count);
+
+int npc_lf_admin_setup(struct nix *nix);
+int npc_af_shutdown(struct nix_af *nix_af);
+
+int nix_af_setup(struct nix_af *nix_af);
+int nix_af_shutdown(struct nix_af *nix_af);
+int nix_lf_setup(struct nix *nix);
+int nix_lf_shutdown(struct nix *nix);
+struct nix *nix_lf_alloc(struct udevice *dev);
+int nix_lf_admin_setup(struct nix *nix);
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count);
+struct rvu_af *get_af(void);
+
+int nix_lf_setup_mac(struct udevice *dev);
+int nix_lf_read_rom_mac(struct udevice *dev);
+void nix_lf_halt(struct udevice *dev);
+int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len);
+int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp);
+int nix_lf_init(struct udevice *dev);
+int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len);
+
+#endif /* __NIX_H__ */
diff --git a/drivers/net/octeontx3/nix_af.c b/drivers/net/octeontx3/nix_af.c
new file mode 100644
index 0000000000..3d0916e9ab
--- /dev/null
+++ b/drivers/net/octeontx3/nix_af.c
@@ -0,0 +1,1108 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/log2.h>
+#include <asm/arch/board.h>
+#include "asm/arch/csrs/csrs-npc.h"
+#include "asm/arch/csrs/csrs-lmt.h"
+#include "nix.h"
+#include "lmt.h"
+
+/* TODO for t106 */
+#ifdef TEMP_OUT_FOR_T106
+static struct nix_aq_cq_dis cq_dis ALIGNED;
+static struct nix_aq_rq_dis rq_dis ALIGNED;
+static struct nix_aq_sq_dis sq_dis ALIGNED;
+
+/***************
+ * NPA API
+ ***************/
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+		    const union npa_aura_s *desc, u32 aura_id)
+{
+	struct npa_af *npa = nix_af->npa_af;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
+	union npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, aura_id);
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+	inst->s.cindex = aura_id;
+
+	context = (union npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+		    const union npa_pool_s *desc, u32 pool_id)
+{
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	union npa_af_aq_status aq_stat;
+	struct npa_af *npa = nix_af->npa_af;
+	union npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, pool_id);
+	aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+
+	inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.cindex = pool_id;
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+	inst->s.op = NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+
+	context = (union npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+
+	if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base)
+{
+	union npa_af_lf_rst lf_rst;
+	union npa_af_lfx_auras_cfg auras_cfg;
+	struct npa_af *npa_af = npa->npa_af;
+
+	debug("%s(%p, %d, 0x%llx)\n", __func__, npa_af, lf, aura_base);
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa_af, NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa_af, NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Set Aura size and enable caching of contexts */
+	auras_cfg.u = npa_af_reg_read(npa_af, NPA_AF_LFX_AURAS_CFG(lf));
+	auras_cfg.s.loc_aura_size = NPA_AURA_SIZE_DEFAULT; //FIXME aura_size;
+	auras_cfg.s.caching = 1;
+	auras_cfg.s.rmt_aura_size = 0;
+	auras_cfg.s.rmt_aura_offset = 0;
+	auras_cfg.s.rmt_lf = 0;
+	npa_af_reg_write(npa_af, NPA_AF_LFX_AURAS_CFG(lf), auras_cfg.u);
+	/* Configure aura HW context base */
+	npa_af_reg_write(npa_af, NPA_AF_LFX_LOC_AURAS_BASE(lf),
+			 aura_base);
+
+	return 0;
+}
+
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
+{
+	int pool_id;
+	u32 head;
+	union npa_aq_inst_s *inst;
+	union npa_aq_res_s *res;
+	struct npa_aq_pool_request {
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_pool_s p0 ALIGNED;
+		union npa_pool_s p1 ALIGNED;
+	} pool_req ALIGNED;
+	struct npa_aq_aura_request {
+		union npa_aq_res_s	resp ALIGNED;
+		union npa_aura_s a0 ALIGNED;
+		union npa_aura_s a1 ALIGNED;
+	} aura_req ALIGNED;
+	union npa_af_aq_status aq_stat;
+	union npa_af_lf_rst lf_rst;
+	struct npa_af *npa = nix_af->npa_af;
+	ulong start;
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &pool_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = NPA_AQ_CTYPE_E_POOL;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&pool_req.resp;
+
+		memset((void *)&pool_req, 0, sizeof(pool_req));
+		pool_req.p0.s.ena = 0;
+		pool_req.p1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+				pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, pool id %d) disabled\n", __func__, lf,
+		      pool_id);
+	}
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &aura_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = NPA_AQ_CTYPE_E_AURA;
+		inst->s.op = NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&aura_req.resp;
+
+		memset((void *)&aura_req, 0, sizeof(aura_req));
+		aura_req.a0.s.ena = 0;
+		aura_req.a1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d\n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+			       pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, aura id %d) disabled\n", __func__, lf,
+		      pool_id);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa, NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa, NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+#endif // TEMP_OUT_FOR_T106
+
+int npa_af_setup(struct npa_af *npa_af)
+{
+	int err;
+	union npa_af_gen_cfg npa_cfg;
+	union npa_af_ndc_cfg ndc_cfg;
+	union npa_af_aq_cfg aq_cfg;
+	union npa_af_blk_rst blk_rst;
+
+	err = rvu_aq_alloc(&npa_af->aq, Q_COUNT(AQ_SIZE),
+			   sizeof(union npa_aq_inst_s),
+			   sizeof(union npa_aq_res_s));
+	if (err) {
+		printf("%s: Error %d allocating admin queue\n", __func__, err);
+		return err;
+	}
+	debug("%s: NPA admin queue allocated at %p %llx\n", __func__,
+	      npa_af->aq.inst.base, npa_af->aq.inst.iova);
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Set little Endian */
+	npa_cfg.u = npa_af_reg_read(npa_af, NPA_AF_GEN_CFG());
+	npa_cfg.s.af_be = 0;
+	npa_af_reg_write(npa_af, NPA_AF_GEN_CFG(), npa_cfg.u);
+	/* Enable NDC cache */
+	ndc_cfg.u = npa_af_reg_read(npa_af, NPA_AF_NDC_CFG());
+	ndc_cfg.s.ndc_bypass = 0;
+	npa_af_reg_write(npa_af, NPA_AF_NDC_CFG(), ndc_cfg.u);
+	/* Set up queue size */
+	aq_cfg.u = npa_af_reg_read(npa_af, NPA_AF_AQ_CFG());
+	aq_cfg.s.qsize = AQ_SIZE;
+	npa_af_reg_write(npa_af, NPA_AF_AQ_CFG(), aq_cfg.u);
+	/* Set up queue base address */
+	npa_af_reg_write(npa_af, NPA_AF_AQ_BASE(), npa_af->aq.inst.iova);
+
+	return 0;
+}
+
+int npa_af_shutdown(struct npa_af *npa_af)
+{
+	union npa_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&npa_af->aq);
+
+	debug("%s: npa af reset --\n", __func__);
+
+	return 0;
+}
+
+/* TODO for t106 */
+#ifdef TEMP_OUT_FOR_T106
+/***************
+ * NIX API
+ ***************/
+/**
+ * Setup SMQ -> TL4 -> TL3 -> TL2 -> TL1 -> MAC mapping
+ *
+ * @param nix     Handle to setup
+ *
+ * @return 0, or negative on failure
+ */
+static int nix_af_setup_sq(struct nix *nix)
+{
+	union nixx_af_tl1x_schedule tl1_sched;
+	union nixx_af_tl2x_parent tl2_parent;
+	union nixx_af_tl3x_parent tl3_parent;
+	union nixx_af_tl3_tl2x_cfg tl3_tl2_cfg;
+	union nixx_af_tl3_tl2x_linkx_cfg tl3_tl2_link_cfg;
+	union nixx_af_tl4x_parent tl4_parent;
+	union nixx_af_tl4x_sdp_link_cfg tl4_sdp_link_cfg;
+	union nixx_af_smqx_cfg smq_cfg;
+	union nixx_af_mdqx_schedule mdq_sched;
+	union nixx_af_mdqx_parent mdq_parent;
+	union nixx_af_rx_linkx_cfg link_cfg;
+	int tl1_index = nix->lmac->link_num; /* NIX_LINK_E enum */
+	int tl2_index = tl1_index;
+	int tl3_index = tl2_index;
+	int tl4_index = tl3_index;
+	int smq_index = tl4_index;
+	struct nix_af *nix_af = nix->nix_af;
+	u64 offset = 0;
+
+	tl1_sched.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_TL1X_SCHEDULE(tl1_index));
+	tl1_sched.s.rr_quantum = MAX_MTU;
+	nix_af_reg_write(nix_af, NIXX_AF_TL1X_SCHEDULE(tl1_index),
+			 tl1_sched.u);
+
+	tl2_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL2X_PARENT(tl2_index));
+	tl2_parent.s.parent = tl1_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL2X_PARENT(tl2_index),
+			 tl2_parent.u);
+
+	tl3_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL3X_PARENT(tl3_index));
+	tl3_parent.s.parent = tl2_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL3X_PARENT(tl3_index),
+			 tl3_parent.u);
+	tl3_tl2_cfg.u = nix_af_reg_read(nix_af,
+					NIXX_AF_TL3_TL2X_CFG(tl3_index));
+	tl3_tl2_cfg.s.express = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_TL3_TL2X_CFG(tl3_index),
+			 tl3_tl2_cfg.u);
+
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	tl3_tl2_link_cfg.u = nix_af_reg_read(nix_af, offset);
+	tl3_tl2_link_cfg.s.bp_ena = 1;
+	tl3_tl2_link_cfg.s.ena = 1;
+	tl3_tl2_link_cfg.s.relchan = 0;
+	offset = NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+					    nix->lmac->link_num);
+	nix_af_reg_write(nix_af, offset, tl3_tl2_link_cfg.u);
+
+	tl4_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_TL4X_PARENT(tl4_index));
+	tl4_parent.s.parent = tl3_index;
+	nix_af_reg_write(nix_af, NIXX_AF_TL4X_PARENT(tl4_index),
+			 tl4_parent.u);
+
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	tl4_sdp_link_cfg.u = nix_af_reg_read(nix_af, offset);
+	tl4_sdp_link_cfg.s.bp_ena = 0;
+	tl4_sdp_link_cfg.s.ena = 0;
+	tl4_sdp_link_cfg.s.relchan = 0;
+	offset = NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index);
+	nix_af_reg_write(nix_af, offset, tl4_sdp_link_cfg.u);
+
+	smq_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_SMQX_CFG(smq_index));
+	smq_cfg.s.express = 0;
+	smq_cfg.s.lf = nix->lf;
+	smq_cfg.s.desc_shp_ctl_dis = 1;
+	smq_cfg.s.maxlen = MAX_MTU;
+	smq_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix_af, NIXX_AF_SMQX_CFG(smq_index), smq_cfg.u);
+
+	mdq_sched.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_MDQX_SCHEDULE(smq_index));
+	mdq_sched.s.rr_quantum = MAX_MTU;
+	offset = NIXX_AF_MDQX_SCHEDULE(smq_index);
+	nix_af_reg_write(nix_af, offset, mdq_sched.u);
+	mdq_parent.u = nix_af_reg_read(nix_af,
+				       NIXX_AF_MDQX_PARENT(smq_index));
+	mdq_parent.s.parent = tl4_index;
+	nix_af_reg_write(nix_af, NIXX_AF_MDQX_PARENT(smq_index),
+			 mdq_parent.u);
+
+	link_cfg.u = 0;
+	link_cfg.s.maxlen = NIX_MAX_HW_MTU;
+	link_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix->nix_af,
+			 NIXX_AF_RX_LINKX_CFG(nix->lmac->link_num),
+			 link_cfg.u);
+
+	return 0;
+}
+
+/**
+ * Issue a command to the NIX AF Admin Queue
+ *
+ * @param nix    nix handle
+ * @param lf     Logical function number for command
+ * @param op     Operation
+ * @param ctype  Context type
+ * @param cindex Context index
+ * @param resp   Result pointer
+ *
+ * @return	0 for success, -EBUSY on failure
+ */
+static int nix_aq_issue_command(struct nix_af *nix_af,
+				int lf,
+				int op,
+				int ctype,
+				int cindex, union nix_aq_res_s *resp)
+{
+	union nixx_af_aq_status aq_status;
+	union nix_aq_inst_s *aq_inst;
+	union nix_aq_res_s *result = resp;
+	ulong start;
+
+	debug("%s(%p, 0x%x, 0x%x, 0x%x, 0x%x, %p)\n", __func__, nix_af, lf,
+	      op, ctype, cindex, resp);
+	aq_status.u = nix_af_reg_read(nix_af, NIXX_AF_AQ_STATUS());
+	aq_inst = (union nix_aq_inst_s *)(nix_af->aq.inst.base) +
+						aq_status.s.head_ptr;
+	aq_inst->u[0] = 0;
+	aq_inst->u[1] = 0;
+	aq_inst->s.op = op;
+	aq_inst->s.ctype = ctype;
+	aq_inst->s.lf = lf;
+	aq_inst->s.cindex = cindex;
+	aq_inst->s.doneint = 0;
+	aq_inst->s.res_addr = (u64)resp;
+	debug("%s: inst@%p: 0x%llx 0x%llx\n", __func__, aq_inst,
+	      aq_inst->u[0], aq_inst->u[1]);
+	__iowmb();
+
+	/* Ring doorbell and wait for result */
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	/* Wait for completion */
+	do {
+		WATCHDOG_RESET();
+		dsb();
+	} while (result->s.compcode == 0 && get_timer(start) < 2);
+
+	if (result->s.compcode != NIX_AQ_COMP_E_GOOD) {
+		printf("NIX:AQ fail or time out with code %d after %ld ms\n",
+		       result->s.compcode, get_timer(start));
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int nix_attach_receive_queue(struct nix_af *nix_af, int lf)
+{
+	struct nix_aq_rq_request rq_req ALIGNED;
+	int err;
+
+	debug("%s(%p, %d)\n", __func__, nix_af, lf);
+
+	memset(&rq_req, 0, sizeof(struct nix_aq_rq_request));
+
+	rq_req.rq.s.ena = 1;
+	rq_req.rq.s.spb_ena = 1;
+	rq_req.rq.s.ipsech_ena = 0;
+	rq_req.rq.s.ena_wqwd = 0;
+	rq_req.rq.s.cq = NIX_CQ_RX;
+	rq_req.rq.s.substream = 0;	/* FIXME: Substream IDs? */
+	rq_req.rq.s.wqe_aura = -1;	/* No WQE aura */
+	rq_req.rq.s.spb_aura = NPA_POOL_RX;
+	rq_req.rq.s.lpb_aura = NPA_POOL_RX;
+	/* U-Boot doesn't use WQE group for anything */
+	rq_req.rq.s.pb_caching = 1;
+	rq_req.rq.s.xqe_drop_ena = 0;	/* Disable RED dropping */
+	rq_req.rq.s.spb_drop_ena = 0;
+	rq_req.rq.s.lpb_drop_ena = 0;
+	rq_req.rq.s.spb_sizem1 = (MAX_MTU / (3 * 8)) - 1; /* 512 bytes */
+	rq_req.rq.s.lpb_sizem1 = (MAX_MTU / 8) - 1;
+	rq_req.rq.s.first_skip = 0;
+	rq_req.rq.s.later_skip = 0;
+	rq_req.rq.s.xqe_imm_copy = 0;
+	rq_req.rq.s.xqe_hdr_split = 0;
+	rq_req.rq.s.xqe_drop = 0;
+	rq_req.rq.s.xqe_pass = 0;
+	rq_req.rq.s.wqe_pool_drop = 0;	/* No WQE pool */
+	rq_req.rq.s.wqe_pool_pass = 0;	/* No WQE pool */
+	rq_req.rq.s.spb_aura_drop = 255;
+	rq_req.rq.s.spb_aura_pass = 255;
+	rq_req.rq.s.spb_pool_drop = 0;
+	rq_req.rq.s.spb_pool_pass = 0;
+	rq_req.rq.s.lpb_aura_drop = 255;
+	rq_req.rq.s.lpb_aura_pass = 255;
+	rq_req.rq.s.lpb_pool_drop = 0;
+	rq_req.rq.s.lpb_pool_pass = 0;
+	rq_req.rq.s.qint_idx = 0;
+
+	err = nix_aq_issue_command(nix_af, lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_RQ,
+				   0, &rq_req.resp);
+	if (err) {
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_send_queue(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_sq_request sq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = nix_af_setup_sq(nix);
+
+	memset(&sq_req, 0, sizeof(sq_req));
+
+	sq_req.sq.s.ena = 1;
+	sq_req.sq.s.cq_ena = 1;
+	sq_req.sq.s.max_sqe_size = NIX_MAXSQESZ_E_W16;
+	sq_req.sq.s.substream = 0; // FIXME: Substream IDs?
+	sq_req.sq.s.sdp_mcast = 0;
+	sq_req.sq.s.cq = NIX_CQ_TX;
+	sq_req.sq.s.cq_limit = 0;
+	sq_req.sq.s.smq = nix->lmac->link_num; // scheduling index
+	sq_req.sq.s.sso_ena = 0;
+	sq_req.sq.s.smq_rr_quantum = MAX_MTU / 4;
+	sq_req.sq.s.default_chan = nix->lmac->chan_num;
+	sq_req.sq.s.sqe_stype = NIX_STYPE_E_STP;
+	sq_req.sq.s.qint_idx = 0;
+	sq_req.sq.s.sqb_aura = NPA_POOL_SQB;
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_SQ,
+				   0, &sq_req.resp);
+	if (err) {
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_completion_queue(struct nix *nix, int cq_idx)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_cq_request cq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	memset(&cq_req, 0, sizeof(cq_req));
+	cq_req.cq.s.ena = 1;
+	cq_req.cq.s.bpid = nix->lmac->pknd;
+	cq_req.cq.s.substream = 0;	/* FIXME: Substream IDs? */
+	cq_req.cq.s.drop_ena = 0;
+	cq_req.cq.s.caching = 1;
+	cq_req.cq.s.qsize = CQS_QSIZE;
+	cq_req.cq.s.drop = 255 * 7 / 8;
+	cq_req.cq.s.qint_idx = 0;
+	cq_req.cq.s.cint_idx = 0;
+	cq_req.cq.s.base = nix->cq[cq_idx].iova;
+	debug("%s: CQ(%d)  base %p\n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   NIX_AQ_INSTOP_E_INIT,
+				   NIX_AQ_CTYPE_E_CQ,
+				   cq_idx, &cq_req.resp);
+	if (err) {
+		printf("%s: Error requesting completion queue\n", __func__);
+		return err;
+	}
+	debug("%s: CQ(%d) allocated, base %p\n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	return 0;
+}
+
+int nix_lf_admin_setup(struct nix *nix)
+{
+	union nixx_af_lfx_rqs_cfg rqs_cfg;
+	union nixx_af_lfx_sqs_cfg sqs_cfg;
+	union nixx_af_lfx_cqs_cfg cqs_cfg;
+	union nixx_af_lfx_rss_cfg rss_cfg;
+	union nixx_af_lfx_cints_cfg cints_cfg;
+	union nixx_af_lfx_qints_cfg qints_cfg;
+	union nixx_af_lfx_rss_grpx rss_grp;
+	union nixx_af_lfx_tx_cfg2 tx_cfg2;
+	union nixx_af_lfx_cfg lfx_cfg;
+	union nixx_af_lf_rst lf_rst;
+	u32 index;
+	struct nix_af *nix_af = nix->nix_af;
+	int err;
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = nix->lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Config NIX RQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_BASE(nix->lf),
+			 (u64)nix->rq_ctx_base);
+	/* Set caching and queue count in HW */
+	rqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf));
+	rqs_cfg.s.caching = 1;
+	rqs_cfg.s.max_queuesm1 = nix->rq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RQS_CFG(nix->lf), rqs_cfg.u);
+
+	/* Config NIX SQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_BASE(nix->lf),
+			 (u64)nix->sq_ctx_base);
+	sqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf));
+	sqs_cfg.s.caching = 1;
+	sqs_cfg.s.max_queuesm1 = nix->sq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_SQS_CFG(nix->lf), sqs_cfg.u);
+
+	/* Config NIX CQ HW context and base*/
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_BASE(nix->lf),
+			 (u64)nix->cq_ctx_base);
+	cqs_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf));
+	cqs_cfg.s.caching = 1;
+	cqs_cfg.s.max_queuesm1 = nix->cq_cnt - 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CQS_CFG(nix->lf), cqs_cfg.u);
+
+	/* Config NIX RSS HW context and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_BASE(nix->lf),
+			 (u64)nix->rss_base);
+	rss_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf));
+	rss_cfg.s.ena = 1;
+	rss_cfg.s.size = ilog2(nix->rss_sz) / 256;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RSS_CFG(nix->lf), rss_cfg.u);
+
+	for (index = 0; index < nix->rss_grps; index++) {
+		rss_grp.u = 0;
+		rss_grp.s.sizem1 = 0x7;
+		rss_grp.s.offset = nix->rss_sz * index;
+		nix_af_reg_write(nix_af,
+				 NIXX_AF_LFX_RSS_GRPX(nix->lf, index),
+				 rss_grp.u);
+	}
+
+	/* Config CQints HW contexts and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_BASE(nix->lf),
+			 (u64)nix->cint_base);
+	cints_cfg.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_LFX_CINTS_CFG(nix->lf));
+	cints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CINTS_CFG(nix->lf),
+			 cints_cfg.u);
+
+	/* Config Qints HW context and base */
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_BASE(nix->lf),
+			 (u64)nix->qint_base);
+	qints_cfg.u = nix_af_reg_read(nix_af,
+				      NIXX_AF_LFX_QINTS_CFG(nix->lf));
+	qints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_QINTS_CFG(nix->lf),
+			 qints_cfg.u);
+
+	debug("%s(%p, %d, %d)\n", __func__, nix_af, nix->lf, nix->pf);
+
+	/* Enable LMTST for this NIX LF */
+	tx_cfg2.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf));
+	tx_cfg2.s.lmt_ena = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_TX_CFG2(nix->lf), tx_cfg2.u);
+
+	/* Use 16-word XQEs, write the npa pf_func number only */
+	lfx_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_LFX_CFG(nix->lf));
+	lfx_cfg.s.xqe_size = NIX_XQESZ_E_W16;
+	lfx_cfg.s.npa_pf_func = nix->pf_func;
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_CFG(nix->lf), lfx_cfg.u);
+
+	nix_af_reg_write(nix_af, NIXX_AF_LFX_RX_CFG(nix->lf), 0);
+
+	for (index = 0; index < nix->cq_cnt; index++) {
+		err = nix_attach_completion_queue(nix, index);
+		if (err) {
+			printf("%s: Error attaching completion queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->rq_cnt; index++) {
+		err = nix_attach_receive_queue(nix_af, nix->lf);
+		if (err) {
+			printf("%s: Error attaching receive queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->sq_cnt; index++) {
+		err = nix_attach_send_queue(nix);
+		if (err) {
+			printf("%s: Error attaching send queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count)
+{
+	union nixx_af_rx_sw_sync sw_sync;
+	union nixx_af_lf_rst lf_rst;
+	int index, err;
+
+	/* Flush all tx packets */
+	sw_sync.u = 0;
+	sw_sync.s.ena = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_RX_SW_SYNC(), sw_sync.u);
+
+	do {
+		sw_sync.u = nix_af_reg_read(nix_af, NIXX_AF_RX_SW_SYNC());
+		WATCHDOG_RESET();
+	} while (sw_sync.s.ena);
+
+	for (index = 0; index < rq_count; index++) {
+		memset((void *)&rq_dis, 0, sizeof(rq_dis));
+		rq_dis.rq.s.ena = 0;	/* Context */
+		rq_dis.mrq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_RQ,
+					   index, &rq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d RQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d RQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < sq_count; index++) {
+		memset((void *)&sq_dis, 0, sizeof(sq_dis));
+		sq_dis.sq.s.ena = 0;	/* Context */
+		sq_dis.msq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_SQ,
+					   index, &sq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d SQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d SQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < cq_count; index++) {
+		memset((void *)&cq_dis, 0, sizeof(cq_dis));
+		cq_dis.cq.s.ena = 0;	/* Context */
+		cq_dis.mcq.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   NIX_AQ_INSTOP_E_WRITE,
+					   NIX_AQ_CTYPE_E_CQ,
+					   index, &cq_dis.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d CQ(%d)\n",
+			       __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d CQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+
+int npc_lf_admin_setup(struct nix *nix)
+{
+	union npc_af_const af_const;
+	union npc_af_pkindx_action0 action0;
+	union npc_af_pkindx_action1 action1;
+	union npc_af_intfx_kex_cfg kex_cfg;
+	union npc_af_intfx_miss_stat_act intfx_stat_act;
+	union npc_af_mcamex_bankx_camx_intf camx_intf;
+	union npc_af_mcamex_bankx_camx_w0 camx_w0;
+	union npc_af_mcamex_bankx_cfg bankx_cfg;
+	union npc_af_mcamex_bankx_stat_act mcamex_stat_act;
+
+	union nix_rx_action_s rx_action;
+	union nix_tx_action_s tx_action;
+
+	struct nix_af *nix_af = nix->nix_af;
+	u32 kpus;
+	int pkind = nix->lmac->link_num;
+	int index;
+	u64 offset;
+
+	debug("%s(%p, pkind 0x%x)\n", __func__, nix_af, pkind);
+	af_const.u = npc_af_reg_read(nix_af, NPC_AF_CONST());
+	kpus = af_const.s.kpus;
+
+	action0.u = 0;
+	action0.s.parse_done = 1;
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION0(pkind), action0.u);
+
+	action1.u = 0;
+	npc_af_reg_write(nix_af, NPC_AF_PKINDX_ACTION1(pkind), action1.u);
+
+	kex_cfg.u = 0;
+	kex_cfg.s.keyw = NPC_MCAMKEYW_E_X1;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_RX(0)),
+			 kex_cfg.u);
+
+	/* HW Issue */
+	kex_cfg.u = 0;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_KEX_CFG(NPC_INTF_E_NIXX_TX(0)),
+			 kex_cfg.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = ~NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 0),
+			 camx_intf.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 1),
+			 camx_intf.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = ~(nix->lmac->chan_num) & (~((~0x0ull) << 12));
+	debug("NPC LF ADMIN camx_w0.u %llx\n", camx_w0.u);
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 0),
+			 camx_w0.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = nix->lmac->chan_num;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 1),
+			 camx_w0.u);
+
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 0),
+			 0);
+
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 1),
+			 0);
+
+	/* Enable stats for NPC INTF RX */
+	mcamex_stat_act.u = 0;
+	mcamex_stat_act.s.ena = 1;
+	mcamex_stat_act.s.stat_sel = pkind;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_MCAMEX_BANKX_STAT_ACT(pkind, 0),
+			 mcamex_stat_act.u);
+	intfx_stat_act.u = 0;
+	intfx_stat_act.s.ena = 1;
+	intfx_stat_act.s.stat_sel = 16;
+	offset = NPC_AF_INTFX_MISS_STAT_ACT(NPC_INTF_E_NIXX_RX(0));
+	npc_af_reg_write(nix_af, offset, intfx_stat_act.u);
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = NIX_RX_ACTIONOP_E_UCAST;
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_ACTION(pkind, 0),
+			 rx_action.u);
+
+	for (index = 0; index < kpus; index++)
+		npc_af_reg_write(nix_af, NPC_AF_KPUX_CFG(index), 0);
+
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = NIX_RX_ACTIONOP_E_DROP;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_RX(0)),
+			 rx_action.u);
+	bankx_cfg.u = 0;
+	bankx_cfg.s.ena = 1;
+	npc_af_reg_write(nix_af, NPC_AF_MCAMEX_BANKX_CFG(pkind, 0),
+			 bankx_cfg.u);
+
+	tx_action.u = 0;
+	tx_action.s.op = NIX_TX_ACTIONOP_E_UCAST_DEFAULT;
+	npc_af_reg_write(nix_af,
+			 NPC_AF_INTFX_MISS_ACT(NPC_INTF_E_NIXX_TX(0)),
+			 tx_action.u);
+
+#ifdef DEBUG
+	/* Enable debug capture on RX intf */
+	npc_af_reg_write(nix_af, NPC_AF_DBG_CTL(), 0x4);
+#endif
+
+	return 0;
+}
+#endif // TEMP_OUT_FOR_T106
+
+int npc_af_shutdown(struct nix_af *nix_af)
+{
+	union npc_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npc_af_reg_write(nix_af, NPC_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npc_af_reg_read(nix_af, NPC_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	debug("%s: npc af reset --\n", __func__);
+
+	return 0;
+}
+
+int nix_af_setup(struct nix_af *nix_af)
+{
+	int err;
+	union nixx_af_const2 af_const2;
+	union nixx_af_const3 af_const3;
+	union nixx_af_sq_const sq_const;
+	union nixx_af_cfg af_cfg;
+	union nixx_af_status af_status;
+	union nixx_af_ndc_cfg ndc_cfg;
+	union nixx_af_aq_cfg aq_cfg;
+	union nixx_af_blk_rst blk_rst;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = rvu_aq_alloc(&nix_af->aq, Q_COUNT(AQ_SIZE),
+			   sizeof(union nix_aq_inst_s),
+			   sizeof(union nix_aq_res_s));
+	if (err) {
+		printf("%s: Error allocating nix admin queue\n", __func__);
+		return err;
+	}
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Put in LE mode */
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	if (af_cfg.s.force_cond_clk_en || af_cfg.s.calibrate_x2p ||
+	    af_cfg.s.force_intf_clk_en) {
+		printf("%s: Error: Invalid NIX_AF_CFG value 0x%llx\n",
+		       __func__, af_cfg.u);
+		return -1;
+	}
+	af_cfg.s.af_be = 0;
+	af_cfg.u |= 0x5E;	/* HW Issue */
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Perform Calibration */
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Wait for calibration to complete */
+	do {
+		af_status.u = nix_af_reg_read(nix_af, NIXX_AF_STATUS());
+		WATCHDOG_RESET();
+	} while (af_status.s.calibrate_done == 0);
+
+	af_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_CFG(), af_cfg.u);
+
+	/* Enable NDC cache */
+	ndc_cfg.u = nix_af_reg_read(nix_af, NIXX_AF_NDC_CFG());
+	ndc_cfg.s.ndc_ign_pois = 0;
+	ndc_cfg.s.byp_sq = 0;
+	ndc_cfg.s.byp_sqb = 0;
+	ndc_cfg.s.byp_cqs = 0;
+	ndc_cfg.s.byp_cints = 0;
+	ndc_cfg.s.byp_dyno = 0;
+	ndc_cfg.s.byp_mce = 0;
+	ndc_cfg.s.byp_rqc = 0;
+	ndc_cfg.s.byp_rsse = 0;
+	ndc_cfg.s.byp_mc_data = 0;
+	ndc_cfg.s.byp_mc_wqe = 0;
+	ndc_cfg.s.byp_mr_data = 0;
+	ndc_cfg.s.byp_mr_wqe = 0;
+	ndc_cfg.s.byp_qints = 0;
+	nix_af_reg_write(nix_af, NIXX_AF_NDC_CFG(), ndc_cfg.u);
+
+	/* Set up queue size */
+	aq_cfg.u = 0;
+	aq_cfg.s.qsize = AQ_SIZE;
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_CFG(), aq_cfg.u);
+
+	/* Set up queue base address */
+	nix_af_reg_write(nix_af, NIXX_AF_AQ_BASE(), nix_af->aq.inst.iova);
+
+	af_const3.u = nix_af_reg_read(nix_af, NIXX_AF_CONST3());
+	af_const2.u = nix_af_reg_read(nix_af, NIXX_AF_CONST2());
+	sq_const.u = nix_af_reg_read(nix_af, NIXX_AF_SQ_CONST());
+	nix_af->rq_ctx_sz = 1ULL << af_const3.s.rq_ctx_log2bytes;
+	nix_af->sq_ctx_sz = 1ULL << af_const3.s.sq_ctx_log2bytes;
+	nix_af->cq_ctx_sz = 1ULL << af_const3.s.cq_ctx_log2bytes;
+	nix_af->rsse_ctx_sz = 1ULL << af_const3.s.rsse_log2bytes;
+	nix_af->qints = af_const2.s.qints;
+	nix_af->cints = af_const2.s.cints;
+	nix_af->cint_ctx_sz = 1ULL << af_const3.s.cint_log2bytes;
+	nix_af->qint_ctx_sz = 1ULL << af_const3.s.qint_log2bytes;
+	nix_af->sqb_size = sq_const.s.sqb_size;
+
+	return 0;
+}
+
+int nix_af_shutdown(struct nix_af *nix_af)
+{
+	union nixx_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&nix_af->aq);
+
+	debug("%s: nix af reset --\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/net/octeontx3/rvu.h b/drivers/net/octeontx3/rvu.h
new file mode 100644
index 0000000000..b08a747db5
--- /dev/null
+++ b/drivers/net/octeontx3/rvu.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier:    GPL-2.0
+ *
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef __RVU_H__
+#define __RVU_H__
+
+#include <asm/arch/csrs/csrs-rvu.h>
+
+#define ALIGNED		__aligned(CONFIG_SYS_CACHELINE_SIZE)
+
+/* PCI device IDs */
+#define	PCI_DEVID_OCTEONTX2_CGX			0xA059
+#define	PCI_DEVID_OCTEONTX2_RVU_AF		0xA065
+#define	PCI_DEVID_OCTEONTX2_RVU_PF		0xA063
+#define	PCI_DEVID_OCTEONTX2_RVU_VF		0xA064
+
+#define Q_SIZE_16		0ULL /* 16 entries */
+#define Q_SIZE_64		1ULL /* 64 entries */
+#define Q_SIZE_256		2ULL
+#define Q_SIZE_1K		3ULL
+#define Q_SIZE_4K		4ULL
+#define Q_SIZE_16K		5ULL
+#define Q_SIZE_64K		6ULL
+#define Q_SIZE_256K		7ULL
+#define Q_SIZE_1M		8ULL /* Million entries */
+#define Q_SIZE_MIN		Q_SIZE_16
+#define Q_SIZE_MAX		Q_SIZE_1M
+
+#define Q_COUNT(x)		(16ULL << (2 * (x)))
+#define Q_SIZE(x, n)		((ilog2(x) - (n)) / 2)
+
+/* Admin queue info */
+
+/* Since we intend to add only one instruction at a time,
+ * keep queue size to it's minimum.
+ */
+#define AQ_SIZE			Q_SIZE_16
+/* HW head & tail pointer mask */
+#define AQ_PTR_MASK		0xFFFFF
+
+struct qmem {
+	void		*base;
+	dma_addr_t	iova;
+	size_t		alloc_sz;
+	u32		qsize;
+	u8		entry_sz;
+};
+
+struct admin_queue {
+	struct qmem inst;
+	struct qmem res;
+};
+
+struct rvu_af {
+	struct udevice *dev;
+	void __iomem *af_base;
+	struct nix_af *nix_af;
+};
+
+struct rvu_pf {
+	struct udevice *dev;
+	struct udevice *afdev;
+	void __iomem *pf_base;
+	struct nix *nix;
+	u8 pfid;
+	int nix_lfid;
+	int npa_lfid;
+};
+
+/**
+ * Store 128 bit value
+ *
+ * @param[out]	dest	pointer to destination address
+ * @param	val0	first 64 bits to write
+ * @param	val1	second 64 bits to write
+ */
+static inline void st128(void *dest, u64 val0, u64 val1)
+{
+	__asm__ __volatile__("stp %x[x0], %x[x1], [%[pm]]" :
+		: [x0]"r"(val0), [x1]"r"(val1), [pm]"r"(dest)
+		: "memory");
+}
+
+/**
+ * Load 128 bit value
+ *
+ * @param[in]	source		pointer to 128 bits of data to load
+ * @param[out]	val0		first 64 bits of data
+ * @param[out]	val1		second 64 bits of data
+ */
+static inline void ld128(const u64 *src, u64 *val0, u64 *val1)
+{
+	__asm__ __volatile__ ("ldp %x[x0], %x[x1], [%[pm]]" :
+		 : [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
+}
+
+void qmem_free(struct qmem *q);
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz);
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size);
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq);
+
+void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid);
+
+#endif /* __RVU_H__ */
+
diff --git a/drivers/net/octeontx3/rvu_af.c b/drivers/net/octeontx3/rvu_af.c
new file mode 100644
index 0000000000..e8c9d12939
--- /dev/null
+++ b/drivers/net/octeontx3/rvu_af.c
@@ -0,0 +1,172 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/io.h>
+#include <asm/arch/board.h>
+#include <asm/arch/csrs/csrs-npa.h>
+#include "nix.h"
+
+struct udevice *rvu_af_dev;
+
+inline struct rvu_af *get_af(void)
+{
+	return rvu_af_dev ? dev_get_priv(rvu_af_dev) : NULL;
+}
+
+void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid)
+{
+	union nixx_af_rvu_lf_cfg_debug nix_lf_dbg;
+	union npa_af_rvu_lf_cfg_debug npa_lf_dbg;
+	union rvu_pf_func_s pf_func;
+	struct rvu_af *af = dev_get_priv(rvu_af_dev);
+	struct nix_af *nix_af = af->nix_af;
+
+	pf_func.u = 0;
+	pf_func.s.pf = pf;
+
+	nix_lf_dbg.u = 0;
+	nix_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	nix_lf_dbg.s.exec = 1;
+	nix_af_reg_write(nix_af, NIXX_AF_RVU_LF_CFG_DEBUG(),
+			 nix_lf_dbg.u);
+	do {
+		nix_lf_dbg.u = nix_af_reg_read(nix_af,
+					       NIXX_AF_RVU_LF_CFG_DEBUG());
+	} while (nix_lf_dbg.s.exec);
+
+	if (nix_lf_dbg.s.lf_valid)
+		*nixid = nix_lf_dbg.s.lf;
+
+	debug("%s: nix lf_valid %d lf %d nixid %d\n", __func__,
+	      nix_lf_dbg.s.lf_valid, nix_lf_dbg.s.lf, *nixid);
+
+	npa_lf_dbg.u = 0;
+	npa_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	npa_lf_dbg.s.exec = 1;
+	npa_af_reg_write(nix_af->npa_af, NPA_AF_RVU_LF_CFG_DEBUG(),
+			 npa_lf_dbg.u);
+	do {
+		npa_lf_dbg.u = npa_af_reg_read(nix_af->npa_af,
+					       NPA_AF_RVU_LF_CFG_DEBUG());
+	} while (npa_lf_dbg.s.exec);
+
+	if (npa_lf_dbg.s.lf_valid)
+		*npaid = npa_lf_dbg.s.lf;
+	debug("%s: npa lf_valid %d lf %d npaid %d\n", __func__,
+	      npa_lf_dbg.s.lf_valid, npa_lf_dbg.s.lf, *npaid);
+}
+
+struct nix_af *rvu_af_init(struct rvu_af *rvu_af)
+{
+	struct nix_af *nix_af;
+	union rvu_af_addr_s block_addr;
+	int err;
+
+	nix_af = (struct nix_af *)calloc(1, sizeof(struct nix_af));
+	if (!nix_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	nix_af->dev = rvu_af->dev;
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NIXX(0);
+	nix_af->nix_af_base = rvu_af->af_base + block_addr.u;
+
+	nix_af->npa_af = (struct npa_af *)calloc(1, sizeof(struct npa_af));
+	if (!nix_af->npa_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPA;
+	nix_af->npa_af->npa_af_base = rvu_af->af_base + block_addr.u;
+
+	block_addr.u = 0;
+	block_addr.s.block = RVU_BLOCK_ADDR_E_NPC;
+	nix_af->npc_af_base = rvu_af->af_base + block_addr.u;
+
+	debug("%s: Setting up npa admin\n", __func__);
+	err = npa_af_setup(nix_af->npa_af);
+	if (err) {
+		printf("%s: Error %d setting up NPA admin\n", __func__, err);
+		goto error;
+	}
+	debug("%s: Setting up nix af\n", __func__);
+	err = nix_af_setup(nix_af);
+	if (err) {
+		printf("%s: Error %d setting up NIX admin\n", __func__, err);
+		goto error;
+	}
+	debug("%s: nix_af: %p\n", __func__, nix_af);
+	return nix_af;
+
+error:
+	if (nix_af->npa_af) {
+		free(nix_af->npa_af);
+		memset(nix_af, 0, sizeof(*nix_af));
+	}
+	if (nix_af)
+		free(nix_af);
+	return NULL;
+}
+
+int rvu_af_probe(struct udevice *dev)
+{
+	struct rvu_af *af_ptr = dev_get_priv(dev);
+
+	af_ptr->af_base = dm_pci_map_bar(dev, PCI_BASE_ADDRESS_0,
+					 PCI_REGION_MEM);
+	debug("%s RVU AF BAR %p\n", __func__, af_ptr->af_base);
+	af_ptr->dev = dev;
+	rvu_af_dev = dev;
+
+	af_ptr->nix_af = rvu_af_init(af_ptr);
+	if (!af_ptr->nix_af) {
+		printf("%s: Error: could not initialize NIX AF\n", __func__);
+		return -1;
+	}
+	debug("%s: Done\n", __func__);
+
+	return 0;
+}
+
+int rvu_af_remove(struct udevice *dev)
+{
+	struct rvu_af *rvu_af = dev_get_priv(dev);
+
+	nix_af_shutdown(rvu_af->nix_af);
+	npa_af_shutdown(rvu_af->nix_af->npa_af);
+	npc_af_shutdown(rvu_af->nix_af);
+
+	debug("%s: rvu af down --\n", __func__);
+	return 0;
+}
+
+U_BOOT_DRIVER(rvu_af) = {
+	.name   = "rvu_af",
+	.id     = UCLASS_MISC,
+	.probe  = rvu_af_probe,
+	.remove = rvu_af_remove,
+	.priv_auto_alloc_size = sizeof(struct rvu_af),
+};
+
+static struct pci_device_id rvu_af_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(rvu_af, rvu_af_supported);
diff --git a/drivers/net/octeontx3/rvu_common.c b/drivers/net/octeontx3/rvu_common.c
new file mode 100644
index 0000000000..02ad27bebe
--- /dev/null
+++ b/drivers/net/octeontx3/rvu_common.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier:    GPL-2.0
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+
+#include "rvu.h"
+
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz)
+{
+	q->base = memalign(CONFIG_SYS_CACHELINE_SIZE, qsize * entry_sz);
+	if (!q->base)
+		return -ENOMEM;
+	q->entry_sz = entry_sz;
+	q->qsize = qsize;
+	q->alloc_sz = (size_t)qsize * entry_sz;
+	q->iova = (dma_addr_t)(q->base);
+	debug("NIX: qmem alloc for (%d * %d = %ld bytes) at %p\n",
+	      q->qsize, q->entry_sz, q->alloc_sz, q->base);
+	return 0;
+}
+
+void qmem_free(struct qmem *q)
+{
+	if (q->base)
+		free(q->base);
+	memset(q, 0, sizeof(*q));
+}
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned int qsize,
+		 size_t inst_size, size_t res_size)
+{
+	int err;
+
+	err = qmem_alloc(&aq->inst, qsize, inst_size);
+	if (err)
+		return err;
+	err = qmem_alloc(&aq->res, qsize, res_size);
+	if (err)
+		qmem_free(&aq->inst);
+
+	return err;
+}
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq)
+{
+	qmem_free(&aq->inst);
+	qmem_free(&aq->res);
+	memset(aq, 0, sizeof(*aq));
+}
-- 
2.29.0

